webpackJsonp([3],{

/***/ 395:
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(Buffer) {/**
 * @license
 * Copyright 2016 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// Polyfill

// Required on IE 11, Android Browser before 5.1.
if ( ! Math.trunc ) {
  Math.trunc = function trunc(v) {
    return v > 0 ? Math.floor(v) : Math.ceil(v);
  };
}

// Required on IE 11, Android Browser (at least to 5.1).
if ( ! Array.from ) {
  /** Turn array-like objects into real arrays. **/
  Array.from = function(a) {
    var b = new Array(a.length);
    for ( var i = 0 ; i < a.length ; i++ ) b[i] = a[i];
    return b;
  }
}

// Required on IE 11, Android Browser (at least to 5.1).
if ( ! Array.prototype.find ) {
  Array.prototype.find = function(predicate) {
    if ( this === null ) {
      throw new TypeError('Array.prototype.find called on null or undefined');
    }
    if ( typeof predicate !== 'function' ) {
      throw new TypeError('predicate must be a function');
    }
    var list    = Object(this);
    var length  = list.length >>> 0;
    var thisArg = arguments[1];
    var value;

    for ( var i = 0 ; i < length ; i++ ) {
      value = list[i];
      if ( predicate.call(thisArg, value, i, list) ) return value;
    }
    return undefined;
  };
}

// Required on IE 11, Android Browser (at least to 5.1).
if ( ! String.prototype.endsWith ) {
  // Official polyfill
  String.prototype.endsWith = function(searchString, position) {
      var subjectString = this.toString();
      if ( typeof position !== 'number' ||
          ! isFinite(position) ||
          Math.floor(position) !== position ||
          position > subjectString.length ) {
        position = subjectString.length;
      }
      position -= searchString.length;
      var lastIndex = subjectString.indexOf(searchString, position);
      return lastIndex !== -1 && lastIndex === position;
  };
}

// Required on IE 11, Android Browser (at least to 5.1).
if ( ! String.prototype.startsWith ) {
  String.prototype.startsWith = function(str, pos) {
    return this.indexOf(str) === 0;
  };
}

// Required for IE 11.
if ( ! Number.isInteger ) {
  Number.isInteger = function(value) {
    return typeof value === 'number' &&
        isFinite(value) &&
        Math.floor(value) === value;
  }
}

if ( ! Object.values ) {
  Object.values = function(obj) {
    return Object.keys(obj).map(function(k) { return obj[k]; });
  };
}

// Required for IE 11.
if( ! Object.is ) {
  // From ES6 specs, and also:
  // https://gist.github.com/matthewp/2036428
  Object.is = function(x, y) {
    if (x === y) {
      // 0 === -0, but they are not identical
      return x !== 0 || 1 / x === 1 / y;
    }

    // NaN !== NaN, but they are identical.
    // NaNs are the only non-reflexive value, i.e., if x !== x,
    // then x is a NaN.
    // isNaN is broken: it converts its argument to number, so
    // isNaN("foo") => true
    return x !== x && y !== y;
  };
}
/**
 * @license
 * Copyright 2016 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Top-Level of foam package
 */
foam = {
  isServer: typeof window === 'undefined',
  core:     {},
  next$UID: (function() {
    /* Return a unique id. */
    var id = 1;
    return function next$UID() { return id++; };
  })()
};


/** Setup nodejs-like 'global' on web */
if ( ! foam.isServer ) global = window;

global.SUPPRESSED_WARNINGS = global.SUPPRESSED_WARNINGS || {};
global.suppressWarnings = function (a) {

  a.forEach(function(key) {
    SUPPRESSED_WARNINGS[key] = true;
  })
}

suppressWarnings([ `Skipping constant PARSE_JSON with unknown type.`,
  `Property foam.core.FObjectProperty.of "value" hidden by "getter"`,
  `Unknown property foam.nanos.menu.DAOMenu.XXXsummaryView: [object Object]`,
  `Import "scriptDAO" already exists in ancestor class of foam.nanos.test.Test.`,
  `Unknown property foam.core.Model.javaType: foam.core.PropertyInfo`,
  `Property foam.dao.index.Index.nodeClass "factory" hidden by "getter"`
]);

Object.defineProperty(
  Object.prototype,
  '$UID',
  {
    get: function() {
      if ( ! Object.hasOwnProperty.call(this, '$UID__') &&
           ! Object.isFrozen(this) ) {
        Object.defineProperty(
            this,
            '$UID__',
            {value: foam.next$UID(), enumerable: false});
      }
      return this.$UID__;
    },
    enumerable: false
  }
);


/**
 * Define an assertion function that is significantly faster and more
 * compatible than console.assert.  Also allows us to turn off assertions
 * in a production scenario.
 *
 * Usage of console.assert directly is slow, and not all platforms agree
 * on what to do with extra arguments, some ignore them, some join them
 * to the message.
 */
foam.assert = function assert(cond) {
  if ( ! cond ) {
//    throw new Error(Array.from(arguments).slice(1).join(' '));
    console.assert(false, Array.from(arguments).slice(1).join(' '));

  }

  return cond;
};


/**
 * Creates a small library in the foam package. A LIB is a collection of
 * constants and static methods.
 * <pre>
foam.LIB({
  name: 'network',
  constants: {
    PORT: 4000
  },
  methods: [ function sendPacket() { ... }  ]
});
</pre>
Produces <code>foam.network</code>:
<pre>
console.log(foam.network.PORT); // outputs 4000
foam.network.sendPacket();
</pre>
 * @method LIB
 * @memberof module:foam
 */
foam.LIB = function LIB(model) {
  var root = global;
  var path = model.name.split('.');
  var i;

  for ( i = 0 ; i < path.length ; i++ ) {
    root = root[path[i]] || ( root[path[i]] = {} );
  }

  // During boot, keep a list of created LIBs
  if ( global.foam.__LIBS__ ) global.foam.__LIBS__[model.name] = root;

  if ( model.constants ) {
    foam.assert(
      typeof model.constants === 'object',
      'Constants must be a map.');

    for ( var key in model.constants ) root[key] = model.constants[key];
  }

  if ( model.methods ) {
    foam.assert(Array.isArray(model.methods), 'Methods must be an array.');

    for ( i = 0 ; i < model.methods.length ; i++ ) {
      var m = model.methods[i];

      foam.assert(
        typeof m === 'object' || typeof m === 'function',
        'Methods must be a map of a function');

      foam.assert(
         typeof m !== 'object' || typeof m.code === 'function',
        'Methods must have a code key which is a function');

      var name = m.name || foam.Function.getName(m);
      foam.assert(name, 'Methods must be named with a non-empty string');

      root[name] = m.code || m;
    }
  }
};
global.foam.__LIBS__ = {};
/**
 * @license
 * Copyright 2016 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// This must be declared as the first foam.LIB() using { name: ..., code: ... }
// method syntax because foam.LIB() may invoke foam.Function.getName() on
// methods declared using function methodName(...) { ... }.
foam.LIB({
  name: 'foam.Function',

  methods: [
    {
      name: 'getName',
      code: (function named() {}).name === 'named' ?
          function(method) { return method.name; } :
          function(method) {
            if (typeof method !== 'function') return method.name;

            // IE11 does not support named functions. Extract name with
            // f.toString().
            var match = method.toString().
                match(/^function\s+([A-Za-z_$][0-9A-Za-z_$]*)\s*\(/);
            foam.assert(match, 'Unable to deduce method name from function');
            return match[1];
          }
    }
  ]
});

/**
  Rather than extending built-in prototypes, we create flyweight versions.

  This has a number of advantages:
  1. It avoids conflicts with other libraries which might also extend built-in
     types with methods with the same names but different semantics.
  2. It is >10X faster (in V8) to call a flyweight method than a Method added
     to the prototypes of String or Number. This is because calling an added
     method on those types promotes the object from a primitive string or number
     to a String or Number object.  Creating the object takes time and creates a
     new object that will need to be GC'ed.
  3. It lets us effectively add methods to built-in special values like
     true, false, null, and undefined. This avoids the need for null-pointer
     checks.
  4. It avoids the proliferation of large ===/typeof/isInstance/instanceof blocks
     throughout the rest of the code.
  5. It provides a consistent method for checking an object's type, since each
     type flyweight has an .isInstance() method which abstracts the underlying detection
     mechanism.
  6. It makes the future implementation of multi-methods much easier.
*/

/**
 * Each of these flyweight types follows a standard interface.
 *
 * <pre>
 * interface Type {
 *   // Returns true if the given object is of this type.
 *   // example: foam.String.isInstance('hello') -> true
 *   isInstance(o) -> Boolean
 *
 *   // Returns a deep clone of o, if the type supports it.
 *   clone(o);
 *
 *   // Returns true if a and b are equivalent.
 *   equals(a, b) -> Boolean
 *
 *   // Returns -1, 0 or 1 as a comparsion of the two types.
 *   // -1 means that 'a' is considered smaller that 'b'
 *   // 0 means that and 'a' and 'b' are considered equivalent
 *   // 1 means that 'a' is considered larger than 'b'
 *   compare(a, b) -> Int
 *
 *   // Returns a hash of 'a' useful for hash tables
 *   hashCode(a) -> Int
 *
 *   // Returns true if the two values are the same instance
 *   // or the same value for primitive types.
 *   is(a, b) -> Boolean
 * }
 */

foam.LIB({
  name: 'foam.Undefined',
  methods: [
    function isInstance(o) { return o === undefined; },
    function is(a, b) { return b === undefined; },
    function clone(o) { return o; },
    function equals(_, b) { return b === undefined; },
    function compare(_, b) { return b === undefined ? 0 : 1; },
    function hashCode() { return -2; }
  ]
});


foam.LIB({
  name: 'foam.Null',
  methods: [
    function isInstance(o) { return o === null; },
    function is(a, b) { return b === null; },
    function clone(o) { return o; },
    function equals(_, b) { return b === null; },
    function compare(_, b) { return b === null ? 0 : 1; },
    function hashCode() { return -3; }
  ]
});


foam.LIB({
  name: 'foam.Boolean',
  methods: [
    function isInstance(o) { return typeof o === 'boolean'; },
    function is(a, b) { return a === b; },
    function clone(o) { return o; },
    function equals(a, b) { return a === b; },
    function compare(a, b) {
      if ( ! foam.Boolean.isInstance(b) ) return 1;
      return a ? (b ? 0 : 1) : (b ? -1 : 0);
    },
    function hashCode(o) { return o ? 1 : -1; }
  ]
});


foam.LIB({
  name: 'foam.Function',
  methods: [
    function isInstance(o) { return typeof o === 'function'; },
    function is(a, b) { return a === b },
    function clone(o) { return o; },
    function equals(a, b) { return b ? a.toString() === b.toString() : false; },
    function compare(a, b) {
      if ( ! foam.Function.isInstance(b) ) return 1;
      return b ? foam.String.compare(a.toString(), b.toString()) :  1;
    },
    function hashCode(o) { return foam.String.hashCode(o.toString()); },

    /* istanbul ignore next */
    function bind(f, that, a1, a2, a3, a4) {
      /**
       * Faster than Function.prototype.bind
       */
      switch ( arguments.length ) {
        case 1:
          console.error('No arguments given to bind to.');
          break;
        case 2: return function() { return f.apply(that, arguments); };
        case 3: return function(b1, b2, b3, b4) {
          switch ( arguments.length ) {
            case 0: return f.call(that, a1);
            case 1: return f.call(that, a1, b1);
            case 2: return f.call(that, a1, b1, b2);
            case 3: return f.call(that, a1, b1, b2, b3);
            case 4: return f.call(that, a1, b1, b2, b3, b4);
          }
        };
        case 4: return function(b1, b2, b3, b4) {
          switch ( arguments.length ) {
            case 0: return f.call(that, a1, a2);
            case 1: return f.call(that, a1, a2, b1);
            case 2: return f.call(that, a1, a2, b1, b2);
            case 3: return f.call(that, a1, a2, b1, b2, b3);
            case 4: return f.call(that, a1, a2, b1, b2, b3, b4);
          }
        };
        case 5: return function(b1, b2, b3, b4) {
          switch ( arguments.length ) {
            case 0: return f.call(that, a1, a2, a3);
            case 1: return f.call(that, a1, a2, a3, b1);
            case 2: return f.call(that, a1, a2, a3, b1, b2);
            case 3: return f.call(that, a1, a2, a3, b1, b2, b3);
            case 4: return f.call(that, a1, a2, a3, b1, b2, b3, b4);
          }
        };
        case 6: return function(b1, b2, b3, b4) {
          switch ( arguments.length ) {
            case 0: return f.call(that, a1, a2, a3, a4);
            case 1: return f.call(that, a1, a2, a3, a4, b1);
            case 2: return f.call(that, a1, a2, a3, a4, b1, b2);
            case 3: return f.call(that, a1, a2, a3, a4, b1, b2, b3);
            case 4: return f.call(that, a1, a2, a3, a4, b1, b2, b3, b4);
          }
        };
      }

      console.error('Attempt to foam.Function.bind more than 4 arguments.');
    },

    /**
     * Decorates the function 'f' to cache the return value of 'f' when
     * called in the future. Also known as a 'thunk'.
     */
    function memoize0(/* Function */ f) {
      var set = false, cache;
      var ret = foam.Function.setName(
          function() {
            if ( ! set ) {
              set = true;
              cache = f();
            }
            return cache;
          },
          'memoize0(' + f.name + ')');
      ret.toString = function() { return f.toString(); };
      return ret;
    },

    /**
     * Decorates the function 'f' to cache the return value of 'f' when called
     * with a particular value for its first argument.
     */
    function memoize1(/* Function */ f) {
      var cache = {}, nullCache, undefinedCache;
      var ret = foam.Function.setName(
          function(key) {
            foam.assert(
                arguments.length === 1,
                'Memoize1\'ed functions must take exactly one argument.');

            var mKey =
                key === null      ? '___null___'      :
                key === undefined ? '___undefined___' :
                key ;

            if ( ! cache.hasOwnProperty(mKey) ) cache[mKey] = f.call(this, key);

            return cache[mKey];
          },
          'memoize1(' + f.name + ')');
        ret.toString = function() { return f.toString(); };
        return ret;
    },

    /**
     * Set a function's name for improved debugging and profiling
     *
     * Returns the given function.
     */
    function setName(f, name) {
      Object.defineProperty(f, 'name', { value: name, configurable: true });
      return f;
    },

    /** Convenience method to append 'arguments' onto a real array **/
    function appendArguments(a, args, start) {
      start = start || 0;
      for ( var i = start ; i < args.length ; i++ ) a.push(args[i]);
      return a;
    },

    /** Finds the function(...) declaration arguments part. Strips newlines. */
    function argsStr(f) {
      var str = f.
          toString().
          replace(/(\r\n|\n|\r)/gm,'');
      var isArrowFunction = !/(async )?function/.test(str);

      var match = isArrowFunction ?
          // (...args...) => ...
          // or
          // arg => ...
          match = str.match(/^(\(([^)]*)\)[^=]*|([^=]+))=>/) :
          // function (...args...) { ...body... }
          match = str.match(/^(async )?function(\s+[_$\w]+|\s*)\((.*?)\)/);

      if ( ! match ) {
        /* istanbul ignore next */
        throw new TypeError("foam.Function.argsStr could not parse input function:\n" + ( f ? f.toString() : 'undefined' ) );
      }

      return isArrowFunction ? (match[2] || match[1] || '') : (match[3] || '');
    },

    function argNames(f) {
      /**
       * Return a function's arguments as an array.
       * Ex. argNames(function(a,b) {...}) === ['a', 'b']
       **/
      var args = foam.Function.argsStr(f);
      args += ',';

      var ret = [];
      // [ ws /* anything */ ] ws [...]arg_name ws [ /* anything */ ],
      var argMatcher = /(\s*\/\*.*?\*\/)?\s*((?:\.\.\.)?[\w_$]+)\s*(\/\*.*?\*\/)?\s*\,+/g;
      var typeMatch;
      while ( ( typeMatch = argMatcher.exec(args) ) !== null ) {
        ret.push(typeMatch[2]);
      }
      return ret;
    },

    /** Finds the function(...) declaration and finds the first block comment
      in the function body. */
    function functionComment(f) {
      var match = f.
          toString().
          replace(/\n/g, '_#_%_%_'). // fake newlines
          match(/^function(\s+[_$\w]+|\s*)\(.*?\)(?:\_\#\_\%\_\%\_|\s)*\{(?:\_\#\_\%\_\%\_|\s)*\/\*\*?\s*(.*?)\*?\*\/.*\}/);
      if ( ! match ) {
        return '';
      } else {
        return match[2] && match[2].replace(/_#_%_%_/g, '\n') || '';
      }
    },

    function breakdown(f) {
      var ident = "([^,\\s\\)]+)";
      var ws = "\\s*";
      var comment = "(?:\\/\\*(?:.|\\s)*?\\*\\/)?";
      var skip = "(?:" + ws + comment + ws + ")*";
      var header = "(?:function" + skip + ident + "?\\(|\\()" + skip;
      var arg = "(?:" + ident + skip + ")";
      var nextArg = "(?:," + skip + arg + ")";
      var argEnd = "\\)";
      var headerToBody = skip + "(?:\\=\\>)?" + skip;
      var body = "\\{((?:.|\\s)*)\\}";

      var breakdown = {
        name: '',
        args: [],
        body: ''
      };

      var source = f.toString();

      var lastIndex = 0;
      var currentRegex;

      function again() {
        var match = currentRegex.exec(source);
        if ( match ) lastIndex = currentRegex.lastIndex;
        return match;
      }

      function next(e) {
        prep(e);
        return again();
      }

      function prep(e) {
        currentRegex = new RegExp(e, "my");
        currentRegex.lastIndex = lastIndex;
      }

      var match = next(header);
      if ( ! match ) return null;

      if ( match[1] ) breakdown.name = match[1];

      match = next(arg);

      if ( match ) {
        breakdown.args.push(match[1]);
        prep(nextArg);
        while ( match = again() ) {
          breakdown.args.push(match[1]);
        }
      }

      match = next(argEnd);
      if ( ! match ) return null;

      if ( ! next(headerToBody) ) return null;

      match = next(body);
      if ( ! match ) return null;
      breakdown.body = match[1];

      return breakdown;
    },

    /**
     * Calls fn, and provides the arguments to fn by looking
     * up their names on source. The 'this' context is either
     * source, or opt_self if provided.
     *
     * If the argument maps to a function on source, it is bound to source.
     *
     * Ex.
     * var a = {
     *   name: 'adam',
     *   hello: function() {
     *     console.blog('Hello ' + this.name);
     *   }
     * };
     * function foo(name, hello) {
     *   console.log('Name is ' + name);
     *   hello();
     * }
     * foam.Function.withArgs(foo, a);
     *
     * Outputs:
     * Name is adam
     * Hello adam
     *
     **/
    function withArgs(fn, source, opt_self) {
      var argNames = foam.Function.argNames(fn);
      var args = [];
      for ( var i = 0 ; i < argNames.length ; i++ ) {
        var a = source[argNames[i]];
        if ( typeof a === 'function' ) a = a.bind(source);
        args.push(a);
      }
      return fn.apply(opt_self || source, args);
    },

    function closure(fn) {
      /**
         Create a closure which still serializes to its definition.

         var f = foam.Function.closure(function() { var i = 0; return function() { return i++; } });
         f(); -> 0
         f(); -> 1
         f.toString(); -> "foam.Function.closure(function () { var i = 0; return function() { return i++; } })"
      */
      var ret = fn();

      ret.toString = function() { return 'foam.Function.closure(' + fn.toString() + ')'; };

      return ret;
    }
  ]
});


/* istanbul ignore next */
(function() {
  // Disable setName if not supported on this platform.
  try {
    foam.Function.setName(function() {}, '');
  } catch (x) {
    console.warn('foam.Function.setName is not supported on your platform. ' +
                 'Stack traces will be harder to decipher, but no ' +
                 'functionality will be lost');
    foam.LIB({
      name: 'foam.Function',
      methods: [
        function setName(f) { return f; }
      ]
    });
  }
})();


foam.LIB({
  name: 'foam.Number',
  methods: [
    function isInstance(o) { return typeof o === 'number'; },
    function is(a, b) { return foam.Number.compare(a, b) == 0; },
    function clone(o) { return o; },
    function equals(a, b) { return foam.Number.compare(a, b) == 0; },
    function compare(a, b) {
      if ( ! foam.Number.isInstance(b) || ( isNaN(a) && ! isNaN(b)) ) return 1;
      if ( ! isNaN(a) && isNaN(b) ) return -1;
      return a < b ? -1 : a > b ? 1 : 0;
    },
    (function() {
      var bufForHash = new ArrayBuffer(8);
      var floatArrayForHash = new Float64Array(bufForHash);
      var intArrayForHash = new Int32Array(bufForHash);

      return function hashCode(n) {
        if (Number.isInteger(n)) return n & n; // Truncate to 32 bits.

        floatArrayForHash[0] = n;
        var hash = ((intArrayForHash[0] << 5) - intArrayForHash[0]) +
            intArrayForHash[1];
        return hash & hash; // Truncate to 32 bits.
      };
    })()
  ]
});


foam.LIB({
  name: 'foam.String',
  methods: [
    function isInstance(o) { return typeof o === 'string'; },
    function is(a, b) { return a === b; },
    function clone(o) { return o; },
    function equals(a, b) { return a === b; },
    function compare(a, b) {
      if ( ! foam.String.isInstance(b) ) return 1;
      return b != null ? a.localeCompare(b) : 1 ;
    },
    function hashCode(s) {
      var hash = -4;

      for ( var i = 0 ; i < s.length ; i++ ) {
        var code = s.charCodeAt(i);
        hash = ((hash << 5) - hash) + code;
        hash &= hash; // Truncate to 32 bits.
      }

      return hash;
    },
    {
      name: 'constantize',
      code: foam.Function.memoize1(function(/* String */ str) {
        // switches from from camelCase to CAMEL_CASE
        return str.replace(/([a-z])([^0-9a-z_])/g, '$1_$2').toUpperCase();
      })
    },
    {
      name: 'labelize',
      code: foam.Function.memoize1(function(/* String= */ str) {
        if ( str === '' || str === null || foam.Undefined.isInstance(str) ) return '';

        return this.capitalize(str.replace(/[a-z][A-Z]/g, function(a) {
          return a.charAt(0) + ' ' + a.charAt(1);
        }));
      })
    },
    {
      name: 'capitalize',
      code: foam.Function.memoize1(function(str) {
        foam.assert(typeof str === 'string',
            'Cannot capitalize non-string values.');
        // switchFromProperyName to //SwitchFromPropertyName
        return str[0].toUpperCase() + str.substring(1);
      })
    },
    {
      /**
       * Takes a key and creates a slot name for it.  Generally key -> key + '$'.
       *
       * For example, if an object has a property called myProperty, the slot
       * name for that will be myProperty$.
       */
      name: 'toSlotName',
      code: foam.Function.memoize1(function toSlotName(key) {
        foam.assert(
            typeof key === 'string',
            'Cannot toSlotName non-string values.  Attempted: ', key);

        return key + '$';
      })
    },
    {
      name: 'toUpperCase',
      code: foam.Function.memoize1(function(str) {
        foam.assert(
            typeof str === 'string',
            'Cannot toUpperCase non-string values.');

        return str.toUpperCase();
      })
    },
    {
      name: 'cssClassize',
      code: foam.Function.memoize1(function(str) {
        foam.assert(typeof str === 'string',
            'Cannot cssClassize non-string values.');
        // Turns foam.u2.Foo into foam-u2-Foo
        return str.replace(/\./g, '-');
      })
    },
    function pad(obj, size) {
      // Right pads to size if size > 0, Left pads to -size if size < 0
      return size < 0 ?
        (new Array(-size).join(' ') + obj).slice(size)       :
        (obj + new Array(size).join(' ')).substring(0, size) ;
    },
    function multiline(f) {
      // Function for returning multi-line strings from commented functions.
      // Ex. var str = multiline(function() { /* multi-line string here */ });
      if ( typeof f === 'string' ) return f;
      var s     = f.toString();
      var start = s.indexOf('/*');
      var end   = s.lastIndexOf('*/');
      return ( start >= 0 && end >= 0 ) ? s.substring(start + 2, end) : '';
    },
    function startsWithIC(a, b) {
      foam.assert(typeof a === 'string' && typeof b === 'string',
          'Cannot startsWithIC non-string values.');

      return a.toUpperCase().startsWith(b.toUpperCase());
    },
    (function() {
      var map = {};

      return function intern(val) {
        /** Convert a string to an internal canonical copy. **/
        return map[val] || (map[val] = val.toString());
      };
    })(),
  ]
});


foam.LIB({
  name: 'foam.Array',
  methods: [
    function isInstance(o) { return Array.isArray(o); },
    function is(a, b) { return a === b; },
    function clone(o) {
      /** Returns a deep copy of this array and its contents. */
      var ret = new Array(o.length);
      for ( var i = 0 ; i < o.length ; i++ ) {
        ret[i] = foam.util.clone(o[i]);
      }
      return ret;
    },
    function diff(a, b) {
      /** Finds elements added (found in other, not in this) and removed
          (found in this, not in other). Repeated values are treated
          as separate elements, but ordering changes are ignored. */
      var added = b.slice(0);
      var removed = [];
      for ( var i = 0 ; i < a.length ; i++ ) {
        for ( var j = 0 ; j < added.length ; j++ ) {
          if ( foam.util.equals(a[i], added[j]) ) {
            added.splice(j, 1);
            j--;
            break;
          }
        }
        if ( j === added.length ) removed.push(a[i]);
      }
      return { added: added, removed: removed };
    },
    function equals(a, b) {
      if ( ! b || ! Array.isArray(b) || a.length !== b.length ) return false;
      for ( var i = 0 ; i < a.length ; i++ ) {
        if ( ! foam.util.equals(a[i], b[i]) ) return false;
      }
      return true;
    },
    function compare(a, b) {
      if ( ! b || ! Array.isArray(b) ) return 1;
      var l = Math.min(a.length, b.length);
      for ( var i = 0 ; i < l ; i++ ) {
        var c = foam.util.compare(a[i], b[i]);
        if ( c ) return c;
      }
      return a.length === b.length ? 0 : a.length < b.length ? -1 : 1;
    },
    function hashCode(a) {
      var hash = -5;

      for ( var i = 0 ; i < a.length ; i++ ) {
        hash = ((hash << 5) - hash) + foam.util.hashCode(a[i]);
      }

      return hash;
    },
    function remove(a, o) {
      for ( var i = 0 ; i < a.length ; i++ ) {
        if ( o === a[i] ) {
          a.splice(i, 1);
        }
      }
    }
  ]
});


foam.LIB({
  name: 'foam.Date',
  methods: [
    function isInstance(o) { return o instanceof Date; },
    function is(a, b) { return a === b; },
    function clone(o) { return new Date(o); },
    function getTime(d) { return ! d ? 0 : d.getTime ? d.getTime() : d ; },
    function equals(a, b) { return this.getTime(a) === this.getTime(b); },
    function compare(a, b) {
      if ( ! foam.Date.isInstance(b) ) return 1;
      return foam.Number.compare(this.getTime(a), this.getTime(b));
    },
    // Hash n & n: Truncate to 32 bits.
    function hashCode(d) { var n = d.getTime(); return n & n; },
    function relativeDateString(date) {
      // FUTURE: make this translatable for i18n, including plurals
      //   "hours" vs. "hour"
      var seconds = Math.trunc( ( Date.now() - date.getTime() ) / 1000 );

      if ( seconds >= 0 && seconds < 60 ) return 'moments ago';
      if ( seconds < 0  && seconds > -60 ) return 'in moments';

      var minutes = Math.trunc((seconds) / 60);

      if ( minutes === 1 ) return '1 minute ago';
      if ( minutes === -1 ) return 'in 1 minute';

      if ( minutes >= 0 && minutes < 60 ) return minutes + ' minutes ago';
      if ( minutes < 0  && minutes > -60 ) return 'in ' + -minutes + ' minutes';

      var hours = Math.trunc(minutes / 60);
      if ( hours === 1 ) return '1 hour ago';
      if ( hours === -1 ) return 'in 1 hour';

      if ( hours >= 0 && hours < 24 ) return hours + ' hours ago';
      if ( hours <  0 && hours > -24 ) return 'in ' + -hours + ' hours';

      var days = Math.trunc(hours / 24);
      if ( days === 1 ) return '1 day ago';
      if ( days === -1 ) return 'in 1 day';

      if ( days >= 0 && days < 7 ) return days + ' days ago';
      if ( days <  0 && days > -7 ) return 'in ' + -days + ' days';

      if ( days >= 0 && days < 365 || days < 0 && days > -365 ) {
        var year = 1900 + date.getYear();
        var noyear = date.toDateString().replace(' ' + year, '');
        return noyear.substring(4);
      }

      return date.toDateString().substring(4);
    }
  ]
});


// An FObject is a FOAM-Object, the root class for all modeled classes.
foam.LIB({
  name: 'foam.core.FObject',
  methods: [
    // Can't be an FObject yet because we haven't built the class system yet
    /* istanbul ignore next */
    function isInstance(o) { return false; },
    function clone(o)      { return o ? o.clone() : this; },
    function is(a, b)      { return a === b; },
    function diff(a, b)    { return a.diff(b); },
    function equals(a, b)  { return a.equals(b); },
    function compare(a, b) {
      if ( ! foam.core.FObject.isInstance(b) ) return 1;
      return a.compareTo(b);
    },
    function hashCode(o)   { return o.hashCode(); }
  ]
});


// AN Object is a Javascript Object which is neither an FObject nor an Array.
foam.LIB({
  name: 'foam.Object',
  methods: [
    function forEach(obj, f) {
      for ( var key in obj ) {
        if ( obj.hasOwnProperty(key) ) f(obj[key], key);
      }
    },
    function is(a, b) { return a === b; },
    function isInstance(o) {
      return typeof o === 'object' && ! Array.isArray(o) &&
          ! foam.core.FObject.isInstance(o);
    },
    function clone(o) { return o; },
    function equals(a, b) { return a === b; },
    function compare(a, b) {
      if ( ! foam.Object.isInstance(b) ) return 1;
      return foam.Number.compare(a.$UID, b ? b.$UID : -1);
    },
    function hashCode(o) {
      var hash = 19;
      for ( var key in o ) {
        if ( ! o.hasOwnProperty(key) ) continue;
        hash = ((hash << 5) - hash) + foam.util.hashCode(o[key]);
      }
      return hash;
    },
    function freeze(o) {
      // Force $UID creation before freezing because it can't
      // be added to the object after it's frozen.
      o.$UID__ = foam.next$UID();
      Object.freeze(o);
    }
  ]
});


/**
  Return the flyweight 'type object' for the provided object.
  Any value is a valid argument, including null and undefined.
*/
foam.typeOf = (function() {
  var tNumber    = foam.Number;
  var tString    = foam.String;
  var tUndefined = foam.Undefined;
  var tNull      = foam.Null;
  var tBoolean   = foam.Boolean;
  var tArray     = foam.Array;
  var tDate      = foam.Date;
  var tFObject   = foam.core.FObject;
  var tFunction  = foam.Function;
  var tObject    = foam.Object;

  return function typeOf(o) {
    if ( tNumber.isInstance(o) )    return tNumber;
    if ( tString.isInstance(o) )    return tString;
    if ( tUndefined.isInstance(o) ) return tUndefined;
    if ( tNull.isInstance(o) )      return tNull;
    if ( tBoolean.isInstance(o) )   return tBoolean;
    if ( tArray.isInstance(o) )     return tArray;
    if ( tDate.isInstance(o) )      return tDate;
    if ( tFunction.isInstance(o) )  return tFunction;
    if ( tFObject.isInstance(o) )   return tFObject;
    return tObject;
  };
})();

/**
  Defining an ordinal property to establish a precedence
  in which items should be compared in. Items are arranged
  by complexity of the type.
*/

foam.core.FObject.ordinal = 0;
foam.Date.ordinal = 1;
foam.Object.ordinal = 2;
foam.Function.ordinal = 3;
foam.Array.ordinal = 4;
foam.String.ordinal = 5;
foam.Number.ordinal = 6;
foam.Boolean.ordinal = 7;
foam.Null.ordinal = 8;
foam.Undefined.ordinal = 9;

foam.LIB({
  name: 'foam',

  methods: [
    function mmethod(map, opt_defaultMethod) {
      var uid = '__mmethod__' + foam.next$UID() + '__';

      var first = true;
      return function(arg1) {
        if ( first ) {
          for ( var key in map ) {
            var type = key === 'FObject' ?
                foam.core.FObject :
                foam[key] || foam.lookup(key);

            type[uid] = map[key];
          }
          first = false;
        }

        var type = arg1 && arg1.cls_ && arg1.cls_[uid] ?
            arg1.cls_ :
            foam.typeOf(arg1) ;

        if ( ! opt_defaultMethod ) {
          foam.assert(type, 'Unknown type: ', arg1,
              'and no default method provided');
          foam.assert(
              type[uid],
              'Missing multi-method for type ', arg1, ' map: ', map,
              'and no deafult method provided');
        }
        return ( type[uid] || opt_defaultMethod ).apply(this, arguments);
      };
    }
  ]
});


(function() {
  var typeOf = foam.typeOf;

  foam.LIB({
    name: 'foam.util',

    methods: [
      function clone(o)      { return typeOf(o).clone(o); },
      function equals(a, b)  { return typeOf(a).equals(a, b); },
      function is(a, b) {
        var aType = typeOf(a);
        var bType = typeOf(b);
        return aType === bType && aType.is(a, b);
      },
      function compare(a, b) {
        // To ensure that symmetry is present when comparing,
        // we will always use the comparator of higher precedence.
        var aType = typeOf(a);
        var bType = typeOf(b);
        return aType.ordinal > bType.ordinal ? 1 :
            aType.ordinal < bType.ordinal ? -1 : aType.compare(a, b);
      },
      function hashCode(o)   { return typeOf(o).hashCode(o); },
      function diff(a, b)    {
        var t = typeOf(a);
        return t.diff ? t.diff(a, b) : undefined;
      },
      function flagFilter(flags) {
        return function(a) {
          if ( ! flags ) return true;
          if ( ! a.flags ) return true;
          for ( var i = 0, f; f = flags[i]; i++ ) {
            if ( a.flags.indexOf(f) != -1 ) return true;
          }
          return false;
        }
      },
    ]
  });
})();


foam.LIB({
  name: 'foam.package',
  methods: [
    /**
     * Registers the given class in the global namespace.
     * If the given class has an id of 'some.package.MyClass'
     * then the class object will be made available globally at
     * global.some.package.MyClass.
     */
    function registerClass(cls) {
      foam.assert(typeof cls === 'object',
          'cls must be an object');
      foam.assert(typeof cls.name === 'string' && cls.name !== '',
          'cls must have a non-empty string name');

      var pkg = foam.package.ensurePackage(global, cls.package);
      pkg[cls.name] = cls;

      foam.package.triggerClass_(cls);
    },

    function waitForClass(cls) {
      if ( foam.lookup(cls, true) ) return Promise.resolve(foam.lookup(cls));

      foam.package.__pending = foam.package.__pending || {};
      foam.package.__pending[cls] = foam.package.__pending[cls] || [];

      return new Promise(function(resolve, reject) {
        foam.package.__pending[cls].push(resolve);
      });
    },

    function triggerClass_(cls) {
      if ( ! foam.package.__pending || ! foam.package.__pending[cls.id] ) return;

      var pending = foam.package.__pending[cls.id];

      foam.package.__pending[cls.id] = undefined;

      for ( var i = 0 ; i < pending.length ; i++ ) {
        pending[i](cls);
      }
    },

    /**
     * Register a class lazily in the global namespace.
     * The class is not created until accessed the first time.
     * The provided factory function creates the class.
     */
    function registerClassFactory(m, thunk) {
      var pkg = foam.package.ensurePackage(global, m.package);
      var tmp;

      Object.defineProperty(
        pkg,
        m.name, {
          configurable: true,
          get: function() {
            if ( tmp ) return tmp;

            tmp = thunk();

            foam.package.triggerClass_(tmp);

            return tmp;
          }
        }
      );
    },

    /**
     * Walk a dot separated path starting at root, creating empty
     * objects if necessary.
     *
     * ensurePackage(global, 'some.dot.separated.path');
     * will ensure that global.some.dot.separated.path exists with
     * each part being a JS object.
     *
     * Returns root if path is null or undefined.
     */
    function ensurePackage(root, path) {
      if ( path === null ||
           path === undefined ||
           path === '' ) {
        return root;
      }

      foam.assert(typeof path === 'string',
          'Cannot make a package path of a non-string');

      path = path.split('.');
      var node = root;

      for ( var i = 0 ; i < path.length ; i++ ) {
        node = node[path[i]] || ( node[path[i]] = {} );
      }

      return node;
    }
  ]
});


foam.LIB({
  name: 'foam.uuid',
  methods: [
    function randomGUID() {
      return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
        var r = Math.random() * 16 | 0;
        var v = c === 'x' ? r : ( r & 0x3 | 0x8 );
        return v.toString(16);
      });
    }
  ]
});


foam.LIB({
  name: 'foam.compare',
  methods: [
    function toCompare(c) {
      return foam.Array.isInstance(c)    ? foam.compare.compound(c) :
             foam.Function.isInstance(c) ? { compare: c} :
             c ;
    },

    // Gets replaced in mlang.js
    function compound(args) {
      /* Create a compound comparator from an array of comparators. */
      var cs = args.map(foam.compare.toCompare);
      if ( cs.lengh === 1 ) return cs[0];

      var f = {
        compare: function(o1, o2) {
          for ( var i = 0 ; i < cs.length ; i++ ) {
            var r = cs[i].compare(o1, o2);
            if ( r != 0 ) return r;
          }
          return 0;
        }
      };

      return f;
    }
  ]
});
/**
 * @license
 * Copyright 2016 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Event listener utilities.
 */
foam.LIB({
  name: 'foam.events',

  methods: [
    function oneTime(listener) {
      /** Create a "one-time" listener which unsubscribes itself when called. **/
      return function(subscription) {
        subscription.detach();
        listener.apply(this, Array.from(arguments));
      };
    },

    function consoleLog(listener) {
      /** Log all listener invocations to console. **/
      return function() {
        var args = Array.from(arguments);
        console.log(args);
        listener && listener.apply(this, args);
      };
    }
  ]
});
/**
 * @license
 * Copyright 2016 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Context Support
 *
 * Contexts, also known as frames, scopes or environments, are used to store
 * named resources. They provide an object-oriented replacement for global
 * variables. Contexts are immutable. New bindings are added by creating
 * "sub-contexts" with new bindings, from an existing parent context.
 * Sub-contexts inherit bindings from their parent.
 *
 * Contexts provide a form of inversion-of-control or dependendency-injection.
 * Normally, contexts are not explicitly used because FOAM's imports/exports
 * mechanism provides a high-level declarative method of dependency management
 * which hides their use.
 *
 * foam.__context__ references the root context, which is the ancestor of all other
 * contexts.
 */

(function() {
  var __context__ = {
    /**
     * Lookup a class in the context.  Throws an exception if the value
     * couldn't be found, unless opt_suppress is true.
     *
     * @param id The id of the class to lookup.
     * @param opt_suppress Suppress throwing an error.
     **/
    lookup: function(id, opt_suppress) {
      var ret = typeof id === 'string' && this.__cache__[id];

      if ( ! opt_suppress ) {
        foam.assert(
            ret,
            'Could not find any registered class for ' + id);
      }

      return foam.Function.isInstance(ret) ? ret() : ret;
    },

    /**
     * Register a class into the given context.  After registration
     * the class can be found again by calling foam.lookup('com.foo.SomeClass');
     *
     * @param cls    The class to register.
     * @param opt_id Optional id under which to register class.
     */
    register: function(cls, opt_id) {
      foam.assert(
        typeof cls === 'object',
        'Cannot register non-objects into a context.');

      if ( opt_id ) {
        this.registerInCache_(cls, this.__cache__, opt_id);
      } else {
        foam.assert(
            typeof cls.id === 'string',
            'Must have an .id property to be registered in a context.');

        this.registerInCache_(cls, this.__cache__, cls.id);

        if ( cls.package === 'foam.core' ) {
          this.registerInCache_(cls, this.__cache__, cls.name);
        }
      }
    },

    /**
     * Register a class factory into the given context.
     * When the class is first accessed the factory is used
     * to create the value which is used.
     */
    registerFactory: function(m, factory) {
      foam.assert(
        typeof m.id === 'string',
        'Must have an .id property to be registered in a context.');

      this.registerInCache_(factory, this.__cache__, m.id);

      if ( m.package === 'foam.core' ) {
        this.registerInCache_(factory, this.__cache__, m.name);
      }
    },

    /**
     * Returns true if the model ID has been registered. False otherwise.
     */
    isRegistered: function(modelId) {
      return !! this.__cache__[modelId];
    },

    /** Internal method to register a context binding in an internal cache */
    registerInCache_: function registerInCache_(cls, cache, name) {
      var hasOld = Object.prototype.hasOwnProperty.call(cache, name);
      var old = cache[name];

      // Okay to replace a function with an actual class.
      // This happens after a lazy class is initialized.
      foam.assert(
          ! hasOld ||
              (foam.Function.isInstance(old) && ! foam.Function.isInstance(cls)),
          name + ' is already registered in this context.');

      cache[name] = cls;
    },

    /** Internal method to create a slot name for a specified key. */
    toSlotName_: foam.Function.memoize1(function toSlotName_(key) {
      return key + '$';
    }),

    /**
     * Creates a sub context of the context that this is called upon.
     * @param opt_args A map of bindings to set up in the sub context.
     *     Currently unused.
     */
    createSubContext: function createSubContext(opt_args, opt_name) {
      if ( ! opt_args ) return this;

      foam.assert(
          opt_name === undefined || typeof opt_name === 'string',
          'opt_name must be left undefined or be a string.');

      var sub = Object.create(this);

      if ( opt_name ) {
        Object.defineProperty(sub, 'NAME', {
          value: opt_name,
          enumerable: false
        });
      }

      for ( var key in opt_args ) {
        if ( opt_args.hasOwnProperty(key) ) {
          var v = opt_args[key];

          if ( ! foam.core.Slot.isInstance(v) ) {
            Object.defineProperty(sub, this.toSlotName_(key), {
              value: foam.core.ConstantSlot.create({ value: v }),
              enumerable: true
            });

            Object.defineProperty(sub, key, {
              value: v,
              enumerable: true
            });
          } else {
            Object.defineProperty(sub, this.toSlotName_(key), {
              value: v,
              enumerable: true
            });

            (function(v) {
              Object.defineProperty(sub, key, {
                get: function() { return v.get(); },
                enumerable: true
              });
            })(v);
          }
        }
      }

      Object.defineProperty(sub, '__cache__', {
        value: Object.create(this.__cache__),
        enumerable: false
      });

      foam.Object.freeze(sub);

      return sub;
    }
  };

  Object.defineProperty(__context__, '__cache__', {
    value: {},
    enumerable: false
  });

  // Create short-cuts for foam.__context__.[createSubContext, register, lookup]
  // in foam.
  foam.lookup = function(id, opt_suppress) {
    return foam.__context__.lookup(id, opt_suppress);
  };
  foam.register = function(cls, opt_id) {
    foam.__context__.register(cls, opt_id);
  };
  foam.createSubContext = function(opt_args, opt_name) {
    return foam.__context__.createSubContext(opt_args, opt_name);
  };

  foam.__context__ = __context__;
})();
/**
 * @license
 * Copyright 2016 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 FOAM Bootstrap
<p>
 FOAM uses Models to specify class definitions.
 The FOAM Model class is itself specified with a FOAM model, meaning
 that Model is defined in the same language which it defines.
 This self-modeling system requires some care to bootstrap, but results
 in a very compact, uniform, and powerful system.
<pre>

 FObject -> FObject Class                     Prototype
    ^                        +-.prototype---------^
    |                        |                    |
  Model  -> buildClass()  -> Class -> create() -> instance
</pre>
  FObject is the root model/class of all other classes, including Model.
  Abstract Class is the prototype of FObject's Class, which makes it the root of all Classes.
  From a Model we call buildClass() to create a Class (or the previously created Class) object.
  From the Class we call create() to create new instances of that class.
  New instances extend the classes prototype object, which is stored on the class as .prototype.
<pre>
  instance ---> .cls_   -> Object's Class
       |
       +------> .model_ -> Object's Model
</pre>
  All descendents of FObject have references to both their Model and Class.
    - obj.cls_ refers to an Object's Class
    - obj.model_ refers to an Object's Model

<p>  Classes also refer to their Model with .model_.

<p>  Model is its own definition:
<pre>
    Model.buildClass().create(Model) == Model
    Model.model_ === Model
</pre>
  Models are defined as a collection of Axioms.
  It is the responsibility of Axioms to install itself onto a Model's Class and/or Prototype.

<p>
  Axioms are defined with the following psedo-interface:
<pre>
    public interface Axiom {
      optional installInClass(cls)
      optional installInProto(proto)
    }
</pre>
  Ex. of a Model with one Axiom:
<pre>
  foam.CLASS({
    name: 'Sample',

    axioms: [
      {
        name: 'axiom1',
        installInClass: function(cls) { ... },
        installInProto: function(proto) { ... }
      }
    ]
  });
</pre>
  Axioms can be added either during the initial creation of a class and prototype,
  or anytime after.  This allows classes to be extended with new functionality,
  and this is very important to the bootstrap process because it allows us to
  start out with very simple definitions of Model and FObject, and then build
  them up until they're fully bootstrapped.
<p>
  However, raw axioms are rarely used directly. Instead we model higher-level
  axiom types, including:
<ul>
  <li>Requires   - Require other classes
  <li>Imports    - Context imports
  <li>Exports    - Context exports
  <li>Implements - Declare interfaces implemented / mix-ins mixed-in
  <li>Constants  - Add constants to the prototype and class
  <li>Properties - High-level instance variable definitions
  <li>Methods    - Prototype methods
  <li>Topics     - Publish/sub topics
  <li>Listeners  - Like methods, but with extra features for use as callbacks
</ul>

*/


/**
 Bootstrap support.

 Is discarded after use.
*/
foam.LIB({
  name: 'foam.boot',

  constants: {
    startTime: Date.now(),
  },

  methods: [
    /**
      Create or Update a Prototype from a Model definition.

      This will be added as a method on the Model class
      when it is eventually built.

      (Model is 'this').
    */
    function buildClass() {
      var context = this.__context__ || foam.__context__;
      var cls;

      if ( this.refines ) {
        cls = context.lookup(this.refines);
        foam.assert(cls, 'Unknown refinement class: ' + this.refines);
      } else {
        foam.assert(this.id, 'Missing id name.', this.name);
        foam.assert(this.name, 'Missing class name.');

        var parent = this.extends      ?
          context.lookup(this.extends) :
          foam.core.FObject            ;

        cls                  = parent.createSubClass_();
        cls.prototype.cls_   = cls;
        cls.prototype.model_ = this;
        cls.count_           = 0;            // Number of instances created
        cls.id               = this.id;
        cls.package          = this.package;
        cls.name             = this.name;
        cls.model_           = this;

        // Install an FObject on the class that we can use as a pub/sub hub.
        // We have to do this because classes aren't FObjects.
        // This is used to publish 'installAxiom' events to, so that descendents
        // properties know when they need to be re-installed.
        if ( cls !== foam.core.FObject ) {
          cls.pubsub_ = foam.core.FObject.create();

          // Relay 'installAxiom' events from parent class.
          parent.pubsub_ && parent.pubsub_.sub(
            'installAxiom',
            function(_, a1, a2, a3) { cls.pubsub_.pub(a1, a2, a3); });
        }
      }

      cls.installModel(this);

      return cls;
    },

    function start() {
      /* Start the bootstrap process. */

      var buildClass = this.buildClass;

      // Will be replaced in phase2.
      foam.CLASS = function(m) {
        m.id = m.package + '.' + m.name;
        var cls = buildClass.call(m);

        foam.assert(
          ! m.refines,
          'Refines is not supported in early bootstrap');

        foam.register(cls);

        // Register the class in the global package path.
        foam.package.registerClass(cls);

        return cls;
      };
    },

    /** Start second phase of bootstrap process. */
    function phase2() {
      // Upgrade to final CLASS() definition.
      /* Creates a Foam class from a plain-old-object definition:
          (1) Determine the class of model for the new class's model;
          (2) Construct and validate the new class's model;
          (3) Construct and validate the new class.
          @method CLASS
          @memberof module:foam */
      foam.CLASS = function(m, skipRegistration) {
        var cls   = m.class ? foam.lookup(m.class) : foam.core.Model;
        var model = cls.create(m);
        model.validate();
        // cls was: class-for-model-construction;
        // cls is: class-constructed-from-model.
        cls = model.buildClass();
        cls.validate();

        if ( skipRegistration ) return cls;

        if ( ! m.refines ) {
          // Register class in global context.
          foam.register(cls);

          // Register the class in the global package path.
          foam.package.registerClass(cls);
        } else if ( m.name ) {
          // Register refinement id in global context.
          foam.register(cls, ( m.package || 'foam.core' ) + '.' + m.name);
        }
        // TODO(markdittmer): Identify and name anonymous refinements with:
        // else {
        //   console.warn('Refinement without unique id', cls);
        //   debugger;
        // }

        return cls;
      };

      // Upgrade existing classes to real classes.
      for ( var key in foam.core ) {
        var m = foam.lookup(key).model_;

        // classModel.buildClass() expects 'refines' if we are upgrading an
        // existing class.
        m.refines = m.id;

        foam.CLASS(m, true);
      }
    },

    function phase3() {
      // Substitute foam.core.installModel() with simpler axiom-only version.
      foam.core.FObject.installModel = function installModel(m) {
        if ( m.source ) m.axioms_.forEach(function(a) { a.source = m.source; });
        this.installAxioms(m.axioms_);
      };
    },

    /** Finish the bootstrap process, deleting foam.boot when done. */
    function end() {
      var Model = foam.core.Model;

      // Update psedo-Models to real Models
      for ( var key in foam.core ) {
        var c = foam.core[key];
        c.prototype.model_ = c.model_ = Model.create(c.model_);
      }

      delete foam.boot;

      console.log('core boot time: ', Date.now() - this.startTime);
    }
  ]
});


foam.boot.start();
/**
 * @license
 * Copyright 2016 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*
  FObject is the root of FOAM's class hierarchy.

  We define FObject twice, first as a LIB to install all of
  the static/class methods in the top-level FObject class,
  then with a CLASS below to define methods on the FObject
  prototype.

  For details on how FObject fits in to the FOAM class system,
  see the documentation in the top of Boot.js
 */
foam.LIB({
  name: 'foam.core.FObject',

  constants: {
    // Each class has a prototype object which is the prototype of all
    // instances of the class. A classes prototype extends its parent
    // classes prototype.
    prototype: {},

    // Each class has a map of Axioms added to the class.
    // Map keys are the name of the axiom.
    // The classes axiomMap_'s extends its parent's axiomMap_.
    axiomMap_: {},

    // Each class has a map of "private" variables for use by
    // axioms. Storing internal data in private_ instead of on the
    // class directly avoids name conflicts with public features of
    // the class.
    private_:  { axiomCache: {} }
  },

  methods: [
    function create(args, opt_parent) {
      /**
       * Create a new instance of this class.
       * Configured from values taken from 'args', if supplifed.
       */

      var obj = Object.create(this.prototype);

      // Increment number of objects created of this class.
      this.count_++;

      // Properties have their values stored in instance_ instead
      // of on the object directly. This lets us defineProperty on
      // the object itself so that we can add extra behaviour
      // to properties (things like preSet, postSet, firing property-
      // change events, etc.).
      obj.instance_ = {};

      // initArgs() is the standard argument extraction method.
      obj.initArgs(args, opt_parent);

      var axioms = this.getInitAgents();
      for ( var i = 0 ; i < axioms.length ; i++ ) {
        axioms[i].initObject(obj);
      }

      // init() is called when object is created.
      // This is where class-specific initialization code should
      // be put (not in initArgs).
      obj.init();

      return obj;
    },

    function createSubClass_() {
      /**
       * Used to create a sub-class of this class.  Sets up the appropriate
       * prototype chains for the class, class.prototype and axiomMap_
       *
       * The very first "subClass" that we create will be FObject itself, when
       * we define the FObject class rather than the FObject lib that we are
       * currently defining.
       *
       * So instead of actually creating a subClass, we will just return "this"
       * and replace createSubClass() on FObject to actually create real
       * sub-classes for all subsequent uses of FObject.createSubClass()
       */
      foam.core.FObject.createSubClass_ = function() {
        var cls = Object.create(this);

        cls.prototype = Object.create(this.prototype);
        cls.axiomMap_ = Object.create(this.axiomMap_);
        cls.private_  = { axiomCache: {} };

        return cls;
      };

      return this;
    },

    function getSuperClass() {
      return this.model_.__context__.lookup(this.model_.extends);
    },

    function installAxioms(axs) {
      if ( ! axs || ! axs.length ) return;

      /**
       * Install Axioms into the class and prototype.
       * Invalidate the axiom-cache, used by getAxiomsByName().
       *
       * FUTURE: Wait for first object to be created before creating prototype.
       * Currently it installs axioms into the protoype immediately, but in should
       * wait until the first object is created. This will provide
       * better startup performance.
       */
      this.private_.axiomCache = {};

      // We install in two passes to avoid ordering issues from Axioms which
      // need to access other axioms, like ids: and exports:.

      var existing = new Array(axs.length);

      for ( var i = 0 ; i < axs.length ; i++ ) {
      // Convert JSON axioms to real instances as late as possible
        if ( foam.String.isInstance(axs[i].class) ) {
          var axsCls = foam.lookup(axs[i].class, true);
          if ( axsCls ) axs[i] = axsCls.create(axs[i]);
        }

        var a = axs[i];

        // Store the destination class in the Axiom. Used by describe().
        // Store source class on a clone of 'a' so that the Axiom can be
        // reused without corrupting the sourceCls_.
        a.sourceCls_ = this;

        if ( Object.prototype.hasOwnProperty.call(this.axiomMap_, a.name) ) {
          existing[i] = this.axiomMap_[a.name];
        }

        this.axiomMap_[a.name] = a;
      }

      for ( var i = 0 ; i < axs.length ; i++ ) {
        var a = axs[i];

        var superAxiom = this.getSuperAxiomByName(a.name);

        a.installInClass && a.installInClass(this,           superAxiom, existing[i]);
        a.installInProto && a.installInProto(this.prototype, superAxiom, existing[i]);

        if ( a.name ) {
          this.pubsub_ && this.pubsub_.pub('installAxiom', a.name, a);
        }
      }
    },

    function installAxiom(a) {
      this.installAxioms([a]);
    },

    function installConstant(key, value) {
      var cName = foam.String.constantize(key);
      var prev  = this[cName];

      // Detect constant name collisions
      if ( prev && prev.name !== key ) {
        throw 'Class constant conflict: ' +
          this.id + '.' + cName + ' from: ' + key + ' and ' + prev.name;
      }

      this.prototype[cName] = this[cName] = value;
    },

    function isInstance(o) {
      /**
       * Determine if an object is an instance of this class
       * or one of its sub-classes.
       */

      return !! ( o && o.cls_ && this.isSubClass(o.cls_) );
    },

    function isSubClass(c) {
      /**
       * Determine if a class is either this class, a sub-class, or
       * if it implements this class (directly or indirectly).
       */

      if ( ! c || ! c.id ) return false;

      // Optimize most common case and avoid creating cache
      if ( this === foam.core.FObject ) return true;

      var cache = this.private_.isSubClassCache ||
        ( this.private_.isSubClassCache = {} );

      if ( cache[c.id] === undefined ) {
        cache[c.id] = ( c === this.prototype.cls_ ) ||
          ( c.getAxiomByName && !! c.getAxiomByName('implements_' + this.id) ) ||
          this.isSubClass(c.__proto__);
      }

      return cache[c.id];
    },

    function getAxiomByName(name) {
      /**
       * Find an axiom by the specified name from either this class or an
       * ancestor.
       */
      return this.axiomMap_[name];
    },

    function getAxiomsByClass(cls) {
      /**
       * Returns all axioms defined on this class or its parent classes
       * that are instances of the specified class.
       */
      // FUTURE: Add efficient support for:
      //    .where() .orderBy() .groupBy()
      var as = this.private_.axiomCache[cls.id];
      if ( ! as ) {
        as = [];
        for ( var key in this.axiomMap_ ) {
          var a = this.axiomMap_[key];
          if ( cls.isInstance(a) ) as.push(a);
        }
        this.private_.axiomCache[cls.id] = as;
      }

      return as;
    },

    function getSuperAxiomByName(name) {
      /**
       * Find an axiom by the specified name from an ancestor.
       */
      return this.axiomMap_.__proto__[name];
    },

    function hasOwnAxiom(name) {
      /**
       * Return true if an axiom named "name" is defined on this class
       * directly, regardless of what parent classes define.
       */
      return Object.hasOwnProperty.call(this.axiomMap_, name);
    },

    function getOwnAxiomsByClass(cls) {
      /**
       * Returns all axioms defined on this class that are instances of the
       * specified class.
       */
      return this.getAxiomsByClass(cls).filter(function(a) {
        return this.hasOwnAxiom(a.name);
      }.bind(this));
    },

    function getOwnAxioms() {
      /** Returns all axioms defined on this class. */
      return this.getAxioms().filter(function(a) {
        return this.hasOwnAxiom(a.name);
      }.bind(this));
    },

    function getAxioms() {
      /** Returns all axioms defined on this class or its parent classes. */

      // The full axiom list is stored in the regular cache with '' as a key.
      var as = this.private_.axiomCache[''];
      if ( ! as ) {
        as = [];
        for ( var key in this.axiomMap_ ) as.push(this.axiomMap_[key]);
        this.private_.axiomCache[''] = as;
      }
      return as;
    },

    function getInitAgents() {
      if ( ! this.private_.initAgentsCache ) {
        this.private_.initAgentsCache = [];
        for ( var key in this.axiomMap_ ) {
          var axiom = this.axiomMap_[key];
          if (axiom.initObject) this.private_.initAgentsCache.push(axiom);
        }
      }
      return this.private_.initAgentsCache;
    },

    // NOP, is replaced if debug.js is loaded
    function validate() { },

    function toString() { return this.name + 'Class'; },

    function installModel(m) {
      /**
       * Temporary Bootstrap Implementation
       *
       * This is a temporary version of installModel.
       * When the bootstrap is finished, it will be replaced by a
       * version that only knows how to install axioms in Boot.js phase3().
       *
       * It is easier to start with hard-coded method and property
       * support because Axioms need methods to install themselves
       * and Property Axioms themselves have properties.
       *
       * However, once we've bootstrapped proper Property and Method
       * Axioms, we can remove this support and just install Axioms.
       */


      /*
        Methods can be defined using two formats.
        1. Short-form function literal:
             function foo() {
               console.log('bar');
             }

        3. Long-form JSON:
             {
               name: 'foo',
               code: function() {
                 console.log('bar');
               }
             }
           The long-form will support many options (many of which are defined
           in Method.js), but only 'name' and 'code' are mandatory.
       */

      if ( m.methods ) {
        for ( var i = 0 ; i < m.methods.length ; i++ ) {
          var a = m.methods[i];

          if ( foam.Function.isInstance(a) ) {
            var name = foam.Function.getName(a);
            m.methods[i] = a = { name: name, code: a };
          }
          if ( foam.core.Method ) {
            foam.assert(a.cls_ !== foam.core.Method,
              'Method', a.name, 'on', m.name,
              'has already been upgraded to a Method');

            a = foam.core.Method.create(a);
            this.installAxiom(a);
          } else {
            this.prototype[a.name] = a.code;
          }
        }
      }

      /*
        Properties can be defined using three formats:
        1. Short-form String:  'firstName' or 'sex'

        2. Medium-form Array:  [ 'firstName', 'John' ] or [ 'sex', 'Male' ]
           The first element of the array is the name and the second is the
           default value.

        3. Long-form JSON:     { class: 'String', name: 'sex', value: 'Male' }
           The long-form will support many options (many of which are defined
           in Property.js), but only 'name' is mandatory.
       */
      if ( foam.core.Property && m.properties ) {
        for ( var i = 0 ; i < m.properties.length ; i++ ) {
          var a = m.properties[i];

          if ( Array.isArray(a) ) {
            m.properties[i] = a = { name: a[0], value: a[1] };
          } else if ( foam.String.isInstance(a) ) {
            m.properties[i] = a = { name: a };
          }

          var type = foam.lookup(a.class, true) || foam.core.Property;
          foam.assert(
            type !== a.cls_,
            'Property', a.name, 'on', m.name,
            'has already been upgraded to a Property.');

          a = type.create(a);

          this.installAxiom(a);
        }
      }
    }
  ]
});

/**
 * The implicit base class for the FOAM class hierarchy. If you do not
 * explicitly extend another class, FObject is used.
 */
foam.CLASS({
  package: 'foam.core',
  name: 'FObject',

  // Effectively imports the following methods, but imports: isn't available
  // yet, so we add with 'methods:'.
  //
  // imports: [ 'error', 'log', 'warn' ],

  methods: [
    function init() {
      /**
       * Template init() method, basic FObject this is a no-op, but classes
       * can override this to do their own per-instance initialization
       */
    },

    function initArgs(args) {
      /**
       * This is a temporary version of initArgs.
       * When the bootstrap is finished, it will be replaced by a version
       * that knows about a classes Properties, so it can do a better job.
       */

      if ( ! args ) return;

      for ( var key in args ) this[key] = args[key];
    },

    function hasOwnProperty(name) {
      /**
       * Returns true if this object is storing a value for a property
       * named by the 'name' parameter.
       */

      return ! foam.Undefined.isInstance(this.instance_[name]);
    },

    function hasDefaultValue(name) {
      if ( ! this.hasOwnProperty(name) ) return true;

      var axiom = this.cls_.getAxiomByName(name);
      return axiom.isDefaultValue(this[name]);
    },

    function clearProperty(name) {
      /**
       * Undefine a Property's value.
       * The value will revert to either the Property's 'value' or
       * 'expression' value, if they're defined or undefined if they aren't.
       * A propertyChange event will be fired, even if the value doesn't change.
       */

      var prop = this.cls_.getAxiomByName(name);
      foam.assert(prop && foam.core.Property.isInstance(prop),
                    'Attempted to clear non-property', name);

      if ( this.hasOwnProperty(name) ) {
        var oldValue = this[name];
        this.instance_[name] = undefined;
        this.clearPrivate_(name);

        // Avoid creating slot and publishing event if nobody is listening.
        if ( this.hasListeners('propertyChange', name) ) {
          this.pub('propertyChange', name, this.slot(name));
        }
      }
    },

    function setPrivate_(name, value) {
      /**
       * Private support is used to store per-object values that are not
       * instance variables.  Things like listeners and topics.
       */
      ( this.private_ || ( this.private_ = {} ) )[name] = value;
      return value;
    },

    function getPrivate_(name) {
      return this.private_ && this.private_[name];
    },

    function hasOwnPrivate_(name) {
      return this.private_ && ! foam.Undefined.isInstance(this.private_[name]);
    },

    function clearPrivate_(name) {
      if ( this.private_ ) this.private_[name] = undefined;
    },

    function validate() {
      var as = this.cls_.getAxioms();
      for ( var i = 0 ; i < as.length ; i++ ) {
        var a = as[i];
        a.validateInstance && a.validateInstance(this);
      }
    },


    /************************************************
     * Console
     ************************************************/

    // Imports aren't implemented yet, so mimic:
    //   imports: [ 'lookup', 'assert', 'error', 'log', 'warn' ],


    // Bootstrap form replaced after this.__context__ is added.
    function lookup() { return foam.lookup.apply(foam, arguments); },

    function error() { this.__context__.error.apply(null, arguments); },

    function log() { this.__context__.log.apply(null, arguments); },

    function warn() { this.__context__.warn.apply(null, arguments); },


    /************************************************
     * Publish and Subscribe
     ************************************************/

    function createListenerList_() {
      /**
       * This structure represents the head of a doubly-linked list of
       * listeners. It contains 'next', a pointer to the first listener,
       * and 'children', a map of sub-topic chains.
       *
       * Nodes in the list contain 'next' and 'prev' links, which lets
       * removing subscriptions be done quickly by connecting next to prev
       * and prev to next.
       *
       * Note that both the head structure and the nodes themselves have a
       * 'next' property. This simplifies the code because there is no
       * special case for handling when the list is empty.
       *
       * Listener List Structure
       * -----------------------
       * next     -> {
       *   prev: <-,
       *   sub: {src: <source object>, detach: <destructor function> },
       *   l: <listener>,
       *   next: -> <same structure>,
       *   children -> {
       *     subTopic1: <same structure>,
       *     ...
       *     subTopicn: <same structure>
       *   }
       * }
       *
       * TODO: Move this structure to a foam.LIB, and add a benchmark
       * to show why we are using plain javascript objects rather than
       * modeled objects for this structure.
    */
      return { next: null };
    },

    function listeners_() {
      /**
       * Return the top-level listener list, creating if necessary.
       */
      return this.getPrivate_('listeners') ||
        this.setPrivate_('listeners', this.createListenerList_());
    },

    function notify_(listeners, a) {
      /**
       * Notify all of the listeners in a listener list.
       * Pass 'a' arguments to listeners.
       * Returns the number of listeners notified.
       */
      var count = 0;
      while ( listeners ) {
        var l = listeners.l;
        var s = listeners.sub;

        // Update 'listeners' before notifying because the listener
        // may set next to null.
        listeners = listeners.next;

        // Like l.apply(l, [s].concat(Array.from(a))), but faster.
        // FUTURE: add benchmark to justify
        // ???: optional exception trapping, benchmark
        try {
          switch ( a.length ) {
            case 0: l(s); break;
            case 1: l(s, a[0]); break;
            case 2: l(s, a[0], a[1]); break;
            case 3: l(s, a[0], a[1], a[2]); break;
            case 4: l(s, a[0], a[1], a[2], a[3]); break;
            case 5: l(s, a[0], a[1], a[2], a[3], a[4]); break;
            case 6: l(s, a[0], a[1], a[2], a[3], a[4], a[5]); break;
            case 7: l(s, a[0], a[1], a[2], a[3], a[4], a[5], a[6]); break;
            case 8: l(s, a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7]); break;
            case 9: l(s, a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8]); break;
            default: l.apply(l, [s].concat(Array.from(a)));
          }
        } catch (x) {}
        count++;
      }
      return count;
    },

    function hasListeners(/* args */) {
      /**
       * Return true iff there are listeners for the supplied message.
       */

      var listeners = this.getPrivate_('listeners');

      for ( var i = 0 ; listeners ; i++ ) {
        if ( listeners.next        ) return true;
        if ( i == arguments.length ) return false;
        listeners = listeners.children && listeners.children[arguments[i]];
      }

      return false;
    },

    function pub(a1, a2, a3, a4, a5, a6, a7, a8) {
      /**
       * Publish a message to all matching sub()'ed listeners.
       *
       * All sub()'ed listeners whose specified pattern match the
       * pub()'ed arguments will be notified.
       * Ex.
       * <pre>
       *   var obj  = foam.core.FObject.create();
       *   var sub1 = obj.sub(               function(a,b,c) { console.log(a,b,c); });
       *   var sub2 = obj.sub('alarm',       function(a,b,c) { console.log(a,b,c); });
       *   var sub3 = obj.sub('alarm', 'on', function(a,b,c) { console.log(a,b,c); });
       *
       *   obj.pub('alarm', 'on');  // notifies sub1, sub2 and sub3
       *   obj.pub('alarm', 'off'); // notifies sub1 and sub2
       *   obj.pub();               // only notifies sub1
       *   obj.pub('foobar');       // only notifies sub1
       * </pre>
       *
       * Note how FObjects can be used as generic pub/subs.
       *
       * Returns the number of listeners notified.
       */

      // This method prevents this function not being JIT-ed because
      // of the use of 'arguments'. Doesn't generate any garbage ([]'s
      // don't appear to be garbage in V8).
      // FUTURE: benchmark
      switch ( arguments.length ) {
        case 0:  return this.pub_([]);
        case 1:  return this.pub_([ a1 ]);
        case 2:  return this.pub_([ a1, a2 ]);
        case 3:  return this.pub_([ a1, a2, a3 ]);
        case 4:  return this.pub_([ a1, a2, a3, a4 ]);
        case 5:  return this.pub_([ a1, a2, a3, a4, a5 ]);
        case 6:  return this.pub_([ a1, a2, a3, a4, a5, a6 ]);
        case 7:  return this.pub_([ a1, a2, a3, a4, a5, a6, a7 ]);
        case 8:  return this.pub_([ a1, a2, a3, a4, a5, a6, a7, a8 ]);
        default: return this.pub_(arguments);
      }
    },

    function pub_(args) {
      /** Internal publish method, called by pub(). */

      // No listeners, so return.
      if ( ! this.hasOwnPrivate_('listeners') ) return 0;

      var listeners = this.listeners_();

      // Notify all global listeners.
      var count = this.notify_(listeners.next, args);

      // Walk the arguments, notifying more specific listeners.
      for ( var i = 0 ; i < args.length; i++ ) {
        listeners = listeners.children && listeners.children[args[i]];
        if ( ! listeners ) break;
        count += this.notify_(listeners.next, args);
      }

      return count;
    },

    function sub() { /* args..., l */
      /**
       * Subscribe to pub()'ed events.
       * args - zero or more values which specify the pattern of pub()'ed
       * events to match.
       * <p>For example:
       * <pre>
       *   sub('propertyChange', l) will match:
       *   pub('propertyChange', 'age', 18, 19), but not:
       *   pub('stateChange', 'active');
       * </pre>
       * <p>sub(l) will match all events.
       *   l - the listener to call with notifications.
       * <p> The first argument supplied to the listener is the "subscription",
       *   which contains the "src" of the event and a detach() method for
       *   cancelling the subscription.
       * <p>Returns a "subscrition" which can be cancelled by calling
       *   its .detach() method.
       */

      var l = arguments[arguments.length - 1];

      foam.assert(foam.Function.isInstance(l),
          'Listener must be a function');

      var listeners = this.listeners_();

      for ( var i = 0 ; i < arguments.length - 1 ; i++ ) {
        var children = listeners.children || ( listeners.children = {} );
        listeners = children[arguments[i]] ||
            ( children[arguments[i]] = this.createListenerList_() );
      }

      var node = {
        sub:  { src: this },
        next: listeners.next,
        prev: listeners,
        l:    l
      };
      node.sub.detach = function() {
        if ( node.next ) node.next.prev = node.prev;
        if ( node.prev ) node.prev.next = node.next;

        // Disconnect so that calling detach more than once is harmless
        node.next = node.prev = null;
      };

      if ( listeners.next ) listeners.next.prev = node;
      listeners.next = node;

      return node.sub;
    },

    function pubPropertyChange_(prop, oldValue, newValue) {
      /**
       * Publish to this.propertyChange topic if oldValue and newValue are
       * different.
       */
      if ( Object.is(oldValue, newValue) ) return;
      if ( ! this.hasListeners('propertyChange', prop.name) ) return;

      var slot = prop.toSlot(this);
      slot.setPrev(oldValue);
      this.pub('propertyChange', prop.name, slot);
    },

    function slot(obj) {
      /**
       * Creates a Slot for an Axiom.
       */
      if ( typeof obj === 'function' ) {
        return foam.core.ExpressionSlot.create(
            arguments.length === 1 ?
                { code: obj, obj: this } :
                {
                  code: obj,
                  obj: this,
                  args: Array.prototype.slice.call(arguments, 1)
                });
      }

      if ( foam.Array.isInstance(obj) ) {
        return foam.core.ExpressionSlot.create({
          obj: this,
          args: obj[0].map(this.slot.bind(this)),
          code: obj[1],
        });
      }

      var names = obj.split('$');
      var axiom = this.cls_.getAxiomByName(names.shift());

      foam.assert(axiom, 'slot() called with unknown axiom name:', obj);
      foam.assert(axiom.toSlot, 'Called slot() on unslottable axiom:', obj);

      var slot = axiom.toSlot(this)
      names.forEach(function(n) {
        slot = slot.dot(n);
      });

      return slot;
    },


    /************************************************
     * Destruction
     ************************************************/

    function onDetach(d) {
      /**
       * Register a function or a detachable to be called when this object is
       * detached.
       *
       * A detachable is any object with a detach() method.
       *
       * Does nothing is the argument is falsy.
       *
       * Returns the input object, which can be useful for chaining.
       */
      foam.assert(! d || foam.Function.isInstance(d.detach) ||
          foam.Function.isInstance(d),
          'Argument to onDetach() must be callable or detachable.');
      if ( d ) this.sub('detach', d.detach ? d.detach.bind(d) : d);
      return d;
    },

    function detach() {
      /**
       * Detach this object. Free any referenced objects and destory
       * any registered detroyables.
       */
      if ( this.instance_.detaching_ ) return;

      // Record that we're currently detaching this object,
      // to prevent infinite recursion.
      this.instance_.detaching_ = true;
      this.pub('detach');
      this.instance_.detaching_ = false;
      this.clearPrivate_('listeners');
    },


    /************************************************
     * Utility Methods: clone, equals, hashCode, etc.
     ************************************************/

    function equals(other) { return this.compareTo(other) === 0; },

    function compareTo(other) {
      if ( other === this ) return 0;
      if ( ! other        ) return 1;

      if ( this.model_ !== other.model_ ) {
        return other.model_ ?
          foam.util.compare(this.model_.id, other.model_.id) :
          1;
      }

      // FUTURE: check 'id' first
      // FUTURE: order properties
      var ps = this.cls_.getAxiomsByClass(foam.core.Property);
      for ( var i = 0 ; i < ps.length ; i++ ) {
        var r = ps[i].compare(this, other);
        if ( r ) return r;
      }

      return 0;
    },

    /**
     * Compare this object to another object of the same type, and produce a raw
     * javascript object which shows the differences between the two.
     * Example
     * <pre>
     * var obj1 = Abc.create({ a: 1, b: ['A', 'B', 'C'] });
     * var obj2 = Abc.create({ a: 2, b: ['A', 'D'] });
     * var diff = obj1.diff(obj2);
     * </pre>
     * The diff object will look like
     * <pre>
     * { a: 2, b: { added: ['D'], removed: ['B', 'C'] } };
     * </pre>
     */
    function diff(other) {
      var d = {};

      foam.assert(other, 'Attempt to diff against null.');
      foam.assert(other.cls_ === this.cls_, 'Attempt to diff objects with different classes.', this, other);

      var ps = this.cls_.getAxiomsByClass(foam.core.Property);
      for ( var i = 0, property ; property = ps[i] ; i++ ) {
        // FUTURE: move this to a refinement in case not needed?
        // FUTURE: add nested Object support
        // FUTURE: add patch() method?

        // Property adds its difference(s) to "d".
        property.diffProperty(this, other, d, property);
      }

      return d;
    },

    /**
      Create an integer hash code value based on all properties of this object.
    */
    function hashCode() {
      var hash = 17;

      var ps = this.cls_.getAxiomsByClass(foam.core.Property);
      for ( var i = 0 ; i < ps.length ; i++ ) {
        var prop = this[ps[i].name];
        hash = ((hash << 5) - hash) + foam.util.hashCode(prop);
        hash &= hash; // forces 'hash' back to a 32-bit int
      }

      return hash;
    },

    function clone(opt_X) {
      /** Create a deep copy of this object. **/
      var m = {};
      for ( var key in this.instance_ ) {
        if ( this.instance_[key] === undefined ) continue; // Skip previously cleared keys.

        var value = this[key];
        this.cls_.getAxiomByName(key).cloneProperty(value, m);
      }
      return this.cls_.create(m, opt_X || this.__context__);
    },

    /**
      Copy property values from the supplied object or map.

      Ex.
<pre>
  person.copyFrom({fName: 'John', lName: 'Smith', age: 42})
  or
  person.copyFrom(otherPerson);
</pre>
     The first example is short-form for:
<pre>
  person.fName = 'John';
  person.lName = 'Smith';
  person.age   = 42;
</pre>
     If an FObject is supplied, it doesn't need to be the same class as 'this'.
     Only properties that the two classes have in common will be copied.
     Null or undefined values are ignored.
     */
    function copyFrom(o, opt_warn) {
      if ( ! o ) return this;

      // When copying from a plain map, just enumerate the keys
      if ( o.__proto__ === Object.prototype || ! o.__proto__ ) {
        for ( var key in o ) {
          var name = key.endsWith('$') ?
              key.substring(0, key.length - 1) :
              key ;

          var a = this.cls_.getAxiomByName(name);
          if ( a && foam.core.Property.isInstance(a) ) {
            this[key] = o[key];
          } else if ( opt_warn ) {
            this.unknownArg(key, o[key]);
          }
        }
        return this;
      }

      // When copying from an object of the same class
      // We don't copy default values or the values of expressions
      // so that the unset state of those properties is preserved
      var props = this.cls_.getAxiomsByClass(foam.core.Property);

      if ( o.cls_ && ( o.cls_ === this.cls_ || o.cls_.isSubClass(this.cls_) ) ) {
        for ( var i = 0 ; i < props.length ; i++ ) {
          var name = props[i].name;

          // Only copy values that are set or have a factory.
          // Any default values or expressions will be the same
          // for each object since they are of the exact same
          // type.
          if ( o.hasOwnProperty(name) || props[i].factory ) {
            this[name] = o[name];
          }
        }
        return this;
      }

      // If the source is an FObject, copy any properties
      // that we have in common.
      if ( foam.core.FObject.isInstance(o) ) {
        for ( var i = 0 ; i < props.length ; i++ ) {
          var name = props[i].name;
          var otherProp = o.cls_.getAxiomByName(name);
          if ( otherProp && foam.core.Property.isInstance(otherProp) ) {
            this[name] = o[name];
          }
        }
        return this;
      }

      // If the source is some unknown object, we do our best
      // to copy any values that are not undefined.
      for ( var i = 0 ; i < props.length ; i++ ) {
        var name = props[i].name;
        if ( typeof o[name] !== 'undefined' ) {
          this[name] = o[name];
        }
      }
      return this;
    },

    function toString() {
      // Distinguish between prototypes and instances.
      return this.cls_.id + (
          this.cls_.prototype === this ? 'Proto' : '');
    },

    function dot(name) {
      // Behaves just like Slot.dot().  Makes it easy for creating sub-slots
      // without worrying if you're holding an FObject or a slot.
      return this[name + '$'];
    }
  ]
});
/**
 * @license
 * Copyright 2016 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/** Class/Prototype description. */
foam.CLASS({
  package: 'foam.core',
  name: 'Model',

  documentation: 'A Class Model (description).',

  properties: [
    {
      name: 'id',
      hidden: true,
      transient: true,
      getter: function() {
        return this.package ? this.package + '.' + this.name : this.name;
      }
    },
    'package',
    'abstract',
    'name',
    {
      name: 'flags',
      factory: function() { return {}; }
    },
    {
      name: 'label',
      expression: function(name) { return foam.String.labelize(name); }
    },
    [ 'extends', 'FObject' ],
    'refines',
    { name: 'documentation', adapt: function(_, d) { return typeof d === 'function' ? foam.String.multiline(d).trim() : d; } },
    {
      // List of all axioms, including methods, properties, listeners,
      // etc. and 'axioms'.
      name: 'axioms_',
      transient: true,
      hidden: true,
      factory: function() { return []; }
    },
    {
      // List of extra axioms. Is added to axioms_.
      name: 'axioms',
      hidden: true,
      factory: function() { return []; },
      postSet: function(_, a) { this.axioms_.push.apply(this.axioms_, a); }
    },
    {
      // Is upgraded to an AxiomArray later.
      of: 'Property',
      name: 'properties'
    },
    {
      // Is upgraded to an AxiomArray later.
      of: 'Method',
      name: 'methods'
    }
  ],

  methods: [ foam.boot.buildClass ]
});
/**
 * @license
 * Copyright 2016 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
  A Property is a high-level instance variable.

  Properties contain more information than typical variable declarations.
  Such as: label, help text, pre/post-set callbacks, default value,
  value factory, units, etc.

  When setting a Propery's value, the callback order is:
    1. adapt()
    2. assertValue()
    3. preSet()
       value updated
       property change event fired
    4. postSet()

   Unless the user has provided a customer 'setter', in which case the order is
     1. setter()

  A sub-class or refinement can include a partial Property definition which
  will override or add meta-information to the Property.
**/
foam.CLASS({
  package: 'foam.core',
  name: 'Property',
  extends: 'FObject',

  properties: [
    {
      name: 'name',
      required: true
    },
    {
      name: 'label',
      // If not provided, it defaults to the name "labelized".
      expression: function(name) { return foam.String.labelize(name); }
    },

    /* Developer-level documentation. */
    'documentation',

    /* User-level help. Could/should appear in GUI's as online help. */
    'help',

    /* Hidden properties to not appear in GUI's by default. */
    { class: 'Boolean', name: 'hidden' },

    /**
      The default-value of this property.
      A property which has never been set or has been cleared
      by setting it to 'undefined' or cleared with clearProperty()
      will have the default value.
    */
    'value',

    /**
      A factory is a function which initializes the property value
      when accessed for the first time, if not already set.
    */
    'factory',

    /**
      A function of the form:
        Object function(oldValue, newValue)
      adapt is called whenver the property is set. It's intended
      to adapt the value to the appropriate type if required.
      Adapt must return a value. It can return newValue unchanged
      if it was already the appropriate type.
    */
    'adapt',

    /**
      A function of the form:
        Object function(oldValue, newValue)
      preSet is called before the propery's value is updated.
      It can veto the value change by returning a different newValue
      (including returning oldValue to leave the property unchanged).
    */
    'preSet',

    /**
      A function of the form:
        void function(oldValue, newValue) throws Exception
      assertValue can validate newValue and throw an exception if it's an
      invalid value.
    */
    'assertValue',

    /**
      A function of the form:
        void function(oldValue, newValue)
      postSet is called after the Property's value has been updated.
    */
    'postSet',

    /**
      A dynamic function which defines this Property's value.
      Similar to 'factory', except that the function takes arguments
      which are named the same as other properties of this object.
      Whenever the values of any of the argument properties change,
      the value of this Property is invalidated. Like a regular factory,
      an invalidated property will be recalculated by calling the provided
      expression function when accessed. This makes expressions very efficient
      because the value is only recomputed when actually needed.
    */
    'expression',

    /**
      A getter function which completely replaces the normal
      Property getter process. Whenever the property is accessed, getter is
      called and its value is returned.
    */
    'getter',

    /**
      A setter function which completely replaces the normal
      Property setter process. Whenever the property is set, setter is
      called.
      A function of the form:
        void function(newValue)
    */
    'setter',

    [ 'cloneProperty', function(
      /* any // The value to clone */         value,
      /* object // Add values to this map to
         have them installed on the clone. */ cloneMap
      ) {
        /** Override to provide special deep cloning behavior. */
        cloneMap[this.name] = ( value && value.clone ) ? value.clone() :
          foam.util.clone(value);
      }
    ],

    /**
      A final Property can only be set once.
      After being set, its value is final (read-only).
    */
    'final',

    /**
      A required Property can not be set to null, undefined, 0 or "".
     */
    'required',

    /**
      When set, marks the property with the given flags. This can be used for
      things like stripping out platform specific properties when serializing.
     */
    'flags',

    [
      /**
        Called to convert a string into a value suitable for this property.
        Eg. this might convert strings to numbers, or parse RFC 2822 timestamps.
        By default it simply returns the string unchanged.
       */
      'fromString',
      function(str) { return str; }
    ],

    [
      /**
        Compare two values taken from this property.
        <p>Used by Property.compare().
        It is a property rather than a method so that it can be configured
        without subclassing.
      */
      'comparePropertyValues',
      function(o1, o2) { return foam.util.compare(o1, o2); }
    ],

    [
      'isDefaultValue',
      function(v) { return ! this.comparePropertyValues(this.value, v); }
    ],

    {
      /** Makes Properties useful as map functions. */
      name: 'f',
      transient: true,
      factory: function() {
        var name = this.name;
        return function f(o) { return o[name]; }
      }
    },

    {
      /** Makes Properties useful as comparators. */
      name: 'compare',
      transient: true,
      factory: function() {
        var comparePropertyValues = this.comparePropertyValues;
        var f = this.f;
        return function compare(o1, o2) {
          return comparePropertyValues(f(o1), f(o2));
        };
      }
    },
    // FUTURE: Move to refinement?
    {
      name: 'diffPropertyValues',
      transient: true,
      value: function(v1, v2, diff) {
        // TODO: instead of array check, have different implementation in ArrayProperty
        if ( Array.isArray(v1) ) {
          var subdiff = foam.Array.diff(v1, v2);
          if ( subdiff.added.length !== 0 || subdiff.removed.length !== 0 ) {
            diff[this.name] = subdiff;
          }
        } else if ( ! foam.util.equals(v1, v2) ) {
          // if the primary value is undefined, use the compareTo of the other
          diff[this.name] = v2;
        }
        return diff;
      }
    },
    {
      name: 'diffProperty',
      transient: true,
      value: function diffProperty(o1, o2, diff, prop) {
        return prop.diffPropertyValues(prop.f(o1), prop.f(o2), diff);
      }
    },
    {
      name: 'forClass_',
      transient: true
    },
  ],

  methods: [
    /**
      Handle overriding of Property definition from parent class by
      copying undefined values from parent Property, if it exists.
    */
    function installInClass(c, superProp, existingProp) {
      var prop = this;

      if ( superProp && foam.core.Property.isInstance(superProp) ) {
        prop = superProp.createChildProperty_(prop);

        // If properties would be shadowed by superProp properties, then
        // clear the shadowing property since the new value should
        // take precedence since it was set later.
        var es = foam.core.Property.SHADOW_MAP || {};
        for ( var key in es ) {
          var e = es[key];
          for ( var j = 0 ; j < e.length ; j++ ) {
            if ( this.hasOwnProperty(e[j]) && superProp[key] ) {
              prop.clearProperty(key);
              break;
            }
          }
        }

        c.axiomMap_[prop.name] = prop;
      }

      if ( this.forClass_ && this.forClass_ !== c.id && prop === this ) {
        // Clone this property if it's been installed before.
        prop = this.clone();
        c.axiomMap_[prop.name] = prop;
      }

      prop.forClass_ = c.id;

      // var reinstall = foam.events.oneTime(function reinstall(_,_,_,axiom) {
      //   // We only care about Property axioms.

      //   // FUTURE: we really only care about those properties that affect
      //   // the definition of the property getter and setter, so an extra
      //   // check would help eliminate extra reinstalls.

      //   // Handle special case of axiom being installed into itself.
      //   // For example foam.core.String has foam.core.String axioms for things
      //   // like "label"
      //   // In the future this shouldn't be required if a reinstall is
      //   // only triggered on this which affect getter/setter.
      //   if ( prop.cls_ === c ) {
      //     return;
      //   }

      //   if ( foam.core.Property.isInstance(axiom) ) {
      //     // console.log('**************** Updating Property: ', c.name, prop.name);
      //     c.installAxiom(prop);
      //   }
      // });

      // // If the superProp is updated, then reinstall this property
      // c.__proto__.pubsub_ && c.__proto__.pubsub_.sub(
      //   'installAxiom',
      //   this.name,
      //   reinstall
      // );

      // // If the class of this Property changes, then also reinstall
      // if (
      //   c.id !== 'foam.core.Property' &&
      //   c.id !== 'foam.core.Model'    &&
      //   c.id !== 'foam.core.Method'   &&
      //   c.id !== 'foam.core.FObject'  &&
      //   this.cls_.id !== 'foam.core.FObject'
      // ) {
      //   this.cls_.pubsub_.sub('installAxiom', reinstall);
      // }

      c.installConstant(prop.name, prop);
    },

    /**
      Install a property onto a prototype from a Property definition.
      (Property is 'this').
    */
    function installInProto(proto) {
      // Take Axiom from class rather than using 'this' directly,
      // since installInClass() may have created a modified version
      // to inherit Property Properties from a super-Property.
      var prop        = proto.cls_.getAxiomByName(this.name);
      var name        = prop.name;
      var adapt       = prop.adapt
      var assertValue = prop.assertValue;
      var preSet      = prop.preSet;
      var postSet     = prop.postSet;
      var factory     = prop.factory;
      var getter      = prop.getter;
      var value       = prop.value;
      var hasValue    = typeof value !== 'undefined';
      var slotName    = name + '$';
      var isFinal     = prop.final;
      var eFactory    = this.exprFactory(prop.expression);
      var FIP         = factory && ( prop.name + '_fip' ); // Factory In Progress
      var fip         = 0;

      // Factory In Progress (FIP) Support
      // When a factory method is in progress, the object sets a private
      // flag named by the value in FIP.
      // This allows for the detection and elimination of
      // infinite recursions (if a factory accesses another property
      // which in turn tries to access its propery) and allows for
      // the property change event to not be fired when the value
      // is first set by the factory (since the value didn't change,
      // the factory is providing its original value).
      // However, this is expensive, so we keep a global 'fip' variable
      // which indicates that the factory is already being called on any
      // object and then we only track on a per-instance basis when this
      // is on. This eliminates almost all per-instance FIP checks.

      // Property Slot
      // This costs us about 4% of our boot time.
      // If not in debug mode we should share implementations like in F1.
      //
      // Define a PropertySlot accessor (see Slot.js) for this Property.
      // If the property is named 'name' then 'name$' will access a Slot
      // for this Property. The Slot is created when first accessed and then
      // cached.
      // If the Slot is set (to another slot) the two Slots are link()'ed
      // together, meaning they will now dynamically share the same value.
      Object.defineProperty(proto, slotName, {
        get: function propertySlotGetter() {
          return prop.toSlot(this);
        },
        set: function propertySlotSetter(slot2) {
          prop.toSlot(this).linkFrom(slot2);
        },
        configurable: true,
        enumerable: false
      });

      // Define Property getter and setter based on Property properties.
      // By default, getter and setter stores instance value for property
      // in this.instance_[<name of property>],
      // unless the user provides custom getter and setter methods.

      // Getter
      // Call 'getter' if provided, else return value from instance_ if set.
      // If not set, return value from 'factory', 'expression', or
      // (default) 'value', if provided.
      var get =
        getter ? function() { return getter.call(this, prop); } :
        factory ? function factoryGetter() {
          var v = this.instance_[name];
          if ( v !== undefined ) return v;
          // Indicate the Factory In Progress state
          if ( fip > 10 && this.getPrivate_(FIP) ) {
            console.warn('reentrant factory for property:', name);
            return undefined;
          }

          var oldFip = fip;
          fip++;
          if ( oldFip === 10 ) this.setPrivate_(FIP, true);
          v = factory.call(this, prop);
          // Convert undefined to null because undefined means that the
          // value hasn't been set but it has. Setting it to undefined
          // would prevent propertyChange events if the value were cleared.
          this[name] = v === undefined ? null : v;
          if ( oldFip === 10 ) this.clearPrivate_(FIP);
          fip--;

          return this.instance_[name];
        } :
        eFactory ? function eFactoryGetter() {
          return this.hasOwnProperty(name) ? this.instance_[name]   :
                 this.hasOwnPrivate_(name) ? this.getPrivate_(name) :
                 this.setPrivate_(name, eFactory.call(this)) ;
        } :
        hasValue ? function valueGetter() {
          var v = this.instance_[name];
          return v !== undefined ? v : value ;
        } :
        function simpleGetter() { return this.instance_[name]; };

      var set = prop.setter ? prop.setter :
        ! ( postSet || factory || eFactory || adapt || assertValue || preSet || isFinal ) ?
        function simplePropSetter(newValue) {
          if ( newValue === undefined ) {
            this.clearProperty(name);
            return;
          }

          var oldValue = this.instance_[name] ;
          this.instance_[name] = newValue;
          this.pubPropertyChange_(prop, oldValue, newValue);
        }
        : factory && ! ( postSet || eFactory || adapt || assertValue || preSet || isFinal ) ?
        function factoryPropSetter(newValue) {
          if ( newValue === undefined ) {
            this.clearProperty(name);
            return;
          }

          var oldValue = this.hasOwnProperty(name) ? this[name] : undefined;

          this.instance_[name] = newValue;

          // If this is the result of a factory setting the initial value,
          // then don't fire a property change event, since it hasn't
          // really changed.
          if ( oldValue !== undefined )
            this.pubPropertyChange_(prop, oldValue, newValue);
        }
        :
        function propSetter(newValue) {
          // ???: Should clearProperty() call set(undefined)?
          if ( newValue === undefined ) {
            this.clearProperty(name);
            return;
          }

          // Getting the old value but avoid triggering factory or expression if
          // present. Factories and expressions (which are also factories) can be
          // expensive to generate, and if the value has been explicitly set to
          // some value, then it isn't worth the expense of computing the old
          // stale value.
          var oldValue =
            factory  ? ( this.hasOwnProperty(name) ? this[name] : undefined ) :
            eFactory ?
                ( this.hasOwnPrivate_(name) || this.hasOwnProperty(name) ?
                  this[name] :
                  undefined ) :
            this[name] ;

          if ( adapt ) newValue = adapt.call(this, oldValue, newValue, prop);

          if ( assertValue ) assertValue.call(this, newValue, prop);

          if ( preSet ) newValue = preSet.call(this, oldValue, newValue, prop);

          // ???: Should newValue === undefined check go here instead?

          this.instance_[name] = newValue;

          if ( isFinal ) {
            Object.defineProperty(this, name, {
              value: newValue,
              writable: false,
              configurable: true // ???: is this needed?
            });
          }

          // If this is the result of a factory setting the initial value,
          // then don't fire a property change event, since it hasn't
          // really changed.
          if ( ! factory || oldValue !== undefined )
            this.pubPropertyChange_(prop, oldValue, newValue);

          // FUTURE: pub to a global topic to support dynamic()

          if ( postSet ) postSet.call(this, oldValue, newValue, prop);
        };

      Object.defineProperty(proto, name, {
        get: get,
        set: set,
        configurable: true
      });
    },

    /** Validate an object which has this Property. */
    function validateInstance(o) {
      if ( this.required && ! o[this.name] ) {
        throw 'Required property ' +
            o.cls_.id + '.' + this.name +
            ' not defined.';
      }
    },

    /**
     * Create a factory function from an expression function.
     * Function arguments are validated in debug.js.
     **/
    function exprFactory(e) {
      if ( ! e ) return null;

      var argNames = foam.Function.argNames(e);
      var name     = this.name;

      // FUTURE: determine how often the value is being invalidated,
      // and if it's happening often, then don't unsubscribe.
      return function exportedFactory() {
        var self = this;
        var args = new Array(argNames.length);
        var subs = [];
        var l    = function() {
          if ( ! self.hasOwnProperty(name) ) {
            var oldValue = self[name];
            self.clearPrivate_(name);

            // Avoid creating slot and publishing event if no listeners
            if ( self.hasListeners('propertyChange', name) ) {
              self.pub('propertyChange', name, self.slot(name));
            }
          }
          for ( var i = 0 ; i < subs.length ; i++ ) subs[i].detach();
        };
        for ( var i = 0 ; i < argNames.length ; i++ ) {
          var slot = this.slot(argNames[i]);
          // This check was introduced to handle optional imports not having a
          // slot when the import isn't found in the context.
          if (slot) {
            var s = slot.sub(l);
            s && subs.push(s);
            args[i] = slot.get();
          }
        }
        var ret = e.apply(this, args);
        if ( ret === undefined ) this.warn('Expression returned undefined: ', e);
        return ret;
      };
    },

    /** Returns a developer-readable description of this Property. **/
    function toString() { return this.name; },

    /** Flyweight getter for this Property. **/
    function get(o) { return o[this.name]; },

    /** Flyweight setter for this Property. **/
    function set(o, value) {
      o[this.name] = value;
      return this;
    },

    /**
     * Handles property inheritance.  Builds a new version of
     * this property to be installed on classes that inherit from
     * this but define their own property with the same name as this.
     */
    function createChildProperty_(child) {
      var prop = this.clone();

      if ( child.cls_ !== foam.core.Property &&
           child.cls_ !== this.cls_ )
      {
        if ( this.cls_ !== foam.core.Property ) {
          this.warn('Unsupported change of property type from', this.cls_.id, 'to', child.cls_.id);
        }

        return child;
      }

      prop.sourceCls_ = child.sourceCls_;

      for ( var key in child.instance_ ) {
        prop.instance_[key] = child.instance_[key];
      }

      return prop;
    },

    function exportAs(obj, sourcePath) {
      /** Export obj.name$ instead of just obj.name. */

      var slot = this.toSlot(obj);

      for ( var i = 0 ; sourcePath && i < sourcePath.length ; i++ ) {
        slot = slot.dot(sourcePath[i]);
      }

      return slot;
    },

    function toSlot(obj) {
      /** Create a Slot for this Property. */
      var slotName = this.slotName_ || ( this.slotName_ = this.name + '$' );
      var slot     = obj.getPrivate_(slotName);

      if ( ! slot ) {
        slot = foam.core.internal.PropertySlot.create();
        slot.obj  = obj;
        slot.prop = this;
        obj.setPrivate_(slotName, slot);
      }

      return slot;
    }
  ]
});


/**
  A Simple Property skips the regular FOAM Property getter/setter/instance_
  mechanism. In gets installed on the CLASS as a Property constant, but isn't
  added to the prototype at all. From this point of view, it's mostly just for
  documentation. Simple Properties are used only in special cases to maximize
  performance and/or minimize memory use.
  Used for MDAO indices and Slots.

  USE WITH EXTREME CAUTION (OR NOT AT ALL).
*/
foam.CLASS({
  package: 'foam.core',
  name: 'Simple',
  extends: 'Property',

  methods: [
    function installInProto(proto) {}
  ]
});
/**
 * @license
 * Copyright 2016 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
<p>
  Methods are only installed on the prototype.
  If the method is overriding a method from a parent class,
  then SUPER support is added.

<p>
  Ex.
<pre>
  foam.CLASS({
    name: 'Parent',
    methods: [
      // short-form
      function sayHello() { console.log('hello'); },

      // long-form
      {
        name: 'sayGoodbye',
        code: function() { console.log('goodbye'); }
      }
    ]
  });

  // Create a subclass of Parent and override the 'sayHello' method.
  // The parent classes 'sayHello' methold is called with 'this.SUPER()'
  foam.CLASS({
    name: 'Child',
    extends: 'Parent',
    methods: [
      function sayHello() { this.SUPER(); console.log('world'); }
    ]
  });

  Child.create().sayHello();
  >> hello
  >> world
</pre>
*/
foam.CLASS({
  package: 'foam.core',
  name: 'AbstractMethod',

  properties: [
    { name: 'name', required: true },
    { name: 'code', required: false },
    'documentation',
    'returns',
    {
      name: 'args',
      factory: function() { return this.code ? foam.Function.args(this.code) : []; }
    }
  ],

  methods: [
    /**
      Decorate a method so that it can call the
      method it overrides with this.SUPER().
    */
    function override_(proto, method, superMethod) {
      if ( ! method ) return;

      // Not using SUPER, so just return original method
      if ( method.toString().indexOf('SUPER') == -1 ) return method;

      var superMethod_ = proto.cls_.getSuperAxiomByName(this.name);
      var super_;

      if ( ! superMethod_ ) {
        var name = this.name;

        // This method itself provides a false-posistive because
        // it references SUPER(), so ignore.
        if ( name !== 'override_' ) {
          super_ = function() {
            console.warn(
                'Attempted to use SUPER() in',
                name, 'on', proto.cls_.id, 'but no parent method exists.');
          };

          // Generate warning now.
          super_();
        }
      } else {
        foam.assert(foam.core.AbstractMethod.isInstance(superMethod_),
          'Attempt to override non-method', this.name, 'on', proto.cls_.id);

        // Fetch the super method from the proto, as the super method axiom
        // may have decorated the code before installing it.
        super_ = proto.__proto__[this.name];
      }

      function SUPER() { return super_.apply(this, arguments); }

      var f = function superWrapper() {
        var oldSuper = this.SUPER;
        this.SUPER = SUPER;

        try {
          return method.apply(this, arguments);
        } finally {
          this.SUPER = oldSuper;
        }

        return ret;
      };

      foam.Function.setName(f, this.name);
      f.toString = function() { return method.toString(); };

      return f;
    },

    function createChildMethod_(child) {
      /**
        Template method for use by Method subclasses.
        (Used by JavaSource.)
      */
      return child;
    },

    function installInClass(cls, superMethod, existingMethod) {
      var method = this;

      var parent = superMethod;
      if ( parent && foam.core.AbstractMethod.isInstance(parent) ) {
        method = parent.createChildMethod_(method);
      }

      cls.axiomMap_[method.name] = method;
    }
  ]
});


foam.CLASS({
  package: 'foam.core',
  name: 'Method',
  extends: 'foam.core.AbstractMethod',

  methods: [
    function installInProto(proto, superAxiom) {
      proto[this.name] = this.override_(proto, this.code, superAxiom);
    },

    function exportAs(obj) {
      var m = obj[this.name];
      /** Bind the method to 'this' when exported so that it still works. **/
      return function exportedMethod() { return m.apply(obj, arguments); };
    }
  ]
});


foam.boot.phase2();
/**
 * @license
 * Copyright 2016 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

foam.CLASS({
  package: 'foam.core',
  name: 'Boolean',
  extends: 'Property',

  documentation: 'A Property for Boolean values.',

  properties: [
    [ 'value', false ],
    [ 'adapt', function adaptBoolean(_, v) { return !!v; } ]
  ]
});
/**
 * @license
 * Copyright 2016 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

foam.CLASS({
  package: 'foam.core',
  name: 'AxiomArray',
  extends: 'Property',

  documentation: 'An Array of Axioms (used by Model) whose elements are added to this.axioms_.',

  properties: [
    {
      name: 'of',
      required: true
    },
    {
      name: 'adapt',
      value: function(_, a, prop) {
        if ( ! Array.isArray(a) ) return a;

        var copy;
        for ( var i = 0 ; i < a.length ; i++ ) {
          var b = prop.adaptArrayElement.call(this, a[i], prop);
          if ( b !== a[i] ) {
            if ( ! copy ) copy = a.slice();
            copy[i] = b;
          }
        }

        return copy || a;
      }
    },
    {
      name: 'assertValue',
      value: function(v, prop) {
        foam.assert(Array.isArray(v),
            'Tried to set', prop.name, 'to non array value');

        var of = this.lookup(prop.of, true);
        foam.assert(
            of,
            'Unknown "of" Model in AxiomArray: property=',
            prop.name,
            ' of=',
            prop.of);
        for ( var i = 0 ; i < v.length ; i++ ) {
          foam.assert(of.isInstance(v[i]),
              'Element', i, 'of', prop.name, 'is not an instance of',
              prop.of);
        }
      }
    },
    {
      name: 'adaptArrayElement',
      value: function(a, prop) {
        var of = this.lookup(prop.of);
        return of.isInstance(a) ? a : of.create(a, this);
      }
    },
    [ 'postSet', function(_, a) { this.axioms_.push.apply(this.axioms_, a); } ]
  ]
});
/**
 * @license
 * Copyright 2016 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Map of Property property names to arrays of names of properties that they shadow.
 *
 * Ex. 'setter' has higher precedence than 'adapt', 'preSet', and 'postSet', so if
 * it is set, then it shadows those other properties if they are set, causing their
 * values to be ignored.
 *
 * Not defined as a constant, because they haven't been defined yet.
 */
foam.core.Property.SHADOW_MAP = {
  setter:     [ 'adapt', 'preSet', 'postSet' ],
  getter:     [ 'factory', 'expression', 'value' ],
  factory:    [ 'expression', 'value' ],
  expression: [ 'value' ]
};


/** Add new Axiom types (Implements, Constants, Topics, Properties, Methods and Listeners) to Model. */
foam.CLASS({
  refines: 'foam.core.Model',

  properties: [
    {
      class: 'AxiomArray',
      of: 'Property',
      name: 'properties',
      adaptArrayElement: function(o) {
        if ( typeof o === 'string' ) {
          var p = foam.core.Property.create();
          p.name = o;
          return p;
        }

        if ( Array.isArray(o) ) {
          var p = foam.core.Property.create();
          p.name  = o[0];
          p.value = o[1];
          return p;
        }

        if ( o.class ) {
          var m = this.lookup(o.class);
          if ( ! m ) throw 'Unknown class : ' + o.class;
          return m.create(o, this);
        }

        return foam.core.Property.isInstance(o) ? o : foam.core.Property.create(o);
      }
    },
    {
      class: 'AxiomArray',
      of: 'Method',
      name: 'methods',
      adaptArrayElement: function(o, prop) {
        if ( typeof o === 'function' ) {
          var name = foam.Function.getName(o);
          foam.assert(name, 'Method must be named');
          var m = this.lookup(prop.of).create();
          m.name = name;
          m.code = o;
          return m;
        }
        if ( this.lookup(prop.of).isInstance(o) ) return o;
        if ( o.class ) return this.lookup(o.class).create(o, this);
        return foam.lookup(prop.of).create(o);
      }
    }
  ]
});


foam.boot.phase3();


foam.CLASS({
  refines: 'foam.core.FObject',

  documentation: 'Upgrade FObject to fully bootstraped form.',

  axioms: [
    {
      name: '__context__',
      installInProto: function(p) {
        Object.defineProperty(p, '__context__', {
          get: function() {
            var x = this.getPrivate_('__context__');
            if ( ! x ) {
              var contextParent = this.getPrivate_('contextParent');
              if ( contextParent ) {
                this.setPrivate_(
                    '__context__',
                    x = contextParent.__subContext__ || contextParent.__context__);
                this.setPrivate_('contextParent', undefined);
              } else {
                // Happens during bootstrap with Properties.
                x = foam.__context__;
              }
            }
            return x;
          },
          set: function(x) {
            if ( x ) {
              this.setPrivate_(
                  foam.core.FObject.isInstance(x) ?
                      'contextParent' :
                      '__context__',
                  x);
            }
          }
        });

        // If no delcared exports, then sub-context is the same as context.
        Object.defineProperty(
            p,
            '__subContext__',
            {
              get: function() { return this.__context__; },
              set: function() {
                throw new Error(
                    'Attempted to set unsettable __subContext__ in ' +
                    this.cls_.id);
              }
            });
      }
    }
  ],

  methods: [
    /**
      Called to process constructor arguments.
      Replaces simpler version defined in original FObject definition.
    */
    function initArgs(args, ctx) {
      if ( ctx  ) this.__context__ = ctx;
      if ( args ) this.copyFrom(args, true);
    },

    /**
      Template method used to report an unknown argument passed
      to a constructor. Is set in debug.js.
    */
    function unknownArg(key, value) {
      // NOP
    },

    function lookup() { return this.__context__.lookup.apply(this.__context__, arguments); },
  ]
});

foam.boot.end();


/**
  Refine foam.core.Property to add 'transient' support.

  A transient Property is not intended to be persisted
  or transfered over the network.

  Ex. A computed Property could be made transient to avoid
  wasting disk space or network bandwidth.

  For finer control, there are also separate properties called
  'networkTransient' and 'storageTransient', which default to
  the value of 'transient' if not explicitly set.

  A networkTransient field is not marshalled over network calls.
  foam.json.Network does not encode networkTransient fields.

  A storageTransient field is not stored to persistent storage.
  foam.json.Storage does not encode storageTransient fields.
 */
foam.CLASS({
  refines: 'foam.core.Property',

  properties: [
    {
      class: 'Boolean',
      name: 'transient'
    },
    {
      class: 'Boolean',
      name: 'networkTransient',
      expression: function(transient) {
        return transient;
      }
    },
    {
      class: 'Boolean',
      name: 'storageTransient',
      expression: function(transient) {
        return transient;
      }
    }
  ]
});


/**
 * Replace foam.CLASS() with a lazy version which only
 * build the class when first accessed.
 */
(function() {
  // List of unused Models in the system.
  foam.USED      = {};
  foam.UNUSED    = {};

  var CLASS = foam.CLASS;

  foam.CLASS = function(m) {
    if ( ! m.source && global.document && global.document.currentScript ) {
      m.source = global.document.currentScript.src;
    }

    if ( m.refines ) return CLASS(m);

    m.id = m.package ? m.package + '.' + m.name : m.name;
    foam.UNUSED[m.id] = true;

    var f = foam.Function.memoize0(function() {
      delete foam.UNUSED[m.id];
      var c = CLASS(m);
      foam.USED[m.id] = c;
      return c;
    });

    foam.__context__.registerFactory(m, f);
    foam.package.registerClassFactory(m, f);
  };
})();
/**
 * @license
 * Copyright 2016 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

foam.CLASS({
  package: 'foam.core',
  name: 'FObjectArray',
  extends: 'Property',

  documentation: "A Property which contains an array of 'of' FObjects.",

  properties: [
    { name: 'of', required: true },
    [
      'factory',
      function() { return []; }
    ],
    [ 'adapt', function(_, /* array? */ a, prop) {
        if ( ! a ) return [];
        // If not an array, allow assertValue to assert the type-check.
        if ( ! Array.isArray(a) ) return a;

        var b = new Array(a.length);
        for ( var i = 0 ; i < a.length ; i++ ) {
          b[i] = prop.adaptArrayElement(a[i], this);
        }
        return b;
      }
    ],
    [ 'assertValue', function(v, prop) {
        foam.assert(Array.isArray(v),
            prop.name, 'Attempt to set array property to non-array value', v);
      }
    ],
    [ 'adaptArrayElement', function(o, obj) {
      // FUTURE: replace 'foam.' with '(this.__subContext__ || foam).' ?
      var ctx = obj.__subContext__ || foam;
      var of = o.class || this.of;
      var cls = ctx.lookup(of);
      return cls.isInstance(o) ? o : cls.create(o, obj);
    }],
    {
      name: 'fromJSON',
      value: function(value, ctx, prop) {
        return foam.json.parse(value, prop.of, ctx);
      }
    }
  ]
});
/**
 * @license
 * Copyright 2016 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
  Constants are installed on both the prototype and class.
<pre>
  Ex.
  constants: {
    KEY: 'some value'
  }

  this.cls_.KEY === this.KEY === 'some value'
</pre>
*/
foam.CLASS({
  package: 'foam.core',
  name: 'Constant',

  documentation: 'An Axiom for defining class constants.',

  properties: [
    'name',
    {
      name: 'value',
      factory: function() {
        return this.factory();
      },
    },
    'factory',
    'documentation',
  ],

  methods: [
    function installInClass(cls) {
      Object.defineProperty(
        cls,
        foam.String.constantize(this.name),
        {
          value: this.value,
          configurable: false
        });
    },
    function installInProto(proto) {
      this.installInClass(proto);
    }
  ]
});


foam.CLASS({
  refines: 'foam.core.Model',
  properties: [
    {
      class: 'AxiomArray',
      of: 'Constant',
      name: 'constants',
      adapt: function(_, a, prop) {
        if ( ! a ) return [];
        if ( ! Array.isArray(a) ) {
          var cs = [];
          for ( var key in a ) {
            cs.push(foam.core.Constant.create({name: key, value: a[key]}));
          }
          return cs;
        }
        var b = new Array(a.length);
        for ( var i = 0 ; i < a.length ; i++ ) {
          b[i] = prop.adaptArrayElement.call(this, a[i], prop);
        }
        return b;
      }
    }
  ]
});
/**
 * @license
 * Copyright 2016 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

foam.CLASS({
  refines: 'foam.core.Property',

  properties: [
    {
      name: 'validateObj',
      expression: function(name, label, required) {
        return !required ? null : [[name],
          function() {
            return !this.hasOwnProperty(name) && (label + ' is required.');
          }]
      },
    },
  ]
});


foam.CLASS({
  package: 'foam.core.internal',
  name: 'Errors',
//  extends: 'foam.core.Property',

  documentation: `
    A psedo-Property Axiom added to FObject which contains an object\'s validation errors.
    Adds the following attributes to an Object:
    <dl>
      <dt>errors_</dt><dd>list of current errors</dd>
      <dt>errors_$</dt><dd>Slot representation of errors_</dd>
      <dt>validateObject()</dt><dd>calls the validateObj() method of all property Axioms, allowing them to populate errors_</dd>
    </dl>
  `,

  properties: [
    [ 'name', 'errors_' ]
  ],

  methods: [
    function installInProto(proto) {
      var self = this;
      Object.defineProperty(proto, 'errors_', {
        get: function() {
          return self.toSlot(this).get();
        },
        configurable: true,
        enumerable: false
      });

      Object.defineProperty(proto, 'errors_$', {
        get: function() {
          return self.toSlot(this);
        },
        configurable: true,
        enumerable: false
      });
    },

    function toSlot(obj) {
      var slotName = this.slotName_ || ( this.slotName_ = this.name + '$' );
      var slot     = obj.getPrivate_(slotName);

      if ( ! slot ) {
        slot = this.createErrorSlot_(obj)
        obj.setPrivate_(slotName, slot);
      }

      return slot;
    },

    function createErrorSlot_(obj) {
      var args = [];
      var ps   = obj.cls_.getAxiomsByClass(foam.core.Property).
        filter(function(a) { return a.validateObj; });

      for ( var i = 0 ; i < ps.length ; i++ ) {
        var p = ps[i];
        args.push(obj.slot(p.validateObj));
      }

      function validateObject() {
        var ret;

        for ( var i = 0 ; i < ps.length ; i++ ) {
          var p = ps[i];
          var err = args[i].get();
          if ( err ) (ret || (ret = [])).push([p, err]);
        }

        return ret;
      }

      return foam.core.ExpressionSlot.create({
        obj: obj,
        code: validateObject,
        args: args});
    }
  ]
});


foam.CLASS({
  refines: 'foam.core.FObject',

  axioms: [
    foam.core.internal.Errors.create()
  ]
});
/**
 * @license
 * Copyright 2017 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
  A Faceted Axiom, when added to a Class, makes it implement
  the Facet-Manager Pattern, meaning that calls to create() can
  be intercepted and return a special Facet class depending on the
  value of the 'of' create argument.

  Ex.:
  foam.CLASS({
    name: 'View',
    axioms: [ foam.pattern.Faceted.create() ],
    properties: [ 'of' ],
    methods: [ function view() { return 'default' } ]
  });

  foam.CLASS({name: 'A'});
  foam.CLASS({name: 'B'});
  foam.CLASS({name: 'C'});
  foam.CLASS({name: 'BView', extends: 'View', methods: [function view() { return 'BView'; }]});
  foam.CLASS({name: 'CView', extends: 'View', methods: [function view() { return 'CView'; }]});

  console.log(View.create({of: A}));
  console.log(View.create({of: B}));
  console.log(View.create({of: C}));
*/
// FUTURE: add createOriginal() (or similar) method.
foam.CLASS({
  package: 'foam.pattern',
  name: 'Faceted',

  methods: [
    function installInClass(cls) {
      var oldCreate = cls.create;

      cls.getFacetOf = function(of, X) {
        if ( ! of ) return this;
        X = X || foam.__context__;

        var name;
        var pkg;
        if ( foam.String.isInstance(of) ) {
          name = of.substring(of.lastIndexOf('.') + 1);
          pkg = of.substring(0, of.lastIndexOf('.'))
        } else {
          name = of.name;
          pkg  = of.package;
        }

        var id = ( pkg ? pkg + '.' : '' ) + name + this.name;

        return X.lookup(id, true) || this;
      };

      // ignoreFacets is set to true when called to prevent a second-level
      // of facet checking
      cls.create = function(args, X, ignoreFacets) {
        if ( ! ignoreFacets ) {
          var facetCls = this.getFacetOf(args && args.of, X);

          if ( facetCls !== this ) return facetCls.create(args, X, true);
        }

        return oldCreate.apply(this, arguments);
      }
    }
  ],

  properties: [
    ['name', 'foam.pattern.Faceted']
  ]
});
/**
 * @license
 * Copyright 2016 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
foam.CLASS({
  package: 'foam.core',
  name: 'Int',
  extends: 'Property',

  properties: [
    'units',
    [ 'value', 0 ],
    'min',
    'max',
    [ 'adapt', function adaptInt(_, v) {
        return typeof v === 'number' ? Math.trunc(v) :
          v ? parseInt(v) :
          0 ;
      }
    ],
    [ 'fromString', function intFromString(str) {
        return str ? parseInt(str) : 0;
      }
    ]
  ]
});


foam.CLASS({
  package: 'foam.core',
  name: 'String',
  extends: 'Property',

  documentation: 'StringProperties coerce their arguments into Strings.',

  properties: [
    { class: 'Int', name: 'width', value: 30 },
    [ 'adapt', function(_, a) {
        return typeof a === 'function' ? foam.String.multiline(a) :
               typeof a === 'number'   ? String(a)                :
               a && a.toString         ? a.toString()             :
                                         ''                       ;
      }
    ],
    [ 'value', '' ]
  ]
});


foam.CLASS({
  refines: 'foam.core.Model',

  documentation: 'Upgrade Mode.documentation to a proper String property.',

  properties: [
    { class: 'String', name: 'documentation' }
  ]
});


foam.CLASS({
  package: 'foam.core',
  name: 'Date',
  extends: 'Property',

  // documentation: 'Describes properties of type Date.',
  label: 'Date',

  properties: [
    {
      name: 'adapt',
      value: function (_, d) {
        if ( typeof d === 'number' ) return new Date(d);
        if ( typeof d === 'string' ) {
          var ret = new Date(d);

          if ( isNaN(ret.getTime()) ) throw 'Invalid Date: ' + d;

          return ret;
        }
        return d;
      }
    },
    {
      name: 'comparePropertyValues',
      value: function(o1, o2) {
        if ( ! o1 ) return o2 ? -1 : 0;
        if ( ! o2 ) return 1;

        return foam.Date.compare(o1, o2);
      }
    }
  ]
});


foam.CLASS({
  package: 'foam.core',
  name: 'DateTime',
  extends: 'Date',

  documentation: 'Describes properties of type DateTime.',
  label: 'Date and time'
});

foam.CLASS({
  package: 'foam.core',
  name: 'Time',
  extends: 'String',

  documentation: 'Describes properties of type Time.',
  label: 'Time'
});


foam.CLASS({
  package: 'foam.core',
  name: 'Byte',
  extends: 'Int',

  documentation: 'Describes properties of type Byte.',
  label: 'Round byte numbers'
});


foam.CLASS({
  package: 'foam.core',
  name: 'Short',
  extends: 'Int',

  documentation: 'Describes properties of type Short.',
  label: 'Round short numbers'
});


foam.CLASS({
  package: 'foam.core',
  name:  'Long',
  extends: 'Int',

  documentation:  'Describes properties of type Long.',
  label: 'Round long numbers'
});


foam.CLASS({
  package: 'foam.core',
  name: 'Float',
  extends: 'Int',

  // documentation:  'Describes properties of type Float.',
  label: 'Decimal numbers',

  properties: [
    'precision',
    [
      'adapt',
      function (_, v) {
        return typeof v === 'number' ? v : v ? parseFloat(v) : 0.0 ;
      }
    ]
  ]
});


/**
 No different than Float for JS, but useful when targeting with other languages.
 **/
foam.CLASS({
  package: 'foam.core',
  name: 'Double',
  extends: 'Float'
});


foam.CLASS({
  package: 'foam.core',
  name: 'Function',
  extends: 'Property',

  documentation: 'Describes properties of type Function.',
  label: 'Code that can be run',

  properties: [
    [
      'value',
      function() {}
    ],
    [
      'assertValue',
      function(value, prop) {
        foam.assert(typeof value === 'function', prop.name, 'Cannot set to non function type.');
      }
    ]
  ]
});


foam.CLASS({
  package: 'foam.core',
  name: 'Object',
  extends: 'Property',
  documentation: ''
});


foam.CLASS({
  package: 'foam.core',
  name: 'Array',
  extends: 'Property',

  properties: [
    [
      'factory',
      function() { return []; }
    ],
    [
      'isDefaultValue',
      function(v) { return ! v || ! v.length; }
    ]
  ]
});


foam.CLASS({
  package: 'foam.core',
  name: 'List',
  extends: 'foam.core.Object'
});


foam.CLASS({
  package: 'foam.core',
  name: 'StringArray',
  extends: 'Property',

  documentation: 'An array of String values.',
  label: 'List of text strings',

  properties: [
    {
      name: 'of',
      value: 'String',
      documentation: 'The FOAM sub-type of this property.'
    },
    [
      'factory',
      function() { return []; }
    ],
    [
      'adapt',
      function(_, v, prop) {
        if ( ! Array.isArray(v) ) return v;

        var copy;
        for ( var i = 0 ; i < v.length ; i++ ) {
          if ( typeof v[i] !== 'string' ) {
            if ( ! copy ) copy = v.slice();
            copy[i] = '' + v[i];
          }
        }

        return copy || v;
      }
    ],
    [
      'assertValue',
      function(v, prop) {
        if ( v === null ) return;

        foam.assert(Array.isArray(v),
            prop.name, 'Tried to set StringArray to non-array type.');
        for ( var i = 0 ; i < v.length ; i++ ) {
          foam.assert(typeof v[i] === 'string',
              prop.name, 'Element', i, 'is not a string', v[i]);
        }
      }
    ]
  ]
});


foam.CLASS({
  package: 'foam.core',
  name: 'Class',
  extends: 'Property',

  properties: [
    [ 'getter', function(prop) {
        var c = this.instance_[prop.name];

        // Implement value and factory support.
        if ( foam.Undefined.isInstance(c) ) {
          if ( ! foam.Undefined.isInstance(prop.value) ) {
            c = prop.value;
          } else if ( prop.factory ) {
            c = this.instance_[prop.name] = prop.factory.call(this, prop);
          }
        }

        // Upgrade Strings to actual classes, if available.
        if ( foam.String.isInstance(c) ) {
          c = this.lookup(c, true);
          if ( c ) {
            this.instance_[prop.name] = c;
          } else {
            console.error('Unknown class: ' + c);
          }
        }

        return c;
      }
    ],
    ['toJSON', function(value) { return value ? value.id : value; } ]
  ],

  methods: [
    function installInProto(proto) {
      this.SUPER(proto);

      var name = this.name;

      Object.defineProperty(proto, name + '$cls', {
        get: function classGetter() {
          console.warn("Deprecated use of 'cls.$cls'. Just use 'cls' instead.");
          return typeof this[name] !== 'string' ? this[name] :
            this.__context__.lookup(this[name], true);
        },
        configurable: true
      });
    }
  ]
});


foam.CLASS({
  package: 'foam.core',
  name: 'EMail',
  extends: 'String',
  // FUTURE: verify
  label: 'Email address'
});


foam.CLASS({
  package: 'foam.core',
  name: 'Image',
  extends: 'String',
  // FUTURE: verify
  label: 'Image data or link'
});


foam.CLASS({
  package: 'foam.core',
  name: 'URL',
  extends: 'String',
  // FUTURE: verify
  label: 'Web link (URL or internet address)'
});


foam.CLASS({
  package: 'foam.core',
  name: 'Color',
  extends: 'String',
  label: 'Color'
});


foam.CLASS({
  package: 'foam.core',
  name: 'Password',
  extends: 'String',
  label: 'Password that displays protected or hidden text'
});


foam.CLASS({
  package: 'foam.core',
  name: 'PhoneNumber',
  extends: 'String',
  label: 'Phone number'
});


foam.CLASS({
  package: 'foam.core',
  name: 'Currency',
  extends: 'Long'
});


foam.CLASS({
  package: 'foam.core',
  name: 'Map',
  extends: 'Property',

  // TODO: Remove need for sorting
  properties: [
    [ 'factory', function() { return {} } ],
    [
      'comparePropertyValues',
      function(o1, o2) {
        if ( foam.typeOf(o1) != foam.typeOf(o2) ) return -1;

        var keys1 = Object.keys(o1).sort();
        var keys2 = Object.keys(o2).sort();
        if ( keys1.length < keys2.length ) return -1;
        if ( keys1.length > keys2.length ) return 1;
        for ( var i = 0 ; i < keys1.length ; i++ ) {
          var c = foam.String.compare(keys1[i], keys2[i]);
          if ( c != 0 ) return c;
          c = foam.util.compare(o1[keys1[i]], o2[keys2[i]]);
          if ( c != 0 ) return c;
        }

        return 0;
      }
    ],
    [
      'cloneProperty',
      function(value, cloneMap) {
        if ( value ) {
          var tmp = cloneMap[this.name] = {};
          for ( var key in value ) {
            tmp[key] = value[key];
          }
        }
      }
    ],
    [
      'diffPropertyValues',
      function(o1, o2) {
        // TODO
      }
    ],
    'of'
  ]
});


foam.CLASS({
  package: 'foam.core',
  name: 'FObjectProperty',
  extends: 'Property',

  properties: [
    {
      class: 'Class',
      name: 'of',
      value: 'foam.core.FObject'
    },
    {
      name: 'fromJSON',
      value: function(json, ctx, prop) {
        return foam.json.parse(json, prop.of, ctx);
      }
    },
    {
      name: 'adapt',
      value: function(_, v, prop) {
        // All FObjects may be null.
        if (v === null) return v;

        var of = prop.of;

        return of.isInstance(v) ?
            v :
            ( v.class ?
                this.lookup(v.class) :
                of ).create(v, this.__subContext__);
      }
    }
  ]
});


foam.CLASS({
  package: 'foam.core',
  name: 'Reference',
  extends: 'Property',

  properties: [
    {
      class: 'Class',
      name: 'of'
    },
    {
      class: 'String',
      name: 'targetDAOKey',
      expression: function(of) { return foam.String.daoize(of.name); }
    },
    {
      name: 'adapt',
      value: function(oldValue, newValue, prop) {
        return prop.of.isInstance(newValue) ?
          newValue.id :
          newValue ;
      }
    }
  ],

  methods: [
    function installInProto(proto) {
      this.SUPER(proto);
      var key  = this.targetDAOKey;
      var name = this.name;

      Object.defineProperty(proto, name + '$find', {
        get: function classGetter() {
          return this.__context__[key].find(this[name]);
        },
        configurable: true
      });
    }
  ]
});


foam.CLASS({
  refines: 'foam.core.Model',

  documentation: 'Update Model Property types.',

  properties: [
    { class: 'String',  name: 'name' },
    { class: 'Boolean', name: 'abstract' }
  ]
});


foam.CLASS({
  refines: 'Property',

  axioms: [
    foam.pattern.Faceted.create()
  ],

  properties: [
    {
      name: 'of'
    }
  ]
});


foam.CLASS({
  refines: 'Property',

  properties: [
    /**
      A short-name is an optional shorter name for a property.
      It is used by JSON and XML support when 'useShortNames'
      is enabled. Short-names enable output to be smaller,
      which can save disk space and/or network bandwidth.
      Ex.
    <pre>
      properties: [
        { name: 'firstName', shortName: 'fn' },
        { name: 'lastName',  shortName: 'ln' }
      ]
    </pre>
    */
    { class: 'String', name: 'shortName' }
  ]
});
/**
 * @license
 * Copyright 2016 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

foam.CLASS({
  package: 'foam.core',
  name: 'Topic',

  documentation: `
  Topics delcare the types of events that an object publishes.
  <pre>
    Ex.
    foam.CLASS({
      name: 'Alarm',
      topics: [ 'ring' ]
    });

    then doing:
    alarm.ring.pub();
    alarm.ring.sub(l);

    is the same as:
    alarm.pub('ring');
    alarm.sub('ring', l);
  </pre>
  `,

  properties: [
    'name',
    'description',
    {
      class: 'FObjectArray',
      of: 'Topic',
      name: 'topics',
      adaptArrayElement: function(o) {
        return typeof o === 'string' ?
          foam.core.Topic.create({ name: o }, this) :
          foam.core.Topic.create(o, this);
      }
    }
  ],

  methods: [
    function installInProto(proto) {
      var name      = this.name;
      var topic     = this;
      var makeTopic = this.makeTopic;

      Object.defineProperty(proto, name, {
        get: function topicGetter() {
          if ( ! this.hasOwnPrivate_(name) ) {
            this.setPrivate_(name, makeTopic(topic, this));
          }

          return this.getPrivate_(name);
        },
        configurable: true,
        enumerable: false
      });
    },

    function makeTopic(topic, parent) {
      var name   = topic.name;
      var topics = topic.topics || [];

      var ret = {
        pub: foam.Function.bind(parent.pub, parent, name),
        sub: foam.Function.bind(parent.sub, parent, name),
        hasListeners: foam.Function.bind(parent.hasListeners, parent, name),
        toString: function() { return 'Topic(' + name + ')'; }
      };

      for ( var i = 0 ; i < topics.length ; i++ ) {
        ret[topics[i].name] = makeTopic(topics[i], ret);
      }

      return ret;
    }
  ]
});


foam.CLASS({
  refines: 'foam.core.Model',
  properties: [
    {
      class: 'AxiomArray',
      of: 'Topic',
      name: 'topics',
      adaptArrayElement: function(o) {
        return typeof o === 'string'        ?
          foam.core.Topic.create({name: o}) :
          foam.core.Topic.create(o)         ;
      }
    }
  ]
});


foam.CLASS({
  refines: 'foam.core.FObject',
  topics: [ 'propertyChange' ]
});
/**
 * @license
 * Copyright 2016 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
  Classes can have "inner-classes" which are classes which are defined within
  the scope of a class itself rather than being top-level classes which reside
  in a package or globally. This helps to avoid polluting namespaces with classes
  which are only used by a single class.

<pre>
  Ex.
  // Classes can have inner-Classes.
  foam.CLASS({
    name: 'InnerClassTest',
    classes: [
      { name: 'InnerClass1', properties: ['a', 'b'] },
      { name: 'InnerClass2', properties: ['x', 'y'] }
    ],
    methods: [
      function init() {
        var ic1 = this.InnerClass1.create({a:1, b:2});
        var ic2 = this.InnerClass2.create({x:5, y:10});
        log(ic1.a, ic1.b, ic2.x, ic2.y);
      }
    ]
  });
  InnerClassTest.create();
</pre>
*/
foam.CLASS({
  package: 'foam.core',
  name: 'InnerClass',

  documentation: 'Axiom for defining inner-classes. An inner-class is a class defined in the scope of the outer/owner class. This avoids poluting the package namespace with classes which are only used internally by a class.',

  properties: [
    {
      name: 'name',
      getter: function() { return this.model.name; }
    },
    {
      name: 'model',
      adapt: function(_, m) {
        return this.modelAdapt_(m);
      }
    }
  ],

  methods: [
    function modelAdapt_(m) {
      return foam.core.Model.isInstance(m) ? m :
          foam.core.EnumModel.isInstance(m) ? m :
          foam.core.InnerClass.isInstance(m) ? this.modelAdapt_(m.model) :
          m.class ? this.modelAdapt_(foam.json.parse(m)) :
          foam.core.Model.create(m);
    },

    function installInClass(cls) {
      cls[this.model.name] = this.model.buildClass();
    },

    function installInProto(proto) {
      // get class already created in installInClass();
      var name = this.model.name;
      var cls = proto.cls_[name];

      // Create a private_ clone of the Class with the create() method decorated
      // to pass 'this' as the context if not explicitly provided.  This ensures
      // that the created object has access to this object's exported bindings.
      Object.defineProperty(proto, name, {
        get: function innerClassGetter() {
          if ( ! this.hasOwnPrivate_(name) ) {
            var parent = this;
            var c      = Object.create(cls);

            c.create = function innerClassCreate(args, ctx) {
              return cls.create(args, ctx || parent);
            };
            this.setPrivate_(name, c);
          }

          return this.getPrivate_(name);
        },
        configurable: true,
        enumerable: false
      });
    }
  ]
});


foam.CLASS({
  refines: 'foam.core.Model',
  properties: [
    {
      class: 'AxiomArray',
      of: 'InnerClass',
      name: 'classes',
      // A custom adaptArrayElement is needed because we're
      // passing the model definition as model:, rather than
      // as all of the arguments to create().
      adaptArrayElement: function(o) {
        return foam.core.InnerClass.isInstance(o) ?
          o :
          foam.core.InnerClass.create({model: o}) ;
      }
    }
  ]
});
/**
 * @license
 * Copyright 2016 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
  Classes can have "inner-enums" which are enums which are defined within
  the scope of a class itself rather than being top-level enums which reside
  in a package or globally. This helps to avoid polluting namespaces with enums
  which are only used by a single class.

<pre>
  Ex.
  // Classes can have inner-Enums.
  foam.CLASS({
    name: 'InnerEnumTest',
    enums: [
      { name: 'InnerEnum', values: [
        { name: 'OPEN',   label: 'Open'   },
        { name: 'CLOSED', label: 'Closed' }
      ] }
    ],
    methods: [
      function init() {
        log(this.InnerEnum.OPEN, this.InnerEnum.CLOSED)
      }
    ]
  });
  InnerEnumTest.create();
</pre>
*/
foam.CLASS({
  package: 'foam.core',
  name: 'InnerEnum',

  documentation: 'Axiom for defining inner-enums. An inner-enum is an enum defined in the scope of the outer/owner class. This avoids poluting the package namespace with enums which are only used internally by a class.',

  properties: [
    {
      name: 'name',
      getter: function() { return this.model.name; }
    },
    {
      name: 'model',
      adapt: function(_, m) {
        return foam.core.EnumModel.isInstance(m) ? m : foam.core.EnumModel.create(m);
      }
    }
  ],

  methods: [
    function installInClass(cls) {
      cls[this.model.name] = this.model.buildClass();
    },

    function installInProto(proto) {
      // get class already created in installInClass();
      var name = this.model.name;
      var cls = proto.cls_[name];
      proto[name] = cls;
    }
  ]
});


foam.CLASS({
  refines: 'foam.core.Model',
  properties: [
    {
      class: 'AxiomArray',
      of: 'InnerEnum',
      name: 'enums',
      // A custom adaptArrayElement is needed because we're
      // passing the model definition as model:, rather than
      // as all of the arguments to create().
      adaptArrayElement: function(o) {
        return foam.core.InnerEnum.isInstance(o) ?
          o :
          foam.core.InnerEnum.create({model: o}) ;
      }
    }
  ]
});
/**
 * @license
 * Copyright 2016 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

foam.CLASS({
  package: 'foam.core',
  name: 'Implements',

  documentation: function() {/*
    Axiom for declaring intent to implement an interface.

    Since interfaces can also have implementations, it
    can also be used to provide mix-ins, which is a safe form of
    multiple-inheritance.
  <pre>
    Ex.
    foam.CLASS({
      name: 'SalaryI',
      properties: [ 'salary' ]
    });

    foam.CLASS({
      name: 'Employee',
      extends: 'Person',
      implements: [ 'SalaryI' ]
    });
  </pre>
  Employee extends Person through regular inheritance, but
  the axioms from SalaryI are also added to the class.
  Any number of mix-ins/interfaces can be specified.
  */},

  properties: [
    {
      name: 'name',
      getter: function() { return 'implements_' + this.path; }
    },
    'path'
  ],

  methods: [
    function installInClass(cls) {
      var m = this.lookup(this.path);
      if ( ! m ) throw 'No such interface or trait: ' + this.path;

      // TODO: clone these axioms since they could be reused and then would
      // have the wrong sourceCls_;

      // This next part is a bit tricky.
      // If we install a mixin and then override properties of one of the
      // Properties from the mixin, the mixin Property will see the overridden
      // Property as its super-prop, which is wrong. So, we insert a new level
      // in the axiomMap_ between the current axiomMap_ and its prototype, and
      // then install the mixin there.

      // Current AxiomMap
      var aMap = cls.axiomMap_;

      // New mixin AxiomMap to install into
      var sMap = Object.create(aMap.__proto__);

      // Insert new AxiomMap between current and its parent
      aMap.__proto__ = sMap;

      // Temporarily set the class'es AxiomMap to sMap so that
      // mixin axioms get installed into it.
      cls.axiomMap_ = sMap;

      cls.installAxioms(m.getOwnAxioms());

      // Put the original AxiomMap back, with the inserted parent.
      cls.axiomMap_ = aMap;
    }
  ]
});


foam.CLASS({
  refines: 'foam.core.Model',
  properties: [
    {
      class: 'AxiomArray',
      of: 'Implements',
      name: 'implements',
      adaptArrayElement: function(o) {
        return typeof o === 'string' ?
          foam.core.Implements.create({path: o}) :
          foam.core.Implements.create(o)         ;
      }
    }
  ]
});
/**
 * @license
 * Copyright 2016 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
  Imports and Exports provide implicit Context dependency management.

  A class can list which values it requires from the Context, and then
  these values will be added to the object itself so that it doesn't need
  to explicitly work with the Context.

  A class can list which values (properties, methods, or method-like axioms)
  that it exports, and these will automatically be added to the object's
  sub-Context. The object's sub-Context is the context that is used when
  new objects are created by the object.

  Ex.
<pre>
foam.CLASS({
  name: 'ImportsTest',

  imports: [ 'log', 'warn' ],

  methods: [
    function foo() {
      this.log('log foo from ImportTest');
      this.warn('warn foo from ImportTest');
    }
  ]
});

foam.CLASS({
  name: 'ExportsTest',
  requires: [ 'ImportsTest' ],

  exports: [ 'log', 'log as warn' ],

  methods: [
    function init() {
      // ImportsTest will be created in ExportTest's
      // sub-Context, which will have 'log' and 'warn'
      // exported.
      this.ImportsTest.create().foo();
    },
    function log(msg) {
      console.log('log:', msg);
    }
  ]
});
</pre>

  Aliasing:
    Bindings can be renamed or aliased when they're imported or exported using
    'as alias'.

  Examples:
    // import 'userDAO' from the Context and make available as this.dao
    imports: [ 'userDAO as dao' ]

    // export my log method as 'warn'
    exports: [ 'log as warn' ]

    // If the axiom to be exported isn't named, but just aliased, then 'this'
    // is exported as the named alias.  This is how objects export themselves.
    exports: [ 'as Controller' ]

  See Context.js.
 */
foam.CLASS({
  package: 'foam.core',
  name: 'Import',

  documentation: 'Axiom to Import a Context Value.',

  properties: [
    {
      class: 'String',
      name: 'name'
    },
    'key',
    {
      class: 'Boolean',
      name: 'required',
      value: true
    },
    {
      name: 'slotName_',
      factory: function() {
        return foam.String.toSlotName(this.name);
      }
    }
  ],

  methods: [
    function installInProto(proto) {
      foam.assert(this.key, 'No key for import: ' + this.name);

      var name     = this.name;
      var key      = foam.String.toSlotName(this.key);
      var slotName = this.slotName_;
      var required = this.required;

      Object.defineProperty(proto, slotName, {
        get: function importsSlotGetter() {
          return this.__context__[key];
        },
        configurable: false,
        enumerable: false
      });

      Object.defineProperty(proto, name, {
        get: function importsGetter()  {
          var slot = this[slotName];
          if ( slot ) return slot.get();
          if ( required ) console.warn('Access missing import:', name);
          return undefined;
        },
        set: function importsSetter(v) {
          var slot = this[slotName];
          if ( slot )
            slot.set(v);
          else
            console.warn('Attempt to set missing import:', name);
        },
        configurable: true,
        enumerable: false
      });
    },

    function toSlot(obj) {
      return obj[this.slotName_];
    }
  ]
});


foam.CLASS({
  package: 'foam.core',
  name: 'Export',

  documentation: 'Axiom to Export a Sub-Context Value.',

  properties: [
    {
      class: 'String',
      name: 'name'
    },
    {
      name: 'exportName',
      postSet: function(_, name) {
        this.name = 'export_' + name;
      }
    },
    'key'
  ],

  methods: [
    function getExportMap() {
      var m = {};
      var bs = this.cls_.getAxiomsByClass(foam.core.Export);
      for ( var i = 0 ; i < bs.length ; i++ ) {
        var b = bs[i];

        if ( b.key ) {
          var path = b.key.split('.');

          var a = this.cls_.getAxiomByName(path[0]);

          foam.assert(!!a, 'Unknown axiom: "', path[0], '" in model: ',
                      this.cls_.id, ", trying to export: '", b.key, "'");

          // Axioms have an option of wrapping a value for export.
          // This could be used to bind a method to 'this', for example.
          var e = a.exportAs ? a.exportAs(this, path.slice(1)) : this[path[0]];

          m[b.exportName] = e;
        } else {
          // Ex. 'as Bank', which exports an implicit 'this'
          m[b.exportName] = this;
        }
      }
      return m;
    },

    function installInProto(proto) {
      if ( Object.prototype.hasOwnProperty.call(proto, '__subContext__' ) ) {
        return;
      }

      var axiom = this;

      Object.defineProperty(proto, '__subContext__', {
        get: function YGetter() {
          if ( ! this.hasOwnPrivate_('__subContext__') ) {
            var ctx = this.__context__;
            var m = axiom.getExportMap.call(this);
            this.setPrivate_('__subContext__', ctx.createSubContext(m));
          }

          return this.getPrivate_('__subContext__');
        },
        set: function() {
          throw new Error('Attempted to set unsettable __subContext__ in ' + this.cls_.id);
        },
        configurable: true,
        enumerable: false
      });
    }
  ]
});


foam.CLASS({
  refines: 'foam.core.Model',

  properties: [
    {
      class: 'AxiomArray',
      of: 'Import',
      name: 'imports',
      adaptArrayElement: function(o) {
        if ( typeof o === 'string' ) {
          var a        = o.split(' as ');
          var key      = a[0];
          var optional = key.endsWith('?');
          if ( optional ) key = key.slice(0, key.length-1);
          return foam.core.Import.create({name: a[1] || key, key: key, required: ! optional});
        }

        return foam.core.Import.create(o);
      }
    },
    {
      class: 'AxiomArray',
      of: 'Export',
      name: 'exports',
      adaptArrayElement: function(o) {
        if ( typeof o === 'string' ) {
          var a = o.split(' ');

          switch ( a.length ) {
            case 1:
              return foam.core.Export.create({exportName: a[0], key: a[0]});

            case 2:
              // Export 'this'
              foam.assert(
                  a[0] === 'as',
                  'Invalid export syntax: key [as value] | as value');
              return foam.core.Export.create({exportName: a[1], key: null});

            case 3:
              foam.assert(
                  a[1] === 'as',
                  'Invalid export syntax: key [as value] | as value');
              return foam.core.Export.create({exportName: a[2], key: a[0]});

            default:
              foam.assert(false,
                  'Invalid export syntax: key [as value] | as value');
          }
        }

        return foam.core.Export.create(o);
      }
    }
  ]
});
/**
 * @license
 * Copyright 2016 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
  Listeners are high-level pre-bound event call-backs.
<pre>
  Ex.
  foam.CLASS({
    name: 'Sprinkler',
    listeners: [

      // short-form
      function onAlarm() { ... },

      // long-form
      {
        name: 'onClear',
        isFramed: true,
        code: function() { ... }
      }
    ]
  });
</pre>
  You might use the above onAlarm listener like this:
  alarm.ring.sub(sprinker.onAlarm);
<p>
  Notice, that normally JS methods forget which object they belong
  to so you would need to do something like:
    <pre>alarm.ring.sub(sprinker.onAlarm.bind(sprinkler));</pre>
  But listeners are pre-bound.
*/
// TODO(kgr): Add SUPER support.
foam.CLASS({
  package: 'foam.core',
  name: 'Listener',
  extends: 'foam.core.AbstractMethod',

  requires: [
    'foam.core.Argument',
  ],

  properties: [
    { class: 'Boolean', name: 'isFramed',   value: false },
    { class: 'Boolean', name: 'isMerged',   value: false },
    { class: 'Int',     name: 'mergeDelay', value: 16, units: 'ms' },
    {
      name: 'args',
      factory: function() {
        return [
          this.Argument.create({
            name: 'sub',
            javaType: 'foam.core.Detachable'
          })
        ];
      }
    }
  ],

  methods: [
    function installInProto(proto, superAxiom) {
      // This can happen when there's no js implementation of a listener.
      if ( ! this.code ) return;

      foam.assert(
        ! superAxiom ||
          foam.core.Listener.isInstance(superAxiom),
        'Attempt to override non-listener', this.name);

      var name       = this.name;
      var code       = this.override_(proto, foam.Function.setName(this.code, name), superAxiom);
      var isMerged   = this.isMerged;
      var isFramed   = this.isFramed;
      var mergeDelay = this.mergeDelay;

      Object.defineProperty(proto, name, {
        get: function listenerGetter() {
          if ( this.cls_.prototype === this ) return code;

          if ( ! this.hasOwnPrivate_(name) ) {
            var self = this;
            var l = function(sub) {
              // Is it possible to detect stale subscriptions?
              // ie. after an object has been detached.
              return code.apply(self, arguments);
            };

            if ( isMerged ) {
              l = this.__context__.merged(l, mergeDelay);
            } else if ( isFramed ) {
              l = this.__context__.framed(l);
            }
            this.setPrivate_(name, l);
          }

          return this.getPrivate_(name);
        },
        configurable: true,
        enumerable: false
      });
    }
  ]
});


foam.CLASS({
  refines: 'foam.core.Model',

  properties: [
    {
      class: 'AxiomArray',
      of: 'Listener',
      name: 'listeners',
      adaptArrayElement: function(o) {
        if ( typeof o === 'function' ) {
          var name = foam.Function.getName(o);
          foam.assert(name, 'Listener must be named');
          return foam.core.Listener.create({name: name, code: o});
        }

        return foam.core.Listener.isInstance(o) ?
            o :
            foam.core.Listener.create(o) ;
      }
    }
  ]
});
/**
 * @license
 * Copyright 2016 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @license
 * Copyright 2018 The FOAM Authors. All Rights Reserved.
 * http://www.apache.org/licenses/LICENSE-2.0
 */

foam.CLASS({
  package: 'foam.core',
  name: 'IDAlias',
  extends: 'foam.core.Object',
  properties: [
    ['name', 'id'],
    {
      class: 'String',
      name: 'propName'
    },
    {
      name: 'targetProperty',
      transient: true
    },
    ['getter', function() {
      return this.cls_.ID.targetProperty.f(this);
    }],
    ['setter', function(v) {
      this.cls_.ID.targetProperty.set(this, v);
    }]
  ],
  methods: [
    function installInClass(c) {
      var prop = c.getAxiomByName(this.propName);
      foam.assert(foam.core.Property.isInstance(prop), 'Ids property: ' + c.id + '.' + this.propName, 'is not a Property');
      this.targetProperty = prop;

      this.SUPER(c);
    }
  ]
});

foam.CLASS({
  package: 'foam.core',
  name: 'MultiPartID',
  extends: 'foam.core.FObjectProperty',

  documentation: function() {/*
  An Identity Axiom which installs a psedo-property to use as an id.

  Use when you want a multi-part primary-key.
  <pre>
  Ex.
  foam.CLASS({
    name: 'Person',
    ids: [ 'firstName', 'lastName' ],
    properties: [ 'firstName', 'lastName', 'age', 'sex' ]
  });

  > var p = Person.create({firstName: 'Kevin', lastName: 'Greer'});
  > p.id.cls_.id;
  "PersonId"
  > p.id.toString();
  "{firstName:\"Kevin\",lastName:\"Greer\"}"
  </pre>
  */},

  properties: [
    [ 'name', 'id' ],
    [ 'transient', true ],
    [ 'hidden', true ],
    {
      class: 'Class',
      name: 'of',
      transient: true,
      required: false,
      value: null
    },
    {
      class: 'StringArray',
      name: 'propNames',
      required: true
    },
    [ 'getter', function multiPartGetter() {
      return this.cls_.ID.of.create(this);
    }],
    [ 'setter', function multiPartSetter(a) {
      if ( ! foam.Array.isInstance(a) ) {
        this.copyFrom(a);
        return;
      }

      // TODO(markdittmer): Should not assume this property is named "id".
      var names = this.cls_.ID.propNames;
      foam.assert(names.length === a.length,
                  `Improperly sized array for ${this.cls_.id} array value`);
      for ( var i = 0; i < names.length; i++ ) {
        this[names[i]] = a[i];
      }
    }]
  ],

  methods: [
    function installInClass(c) {
      var generatedId = c.package ?
          c.package + '.' + c.name + 'Id' :
          c.name + 'Id';

      foam.CLASS({
        package: c.package,
        name: c.name + 'Id',
        properties: this.propNames.map(function(n) {
          var prop = c.getAxiomByName(n);
          foam.assert(prop, 'Unknown ids property:', c.id + '.' + n);
          foam.assert(foam.core.Property.isInstance(prop), 'Ids property:', c.id + '.' + n, 'is not a Property.');
          return prop.clone();
        }),
        methods: [
          function toString() {
            return foam.json.Compact.stringify(this, this.cls_);
          }
        ]
      });

      c.installAxiom(foam.core.Requires.create({
        name: c.name + 'Id',
        path: generatedId
      }));

      this.of = foam.lookup(generatedId);

      // Extends Property, so actually gets installed in SUPER call
      this.SUPER(c);
    }
  ]
});

foam.CLASS({
  refines: 'foam.core.Model',
  properties: [
    {
      name: 'ids',
      postSet: function(_, ids) {
        foam.assert(foam.Array.isInstance(ids), 'Ids must be an array.');
        foam.assert(ids.length, 'Ids must contain at least one property.');

        // Don't build MultiPartID property if the id is not multi part.
        if ( ids.length == 1 ) this.axioms_.push(foam.core.IDAlias.create({ propName: ids[0] }));
        else this.axioms_.push(foam.core.MultiPartID.create({propNames: ids}));
      }
    }
  ]
});
/**
 * @license
 * Copyright 2016 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
  The Requires Axiom is used to declare that a class requires/creates objects
  of a particular class. Required classes can be accessed without fully
  qualifying their package names. Required classes are automatically
  created in the sub-context of the creating object.
<pre>
  Ex.
  foam.CLASS({
    package: 'demo.bank',
    name: 'AccountTester',
    requires: [
      // Require demo.bank.Account so that it can be accessed as this.Account
      'demo.bank.Account',

      // Require SavingsAccount and alias it so that it can be accessed
      // as this.SAccount
      'demo.bank.SavingsAccount as SAccount'
    ],
    methods: [ function init() {
      var a = this.Account.create();
      var s = this.SAccount.create();
    } ]
  });
</pre>
*/
foam.CLASS({
  package: 'foam.core',
  name: 'Requires',

  properties: [
    {
      name: 'name',
      factory: function() {
        return this.path.split('.').pop();
      },
    },
    'path',
    'flags',
  ],

  methods: [
    function installInProto(proto) {
      var name = this.name;
      var path = this.path;

      // Create a private_ clone of the Class with the create() method decorated
      // to pass 'this' as the context if not explicitly provided.  This ensures
      // that the created object has access to this object's exported bindings.
      Object.defineProperty(proto, name, {
        get: function requiresGetter() {
          if ( ! this.hasOwnPrivate_(name) ) {
            var cls    = (this.__context__ || foam).lookup(path);
            var parent = this;
            foam.assert(cls, 'Requires: Unknown class: ', path);

            var c = Object.create(cls);
            c.create = function requiresCreate(args, ctx) { return cls.create(args, ctx || parent); };
            this.setPrivate_(name, c);
          }

          return this.getPrivate_(name);
        },
        configurable: true,
        enumerable: false
      });
    }
  ]
});

foam.CLASS({
  refines: 'foam.core.Model',
  properties: [
    {
      class: 'AxiomArray',
      of: 'Requires',
      name: 'requires',
      adaptArrayElement: function(o) {
        if ( typeof o === 'string' ) {
          var a    = o.split(' as ');
          var path = a[0];
          var r = foam.core.Requires.create({path: path}, this);
          if ( a[1] ) r.name = a[1];
          return r;
        }
        return foam.core.Requires.create(o, this);
      }
    }
  ]
});
/**
 * @license
 * Copyright 2016 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

foam.CLASS({
  package: 'foam.core',
  name: 'Slot', // ???: Rename AbstractSlot or make an Interface

  documentation: `
    Slots are observable values which can change over time.

    Slots are simple single-value Model-View-Controller Models, but since
    another meaning of 'Model' is already heavily used in FOAM, Slot is
    used to avoid overloading the term.

    <ul>Types of Slots include:
      <li>PropertySlot
      <li>ConstantSlot
      <li>ExpressionSlot
    </ul>
  `,

  methods: [
    /**
      Subscribe to the Slot's value, if it has one. If the Slot's
      value changes, then unsubscribe from the previous value and
      resubscribe to the new one.
    */
    function valueSub() {
      var self = this;
      var args = Array.from(arguments);
      var s;
      var l = function() {
        var v = self.get();
        if ( s ) s.detach();
        if ( v ) s = v.sub.apply(v, args);
      };
      l();
      this.sub(l);
    },

    /**
      Create a sub-Slot for this Slot's value. If this Slot's
      value changes, then the sub-Slot becomes the Slot for
      the new value's sub-Slot instead. Useful for creating
      Slot paths without having to rebuild whenever a value
      along the chain changes.
    */
    function dot(name) {
      return foam.core.internal.SubSlot.create({
        parent: this,
        name:   name
      });
    },

    // TODO: remove when all code ported
    function link(other) {
      console.warn('deprecated use of link(), use linkFrom() instead');
      return this.linkFrom(other);
    },

    /**
      Link two Slots together, setting both to other's value.
      Returns a Detachable which can be used to break the link.
      After copying a value from one slot to the other, this implementation
      then copies the value back in case the target slot rejected the value.
    */
    function linkFrom(s2) {
      var s1        = this;
      var feedback1 = false, feedback2 = false;

      // TODO: once all slot types property set 'src', these
      // two listeneners can be merged.
      var l1 = function(e) {
        if ( feedback1 ) return;

        if ( ! foam.util.is(s1.get(), s2.get()) ) {
          feedback1 = true;
          s2.set(s1.get());
          if ( ! foam.util.is(s1.get(), s2.get()) )
            s1.set(s2.get());
          feedback1 = false;
        }
      };

      var l2 = function(e) {
        if ( feedback2 ) return;

        if ( ! foam.util.is(s1.get(), s2.get()) ) {
          feedback2 = true;
          s1.set(s2.get());
          if ( ! foam.util.is(s1.get(), s2.get()) )
            s2.set(s1.get());
          feedback2 = false;
        }
      };

      var sub1 = s1.sub(l1);
      var sub2 = s2.sub(l2)

      l2();

      return {
        detach: function() {
          sub1 && sub1.detach();
          sub2 && sub2.detach();
          sub1 = sub2 = null;
        }
      };
    },

    function linkTo(other) {
      return other.linkFrom(this);
    },

    /**
      Have this Slot dynamically follow other's value.
      Returns a Detachable which can be used to cancel the binding.
    */
    function follow(other) {
      foam.assert(other, 'Slot.follow requires Slot argument.');
      var self = this;
      var l = function() {
        if ( ! foam.util.is(self.get(), other.get()) ) {
          self.set(other.get());
        }
      };
      l();
      return other.sub(l);
    },

    /**
     * Maps values from one model to another.
     * @param f maps values from srcValue to dstValue
     */
    function mapFrom(other, f) {
      var self = this;
      var l = function() { self.set(f(other.get())); };
      l();
      return other.sub(l);
    },

    function mapTo(other, f) {
      return other.mapFrom(this, f);
    },

    function map(f) {
      return foam.core.ExpressionSlot.create({code: f, args: [this]});
    },

    /**
     * Relate to another Slot.
     * @param f maps from this to other
     * @param fprime maps other to this
     */
    function relateTo(other, f, fPrime) {
      var self     = this;
      var feedback = false;
      var sub      = foam.core.FObject.create();
      var l1 = function() {
        if ( feedback ) return;
        feedback = true;
        other.set(f(self.get()));
        feedback = false;
      };
      var l2 = function() {
        if ( feedback ) return;
        feedback = true;
        self.set(fPrime(other.get()));
        feedback = false;
      };

      sub.onDetach(this.sub(l1));
      sub.onDetach(other.sub(l2));

      l1();

      return sub;
    },

    function relateFrom(other, f, fPrime) {
      return other.relateTo(this, fPrime, f);
    }
  ]
});


foam.CLASS({
  package: 'foam.core.internal',
  name: 'PropertySlot',
  extends: 'foam.core.Slot',

  documentation: `
    Represents object properties as Slots.
    Created with calling obj.prop$ or obj.slot('prop').
    For internal use only.
  `,

  methods: [
    function initArgs() { },
    function init() { },

    function get() {
      return this.prop.get(this.obj);
    },

    function set(value) {
      return this.prop.set(this.obj, value);
    },

    function getPrev() {
      return this.oldValue;
    },

    function setPrev(value) {
      return this.oldValue = value;
    },

    function sub(l) {
      var s = this.obj.sub('propertyChange', this.prop.name, l);
      s.src = this;
      return s;
    },

    function isDefined() {
      return this.obj.hasOwnProperty(this.prop.name);
    },

    function clear() {
      this.obj.clearProperty(this.prop.name);
    },

    function toString() {
      return 'PropertySlot(' + this.obj.cls_.id + '.' + this.prop.name + ')';
    }
  ]
});


foam.CLASS({
  package: 'foam.core.internal',
  name: 'SubSlot',
  extends: 'foam.core.Slot',

  documentation:
      'For internal use only. Is used to implement the Slot.dot() method.',

  properties: [
    'of',
    'parent', // parent slot, not parent object
    'name',
    'value',
    'prevSub'
  ],

  methods: [
    function init() {
      this.parent.sub(this.parentChange);
      this.parentChange();
    },

    function get() {
      var o = this.parent.get();

      return o && o[this.name];
    },

    function set(value) {
      var o = this.parent.get();

      if ( o ) o[this.name] = value;
    },

    /** Needed? **/
    function getPrev() {
      debugger;
      return this.oldValue;
    },

    /** Needed? **/
    function setPrev(value) {
      debugger;
      return this.oldValue = value;
    },

    function sub(l) {
      return this.SUPER('propertyChange', 'value', l);
    },

    function isDefined() {
      return this.parent.get().hasOwnProperty(this.name);
    },

    function clear() {
      this.parent.get().clearProperty(this.name);
    },

    function toString() {
      return 'SubSlot(' + this.parent + ',' + this.name + ')';
    }
  ],

  listeners: [
    function parentChange(s) {
      this.prevSub && this.prevSub.detach();
      var o = this.parent.get();

      // If the parent object changes class, then don't update
      // because a new class will have different sub-slots.
      if ( ( ! this.of  ) && o ) this.of = o.cls_;

      this.prevSub = o && o.slot(this.name).sub(this.valueChange);
      this.valueChange();
    },

    function valueChange() {
      var parentValue = this.parent.get();
      this.value = parentValue ? parentValue[this.name] : undefined;
    }
  ]
});


foam.CLASS({
  package: 'foam.core',
  name: 'ConstantSlot',

  implements: [ 'foam.core.Slot' ],

  documentation: 'An immutable constant valued Slot.',

  properties: [
    {
      name: 'value',
      getter: function() { return this.value_; },
      setter: function() {}
    }
  ],

  methods: [
    function initArgs(args) { this.value_ = args && args.value; },

    function get() { return this.value; },

    function set() {
      throw new Error('Tried to mutate immutable ConstantSlot.');
    },

    function sub(l) { /* nop */ }
  ]
});


/**
*/
foam.CLASS({
  package: 'foam.core',
  name: 'ExpressionSlot',
  implements: [ 'foam.core.Slot' ],

  documentation: `
    Tracks dependencies for a dynamic function and invalidates if they change.

    <pre>
      foam.CLASS({name: 'Person', properties: ['fname', 'lname']});
      var p = Person.create({fname: 'John', lname: 'Smith'});
      var e = foam.core.ExpressionSlot.create({
        args: [ p.fname$, p.lname$ ],
        code: function(f, l) { return f + ' ' + l; }
      });
      log(e.get());
      e.sub(log);
      p.fname = 'Steve';
      p.lname = 'Jones';
      log(e.get());

      Output:
       > John Smith
       > [object Object] propertyChange value [object Object]
       > [object Object] propertyChange value [object Object]
       > Steve Jones

      var p = foam.CLASS({name: 'Person', properties: [ 'f', 'l' ]}).create({f:'John', l: 'Doe'});
      var e = foam.core.ExpressionSlot.create({
        obj: p,
        code: function(f, l) { return f + ' ' + l; }
      });
    </pre>
  `,

  properties: [
    'obj',
    'code',
    {
      name: 'args',
      expression: function(obj) {
        foam.assert(obj, 'ExpressionSlot: "obj" or "args" required.');

        var args = foam.Function.argNames(this.code);
        for ( var i = 0 ; i < args.length ; i++ ) {
          args[i] = obj.slot(args[i]);
        }

        // this.invalidate(); // ???: Is this needed?
        this.subToArgs_(args);

        return args;
      },
      postSet: function(_, args) {
        this.subToArgs_(args);
      }
    },
    {
      name: 'value',
      factory: function() {
        return this.code.apply(this.obj || this, this.args.map(function(a) {
          return a.get();
        }));
      }
    },
    'cleanup_', // detachable to cleanup old subs when obj changes
  ],

  methods: [
    function init() { this.onDetach(this.cleanup); },

    function get() { return this.value; },

    function set() { /* nop */ },

    function sub(l) {
      return arguments.length === 1 ?
        this.SUPER('propertyChange', 'value', l) :
        this.SUPER.apply(this,arguments);
    },

    function subToArgs_(args) {
      this.cleanup();

      var cleanup = foam.core.FObject.create();

      for ( var i = 0 ; i < args.length ; i++ ) {
        cleanup.onDetach(args[i].sub(this.invalidate));
      }

      this.cleanup_ = cleanup;
    }
  ],

  listeners: [
    function cleanup() { this.cleanup_ && this.cleanup_.detach(); },
    function invalidate() { this.clearProperty('value'); }
  ]
});
/**
 * @license
 * Copyright 2016 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * The Proxy axiom enables your class to automatically proxy methods of
 * an interface to a delegate object.
 *
 * It is an implementation of the Proxy design pattern.
 *
 * The Proxy axiom itself is a property which holds the delegate object
 * that we are proxying.  It also installs a number of Method axioms onto
 * the target class, which proxy all the the specific methods of the interface
 * being proxied.
 *
 * Currently only methods are proxied.
 *
 * USAGE:
 *
 * foam.CLASS({
 *   name: 'Abc',
 *   methods: [
 *     function foo() {
 *       console.log("foo");
 *     }
 *   ]
 * });
 *
 * foam.CLASS({
 *   name: 'ProxyAbc',
 *   properties: [
 *     {
 *       class: 'Proxy',
 *       of: 'Abc'
 *       name: 'delegateAbc'
 *     }
 *   ]
 * });
 *
 * var a = ProxyAbc.create({ delegateAbc: Abc.create() });
 * a.foo();
 *
 * will output:
 *
 * "foo"
 *
 *
 * Methods can be forwarded or delegated to the proxied object.
 * Forwarded methods are the simple case:
 *
 * function foo() {
 *   // This is what a forwarded method looks like
 *   this.delegateAbc.foo();
 * }
 *
 * Delegated methods call the proxied object's implementation
 * but keep "this" as the same object.
 *
 * If the foo method was delegated it would look like this:
 *
 * function foo() {
 *   this.delegateAbc.foo.call(this);
 * }
 *
 * FUTURE(adamvy): Support proxying properties?
 * TODO(adamvy): Document how topics are proxied once the implementation is settled.
 */
// NB: Extending a Proxied object and unsetting options (like setting
//     topics: []) will not undo the work the base class has already done.
//     The ProxySub is already installed in the prototype and will still
//     be active in the derived class, even though it appears that topics is
//     not proxied when examining the dervied class' axiom.
foam.CLASS({
  package: 'foam.core',
  name: 'Proxy',
  extends: 'Property',

  properties: [
    { name: 'of', required: true },
    {
      class: 'StringArray',
      name: 'topics'
    },
    {
      class: 'StringArray',
      name: 'forwards',
      factory: null,
      value: null
      //documentation: 'Methods that are forwarded to the proxies object.'
    },
    {
      class: 'StringArray',
      name: 'delegates',
      factory: null,
      value: null
      //documentation: 'Methods that are delegated to the proxied object.'
    },
    {
      name: 'fromJSON',
      value: function(json, ctx) {
        return foam.json.parse(json, null, ctx);
      }
    }
  ],

  methods: [
    function installInClass(cls) {
      this.SUPER(cls);

      var name     = this.name;
      var delegate = this.lookup(this.of);

      function resolveName(name) {
        var m = delegate.getAxiomByName(name);
        foam.assert(foam.core.Method.isInstance(m), 'Cannot proxy non-method', name);
        return m;
      }

      var delegates = this.delegates ? this.delegates.map(resolveName) : [];

      var forwards = this.forwards ?
          this.forwards.map(resolveName) :
          // TODO(adamvy): This isn't the right check.  Once we have modeled interfaces
          // we can proxy only that which is defined in the interface.
          delegate.getOwnAxiomsByClass(foam.core.Method);

      var axioms = [];
      for ( var i = 0 ; i < forwards.length ; i++ ) {
        var method = forwards[i];
        axioms.push(foam.core.ProxiedMethod.create({
          name: method.name,
          returns: method.returns,
          property: name,
          args: method.args
        }));
      }

      for ( var i = 0 ; i < delegates.length ; i++ ) {
        var method = delegates[i];
        axioms.push(foam.core.ProxiedMethod.create({
          name: method.name,
          returns: method.returns,
          property: name,
          args: method.args,
          delegate: true
        }));
      }

      if ( ! this.topics || this.topics.length ) {
        axioms.push(foam.core.ProxySub.create({
          topics: this.topics,
          prop:   this.name
        }));
      }

      cls.installAxioms(axioms);
    }
  ]
});

/**
 * ProxiedMethod is a type of method that delegates or forwards calls
 * to a delegate object.  It is used as an implementation detail of the
 * Proxy axiom
 *
 * Delegation means that the delegate object's implementation is called with
 * "this" still being the original object.
 *
 * Forwarding means that the method call is simply "forwarded" to the delegate
 * object.  "this" will be the delegate object.
 */
foam.CLASS({
  package: 'foam.core',
  name: 'ProxiedMethod',
  extends: 'Method',

  properties: [
    {
      class: 'String',
      name: 'property'
    },
    {
      class: 'Boolean',
      name: 'delegate',
      value: false
    },
    {
      name: 'code',
      expression: function(name, property, returns, delegate) {
        return delegate ?
            function delegate() {
              return this[property][name].apply(this, arguments);
            } :
            function forward() {
              return this[property][name].apply(this[property], arguments);
            } ;
      }
    }
  ]
});


foam.CLASS({
  package: 'foam.core',
  name: 'EventProxy',

  properties: [
    {
      name: 'dest',
      swiftType: 'Topic',
    },
    {
      class: 'StringArray',
      name: 'topic',
      factory: function() { return []; }
    },
    {
      class: 'Boolean',
      name: 'active',
      value: false,
      postSet: function(old, a) {
        for ( var key in this.children ) {
          this.children[key].active = ! a;
        }

        if ( old !== a ) {
          if ( a ) {
            this.doSub();
          } else {
            this.doUnsub();
          }
        }
      },
      swiftPostSet: `
for child in children.values {
  child.active = !newValue
}

if (oldValue as? Bool ?? false) != newValue {
  if newValue {
    self.doSub()
  } else {
    self.doUnsub()
  }
}
      `
    },
    {
      name: 'parent',
      swiftType: 'EventProxy?',
    },
    {
      name: 'children',
      factory: function() {
        return {};
      },
      swiftType: '[String:EventProxy]',
      swiftFactory: 'return [:]',
    },
    {
      name: 'src',
      postSet: function(o, src) {
        if ( this.active ) this.doSub();
        for ( var key in this.children ) {
          this.children[key].src = src;
        }
      }
    },
    {
      swiftType: 'Subscription?',
      name: 'subscription',
    }
  ],

  methods: [
    {
      name: 'init',
      code: function() {
        this.onDetach(foam.Function.bind(function() {
          this.subscription && this.subscription.detach();

          if ( this.parent ) {
            this.parent.removeChild(this);
            this.parent.active = true;
          }
        }, this));
      },
      swiftCode: `
onDetach(Subscription(detach: { [weak self] in
  self?.subscription?.detach()
  if let parent = self?.parent {
    parent.removeChild(self!)
    parent.active = true
  }
}))
      `,
    },

    {
      name: 'doSub',
      code: function doSub() {
        if ( this.subscription ) this.subscription.detach();

        if ( ! this.src ) return;

        var args = this.topic.slice()
        args.push(this.onEvent);
        this.subscription = this.src.sub.apply(this.src, args);
      },
      swiftCode: `
subscription?.detach()
if let src = src as? Topic {
  subscription = src.sub(topics: topic, listener: onEvent_listener)
}
      `,
    },

    {
      name: 'doUnsub',
      code: function doUnsub() {
        if ( this.subscription ) this.subscription.detach();
      },
      swiftCode: 'subscription?.detach()',
    },

    {
      name: 'removeChild',
      args: [
        {
          name: 'c',
          swiftType: 'EventProxy',
        },
      ],
      code: function removeChild(c) {
        for ( var key in this.children ) {
          if ( this.children[key] === c ) {
            delete this.children[key];
            return;
          }
        }
      },
      swiftCode: `
for (key, child) in children {
  if child === c {
    children.removeValue(forKey: key)
    return
  }
}
      `,
    },

    {
      name: 'getChild',
      args: [
        {
          name: 'key',
          swiftType: 'String',
        },
      ],
      swiftReturns: 'EventProxy',
      code: function getChild(key) {
        if ( ! this.children[key] ) {
          this.children[key] = this.cls_.create({
            parent: this,
            dest: this.dest,
            src: this.src,
            topic: this.topic.slice().concat(key)
          });
        }
        return this.children[key];
      },
      swiftCode: `
if children[key] == nil {
  children[key] = __context__.create(EventProxy.self, args: [
    "parent": self,
    "dest": dest,
    "src": src,
    "topic": topic + [key],
  ])!
}
return children[key]!
      `,
    },

    {
      name: 'addProxy',
      args: [
        {
          name: 'topics',
          swiftType: '[String]',
        },
      ],
      code: function addProxy(topic) {
        var c = this;
        var active = true;
        for ( var i = 0 ; i < topic.length ; i++ ) {
          active = active && ! c.active;
          c = c.getChild(topic[i]);
        }

        c.active = active;
      },
      swiftCode: `
var c = self
var active = true
for t in topics {
  active = active && !c.active
  c = c.getChild(t)
}

c.active = active;
      `,
    },
  ],

  listeners: [
    {
      name: 'onEvent',
      code: function() {
        if ( this.active ) {
          var args = foam.Function.appendArguments([], arguments, 1);
          var c = this.dest.pub.apply(this.dest, args);
          if ( ! c ) this.detach();
        }
      },
      swiftCode: `
if active {
  let c = dest.pub(args);
  if c == 0 { detach() }
}
      `,
    },
  ]
});

foam.CLASS({
  package: 'foam.core',
  name: 'ProxySub',
  extends: 'Method',

  properties: [
    {
      name: 'name',
      getter: function() {
        return 'sub';
      }
    },
    {
      class: 'String',
      name: 'prop'
    },
    {
      class: 'StringArray',
      name: 'topics',
      factory: null
    },
    {
      name: 'code',
      expression: function(prop, topics) {
        var privateName = prop + 'EventProxy_';
        return function subProxy(a1) {
          if ( ! topics || topics.indexOf(a1) != -1 ) {
            var proxy = this.getPrivate_(privateName);
            if ( ! proxy ) {
              proxy = foam.core.EventProxy.create({
                dest: this,
                src: this[prop]
              });
              this.setPrivate_(privateName, proxy);

              proxy.src$.follow(this.slot(prop));
            }

            proxy.addProxy(Array.from(arguments).slice(0, -1));
          }

          return this.SUPER.apply(this, arguments);
        };
      }
    }
  ]
});
/**
 * @license
 * Copyright 2016 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

foam.CLASS({
  package: 'foam.core',
  name: 'PromisedMethod',
  extends: 'ProxiedMethod',

  properties: [
    {
      name: 'code',
      expression: function(name, property, returns, delegate) {
        if ( delegate ) {
          return returns ?
            function() {
              var self = this;
              var args = arguments;
              return this[property].then(function(d) {
                return d[name].apply(self, args);
              });
            } :
            function() {
              var self = this;
              var args = arguments;
              this[property].then(function(d) {
                d[name].apply(self, args);
              });
            };
        }
        return returns ?
          function() {
            var self = this;
            var args = arguments;
            return this[property].then(function(d) {
              return d[name].apply(d, args);
            });
          } :
          function() {
            var self = this;
            var args = arguments;
            this[property].then(function(d) {
              d[name].apply(d, args);
            });
          };
      }
    }
  ]
});


foam.CLASS({
  package: 'foam.core',
  name: 'Promised',
  extends: 'Property',

  properties: [
    {
      name: 'of',
      required: true
    },
    {
      class: 'StringArray',
      name: 'methods',
      value: null,
      factory: null
    },
    {
      class: 'StringArray',
      name: 'topics',
      value: null,
      factory: null
    },
    {
      name: 'postSet',
      expression: function(name) {
        var stateName    = name + 'State';
        var delegateName = name + 'Delegate';
        return function(_, p) {
          var self = this;
          this[stateName]    = undefined;
          this[delegateName] = undefined;

          p.then(function(d) { self[delegateName] = d; });
        };
      }
    }
  ],

  methods: [
    function installInClass(cls) {
      this.SUPER(cls);

      var myName         = this.name;
      var stateName      = this.name + 'State';
      var delegateName   = this.name + 'Delegate';
      var pendingState   = 'Pending' + foam.String.capitalize(myName);
      var fulfilledState = 'Fulfilled' + foam.String.capitalize(myName);

      var delegate = this.lookup(this.of);

      function resolveName(name) {
        var m = delegate.getAxiomByName(name);
        foam.assert(foam.core.Method.isInstance(m), 'Cannot proxy non-method', name);
        return m;
      }

      var methods = this.methods ?
          this.methods.map(resolveName) :
          delegate.getOwnAxiomsByClass(foam.core.Method);

      var methodNames = methods.map(function(m) { return m.name; });

      var myAxioms = [
        foam.core.Proxy.create({
          name:      stateName,
          of:        this.of,
          delegates: methodNames,
          forwards:  [],
          factory: function() {
            return this[pendingState].create();
          },
          swiftFactory: `return ${pendingState}_create(["obj": self])`,
          transient: true
        }),
        foam.core.Property.create({
          name: delegateName,
          postSet: function() {
            this[stateName] = this[fulfilledState].create();
          },
          swiftGetter: `return try! ${myName}.get() as! ${foam.lookup(this.of).model_.swiftName}`,
        }),
        foam.core.ProxySub.create({
          topics: this.topics,
          prop:   delegateName
        })
      ];

      var pendingMethods = [];

      for ( var i = 0 ; i < methods.length ; i++ ) {
        pendingMethods.push(foam.core.PromisedMethod.create({
          name: methods[i].name,
          property: myName,
          returns:  methods[i].returns,
          delegate: false
        }));
      }

      var name = this.name;
      myAxioms = myAxioms.concat(
        foam.core.InnerClass.create({
          model: {
            name: pendingState,
            implements: [this.of],
            axioms: [
              foam.pattern.Singleton.create()
            ],
            methods: pendingMethods,
            properties: [
              {
                swiftType: cls.model_.swiftName,
                name: 'obj',
              },
            ],
          }
        }),
        foam.core.InnerClass.create({
          model: {
            name: fulfilledState,
            properties: [
              {
                class:    'Proxy',
                name:     delegateName,
                of:       this.of,
                topics:   this.topics,
                forwards: methodNames
              }
            ],
            axioms: [
              foam.pattern.Singleton.create()
            ],
            generateSwift: false,
          }
        }));

      cls.installAxioms(myAxioms);
    }
  ]
});
/**
 * @license
 * Copyright 2016 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

foam.CLASS({
  package: 'foam.core.internal',
  name: 'InterfaceMethod',
  extends: 'foam.core.Method',

  documentation: 'An InterfaceMethod is a Method declaration, but lacks code.',

  properties: [
    {
      name: 'code',
      required: false
    },
    {
      class: 'Boolean',
      name: 'abstract',
      value: true
    }
  ],

  methods: [
    function installInProto() { },
    function installInClass(cls, superMethod, existingMethod) {
      // This is required to avoid inheritance from regular methods,
      // which would prevent methods from being named the same as methods
      // defined on FObject, like: log, warn, error.
      cls.axiomMap_[this.name] = this;
    }
  ]
});


foam.CLASS({
  package: 'foam.core',
  name: 'InterfaceModel',
  extends: 'foam.core.Model',

  documentation: 'An Interface Mode/definition. Created with foam.INTERFACE().',

  properties: [
    [ 'extends', 'foam.core.AbstractInterface' ],
    {
      class: 'AxiomArray',
      name: 'methods',
      of: 'foam.core.internal.InterfaceMethod'
    },
    {
      class: 'StringArray',
      name: 'javaExtends'
    }
  ]
});


foam.CLASS({
  package: 'foam.core',
  name: 'AbstractInterface',

  documentation: 'Abstract base-class for Interfaces.',

  axioms: [
    {
      installInClass: function(cls) {
        cls.create = function() {
          throw new Error("Cannot instantiate an Interface.");
        };
      }
    }
  ]
});


foam.LIB({
  name: 'foam',

  methods: [
    function INTERFACE(m) {

      m.class = m.class || 'foam.core.InterfaceModel';
      // if m.implements not defined, add it as an array, otherwise add its content
      // in an array
      if ( ! m.implements ) {
        m.implements = [];
      } else if ( typeof m.implements === 'string' ) {
        m.implements = [m.implements];
      }
      // adds m.extends content to m.implements and then remove it
      if ( m.extends ) {
        if ( typeof m.extends === 'string' ) {
          m.implements.push(m.extends);
        } else if( m.extends.length > 0 ) {
          m.implements = m.implements.concat(m.extends);
        }
        delete m.extends;
      }
      foam.CLASS(m);
    }
  ]
});
/**
 * @license
 * Copyright 2017 The FOAM Authors. All Rights Reserved.
 * http://www.apache.org/licenses/LICENSE-2.0
 */

foam.INTERFACE({
  package: 'foam.core',
  name: 'Axiom',

  documentation: 'Represents an axiom',

  methods: [
    {
      name: 'getName',
      returns: 'String',
      javaReturns: 'String'
    }
  ]
});
/**
 * @license
 * Copyright 2017 The FOAM Authors. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

foam.INTERFACE({
  package: 'foam.core',
  name: 'Exception',
  swiftImplements: ['Error'],
});
/**
 * @license
 * Copyright 2016 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

foam.CLASS({
  package: 'foam.core',
  name: 'ContextMethod',
  extends: 'foam.core.Method',

  documentation: 'A Method which has the call-site context added as the first argument when exported. See use in foam.u2.U2Context.E',

  methods: [
    function exportAs(obj) {
      var m = obj[this.name];

      return function() {
        var ctx = foam.core.FObject.isInstance(this) ? this.__context__ : this;

        return m.apply(obj, foam.Function.appendArguments([ctx], arguments, 0));
      };
    }
  ]
});
/**
 * @license
 * Copyright 2016 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

foam.CLASS({
  package: 'foam.core',
  name: 'Window',

  documentation: function(){/*
    Encapsulates top-level window/document features.

    Export common window/document services through the Context.

    Rather than using window or document directly, objects should import: the
    services that foam.core.Window exports:, and then access them as this.name,
    rather than as console.name or document.name.

    All FObjects already import: [ 'error', 'log', 'warn' ], meaning
    that these do not need to be explicitly imported.

    This is done to remove dependency on the globals 'document' and 'window',
    which makes it easier to write code which works with multiple windows.

    It also allows for common services to be decorated, trapped, or replaced
    in sub-contexts (for example, to replace console.error and console.warn when
    running test).

    A foam.core.Window is installed by FOAM on starup for the default
    window/document, but if user code opens a new Window, it should create
    and install a new foam.core.Window explicitly.
  */},

  exports: [
    'getElementsByClassName',
    'getElementById',
    'async',
    'cancelAnimationFrame',
    'clearInterval',
    'clearTimeout',
    'console',
    'debug',
    'delayed',
    'document',
    'error',
    'framed',
    'info',
    'installCSS',
    'log',
    'merged',
    'requestAnimationFrame',
    'setInterval',
    'setTimeout',
    'warn',
    'window'
  ],

  properties: [
    [ 'name', 'window' ],
    'window',
    {
      name: 'document',
      factory: function() { return this.window.document; }
    },
    {
      name: 'console',
      factory: function() { return this.window.console; }
    }
  ],

  methods: [
    function getElementById(id) {
      return this.document.getElementById(id);
    },

    function getElementsByClassName(cls) {
      return this.document.getElementsByClassName(cls);
    },

    function debug() {
      this.console.debug.apply(this.console, arguments);
    },

    function error() {
      this.console.error.apply(this.console, arguments);
    },

    function info() {
      this.console.info.apply(this.console, arguments);
    },

    function log() {
      this.console.log.apply(this.console, arguments);
    },

    function warn() {
      var msg = Array.prototype.join.call(arguments, '');
      if ( SUPPRESSED_WARNINGS[msg] ) return;
      this.console.warn(msg)
    },

    function async(l) {
      /* Decorate a listener so that the event is delivered asynchronously. */
      return this.delayed(l, 0);
    },

    function delayed(l, delay) {
      /* Decorate a listener so that events are delivered 'delay' ms later. */
      return foam.Function.bind(function() {
        this.setTimeout(
          function() { l.apply(this, arguments); },
          delay);
      }, this);
    },

    function merged(l, opt_delay) {
      var delay = opt_delay || 16;
      var ctx     = this;

      return foam.Function.setName(function() {
        var triggered = false;
        var lastArgs  = null;
        function mergedListener() {
          triggered = false;
          var args = Array.from(lastArgs);
          lastArgs = null;
          l.apply(this, args);
        }

        var f = function() {
          lastArgs = arguments;

          if ( ! triggered ) {
            triggered = true;
            ctx.setTimeout(mergedListener, delay);
          }
        };

        return f;
      }(), 'merged(' + l.name + ')');
    },

    function framed(l) {
      var ctx = this;

      return foam.Function.setName(function() {
        var triggered = false;
        var lastArgs  = null;
        function frameFired() {
          triggered = false;
          var args = lastArgs;
          lastArgs = null;
          l.apply(this, args);
        }

        var f = function framed() {
          lastArgs = arguments;

          if ( ! triggered ) {
            triggered = true;
            ctx.requestAnimationFrame(frameFired);
          }
        };

        return f;
      }(), 'framed(' + l.name + ')');
    },

    function setTimeout(f, t) {
      return this.window.setTimeout(f, t);
    },
    function clearTimeout(id) {
      this.window.clearTimeout(id);
    },

    function setInterval(f, t) {
      return this.window.setInterval(f, t);
    },
    function clearInterval(id) {
      this.window.clearInterval(id);
    },

    function requestAnimationFrame(f) {
      return this.window.requestAnimationFrame(f);
    },
    function cancelAnimationFrame(id) {
      this.window.cancelAnimationFrame(id);
    },
    function installCSS(text, id) {
      /* Create a new <style> tag containing the given CSS code. */
      this.document && this.document.head.insertAdjacentHTML('beforeend',
          '<style owner="' + id + '">' + text + '</style>');
    }
  ]
});


/*
 * requestAnimationFrame is not available on nodejs,
 * so swap out with calls to setTimeout.
 */
if ( foam.isServer ) {
  foam.CLASS({
    refines: 'foam.core.Window',
    methods: [
      function requestAnimationFrame(f) {
        return this.setTimeout(f, 16);
      },
      function cancelAnimationFrame(id) {
        this.clearTimeout(id);
      }
    ]
  });
}


// Replace top-level Context with one which includes Window's exports.
foam.__context__ = foam.core.Window.create(
  { window: global },
  foam.__context__
).__subContext__;
/**
 * @license
 * Copyright 2017 The FOAM Authors. All Rights Reserved.
 * http://www.apache.org/licenses/LICENSE-2.0
 */

foam.CLASS({
  package: 'foam.core.internal',
  name: 'ContextMultipleInheritence',
  
  exports: [
    'createSubContext'
  ],

  methods: [
    {
      class: 'ContextMethod',
      name: 'createSubContext',
      code: function createSubContext(X, opt_args, opt_name) {
        // TODO(adamvy): Revisit this.  Consider adding a MultiContext object which
        // implemented context multiple inheritence property.
        if ( foam.core.FObject.isInstance(opt_args) ) {
          var obj = opt_args;

          var exports = obj.cls_.getAxiomsByClass(foam.core.Export);

          if ( ( ! exports ) || ( ! exports.length ) ) return X;

          opt_args = exports[0].getExportMap.call(obj);
        }

        return this.__context__.createSubContext.call(X, opt_args, opt_name);
      }
    }
  ]
});

(function() {
  var tmp = foam.core.internal.ContextMultipleInheritence.create();
  tmp.setPrivate_('__context__', foam.__context__);
  foam.__context__ = tmp.__subContext__;
})();
/**
 * @license
 * Copyright 2016 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

foam.CLASS({
  package: 'foam.classloader',
  name: 'ModelARequireExtension',
  refines: 'foam.core.Model',

  methods: [
    function arequire(opt_deps) {
      var X = this.__context__;
      var promises = [];
      if ( this.extends ) promises.push(X.arequire(this.extends, opt_deps));

      for ( var i = 0, a; a = this.axioms_[i]; i++ ) {
        if ( a.arequire ) promises.push(a.arequire(opt_deps));
      }

      return Promise.all(promises);
    }
  ]
});


foam.CLASS({
  package: 'foam.classloader',
  name: 'RequiresARequireExtension',
  refines: 'foam.core.Requires',

  methods: [
    function arequire(opt_deps) {
      return this.__context__.arequire(this.path, opt_deps);
    }
  ]
});


foam.CLASS({
  package: 'foam.classloader',
  name: 'ClassLoader',

  documentation: 'Asynchronous class loader service. Loads classes dynamically.',

  exports: [
    'arequire'
  ],

  properties: [
    {
      name: 'pending',
      class: 'Object',
      factory: function() { return {}; }
    }
  ],

  methods: [
    {
      name: 'arequire',
      class: 'foam.core.ContextMethod',
      code: function(X, modelId, opt_deps) {
        // Contains models that depend on the modelId and have already been
        // arequired. Used to avoid circular dependencies from waiting on
        // each other.
        var deps = opt_deps || {};

        if ( X.isRegistered(modelId) ) return Promise.resolve();
        if ( deps[modelId] ) return Promise.resolve();
        if ( this.pending[modelId] ) return this.pending[modelId];
        deps[modelId] = true;

        var modelDao = X.classloader[foam.String.daoize(foam.core.Model.name)];
        this.pending[modelId] = modelDao.find(modelId).then(function(m) {
          // Model validation may make use of deps. Require them first, then
          // validate the model.
          foam.assert(m, 'Cannot find ' + modelId);
          return m.arequire(deps).then(function() {
            m.validate();
            return m;
          });
        }).then(function(m) {
          if ( X.isRegistered(modelId) ) return m;

          if ( m.refines ) {
            foam.CLASS(m);
            return m;
          }

          m.id = m.package ? m.package + '.' + m.name : m.name;
          foam.UNUSED[m.id] = true;

          var f = foam.Function.memoize0(function() {
            delete foam.UNUSED[m.id];
            var c = m.buildClass();
            c.validate();
            foam.USED[m.id] = c;
            return c;
          });

          // Register model in global context and global namespace.
          foam.__context__.registerFactory(m, f);
          foam.package.registerClassFactory(m, f);
          return m;
        });

        var self = this;
        this.pending[modelId].then(function() {
          delete self.pending[modelId];
        });

        return this.pending[modelId];
      }
    }
  ]
});

// Export ClassLoader.arequire by overwriting global context with
// ClassLoader's sub-context.
foam.__context__ = foam.classloader.ClassLoader.create(
  {},
  foam.__context__
).__subContext__;
/**
 * @license
 * Copyright 2016 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

foam.LIB({
  name: 'foam.Function',

  methods: [
    (function() {
      var ret = function resolveTypeString(typeStr) {
        /** Looks up a type as a FOAM class, stdlib String, Number, etc., or 'any' */
        // missing types are checked for _after_ the body comment is checked
        if ( ! typeStr ) return undefined;

        typeStr = typeStr.trim();
        if ( typeStr.substring(typeStr.length - 2) === '[]' ) {
          return foam.Array;
        }
        if ( typeStr === 'any' || typeStr == '``' ) {
          return undefined;
        }

        // otherwise look for foam.<primitive> type
        cls = foam[typeStr];
        if ( cls ) return cls;

        var cls = foam.lookup(typeStr, true);
        if ( cls ) return cls;

        // could not resolve
        throw new TypeError('foam.Function.args could not resolve type ' +
          typeStr);
      };
      ret.isTypeChecked__ = true;
      return ret;
    })(),

    function args(fn) {
      /**
       * Extracts the arguments and their types from the given function.
       * @param {Function} fn The function to extract from. The toString() of the function
       *     must be accurate.
       * @return {Array} An array of Argument objects.
       */
      // strip newlines and find the function(...) declaration
      var args = foam.Function.argsStr(fn);

      if ( ! args ) return [];

      args += ','; // easier matching

      var ret = [];
      var retMapByName = {};
      // check each arg for types
      // Optional commented type(incl. dots for packages), argument name,
      // optional commented return type
      // ws [/* ws package.type? ws */] ws argname ws [/* ws retType ws */]
      var argIdx = 0;
      var argMatcher = /(\s*\/\*\s*(\.\.\.)?([\w._$\[\]]+)(\=)?\s*(\/\/\s*(.*?))?\s*\*\/)?\s*(\.\.\.)?([\w_$]+)\s*(\/\*\s*([\w._$\[\]`]*)(\?)?\s*\*\/)?\s*\,+/g;
      var typeMatch;

      while ( typeMatch = argMatcher.exec(args) ) {
        // if can't match from start of string, fail
        if ( argIdx === 0 && typeMatch.index > 0 ) break;

        if ( ret.returnType ) {
          throw new SyntaxError('foam.Function.args return type \'' +
            ret.returnType.typeName +
            '\' must appear after the last argument only: ' +
            args.toString() + '\n' +
            'For function:\n' +
            fn.toString() + '\n'

          );
        }

        // record the argument
        var arg = foam.core.Argument.create({
          name:          typeMatch[8],
          typeName:      typeMatch[3],
          type:          this.resolveTypeString(typeMatch[3]),
          optional:      true, //typeMatch[4] === '=', // TODO: mandatory
          repeats:       typeMatch[2] === '...' || typeMatch[7] === '...',
          index:         argIdx++,
          documentation: typeMatch[6]
        });
        ret.push(arg);
        retMapByName[arg.name] = arg;

        // if present, record return type (if not the last arg, we fail on the
        // next iteration)
        if ( typeMatch[9] ) {
          ret.returnType = foam.core.Argument.create({
            name: 'ReturnValue',
            optional: typeMatch[11],
            typeName: typeMatch[10]
          });
        }
      }

      if ( argIdx === 0 ) {
        // check for bare return type with no args
        typeMatch = args.match(/^\s*\/\*\s*([\w._$\[\]]+)(\=)?\s*\*\/\s*/);
        if ( typeMatch && typeMatch[1] ) {
          foam.assert(! ret.returnType,
            'foam.Function.args found two return types: ' + fn.toString());
          ret.returnType = foam.core.Argument.create({
            name: 'ReturnValue',
            optional: typeMatch[2] === '=',
            typeName: typeMatch[1]
          });
        } else {
          throw new SyntaxError(
              'foam.Function.args argument parsing error:\n' +
              args.toString() + '\n' +
            'For function:\n' +
            fn.toString() + '\n'
          );
        }
      }

      // Also pull args out of the documentation comment (if inside the body
      // so we can access it)
      var comment = foam.Function.functionComment(fn);
      if ( comment ) {
        // match @arg or @param {opt_type} arg_name
        var commentMatcher = /.*(\@arg|\@param|\@return)\s+(?:\{(\.\.\.)?([\w._$\[\]]+)(\=)?\}\s+)?(.*?)\s+(?:([^\@]*))?/g;
        var commentMatch;
        while ( commentMatch = commentMatcher.exec(comment) ) {
          var name     = commentMatch[5];
          var optional = commentMatch[4] === '=';
          var repeats  = commentMatch[2] === '...';
          var type     = commentMatch[3];
          var docs     = commentMatch[6] && commentMatch[6].trim();

          if ( commentMatch[1] === '@return' ) {
            if ( ret.returnType ) {
              throw new SyntaxError(
                  'foam.Function.args duplicate return type ' +
                  'definition in block comment: \"' +
                  type + '\" from \:\n' + fn.toString());
            }

            ret.returnType = foam.core.Argument.create({
              name: 'ReturnValue',
              optional: optional,
              repeats: repeats,
              typeName: type,
              type: this.resolveTypeString(type),
              documentation: docs
            });
          } else {
            // check existing args
            if ( retMapByName[name] ) {
              if ( retMapByName[name].typeName ) {
                throw new SyntaxError(
                    'foam.Function.args duplicate argument ' +
                    'definition in block comment: \"' +
                    name + '\" from:\n' + fn.toString());
              }

              retMapByName[name].typeName      = type;
              retMapByName[name].optional      = optional;
              retMapByName[name].repeats       = repeats;
              retMapByName[name].documentation = docs;
              retMapByName[name].type          = this.resolveTypeString(type);
            } else {
              var arg = foam.core.Argument.create({
                name:          name,
                optional:      optional,
                repeats:       repeats,
                typeName:      type,
                index:         argIdx++,
                documentation: docs
              });
              ret.push(arg);
              retMapByName[arg.name] = arg;
            }
          }
        }
      }

      // Check for missing types
      var missingTypes = [];
      for ( var i = 0; i < ret.length; i++ ) {
        if ( ! ret[i].typeName ) missingTypes.push(ret[i].name);
      }

      if ( missingTypes.length ) {
        //(this.warn || console.warn)('Missing type(s) for ' +
        //  missingTypes.join(', ') + ' in:\n' + fn.toString());
      }

      return ret;
    }
  ]
});


foam.CLASS({
  package: 'foam.core',
  name: 'Argument',

  documentation: 'Describes one argument of a function or method.',

  properties: [
    {
      /** The name of the argument */
      name: 'name'
    },
    {
      name: 'of'
    },
    {
      /**
       * The string name of the type
       * (either a model name or foam.String, foam.Function, etc. or [])
       */
      name: 'typeName'
    },
    {
      /**
       * If set, this holds the actual FOAM Class or LIB represented
       * by typeName.
       */
      name: 'type',
      factory: function() {
        return foam.Function.resolveTypeString(this.typeName) || null;
      }
    },
    {
      /** If true, indicates that this argument is optional. */
      name: 'optional', value: false
    },
    {
      /** If true, indicates a variable number of arguments. */
      name: 'repeats', value: false
    },
    {
      /** The index of the argument (the first argument is at index 0). */
      name: 'index', value: -1
    },
    {
      /** The documentation associated with the argument (denoted by a // ) */
      name: 'documentation', value: ''
    }
  ],

  methods: [
    (function() {
      var validate = function validate(arg) {
        /**
          Validates the given argument against this type information.
          If any type checks are failed, a TypeError is thrown.
         */
        if ( ! this.type ) {
          // no type, no check to perform
          return;
        }

        var i = ( this.index >= 0 ) ? ' ' + this.index + ', ' : ', ';

        // optional check
        if ( foam.Null.isInstance(arg) || foam.Undefined.isInstance(arg) ) {
          if ( ! this.optional ) {
            throw new TypeError(
              'Argument ' + i + this.name + ' {' + this.typeName + '}' +
                ', is not optional, but was undefined in a function call');
          }

          return; // value is undefined, but ok with that
        }

        // have a modelled type
        if ( ! this.type.isInstance(arg) ) {
          var gotType = (arg.cls_) ? arg.cls_.name : typeof arg;
          throw new TypeError(
              'Argument ' + i + this.name +
              ', expected type ' + this.typeName + ' but passed ' + gotType);
        }
      };

      validate.isTypeChecked__ = true; // avoid type checking this method
      return validate;
    })()
  ]
});

foam.CLASS({
  refines: 'foam.core.Method',
  properties: [
    {
      class: 'FObjectArray',
      of: 'foam.core.Argument',
      name: 'args',
      adaptArrayElement: function(e, obj) {
        var ctx = obj.__subContext__ || foam;
        var of = e.class || this.of;
        var cls = ctx.lookup(of);

        return cls.isInstance(e) ? e :
          foam.String.isInstance(e) ? cls.create({ name: e }) :
          cls.create(e, obj);
      }
    }
  ]
});
/**
 * @license
 * Copyright 2016 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*
  A -> foo(C)
       foo(D)
  B -> foo(C)

  How does B.foo(D) work?
  Copy methods? Then what if A gets refined?
  Lookup B.foo, otherwise lookup A.foo()?
    Then what about FObject vs. particular class lookup?
  What about treating 'this' as first argument?
*/

foam.CLASS({
  package: 'foam.core',
  name: 'MultiMethod',
  extends: 'foam.core.AbstractMethod',

  properties: [
    {
      name: 'name',
      factory: function() {
        return this.methodName +
          this.args.map(function(a) { return a.typeName; }).join(':');
      }
    },
    {
      name: 'methodName',
      required: true
    }
  ],

  methods: [
    function installInProto(proto) {
      var key = this.cls_.id.replace(/\./g,':') + ':' + this.methodName;
      console.log('Installing: ' + key);
      var dispath = this.createDispatch(proto, key, 0, this.args);
      displatch.code = this.code;
    },

    function createDispatch(proto, prefix, pos, args) {
      var d = proto[prefix];

      if ( ! d ) {
        var prefix2 = prefix + ':' + args[pos] + typeName;
        proto[prefix] = function dispatch() {
          if ( arguments.length === pos ) {
            return arguments.callee.code.apply(this, arguments);
          }
          var t = foam.typeOf(arguments[pos]);
          var f = t[prefix2];
          return f.apply(this, arguments);
        };
      }

      if ( pos === args.length ) return proto[prefix];
    },

    function exportAs(obj) {
      var m = obj[this.name];
      /** Bind the method to 'this' when exported so that it still works. **/
      return function exportedMethod() { return m.apply(obj, arguments); };
    }
  ]
});
/**
 * @license
 * Copyright 2016 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

foam.CLASS({
  package: 'foam.pattern',
  name: 'Singleton',

  documentation: `
  A Singleton Axiom, when added to a Class, makes it implement
  the Singleton Pattern, meaning that all calls to create()
  will return the same (single) instance.
  `,

  properties: [ [ 'name', 'create' ] ],

  methods: [
    function installInClass(cls) {
      /** @param {any} cls */
      var oldCreate = cls.create;
      var newCreate = cls.create = function() {
        // This happens when a newer Axiom replaces create().
        // If this happens, don't apply Singleton behaviour.
        if ( this.create !== newCreate )
          return oldCreate.apply(this, arguments);

        return this.private_.instance_ ||
            ( this.private_.instance_ = oldCreate.apply(this, arguments) );
      };
    },

    function installInProto(p) {
      // Not needed, but improves performance.
      p.clone  = function() { return this; };
      p.equals = function(o) { /** @param {any=} o */ return this === o; };
    }
  ]
});

// We only need one Singleton, so make it a Singleton.
foam.CLASS({
  refines: 'foam.pattern.Singleton',
  axioms: [ foam.pattern.Singleton.create() ]
});
/**
 * @license
 * Copyright 2016 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
  A Multiton Axiom, when added to a Class, makes it implement
  the Multiton Pattern, meaning that calls to create() with
  the same value for the specified 'property', will return the
  same instance.

  Ex.:
  foam.CLASS({
    name: 'Color',
    axioms: [ foam.pattern.Multiton.create({property: 'color'}) ],
    properties: [ 'color' ],
    methods: [ function init() { log('Creating Color:', this.color); } ]
  });

  var red1 = Color.create({color: 'red'});
  var red2 = Color.create({color: 'red'});
  var blue = Color.create({color: 'blue'});

  log(red1 === red2); // true, same object
  log(red1 === blue); // false, different objects
*/
foam.CLASS({
  package: 'foam.pattern',
  name: 'Multiton',

  properties: [
    [ 'name', 'create' ],
    {
      // FUTURE: switch to 'properties' to support multiple keys when/if needed.
      class: 'String',
      name: 'property'
    }
  ],

  methods: [
    function installInClass(cls) {
      var property  = this.property;
      var oldCreate = cls.create;

      cls.create = function(args) {
        var instances = this.private_.instances ||
            ( this.private_.instances = {} );
        var key = args[property];

        // If key isn't provided, try using property.value instead
        if ( key === undefined ) {
          key = cls.getAxiomByName(property).value;
        }

        return instances[key] ||
            ( instances[key] = oldCreate.apply(this, arguments) );
      };
    },

    function installInProto(p) {
      // Not needed, but improves performance.
      p.clone  = function() { return this; };
      p.equals = function(o) { return this === o; };
    }
  ]
});
/**
 * @license
 * Copyright 2017 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * For those familiar with Java, FOAM Enums are very similar to Java enums in
 * design.
 *
 * An Enum is essentially a class with a fixed number of named instances.
 * The instances are frequently referred to as Enum Values, or the 'values'
 * of an Enum.
 *
 * Enums have most of the features available to FOAM classes, including
 * properties, methods, constants, templates, and listeners.
 *
 * Enums extend from FObject, so they inherit FObject features such as
 * pub/sub events, diffing, hashCode, etc.
 *
 * Enums also have a few built-in properties by default. Every Enum has an
 * 'ordinal' property, which is a integer unique to all the Enum Values of a
 * particular Enum. Each enum also has a 'name' property, which is the name
 * given to each Enum Value.
 *
 * Example usage:
 * <pre>
 * // To define an enum we use the foam.ENUM() function.
 * foam.ENUM({
 *   name: 'IssueStatus',
 *
 *   // Enums share many features with regular classes, the properties
 *   // and methods we want our enums to have are defined as follows.
 *   properties: [
 *     {
 *       class: 'Boolean',
 *       name: 'consideredOpen',
 *       value: true
 *     }
 *   ],
 *
 *   methods: [
 *     function foo() {
 *       return this.label + ( this.consideredOpen ? ' is' : ' is not' ) +
 *           ' considered open.';
 *     }
 *   ],
 *
 *   // Use the values: key to define the actual Enum Values that we
 *   // want to exist.
 *   values: [
 *     {
 *       name: 'OPEN'
 *     },
 *     {
 *       // The ordinal can be specified explicitly.
 *       name: 'CLOSED',
 *       ordinal: 100
 *     },
 *     {
 *       // If the ordinal isn't given explicitly it is auto assigned as
 *       // the previous ordinal + 1
 *       name: 'ASSIGNED'
 *     },
 *     {
 *       // You can specify the label, which will be used when rendering in a
 *       // combo box or similar
 *       name: 'UNVERIFIED',
 *       label: 'Unverified'
 *     },
 *     {
 *       // Values for additional properties to your enum are also defined
 *       // inline.
 *       name: 'FIXED',
 *       label: 'Fixed',
 *       consideredOpen: false
 *     }
 *   ]
 * });
 *
 * console.log(IssueStatus.OPEN.name); // outputs "OPEN"
 * console.log(IssueStatus.ASSIGNED.consideredOpen); // outputs "true"
 *
 * // Enum value ordinals can be specified.
 * console.log(IssueStatus.CLOSED.ordinal); // outputs 100
 * // values without specified ordinals get auto assigned.
 * console.log(IssueStatus.ASSIGNED.ordinal); // outputs 101
 *
 * // Methods can be called on the enum values.
 * // outputs "Fixed is not considered open."
 * console.log(IssueStatus.FIXED.foo());
 *
 * // To store enums on a class, it is recommended to use the Enum property
 * // type.
 * foam.CLASS({
 *   name: 'Issue',
 *   properties: [
 *     {
 *       class: 'Enum',
 *       of: 'IssueStatus',
 *       name: 'status'
 *     }
 *   ]
 * });
 *
 * var issue = Issue.create({ status: IssueStatus.UNVERIFIED });
 * console.log(issue.status.label); // outputs "Unverified"
 *
 * // Enum properties give you some convenient adapting.
 * // You can set the property to the ordinal or the
 * // name of an enum, and it will set the property
 * // to the correct Enum value.
 *
 * issue.status = 100;
 *
 * issue.status === IssueStatus.CLOSED; // is true
 *
 * // Enum properties also allow you to assign them via the name
 * // of the enum.
 *
 * issue.status = "ASSIGNED"
 *
 * issue.status === IssueStatus.ASSIGNED; // is true
 *
 * The extent of all Enum values can be accessed from either the collection or from any
 * individual Enum value:
 * console.log(IssueStatus.VALUES, IssueStatus.CLOSED.VALUES);
 *
 * Values can be specified as just Strings if you don't want to explicitly set the label
 * or ordinal. Ex.:
 *
 * foam.ENUM({
 *  name: 'DaysOfWeek',
 *  values: [
 *    'SUNDAY',
 *    'MONDAY',
 *    'TUESDAY',
 *    'WEDNESDAY',
 *    'THURSDAY',
 *    'FRIDAY',
 *    'SATURDAY'
 *  ]
 * });
 *
 * </pre>
 */
// TODO: Make extend Model so can override methods (or do some other way).
foam.CLASS({
  package: 'foam.core.internal',
  name: 'EnumValueAxiom',

  documentation: 'The definition of a single Enum value.',

  properties: [
    {
      name: 'ordinal',
      getter: function() { return this.definition.ordinal; },
      setter: function(o) { this.definition.ordinal = o; }
    },
    {
      name: 'name',
      getter: function() { return this.definition.name; }
    },
    'definition'
  ],

  methods: [
    function installInClass(cls) {
      var e = cls.create(this.definition);
      cls.installConstant(this.name, e);
      cls.VALUES.push(e);
    }
  ]
});


foam.CLASS({
  package: 'foam.core',
  name: 'EnumModel',
  extends: 'Model',

  documentation: 'Model for defining Enum(erations).',

  properties: [
    [ 'extends', 'foam.core.AbstractEnum' ],
    {
      class: 'AxiomArray',
      of: 'foam.core.internal.EnumValueAxiom',
      name: 'values',
      adapt: function(_, v) {
        var used = {}; // map of ordinals used to check for duplicates

        var next = 0;
        for ( var i = 0 ; i < v.length ; i++ ) {
          var def = v[i];

          if ( foam.String.isInstance(def) ) {
            def = { label: def, name: foam.String.constantize(def) };
          }

          if ( def.ordinal || def.ordinal === 0 ) {
            next = def.ordinal + 1;
          } else {
            def.ordinal = next++;
          }

          if ( ! foam.core.internal.EnumValueAxiom.isInstance(def) ) {
            v[i] = def = foam.core.internal.EnumValueAxiom.create({definition: def});
          }

          if ( used[def.ordinal] ) {
            throw this.id +
                ' Enum error: duplicate ordinal found ' + def.name + ' ' +
                used[def.ordinal] + ' both have an ordinal of ' + def.ordinal;
          }

          used[def.ordinal] = def.name;
        }

        return v;
      }
    }
  ]
});


foam.CLASS({
  package: 'foam.core',
  name: 'AbstractEnum',

  documentation: 'Abstract base class for all Enum classes.',

  axioms: [
    foam.pattern.Multiton.create({property: 'ordinal'}),
    {
      installInClass: function(cls) {
        // Each sub-class of AbstractEnum gets it's own VALUES array.
        Object.defineProperty(cls, 'VALUES', {
          get: function() {
            return this.private_.VALUES || ( this.private_.VALUES = [] );
          },
          configurable: true,
          enumerable: false
        });
      },
      installInProto: function(p) {
        Object.defineProperty(p, 'VALUES', {
          get: function() { return this.cls_.VALUES; },
          configurable: true,
          enumerable: false
        });
      }
    }
  ],

  properties: [
    {
      class: 'String',
      name: 'documentation',
      adapt: function(_, d) {
        return typeof d === 'function' ? foam.String.multiline(d).trim() : d;
      }
    },
    {
      class: 'Int',
      name: 'ordinal',
      // NOTE: Default value of -1 forces legitimate values (starting at 0) to
      // all be non-default. This is important for, e.g., serialization of enum
      // values:
      // https://github.com/foam-framework/foam2/issues/637
      value: -1,
      final: true
    },
    {
      class: 'String',
      name: 'name',
      final: true
    },
    {
      class: 'String',
      name: 'label',
      final: true,
      factory: function() {
        return this.name;
      }
    }
  ],

  methods: [
    function outputFObject(o) {
      o.out(this.ordinal);
    },
    function toString() { return this.name; }
  ]
});


foam.CLASS({
  package: 'foam.core',
  name: 'Enum',
  extends: 'Property',

  documentation: 'A Property type for storing enum values.',

  properties: [
    {
      class: 'Class',
      name: 'of',
      required: true
    },
    {
      name: 'value',
      adapt: function(_, n) {
        if ( foam.String.isInstance(n) ) n = this.of[n];
        return n
      },
      expression: function(of) {
        return of && of.VALUES[0];
      },
    },
    {
      name: 'javaValue',
      expression: function(of, value) {
        return of.id + '.' + value;
      },
    },
    [
      'adapt',
      function(o, n, prop) {
        var of = prop.of;

        if ( n && n.cls_ === of ) return n;

        var type = foam.typeOf(n), ret;

        if ( type === foam.String ) {
          ret = of[foam.String.constantize(n)];
        } else if ( type === foam.Number ) {
          ret = of.create({ordinal: n}, foam.__context__);
        }

        if ( ret ) return ret;

        throw 'Attempt to set invalid Enum value. Enum: ' + of.id + ', value: ' + n;
      }
    ],
    {
      name: 'toJSON',
      value: function(value) { return value.ordinal; }
    }
  ]
});


foam.LIB({
  name: 'foam',

  methods: [
    function ENUM(m) {
      m.class = m.class || 'foam.core.EnumModel';
      return foam.CLASS(m);
    }
  ]
});
/**
 * @license
 * Copyright 2016 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
// JSON Support
//
// TODO:
//   - don't output default classes
*/
foam.CLASS({
  refines: 'foam.core.Property',

  properties: [
    {
      name: 'fromJSON',
      value: function fromJSON(value, ctx, prop, json) {
        return foam.json.parse(value, null, ctx);
      }
    },
    {
      name: 'toJSON',
      value: function toJSON(value, outputter) { return value; }
    }
  ],

  methods: [
    function outputJSON(o) {
      if ( o.passPropertiesByReference ) {
        o.output({ class: '__Property__', forClass_: this.forClass_, name: this.name });
      } else {
        o.outputFObject_(this);
      }
    }
  ]
});

foam.CLASS({
  name: '__Property__',
  package: 'foam.core',
  axioms: [
    {
      name: 'create',
      installInClass: function(c) {
        var oldCreate = c.create;
        c.create = function(args, X) {
          var clsName = args.forClass_;
          var name = args.name;

          var cls = X.lookup(clsName, true);

          // If we failed to find the class, try to deserialize the old format
          // where forClass_ contains the full path to the property: foo.bar.Pereson.lastName
          if ( ! cls ) {
            clsName = args.forClass_.substring(0, args.forClass_.lastIndexOf('.'));
            name = args.forClass_.substring(args.forClass_.lastIndexOf('.') + 1);

            cls = X.lookup(clsName);
          }

          var prop = cls.getAxiomByName(name);

          foam.assert(prop, 'Could not find property "', args.forClass_ + '.' + name, '"');

          return prop;
        };
      }
    }
  ]
});

/** Add toJSON() method to FObject. **/
foam.CLASS({
  refines: 'foam.core.FObject',

  methods: [
    /**
      Output as a pretty-printed JSON-ish String.
      Use for debugging/testing purposes. If you want actual
      JSON output, use foam.json.* instead.
    */
    function stringify() {
      return foam.json.Pretty.stringify(this);
    }
  ]
});


/** JSON Outputter. **/
foam.CLASS({
  package: 'foam.json',
  name: 'Outputter',

  documentation: 'JSON Outputter.',

  properties: [
    {
      class: 'String',
      name: 'buf_',
      value: ''
    },
    {
      class: 'Int',
      name: 'indentLevel_',
      value: 0
    },
    {
      class: 'String',
      name: 'indentStr',
      value: '\t'
    },
    {
      class: 'String',
      name: 'nlStr',
      value: '\n'
    },
    {
      class: 'String',
      name: 'postColonStr',
      value: ' '
    },
    {
      class: 'Boolean',
      name: 'useTemplateLiterals',
      help: 'If true, multiline strings will be outputted using template literals (i.e. surrounded by backticks)',
      value: false,
    },
    {
      class: 'Boolean',
      name: 'alwaysQuoteKeys',
      help: 'If true, keys are always quoted, as required by the JSON standard. If false, only quote keys which aren\'tvalid JS identifiers.',
      value: true
    },
    {
      class: 'Boolean',
      name: 'passPropertiesByReference',
      help: 'If true, Property objects are passed as __Property__ references rather than by value.',
      value: true
    },
    {
      class: 'Boolean',
      name: 'formatDatesAsNumbers',
      value: false
    },
    {
      class: 'Boolean',
      name: 'formatFunctionsAsStrings',
      value: true
    },
    {
      class: 'Boolean',
      name: 'outputDefaultValues',
      value: true
    },
    {
      class: 'Boolean',
      name: 'outputOwnPropertiesOnly',
      documentation: 'If true expressions are not stored.',
      value: true
    },
    {
      class: 'Boolean',
      name: 'outputClassNames',
      value: true
    },
    {
      class: 'Function',
      name: 'propertyPredicate',
      value: function(o, p) { return ! p.transient; }
    },
    {
      class: 'Function',
      name: 'objectKeyValuePredicate',
      documentation: 'Called before outputting a key/value. Outputs if true.',
      value: function(k, v) { return true; }
    },
    {
      class: 'Boolean',
      name: 'useShortNames',
      value: false
    },
    {
      class: 'Boolean',
      name: 'sortObjectKeys',
      value: false
    },
    {
      class: 'Boolean',
      name: 'convertUnserializableToStubs',
      value: false
    },
    {
      class: 'Boolean',
      name: 'pretty',
      value: true,
      postSet: function(_, p) {
        if ( p ) {
          this.clearProperty('indentStr');
          this.clearProperty('nlStr');
          this.clearProperty('postColonStr');
          this.clearProperty('useShortNames');
        } else {
          this.indentStr = this.nlStr = this.postColonStr = null;
        }
      }
    },
    {
      // TODO: rename to FON
      class: 'Boolean',
      name: 'strict',
      value: true,
      postSet: function(_, s) {
        if ( s ) {
          this.useShortNames            = false;
          this.formatDatesAsNumbers     = false;
          this.alwaysQuoteKeys          = true;
          this.formatFunctionsAsStrings = true;
        } else {
          this.alwaysQuoteKeys          = false;
          this.formatFunctionsAsStrings = false;
        }
      }
    }
    /*
    {
      class: 'Boolean',
      name: 'functionFormat',
      value: false
    },
    */
  ],

  methods: [
    function reset() {
      this.indentLevel_ = 0;
      this.buf_ = '';
      return this;
    },

    function escape(str) {
      return str
        .replace(/\\/g, '\\\\')
        .replace(/"/g, '\\"')
        .replace(/[\x00-\x1f]/g, function(c) {
          return "\\u00" + ((c.charCodeAt(0) < 0x10) ?
              '0' + c.charCodeAt(0).toString(16) :
              c.charCodeAt(0).toString(16));
        });
    },

    function maybeEscapeKey(str) {
      return this.alwaysQuoteKeys || ! /^[a-zA-Z\$_][0-9a-zA-Z$_]*$/.test(str) ?
          '"' + str + '"' :
          str ;
    },

    function out() {
      for ( var i = 0 ; i < arguments.length ; i++ ) this.buf_ += arguments[i];
      return this;
    },

    /**
      Start a block, using the supplied start character, which would typically
      be '{' for objects or '[' for arrays.  Handles indentation if enabled.
    */
    function start(c) {
      if ( c ) this.out(c).nl();
      if ( this.indentStr ) {
        this.indentLevel_++;
        this.indent();
      }
      return this;
    },

    /**
      End a block, using the supplied end character, which would typically
      be '}' for objects or ']' for arrays.
    */
    function end(c) {
      if ( this.indent ) {
        this.indentLevel_--;
      }
      if ( c ) this.nl().indent().out(c);
      return this;
    },

    function nl() {
      if ( this.nlStr && this.nlStr.length ) {
        this.out(this.nlStr);
      }
      return this;
    },

    function indent() {
      for ( var i = 0 ; i < this.indentLevel_ ; i++ ) this.out(this.indentStr);
      return this;
    },

    function outputPropertyName(p) {
      this.out(this.maybeEscapeKey(this.useShortNames && p.shortName ? p.shortName : p.name));
      return this;
    },

    function outputProperty(o, p, includeComma) {
      if ( ! this.propertyPredicate(o, p ) ) return false;
      if ( ! this.outputDefaultValues && p.isDefaultValue(o[p.name]) )
        return false;

      // Access property before checking o.hasOwnProperty.
      var v = o[p.name];
      if ( this.outputOwnPropertiesOnly && ! o.hasOwnProperty(p.name) )
        return false;

      if ( foam.Array.isInstance(v) && v.length == 0 )
        return false;

      if ( includeComma ) this.out(',');

      this.nl().indent().outputPropertyName(p).out(':', this.postColonStr);
      this.output(p.toJSON(v, this), p.of);
      return true;
    },

    function outputString(str) {
      if ( this.useTemplateLiterals && str.indexOf('\n') != -1 ) {
        this.out('`', str.replace(/`/, '\\`'), '`');
      } else {
        this.out('"', this.escape(str), '"');
      }
    },

    function outputDate(o) {
      if ( this.formatDatesAsNumbers ) {
        this.out(o.valueOf());
      } else {
        this.out(JSON.stringify(o));
      }
    },

    function outputFunction(o) {
      if ( this.formatFunctionsAsStrings ) {
        this.output(o.toString());
      } else {
        this.out(o.toString());
      }
    },

    function outputFObject(o, opt_cls) {
      if ( o.outputJSON ) {
        o.outputJSON(this);
      } else {
        this.outputFObject_(o, opt_cls);
      }
    },

    function outputFObject_(o, opt_cls) {
      /** Output an FObject without checking if it implements outputJSON. **/
      this.start('{');
      var cls = this.getCls(opt_cls);
      var outputClassName = this.outputClassNames && o.cls_ !== cls;
      if ( outputClassName ) {
        this.out(
          this.maybeEscapeKey('class'),
          ':',
          this.postColonStr,
          '"',
          o.cls_.id,
          '"');
      }
      var ps = o.cls_.getAxiomsByClass(foam.core.Property);
      var outputComma = outputClassName;
      for ( var i = 0 ; i < ps.length ; i++ ) {
        outputComma = this.outputProperty(o, ps[i], outputComma) ||
          outputComma;
      }
      this.end('}');
    },

    function outputObjectKeyValue_(key, value, first) {
      if ( this.objectKeyValuePredicate(key, value) ) {
        if ( ! first ) this.out(',').nl().indent();
        this.out(
          this.maybeEscapeKey(key),
          ':',
          this.postColonStr).output(value);
        return true;
      }
      return false;
    },

    function outputObjectKeyValues_(o) {
      var first = true;
      for ( var key in o ) {
        first = !this.outputObjectKeyValue_(key, o[key], first) && first;
      }
    },

    function outputSortedObjectKeyValues_(o) {
      var key, keys = [];

      for ( key in o ) keys.push(key);
      keys.sort();

      var first = true;
      for ( var i = 0 ; i < keys.length; i++ ) {
        key = keys[i];
        first = !this.outputObjectKeyValue_(key, o[key], first) && first;
      }
    },

    {
      name: 'output',
      code: foam.mmethod({
        // JSON doesn't support sending 'undefined'
        Undefined: function(o) { this.out('null'); },
        Null:      function(o) { this.out('null'); },
        String:    function(o) { this.outputString(o); },
        Number:    function(o) { this.out(o); },
        Boolean:   function(o) { this.out(o); },
        Date:      function(o) { this.outputDate(o); },
        Function:  function(o) { this.outputFunction(o); },
        FObject: function(o, opt_cls) { this.outputFObject(o, opt_cls); },
        Array: function(o, opt_cls) {
          this.start('[');
          var cls = this.getCls(opt_cls);
          for ( var i = 0 ; i < o.length ; i++ ) {
            this.output(o[i], cls);
            if ( i < o.length-1 ) this.out(',').nl().indent();
          }
          //this.nl();
          this.end(']');
        },
        Object: function(o) {
          if ( o.outputJSON ) {
            o.outputJSON(this);
          } else {
            this.start('{');
            if ( this.sortObjectKeys ) {
              this.outputSortedObjectKeyValues_(o);
            } else {
              this.outputObjectKeyValues_(o);
            }
            this.end('}');
          }
        }
      })
    },

    function stringify(o, opt_cls) {
      // Focibly set this.buf_ to empty string.
      // It can be non-empty if a previous serialized threw an exception and didn't complete.
      this.buf_ = "";

      this.output(o, opt_cls);
      var ret = this.buf_;
      this.reset(); // reset to avoid retaining garbage
      return ret;
    },

    {
      name: 'objectify',
      code: foam.mmethod({
        Date: function(o) {
          return this.formatDatesAsNumbers ? o.valueOf() : o;
        },
        Function: function(o) {
          return this.formatFunctionsAsStrings ? o.toString() : o;
        },
        FObject: function(o, opt_cls) {
          var m = {};
          var cls = this.getCls(opt_cls);
          if ( this.outputClassNames && o.cls_ !== cls ) {
            m.class = o.cls_.id;
          }
          var ps = o.cls_.getAxiomsByClass(foam.core.Property);
          for ( var i = 0 ; i < ps.length ; i++ ) {
            var p = ps[i];
            if ( ! this.propertyPredicate(o, p) ) continue;
            if ( ! this.outputDefaultValues && p.isDefaultValue(o[p.name]) )
              continue;

            m[p.name] = this.objectify(p.toJSON(o[p.name], this), p.of);
          }
          return m;
        },
        Array: function(o, opt_cls) {
          var a = [];
          var cls = this.getCls(opt_cls);
          for ( var i = 0 ; i < o.length ; i++ ) {
            a[i] = this.objectify(o[i], cls);
          }
          return a;
        },
        Object: function(o) {
          var ret = {};
          for ( var key in o ) {
            // NOTE: Could lazily construct "ret" first time
            // this.objectify(o[key]) !== o[key].
            if ( o.hasOwnProperty(key) ) ret[key] = this.objectify(o[key]);
          }
          return ret;
        }
      },
      function(o) { return o; })
    },

    function getCls(opt_cls) {
      return foam.typeOf(opt_cls) === foam.String ? this.lookup(opt_cls, true) :
          opt_cls;
    }
  ]
});


foam.CLASS({
  package: 'foam.json',
  name: 'Parser',

  properties: [
    {
      class: 'Boolean',
      name: 'strict',
      value: true
    },
    {
      name: 'creationContext'
    },
    {
      name: 'fonParser_',
      expression: function(creationContext) {
        return foam.parsers.FON.create({
          creationContext: creationContext
        });
      }
    }
  ],

  methods: [
    function parseString(str, opt_ctx) {
      return this.parseClassFromString(str, null, opt_ctx);
    },
    function aparse(str, opt_ctx) {
      var x = this.__context__;

      var json = JSON.parse(str);

      var references = foam.json.references(x, json);;

      return Promise.all(references).then(function() {
        return foam.json.parse(json, undefined, opt_ctx || this.creationContext);
      }.bind(this));
    },
    function parseClassFromString(str, opt_cls, opt_ctx) {
      return this.strict ?
          // JSON.parse() is faster; use it when data format allows.
          foam.json.parse(JSON.parse(str), opt_cls,
                          opt_ctx || this.creationContext) :
          // Create new parser iff different context was injected; otherwise
          // use same parser bound to "creationContext" each time.
          opt_ctx ? foam.parsers.FON.create({
            creationContext: opt_ctx || this.creationContext
          }).parseClassFromString(str, opt_cls) :
          this.fonParser_.parseClassFromString(str, opt_cls);
    }
  ]
});


/** Library of pre-configured JSON Outputters. **/
foam.LIB({
  name: 'foam.json',

  constants: {

    // Pretty Print
    Pretty: foam.json.Outputter.create({
      strict: false
    }),

    // Strict means output as proper JSON.
    Strict: foam.json.Outputter.create({
      pretty: false,
      strict: true
    }),

    // Pretty and proper JSON.
    PrettyStrict: foam.json.Outputter.create({
      pretty: true,
      strict: true
    }),

    // Compact output (not pretty)
    Compact: foam.json.Outputter.create({
      pretty: false,
      formatDatesAsNumbers: true,
      outputDefaultValues: false,
      strict: false
    }),

    // Shorter than Compact (uses short-names if available)
    Short: foam.json.Outputter.create({
      pretty: false,
      formatDatesAsNumbers: true,
      outputDefaultValues: false,
      // TODO: No deserialization support for shortnames yet.
      //      useShortNames: true,
      useShortNames: false,
      strict: false
    }),

    // Short, but exclude network-transient properties.
    Network: foam.json.Outputter.create({
      pretty: false,
      formatDatesAsNumbers: true,
      outputDefaultValues: false,
      // TODO: No deserialization support for shortnames yet.
      //      useShortNames: true,
      useShortNames: false,
      // TODO: Currently faster to use strict JSON and native JSON.parse
      strict: true,
      convertUnserializableToStubs: true,
      propertyPredicate: function(o, p) { return ! p.networkTransient; }
    }),

    // Short, but exclude storage-transient properties.
    Storage: foam.json.Outputter.create({
      pretty: false,
      formatDatesAsNumbers: true,
      outputDefaultValues: false,
      // TODO: No deserialization support for shortnames yet.
      //      useShortNames: true,
      useShortNames: false,
      strict: false,
      propertyPredicate: function(o, p) { return ! p.storageTransient; }
    })
  },

  methods: [
    {
      // TODO: why is this called parse when it's really objectify?
      name: 'parse',
      code: foam.mmethod({
        Array: function(o, opt_class, opt_ctx) {
          var a = new Array(o.length);
          for ( var i = 0 ; i < o.length ; i++ ) {
            a[i] = this.parse(o[i], opt_class, opt_ctx);
          }

          return a;
        },
        FObject: function(o) { return o; },
        Object: function(json, opt_class, opt_ctx) {
          var cls = json.class || opt_class;

          if ( cls ) {
            var c = typeof cls === 'string' ? ( opt_ctx || foam ).lookup(cls) : cls;
            // TODO(markdittmer): Turn into static method: "parseJSON" once
            // https://github.com/foam-framework/foam2/issues/613 is fixed.
            if ( c.PARSE_JSON ) return c.PARSE_JSON(json, opt_class, opt_ctx);

            for ( var key in json ) {
              var prop = c.getAxiomByName(key);
              if ( prop ) {
                json[key] = prop.fromJSON(json[key], opt_ctx, prop, this);
              }
            }

            return c.create(json, opt_ctx);
          }

          for ( var key in json ) {
            var o = json[key];
            json[key] = this.parse(json[key], null, opt_ctx);
          }

          return json;
        }
      }, function(o) { return o; })
    },

    {
      name: 'references',
      code: function(x, o, r) {
        r = r || [];

        if ( foam.Array.isInstance(o) ) {
          for ( var i = 0 ; i < o.length ; i++ ) {
            foam.json.references(x, o[i], r);
          }
          // TODO: Should just be foam.core.FObject.isSubClass(o), but its broken #1023
        } else if ( ( o && o.prototype && foam.core.FObject.prototype.isPrototypeOf(o.prototype) ) ||
                    foam.core.FObject.isInstance(o) ) {
          return r;
        } else if ( foam.Object.isInstance(o) ) {
          for ( var key in o ) {
            // anonymous class support.
            if ( key === 'class' && foam.Object.isInstance(o[key]) ) {
              var json = o[key];
              json.name = 'AnonymousClass' + foam.next$UID();
              console.log('Constructing anonymous class', json.name);

              r.push(Promise.all(foam.json.references(x, json, [])).then(function() {
                return x.classloader.maybeLoad(foam.core.Model.create(json));
              }));

              o[key] = json.name;
              continue;
            } else if ( ( key === 'of' || key === 'class' || key == 'view' ) &&
                        foam.String.isInstance(o[key]) ) {
              r.push(x.classloader.maybeLoad(o[key]));
              continue;
            }

            foam.json.references(x, o[key], r);
          }

          return r;
        }
      }
    },

    // TODO: unsafe and only used by LocalStorageDAO, so remove.
    function parseString(jsonStr, opt_ctx) {
      return this.parse(eval('(' + jsonStr + ')'), undefined, opt_ctx);
    },

    function stringify(o) {
      return foam.json.Compact.stringify(o);
    },

    function objectify(o) {
      return foam.json.Compact.objectify(o);
    }
  ]
});
/**
@license
Copyright 2017 The FOAM Authors. All Rights Reserved.
http://www.apache.org/licenses/LICENSE-2.0
*/

foam.CLASS({
  refines: 'foam.core.Property',

  properties: [
    {
      class: 'Boolean',
      name: 'xmlAttribute',
      value: false
    },
    {
      class: 'Boolean',
      name: 'xmlTextNode',
      value: false
    },
    {
      name: 'fromXML',
      value: function fromXML(value, ctx, prop, xml) {
        return foam.xml.parse(value, null, ctx);
      }
    },
    {
      name: 'toXML',
      value: function toXML(value, Outputter) { return value; }
    }
  ],

  methods: [
    function outputXML(o) {
      o.output({ class: '__Property__', forClass_: this.forClass_, name: this.name });
    }
  ]
});

/** Add toXML() method to FObject. **/
foam.CLASS({
  refines: 'foam.core.FObject',

  methods: [
    /**
      Output as a pretty-printed XML-ish String.
      Use for debugging/testing purposes. If you want actual
      XML output, use foam.xml.* instead.
    */
    function stringify() {
      return foam.xml.Pretty.stringify(this);
    }
  ]
});


/** XML Outputter **/
foam.CLASS({
  package: 'foam.xml',
  name: "Outputter",

  documentation: 'XML Outputter.',

  properties: [
    {
      class: 'String',
      name: 'buf_',
      value: ''
    },
    {
      class: 'Int',
      name: 'indentLevel_',
      value: 0
    },
    {
      class: 'String',
      name: 'indentStr',
      value: '\t'
    },
    {
      class: 'String',
      name: 'nlStr',
      value: '\n'
    },
    {
      class: 'Boolean',
      name: 'outputDefaultValues',
      value: true
    },
    {
      class: 'Boolean',
      name: 'outputDefinedValues',
      value: true
    },
    {
      class: 'Boolean',
      name: 'formatDatesAsNumbers',
      value: false
    },
    {
      class: 'Boolean',
      name: 'outputClassNames',
      value: true
    },
    {
      class: 'Function',
      name: 'propertyPredicate',
      value: function(o, p) { return ! p.transient; }
    },
    {
      class: 'Boolean',
      name: 'useShortNames',
      value: false
    },
        {
      class: 'Boolean',
      name: 'sortObjectKeys',
      value: false
    },
    {
      class: 'Boolean',
      name: 'pretty',
      value: true,
      postSet: function(_, p) {
        if ( p ) {
          this.clearProperty('indentStr');
          this.clearProperty('nlStr');
          this.clearProperty('useShortNames');
        } else {
          this.indentStr = this.nlStr = null;
        }
      }
    }
  ],

  methods: [

    function reset() {
      this.indentLevel_ = 0;
      this.buf_ = '';
      return this;
    },

    function escape(str) {
        return str && str.toString()
            .replace(/&/g, '&amp;')
            .replace(/</g, '&lt;')
            .replace(/>/g, '&gt;');
    },

    function maybeEscapeKey(str) {
      return this.alwaysQuoteKeys || ! /^[a-zA-Z\$_][0-9a-zA-Z$_]*$/.test(str) ?
          '"' + str + '"' :
          str ;
    },

    function escapeAttr(str) {
        return str && str.replace(/"/g, '&quot;');
    },

    function out() {
      for ( var i = 0 ; i < arguments.length ; i++ ) this.buf_ += arguments[i];
      return this;
    },

    function start(c) {
      if ( c ) this.out(c);
      if ( this.indentStr ) {
        this.indentLevel_++;
        this.indent();
      }
    },

    function end(c) {
      if ( this.indent ) {
        this.indentLevel_--;
      }
      if ( c ) this.nl().indent().out(c);
      return this;
    },

    function nl() {
      if ( this.nlStr && this.nlStr.length ) {
        this.out(this.nlStr);
      }
      return this;
    },

    function indent() {
      for ( var i = 0 ; i < this.indentLevel_ ; i++ ) this.out(this.indentStr);
      return this;
    },

    function outputPropertyName(p) {
      this.out(this.maybeEscapeKey(this.useShortNames && p.shortName ? p.shortName : p.name));
      return this;
    },

    function outputAttributes(v) {
      var attributes = v.cls_.getAxiomsByClass(foam.core.Property).filter(function (p) { return p.xmlAttribute });
      if ( attributes.length === 0 ) return this;

      for ( var i = 0 ; i < attributes.length ; i++ ) {
        this.out(' ' + attributes[i].name + '="' + this.escapeAttr(attributes[i].get(v)) + '"');
      }
      return this;
    },

    function propertyName(p) {
      return this.maybeEscapeKey(this.useShortNames && p.shortName ? p.shortName : p.name)
    },

    function outputProperty_(o, p) {
      if ( ! this.propertyPredicate(o, p ) ) return;
      // don't output default values unless value is defined and outputDefinedValues set to true
      if ( this.outputDefinedValues ) {
        if ( ! o.hasOwnProperty(p.name) ) return;
      } else if ( this.outputDefaultValues ) {
        if ( p.isDefaultValue(o[p.name]) ) return;
      }

      var v = o[p.name];
      if ( ! v || ( v instanceof Array && v.length === 0 ) ) {
        return;
      }

      this.nl().indent();
      this.outputProperty(v, p);
    },

    {
      name: 'outputProperty',
      code: foam.mmethod({
        Undefined:    function(v, p) {},
        String:       function(v, p) { this.outputPrimitive(v, p); },
        Number:       function(v, p) { this.outputPrimitive(v, p); },
        Boolean:      function(v, p) { this.outputPrimitive(v, p); },
        Date:         function(v, p) { this.outputPrimitive(v, p); },
        AbstractEnum: function(v, p) { this.outputPrimitive(v.name, p); },
        Array:     function(v, p) {
          for ( var i = 0 ; i < v.length ; i++ ) {
            if ( foam.core.FObjectArray.isInstance(p) ) {
              // output FObject array
              this.start('<' + this.propertyName(p) + '>');
              this.output(p.toXML(v[i], this));
              this.end('</' + this.propertyName(p) + '>');
            } else {
              // output primitive array
              this.outputPrimitive(v[i], p);
            }

            // new line and indent except on last element
            if ( i != v.length - 1 ) this.nl().indent();
          }
        },
        FObject: function(v, p) {
          if ( v.xmlValue ) {
            // if v.xmlValue exists then we have attributes
            // check if the value is an FObject and structure XML accordingly
            if ( foam.core.FObject.isInstance(v.xmlValue) ) {
              this.start('<' + this.propertyName(p) + this.outputAttributes(v) + '>');
              this.output(p.toXML(v, this));
              this.end('</' +  this.propertyName(p) + '>');
            } else {
              this.out('<').outputPropertyName(p).outputAttributes(v).out('>');
              this.out(p.toXML(v.xmlValue, this));
              this.out('</').outputPropertyName(p).out('>');
            }
          } else {
            // assume no attributes
            this.start('<' + this.propertyName(p) + '>');
            this.output(p.toXML(v, this));
            this.end('</' +  this.propertyName(p) + '>');
          }
        }
      })
    },

    function outputPrimitive(v, p){
      this.out('<').outputPropertyName(p).out('>');
      this.output(p.toXML(v, this));
      this.out('</').outputPropertyName(p).out('>');
    },

    function outputDate(o) {
      if ( this.formatDatesAsNumbers ) {
        this.out(o.valueOf());
      } else {
        this.out(o.toISOString());
      }
    },

    function outputFunction(o) {
      if ( this.formatFunctionsAsStrings ) {
        this.output(o.toString());
      } else {
        this.out(o.toString());
      }
    },

    function outputObjectKeyValue_(key, value, first) {
      if ( ! first ) this.out(',').nl().indent();
      this.out(this.maybeEscapeKey(key), ':').output(value);
    },

    function outputObjectKeyValues_(o) {
      var first = true;
      for ( var key in o ) {
        this.outputObjectKeyValue_(key, o[key], first);
        first = false;
      }
    },

    function outputSortedObjectKeyValues_(o) {
      var key, keys = [];

      for ( key in o ) keys.push(key);
      keys.sort();

      var first = true;
      for ( var i = 0 ; i < keys.length; i++ ) {
        key = keys[i];
        this.outputObjectKeyValue_(key, o[key], first);
        first = false;
      }
    },

    {
      name: 'output',
      code: foam.mmethod({
        Undefined:    function(o) { this.out('null'); },
        Null:         function(o) { this.out('null'); },
        String:       function(o) { this.out(this.escape(o)); },
        Number:       function(o) { this.out(o); },
        Boolean:      function(o) { this.out(o); },
        Date:         function(o) { this.outputDate(o); },
        Function:     function(o) { this.outputFunction(o); },
        AbstractEnum: function(o) { },
        FObject:      function(o) {
          if ( o.outputXML ) {
            o.outputXML(this)
            return;
          }

          var clsName = o.cls_.id;
          // Iterate through properties and output
          var ps = o.cls_.getAxiomsByClass(foam.core.Property);
          for ( var i = 0 ; i < ps.length ; i++ ) {
            // skip outputting of attributes
            if ( ps[i].xmlAttribute ) continue;
            this.outputProperty_(o, ps[i]);
          }
        },
        Array: function(o, opt_cls) {
          this.start('<objects>\n');
          var cls = this.getCls(opt_cls);
          for ( var i = 0 ; i < o.length ; i++ ) {
            this.output(o[i], cls);
            if ( i < o.length-1 ) this.out('\n').nl().indent();
          }
          this.end('\n</objects>');
        },
        Object:        function(o) {
          if ( o.outputXML ) {
            o.outputXML(this);
          } else {
            var oName = o.name;
            this.start("<object name='" + oName + "'>");
            if ( this.sortObjectKeys ) {
              this.outputSortedObjectKeyValues_(o);
            } else {
              this.outputObjectKeyValues_(o);
            }
            this.end('</object>');
          }
        }
      })
    },

    function stringify(o) {
      // Root tags of objects for array of FObjects
      this.output(o);
      var ret = this.buf_;
      this.reset(); // reset to avoid retaining garbage
      return ret;
    },

    function objectify(doc, cls) {
      var obj = cls.create();
      var children = doc.children;

      for ( var i = 0 ; i < children.length ; i++ ) {
        // fetch property based on xml tag name since they may not be in order
        var node = children[i];
        var prop = obj.cls_.getAxiomByName(node.tagName);

        if ( foam.core.FObjectProperty.isInstance(prop) ) {
          // parse FObjectProperty
          prop.set(obj, this.objectify(node, prop.of));
        } else if ( foam.core.FObjectArray.isInstance(prop) ) {
          // parse array property
          prop.get(obj).push(this.objectify(node, foam.lookup(prop.of)));

        } else if ( foam.core.StringArray.isInstance(prop) ) {
          // parse string array
          prop.get(obj).push(node.firstChild ? node.firstChild.nodeValue : null);
        } else {
          // parse property
          prop.set(obj, node.firstChild ? node.firstChild.nodeValue : null);
        }
      }

      // check to see if xmlValue property exists
      var xmlValueProp = obj.cls_.getAxiomByName('xmlValue');
      if ( xmlValueProp ) {
        // parse attributes if they exist
        var attributes = doc.attributes;
        for ( var i = 0 ; i < attributes.length ; i++ ) {
          var attribute = attributes[i];
          var prop = obj.cls_.getAxiomByName(attribute.name);
          // don't need to check for types as attributes are always simple types
          prop.set(obj, attribute.value);
        }

        if ( foam.core.FObjectProperty.isInstance(xmlValueProp) ) {
          xmlValueProp.set(obj, this.objectify(doc, xmlValueProp.of));
        } else {
          xmlValueProp.set(obj, doc.firstChild ? doc.firstChild.nodeValue : null);
        }
      }

      return obj;
    },

    function parseString(str, opt_class) {
      // create DOM
      var parser = new DOMParser();
      var doc = parser.parseFromString(str, 'text/xml');
      var root = doc.firstChild;

      var rootClass = root.getAttribute('class');
      if ( rootClass )
        return this.objectify(root, foam.lookup(rootClass));

      if ( opt_class ) {
        // lookup class if given a string
        if ( typeof(opt_class) === 'string' )
          opt_class = foam.lookup(opt_class);
        return this.objectify(root, opt_class);
      }

      throw new Error('Class not provided');
    },

    function getCls(opt_cls) {
      return foam.String.isInstance(opt_cls);
    }
  ]
});


/** Library of pre-configured XML Outputters. **/
foam.LIB({
  name: 'foam.xml',

  constants: {
    // Pretty Print
    Pretty: foam.xml.Outputter.create({
      outputDefaultValues: false,
      outputDefinedValues: true
    }),

    // Compact output (not pretty)
    Compact: foam.xml.Outputter.create({
      pretty: false,
      formatDatesAsNumbers: true,
      outputDefaultValues: false,
      outputDefinedValues: false
    }),

    // Shorter than Compact (uses short-names if available)
    Short: foam.xml.Outputter.create({
      pretty: false,
      formatDatesAsNumbers: true,
      outputDefaultValues: false,
      outputDefinedValues: false,
      // TODO: No deserialization support for shortnames yet.
      //      useShortNames: true,
      useShortNames: false,
    })
  },

  methods: [
    function stringify(o) {
      return foam.xml.Compact.stringify(o);
    },

    function objectify(o) {
      return foam.xml.Compact.objectify(o);
    }
  ]
});
/**
 * @license
 * Copyright 2017 The FOAM Authors. All Rights Reserved.
 * http://www.apache.org/licenses/LICENSE-2.0
 */

foam.CLASS({
  package: 'foam.lib.csv',
  name: 'Outputter',

  documentation: 'CSV Outputter.',

  properties: [
    {
      class: 'String',
      name: 'buf_',
      value: ''
    },
    {
      class: 'String',
      name: 'delimiter',
      value: ','
    },
    {
      class: 'String',
      name: 'nestedObjectSeperator',
      value: '__'
    },
    {
      class: 'String',
      name: 'nlStr',
      value: '\n'
    },
    {
      class: 'String',
      name: 'undefinedStr',
      value: ''
    },
    {
      class: 'Boolean',
      name: 'outputHeaderRow',
      value: true
    },
    {
      class: 'Function',
      name: 'propertyPredicate',
      value: function(o, p) { return ! p.transient; }
    }
  ],

  methods: [
    function out() {
      for ( var i = 0 ; i < arguments.length ; i++ ) this.buf_ += arguments[i];
      return this;
    },

    function toCSV(o) {
      // Resets buffer
      this.reset();

      // Outputs object headers
      this.outputHeader(o);

      // Outputs object values
      this.output(o, true);
      this.out(this.nlStr);

      return this.buf_;
    },

    function outputHeader(o) {
      if ( ! this.outputHeaderRow ) return;

      this.outputPropertyName(o, '', true);
      this.out(this.nlStr);
    },

    function outputHeaderTitle(o, prefix, first) {
      this.out(first ? '' : this.delimiter)
          .out(this.escapeString(prefix + this.sanitizeHeaderTitle(o)));
    },

    function outputPropertyName_(o, p, prefix, first) {
      if ( ! this.propertyPredicate(o, p) ) return;

      if ( foam.core.FObjectProperty.isInstance(p) ) {
        // Gets new empty object if FObjectProperty is currently undefined
        // Done to permit appropriate headers for multi-line CSVs (multiple objects to convert)
        if ( o[p.name] == undefined ) o[p.name] = p.of.id;

        // Appends object name to prefix for CSV Header
        prefix += this.sanitizeHeaderTitle(p.name) + this.nestedObjectSeperator;
        this.outputPropertyName(o[p.name], prefix, first);
      } else {
        this.outputPropertyName(p.name, prefix, first);
      }
    },

    function sanitizeHeaderTitle(t) {
      // Sanitizes header title by replacing the nested object seperator, by itself x 2
      return this.replaceAll(t, this.nestedObjectSeperator, 
                    this.nestedObjectSeperator + this.nestedObjectSeperator);
    },

    {
      name: 'outputPropertyName',
      code: foam.mmethod({
        FObject:   function(o, prefix, first) {
          // Get and recurse through object properties
          var ps = o.cls_.getAxiomsByClass(foam.core.Property);

          for ( var i = 0 ; i < ps.length ; i++ ) {
            this.outputPropertyName_(o, ps[i], prefix, (i == 0 && first));
          }
        },
        Array: function(o, prefix, first) {
          if ( ! o || o.length === 0 ) return;

          // Get and recurse through object properties
          var ps = o[0].cls_.getAxiomsByClass(foam.core.Property);

          for ( var i = 0 ; i < ps.length ; i++ ) {
            this.outputPropertyName_(o, ps[i], prefix, (i == 0 && first));
          }
        },
        Function: function(o) { /* Ignore functions in CSV */ },
        Object: function(o) { /* Ignore generic objects in CSV */ }
      }, function(o, prefix, first) { this.outputHeaderTitle(o, prefix, first); })
    },

    function outputProperty(o, p, first) {
      if ( this.propertyPredicate(o, p) ) this.output(o[p.name], first);
    },

    function reset() {
      this.buf_ = '';
      return this;
    },

    function outputPrimitive(val, first) {
      this.out(first ? '' : this.delimiter, val);
      return this;
    },

    function escapeString(source) {
      if ( source.includes(',') ) {
        // Surrounds fields with ',' in quotes
        // Escapes inner quotes by adding another quote char (Google Sheets strategy)
        source = '"' + this.replaceAll(source, '"', '""') + '"';
      }
      
      return source;
    },

    {
      name: 'output',
      code: foam.mmethod({
        Undefined:    function(o, first) { this.outputPrimitive(this.undefinedStr, first); },
        String:       function(o, first) { this.outputPrimitive(this.escapeString(o), first); },
        AbstractEnum: function(o, first) { this.outputPrimitive(o.ordinal, first); },
        FObject:   function(o, first) {
          if ( o.outputCSV ) {
            o.outputCSV(this)
            return;
          }
          
          var ps = o.cls_.getAxiomsByClass(foam.core.Property);

          for ( var i = 0 ; i < ps.length ; i++ ) {
            this.outputProperty(o, ps[i], (i == 0 && first));
          }
        },
        Array:  function(o, opt_cls) { 
          var cls = this.getCls(opt_cls);
          for ( var i = 0 ; i < o.length ; i++ ) {
            this.output(o[i], cls);
            if ( i < o.length-1 ) this.out('\n');
          }
        },
        Function:     function(o) { /* Ignore functions in CSV */ },
        Object:       function(o) { /* Ignore generic objects in CSV */ }
      }, function(o, first) { this.outputPrimitive(o, first); })
    },

    function fromCSV(cls, s, sink) {
      if ( ! s ) throw 'Invalid CSV input to convert. Arguments must be (class, csvString).'
      var lines = s.split('\n');

      if ( lines.length == 0 ) throw 'Insufficient CSV Input';

      // Trims quotes and splits CSV row into array
      var props = this.splitIntoValues(lines[0]).map(this.splitHeaderTitle.bind(this));

      for ( var i = 1 ; i < lines.length ; i++ ) {
        var values = this.splitIntoValues(lines[i]);

        // Skips blank lines
        if ( values.length == 0 ) continue;

        // Calls for creation of new model, and `puts` into sink
        sink.put(this.createModel(props, values, cls));
      }

      return sink;
    },

    function validString(s) {
      return ( s != undefined ) && ( s.length > 0);
    },

    function splitIntoValues(csvString) {
      if ( ! this.validString(csvString) ) return [];

      var parser = foam.lib.csv.CSVParser.create();
      return parser.parseString(csvString, this.delimiter).map(field => field.value == undefined ? '' : field.value);
    },

    function splitHeaderTitle(p) {
      if ( ! this.validString(p) ) return [];

      var parser = foam.lib.csv.CSVParser.create();
      return parser.parseHeader(p, this.nestedObjectSeperator).map(field => field.value == undefined ? '' : field.value);
    },

    // Perhaps move this to foam.core.string
    function replaceAll(text, search, replacement) {
      return text.replace(new RegExp(search, 'g'), replacement);
    },

    function createModel(props, values, cls) {
      foam.assert(props.length == values.length,
        'Invalid CSV Input, header and value rows must be the same number of cells');

      var model = cls.create();

      for ( var i = 0 ; i < props.length ; i++ ) {
        var p = props[i];
        var v = values[i];

        // Adds nested prop
        if ( p.length > 1 ) {
          var prefix = p[0];

          for ( var j = i ; j <= props.length ; ++j ) {
            // If last element, or prefix no longer matches prop
            if ( ( j == props.length ) || ( props[j][0] != prefix ) ) {
              // Creates a new model for the inner object
              var prop = model.cls_.getAxiomByName(p[0]);
              prop.set(model, this.createModel(props.slice(i, j).map(nestedProp => nestedProp.slice(1)), 
                                          values.slice(i, j), prop.of));
              
              i = j - 1;
              break;
            }
          }
        // Adds regular prop
        } else {
          var prop = model.cls_.getAxiomByName(p[0]);
          prop.set(model, prop.of ? prop.of.create({ ordinal: v }) : v);
        }
      }

      return model;
    },

    function getCls(opt_cls) {
      return foam.String.isInstance(opt_cls);
    }
  ]
});

foam.LIB({
  name: 'foam.lib.csv',

  constants: {
    Standard: foam.lib.csv.Outputter.create(),
  },

  methods: [
    function toCSV(o) {
      return foam.lib.csv.Standard.toCSV(o);
    },

    function fromCSV(cls, csvString, sink) {
      return foam.lib.csv.Standard.fromCSV(cls, csvString, sink);
    }
  ]
});

/**
 * @license
 * Copyright 2017 The FOAM Authors. All Rights Reserved.
 * http://www.apache.org/licenses/LICENSE-2.0
 */

foam.CLASS({
  package: 'foam.lib.csv',
  name: 'CSVParser',
  
  requires: [
    'foam.parse.ImperativeGrammar'
  ],

  properties: [
    {
      class: 'String',
      name: 'delimiter'
    },
    {
      class: 'String',
      name: 'nestedObjectSeperator'
    },
    {
      name: 'stringParser',
      factory: function() {
        var X = this.X;
        var self = this;
        
        return this.ImperativeGrammar.create({ 
          symbols: function(alt, anyChar, literal, literalIC, not, notChars, optional,
          plus, range, repeat, repeat0, seq, seq1, str, sym) {
            return {

              START: seq1(1, sym('ws'), repeat(sym('field'), literal(self.delimiter)), sym('ws')),

              field: alt(sym('quotedText'), sym('unquotedText'), ''),

              unquotedText: repeat(not(literal(self.delimiter), anyChar()), '', 1),

              quotedText: seq1(1, '"', repeat(alt(sym('escapedQuote'), not('"', anyChar()))), '"'),

              escapedQuote: '""',

              white: alt(' ', '\t', '\r', '\n'),

              // 0 or more whitespace characters.
              ws: repeat0(sym('white'))
            }
          }
        }).addActions({
          unquotedText: function(a) {
            return { node: 'unquotedText', value: a.join('') };
          },

          quotedText: function(a) {
            return { node: 'quotedText', value: a.join('') };
          },

          escapedQuote: function() { return '"'; }
        });
      }
    },
    {
      name: 'headerParser',
      factory: function() {
        var X = this.X;
        var self = this;
        
        return this.ImperativeGrammar.create({ 
          symbols: function(alt, anyChar, literal, literalIC, not, notChars, optional,
          plus, range, repeat, repeat0, seq, seq1, str, sym) {
            return {

              START: seq1(1, sym('ws'), repeat(sym('field'), literal(self.nestedObjectSeperator)), sym('ws')),

              field: alt(sym('text'), ''),

              text: repeat(alt(sym('escapedSeperator'), not(self.nestedObjectSeperator, anyChar())), '', 1),

              escapedSeperator: literal(self.nestedObjectSeperator + self.nestedObjectSeperator),

              white: alt(' ', '\t', '\r', '\n'),

              // 0 or more whitespace characters.
              ws: repeat0(sym('white'))
            }
          }
        }).addActions({
          text: function(a) {
            return { node: 'text', value: self.recoverHeaderTitle(a.join('')) };
          },

          escapedQuote: function() { return '"'; }
        });
      }
    }
  ],

  methods: [
    function parseString(str, delimiter) {
      this.delimiter = delimiter;
      return this.stringParser.parseString(str);
    },
    
    function parseHeader(str, nestedObjectSeperator) {
      this.nestedObjectSeperator = nestedObjectSeperator;
      return this.headerParser.parseString(str);
    },

    function recoverHeaderTitle(t) {
      // Recovers header title by replacing the nested object seperator x 2, by itself
      return t.replace(new RegExp(this.nestedObjectSeperator + this.nestedObjectSeperator, 'g'), 
                this.nestedObjectSeperator);
    }
  ]
});
/**
 * @license
 * Copyright 2016 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
  Parse combinator library.

  Create complex parsers by composing simple parsers.s

  A PStream is a "Parser Stream", the input format accepted by
  FOAM parsers.

  PStreams have the following interface:
    get int     pos   - The character position in the input stream.

    get Char    head  - The first character in the stream.

    get PStream tail  - A PStream for the next position in the input steam.

    get Object  value - 'Value' associated with this PStream.

    PStream setValue(Object value) - Create a new PStream at the same position
        but with a new 'value'. The value is used to hold the result of a
        (sub-)parse.

  PStreams are immutable, which greatly simplifies backtracking.

  A parser has the following interface:
    PStream parse(PStream stream);

  It takes as input a PStream, and returns either a PStream
  advanced to the point after all input consumed by the parser,
  or undefined if the parse failed. The value generated by the parser
  is stored in the .value property of the returned PStream.
 */
foam.CLASS({
  package: 'foam.parse',
  name: 'StringPStream',

  properties: [
    {
      name: 'str',
      class: 'Simple'
    },
    {
      name: 'pos',
      class: 'Simple'
    },
    {
      name: 'head',
      getter: function() {
        return this.str[0][this.pos];
      }
    },
    {
      name: 'tail',
      getter: function() {
        if ( ! this.instance_.tail ) {
          var ps = this.cls_.create();
          ps.str = this.str;
          ps.pos = this.pos + 1;
          this.instance_.tail = ps;
        }
        return this.instance_.tail;
      },
      setter: function(value) {
        this.instance_.tail = value;
      }
    },
    {
      name: 'valid',
      getter: function() {
        return this.pos <= this.str[0].length;
      }
    },
    {
      name: 'value',
      setter: function(value) { this.instance_.value = value; },
      getter: function() {
        return this.instance_.value !== undefined ?
          this.instance_.value :
          this.str[0].charAt(this.pos - 1);
      }
    }
  ],

  methods: [
    function initArgs() {},

    function setValue(value) {
      // Force undefined values to null so that hasOwnProperty checks are faster.
      if ( value === undefined ) value = null;
      var ps = this.cls_.create();
      ps.str = this.str;
      ps.pos = this.pos;
      ps.tail = this.tail;
      ps.value = value;
      return ps;
    },

    function setString(s) {
      if ( ! this.pos ) this.pos = 0;
      if ( ! this.str ) this.str = [];
      this.str[0] = s;
    },

    function substring(end) {
      foam.assert(this.str === end.str &&
                  end.pos >= this.pos,
                  'Cannot make substring: end PStream is not a tail of this.');

      return this.str[0].substring(this.pos, end.pos);
    },

    function apply(p, obj) {
      return p.parse(this, obj);
    }
  ]
});


foam.CLASS({
  package: 'foam.parse',
  name: 'ParserArray',
  extends: 'FObjectArray',

  properties: [
    ['of', 'foam.parse.Parser'],
    ['adapt', function(_, a) {
        if ( ! a ) return [];
        var b = new Array(a.length);
        for ( var i = 0 ; i < a.length ; i++ ) {
          b[i] = typeof a[i] === 'string' ?
              foam.parse.Literal.create({s: a[i]}) :
              a[i];
        }
        return b;
      }
    ]
  ]
});


foam.CLASS({
  package: 'foam.parse',
  name: 'ParserProperty',
  extends: 'Property',

  properties: [
    {
      name: 'adapt',
      value: function(_, v) {
        return typeof v === 'string' ? foam.parse.Literal.create({s: v}) : v;
      }
    }
  ]
});


foam.CLASS({
  package: 'foam.parse',
  name: 'ParserDecorator',

  properties: [
    {
      name: 'p',
      class: 'foam.parse.ParserProperty',
      final: true
    }
  ],

  methods: [
    function toString() { return this.p.toString(); }
  ]
});


foam.CLASS({
  package: 'foam.parse',
  name: 'Literal',

  documentation: 'Matches a literal with the parse stream (case sensitive)',

  properties: [
    {
      name: 's',
      final: true
    },
    {
      name: 'value',
      final: true
    }
  ],

  methods: [
    function parse(ps) {
      var str = this.s;
      for ( var i = 0 ; i < str.length ; i++, ps = ps.tail ) {
        if ( str.charAt(i) !== ps.head ) {
          return undefined;
        }
      }
      return ps.setValue(this.value !== undefined ? this.value : str);
    },

    function toString() {
      return '"' + this.s + '"';
    }
  ]
});


foam.CLASS({
  package: 'foam.parse',
  name: 'LiteralIC',

  documentation: 'Matches a literal with the parse stream (case insensitive)',

  properties: [
    {
      name: 's',
      final: true,
      postSet: function(old, nu) {
        this.lower = nu.toLowerCase();
      }
    },
    {
      name: 'lower',
      final: true
    },
    {
      name: 'value',
      final: true
    }
  ],

  methods: [
    function parse(ps) {
      var str = this.lower;
      for ( var i = 0 ; i < str.length ; i++, ps = ps.tail ) {
        if ( ! ps.head || str.charAt(i) !== ps.head.toLowerCase() ) {
          return undefined;
        }
      }
      return ps.setValue(this.value !== undefined ? this.value : this.s);
    },

    function toString() {
      return 'ignoreCase("' + this.lower + '")';
    }
  ]
});


foam.CLASS({
  package: 'foam.parse',
  name: 'Alternate',

  documentation: 'Attempts to match one of the parser properties to the parse stream.',

  properties: [
    {
      name: 'args',
      final: true,
      class: 'foam.parse.ParserArray'
    }
  ],

  methods: [
    function parse(ps, obj) {
      // TODO(adamvy): Should we remove the obj argument in favour of
      // passing the obj along via context or something?
      var args = this.args;
      for ( var i = 0, p ; p = args[i] ; i++ ) {
        var ret = ps.apply(p, obj);
        if ( ret ) return ret;
      }
      return undefined;
    },

    function toString() {
      var args = this.args;
      var strs = new Array(args.length);
      for ( var i = 0; i < args.length; i++ ) {
        strs[i] = args[i].toString();
      }
      return 'alt(' + strs.join(', ') + ')';
    }
  ]
});


foam.CLASS({
  package: 'foam.parse',
  name: 'Sequence',

  documentation: 'Parses the parser properties sequentially.',

  properties: [
    {
      name: 'args',
      final: true,
      class: 'foam.parse.ParserArray'
    }
  ],

  methods: [
    function parse(ps, obj) {
      var ret = [];
      var args = this.args;
      for ( var i = 0, p ; p = args[i] ; i++ ) {
        if ( ! ( ps = ps.apply(p, obj) ) ) return undefined;
        ret.push(ps.value);
      }
      return ps.setValue(ret);
    },

    function toString() {
      var args = this.args;
      var strs = new Array(args.length);
      for ( var i = 0; i < args.length; i++ ) {
        strs[i] = args[i].toString();
      }
      return 'seq(' + strs.join(', ') + ')';
    }
  ]
});


foam.CLASS({
  package: 'foam.parse',
  name: 'String',
  extends: 'foam.parse.ParserDecorator',
  methods: [
    function parse(ps, obj) {
      ps = ps.apply(this.p, obj);
      return ps ? ps.setValue(ps.value.join('')) : undefined;
    },

    function toString() {
      return 'str(' + this.SUPER() + ')';
    }
  ]
});


foam.CLASS({
  package: 'foam.parse',
  name: 'Substring',
  extends: 'foam.parse.ParserDecorator',
  methods: [
    function parse(ps, obj) {
      var start = ps;
      ps = ps.apply(this.p, obj);
      return ps ? ps.setValue(start.substring(ps)) : undefined;
    },

    function toString() {
      return 'str(' + this.SUPER() + ')';
    }
  ]
});


foam.CLASS({
  package: 'foam.parse',
  name: 'Sequence0',

  documentation: `Parses the parser properties sequentially,
    without returning value`,

  properties: [
    {
      name: 'args',
      final: true,
      class: 'foam.parse.ParserArray'
    }
  ],

  methods: [
    function parse(ps, obj) {
      var args = this.args;
      for ( var i = 0, p ; p = args[i] ; i++ ) {
        if ( ! ( ps = ps.apply(p, obj) ) ) return undefined;
      }
      return ps;
    },

    function toString() {
      var args = this.args;
      var strs = new Array(args.length);
      for ( var i = 0; i < args.length; i++ ) {
        strs[i] = args[i].toString();
      }
      return 'seq0(' + strs.join(', ') + ')';
    }
  ]
});

foam.CLASS({
  package: 'foam.parse',
  name: 'Sequence1',

  documentation: `Parses the parser properties sequentially, returning
    the n(th) property value parsed.`,

  properties: [
    {
      name: 'args',
      final: true,
      class: 'foam.parse.ParserArray'
    },
    {
      name: 'n',
      final: true
    }
  ],

  methods: [
    function parse(ps, obj) {
      var ret;
      var args = this.args;
      var n = this.n;
      for ( var i = 0, p ; p = args[i] ; i++ ) {
        if ( ! ( ps = ps.apply(p, obj) ) ) return undefined;
        if ( i === n ) ret = ps.value;
      }
      return ps.setValue(ret);
    },

    function toString() {
      var args = this.args;
      var strs = new Array(args.length);
      for ( var i = 0; i < args.length; i++ ) {
        strs[i] = args[i].toString();
      }
      return 'seq1(' + this.n + ', ' + strs.join(', ') + ')';
    }
  ]
});

foam.CLASS({
  package: 'foam.parse',
  name: 'Optional',
  extends: 'foam.parse.ParserDecorator',

  documentation: 'Refers to an optional parser property.',

  methods: [
    function parse(ps, obj) {
      return ps.apply(this.p, obj) || ps.setValue(null);
    },

    function toString() {
      return 'opt(' + this.SUPER() + ')';
    }
  ],
});


foam.CLASS({
  package: 'foam.parse',
  name: 'AnyChar',

  documentation: `Matches any char within the parse stream.
    Often used under the else clause of the 'not' parser
    property. Ex. \`not(',', anyChar())\``,

  axioms: [ foam.pattern.Singleton.create() ],

  methods: [
    function parse(ps) {
      return ps.head ? ps.tail : undefined;
    },

    function toString() { return 'anyChar()'; }
  ]
});


foam.CLASS({
  package: 'foam.parse',
  name: 'NotChars',

  documentation: `Matches against all but the chars specified
    in the argument string.`,

  properties: [
    {
      name: 'string',
      final: true
    }
  ],

  methods: [
    function parse(ps) {
      return ps.head && this.string.indexOf(ps.head) === -1 ?
        ps.tail : undefined;
    },

    function toString() {
      var str = this.string;
      var chars = new Array(str.length);
      for ( var i = 0; i < str.length; i++ ) {
        chars[i] = str.charAt(i);
      }
      return 'notChars("' + chars.join('", "') + '")';
    }
  ]
});


foam.CLASS({
  package: 'foam.parse',
  name: 'Chars',

  documentation: `Matches against any of the chars specified
    in the argument string.`,

  properties: [
    {
      name: 'string',
      final: true
    }
  ],

  methods: [
    function parse(ps) {
      return ps.valid && this.string.indexOf(ps.head) !== -1 ?
        ps.tail : undefined;
    },

    function toString() {
      var str = this.string;
      var chars = new Array(str.length);
      for ( var i = 0; i < str.length; i++ ) {
        chars[i] = str.charAt(i);
      }
      return 'chars("' + chars.join('", "') + '")';
    }
  ]
});


foam.CLASS({
  package: 'foam.parse',
  name: 'Range',

  documentation: `Matches against a range of chars specified
    with from/to. Ex. \`range('0', '9')\` for digits`,

  properties: [
    {
      name: 'from',
      final: true
    },
    {
      name: 'to',
      final: true
    }
  ],

  methods: [
    function parse(ps) {
      if ( ! ps.head ) return undefined;
      return ( this.from <= ps.head && ps.head <= this.to ) ?
          ps.tail.setValue(ps.head) :
          undefined;
    },

    function toString() {
      return 'range("' + this.from + '", "' + this.to + '")';
    }
  ]
});


foam.CLASS({
  package: 'foam.parse',
  name: 'Repeat',
  extends: 'foam.parse.ParserDecorator',

  documentation: `Repeats matching to the parser property specified
    with an optional delimiter, and min number of matches.`,

  properties: [
    {
      class: 'foam.parse.ParserProperty',
      name: 'delimiter'
    },
    {
      class: 'Int',
      name: 'minimum'
    }
  ],

  methods: [
    function parse(ps, obj) {
      var ret = [];
      var p = this.p;
      var last;
      var delim = this.delimiter;

      while ( ps ) {
        // Checks for end of string
        if ( last && ( last.pos == ps.str[0].length ) ) {
          // Checks if previous char was delimiter, if not removes trailing empty string
          // TODO: Find a better way to handle reading past input
          if ( delim && ( ps.str[0][last.pos - 1] != delim.s ) ) ret.pop();
          return ps.setValue(ret);
        }

        last = ps;
        ps = ps.apply(p, obj);
        if ( ps ) ret.push(ps.value);
        if ( delim && ps ) {
          ps = ps.apply(delim, obj) || ps;
        }
      }

      if ( this.minimum > 0 && ret.length < this.minimum ) return undefined;

      return last.setValue(ret);
    },

    function toString() {
      var str = 'repeat(' + this.SUPER();
      if ( this.delimiter ) str += ', ' + this.delimiter;
      if ( this.minimum ) str += ', ' + this.minimum;
      str += ')';
      return str;
    }
  ]
});


foam.CLASS({
  package: 'foam.parse',
  name: 'Plus',
  extends: 'foam.parse.Repeat',

  documentation: `Repeats matching to a parser property at least one time
    with an optional delimiter.`,

  properties: [
    ['minimum', 1]
  ],

  methods: [
    function toString() {
      var str = 'plus(' + this.p.toString();
      if ( this.delimiter ) str += ', ' + this.delimiter;
      str += ')';
      return str;
    }
  ]
});


foam.CLASS({
  package: 'foam.parse',
  name: 'Repeat0',
  extends: 'foam.parse.Repeat',

  documentation: `Repeats matching to a parser property,
    without returning a value. Useful for whitespace.
    Ex. \`repeat0(sym('white'))\``,

  methods: [
    function parse(ps, obj) {
      var p = this.p;
      var last;
      var delim = this.delimiter;
      var i = 0;

      while ( ps ) {
        last = ps;
        ps = ps.apply(p, obj);
        if ( ps ) i++;
        if ( delim && ps ) {
          ps = ps.apply(delim, obj) || ps;
        }
      }

      if ( this.minimum > 0 && i < this.minimum ) return undefined;
      return last;
    },

    function toString() {
      var str = 'repeat0(' + this.p.toString();
      if ( this.delimiter ) str += ', ' + this.delimiter;
      if ( this.minimum ) str += ', ' + this.minimum;
      str += ')';
      return str;
    }
  ]
});


foam.CLASS({
  package: 'foam.parse',
  name: 'Not',
  extends: 'foam.parse.ParserDecorator',

  documentation: `Ensures the leading char isn't the parser
    property specified. If not, attempts to parse with the
    else clause parser property. Useful for matching all but
    a particular character. Ex. \`not('"', anyChar())\``,

  properties: [
    {
      name: 'else',
      final: true,
      class: 'foam.parse.ParserProperty'
    }
  ],

  methods: [
    function parse(ps, obj) {
      return ps.apply(this.p, obj) ?
        undefined :
        (this.else ? ps.apply(this.else, obj) : ps);
    },

    function toString() {
      var str = 'not(' + this.SUPER();
      if ( this.else ) str += ', ' + this.else.toString();
      str += ')';
      return str;
    }
  ]
});


foam.CLASS({
  package: 'foam.parse',
  name: 'ParserWithAction',
  extends: 'foam.parse.ParserDecorator',

  properties: [
    'action'
  ],

  methods: [
    function parse(ps, obj) {
      ps = ps.apply(this.p, obj);
      return ps ?
        ps.setValue(this.action(ps.value)) :
        undefined;
    }
  ]
});


foam.CLASS({
  package: 'foam.parse',
  name: 'Symbol',

  documentation: `Parses based on the parser property named.`,

  properties: [
    {
      name: 'name',
      final: true
    },
  ],

  methods: [
    function parse(ps, grammar) {
      var p = grammar.getSymbol(this.name);
      if ( ! p ) {
        console.error('No symbol found for', this.name);
        return undefined;
      }
      return ps.apply(p, grammar);
    },

    function toString() { return 'sym("' + this.name + '")'; }
  ]
});


foam.CLASS({
  package: 'foam.parse',
  name: 'Parsers',

  axioms: [ foam.pattern.Singleton.create() ],

  methods: [
    function seq() {
      return this.lookup('foam.parse.Sequence').create({
        args: Array.from(arguments)
      });
    },

    function repeat0(p, delim, min) {
      return this.lookup('foam.parse.Repeat0').create({
        p: p,
        minimum: min || 0,
        delimiter: delim
      });
    },

    function simpleAlt() {
      return this.lookup('foam.parse.Alternate').create({
        args: Array.from(arguments)
      });
    },

    function alt() {
      return this.lookup('foam.parse.Alternate').create({
        args: Array.from(arguments)
      });
    },

    function sym(name) {
      return this.lookup('foam.parse.Symbol').create({
        name: name
      });
    },

    function seq1(n) {
      return this.lookup('foam.parse.Sequence1').create({
        n: n,
        args: Array.from(arguments).slice(1)
      });
    },

    function seq0() {
      return this.lookup('foam.parse.Sequence0').create({
        args: Array.from(arguments)
      });
    },

    function repeat(p, delim, min) {
      return this.lookup('foam.parse.Repeat').create({
        p: p,
        minimum: min || 0,
        delimiter: delim
      });
    },

    function plus(p, delim) {
      return this.lookup('foam.parse.Plus').create({
        p: p,
        delimiter: delim
      });
    },

    function str(p) {
      return this.lookup('foam.parse.String').create({
        p: p
      });
    },

    function substring(p) {
      return this.lookup('foam.parse.Substring').create({
        p: p
      });
    },

    function range(a, b) {
      return this.lookup('foam.parse.Range').create({
        from: a,
        to: b
      });
    },

    function notChars(s) {
      return this.lookup('foam.parse.NotChars').create({
        string: s
      });
    },

    function chars(s) {
      return this.lookup('foam.parse.Chars').create({
        string: s
      });
    },

    function not(p, opt_else) {
      return this.lookup('foam.parse.Not').create({
        p: p,
        else: opt_else
      });
    },

    function optional(p) {
      return this.lookup('foam.parse.Optional').create({
        p: p
      });
    },

    function literal(s, value) {
      return this.lookup('foam.parse.Literal').create({
        s: s,
        value: value
      });
    },

    function literalIC(s, value) {
      return this.lookup('foam.parse.LiteralIC').create({
        s: s,
        value: value
      });
    },

    function anyChar() {
      return foam.parse.AnyChar.create();
    }
  ]
});


foam.CLASS({
  package: 'foam.parse',
  name: 'PSymbol',

  properties: ['name', 'parser']
});


foam.CLASS({
  package: 'foam.parse',
  name: 'Grammar',

  requires: [
    'foam.parse.StringPStream',
    'foam.parse.Parsers'
  ],

  properties: [
    {
      class: 'FObjectArray',
      of: 'foam.parse.PSymbol',
      name: 'symbols',
      adapt: function(_, o) {
        if ( Array.isArray(o) ) return o;

        if ( typeof o === 'function' ) {
          var args = o.toString().match(/\((.*?)\)/);
          if ( ! args ) {
            throw 'Could not parse arguments from parser factory function';
          }

          o = foam.Function.withArgs(o, this.Parsers.create(), this);
        }

        var a = [];
        for ( var key in o ) {
          a.push(foam.parse.PSymbol.create({
            name: key,
            parser: o[key]
          }));
        }
        return a;
      }
    },
    {
      name: 'symbolMap_',
      expression: function(symbols) {
        var m = {};
        for ( var i = 0 ; i < symbols.length ; i++ ) {
          if ( m[symbols[i].name] ) {
            console.error('Duplicate symbol found', symbols[i].name);
          }
          m[symbols[i].name] = symbols[i];
        }
        return m;
      }
    },
    {
      name: 'ps',
      factory: function() {
        return this.StringPStream.create();
      }
    }
  ],

  methods: [
    function parseString(str, opt_name) {
      var result = this.getParse(str, opt_name);
      return result && result.value;
    },

    function getParse(str, opt_name) {
      opt_name = opt_name || 'START';

      this.ps.setString(str);
      var start = this.getSymbol(opt_name);
      foam.assert(start, 'No symbol found for', opt_name);

      return this.ps.apply(start, this);
    },

    function getSymbol(name) {
      return this.symbolMap_[name].parser;
    },

    function addSymbol(name, parser) {
      this.symbols.push(foam.parse.PSymbol.create({
        name: name, parser: parser
      }));
    },

    function addActions(map) {
      for ( var key in map ) {
        this.addAction(key, map[key]);
      }
      return this;
    },

    function addAction(name, action) {
      for ( var i = 0 ; i < this.symbols.length ; i++ ) {
        if ( this.symbols[i].name === name ) {
          this.symbols[i].parser = foam.parse.ParserWithAction.create({
            p: this.symbols[i].parser,
            action: action
          });
        }
      }

      // TODO(adamvy): Array property should help me here
      this.pub('propertyChange', 'symbols', this.slot('symbols'));
      return this;
    }
  ]
});

foam.CLASS({
  package: 'foam.parse',
  name: 'GrammarAxiom',
  properties: [
    {
      class: 'String',
      name: 'name'
    },
    {
      class: 'String',
      name: 'language',
      value: 'foam.parse.Parsers'
    },
    {
      name: 'symbols'
    },
    {
      class: 'Array',
      name: 'actions'
    },
    {
      class: 'Boolean',
      documentation: `When true, use foam.Function.withArgs() to evaluate
          symbols function in its original script closure context. Otherwise,
          use with(language) { eval(symbols()); }.`,
      name: 'withArgs'
    }
  ],
  methods: [
    function installInProto(proto) {
      var name = this.name;
      var axiom = this;
      Object.defineProperty(proto, name, {
        get: function() {
          var g = this.getPrivate_(name);

          if ( ! g ) {
            this.setPrivate_(name, g = axiom.buildGrammar(this));
          }

          return this.getPrivate_(name);
        }
      });
    },
    function buildGrammar(obj) {
      var g = obj.lookup('foam.parse.Grammar').create(null, obj);

      var symbols;

      if ( typeof this.symbols == 'function' ) {
        var language = obj.lookup(this.language).create();
        if (this.withArgs) {
          symbols = foam.Function.withArgs(this.symbols, language);
        } else {
          with(obj.lookup(this.language).create()) {
            symbols = eval('(' + this.symbols.toString() + ')()');
          }
        }
      } else {
        symbols = this.symbols;
      }

      for ( var key in symbols ) {
        g.addSymbol(key, symbols[key]);
      }

      for ( var i = 0 ; i < this.actions.length ; i++ ) {
        g.addAction(this.actions[i].name, (this.actions[i].code || this.actions[i]).bind(obj));
      }

      return g;
    }
  ]
});


foam.CLASS({
  refines: 'foam.core.Model',
  properties: [
    {
      class: 'AxiomArray',
      name: 'grammars',
      of: 'foam.parse.GrammarAxiom'
    }
  ]
});

foam.CLASS({
  package: 'foam.parse',
  name: 'ImperativeGrammar',
  extends: 'foam.parse.Grammar',
});

/*
TODO(adamvy):
  -detect non string values passed to StringPStream.setString()
*/
/**
 * @license
 * Copyright 2017 The FOAM Authors. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

foam.CLASS({
  package: 'foam.parse.json',
  name: 'String',

  constants: {
    CHAR_CODE_0:       '0'.charCodeAt(0),
    CHAR_CODE_9:       '9'.charCodeAt(0),
    CHAR_CODE_A_LOWER: 'a'.charCodeAt(0),
    CHAR_CODE_F_LOWER: 'f'.charCodeAt(0),
    CHAR_CODE_A_UPPER: 'A'.charCodeAt(0),
    CHAR_CODE_F_UPPER: 'F'.charCodeAt(0)
  },

  properties: [
    {
      class: 'String',
      name: 'escape',
      value: '\\'
    },
    {
      name: 'escapeChars',
      value: {
        'n': '\u000a',
        'f': '\u000c',
        'b': '\u0008',
        'r': '\u000d',
        't': '\u0009'
      }
    }
  ],

  methods: [
    function parse(ps, obj) {
      var delim = ps.head;
      var escape = this.escape;

      if ( delim !== '"' && delim !== "'" ) return undefined;

      ps = ps.tail;

      var lastc = delim;
      var str = '';

      while ( ps.valid ) {
        var c = ps.head;
        if ( c === delim && lastc !== escape ) break;

        if ( c !== escape ) {
          str += c;
        } else {
          var next = ps.tail.head;
          if ( next === escape ) {
            // "\\" parses to "\".
            str += escape;
            ps = ps.tail;
          } else if ( ps.tail.head === 'u' ) {
            // Unicode escape sequence: "\u####".
            // Extract "###".
            var hexCharCode = ps.tail.str[0].substr(ps.pos + 2, 4);
            // Verify that each character in sequence is a hex digit.
            for ( var i = 0; i < hexCharCode.length; i++ ) {
              var hexDigitCharCode = hexCharCode.charCodeAt(i);
              if ( ! this.isHexDigitCharCode_(hexDigitCharCode) )
                throw new Error('FON string parse error at ' + ps.pos + ': ' +
                                'Invalid unicode escape sequence: \\u' +
                                hexCharCode);
            }
            // Construct hex character and add it to str.
            var charCode = parseInt(hexCharCode, 16);
            c = String.fromCharCode(charCode);
            str += c;
            // Advance to last char in "\u####" escape sequence.
            ps = ps.tail.tail.tail.tail.tail;
          } else if ( this.escapeChars[ps.tail.head] ) {
            c = this.escapeChars[ps.tail.head];
            str += c;
            ps = ps.tail;
          }
        }

        lastc = c;
        ps = ps.tail;
      }

      return ps.tail.setValue(str);
    },

    function isHexDigitCharCode_(charCode) {
      return ( ( charCode >= this.CHAR_CODE_0 &&
                 charCode <= this.CHAR_CODE_9 ) ||
               ( charCode >= this.CHAR_CODE_A_LOWER &&
                 charCode <= this.CHAR_CODE_F_LOWER ) ||
               ( charCode >= this.CHAR_CODE_A_UPPER &&
                 charCode <= this.CHAR_CODE_F_UPPER ) );
    }
  ]
});


foam.CLASS({
  package: 'foam.parse.json',
  name: 'Parsers',
  extends: 'foam.parse.Parsers',

  methods: [
    function string() {
      return foam.parse.json.String.create();
    }
  ]
});
/**
 * @license
 * Copyright 2017 The FOAM Authors. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

foam.CLASS({
  package: 'foam.parsers',
  name: 'FON',
  implements: [ 'foam.json.Parser' ],
  properties: [
    {
      name: 'creationContext'
    }
  ],
  methods: [
    function parseString(str) {
      return this.parseClassFromString(str, null);
    },
    function parseClassFromString(str, opt_cls) {
      foam.assert(this.creationContext, 'No creation context assigned.');

      var res = this.grammar.parseString(str, 'obj');
      if ( ! res ) return null;
      return foam.json.parse(res, opt_cls, this.creationContext);
    }
  ],
  grammars: [
    {
      name: 'grammar',
      language: 'foam.parse.json.Parsers',
      symbols: function() {
        return {
          'obj': seq1(3,
                      sym('ws'),
                     '{', sym('ws'),
                     repeat(sym('keyValue'), seq0(',', sym('ws'))),
                     sym('ws'),
                     '}',
                     sym('ws')),
          'keyValue': seq(sym('key'), sym('ws'),
                          ':', sym('ws'),
                          sym('value'), sym('ws')),

          'key': alt(string(),
                     sym('identifier')),

          'ws': repeat0(chars(' \t\r\n')),

          // TODO: Support all valid characters, should consult unicode tables for things like ID_Start
          'id_start': alt(
            range('a', 'z'),
            range('A', 'Z'),
            '_',
            '$'),

          'identifier': substring(seq0(
            sym('id_start'),
            repeat0(alt(range('0', '9'), sym('id_start'))))),

          'value': alt(
            string(),
            sym('null'),
            sym('undefined'),
            sym('number'),
            sym('bool'),
            sym('array'),
            sym('obj')),

          'null': literal('null', null),
          'undefined': literal('undefined', undefined),
          'number': substring(seq0(optional('-'),
                             repeat0(range('0', '9'), null, 1),
                             optional(
                               seq0('.', repeat0(range('0', '9')))),
                             optional(
                               seq0('e', alt('-', '+'), repeat0(range('0', '9')))))),
          'bool': alt(literal('true', true),
                      literal('false', false)),

          'array': seq1(2,
                        '[', sym('ws'),
                        repeat(sym('value'), seq0(',', sym('ws'))), sym('ws'),
                       ']', sym('ws'))
        };
      },
      actions: [
        function obj(a) {
          var obj = {};
          for ( var i = 0 ; i < a.length ; i++ ) {
            obj[a[i][0]] = a[i][4];
          }
          return obj
        },
        function number(a) {
          return parseFloat(a);
        }
      ]
    }
  ]
});
/**
 * @license
 * Copyright 2016 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

foam.CLASS({
  package: 'foam.templates',
  name: 'TemplateOutput',

  documentation: 'A buffer for storing Template output.',

  properties: [
    {
      name: 'buf',
      factory: function() { return []; }
    }
  ],

  methods: [
    function output() {
      for ( var i = 0 ; i < arguments.length ; i++ ) {
        var o = arguments[i];

        if ( typeof o === 'object' ) {
          this.buf.push(o.toString());
        } else {
          this.buf.push(o);
        }
      }
    },

    function toString() {
      return this.buf.length == 0 ? '' :
        this.buf.length == 1 ? this.buf[0] :
        this.buf.join('');
    }
  ]
});


foam.CLASS({
  package: 'foam.templates',
  name: 'TemplateUtil',

  documentation: 'Utility methods for working with Templates. Mostly just for internal use.',

  axioms: [ foam.pattern.Singleton.create() ],

  requires: [
    'foam.parse.ImperativeGrammar as Grammar'
  ],

  constants: {
    HEADER: 'var self = this, ctx = this.__context__, Y = this.__subContext__;\n' +
      'var output = opt_outputter ? opt_outputter : TOC(this);\n' +
      'var out = output.output.bind(output);\n' +
      "out('",
    FOOTER: "');\nreturn opt_outputter ? output : output.toString();\n"
  },

  properties: [
    {
      name: 'grammar',
      factory: function() {
        var g = this.Grammar.create({
          symbols: function(repeat0, simpleAlt, sym, seq1, seq, repeat, notChars, anyChar, not, optional, literal) {
            return {
              START: sym('markup'),

              markup: repeat0(simpleAlt(
                sym('comment'),
                sym('simple value'),
                sym('raw values tag'),
                sym('code tag'),
                sym('ignored newline'),
                sym('newline'),
                sym('single quote'),
                sym('text')
              )),

              'comment': seq1(1, '<!--', repeat0(not('-->', anyChar())), '-->'),

              'simple value': seq('%%', repeat(notChars(' ()-"\r\n><:;,')), optional('()')),

              'raw values tag': simpleAlt(
                seq('<%=', repeat(not('%>', anyChar())), '%>')
              ),

              'code tag': seq('<%', repeat(not('%>', anyChar())), '%>'),
              'ignored newline': simpleAlt(
                literal('\\\r\\\n'),
                literal('\\\n')
              ),
              newline: simpleAlt(
                literal('\r\n'),
                literal('\n')
              ),
              'single quote': literal("'"),
              text: anyChar()
            }
          }
        });

        var self = this;

        g.addActions({
          markup: function(v) {
            var wasSimple = self.simple;
            var ret = wasSimple ? null : self.out.join('');
            self.out = [];
            self.simple = true;
            return [wasSimple, ret];
          },
          'simple value': function(v) {
            self.push("',\n self.",
                v[1].join(''),
                v[2],
                ",\n'");
          },
          'raw values tag': function (v) {
            self.push("',\n",
                v[1].join(''),
                ",\n'");
          },
          'code tag': function (v) {
            self.push("');\n",
                v[1].join(''),
                ";out('");
          },
          'single quote': function() {
            self.push("\\'");
          },
          newline: function() {
            self.push('\\n');
          },
          text: function(v) {
            self.pushSimple(v);
          }
        });
        return g;
      }
    },
    {
      name: 'out',
      factory: function() { return []; }
    },
    {
      name: 'simple',
      value: true
    }
  ],

  methods: [
    function push() {
      this.simple = false;
      this.pushSimple.apply(this, arguments);
    },

    function pushSimple() {
      this.out.push.apply(this.out, arguments);
    },

    function compile(t, name, args) {
      var result = this.grammar.parseString(t);
      if ( ! result ) throw "Error parsing template " + name;

      var code = this.HEADER +
          ( result[0] ? t : result[1] ) +
          this.FOOTER;

      var newArgs = ['opt_outputter'].concat(args.map(function(a) { return a.name || a }));
      var f = eval(
        '(function() { ' +
          'var TOC = function(o) { return foam.templates.TemplateOutput.create(); };' +
          'var f = function(' + newArgs.join(',') + '){' + code + '};' +
          'return function() { '+
          'if ( arguments.length && arguments[0] && ! arguments[0].output ) return f.apply(this, [undefined].concat(Array.from(arguments)));' +
          'return f.apply(this, arguments);};})()');

      return f;
    },

    function lazyCompile(t, name, args) {
      return (function(util) {
        var delegate;
        return function() {
          if ( ! delegate ) delegate = util.compile(t, name, args)
          return delegate.apply(this, arguments);
        };
      })(this);
    }
  ]
});


foam.CLASS({
  package: 'foam.templates',
  name: 'TemplateAxiom',
  extends: 'Method',

  properties: [
    {
      name: 'template',
      class: 'String'
    },
    { name: 'code', required: false },
    'args'
  ],

  methods: [
    function installInProto(proto) {
      proto[this.name] =
          foam.templates.TemplateUtil.create().lazyCompile(
              this.template, this.name, this.args || []);
    }
  ]
});


foam.CLASS({
  package: 'foam.templates',
  name: 'TemplateExtension',
  refines: 'foam.core.Model',

  properties: [
    {
      name: 'templates',
      class: 'AxiomArray',
      of: 'foam.templates.TemplateAxiom',
      adaptArrayElement: function(o, prop) {
        return this.lookup(prop.of).create(o);
      }
    }
  ]
});
/**
 * @license
 * Copyright 2017 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

foam.locale = foam.locale || 'en';

foam.CLASS({
  package: 'foam.i18n',
  name: 'MessageAxiom',

  properties: [
    {
      class: 'String',
      name: 'name'
    },
    {
      class: 'String',
      name: 'description'
    },
    {
      class: 'Object',
      name: 'messageMap',
      help: 'Map of language codes to the message in that language.',
      factory: function() { return {}; }
    },
    {
      class: 'String',
      name: 'message',
      getter: function() { return this.message_ || this.messageMap[foam.locale]; },
      setter: function(m) { this.message_ = this.messageMap[foam.locale] = m; }
    },
    {
      class: 'Simple',
      name: 'message_'
    }
  ],

  methods: [
    function installInClass(cls) {
      Object.defineProperty(
        cls,
        this.name,
        {
          value: this.message,
          configurable: false
        });
    },

    function installInProto(proto) {
      this.installInClass(proto);
    }
  ]
});


foam.CLASS({
  package: 'foam.i18n',
  name: 'MessagesExtension',
  refines: 'foam.core.Model',

  properties: [
    {
      name: 'messages',
      class: 'AxiomArray',
      of: 'foam.i18n.MessageAxiom'
    }
  ]
});
/**
 * @license
 * Copyright 2016 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
  Actions are high-level executable behaviours that are typically
  triggered by users and represented as buttons or menus.

  Actions are installed as methods on the class, but contain more
  meta-information than regular methods. Meta-information includes
  information needed to surface to action in a meaningful way to
  users, and includes things like the label to appear in the button
  or menu, a speech-label for i18n, help text, dynamic functions to
  enable or disable and hide or unhide the UI associated with this Action.

  Actions implement the Action Design Pattern.
*/
foam.CLASS({
  package: 'foam.core',
  name: 'Action',

  documentation: 'An Action is a method with extra GUI support.',

  properties: [
    {
      class: 'String',
      name: 'name',
      required: true
    },
    {
      class: 'String',
      name: 'label',
      expression: function(name) { return foam.String.labelize(name); }
    },
    {
      class: 'String',
      name: 'speechLabel',
      expression: function(label) { return label; }
    },
    {
      documentation: 'displayed on :hover',
      class: 'String',
      name: 'toolTip',
      expression: function(label) { return label; }
    },
    {
      name: 'icon'
    },
    {
      class: 'Boolean',
      name: 'confirmationRequired',
      documentation: 'If confirmation is required. Recommended for destructive actions.'
    },
    {
      class: 'String',
      name: 'iconFontFamily',
      value: 'Material Icons'
    },
    {
      class: 'String',
      name: 'iconFontClass',
      value: 'material-icons'
    },
    {
      class: 'String',
      name: 'iconFontName'
    },
    {
      class: 'Array',
      name: 'keyboardShortcuts'
    },
    {
      class: 'String',
      name: 'help'
    },
    {
      class: 'Boolean',
      name: 'isDefault',
      help: 'Indicates if this is the default action.',
      value: false
    },
    {
      class: 'Function',
      name: 'isAvailable',
      label: 'Available',
      help: 'Function to determine if action is available.',
      value: null
    },
    {
      class: 'Function',
      name: 'isEnabled',
      label: 'Enabled',
      help: 'Function to determine if action is enabled.',
      value: null
    },
    {
      class: 'Function',
      name: 'code',
      required: true,
      value: null
    }
  ],

  methods: [
    function isEnabledFor(data) {
      return this.isEnabled ?
        data.slot(this.isEnabled).get() :
        true;
    },

    function createIsEnabled$(data$) {
      return foam.core.ExpressionSlot.create({
        obj$: data$,
        code: this.isEnabled
      });
    },

    function isAvailableFor(data) {
      return this.isAvailable ?
        foam.Function.withArgs(this.isAvailable, data) :
        true ;
    },

    function createIsAvailable$(data$) {
      return foam.core.ExpressionSlot.create({
        obj$: data$,
        code: this.isAvailable
      });
    },

    function maybeCall(ctx, data) {
      if ( this.isEnabledFor(data) && this.isAvailableFor(data) ) {
        this.code.call(data, ctx, this);
        data && data.pub('action', this.name, this);
        return true;
      }

      return false;
    },

    function installInClass(c) {
      c.installConstant(this.name, this);
    },

    function installInProto(proto) {
      var action = this;
      proto[this.name] = function() {
        return action.maybeCall(this.__context__, this);
      };
    }
  ]
});


/** Add Action support to Model. */
foam.CLASS({
  refines: 'foam.core.Model',

  properties: [
    {
      class: 'AxiomArray',
      of: 'Action',
      name: 'actions',
      adaptArrayElement: function(o, prop) {
        if ( typeof o === 'function' ) {
          return foam.core.Action.create({name: o.name, code: o});
        }

        if ( o.class ) {
          var a = this.lookup(o.class);
          if ( ! a ) throw 'Unknown class : ' + o.class;
          return a.create(o, this);
        }

        return this.lookup(prop.of).create(o, this);
      }
    }
  ]
});
/**
 * @license
 * Copyright 2017 The FOAM Authors. All Rights Reserved.
 * http://www.apache.org/licenses/LICENSE-2.0
 */

foam.CLASS({
  package: 'foam.core',
  name: 'Static',
  extends: 'foam.core.AbstractMethod',

  documentation: 'An Axiom for defining static methods.',

  methods: [
    function isStatic() { return true; },

    function installInClass(cls) {
      Object.defineProperty(
        cls,
        this.name,
        {
          value: this.code,
          configurable: false
        });
    },

    function installInProto(proto) {
      this.installInClass(proto);
    }
  ]
});


foam.CLASS({
  refines: 'foam.core.Model',

  properties: [
    {
      class: 'AxiomArray',
      of: 'Static',
      name: 'static',
      adaptArrayElement: function(o) {
        if ( typeof o === 'function' ) {
          var name = foam.Function.getName(o);
          foam.assert(name, 'Static must be named');
          return foam.core.Static.create({name: name, code: o});
        }

        return foam.core.Static.isInstance(o) ?
            o :
            foam.core.Static.create(o) ;
      }
    }
  ]
});
/**
 * @license
 * Copyright 2017 The FOAM Authors. All Rights Reserved.
 * http://www.apache.org/licenses/LICENSE-2.0
 */

foam.CLASS({
  package: 'foam.core',
  name: 'Reaction',

  properties: [
    {
      name: 'name',
      expression: function(target, topic, listener) {
        return 'reaction_' + target +  '$$' + topic + '$$' + listener;
      }
    },
    {
      class: 'String',
      name: 'target'
    },
    {
      class: 'StringArray',
      name: 'topic'
    },
    {
      name: 'listener'
    },
  ],

  methods: [
    function initObject(obj) {
      var listener = obj[this.listener];
      var topic = this.topic;

      if ( this.target === '' ) {
        obj.onDetach(obj.sub.apply(obj, this.topic.concat(listener)));
        return;
      }

      var path = this.target.split('.');

      var slot = obj;

      for ( var i = 0 ; i < path.length ; i++ ) {
        slot = slot.dot(path[i]);
      }

      if ( topic.length ) {
        var l = listener;
        var prevSub;
        var args = topic.concat(l);

        listener = function() {
          prevSub && prevSub.detach();
          var target = slot.get();
          if ( target && foam.core.FObject.isInstance(target) ) {
            obj.onDetach(prevSub = target.sub.apply(target, args));
          }
        };

        listener();
      }

      obj.onDetach(slot.sub(listener));
    }
  ]
});


foam.CLASS({
  refines: 'foam.core.Model',

  properties: [
    {
      class: 'AxiomArray',
      name: 'reactions',
      of: 'foam.core.Reaction',
      adaptArrayElement: function(e, prop) {
        return foam.Array.isInstance(e) ?
          foam.core.Reaction.create({target: e[0], topic: e[1] ? e[1].split('.') : [], listener: e[2] }) :
          e.class ? this.lookup(e.class).create(e, this) :
          this.lookup(prop.of).create(e, this);
      }
    }
  ]
});
/**
 * @license
 * Copyright 2016 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

foam.INTERFACE({
  package: 'foam.core',
  name: 'Serializable',

  documentation:
      'Marker interface to indicate that a CLASS is serializble or not.'
});
/**
 * @license
 * Copyright 2018 The FOAM Authors. All Rights Reserved.
 * http://www.apache.org/licenses/LICENSE-2.0
 */

foam.INTERFACE({
  package: 'foam.core',
  name: 'Validatable',
  documentation:
    `Dummy interface so FOAM Models can
    implement java validatable interface`
});/**
 * @license
 * Copyright 2018 The FOAM Authors. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

foam.CLASS({
  package: 'foam.json2',
  name: 'Outputter',
  properties: [
    {
      class: 'String',
      name: 'str'
    },
    {
      name: 'state',
      factory: function() {
        return [{}];
      }
    }
  ],
  methods: [
    function obj() {
      this.e();
      this.str += '{';
      this.state.push({
        end: '}',
        comma: false
      });
      return this;
    },
    function array() {
      this.e();
      this.str += '[';
      this.state.push({
        end: ']',
        array: true,
        comma: false
      });
      return this;
    },
    function top() {
      return this.state[this.state.length - 1];
    },
    function key(s) {
      if ( this.top().comma ) this.str += ',';
      else this.top().comma = true;

      this.str += this.string(s);
      this.str += ':';

      return this;
    },
    function e() {
      if ( this.top().array ) {
        if ( this.top().comma ) this.str += ',';
        this.top().comma = true;
      }
    },
    function string(s) {
      return '"' + s.
        replace(/\\/g, '\\\\').
        replace(/"/g, '\\"').
        replace(/[\x00-\x1f]/g, function(c) {
          return "\\u00" + ((c.charCodeAt(0) < 0x10) ?
                            '0' + c.charCodeAt(0).toString(16) :
                            c.charCodeAt(0).toString(16));
        }) + '"';
    },
    function s(s) {
      this.e();
      this.str += this.string(s);
      return this;
    },
    function n(n) {
      this.e();
      this.str += n;
      return this;
    },
    function b(b) {
      this.e();
      this.str += b;
      return this;
    },
    function nul() {
      this.e();
      this.str += 'null';
      return this;
    },
    function end() {
      var s = this.state.pop();
      this.str += s.end;
      return this;
    }
  ]
});
/**
 * @license
 * Copyright 2018 The FOAM Authors. All Rights Reserved.
 * http://www.apache.org/licenses/LICENSE-2.0
 */

foam.CLASS({
  package: 'foam.json2',
  name: 'Deserializer',
  imports: [
    'classloader',
  ],
  properties: [
    {
      class: 'Boolean',
      name: 'parseFunctions',
      value: false
    }
  ],
  methods: [
    function aparseString(x, str) {
      return this.aparse(x, JSON.parse(str));
    },
    function aparse(x, v) {
      var self = this;
      return new Promise(function(ret) {
        if ( v['$DEPS$'] && v['$BODY$'] ) {
          var load = self.classloader.load.bind(self.classloader);
          Promise.all(v['$DEPS$'].map(load)).then(function() {
            ret(self.parse(x, v['$BODY$']));
          });
        } else {
          ret(self.parse(x, v));
        }
      });
    },
    function parse(x, v) {
      var type = foam.typeOf(v);

      if ( type == foam.Object ) {
        if ( ! foam.Undefined.isInstance(v["$UNDEF"]) ) return undefined;
        if ( ! foam.Undefined.isInstance(v["$DATE$"]) ) {
          var d = new Date();
          d.setTime(v["$DATE"]);
          return d;
        }
        if ( ! foam.Undefined.isInstance(v["$FUNC$"]) ) {
          if ( this.parseFunctions ) {
            var name = v.name;
            var args = v.args;
            var body = v.body;
            var f = Function.apply(null, args.concat(body));
            if ( name ) foam.Function.setName(f, name);
            return f;
          }

          return null;
        }
        if ( ! foam.Undefined.isInstance(v["$INST$"]) ) {
          // Is an instance of the class defined by $INST$ key
          var cls = this.parse(x, v["$INST$"]);
        }
        if ( ! foam.Undefined.isInstance(v["$CLS$"]) ) {
          // Defines a class referenced by $CLS$ key
          return foam.lookup(v["$CLS$"]);
        }

        var keys = Object.keys(v);
        var args = {}
        for ( var i = 0 ; i < keys.length ; i++ ) {
          if ( keys[i] == '$INST$' ) continue;

          args[keys[i]] = this.parse(x, v[keys[i]]);
        }

        return cls ?
          cls.create(args, x) :
          args;

      } else if ( type == foam.Array ) {
        for ( var i = 0 ; i < v.length ; i++ ) {
          v[i] = this.parse(x, v[i]);
        }
        return v;
/*      } else if ( type == foam.Null ) {
      } else if ( type == foam.Number ) {
      } else if ( type == foam.String ) {
      } else if ( type == foam.Boolean ) { */
      } else {
        return v;
      }
    }
  ]
});
/**
 * @license
 * Copyright 2018 The FOAM Authors. All Rights Reserved.
 * http://www.apache.org/licenses/LICENSE-2.0
 */

foam.CLASS({
  package: 'foam.json2',
  name: 'Serializer',
  requires: [
    'foam.json2.Outputter',
  ],
  methods: [
    function stringify(x, v) {
      var serializer = this.InnerSerializer.create();
      serializer.output(x, v);
      return serializer.getString();
    }
  ],
  classes: [
    {
      name: 'InnerSerializer',
      requires: [
        'foam.json2.Outputter'
      ],
      properties: [
        {
          class: 'Map',
          name: 'deps'
        },
        {
          class: 'FObjectProperty',
          of: 'foam.json2.Outputter',
          name: 'out',
          factory: function() {
            return this.Outputter.create();
          }
        }
      ],
      methods: [
        function getString() {
          var deps = Object.keys(this.deps).map(function(d) { return `"${d}"` }).join(',');
          return `{"$DEPS$":[${deps}],"$BODY$":${this.out.str}}`
        },
        function output(x, v) {
          var out = this.out;
          var type = foam.typeOf(v);

          if ( type == foam.Number ) {
            out.n(v);
          } else if ( type == foam.String ) {
            out.s(v);
          } else if ( type == foam.Undefined ) {
            out.obj();
            out.key("$UNDEF");
            out.b(true);
            out.end();
          } else if ( type == foam.Null ) {
            out.nul();
          } else if ( type == foam.Boolean ) {
            out.b(v);
          } else if ( type == foam.Array ) {
            out.array();
            for ( var i = 0 ; i < v.length ; i++ ) {
              this.output(x, v[i])
            }
            out.end()
          } else if ( type == foam.Date ) {
            out.obj();
            out.key("$DATE$");
            out.n(v.getTime());
            out.end();
          } else if ( type == foam.Object ) {
            if ( foam.core.FObject.isSubClass(v) ) { // Is an actual class
              if ( v.id.indexOf('AnonymousClass') == 0 ) {
                this.output(x, v.model_);
              } else {
                out.obj();
                out.key("$CLS$");
                out.s(v.id);
                out.end();
                this.deps[v.id] = true;
              }
            } else { // is some other JS object
              if ( v.outputJSON2 ) {
                // If it knows how to output itself, let it do so
                v.outputJSON2(x, this, out);
              } else {
                // Otherwise just do our best.  This is pretty equivalent to
                // JSON.stringify()
                out.obj();
                var keys = Object.keys(v);
                for ( var i = 0 ; i < keys.length ; i++ ) {
                  if ( foam.Undefined.isInstance(v[keys[i]]) ) continue;

                  out.key(keys[i]);
                  this.output(x, v[keys[i]]);
                }
                out.end();
              }
            }
          } else if ( type == foam.core.FObject ) {
            if ( v.outputJSON2 ) v.outputJSON2(x, this, out);
            else {
              out.obj();
              var cls = v.cls_;
              var axioms = v.cls_.getAxioms();

              out.key("$INST$");
              this.output(x, cls);

              for ( var i = 0 ; i < axioms.length ; i++ ) {
                var a = axioms[i];
                if ( a.outputPropertyJSON2 ) a.outputPropertyJSON2(x, v, this, out);
              }

              out.end();
            }
          } else if ( type == foam.Function ) {

            var breakdown = foam.Function.breakdown(v);
            if ( breakdown == null ) {
              debugger;
              breakdown = foam.Function.breakdown(v);
            }

            foam.assert(breakdown, "Failed to parse funciton, this is a bug!");

            out.obj();

            out.key("$FUNC$");
            out.b(true);

            out.key("name")
            out.s(breakdown.name);

            out.key("args");
            out.array();
            for ( var i = 0 ; i < breakdown.args.length ; i++ ) {
              out.s(breakdown.args[i]);
            }
            out.end();

            out.key("body");
            out.s(breakdown.body);

            out.end();
          }
        }
      ]
    }
  ]
});

foam.CLASS({
  refines: 'foam.core.Property',
  methods: [
    function outputPropertyJSON2(x, obj, outputter, out) {
      if ( obj.hasDefaultValue(this.name) ) return;

      if ( this.transient ) return;

      if ( ! foam.util.flagFilter(x.flags)(this) ) return;

      out.key(this.name);

      outputter.output(x, this.f(obj), out);
    }
  ]
});

foam.CLASS({
  refines: 'foam.core.AxiomArray',
  methods: [
    function outputPropertyJSON2(x, obj, outputter, out) {
      if ( obj.hasDefaultValue(this.name) ) return;

      if ( this.transient ) return;

      var o = this.f(obj).filter(foam.util.flagFilter(x.flags));

      out.key(this.name);

      outputter.output(x, o, out);
    }
  ]
});
/**
 * @license
 * Copyright 2015 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

foam.CLASS({
  package: 'foam.util',
  name: 'Timer',
  swiftName: 'FoamTimer',

  documentation: 'Timer object. Useful for creating animations.',

  properties: [
    {
      class: 'Int',
      name: 'interval',
      help: 'Interval of time between updating time.',
      // units: 'ms',
      value: 10
    },
    {
      class: 'Int',
      name: 'i',
      value: 0
    },
    {
      class: 'Float',
      name: 'timeWarp',
      value: 1.0
    },
    {
      class: 'Int',
      name:  'duration',
      units: 'ms',
      value: -1
    },
    {
      class: 'Float',
      name: 'percent',
      value: 0
    },
    {
      class: 'Long',
      name:  'startTime',
      value: 0
    },
    {
      class: 'Long',
      name:  'time',
      help:  'The current time in milliseconds since epoch.',
      adapt: function(_, t) { return Math.ceil(t); },
      swiftAdapt: function() {/*
if let newValue = newValue as? Double {
  return Int(ceil(newValue))
}
return newValue as! Int
      */},
      value: 0
    },
    {
      class: 'Int',
      name:  'second',
      help:  'The second of the current minute.',
      value: 0
    },
    {
      class: 'Int',
      name:  'minute',
      help:  'The minute of the current hour.',
      value: 0
    },
    {
      class: 'Int',
      name:  'hour',
      help:  'The hour of the current day.',
      value: 0
    },
    {
      class: 'Boolean',
      name: 'isStarted',
      hidden: true
    },
    {
      class: 'Long',
      name: 'startTime_',
      hidden: true
    }
  ],

  methods: [
    {
      /**
         cycle(frequency)             - cycle between -1 and 1 frequency times a second
         cycle(frequency, amplitude)  - cycle between -amplitude and amplitude frequency times a second
         cycle(frequency, start, end) - cycle between start and end frequency times a second
      */
      name: 'cycle',
      swiftReturns: 'Float',
      args: [
        {
          name: 'frequency',
          swiftType: 'Float',
        },
        {
          name: 'a',
          swiftType: 'Float?',
        },
        {
          name: 'b',
          swiftType: 'Float?',
        },
      ],
      code: function(frequency, a, b) {
        var s = Math.sin(this.time/1000*frequency*Math.PI*2);
        if ( arguments.length === 1 ) return s;
        if ( arguments.length === 2 ) return s * a;
        return a + (1 + s) * (b-a)/2;
      },
      swiftCode: function() {/*
let s = sin(Float(time)/1000*frequency*Float.pi*2)
if a == nil { return s }
if b == nil { return s * a! }
return a! + (1 + s) * (b!-a!)/2;
      */},
    },
  ],

  actions: [
    {
      name:  'start',
      help:  'Start the timer.',
      isEnabled: function(isStarted) { return ! isStarted; },
      code:      function() { this.isStarted = true; this.tick(); },
      swiftCode: 'isStarted = true; tick()',
    },
    {
      name:  'step',
      help:  'Step the timer.',
      code: function() {
        this.i++;
        this.time  += this.interval * this.timeWarp;
        this.second = this.time /    1000 % 60 << 0;
        this.minute = this.time /   60000 % 60 << 0;
        this.hour   = this.time / 3600000 % 24 << 0;
      },
      swiftCode: function() {/*
i+=1
time  += Int(Float(interval) * timeWarp)
second = time /    1000 % 60 << 0;
minute = time /   60000 % 60 << 0;
hour   = time / 3600000 % 24 << 0;
      */}
    },
    {
      name:  'stop',
      help:  'Stop the timer.',
      isEnabled: function(isStarted) { return isStarted; },
      code:      function() { this.isStarted = false; },
      swiftCode: 'isStarted = false'
    }
  ],

  listeners: [
    {
      name: 'tick',
      isFramed: true,
      code: function() {
        if ( ! this.isStarted ) return;

        var prevTime = this.startTime_;
        this.startTime_ = Date.now();
        this.interval = Math.min(100, this.startTime_ - prevTime);
        this.step();
        this.tick();
      },
      swiftCode: function() {/*
if !isStarted { return }

let prevTime = startTime_
startTime_ = Int(Date().timeIntervalSince1970 * Double(1000))
interval = min(100, startTime_ - prevTime)
step()
tick()
      */}
    }
  ]
});
/**
 * @license
 * Copyright 2017 The FOAM Authors. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

foam.ENUM({
  package: 'foam.log',
  name: 'LogLevel',

  properties: [
    {
      class: 'String',
      name: 'shortName'
    },
    {
      class: 'String',
      name: 'consoleMethodName'
    }
  ],

  values: [
    {
      name: 'DEBUG',
      shortName: 'DEBG',
      label: 'Debug',
      consoleMethodName: 'debug'
    },
    {
      name: 'INFO',
      shortName: 'INFO',
      label: 'Info',
      consoleMethodName: 'info'
    },
    {
      name: 'WARN',
      shortName: 'WARN',
      label: 'Warn',
      consoleMethodName: 'warn'
    },
    {
      name: 'ERROR',
      shortName: 'ERRR',
      label: 'Error',
      consoleMethodName: 'error'
    }
  ]
});
/**
 * @license
 * Copyright 2017 The FOAM Authors. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

foam.INTERFACE({
  package: 'foam.log',
  name: 'Logger',

  methods: [
    { name: 'debug', documentation: 'Log at "debug" log level.' },
    { name: 'log',   documentation: 'Synonym for "info".'       },
    { name: 'info',  documentation: 'Log at "info" log level.'  },
    { name: 'warn',  documentation: 'Log at "warn" log level.'  },
    { name: 'error', documentation: 'Log at "error" log level.' }
  ],
});
/**
 * @license
 * Copyright 2017 The FOAM Authors. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

foam.CLASS({
  package: 'foam.log',
  name: 'ConsoleLogger',
  implements: [ 'foam.log.Logger' ],

  documentation: `Decorate contextual logging methods with log level (short
      name) and date string`,

  requires: [ 'foam.log.LogLevel' ],

  imports: [
    'debug as debug_',
    'log as log_',
    'info as info_',
    'warn as warn_',
    'error as error_'
  ],

  exports: [
    'debug',
    'log',
    'info',
    'warn',
    'error'
  ],

  properties: [
    {
      class: 'Function',
      name: 'debug',
      factory: function() { return this.put.bind(this, this.LogLevel.DEBUG); }
    },
    {
      class: 'Function',
      documentation: 'Synonym for "info".',
      name: 'log',
      factory: function() { return this.put.bind(this, this.LogLevel.INFO); }
    },
    {
      class: 'Function',
      name: 'info',
      factory: function() { return this.put.bind(this, this.LogLevel.INFO); }
    },
    {
      class: 'Function',
      name: 'warn',
      factory: function() { return this.put.bind(this, this.LogLevel.WARN); }
    },
    {
      class: 'Function',
      name: 'error',
      factory: function() { return this.put.bind(this, this.LogLevel.ERROR); }
    },
    {
      class: 'Function',
      name: 'getDateString',
      factory: function() {
        return function() { return (new Date()).toString(); };
      }
    }
  ],

  methods: [
    function put(logLevel) {
      var args = [ logLevel.shortName, '[' + this.getDateString() + ']' ]
          .concat(Array.from(arguments).slice(1));
      this[logLevel.consoleMethodName + '_'].apply(this, args);
    }
  ]
});
/**
 * @license
 * Copyright 2015 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

foam.CLASS({
  package: 'foam.memento',
  name: 'MementoMgr',

  documentation: 'Provide memento undo/redo support.',

  properties: [
    {
      name: 'memento'
    },
    {
      name: 'stack',
      factory: function() { return []; }
    },
    {
      name: 'redo',
      factory: function() { return []; }
    },
    'posFeedback_',
    {
      class: 'Int',
      name: 'position',
      postSet: function(_, n) {
        if ( this.posFeedback_ ) return;

        while ( n < this.stackSize_ ) this.back();
        while ( n > this.stackSize_ ) this.forth();
      }
    },
    'stackSize_',
    'redoSize_',
    'totalSize_'
  ],

  methods: [
    function init() {
      this.memento$.sub(this.onMementoChange);
    },

    function updateSizes() {
      this.posFeedback_  = true;
      this.stackSize_    = this.stack.length;
      this.redoSize_     = this.redo.length;
      this.totalSize_    = this.stack.length + this.redo.length;
      this.position      = this.stack.length;
      this.posFeedback_  = false;
    },

    function remember(memento) {
      this.dumpState('preRemember');
      this.stack.push(memento);
      this.updateSizes();
      this.dumpState('postRemember');
    },

    function restore(memento) {
      this.dumpState('preRestore');
      this.ignore_ = true;
      this.memento = memento;
      this.ignore_ = false;
      this.dumpState('postRestore');
    },

    function dumpState(spot) {
      // Uncomment for debugging
      /*
      console.log('--- ', spot);
      console.log('stack: ', JSON.stringify(this.stack));
      console.log('redo: ', JSON.stringify(this.redo));
      */
    }
  ],

  actions: [
    {
      name:  'back',
      label: ' <-- ',
      help:  'Go to previous view',

      isEnabled: function(stackSize_) { return !! stackSize_; },
      code: function() {
        this.dumpState('preBack');
        this.redo.push(this.memento);
        this.restore(this.stack.pop());
        this.updateSizes();
        this.dumpState('postBack');
      }
    },
    {
      name:  'forth',
      label: ' --> ',
      help:  'Undo the previous back.',

      isEnabled: function(redoSize_) { return !! redoSize_; },
      code: function() {
        this.dumpState('preForth');
        this.remember(this.memento);
        this.restore(this.redo.pop());
        this.updateSizes();
        this.dumpState('postForth');
      }
    }
  ],

  listeners: [
    function onMementoChange(_,__,___,memento$) {
      if ( this.ignore_ ) return;

      // console.log('MementoMgr.onChange', oldValue, newValue);
      this.remember(memento$.oldValue);
      this.redo = [];
      this.updateSizes();
    }
  ]
});
/**
 * @license
 * Copyright 2017 The FOAM Authors. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

foam.CLASS({
  package: 'foam.web',
  name: 'DetachedURLState',

  documentation: `foam.web.URLState that is detached from
      window.location.hash.`,

  requires: [
    'foam.json.Outputter',
    'foam.json.Parser'
  ],
  imports: [ 'warn', 'window' ],

  properties: [
    {
      name: 'serializer',
      documentation: 'Implementer of stringify(value) for value serialization.',
      factory: function() {
        return this.Outputter.create({
          pretty: false,
          formatDatesAsNumbers: true,
          outputDefaultValues: false,
          strict: true
        });
      }
    },
    {
      name: 'deserializer',
      documentation: `Implementer of parseString(str) for value
          deserialization.`,
      factory: function() {
        return this.Parser.create({
          strict: true,
          creationContext: this.__subContext__
        });
      }
    },
    {
      name: 'bindingsMap_',
      documentation: 'Map of {<key>: foam.core.Slot} comprising state.',
      factory: function() { return {}; }
    },
    {
      name: 'subMap_',
      documentation: `Map of {<key>: <event subscription>} parallel to
          bindingsMap_.`,
      factory: function() { return {}; }
    },
    {
      name: 'unboundMap_',
      documentation: `Map of {<key>: <deserialized value>} that contains
          bindings loaded from hash, but not bound to a foam.core.Slot.`,
      factory: function() { return {}; }
    },
    {
      class: 'String',
      name: 'path_',
      documentation: `"path" part of hash; hash is:
          "#<path>?<key1>=<value1>&<key2>=<value2>..."`,
      postSet: function(old, nu) {
        if ( old !== nu ) this.onStateChange();
      }
    },
    {
      class: 'String',
      name: 'hash_',
      documentation: 'Complete state serialized to a URL hash value.',
    },
  ],

  methods: [
    function init() {
      this.SUPER();
      this.hashToState_();
    },
    function getHash() { return this.hash_; },
    function setHash(hash) {
      this.hash_ = hash;
      this.hashToState_();
    },
    function getPath() { return this.path_; },
    function setPath(path) { return this.path_ = path; },
    function getSlot(name) {
      return this.bindingsMap_[name] || null;
    },
    function addBinding(name, slot) {
      if ( this.bindingsMap_.hasOwnProperty(name) ) {
        this.warn('Overwriting URLState:', name, this.bindingsMap_[name],
                  'with', slot);
        this.subMap_[name].detach();
      }
      if ( this.unboundMap_.hasOwnProperty(name) ) {
        slot.set(this.unboundMap_[name]);
        delete this.unboundMap_[name];
      }
      this.bindingsMap_[name] = slot;
      this.subMap_[name] = slot.sub(this.onStateChange);
      this.onStateChange();
    },
    function removeBinding(name) {
      if ( ! this.bindingsMap_.hasOwnProperty(name) ) return;
      this.subMap_[name].detach();
      delete this.subMap_[name];
      delete this.bindingsMap_[name];
      this.onStateChange();
    },
    function clearBindings() {
      var subMap = this.subMap_;
      for ( var key in subMap ) {
        if ( ! subMap.hasOwnProperty(key) ) continue;
        subMap[key].detach();
      }
      this.subMap_ = {};
      this.bindingsMap_ = {};
      this.unboundMap_ = {};
      this.onStateChange();
    },
    function stateToHash_() {
      var stateStr = '';
      stateStr = this.appendMapToStateStr_(
          stateStr, this.bindingsMap_, this.getBoundValue);
      stateStr = this.appendMapToStateStr_(
          stateStr, this.unboundMap_, this.getUnboundValue);

      this.hash_ = '#' + this.path_ + '?' + stateStr;
    },
    function appendMapToStateStr_(str, map, getMapValue) {
      for ( var key in map ) {
        if ( ! map.hasOwnProperty(key) ) continue;

        if ( str !== '' ) str += '&';

        var value = this.serializer.stringify(getMapValue(key));
        str += this.window.encodeURIComponent(key) + '=' +
            this.window.encodeURIComponent(value);
      }
      return str;
    },
    function hashToState_() {
      var hash = this.hash_;
      var res = this.hashGrammar.parseString(hash, 'hash');
      foam.assert(res, 'Invalid URLState hash: ' + hash);

      this.path_ = this.window.decodeURIComponent(res.path);
      var bindingsMap = this.bindingsMap_;
      var bindings = res.bindings;
      for ( var i = 0; i < bindings.length; i++ ) {
        var binding = bindings[i];
        var key = this.window.decodeURIComponent(binding.key);
        var value = this.deserializer.parseString(
            this.window.decodeURIComponent(binding.value));
        if ( bindingsMap.hasOwnProperty(key) ) {
          if ( ! foam.util.equals(bindingsMap[key].get(), value) )
            bindingsMap[key].set(value);
        } else {
          this.unboundMap_[key] = value;
        }
      }
    }
  ],

  listeners: [
    function onStateChange() { this.stateToHash_(); },
    function getBoundValue(key) {
      return this.bindingsMap_[key] && this.bindingsMap_[key].get();
    },
    function getUnboundValue(key) { return this.unboundMap_[key]; }
  ],

  grammars: [
    {
      name: 'hashGrammar',
      language: 'foam.parse.json.Parsers',
      symbols: function() {
        return {
          hash: optional(
              seq('#', optional(sym('path')),
                  optional(seq1(1, '?', repeat(sym('binding'), '&'))))),
          path: str(repeat(notChars('?'))),
          binding: seq(sym('key'), optional(seq1(1, '=', sym('value')))),
          key: str(plus(notChars('=&'))),
          value: str(plus(notChars('=&')))
        };
      },
      actions: [
        function binding(v) { return { key: v[0], value: v[1] }; },
        function hash(v) {
          return { path: v && v[1] || '' , bindings: v && v[2] || [] };
        }
      ]
    }
  ]
});
/**
 * @license
 * Copyright 2017 The FOAM Authors. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

foam.CLASS({
  package: 'foam.web',
  name: 'URLState',
  extends: 'foam.web.DetachedURLState',

  documentation: `A URL-based strategy for storing application state in the URL
      hash. Produces hashes of the form:

      #<path>?<key1>=<value1>&<key2>=<value2>...

      All parts are URI-encoded. The "path" is intended as a top-level
      description what view/controller the application is rendering. Keys and
      values additional state bindings to be reflected in the URL hash.`,

  requires: [
    'foam.json.Outputter',
    'foam.json.Parser'
  ],
  imports: [ 'warn', 'window' ],

  methods: [
    function init() {
      this.SUPER();
      this.setHash(this.window.location.hash);
      this.window.addEventListener('hashchange', this.onHashChange);
    },
  ],

  listeners: [
    function onHashChange() {
      this.setHash(this.window.location.hash);
      this.hashToState_();
    },
    {
      name: 'onStateChange',
      isMerged: true,
      mergeDelay: 150,
      code: function() {
        this.stateToHash_();
        this.window.location.hash = this.hash_;
      }
    }
  ]
});
/**
 * @license
 * Copyright 2016 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

foam.CLASS({
  package: 'foam.input',
  name: 'TouchEvent',

  properties: [
    {
      class: 'Float',
      name: 'x'
    },
    {
      class: 'Float',
      name: 'y'
    },
    {
      class: 'Boolean',
      name: 'claimed',
      value: false
    }
  ]
});


foam.CLASS({
  package: 'foam.input',
  name: 'Mouse',

  topics: [
    'down',
    'move',
    'touch',
    'up'
  ],

  properties: [
    'lastTouch',
    'x',
    'y',
    {
      name: 'element',
      postSet: function(old, e) {
        if ( old ) {
          old.removeEventListener('mousedown', this.onMouseDown);
          old.removeEventListener('mouseup',   this.onMouseUp);
          old.removeEventListener('mousemove', this.onMouseMove);
        }
        e.addEventListener('mousedown', this.onMouseDown);
        e.addEventListener('mouseup',   this.onMouseUp);
        e.addEventListener('mousemove', this.onMouseMove);
      }
    }
  ],

  methods: [
    function install(element) {
      this.ref = element;
    }
  ],

  listeners: [
    {
      name: 'onMouseDown',
      code: function(e) {
        var bounds = this.element.getBoundingClientRect();

        this.x = e.clientX - bounds.left;
        this.y = e.clientY - bounds.top;

        this.down.pub();

        if ( this.touch.hasListeners() ) {
          if ( this.lastTouch ) this.lastTouch.detach();

          this.lastTouch = foam.input.TouchEvent.create();
          this.lastTouch.onDetach(this.lastTouch.x$.follow(this.x$));
          this.lastTouch.onDetach(this.lastTouch.y$.follow(this.y$));

          this.touch.pub(this.lastTouch);

          if ( this.lastTouch && this.lastTouch.claimed ) e.preventDefault();
        }

        // While the mouse is down, track the movements and mouseup on the
        // entire window so it's tracked if/when the mouse leaves the element.
        window.addEventListener('mouseup',   this.onMouseUp);
        window.addEventListener('mousemove', this.onMouseMove);
      }
    },
    {
      name: 'onMouseUp',
      code: function(e) {
        this.up.pub();

        if ( this.lastTouch ) {
          this.lastTouch.detach();
          this.lastTouch = undefined;
        }

        window.removeEventListener('mouseup',   this.onMouseUp);
        window.removeEventListener('mousemove', this.onMouseMove);
      }
    },
    {
      name: 'onMouseMove',
      code: function(e) {
        if ( this.lastTouch ||
             this.hasListeners('propertyChange') ||
             this.move.hasListeners() ) {

          var bounds = this.element.getBoundingClientRect();

          this.x = e.clientX - bounds.left;
          this.y = e.clientY - bounds.top;

          this.move.pub();

          if ( this.lastTouch && this.lastTouch.claimed ) e.preventDefault();
        }
      }
    }
  ]
});


foam.CLASS({
  package: 'foam.input',
  name: 'Touch',

  topics: [
    'touch'
  ],

  properties: [
    {
      name: 'touches',
      factory: function() { return {}; }
    },
    {
      name: 'element',
      postSet: function(old, e) {
        if ( old ) {
          old.removeEventListener('touchstart', this.onTouchStart);
          old.removeEventListener('touchmove',  this.onTouchMove);
          old.removeEventListener('touchend',   this.onTouchEnd);
        }
        e.addEventListener('touchstart', this.onTouchStart);
        e.addEventListener('touchmove',  this.onTouchMove);
        e.addEventListener('touchend',   this.onTouchEnd);
      }
    }
  ],

  listeners: [
    function onTouchStart(e) {
      var newTouches = e.changedTouches;
      var bounds     = this.element.getBoundingClientRect();

      for ( var i = 0 ; i < newTouches.length ; i++ ) {
        var touch = newTouches.item(i);

        var touchEvent = foam.input.TouchEvent.create({
          x: touch.clientX - bounds.left,
          y: touch.clientY - bounds.top
        });

        this.touch.pub(touchEvent);
        if ( touchEvent.claimed ) e.preventDefault();

        this.touches[touch.identifier] = touchEvent;
      }
    },

    function onTouchMove(e) {
      var changed = e.changedTouches;
      var bounds  = this.element.getBoundingClientRect();

      for ( var i = 0 ; i < changed.length ; i++ ) {
        var touch = changed.item(i);

        var event = this.touches[touch.identifier];
        event.x = touch.clientX - bounds.left;
        event.y = touch.clientY - bounds.top;
        if ( event.claimed ) e.preventDefault();
      }
    },

    function onTouchEnd(e) {
      var changed = e.changedTouches;
      for ( var i = 0 ; i < changed.length ; i++ ) {
        var touch = changed.item(i);

        this.touches[touch.identifier].detach();
        delete this.touches[touch.identifier];
      }
    }
  ]
});


foam.CLASS({
  package: 'foam.input',
  name: 'Pointer',

  requires: [
    'foam.input.Mouse',
    'foam.input.Touch'
  ],

  topics: [
    'touch'
  ],

  properties: [
    {
      name: 'element',
      required: true
    },
    {
      name: 'mouseInput',
      factory: function() {
        var m = this.Mouse.create();
        this.onDetach(m.element$.follow(this.element$));
        this.onDetach(m.touch.sub(this.onTouch));
        return m;
      }
    },
    {
      name: 'touchInput',
      factory: function() {
        var t = this.Touch.create();
        this.onDetach(t.element$.follow(this.element$));
        this.onDetach(t.touch.sub(this.onTouch));
        return t;
      }
    }
  ],

  methods: [
    function init() {
      // Assigning to unused variables to make Closure happy.
      var mi = this.mouseInput;
      var ti = this.touchInput;
    }
  ],

  listeners: [
    function onTouch(e, _, t) {
      this.touch.pub(t);
    }
  ]
});

foam.CLASS({
  package: 'foam.nanos.controller',
  name: 'AppStyles',
  extends: 'foam.u2.View',

  documentation: 'Generic CSS that can be included into the top level controller of foam app. Implement to foam class to use.',

  css: `
    body {
      font-family: 'Roboto', sans-serif;
      font-size: 14px;
      letter-spacing: 0.2px;
      color: #373a3c;
      background: #edf0f5;
      margin: 0;
    }
    table {
      border-collapse: collapse;
      margin: auto;
      width: 962px;
    }
    thead > tr > th {
      font-family: 'Roboto';
      font-size: 14px;
      background-color: rgba(110, 174, 195, 0.2);
      color: #093649;
      line-height: 1.14;
      letter-spacing: 0.3px;
      border-spacing: 0;
      text-align: left;
      padding-left: 15px;
      height: 40px;
    }
    tbody > tr > th > td {
      font-size: 12px;
      letter-spacing: 0.2px;
      text-align: left;
      color: #093649;
      padding-left: 15px;
      height: 60px;
    }
    .foam-u2-view-TableView th {
      font-family: 'Roboto';
      padding-left: 15px;
      font-size: 14px;
      line-height: 1;
      letter-spacing: 0.4px;
      color: #093649;
    }
    .foam-u2-view-TableView td {
      font-family: Roboto;
      font-size: 12px;
      line-height: 1.33;
      letter-spacing: 0.2px;
      padding-left: 15px;
      font-size: 12px;
      color: #093649;
    }
    .foam-u2-view-TableView tbody > tr {
      height: 60px;
      background: white;
    }
    .foam-u2-view-TableView tbody > tr:nth-child(odd) {
      background: #f6f9f9;
    }
  `
});foam.CLASS({
  package: 'foam.u2',
  name: 'ModalHeader',
  extends: 'foam.u2.View',

  documentation: 'Modal Container close/title use in modal class to append title & close buttons.',

  imports: [
    'stack',
    'closeDialog'
  ],

  properties: [
    'title'
  ],

  css: `
    ^{
      width: 448px;
      margin: auto;
    }
    ^ .container{
      height: 40.8px;
      background-color: #093649;
      margin-bottom: 20px;
    }
    ^ .title{
      height: 40px;
      font-family: Roboto;
      font-size: 14px;
      line-height: 2.86;
      text-align: left;
      color: #ffffff;
      margin-left: 19px;
      display: inline-block;
    }
    ^ .close{
      width: 24px;
      height: 24px;
      margin-top: 5px;
      cursor: pointer;
      position: relative;
      top: 4px;
      right: 20px;
      float: right;
    }
    ^ .foam-u2-ActionView-closeModal{
      position: relative;
      right: 0px;
      width: 50px;
      height: 40px;
      background: transparent;
      margin-top: 0;
      top: 0;
      right: 0;
      border: none;
    }
  `,

  methods: [
    function initE(){
    this.SUPER();
    var self = this;

    this
    .addClass(this.myClass())
      .start()
        .start()
          .start().addClass('container')
            .start().addClass('title').add(this.title).end()
            .start(this.CLOSE_MODAL).addClass('close').end()
          .end()
        .end()
      .end()
    }
  ],

  actions: [
    {
      name: 'closeModal',
      icon: 'ic-cancelwhite.svg',
      code: function(X){
        X.closeDialog()
      }
    }
  ]
});/**
 * @license
 * Copyright 2015 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

foam.CLASS({
  package: 'foam.u2',
  name: 'AttrSlot',
  implements: [ 'foam.core.Slot' ],

  documentation: 'A Value bound to an Element attribute. Used to bind values to DOM.',

  properties: [
    {
      name: 'element',
      required: true
    },
    'value',
    [ 'property', 'value'  ],
    [ 'event',    'change' ]
  ],

  methods: [
    function get() {
      return this.element.getAttribute(this.property);
    },

    function set(value) {
      this.element.setAttribute(this.property, value);

      // The next line is necessary to fire a change event.
      // This is necessary because DOM isn't proper MVC and
      // doesn't fire a change event when the value is explicitly set.
      this.value = value;
    },

    function sub(l) {
      // TODO: remove listener on unsubscribe. But how?
      if ( ! this.hasListeners() ) {
        var self = this;
        this.element.on(this.event, function() {
          self.value = self.get();
        });
      }
      return this.SUPER('propertyChange', 'value', l);
    },

    function toString() {
      return 'AttrSlot(' + this.event + ', ' + this.property + ')';
    }
  ]
});
/**
 * @license
 * Copyright 2016 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

foam.CLASS({
  package: 'foam.u2',
  name: 'ViewSpec',
  extends: 'foam.core.Property',

  documentation: 'Set a ViewFactory to be a string containing a class name, ' +
      'a Class object, or a factory function(args, context). ' +
      'Useful for rowViews and similar.',

  axioms: [
    {
      installInClass: function(cls) {
        cls.createView = function(spec, args, self, ctx) {
          if ( foam.u2.Element.isInstance(spec) )
            return spec.copyFrom(args);

          if ( foam.core.Slot.isInstance(spec) )
            return spec;

          if ( spec && spec.toE )
            return spec.toE(args, ctx);

          if ( foam.Function.isInstance(spec) )
            return foam.u2.ViewSpec.createView(spec.call(self, args, ctx), args, self, ctx);

          if ( foam.Object.isInstance(spec) ) {
            var ret = spec.create ?
                spec.create(args, ctx) :
                ctx.lookup(spec.class).create(spec, ctx).copyFrom(args || {});

            foam.assert(
                foam.u2.Element.isInstance(ret) || ret.toE,
                'ViewSpec result must extend foam.u2.Element or be toE()-able.');

            return ret;
          }

          if ( foam.core.FObject.isSubClass(spec) ) {
            var ret = spec.create(args, ctx);

            foam.assert(foam.u2.Element.isInstance(ret), 'ViewSpec class must extend foam.u2.Element or be toE()-able.');

            return ret;
          }

          if ( foam.String.isInstance(spec) || spec === undefined || spec === null )
            return foam.u2.Element.create({ nodeName: spec || 'div' }, ctx);

          throw 'Invalid ViewSpec, must provide an Element, Slot, toE()-able, Function, {create: function() {}}, {class: \'name\'}, Class, or String, but received: ' + spec;
        };
      }
    }
  ],

  properties: [
    /* TODO: uncomment this to fix ViewSpecs converting into Views when loading.
    [
      'fromJSON',
      function fromJSON(value, ctx, prop, json) {
        return value;
      }
    ],
    */
    [ 'adapt', function(_, spec, prop) {
      return foam.String.isInstance(spec) ? { class: spec } : spec ;
    } ]
    /*
    [ 'toJSON', function(value) {
      Output as string if 'class' is only defined value.
    } ]
    */
  ]
});
/**
 * @license
 * Copyright 2017 The FOAM Authors. All Rights Reserved.
 * http://www.apache.org/licenses/LICENSE-2.0
 */

foam.ENUM({
  package: 'foam.u2',
  name: 'Visibility',

  documentation: 'View visibility mode combines with current ControllerModel to determine DisplayMode.',

  values: [
    { name: 'RW',       label: 'Read-Write' },
    { name: 'FINAL',    label: 'Final',     documentation: 'FINAL views are editable only in CREATE ControllerMode.' },
    { name: 'DISABLED', label: 'Disabled',  documentation: 'DISABLED views are visible but not editable.' },
    { name: 'RO',       label: 'Read-Only'  },
    { name: 'HIDDEN',   label: 'Hidden'     }
  ]
});/**
 * @license
 * Copyright 2017 The FOAM Authors. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

foam.CLASS({
  refines: 'foam.core.Method',
  properties: [ 'swiftReturns', 'swiftCode', 'swiftSynchronized' ]
});
foam.CLASS({
  refines: 'foam.core.internal.InterfaceMethod',
  properties: [ 'swiftReturns', 'swiftThrows', 'swiftSupport' ]
});
foam.CLASS({
  refines: 'foam.core.Property',
  properties: [ 'swiftType', 'swiftExpression', 'swiftExpressionArgs', 'swiftPostSet', 'swiftFactory', 'swiftRequiresEscaping', 'swiftGetter' ]
});
foam.CLASS({
  refines: 'foam.core.Argument',
  properties: [ 'swiftType', 'swiftDefaultValue' ]
});
foam.CLASS({
  refines: 'foam.core.InterfaceModel',
  properties: [ 'swiftName', 'swiftImplements' ]
});
foam.CLASS({
  refines: 'foam.core.Model',
  properties: [ 'swiftName', 'generateSwift' ]
});
foam.CLASS({
  refines: 'foam.core.FObjectProperty',
  properties: [ 'swiftFactory', 'swiftPostSet' ]
});
foam.CLASS({
  refines: 'foam.core.String',
  properties: [ 'swiftFactory' ]
});
foam.CLASS({
  refines: 'foam.core.Constant',
  properties: [ 'type', 'swiftValue', 'swiftType' ]
});
foam.CLASS({
  refines: 'foam.core.Listener',
  properties: [ 'swiftCode' ]
});
foam.CLASS({
  refines: 'foam.core.ContextMethod',
  properties: [ 'swiftThrows' ]
});
/**
 * @license
 * Copyright 2017 The FOAM Authors. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

foam.INTERFACE({
  package: 'foam.u2',
  name: 'RowFormatter',

  documentation: 'Base class for markup-generating row formatters.',

  methods: [
    function format(data, opt_columns) {}
  ]
});
/**
 * @license
 * Copyright 2017 The FOAM Authors. All Rights Reserved.
 * http://www.apache.org/licenses/LICENSE-2.0
 */

// WeakMap Polyfill, doesn't implement the full interface, just the parts
// that FOAM uses. Only used in Element.js, which is why it's in the u2 package
// rather than in core with other polyfils.
if ( ! global.WeakMap ) {
  Object.defineProperty(window, 'WeakMap', {
    configurable: true,
    writable: true,
    value: function WeakMap() {
      var id = '__WEAK_MAP__' + this.$UID;

      function del(key) { delete key[id]; }
      function get(key) { return key[id]; }
      function set(key, value) { key[id] = value; }
      function has(key) { return !!key[id]; }

      return {
        __proto__: this,
        "delete": del,
        get: get,
        set: set,
        has: has
      };
    }
  });
}
/**
 * @license
 * Copyright 2017 The FOAM Authors. All Rights Reserved.
 * http://www.apache.org/licenses/LICENSE-2.0
 */

/*
TODO:
 - Remove use of E() and replace with create-ing axiom to add same behaviour.
 - create 'inner' element which defaults to this. add() adds to inner to make
   creating borders simple
 - start('leftPanel') should work for locating pre-existing named spaces
 - start, tag, and add() should use standard helper method
 - Fix handling of Slots that return arrays.
 - Properly handle insertBefore_ of an element that's already been inserted?
*/

foam.ENUM({
  package: 'foam.u2',
  name: 'ControllerMode',

  documentation: 'CRUD controller modes: CREATE/VIEW/EDIT.',

  values: [
    { name: 'CREATE', label: 'Create' },
    { name: 'VIEW',   label: 'View'   },
    { name: 'EDIT',   label: 'Edit'   }
  ]
});

foam.ENUM({
  package: 'foam.u2',
  name: 'DisplayMode',

  documentation: 'View display mode; how or if a view is displayed.',

  values: [
    { name: 'RW',       label: 'Read-Write' },
    { name: 'DISABLED', label: 'Disabled'   },
    { name: 'RO',       label: 'Read-Only'  },
    { name: 'HIDDEN',   label: 'Hidden'     }
  ]
});


foam.CLASS({
  package: 'foam.u2',
  name: 'Entity',

  documentation: `
    Virtual-DOM Entity.
    // TODO: Make both Entity and Element extend a common base-Model (Node?)
  `,

  properties: [
    {
      name: 'name',
      documentation: `
        // parser: seq(alphaChar, repeat0(wordChar)),
        // TODO(adamvy): This should be 'pattern' or 'regex', if those are ever
        // added.
      `,
      assertValue: function(nu) {
        if ( ! nu.match(/^[a-z#]\w*$/i) ) {
          throw new Error('Invalid Entity name: ' + nu);
        }
      }
    }
  ],

  methods: [
    function output(out) { out('&', this.name, ';'); },
    function toE() { return this; }
  ]
});


foam.CLASS({
  package: 'foam.u2',
  name: 'CSS',

  documentation: 'Axiom to install CSS.',

  properties: [
    {
      class: 'String',
      name: 'code'
    },
    {
      name: 'name',
      factory: function() { return 'CSS-' + this.$UID; }
    },
    {
      name: 'installedDocuments_',
      factory: function() { return new WeakMap(); },
      transient: true
    }
  ],

  methods: [
    function installInClass(cls) {
      // Install myself in this Window, if not already there.
      var oldCreate = cls.create;
      var axiom     = this;

      cls.create = function(args, opt_parent) {
        // TODO: move this functionality somewhere reusable
        var X = opt_parent ?
          ( opt_parent.__subContext__ || opt_parent.__context__ || opt_parent ) :
          foam.__context__;

        // Install our own CSS, and then all parent models as well.
        if ( X.document && ! axiom.installedDocuments_.has(X.document) ) {
          X.installCSS(axiom.expandCSS(this, axiom.code), cls.id);
          axiom.installedDocuments_.set(X.document, true);
        }

        // Now call through to the original create.
        return oldCreate.call(this, args, X);
      };
    },

    function expandCSS(cls, text) {
      /* Performs expansion of the ^ shorthand on the CSS. */
      // TODO(braden): Parse and validate the CSS.
      // TODO(braden): Add the automatic prefixing once we have the parser.
      var base = '.' + foam.String.cssClassize(cls.id);
      return text.replace(/\^(.)/g, function(match, next) {
        var c = next.charCodeAt(0);
        // Check if the next character is an uppercase or lowercase letter,
        // number, - or _. If so, add a - because this is a modified string.
        // If not, there's no extra -.
        if ( (65 <= c && c <= 90) || (97 <= c && c <= 122) ||
            (48 <= c && c <= 57) || c === 45 || c === 95 ) {
          return base + '-' + next;
        }

        return base + next;
      });
    }
  ]
});


foam.CLASS({
  package: 'foam.u2',
  name: 'DefaultValidator',

  documentation: 'Default Element validator.',

  axioms: [ foam.pattern.Singleton.create() ],

  methods: [
    function validateNodeName(name) {
      return true;
    },

    function validateClass(cls) {
      // TODO
    },

    function validateAttributeName(name) {
      // TODO
    },

    function validateAttributeValue(value) {
      // TODO
    },

    function validateStyleName(name) {
      // TODO
    },

    function validateStyleValue(value) {
      // TODO
    },

    function sanitizeText(text) {
      if ( ! text ) return text;
      text = text.toString();
      return text.replace(/[&<"']/g, function(m) {
        switch ( m ) {
          case '&': return '&amp;';
          case '<': return '&lt;';
          case '"': return '&quot;';
          case "'": return '&#039';
        }
      });
    }
  ]
});


foam.CLASS({
  package: 'foam.u2',
  name: 'ElementState',

  documentation: `
    Current lifecycle state of an Element.
    // TODO: Do we want the following method?
    // function detach() {},
  `,

  methods: [
    function output(out) {},
    function load() {},
    function unload() {},
    function onRemove() {},
    function onSetClass() {},
    function onFocus() {},
    function onAddListener() {},
    function onRemoveListener() {},
    function onSetStyle() {},
    function onSetAttr() {},
    function onRemoveAttr() {},
    function onAddChildren() {},
    function onInsertChildren() {},
    function onReplaceChild() {},
    function onRemoveChild() {},
    function getBoundingClientRect() {
      return {
        left: 0,
        right: 0,
        bottom: 0,
        top: 0,
        width: 0,
        height: 0
      };
    }
  ]
});


foam.CLASS({
  package: 'foam.u2',
  name: 'UnloadedElementState',
  extends: 'foam.u2.ElementState',

  documentation: 'State of an unloaded Element.',

  methods: [
    function output(out) {
      this.state = this.OUTPUT;
      this.output_(out);
      return out;
    },
    function load() {
      this.error('Must output before loading.');
    },
    function unload() {
      this.error('Must output and load before unloading.');
    },
    function toString() { return 'UNLOADED'; }
  ]
});


foam.CLASS({
  package: 'foam.u2',
  name: 'InitialElementState',
  extends: 'foam.u2.UnloadedElementState',

  documentation: 'Initial state of a newly created Element.',

  methods: [
    function output(out) {
      this.initE();
      return this.SUPER(out);
    },
    function toString() { return 'INITIAL'; }
  ]
});


foam.CLASS({
  package: 'foam.u2',
  name: 'OutputElementState',
  extends: 'foam.u2.ElementState',

  documentation: 'State of Element after it has been output to DOM, but not yet loaded.',

  methods: [
    function output(out) {
      // TODO: raise a real error
      this.warn('ERROR: Duplicate output.');
      return this.UNLOADED.output.call(this, out);
    },
    function load() {
      if ( this.hasOwnProperty('elListeners') ) {
        var ls = this.elListeners;
        for ( var i = 0 ; i < ls.length ; i+=2 ) {
          this.addEventListener_(ls[i], ls[i+1]);
        }
      }

      this.visitChildren('load');
      this.state = this.LOADED;
      if ( this.tabIndex ) this.setAttribute('tabindex', this.tabIndex);
      if ( this.focused ) this.el().focus();
      // Allows you to take the DOM element and map it back to a
      // foam.u2.Element object.  This is expensive when building
      // lots of DOM since it adds an extra DOM call per Element.
      // But you could use it to cut down on the number of listeners
      // in something like a table view by doing per table listeners
      // rather than per-row listeners and in the event finding the right
      // U2 view by walking the DOM tree and checking e_.
      // This could save more time than the work spent here adding e_ to each
      // DOM element.
      // this.el().e_ = this;
    },
    function unload() {
      this.state = this.UNLOADED;
      this.visitChildren('unload');
    },
    function error() {
      throw new Error('Mutations not allowed in OUTPUT state.');
    },
    function onSetClass(cls, enabled) { this.error(); },
    function onFocus(cls, enabled) { this.error(); },
    function onAddListener(topic, listener) { this.error(); },
    function onRemoveListener(topic, listener) { this.error(); },
    function onSetStyle(key, value) { this.error(); },
    function onSetAttr(key, value) { this.error(); },
    function onRemoveAttr(key) { this.error(); },
    function onAddChildren(c) { this.error(); },
    function onInsertChildren() { this.error(); },
    function onReplaceChild() { this.error(); },
    function onRemoveChild() { this.error(); },
    function toString() { return 'OUTPUT'; }
  ]
});


foam.CLASS({
  package: 'foam.u2',
  name: 'LoadedElementState',
  extends: 'foam.u2.ElementState',

  documentation: 'State of an Element after it has been output to the DOM and loaded.',

  methods: [
    function output(out) {
      this.warn('Duplicate output.');
      return this.UNLOADED.output.call(this, out);
    },
    function load() { this.error('Duplicate load.'); },
    function unload() {
      if ( ! this.parentNode || this.parentNode.state === this.LOADED ) {
        var e = this.el();
        if ( e ) e.remove();
      }

      this.state = this.UNLOADED;
      this.visitChildren('unload');
    },
    function onRemove() { this.unload(); },
    function onSetClass(cls, enabled) {
      var e = this.el();
      if ( e ) {
        e.classList[enabled ? 'add' : 'remove'](cls);
      } else {
        this.warn('Missing Element: ', this.id);
      }
    },
    function onFocus() {
      this.el().focus();
    },
    function onAddListener(topic, listener) {
      this.addEventListener_(topic, listener);
    },
    function onRemoveListener(topic, listener) {
      this.addRemoveListener_(topic, listener);
    },
    function onSetStyle(key, value) {
      this.el().style[key] = value;
    },
    function onSetAttr(key, value) {
      if ( this.PSEDO_ATTRIBUTES[key] ) {
        this.el()[key] = value;
      } else {
        this.el().setAttribute(key, value === true ? '' : value);
      }
    },
    function onRemoveAttr(key) {
      if ( this.PSEDO_ATTRIBUTES[key] ) {
        this.el()[key] = '';
      } else {
        this.el().removeAttribute(key);
      }
    },
    function onAddChildren() {
      var e = this.el();
      if ( ! e ) {
        this.warn('Missing Element: ', this.id);
        return;
      }
      var out = this.createOutputStream();
      for ( var i = 0 ; i < arguments.length ; i++ ) {
        out(arguments[i]);
      }
      e.insertAdjacentHTML('beforeend', out);
      for ( var i = 0 ; i < arguments.length ; i++ ) {
        arguments[i].load && arguments[i].load();
      }
    },
    function onInsertChildren(children, reference, where) {
      var e = this.el();
      if ( ! e ) {
        this.warn('Missing Element: ', this.id);
        return;
      }
      var out = this.createOutputStream();
      for ( var i = 0 ; i < children.length ; i++ ) {
        out(children[i]);
      }

      reference.el().insertAdjacentHTML(where, out);

      // EXPERIMENTAL:
      // TODO(kgr): This causes some elements to get stuck in OUTPUT state
      // forever. It can be resurrected if that problem is fixed.
      // Load (mostly adding listeners) on the next frame
      // to allow the HTML to be shown more quickly.
      // this.__context__.window.setTimeout(function() {
      for ( var i = 0 ; i < children.length ; i++ ) {
        children[i].load && children[i].load();
      }
      // }, 33);
    },
    function onReplaceChild(oldE, newE) {
      var e = this.el();
      if ( ! e ) {
        this.warn('Missing Element: ', this.id);
        return;
      }
      var out = this.createOutputStream();
      out(newE);
      oldE.el().outerHTML = out.toString();
      newE.load && newE.load();
    },
    function onRemoveChild(child, index) {
      if ( typeof child === 'string' ) {
        this.el().childNodes[index].remove();
      } else {
        child.remove();
      }
    },
    function getBoundingClientRect() {
      return this.el().getBoundingClientRect();
    },
    function toString() { return 'LOADED'; }
  ]
});


foam.CLASS({
  package: 'foam.u2',
  name: 'RenderSink',
  implements: [ 'foam.dao.Sink' ],
  axioms: [
    {
      class: 'foam.box.Remote',
      clientClass: 'foam.dao.ClientSink'
    }
  ],
  properties: [
    {
      class: 'Function',
      name: 'addRow'
    },
    {
      class: 'Function',
      name: 'cleanup'
    },
    'dao',
    {
      class: 'Int',
      name: 'batch'
    }
  ],
  methods: [
    function put(obj, s) {
      this.reset();
    },
    function remove(obj, s) {
      this.reset();
    },
    function reset() {
      this.paint();
    }
  ],
  listeners: [
    {
      name: 'paint',
      isMerged: 100,
      code: function() {
        var batch = ++this.batch;
        var self = this;
        this.dao.select().then(function(a) {
          // Check if this is a stale render
          if ( self.batch !== batch ) return;

          var objs = a.array;
          self.cleanup();
          for ( var i = 0 ; i < objs.length ; i++ ) {
            self.addRow(objs[i]);
          }
        });
      }
    }
  ]
});

foam.CLASS({
  package: 'foam.u2',
  name: 'Element',

  documentation: `
    Virtual-DOM Element. Root model for all U2 UI components.

    To insert a U2 Element into a regular DOM element, either:

    el.innerHTML = view.outerHTML;
    view.load();

    Or use a foam tag in your markup:

    <foam class="com.acme.mypackage.MyView"></foam>

    // TODO: Decide if we want this or not:
    // function XXXE(opt_nodeName /* | DIV */) {
    //   /* Create a new Element */
    //   var Y = this.__subContext__;
    //
    //   // ???: Is this needed / a good idea?
    //   if ( this.data && ! Y.data ) Y = Y.createSubContext({ data: this.data });
    //
    //   // Some names have sub-Models registered for them.
    //   // Example 'input'
    //   var e = Y.elementForName(opt_nodeName);
    //
    //   if ( ! e ) {
    //     e = foam.u2.Element.create(null, Y);
    //     if ( opt_nodeName ) e.nodeName = opt_nodeName;
    //   }
    //
    //   return e;
    // },
  `,

  requires: [
    'foam.u2.AttrSlot',
    'foam.u2.DefaultValidator',
    'foam.u2.Entity',
    'foam.u2.ViewSpec'
  ],

  imports: [
    'document',
    'elementValidator',
    'framed',
    'getElementById'
  ],

  topics: [
    'onload',
    'onunload'
  ],

  constants: [
    {
      documentation: `
        Psedo-attributes don't work consistently with setAttribute() so need to
        be set on the real DOM element directly.
      `,
      name: 'PSEDO_ATTRIBUTES',
      value: {
        value: true,
        checked: true
      },
    },

    {
      name: 'DEFAULT_VALIDATOR',
      factory: function() { return foam.u2.DefaultValidator.create() },
    },

    {
      documentation: `
        State of an Element after it has been output (to a String) but before it
        is loaded. This should be only a brief transitory state, as the Element
        should be loaded almost immediately after being output. It is an error
        to try and mutate the Element while in the OUTPUT state.
      `,
      name: 'OUTPUT',
      factory: function() { return foam.u2.OutputElementState.create() },
    },

    {
      documentation: `
        State of an Element after it has been loaded.
        A Loaded Element should be visible in the DOM.
      `,
      name: 'LOADED',
      factory: function() { return foam.u2.LoadedElementState.create() },
    },

    {
      documentation: `
        State of an Element after it has been removed from the DOM.
        An unloaded Element can be readded to the DOM.
      `,
      name: 'UNLOADED',
      factory: function() { return foam.u2.UnloadedElementState.create() },
    },

    {
      documentation: `
        Initial state of an Element before it has been added to the DOM.
      `,
      name: 'INITIAL',
      factory: function() {
        return foam.u2.InitialElementState.create();
      },
    },

    // ???: Add DESTROYED State?

    {
      documentation: `TODO: Don't allow these as they lead to ambiguous markup.`,
      name: 'OPTIONAL_CLOSE_TAGS',
      value: {
        BODY: true,
        COLGROUP: true,
        DD: true,
        DT: true,
        HEAD: true,
        HTML: true,
        LI: true,
        OPTION: true,
        P: true,
        TBODY: true,
        TD: true,
        TFOOT: true,
        TH: true,
        THEAD: true,
        TR: true
      }
    },

    {
      documentation: `
        Element nodeName's that are self-closing.
        Used to generate valid HTML output.
        Used by ElementParser for valid HTML parsing.
      `,
      name: 'ILLEGAL_CLOSE_TAGS',
      value: {
        AREA: true,
        BASE: true,
        BASEFONT: true,
        BR: true,
        COL: true,
        FRAME: true,
        HR: true,
        IMG: true,
        INPUT: true,
        ISINDEX: true,
        LINK: true,
        META: true,
        PARAM: true
      },
    },

    {
      name: '__ID__',
      value: [ 0 ],
    },

    {
      name: 'NEXT_ID',
      value: function() {
        return 'v' + this.__ID__[ 0 ]++;
      },
    },

    {
      documentation: `Keys which respond to keydown but not keypress`,
      name: 'KEYPRESS_CODES',
      value: { 8: true, 13: true, 27: true, 33: true, 34: true, 37: true, 38: true, 39: true, 40: true },
    },

    {
      name: 'NAMED_CODES',
      value: {
        '13': 'enter',
        '37': 'left',
        '38': 'up',
        '39': 'right',
        '40': 'down'
      }
    },
  ],

  css: `
    /*
     We hide Elements by adding this style rather than setting
     'display: none' directly because then when we re-show the
     Element we don't need to remember it's desired 'display' value.
    */
    .foam-u2-Element-hidden {
      display: none !important;
    }
  `,

  properties: [
    {
      name: 'id',
      transient: true,
      factory: function() { return this.NEXT_ID(); }
    },
    {
      name: 'state',
      class: 'Proxy',
      of: 'foam.u2.ElementState',
      transient: true,
      topics: [],
      delegates: foam.u2.ElementState.getOwnAxiomsByClass(foam.core.Method).
          map(function(m) { return m.name; }),
      factory: function() { return this.INITIAL; },
      postSet: function(oldState, state) {
        if ( state === this.LOADED ) {
          this.pub('onload');
        } else if ( state === this.UNLOADED ) {
          this.pub('onunload');
        }
      }
    },
    {
      name: 'content',
      preSet: function(o, n) {
        // Prevent setting to 'this', which wouldn't change the behaviour.
        return n === this ? null : n ;
      }
    },
    {
      name: 'parentNode',
      transient: true
    },
    {
      class: 'Boolean',
      name: 'shown',
      value: true,
      postSet: function(o, n) {
        if ( o === n ) return;
        if ( n ) {
          this.removeClass('foam-u2-Element-hidden');
        } else {
          this.addClass('foam-u2-Element-hidden');
        }
      }
    },
    {
      class: 'Proxy',
      of: 'foam.u2.DefaultValidator',
      name: 'validator',
      topics: [],
      factory: function() {
        return this.elementValidator$ ? this.elementValidator : this.DEFAULT_VALIDATOR;
      }
    },
    {
      name: 'nodeName',
      adapt: function(_, v) {
        // Convert to uppercase so that checks against OPTIONAL_CLOSE_TAGS
        // and ILLEGAL_CLOSE_TAGS work.
        return foam.String.toUpperCase(v);
      },
      value: 'DIV'
    },
    {
      name: 'attributeMap',
      documentation: 'Same information as "attributes", but in map form for faster lookup',
      transient: true,
      factory: function() { return {}; }
    },
    {
      name: 'attributes',
      documentation: 'Array of {name: ..., value: ...} attributes.',
      factory: function() { return []; },
      postSet: function(_, attrs) {
        this.attributeMap = {};
        for ( var i = 0 ; i < attrs.length ; i++ ) {
          this.attributeMap[attrs[i].name] = attrs[i];
        }
      }
    },
    {
      name: 'classes',
      documentation: 'CSS classes assigned to this Element. Stored as a map of true values.',
      factory: function() { return {}; }
    },
    {
      name: 'css',
      documentation: 'Styles added to this Element.',
      factory: function() { return {}; }
    },
    {
      name: 'childNodes',
      documentation: 'Children of this Element.',
      factory: function() { return []; }
    },
    {
      name: 'elListeners',
      documentation: 'DOM listeners of this Element. Stored as topic then listener.',
      factory: function() { return []; }
    },
    {
      name: 'children',
      documentation: 'Virtual property of non-String childNodes.',
      transient: true,
      getter: function() {
        return this.childNodes.filter(function(c) {
          return typeof c !== 'string';
        });
      }
    },
    {
      class: 'Boolean',
      name: 'focused'
    },
    {
      name: 'outerHTML',
      transient: true,
      hidden: true,
      getter: function() {
        return this.output(this.createOutputStream()).toString();
      }
    },
    {
      name: 'innerHTML',
      transient: true,
      hidden: true,
      getter: function() {
        return this.outputInnerHTML(this.createOutputStream()).toString();
      }
    },
    {
      name: 'scrollHeight',
    },
    {
      class: 'Int',
      name: 'tabIndex',
    },
    {
      name: 'clickTarget_'
    },
    {
      name: '__subSubContext__',
      factory: function() { return this.__subContext__; }
    },
    'keyMap_'
  ],

  methods: [
    function init() {
      this.onDetach(this.visitChildren.bind(this, 'detach'));
    },

    function initE() {
      /*
        Template method for adding addtion element initialization
        just before Element is output().
      */
      this.initKeyboardShortcuts();
    },

    function observeScrollHeight() {
      // TODO: This should be handled by an onsub event when someone subscribes to
      // scroll height changes.
      var self = this;
      var observer = new MutationObserver(function(mutations) {
        self.scrollHeight = self.el().scrollHeight;
      });
      var config = { attributes: true, childList: true, characterData: true };

      this.onload.sub(function(s) {
        observer.observe(self.el(), config);
      });
      this.onunload.sub(function(s) {
        observer.disconnect()
      });
      return this;
    },

    function evtToCharCode(evt) {
      /* Maps an event keycode to a string */
      var s = '';
      if ( evt.altKey   ) s += 'alt-';
      if ( evt.ctrlKey  ) s += 'ctrl-';
      if ( evt.shiftKey && evt.type === 'keydown' ) s += 'shift-';
      if ( evt.metaKey  ) s += 'meta-';
      s += evt.type === 'keydown' ?
          this.NAMED_CODES[evt.which] || String.fromCharCode(evt.which) :
          String.fromCharCode(evt.charCode);
      return s;
    },

    function initKeyMap_(keyMap, cls) {
      var count = 0;

      var as = cls.getAxiomsByClass(foam.core.Action);

      for ( var i = 0 ; i < as.length ; i++ ) {
        var a = as[i];

        for ( var j = 0 ; a.keyboardShortcuts && j < a.keyboardShortcuts.length ; j++, count++ ) {
          var key = a.keyboardShortcuts[j];

          // First, lookup named codes, then convert numbers to char codes,
          // otherwise, assume we have a single character string treated as
          // a character to be recognized.
          if ( this.NAMED_CODES[key] ) {
            key = this.NAMED_CODES[key];
          } else if ( typeof key === 'number' ) {
            key = String.fromCharCode(key);
          }

          keyMap[key] = a.maybeCall.bind(a, this.__subContext__, this);
          /*
          keyMap[key] = opt_value ?
            function() { a.maybeCall(this.__subContext__, opt_value.get()); } :
            a.maybeCall.bind(action, self.X, self) ;
          */
        }
      }

      return count;
    },

    function initKeyboardShortcuts() {
      /* Initializes keyboard shortcuts. */
      var keyMap = {}
      var count = this.initKeyMap_(keyMap, this.cls_);

      //      if ( this.of ) count += this.initKeyMap_(keyMap, this.of);

      if ( count ) {
        this.keyMap_ = keyMap;
        var target = this.parentNode || this;

        // Ensure that target is focusable, and therefore will capture keydown
        // and keypress events.
        target.tabIndex = target.tabIndex || 1;

        target.on('keydown',  this.onKeyboardShortcut);
        target.on('keypress', this.onKeyboardShortcut);
      }
    },

    function el() {
      /* Return this Element's real DOM element, if loaded. */
      return this.getElementById(this.id);
    },

    function findChildForEvent(e) {
      var src  = e.srcElement;
      var el   = this.el();
      var cMap = {};
      var cs   = this.children;

      if ( ! el ) return;

      for ( var i = 0 ; i < cs.length ; i++ ) {
        var c = cs[i];
        cMap[c.id] = c;
      }

      while ( src !== el ) {
        var c = cMap[src.id];
        if ( c ) return c;
        src = src.parentElement;
      }
    },

    function E(opt_nodeName) {
      return this.__subSubContext__.E(opt_nodeName);
    },

    function attrSlot(opt_name, opt_event) {
      /* Convenience method for creating an AttrSlot's. */
      var args = { element: this };

      if ( opt_name  ) args.property = opt_name;
      if ( opt_event ) args.event    = opt_event;

      return this.AttrSlot.create(args);
    },

    function myCls(opt_extra) {
      console.warn('Deprecated use of Element.myCls(). Use myClass() instead.');
      return this.myClass(opt_extra);
    },

    function myClass(opt_extra) {
      // Use hasOwnProperty so that class doesn't inherit CSS classname
      // from ancestor FOAM class.
      var f = this.cls_.hasOwnProperty('myClass_') && this.cls_.myClass_;

      if ( ! f ) {
        var base = this.cls_.hasOwnProperty('CSS_CLASS') ?
          this.cls_.CSS_CLASS.split(/ +/) :
          foam.String.cssClassize(this.cls_.id).split(/ +/) ;

        f = this.cls_.myClass_ = foam.Function.memoize1(function(e) {
          return base.map(function(c) { return c + (e ? '-' + e : ''); }).join(' ');
        });
      }

      return f(opt_extra);
    },

    function visitChildren(methodName) {
      /*
        Call the named method on all children.
        Typically used to transition state of all children at once.
        Ex.: this.visitChildren('load');
      */
      var cs = this.childNodes;
      for ( var i = 0 ; i < cs.length ; i++ ) {
        var c = cs[i];
        c[methodName] && c[methodName].call(c);
      }
    },

    function focus() {
      this.focused = true;
      this.onFocus();
      return this;
    },

    function blur() {
      this.focused = false;
      return this;
    },

    function show(opt_shown) {
      if ( opt_shown === undefined ) {
        this.shown = true;
      } else if ( foam.core.Slot.isInstance(opt_shown) ) {
        this.shown$.follow(opt_shown);
      } else {
        this.shown = !! opt_shown;
      }

      return this;
    },

    function hide(opt_hidden) {
      return this.show(
          opt_hidden === undefined              ? false :
          foam.core.Slot.isInstance(opt_hidden) ? opt_hidden.map(function(s) { return ! s; }) :
          ! opt_hidden);
    },

    function setAttribute(name, value) {
      /*
        Set an Element attribute or property.

        If this model has a property named 'name' which has 'attribute: true',
        then the property will be updated with value.
        Otherwise, the DOM attribute will be set.

        Value can be either a string, a Value, or an Object.
        If Value is undefined, null or false, the attribute will be removed.
      */

      // TODO: type checking

      if ( name === 'tabindex' ) this.tabIndex = parseInt(value);

      // handle slot binding, ex.: data$: ...,
      // Remove if we add a props() method
      if ( name.endsWith('$') ) {
        this[name] = value;
        return;
      }

      var prop = this.cls_.getAxiomByName(name);

      if ( prop &&
           foam.core.Property.isInstance(prop) &&
           prop.attribute )
      {
        if ( typeof value === 'string' ) {
          // TODO: remove check when all properties have fromString()
          this[name] = prop.fromString ? prop.fromString(value) : value;
        } else if ( foam.core.Slot.isInstance(value) ) {
          this.slot(name).follow(value);
        } else {
          this[name] = value;
        }
      } else {
        if ( value === undefined || value === null || value === false ) {
          this.removeAttribute(name);
          return;
        }

        if ( foam.core.Slot.isInstance(value) ) {
          this.slotAttr_(name, value);
        } else {
          foam.assert(
              typeof value === 'string' || typeof value === 'number' || typeof value === 'boolean' || foam.Date.isInstance(value),
              'Attribute value must be a primitive type.');

          var attr = this.getAttributeNode(name);

          if ( attr ) {
            attr.value = value;
          } else {
            attr = { name: name, value: value };
            this.attributes.push(attr);
            this.attributeMap[name] = attr;
          }

          this.onSetAttr(name, value);
        }
      }
    },

    function removeAttribute(name) {
      /* Remove attribute named 'name'. */
      for ( var i = 0 ; i < this.attributes.length ; i++ ) {
        if ( this.attributes[i].name === name ) {
          this.attributes.splice(i, 1);
          delete this.attributeMap[name];
          this.onRemoveAttr(name);
          return;
        }
      }
    },

    function getAttributeNode(name) {
      /*
        Get {name: ..., value: ...} attributeNode associated
        with 'name', if exists.
      */
      return this.attributeMap[name];
    },

    function getAttribute(name) {
      // TODO: add support for other dynamic attributes also
      // TODO: don't lookup in real DOM if listener present
      if ( this.PSEDO_ATTRIBUTES[name] && this.el() ) {
        var value = this.el()[name];
        var attr  = this.getAttributeNode(name);

        if ( attr ) {
          attr[name] = value;
        } else {
          attr = { name: name, value: value };
          this.attributes.push(attr);
          this.attributeMap[name] = attr;
        }

        return value;
      }

      /*
        Get value associated with attribute 'name',
        or undefined if attribute not set.
      */
      var attr = this.getAttributeNode(name);
      return attr && attr.value;
    },

    function appendChild(c) {
      // TODO: finish implementation
      this.childNodes.push(c);
    },

    function removeChild(c) {
      /* Remove a Child node (String or Element). */
      var cs = this.childNodes;
      for ( var i = 0 ; i < cs.length ; ++i ) {
        if ( cs[i] === c ) {
          cs.splice(i, 1);
          this.state.onRemoveChild.call(this, c, i);
          return;
        }
      }
    },

    function replaceChild(newE, oldE) {
      /* Replace current child oldE with newE. */
      var cs = this.childNodes;
      for ( var i = 0 ; i < cs.length ; ++i ) {
        if ( cs[i] === oldE ) {
          cs[i] = newE;
          newE.parentNode = this;
          this.state.onReplaceChild.call(this, oldE, newE);
          oldE.unload && oldE.unload();
          return;
        }
      }
    },

    function insertBefore(child, reference) {
      /* Insert a single child before the reference element. */
      return this.insertAt_(child, reference, true);
    },

    function insertAfter(child, reference) {
      /* Insert a single child after the reference element. */
      return this.insertAt_(child, reference, false);
    },

    function remove() {
      /*
        Remove this Element from its parent Element.
        Will transition to UNLOADED state.
      */
      this.onRemove();

      if ( this.parentNode ) {
        var cs = this.parentNode.childNodes;
        for ( var i = 0 ; i < cs.length ; i++ ) {
          if ( cs[i] === this ) {
            cs.splice(i, 1);
            return;
          }
        }
        this.parentNode = undefined;
      }
    },

    function addEventListener(topic, listener) {
      /* Add DOM listener. */
      this.elListeners.push(topic, listener);
      this.onAddListener(topic, listener);
    },

    function removeEventListener(topic, listener) {
      /* Remove DOM listener. */
      var ls = this.elListeners;
      for ( var i = 0 ; i < ls.length ; i+=2 ) {
        var t = ls[i], l = ls[i+1];
        if ( t === topic && l === listener ) {
          ls.splice(i, 2);
          this.onRemoveListener(topic, listener);
          return;
        }
      }
    },

    function setNodeName(name) {
      this.nodeName = name;
      return this;
    },

    function setID(id) {
      /*
        Explicitly set Element's id.
        Normally id's are automatically assigned.
        Setting specific ID's hinders composability.
      */
      this.id = id;
      return this;
    },

    function entity(name) {
      /* Create and add a named entity. Ex. .entity('gt') */
      this.add(this.Entity.create({ name: name }));
      return this;
    },

    function nbsp() {
      return this.entity('nbsp');
    },

    function cssClass(cls) {
      return this.addClass(cls);
    },

    function addClass(cls) { /* Slot | String */
      /* Add a CSS cls to this Element. */
      var self = this;
      if ( foam.core.Slot.isInstance(cls) ) {
        var lastValue = null;
        var l = function() {
          var v = cls.get();
          self.addClass_(lastValue, v);
          lastValue = v;
        };
        cls.sub(l);
        l();
      } else if ( typeof cls === 'string' ) {
        this.addClass_(null, cls);
      } else {
        this.error('cssClass type error. Must be Slot or String.');
      }

      return this;
    },

    function enableCls(cls, enabled, opt_negate) {
      console.warn('Deprecated use of Element.enableCls(). Use enableClass() instead.');
      return this.enableClass(cls, enabled, opt_negate);
    },

    function enableClass(cls, enabled, opt_negate) {
      /* Enable/disable a CSS class based on a boolean-ish dynamic value. */
      function negate(a, b) { return b ? ! a : a; }

      // TODO: add type checking
      if ( foam.core.Slot.isInstance(enabled) ) {
        var self = this;
        var value = enabled;
        var l = function() { self.enableClass(cls, value.get(), opt_negate); };
        value.sub(l);
        l();
      } else {
        enabled = negate(enabled, opt_negate);
        var parts = cls.split(' ');
        for ( var i = 0 ; i < parts.length ; i++ ) {
          this.classes[parts[i]] = enabled;
          this.onSetClass(parts[i], enabled);
        }
      }
      return this;
    },

    function removeCls(cls) {
      console.warn('Deprecated use of Element.removeCls(). Use removeClass() instead.');
      return this.removeClass(cls);
    },

    function removeClass(cls) {
      /* Remove specified CSS class. */
      if ( cls ) {
        delete this.classes[cls];
        this.onSetClass(cls, false);
      }
      return this;
    },

    function on(topic, listener) {
      /* Shorter fluent version of addEventListener. Prefered method. */
      this.addEventListener(topic, listener);
      return this;
    },

    function attr(key, value) {
      this.setAttribute(key, value);
      return this;
    },

    function attrs(map) {
      /* Set multiple attributes at once. */
      for ( var key in map ) this.setAttribute(key, map[key]);
      return this;
    },

    function style(map) {
      /*
        Set CSS styles.
        Map values can be Objects or dynamic Values.
      */
      for ( var key in map ) {
        var value = map[key];
        if ( foam.core.Slot.isInstance(value) ) {
          this.slotStyle_(key, value);
        } else {
          this.style_(key, value);
        }
        // TODO: add type checking for this
      }

      return this;
    },

    function tag(spec, args, slot) {
      /* Create a new Element and add it as a child. Return this. */
      var c = this.createChild_(spec, args);
      this.add(c);
      if ( slot ) slot.set(c);
      return this;
    },

    function br() {
      return this.tag('br');
    },

    function startContext(map) {
      var m = {};
      Object.assign(m, map);
      m.__oldAddContext__ = this.__subSubContext__;
      this.__subSubContext__ = this.__subSubContext__.createSubContext(m);
      return this;
    },

    function endContext() {
      this.__subSubContext__ = this.__subSubContext__.__oldAddContext__;
      return this;
    },

    function createChild_(spec, args) {
      return foam.u2.ViewSpec.createView(spec, args, this, this.__subSubContext__);
    },

    function start(spec, args, slot) {
      /* Create a new Element and add it as a child. Return the child. */
      var c = this.createChild_(spec, args);
      this.add(c);
      if ( slot ) slot.set(c);
      return c;
    },

    function end() {
      /* Return this Element's parent. Used to terminate a start(). */
      return this.parentNode;
    },

    function add() {
      if ( this.content ) {
        this.content.add_(arguments, this);
      } else {
        this.add_(arguments, this);
      }
      return this;
    },

    function toE() {
      return this;
    },

    function add_(cs, parentNode) {
      /* Add Children to this Element. */
      var es = [];
      var Y = this.__subSubContext__;

      for ( var i = 0 ; i < cs.length ; i++ ) {
        var c = cs[i];

        // Remove null values
        if ( c === undefined || c === null ) {
          // nop
        } else if ( Array.isArray(c) ) {
          for ( var j = 0 ; j < c.length ; j++ ) {
            var v = c[j];
            es.push(v.toE ? v.toE(null, Y) : v);
          }
        } else if ( c.toE ) {
          var e = c.toE(null, Y);
          if ( foam.core.Slot.isInstance(e) ) {
            e = this.slotE_(e);
          }
          es.push(e);
        } else if ( typeof c === 'function' ) {
          throw new Error('Unsupported');
        } else if ( foam.core.Slot.isInstance(c) ) {
          var v = this.slotE_(c);
          if ( Array.isArray(v) ) {
            for ( var j = 0 ; j < v.length ; j++ ) {
              var u = v[j];
              es.push(u.toE ? u.toE(null, Y) : u);
            }
          } else {
            es.push(v.toE ? v.toE(null, Y) : v);
          }
        } else {
          es.push(c);
        }
      }

      if ( es.length ) {
        for ( var i = 0 ; i < es.length ; i++ ) {
          if ( foam.u2.Element.isInstance(es[i]) ) {
            es[i].parentNode = parentNode;
          } else if ( es[i].cls_ && es[i].cls_.id === 'foam.u2.Entity' ) {
            // NOP
          } else {
            es[i] = this.sanitizeText(es[i]);
          }
        }

        this.childNodes.push.apply(this.childNodes, es);
        this.onAddChildren.apply(this, es);
      }

      return this;
    },

    function addBefore(reference) { /*, vargs */
      /* Add a variable number of children before the reference element. */
      var children = [];
      for ( var i = 1 ; i < arguments.length ; i++ ) {
        children.push(arguments[i]);
      }
      return this.insertAt_(children, reference, true);
    },

    function removeAllChildren() {
      /* Remove all of this Element's children. */
      var cs = this.childNodes;
      while ( cs.length ) {
        this.removeChild(cs[0]);
      }
      return this;
    },

    function setChildren(slot) {
      /**
         slot -- a Slot of an array of children which set this element's
         contents, replacing old children
      **/
      var l = function() {
        this.removeAllChildren();
        this.add.apply(this, slot.get());
      }.bind(this);

      slot.sub(l);
      l();

      return this;
    },

    function repeat(s, e, f) {
      // TODO: support descending
      for ( var i = s ; i <= e ; i++ ) {
        f.call(this, i);
      }
      return this;
    },

    function daoSlot(dao, sink) {
      var slot = foam.dao.DAOSlot.create({
        dao: dao,
        sink: sink
      });

      this.onDetach(slot);

      return slot;
    },

    function select(dao, f, update) {
      var es   = {};
      var self = this;

      var listener = foam.u2.RenderSink.create({
        dao: dao,
        addRow: function(o) {
          if ( update ) o = o.clone();

          self.startContext({data: o});

          var e = f.call(self, o);

          if ( update ) {
            o.propertyChange.sub(function(_,__,prop,slot) {
              dao.put(o.clone());
            });
          }

          self.endContext();

          if ( es[o.id] ) {
            self.replaceChild(es[o.id], e);
          } else {
            self.add(e);
          }
          es[o.id] = e;
        },
        cleanup: function() {
          for ( var key in es ) {
            es[key].remove();
          }

          es = {};
        }
      }, this);

      listener = foam.dao.MergedResetSink.create({
        delegate: listener
      }, this);

      this.onDetach(dao.listen(listener));
      listener.delegate.paint();

      return this;
    },

    function call(f, args) {
      f.apply(this, args);

      return this;
    },

    function callOn(obj, f, args) {
      obj[f].apply(obj, [this].concat(args));
      return this;
    },

    function callIf(bool, f, args) {
      if ( bool ) f.apply(this, args);

      return this;
    },

    function forEach(a, f) {
      for ( var i = 0 ; i < a.length ; i++ ) {
        f.call(this, a[i], i);
      }

      return this;
    },

    function outputInnerHTML(out) {
      var cs = this.childNodes;
      for ( var i = 0 ; i < cs.length ; i++ ) {
        out(cs[i]);
      }
      return out;
    },

    function createOutputStream() {
      /*
        Create an OutputStream.
        Suitable for providing to the output() method for
        serializing an Element hierarchy.
        Call toString() on the OutputStream to get output.
      */
      var self = this;
      var buf = [];
      var Element = foam.u2.Element;
      var Entity  = self.Entity;
      var f = function templateOut(/* arguments */) {
        for ( var i = 0 ; i < arguments.length ; i++ ) {
          var o = arguments[i];
          if ( o === null || o === undefined ) {
            // NOP
          } else if ( typeof o === 'string' ) {
            buf.push(o);
          } else if ( typeof o === 'number' ) {
            buf.push(o);
          } else if ( Element.isInstance(o) || Entity.isInstance(o) ) {
            o.output(f);
          } else if ( o === null || o === undefined ) {
            buf.push(o);
          }
        }
      };

      f.toString = function() {
        if ( buf.length === 0 ) return '';
        if ( buf.length > 1 ) return buf.join('');
        return buf[0];
      };

      return f;
    },

    function write() {
      /* Write Element to document. */
      this.document.body.insertAdjacentHTML('beforeend', this.outerHTML);
      this.load();
      return this;
    },

    function toString() {
      return this.cls_.id + '(nodeName=' + this.nodeName + ', state=' + this.state + ')';
      /* Converts Element to HTML String without transitioning state. */
      /*
        TODO: put this somewhere useful for debugging
      var s = this.createOutputStream();
      this.output_(s);
      return s.toString();
      */
    },

    function insertAt_(children, reference, before) {
      // (Element[], Element, Boolean)

      var i = this.childNodes.indexOf(reference);

      if ( i === -1 ) {
        this.warn("Reference node isn't a child of this.");
        return this;
      }

      if ( ! Array.isArray(children) ) children = [ children ];

      var Y = this.__subSubContext__;
      children = children.map(function(e) {
        e = e.toE ? e.toE(null, Y) : e;
        e.parentNode = this;
        return e;
      }.bind(this));

      var index = before ? i : (i + 1);
      this.childNodes.splice.apply(this.childNodes,
          [ index, 0 ].concat(children));

      this.state.onInsertChildren.call(
        this,
        children,
        reference,
        before ? 'beforebegin' : 'afterend');

      return this;
    },

    function addClass_(oldClass, newClass) {
      /* Replace oldClass with newClass. Called by cls(). */
      if ( oldClass === newClass ) return;
      this.removeClass(oldClass);
      if ( newClass ) {
        this.classes[newClass] = true;
        this.onSetClass(newClass, true);
      }
    },

    function slotAttr_(key, value) {
      /* Set an attribute based off of a dynamic Value. */
      var self = this;
      var l = function() { self.setAttribute(key, value.get()); };
      value.sub(l);
      l();
    },

    function slotStyle_(key, v) {
      /* Set a CSS style based off of a dynamic Value. */
      var self = this;
      var l = function(value) { self.style_(key, v.get()); };
      v.sub(l);
      l();
    },

    function style_(key, value) {
      /* Set a CSS style based off of a literal value. */
      this.css[key] = value;
      this.onSetStyle(key, value);
      return this;
    },

    function slotE_(slot) {
      // TODO: add same context capturing behviour to other slotXXX_() methods.
      /*
        Return an Element or an Array of Elements which are
        returned from the supplied dynamic Slot.
        The Element(s) are replaced when the Slot changes.
      */
      var self = this;
      var ctx  = this.__subSubContext__;

      function nextE() {
        // Run Slot in same subSubContext that it was created in.
        var oldCtx = self.__subSubContext__;
        self.__subSubContext__ = ctx;
        var e = slot.get();

        // Convert e or e[0] into a SPAN if needed,
        // So that it can be located later.
        if ( e === undefined || e === null || e === '' ) {
          e = self.E('SPAN');
        } else if ( Array.isArray(e) ) {
          if ( e.length ) {
            if ( typeof e[0] === 'string' ) {
              e[0] = self.E('SPAN').add(e[0]);
            }
          } else {
            e = self.E('SPAN');
          }
        } else if ( ! foam.u2.Element.isInstance(e) ) {
          e = self.E('SPAN').add(e);
        }

        self.__subSubContext__ = oldCtx;

        return e;
      }

      var e = nextE();
      var l = function() {
        if ( self.state !== self.LOADED ) {
          s && s.detach();
          return;
        }
        var first = Array.isArray(e) ? e[0] : e;
        var tmp = self.E();
        self.insertBefore(tmp, first);
        if ( Array.isArray(e) ) {
          for ( var i = 0 ; i < e.length ; i++ ) { e[i].remove(); e[i].detach(); }
        } else {
          if ( e.state === e.LOADED ) { e.remove(); e.detach(); }
        }
        var e2 = nextE();
        self.insertBefore(e2, tmp);
        tmp.remove();
        e = e2;
      };

      var s = slot.sub(this.framed(l));
      this.onDetach(s);

      return e;
    },

    function addEventListener_(topic, listener) {
      var el = this.el();
      el && el.addEventListener(topic, listener, false);
    },

    function removeEventListener_(topic, listener) {
      this.el() && this.el().removeEventListener(topic, listener);
    },

    function output_(out) {
      /** Output the element without transitioning to the OUTPUT state. **/
      out('<', this.nodeName);
      if ( this.id !== null ) out(' id="', this.id, '"');

      var first = true;
      if ( this.hasOwnProperty('classes') ) {
        var cs = this.classes;
        for ( var key in cs ) {
          if ( ! cs[key] ) continue;
          if ( first ) {
            out(' class="');
            first = false;
          } else {
            out(' ');
          }
          out(key);
        }
        if ( ! first ) out('"');
      }

      if ( this.hasOwnProperty('css') ) {
        first = true;
        var cs = this.css;
        for ( var key in cs ) {
          var value = cs[key];

          if ( first ) {
            out(' style="');
            first = false;
          }
          out(key, ':', value, ';');
        }
        if ( ! first ) out('"');
      }

      if ( this.hasOwnProperty('attributes') ) {
        var as = this.attributes;
        for ( var i = 0 ; i < as.length ; i++ ) {
          var attr  = as[i];
          var name  = attr.name;
          var value = attr.value;

          out(' ', name);
          if ( value !== false ) out('="', foam.String.isInstance(value) ? value.replace(/"/g, '&quot;') : value, '"');
        }
      }

      if ( ! this.ILLEGAL_CLOSE_TAGS[this.nodeName] ) {
        var hasChildren = this.hasOwnProperty('childNodes') && this.childNodes.length;
        if ( hasChildren || ! this.OPTIONAL_CLOSE_TAGS[this.nodeName] ) {
          out('>');
          if ( hasChildren ) this.outputInnerHTML(out);
          out('</', this.nodeName);
        }
      }

      out('>');
    }
  ],

  listeners: [
    {
      name: 'onKeyboardShortcut',
      documentation: function() {/*
          Automatic mapping of keyboard events to $$DOC{ref:'Action'} trigger.
          To handle keyboard shortcuts, create and attach $$DOC{ref:'Action',usePlural:true}
          to your $$DOC{ref:'foam.ui.View'}.
      */},
      code: function(evt) {
        if ( evt.type === 'keydown' && ! this.KEYPRESS_CODES[evt.which] ) return;
        var action = this.keyMap_[this.evtToCharCode(evt)];
        if ( action ) {
          action();
          evt.preventDefault();
          evt.stopPropagation();
        }
      }
    }
  ]
});


foam.CLASS({
  package: 'foam.u2',
  name: 'U2Context',

  documentation: 'Context which includes U2 functionality.',

  exports: [
    'E',
    'registerElement',
    'elementForName'
  ],

  properties: [
    {
      name: 'elementMap',
      documentation: 'Map of registered Elements.',
      factory: function() { return {}; }
    }
  ],

  methods: [
    {
      class: 'foam.core.ContextMethod',
      name: 'E',
      code: function E(ctx, opt_nodeName) {
        var nodeName = (opt_nodeName || 'div').toUpperCase();

        return (
          ctx.elementForName(nodeName) || foam.u2.Element).
          create({nodeName: nodeName}, ctx);
      }
    },

    function registerElement(elClass, opt_elName) {
      /* Register a View class against an abstract node name. */
      var key = opt_elName || elClass.name;
      this.elementMap[key.toUpperCase()] = elClass;
    },

    function elementForName(nodeName) {
      /* Find an Element Class for the specified node name. */
      return this.elementMap[nodeName];
    }
  ]
});

foam.__context__ = foam.u2.U2Context.create().__subContext__;


foam.CLASS({
  refines: 'foam.core.FObject',
  methods: [
    function toE(args, X) {
      return foam.u2.ViewSpec.createView(
        { class: 'foam.u2.DetailView', showActions: true, data: this },
        args, this, X);
    }
  ]
});


foam.CLASS({
  refines: 'foam.core.Slot',
  methods: [
    function toE() { return this; }
  ]
});


foam.CLASS({
  refines: 'foam.core.ExpressionSlot',
  methods: [
    function toE() { return this; }
  ]
});


foam.CLASS({
  refines: 'foam.core.Property',

  requires: [
    'foam.u2.TextField'
  ],

  properties: [
    {
      // If true, this property is treated as a psedo-U2 attribute.
      name: 'attribute',
      value: false
    },
    {
      class: 'foam.u2.ViewSpec',
      name: 'view',
      value: { class: 'foam.u2.TextField' }
    },
    {
      class: 'Enum',
      of: 'foam.u2.Visibility',
      name: 'visibility',
      value: 'RW'
    }
  ],

  methods: [
    function toE(args, X) {
      var e = foam.u2.ViewSpec.createView(this.view, args, this, X);

      e.fromProperty && e.fromProperty(this);

      if ( X.data$ && ! ( args && ( args.data || args.data$ ) ) ) {
        e.data$ = X.data$.dot(this.name);
      }

      // e could be a Slot, so check if addClass exists
      e.addClass && e.addClass('property-' + this.name);

      return e;
    }
  ]
});


foam.CLASS({
  refines: 'foam.core.String',
  properties: [
    {
      class: 'Int',
      name: 'displayWidth',
      expression: function(width) { return width; }
    }
  ]
});


foam.CLASS({
  refines: 'foam.core.StringArray',
  properties: [
    [ 'view', { class: 'foam.u2.view.StringArrayView' } ]
  ]
});


foam.CLASS({
  refines: 'foam.core.Date',
  requires: [ 'foam.u2.DateView' ],
  properties: [
    [ 'view', { class: 'foam.u2.DateView' } ]
  ]
});


foam.CLASS({
  refines: 'foam.core.DateTime',
  requires: [ 'foam.u2.DateTimeView' ],
  properties: [
    [ 'view', { class: 'foam.u2.DateTimeView' } ]
  ]
});


foam.CLASS({
  refines: 'foam.core.Time',
  requires: [ 'foam.u2.TimeView' ],
  properties: [
    [ 'view', { class: 'foam.u2.TimeView' } ]
  ]
});


foam.CLASS({
  refines: 'foam.core.Float',
  requires: [ 'foam.u2.FloatView' ],
  properties: [
    [ 'displayWidth', 12 ],
    [ 'view', { class: 'foam.u2.FloatView' } ]
  ]
});


foam.CLASS({
  refines: 'foam.core.Int',
  requires: [ 'foam.u2.IntView' ],
  properties: [
    [ 'displayWidth', 10 ],
    [ 'view', { class: 'foam.u2.IntView' } ]
  ]
});


foam.CLASS({
  refines: 'foam.core.Currency',
  requires: [ 'foam.u2.CurrencyView' ],
  properties: [
    [ 'displayWidth', 15 ],
    [ 'view', { class: 'foam.u2.CurrencyView' } ]
  ]
});


foam.CLASS({
  refines: 'foam.core.Boolean',
  requires: [ 'foam.u2.CheckBox' ],
  properties: [
    [ 'view', { class: 'foam.u2.CheckBox' } ],
  ]
});


foam.CLASS({
  refines: 'foam.core.Color',
  properties: [
    {
      name: 'view',
      value: {
        class: 'foam.u2.view.DualView',
        viewa: 'foam.u2.TextField',
        viewb: { class: 'foam.u2.view.ColorPicker', onKey: true }
      }
    }
  ]
});


foam.CLASS({
  refines: 'foam.core.FObjectProperty',
  properties: [
    {
      name: 'view',
      value: { class: 'foam.u2.DetailView' },
    }
  ]
});


foam.CLASS({
  refines: 'foam.core.FObjectArray',
  properties: [
    {
      name: 'view',
      value: { class: 'foam.u2.view.FObjectArrayView' },
    }
  ]
});


foam.CLASS({
  refines: 'foam.core.Class',
  properties: [
    [ 'view', { class: 'foam.u2.ClassView' } ]
  ]
});


foam.CLASS({
  refines: 'foam.core.Reference',
  properties: [
    {
      name: 'view',
      value: {
        class: 'foam.u2.view.ReferenceView'
      }
    }
  ]
});


foam.CLASS({
  refines: 'foam.core.Enum',
  properties: [
    [ 'view',          { class: 'foam.u2.EnumView' } ],
    [ 'tableCellView', function(obj) { return this.get(obj).label; } ]
  ]
});


foam.CLASS({
  package: 'foam.u2',
  name: 'ControllerViewTrait',

  documentation: 'Trait for adding a ControllerMode controllerMode Property.',

  exports: [ 'controllerMode' ],

  properties: [
    {
      class: 'Enum',
      of: 'foam.u2.ControllerMode',
      name: 'controllerMode'
    }
  ]
});


foam.CLASS({
  package: 'foam.u2',
  name: 'View',
  extends: 'foam.u2.Element',

  documentation: `
    A View is an Element used to display data.
    // TODO: Should the following be properties?
    /*
    {
      type: 'Boolean',
      name: 'showValidation',
      documentation: 'Set to false if you want to ignore any ' +
          '$$DOC{ref:"Property.validate"} calls. On by default.',
      defaultValue: true
    },
    {
      type: 'String',
      name: 'validationError_',
      documentation: 'The actual error message. Null or the empty string ' +
          'when there is no error.',
    }
    */
  `,

  exports: [ 'data' ],

  properties: [
    {
      class: 'Enum',
      of: 'foam.u2.ControllerMode',
      name: 'controllerMode',
      factory: function() { return this.__context__.controllerMode || foam.u2.ControllerMode.CREATE; }
    },
    {
      name: 'data',
      attribute: true
    },
    {
      class: 'Enum',
      of: 'foam.u2.Visibility',
      name: 'visibility',
      postSet: function() { this.updateMode_(this.mode); },
      attribute: true,
      value: 'RW'
    },
    {
      class: 'Enum',
      of: 'foam.u2.DisplayMode',
      name: 'mode',
      attribute: true,
      postSet: function(_, mode) { this.updateMode_(mode); },
      expression: function(visibility, controllerMode) {
        if ( visibility === foam.u2.Visibility.RO ) {
          return foam.u2.DisplayMode.RO;
        }

        if ( visibility === foam.u2.Visibility.DISABLED ) {
          return foam.u2.DisplayMode.DISABLED;
        }

        if ( visibility === foam.u2.Visibility.FINAL &&
             controllerMode !== foam.u2.ControllerMode.CREATE ) {
          return foam.u2.DisplayMode.RO;
        }

        return controllerMode === foam.u2.ControllerMode.VIEW ?
          foam.u2.DisplayMode.RO :
          foam.u2.DisplayMode.RW ;
      },
      attribute: true
    }
  ],

  methods: [
    function initE() {
      this.SUPER();
      this.updateMode_(this.mode);
    },

    function updateMode_() {
      // Template method, to be implemented in sub-models
    },

    function fromProperty(p) {
      this.visibility = p.visibility;
    }
  ]
});


foam.CLASS({
  package: 'foam.u2',
  name: 'Controller',
  extends: 'foam.u2.Element',

  documentation: 'A Controller is an Element which exports itself as "data".',

  exports: [ 'as data' ]
});


foam.CLASS({
  refines: 'foam.core.Action',

  requires: [
    'foam.u2.ActionView'
  ],

  methods: [
    function toE(args, X) {
      var view = foam.u2.ViewSpec.createView(
        { class: 'foam.u2.ActionView', action: this }, args, this, X);

      if ( X.data$ && ! ( args && ( args.data || args.data$ ) ) ) {
        view.data$ = X.data$;
      }

      return view;
    }
  ]
});

foam.CLASS({
  package: 'foam.u2',
  name: 'TableColumns',

  documentation: 'Axiom for storing Table Columns information in Class. Unlike most Axioms, doesn\'t modify the Class, but is just used to store information.',

  properties: [
    [ 'name', 'tableColumns' ],
    'columns'
  ]
});


foam.CLASS({
  package: 'foam.u2',
  name: 'SearchColumns',

  documentation: 'Axiom for storing Table Search Columns information in Class. Unlike most Axioms, doesn\'t modify the Class, but is just used to store information.',

  properties: [
    [ 'name', 'searchColumns' ],
    'columns'
  ]
});


foam.CLASS({
  refines: 'foam.core.Model',

  properties: [
    {
      class: 'String',
      name: 'css',
      postSet: function(_, code) {
        this.axioms_.push(foam.u2.CSS.create({code: code}));
      }
    },
    {
      documentation: `
        // TODO: remove when all code ported
      `,
      name: 'tableProperties',
      setter: function(_, ps) {
        console.warn("Deprecated use of tableProperties. Use 'tableColumns' instead.");
        this.tableColumns = ps;
      }
    },
    {
      name: 'tableColumns',
      postSet: function(_, cs) {
        this.axioms_.push(foam.u2.TableColumns.create({columns: cs}));
      }
    },
    {
      name: 'searchColumns',
      postSet: function(_, cs) {
        this.axioms_.push(foam.u2.SearchColumns.create({columns: cs}));
      }
    }
  ]
});
/**
 * @license
 * Copyright 2017 The FOAM Authors. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

foam.CLASS({
  package: 'foam.u2',
  name: 'MNRowFormatter',
  implements: [ 'foam.u2.RowFormatter' ],

  axioms: [
    foam.u2.CSS.create({
      code: function CSS() {/*
        .mn-row {
          height: 100%;
          display: flex;
        }
        .mn-row .row-id {
          flex-grow: 1;
        }
        .mn-row .row-data {
          display: flex;
          flex-grow: 3;
        }
        .mn-row .row-value {
          flex-grow: 1;
          background-color: #ddd;
          justify-content: center;
          align-items: center;
          display: flex;
        }
        .mn-row .row-value.yes {
          background-color: #0f0;
        }
        .mn-row .row-value.no {
          background-color: #f00;
        }
        .mn-row .row-value * {
          background-color: inherit;
        }
    */}
    })
  ],

  methods: [
    function format(data) {
      // TODO(markdittmer): Sanitize data with HTML lib escapeString().
      if ( ! data ) {
        console.log('Render missing data');
        return `<div class="mn-row"></div>`;
      }
      var dataMarkup = '';
      var innerData = data.data;
      for ( var i = 0; i < innerData.length; i++ ) {
        var datum = innerData[i];
        dataMarkup += `<div class="row-value ${datum ? 'yes' : 'no'}">
          ${datum ? '&#10003;' : '&#215;'}
        </div>`;
      }
      return `<div class="mn-row">
        <div class="row-id">${data.id}</div>
        <div class="row-data">
          ${dataMarkup}
        </div>
      </div>`;
    }
  ]
});
/**
 * @license
 * Copyright 2015 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

foam.CLASS({
  package: 'foam.u2',
  name: 'ProgressView',
  extends: 'foam.u2.View',

  css: `
    ^ {
      margin: 2px 0 0 10px;
      height: 23px;
      width: 183px;
    }
  `,

  properties: [
    [ 'nodeName', 'progress' ]
  ],

  methods: [
    function initE() {
      this.
        addClass(this.myClass()).
        attrs({max: 100}).
        attrSlot().follow(this.data$);
    }
  ]
});
/**
 * @license
 * Copyright 2018 The FOAM Authors. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/** @license Copyright 2017 The FOAM Authors, All Rights Reserved. */

foam.CLASS({
  package: 'foam.u2',
  name: 'ListCreateController',
  extends: 'foam.u2.stack.StackView',

  requires: [
    'foam.u2.DetailView',
    'foam.u2.TableView'
  ],

  exports: [
    'createLabel',
    'dao',
    'data as stack',
    'data', // TODO: output as 'stack'
    'detailView',
    'createDetailView',
    'factory',
    'memento',
    'summaryView',
    'showActions'
  ],

  properties: [
    'dao',
    {
      name: 'summaryView',
      value: { class: 'foam.u2.TableView' }
    },
    {
      name: 'detailView',
      value: { class: 'foam.u2.DetailView' }
    },
    {
      name: 'createDetailView',
      value: { class: 'foam.u2.DetailView' }
    },
    {
      name: 'factory',
      value: function() { return this.dao.of.create(); }
    },
    {
      class: 'String',
      name: 'createLabel'
    },
    [ 'showActions', true ],
    'memento'
  ],

  methods: [
    function initE() {
      this.push(this.ListController);
    },

    function push(view) {
      this.data.push(view, this);
    },

    function back() {
      this.data.back();
    }
  ],

  actions: [
    {
      name: 'create',
      code: function() {
        this.data.push(this.detailView);
      }
    }
  ],

  classes: [
    {
      name: 'ListController',
      extends: 'foam.u2.Element',

      imports: [
        'createLabel',
        'dao',
        'memento',
        'stack',
        'summaryView'
      ],

      exports: [ 'as data' ],

      properties: [
        {
          name: 'selection',
          postSet: function(o, n) {
            this.memento = n ? n.id : '';
          }
        }
      ],

      methods: [
        function initE() {
          this.memento$.sub(this.onMementoChange);
          this.onMementoChange();

          this
            .start(this.CREATE, this.createLabel && {label: this.createLabel}).style({float: 'right'}).end()
            .tag(this.summaryView, {data: this.dao, selection$: this.selection$});

          var self = this;
          this.selection$.sub(function() {
            if ( self.selection ) {
              var selection = self.selection;
              self.stack.push(function() {
                return foam.u2.ListCreateController.ViewController.create({obj: selection}, self);
              });
            }
          });
        }
      ],

      actions: [
        function create(X) {
          this.stack.push(function() { return foam.u2.ListCreateController.CreateController.create(null, X); });
        }
      ],

      listeners: [
        function onMementoChange() {
          if ( this.memento ) {
            var self = this;
            this.dao.find(this.memento).then(function (obj) {
              self.selection = obj;
            });
          } else {
            this.selection = null;
          }
        }
      ]
    },

    {
      name: 'CreateController',
      extends: 'foam.u2.Element',

      imports: [ 'createDetailView', 'detailView', 'stack', 'dao', 'factory', 'showActions' ],
      exports: [ 'as data' ],

      properties: [
          {
            name: 'obj',
            factory: function() { return this.factory(); }
          }
      ],

      methods: [
        function initE() {
          var view = this.createDetailView ? this.createDetailView : this.detailView
          this.tag(view, {data: this.obj})
          if ( this.showActions ) this.add(this.CANCEL, this.SAVE);
        }
      ],

      actions: [
        function cancel(X) {
          this.stack.back();
        },

        function save(X) {
          this.dao.put(this.obj);
          this.stack.back();
        }
      ]
    },

    {
      name: 'ViewController',
      extends: 'foam.u2.Element',

      imports: [ 'stack', 'detailView', 'showActions' ],
      exports: [ 'as data' ],

      properties: [
          {
            name: 'obj',
            factory: function() { return this.factory(); }
          }
      ],

      methods: [
        function initE() {
          this.tag(this.detailView, {data: this.obj, controllerMode: foam.u2.ControllerMode.VIEW})
          if ( this.showActions ) this.add(this.BACK);
        }
      ],

      actions: [
        function back(X) {
          this.stack.back();
        }
      ]
    }
  ]
});
/**
 * @license
 * Copyright 2017 The FOAM Authors. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

foam.CLASS({
  package: 'foam.version',
  name: 'VersionTrait',

  properties: [
    {
      class: 'Int',
      name: 'version_',
      value: -1
    },
    {
      class: 'Boolean',
      name: 'deleted_'
    }
  ]
});
/**
 * @license
 * Copyright 2017 The FOAM Authors. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

foam.CLASS({
  package: 'foam.version',
  name: 'VersionedClass',

  axioms: [
    foam.pattern.Multiton.create({ property: 'of' })
  ],

  requires: [
    'foam.core.Model',
  ],

  properties: [
    {
      class: 'Class',
      name: 'of',
      required: true
    },
    {
      class: 'String',
      name: 'package',
      factory: function() { return this.of.package; }
    },
    {
      class: 'String',
      name: 'name',
      factory: function() { return `Versioned${this.of.name}`; }
    },
    {
      class: 'String',
      name: 'id',
      factory: function() { return `${this.package}.${this.name}`; }
    },
    {
      class: 'FObjectProperty',
      of: 'Model',
      name: 'versionedModel',
      factory: function() {
        return this.Model.create({
          package: this.package,
          name: this.name,
          extends: this.of.id,
          implements: [ 'foam.version.VersionTrait' ]
        });
      }
    },
    {
      name: 'versionedCls',
      factory: function() {
        return this.buildClass_();
      }
    }
  ],

  methods: [
    function init() {
      this.validate();
      this.SUPER();
    },

    function buildClass_() {
      this.versionedModel.validate();
      var cls = this.versionedModel.buildClass();
      cls.validate();
      this.__subContext__.register(cls);
      foam.package.registerClass(cls);

      return this.versionedModel.buildClass();
    }
  ]
});
/**
 * @license
 * Copyright 2017 The FOAM Authors. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

foam.CLASS({
  package: 'foam.version',
  name: 'VersionedClassFactory',

  requires: [
    'foam.version.VersionTrait',
    'foam.version.VersionedClass'
  ],

  methods: [
    function get(cls) {
      return this.VersionTrait.isSubClass(cls) ? cls :
          this.VersionedClass.create({ of: cls }).versionedCls;
    }
  ]
});

foam.CLASS({
  package: 'foam.version',
  name: 'VersionedClassFactorySingleton',
  extends: 'foam.version.VersionedClassFactory',

  axioms: [ foam.pattern.Singleton.create() ],
});
/**
 * @license
 * Copyright 2016 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

foam.INTERFACE({
  package: 'foam.dao',
  name: 'Sink',

  documentation: 'Interface for receiving information updates. Primarily used as the target for DAO.select() calls.',

  methods: [
    {
      name: 'put',
      returns: '',
      args: [
        {
          name: 'obj',
          swiftType: 'Any'
        },
        {
          name: 'sub',
          swiftType: 'Detachable',
        },
      ],
    },
    {
      name: 'remove',
      returns: '',
      args: [
        {
          name: 'obj',
          swiftType: 'Any'
        },
        {
          name: 'sub',
          swiftType: 'Detachable',
        },
      ],
    },
    {
      name: 'eof',
      returns: '',
      args: [],
    },
    {
      name: 'reset',
      returns: '',
      args: [
        {
          name: 'sub',
          swiftType: 'Detachable',
        },
      ],
    }
  ]
});


foam.CLASS({
  package: 'foam.dao',
  name: 'ProxySink',
  implements: [ 'foam.dao.Sink' ],

  documentation: 'Proxy for Sink interface.',

  properties: [
    {
      class: 'Proxy',
      of: 'foam.dao.Sink',
      name: 'delegate',
      factory: function() { return foam.dao.ArraySink.create(); }
    }
  ]
});


foam.CLASS({
  package: 'foam.dao',
  name: 'AbstractSink',
  implements: [ 'foam.dao.Sink' ],

  documentation: 'Abstract base class for implementing Sink interface.',

  methods: [
    {
      name: 'put',
      code: function() {},
      swiftCode: '// NOOP',
    },
    {
      name: 'remove',
      code: function() {},
      swiftCode: '// NOOP',
    },
    {
      name: 'eof',
      code: function() {},
      swiftCode: '// NOOP',
    },
    {
      name: 'reset',
      code: function() {},
      swiftCode: '// NOOP',
    }
  ]
});


foam.CLASS({
  package: 'foam.dao',
  name: 'PipeSink',
  extends: 'foam.dao.ProxySink',
  axioms: [
    {
      class: 'foam.box.Remote',
      clientClass: 'foam.dao.ClientSink'
    }
  ],
  properties: [
    'dao'
  ],
  methods: [
    function reset(sub) {
      this.SUPER(sub);
      this.dao.select(this.delegate);
    }
  ]
});


foam.CLASS({
  package: 'foam.dao',
  name: 'ResetListener',
  extends: 'foam.dao.ProxySink',
  documentation: 'Turns all sink events into a reset event.',
  methods: [
    {
      name: 'put',
      code: function put(_, sub) {
        this.reset(sub);
      },
      swiftCode: 'reset(sub)',
    },
    {
      name: 'remove',
      code: function remove(_, sub) {
        this.reset(sub);
      },
      swiftCode: 'reset(sub)',
    },
  ]
});


foam.CLASS({
  package: 'foam.dao',
  name: 'DAOSlot',
  implements: ['foam.core.Slot'],
  extends: 'foam.dao.ResetListener',
  properties: [
    {
      name: 'dao',
      postSet: function() {
        this.start_();
      }
    },
    {
      name: 'sink',
      postSet: function(_, s) {
        this.value = s;
        this.start_();
      }
    },
    {
      name: 'value'
    },
    {
      name: 'subscription',
      postSet: function(old, nu) {
        old && old.detach();
        this.onDetach(nu);
      }
    },
    {
      class: 'Int',
      name: 'batch',
      value: 0
    }
  ],

  methods: [
    function sub(l) {
      return arguments.length === 1 ?
        this.SUPER('propertyChange', 'value', l) :
        this.SUPER.apply(this, arguments);
    },

    function get() { return this.value; },

    function set() {},

    function start_() {
      // Don't start till both sink and dao are set.
      if ( ! this.dao || ! this.sink ) return;

      this.subscription = this.dao.listen(this);
      this.update();
    },

    function reset() {
      this.update();
    }
  ],
  listeners: [
    {
      name: 'update',
      isMerged: 100,
      code: function() {
        var batch = ++this.batch;
        var self = this;
        this.dao.select(this.sink.clone()).then(function(s) {
          if ( self.batch !== batch ) return;

          self.value = s;
        });
      }
    }
  ]
});


foam.CLASS({
  package: 'foam.dao',
  name: 'QuickSink',
  extends: 'foam.dao.AbstractSink',

  axioms: [
    {
      class: 'foam.box.Remote',
      clientClass: 'foam.dao.ClientSink'
    }
  ],
  properties: [
    {
      class: 'Function',
      name: 'putFn'
    },
    {
      class: 'Function',
      name: 'removeFn'
    },
    {
      class: 'Function',
      name: 'eofFn'
    },
    {
      class: 'Function',
      name: 'resetFn'
    }
  ],

  methods: [
    function put() {
      return this.putFn && this.putFn.apply(this, arguments);
    },

    function remove() {
      return this.removeFn && this.removeFn.apply(this, arguments);
    },

    function eof() {
      return this.eofFn && this.eofFn.apply(this, arguments);
    },

    function reset() {
      return this.resetFn && this.resetFn.apply(this, arguments);
    }
  ]
});


foam.CLASS({
  package: 'foam.dao',
  name: 'AnonymousSink',
  implements: [ 'foam.dao.Sink' ],

  axioms: [
    {
      class: 'foam.box.Remote',
      clientClass: 'foam.dao.ClientSink'
    }
  ],

  properties: [ 'sink' ],

  methods: [
    function put(obj, sub) {
      var s = this.sink;
      s && s.put && s.put(obj, sub);
    },
    function remove(obj, sub) {
      var s = this.sink;
      s && s.remove && s.remove(obj, sub);
    },

    function eof() {
      var s = this.sink;
      s && s.eof && s.eof();
    },
    function reset(sub) {
      var s = this.sink;
      s && s.reset && s.reset(sub);
    }
  ]
});


foam.CLASS({
  package: 'foam.dao',
  name: 'PredicatedSink',
  extends: 'foam.dao.ProxySink',

  properties: [
    {
      class: 'FObjectProperty',
      of: 'foam.mlang.predicate.Predicate',
      required: true,
      name: 'predicate'
    }
  ],

  methods: [
    {
      name: 'put',
      code: function put(obj, sub) {
        if ( this.predicate.f(obj) ) this.delegate.put(obj, sub);
      },
      swiftCode: 'if predicate.f(obj) { delegate.put(obj, sub) }'
    },
    {
      name: 'remove',
      code: function remove(obj, sub) {
        if ( this.predicate.f(obj) ) this.delegate.remove(obj, sub);
      },
      swiftCode: 'if predicate.f(obj) { delegate.remove(obj, sub) }'
    }
  ]
});


foam.CLASS({
  package: 'foam.dao',
  name: 'LimitedSink',
  extends: 'foam.dao.ProxySink',

  properties: [
    {
      class: 'Long',
      name: 'limit'
    },
    {
      name: 'count',
      class: 'Int',
      value: 0
    }
  ],

  methods: [
    {
      name: 'put',
      code: function put(obj, sub) {
        if ( this.count++ >= this.limit ) {
          sub && sub.detach();
        } else {
          this.delegate.put(obj, sub);
        }
      },
      swiftCode: function() {/*
count += 1
if count <= limit {
  delegate.put(obj, sub)
}
      */}
    },
    {
      name: 'remove',
      code: function remove(obj, sub) {
        if ( this.count++ >= this.limit ) {
          sub && sub.detach();
        } else {
          this.delegate.remove(obj, sub);
        }
      },
      swiftCode: function() {/*
count += 1
if count <= limit {
  delegate.remove(obj, sub)
}
      */}
    }
  ]
});


foam.CLASS({
  package: 'foam.dao',
  name: 'SkipSink',
  extends: 'foam.dao.ProxySink',

  properties: [
    {
      class: 'Long',
      name: 'skip'
    },
    {
      name: 'count',
      class: 'Int',
      value: 0
    }
  ],

  methods: [
    {
      name: 'put',
      code: function put(obj, sub) {
        if ( this.count < this.skip ) {
          this.count++;
          return;
        }

        this.delegate.put(obj, sub);
      },
      swiftCode: function() {/*
if count < skip {
  count += 1
  return
}
delegate.put(obj, sub)
      */}
    },
    {
      name: 'remove',
      code: function remove(obj, sub) {
        this.reset(sub);
      },
      swiftCode: function() {/*
if count < skip {
  count += 1
  return
}
delegate.remove(obj, sub)
      */}
    },
    {
      name: 'reset',
      code: function(sub) {
        this.count = 0;
        this.delegate.reset(sub);
      },
      swiftCode: function() {/*
count = 0;
delegate.reset(sub);
      */},
    }
  ]
});


foam.CLASS({
  package: 'foam.dao',
  name: 'OrderedSink',
  extends: 'foam.dao.ProxySink',

  properties: [
    {
      class: 'FObjectProperty',
      of: 'foam.mlang.order.Comparator',
      required: true,
      name: 'comparator'
    },
    {
      class: 'List',
      name: 'array',
      factory: function() { return []; }
    }
  ],

  methods: [
    {
      name: 'put',
      code: function put(obj, sub) {
        this.array.push(obj);
      },
      swiftCode: 'array.append(obj)',
    },
    {
      name: 'eof',
      code: function eof() {
        var comparator = this.comparator;
        this.array.sort(function(o1, o2) {
          return comparator.compare(o1, o2);
        });

        var sub = foam.core.FObject.create();
        var detached = false;
        sub.onDetach(function() { detached = true; });
        for ( var i = 0 ; i < this.array.length ; i++ ) {
          this.delegate.put(this.array[i], sub);
          if ( detached ) break;
        }
      },
      swiftCode: function() {/*
array.sort(by: {
  return comparator.compare($0, $1) == 0
});

var detached = false
let sub = Subscription { detached = true }
for obj in array {
  delegate.put(obj as! FObject, sub)
  if detached { break }
}
      */}
    },
    {
      name: 'remove',
      code: function remove(obj, sub) {
        // TODO
      },
      swiftCode: '// TODO',
    },
  ]
});


foam.CLASS({
  package: 'foam.dao',
  name: 'DedupSink',
  extends: 'foam.dao.ProxySink',

  properties: [
    {
      class: 'Object',
      /** @private */
      name: 'results',
      javaType: 'java.util.HashSet',
      hidden: true,
      factory: function() { return {}; }
    }
  ],

  methods: [
    {
      /** If the object to be put() has already been seen by this sink,
        ignore it */
      name: 'put',
      code: function put(obj, sub) {
        if ( ! this.results[obj.id] ) {
          this.results[obj.id] = true;
          return this.delegate.put(obj, sub);
        }
      }
    }
  ]
});


foam.CLASS({
  package: 'foam.dao',
  name: 'DescribeSink',
  implements: [ 'foam.dao.Sink' ],

  documentation: 'Calls .describe() on every object.  Useful for debugging to quickly see what items are in a DAO.',

  methods: [
    function put(o) {
      o.describe();
    },
    function remove() {},
    function eof() {},
    function reset() {}
  ]
});


foam.CLASS({
  package: 'foam.dao',
  name: 'FnSink',
  implements: [ 'foam.dao.Sink' ],
  documentation: 'Converts all sink events to call to a singular function.' +
    '  Useful for subscribing a listener method to a DAO',

  axioms: [
    {
      class: 'foam.box.Remote',
      clientClass: 'foam.dao.ClientSink'
    }
  ],

  properties: [
    {
      name: 'fn',
      swiftType: '((String, Any?, Detachable) -> Void)',
      swiftRequiresEscaping: true,
    },
  ],

  methods: [
    {
      name: 'put',
      code: function(obj, s) {
        this.fn('put', obj, s);
      },
      swiftCode: 'fn("put", obj, sub)',
    },
    {
      name: 'remove',
      code: function(obj, s) {
        this.fn('remove', obj, s);
      },
      swiftCode: 'fn("remove", obj, sub)',
    },
    function eof() {
      this.fn('eof');
    },
    {
      name: 'reset',
      code: function(s) {
        this.fn('reset', s);
      },
      swiftCode: 'fn("reset", nil, sub)',
    },
  ]
});


foam.CLASS({
  package: 'foam.dao',
  name: 'FramedSink',
  extends: 'foam.dao.ProxySink',

  documentation: 'A proxy that waits until the next frame to flush the calls to the delegate.',

  properties: [
    { class: 'Array', name: 'calls' },
  ],

  methods: [
    {
      name: 'put',
      code: function(obj, s) {
        this.calls.push(['put', [obj, s]]);
        this.flushCalls();
      }
    },
    {
      name: 'remove',
      code: function(obj, s) {
        this.calls.push(['remove', [obj, s]]);
        this.flushCalls();
      }
    },
    {
      name: 'eof',
      code: function() {
        this.calls.push(['eof', []]);
        this.flushCalls();
      }
    },
    {
      name: 'reset',
      code: function(s) {
        this.calls = [['reset', [s]]];
        this.flushCalls();
      }
    }
  ],

  listeners: [
    {
      name: 'flushCalls',
      isMerged: 100,
      code: function() {
        var calls = this.calls;
        this.calls = [];
        for (var i = 0, o; o = calls[i]; i++) {
          this.delegate[o[0]].apply(this.delegate, o[1]);
        }
      }
    },
  ]
});


foam.CLASS({
  package: 'foam.dao',
  name: 'DAOSink',

  implements: [ 'foam.dao.Sink' ],

  properties: [
    { class: 'foam.dao.DAOProperty', name: 'dao' },
  ],

  axioms: [
    {
      class: 'foam.box.Remote',
      clientClass: 'foam.dao.ClientSink'
    }
  ],

  methods: [
    {
      name: 'put',
      code: function(o) {
        this.dao.put(o);
      },
      javaCode: `getDao().put((foam.core.FObject)obj);`,
      swiftCode: '_ = try? dao?.put(obj as! FObject)',
    },
    {
      name: 'remove',
      code: function(o) {
        this.dao.remove(o);
      },
      javaCode: `getDao().remove((foam.core.FObject)obj);`,
      swiftCode: '_ = try? dao?.remove(obj as! FObject)',
    },
    {
      name: 'eof',
      code: function() {},
      javaCode: ``,
      swiftCode: '// NOOP',
    },
    {
      name: 'reset',
      code: function() {
        this.dao.removeAll();
      },
      javaCode: `getDao().removeAll();`,
      swiftCode: '_ = try? dao?.removeAll()',
    }
  ]
});
/**
 * @license
 * Copyright 2016 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

foam.INTERFACE({
  package: 'foam.dao',
  name: 'DAO',

  documentation: 'DAO Interface',

  methods: [
    {
      name: 'put',
      returns: 'Promise',
      swiftReturns: 'FObject?',
      swiftThrows: true,
      args: [
        {
          name: 'obj',
          swiftType: 'FObject'
        }
      ],
    },
    {
      name: 'put_',
      returns: 'Promise',
      swiftReturns: 'FObject?',
      swiftThrows: true,
      args: [
        {
          name: 'x',
          swiftType: 'Context?'
        },
        {
          name: 'obj',
          swiftType: 'FObject'
        }
      ],
    },
    {
      name: 'remove',
      returns: 'Promise',
      swiftReturns: 'FObject?',
      swiftThrows: true,
      args: [
        {
          name: 'obj',
          swiftType: 'FObject'
        }
      ],
    },
    {
      name: 'remove_',
      returns: 'Promise',
      swiftReturns: 'FObject?',
      swiftThrows: true,
      args: [
        {
          name: 'x',
          swiftType: 'Context?'
        },
        {
          name: 'obj',
          swiftType: 'FObject'
        }
      ],
    },
    {
      name: 'find',
      returns: 'Promise',
      swiftReturns: 'FObject?',
      swiftThrows: true,
      args: [
        {
          name: 'id',
          swiftType: 'Any?'
        }
      ],
    },
    {
      name: 'find_',
      returns: 'Promise',
      swiftReturns: 'FObject?',
      swiftThrows: true,
      args: [
        {
          name: 'x',
          swiftType: 'Context?'
        },
        {
          name: 'id',
          swiftType: 'Any?'
        }
      ],
    },
    {
      name: 'select',
      returns: 'Promise',
      swiftReturns: 'Sink',
      swiftThrows: true,
      args: [
        {
          name: 'sink',
          swiftType: 'Sink',
        },
      ],
    },
    {
      name: 'select_',
      returns: 'Promise',
      swiftReturns: 'Sink',
      swiftThrows: true,
      args: [
        {
          name: 'x',
          swiftType: 'Context?'
        },
        {
          name: 'sink',
          swiftType: 'Sink',
          swiftDefaultValue: 'ArraySink()',
        },
        {
          name: 'skip',
          swiftType: 'Int',
          swiftDefaultValue: '0',
        },
        {
          name: 'limit',
          swiftType: 'Int',
          swiftDefaultValue: 'Int.max',
        },
        {
          name: 'order',
          swiftType: 'Comparator?',
          swiftDefaultValue: 'nil',
        },
        {
          name: 'predicate',
          swiftType: 'FoamPredicate?',
          swiftDefaultValue: 'nil',
        }
      ],
    },
    {
      name: 'removeAll',
      returns: '',
      swiftThrows: true,
      args: [ ]
    },
    {
      name: 'removeAll_',
      returns: '',
      swiftThrows: true,
      args: [
        {
          name: 'x',
          swiftType: 'Context?'
        },
        {
          name: 'skip',
          swiftType: 'Int?',
          swiftDefaultValue: 'nil',
        },
        {
          name: 'limit',
          swiftType: 'Int?',
          swiftDefaultValue: 'nil',
        },
        {
          name: 'order',
          swiftType: 'Comparator?',
          swiftDefaultValue: 'nil',
        },
        {
          name: 'predicate',
          swiftType: 'FoamPredicate?',
          swiftDefaultValue: 'nil',
        }
      ],
    },
    {
      name: 'listen',
      returns: '',
      swiftReturns: 'Detachable',
      swiftThrows: true,
      args: [
        {
          name: 'sink',
          swiftType: 'Sink',
          swiftDefaultValue: 'ArraySink()',
        },
        {
          name: 'predicate',
          swiftType: 'FoamPredicate?',
          swiftDefaultValue: 'nil',
        }
      ],
    },
    {
      name: 'listen_',
      returns: '',
      swiftReturns: 'Detachable',
      swiftThrows: true,
      args: [
        {
          name: 'x',
          swiftType: 'Context?'
        },
        {
          name: 'sink',
          swiftType: 'Sink',
          swiftDefaultValue: 'ArraySink()',
        },
        {
          name: 'predicate',
          swiftType: 'FoamPredicate?',
          swiftDefaultValue: 'nil',
        }
      ],
    },
    {
      name: 'pipe', // TODO: return a promise? don't put pipe and listen here?
      returns: '',
      swiftThrows: true,
      args: [
        {
          name: 'sink',
          swiftType: 'Sink'
        }
      ],
    },
    {
      name: 'pipe_', // TODO: return a promise? don't put pipe and listen here?
      returns: '',
      swiftThrows: true,
      args: [
        {
          name: 'x',
          swiftType: 'Context?'
        },
        {
          name: 'sink',
          swiftType: 'Sink'
        },
        {
          name: 'predicate',
          swiftType: 'FoamPredicate?',
          swiftDefaultValue: 'nil',
        },
      ],
    },
    {
      name: 'where',
      returns: 'foam.dao.DAO',
      swiftThrows: true,
      args: [
        {
          name: 'predicate',
          swiftType: 'FoamPredicate?',
          swiftDefaultValue: 'nil',
        }
      ],
    },
    {
      name: 'orderBy',
      returns: 'foam.dao.DAO',
      swiftThrows: true,
      args: [
        {
          name: 'comparator',
          swiftType: 'Comparator'
        }
      ],
    },
    {
      name: 'skip',
      returns: 'foam.dao.DAO',
      swiftThrows: true,
      args: [
        {
          name: 'count',
          swiftType: 'Int'
        }
      ],
    },
    {
      name: 'limit',
      returns: 'foam.dao.DAO',
      swiftThrows: true,
      args: [
        {
          name: 'count',
          swiftType: 'Int'
        }
      ],
    },
    {
      name: 'inX',
      swiftSupport: false,
      returns: 'foam.dao.DAO',
      args: [ 'x' ]
    },
    {
      name: 'cmd',
      swiftSupport: false,
      returns: 'obj',
      args: [ 'obj' ]
    },
    {
      name: 'cmd_',
      swiftSupport: false,
      returns: 'obj',
      args: [ 'x', 'obj' ]
    }
  ]
});
/**
 * @license
 * Copyright 2016 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

foam.CLASS({
  package: 'foam.dao',
  name: 'ProxyDAO',
  extends: 'foam.dao.AbstractDAO',

  requires: [
    'foam.dao.NullDAO',
    'foam.dao.ProxyListener',
  ],

  documentation: 'Proxy implementation for the DAO interface.',

  properties: [
    {
      class: 'Proxy',
      of: 'foam.dao.DAO',
      name: 'delegate',
      forwards: [ 'put_', 'remove_', 'find_', 'select_', 'removeAll_', 'cmd_', 'listen_' ],
      topics: [ 'on' ], // TODO: Remove this when all users of it are updated.
      factory: function() { return this.NullDAO.create() },
      postSet: function(old, nu) {
        if ( old ) this.on.reset.pub();
      },
      swiftFactory: 'return NullDAO_create()',
      swiftPostSet: `
if let oldValue = oldValue as? AbstractDAO {
  _ = oldValue.on["reset"].pub()
}
      `,
    },
    {
      name: 'of',
      factory: function() {
        return this.delegate.of;
      },
      swiftExpressionArgs: ['delegate$of'],
      swiftExpression: 'return delegate$of as! ClassInfo',
      javaFactory: `return getDelegate().getOf();`,
    }
  ],

  methods: [
    {
      name: 'listen',
      code: function listen(sink) {
        if ( ! foam.core.FObject.isInstance(sink) ) {
          sink = foam.dao.AnonymousSink.create({ sink: sink }, this);
        }

        var listener = this.ProxyListener.create({
          delegate: sink,
          dao: this
        });

        listener.onDetach(this.sub('propertyChange', 'delegate', listener.update));
        listener.update();

        return listener;
      },
      swiftCode: `
let listener = ProxyListener_create([
  "delegate": sink
])

listener.onDetach(listener.dao$.follow(delegate$))

return listener
      `,
      javaCode: `
// TODO: Support changing of delegate
super.listen(sink, predicate);
`
    }
  ],

  axioms: [
    {
      buildJavaClass: function(cls) {
        cls.extras.push(`
public ProxyDAO(foam.core.X x, foam.dao.DAO delegate) {
  foam.nanos.logger.Logger log = (foam.nanos.logger.Logger)x.get("logger");
  log.warning("Direct constructor use is deprecated. Use Builder instead.");
  setX(x);
  setDelegate(delegate);
}
        `);
      },
    },
  ],
});


foam.CLASS({
  package: 'foam.dao',
  name: 'ProxyListener',

  implements: ['foam.dao.Sink'],

  properties: [
    'args',
    {
      class: 'Proxy',
      of: 'foam.dao.Sink',
      name: 'delegate',
    },
    {
      name: 'innerSub',
      swiftType: 'Detachable?',
      postSet: function(_, s) {
        if (s) this.onDetach(s);
      },
      swiftPostSet: 'if let s = newValue { onDetach(s) }',
    },
    {
      name: 'dao',
      swiftType: 'DAO?',
      swiftPostSet: `
self.innerSub?.detach()
try? self.innerSub = newValue?.listen(self, args as? FoamPredicate)
if oldValue != nil {
  self.reset(Subscription(detach: {}))
}
      `
    }
  ],

  methods: [
    {
      name: 'put',
      code: function put(obj, s) {
        this.delegate.put(obj, this);
      },
      swiftCode: 'delegate.put(obj, self)',
    },

    function outputJSON(outputter) {
      outputter.output(this.delegate);
    },

    {
      name: 'remove',
      code: function remove(obj, s) {
        this.delegate.remove(obj, this);
      },
      swiftCode: 'delegate.remove(obj, self)',
    },

    {
      name: 'reset',
      code: function reset(s) {
        this.delegate.reset(this);
      },
      swiftCode: 'delegate.reset(self)',
    },
  ],
  listeners: [
    {
      name: 'update',
      code: function() {
        var old = this.innerSub;
        old && old.detach();
        this.innerSub = this.dao && this.dao.listen_(this.dao.__context__, this);
        if ( old ) this.reset();
      }
    }
  ]
});


foam.CLASS({
  package: 'foam.dao',
  name: 'ArraySink',
  extends: 'foam.dao.AbstractSink',

  constants: {
    // Dual to outputJSON method.
    //
    // TODO(markdittmer): Turn into static method: "parseJSON" once
    // https://github.com/foam-framework/foam2/issues/613 is fixed.
    PARSE_JSON: function(json, opt_cls, opt_ctx) {
      var cls = json.of || opt_cls;
      var array = json.array;
      if ( ! array ) return foam.dao.ArraySink.create({ of: cls }, opt_ctx);
      if ( foam.typeOf(cls) === foam.String )
        cls = ( opt_ctx || foam ).lookup(cls);

      return foam.dao.ArraySink.create({
        of: cls,
        array: foam.json.parse(array, cls, opt_ctx)
      }, opt_ctx);
    }
  },

  properties: [
    {
      class: 'List',
      name: 'array',
      adapt: function(old, nu) {
        if ( ! this.of ) return nu;
        var cls = this.of;
        for ( var i = 0; i < nu.length; i++ ) {
          if ( ! cls.isInstance(nu[i]) )
            nu[i] = cls.create(nu[i], this.__subContext__);
        }
        return nu;
      },
      factory: function() { return []; },
      javaFactory: `return new java.util.ArrayList();`
    },
    {
      class: 'Class',
      name: 'of'
    },
    {
      name: 'a',
      transient: true,
      getter: function() {
        this.warn('Use of deprecated ArraySink.a');
        return this.array;
      }
    }
  ],

  methods: [
    {
      name: 'put',
      code: function put(o, sub) {
        var cls = this.of;
        if ( ! cls ) {
          this.array.push(o);
          return;
        }
        if ( cls.isInstance(o) )
          this.array.push(o);
        else
          this.array.push(cls.create(o, this.__subContext__));
      },
      swiftCode: 'array.append(obj)',
      javaCode: 'if ( getArray() == null ) setArray(new java.util.ArrayList());\n'
                +`getArray().add(obj);`
    },
    function outputJSON(outputter) {
      outputter.start('{');
      var outputClassName = outputter.outputClassNames;
      if ( outputClassName ) {
        outputter.nl().indent().out(
            outputter.maybeEscapeKey('class'), ':', outputter.postColonStr, '"',
            this.cls_.id, '"');
      }

      var array = this.array;
      var outputComma = outputClassName;
      if ( this.of ) {
        outputter.outputProperty(this, this.OF, outputComma);
        outputComma = true;
      }
      if ( array.length > 0 ) {
        if ( outputComma ) outputter.out(',');
        outputter.nl().indent().outputPropertyName(this.ARRAY).
            out(':', outputter.postColonStr).output(array, this.of);
      }
      outputter.nl().end('}');
    }
  ]
});


foam.CLASS({
  package: 'foam.dao',
  name: 'PromisedDAO',
  extends: 'foam.dao.AbstractDAO',

  properties: [
    {
      class: 'Promised',
      of: 'foam.dao.DAO',
      methods: [ 'put_', 'remove_', 'find_', 'select_', 'removeAll_', 'listen_', 'cmd_' ],
      name: 'promise'
    }
  ]
});


foam.CLASS({
  package: 'foam.dao',
  name: 'LocalStorageDAO',
  extends: 'foam.dao.ArrayDAO',

  properties: [
    {
      name:  'name',
      label: 'Store Name',
      class:  'foam.core.String'
    }
  ],

  methods: [
    function init() {
      var objs = localStorage.getItem(this.name);
      if ( objs ) this.array = foam.json.parseString(objs, this);

      this.on.put.sub(this.updated);
      this.on.remove.sub(this.updated);

      // TODO: base on an indexed DAO
    }
  ],

  listeners: [
    {
      name: 'updated',
      isMerged: true,
      mergeDelay: 100,
      code: function() {
        localStorage.setItem(this.name, foam.json.stringify(this.array));
      }
    }
  ]
});


foam.LIB({
  name: 'foam.String',
  methods: [
    {
      name: 'daoize',
      code: foam.Function.memoize1(function(str) {
        // Turns SomeClassName into someClassNameDAO,
        // of package.ClassName into package.ClassNameDAO
        return str.substring(0, 1).toLowerCase() + str.substring(1) + 'DAO';
      })
    }
  ]
});


foam.CLASS({
  package: 'foam.dao',
  name: 'InvalidArgumentException',
  extends: 'foam.dao.ExternalException',

  properties: [
    {
      class: 'String',
      name: 'message'
    }
  ]
});
/**
 * @license
 * Copyright 2016 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

foam.INTERFACE({
  package: 'foam.dao',
  name: 'DAODecorator',

  methods: [
    {
      name: 'write',
      returns: 'Promise',
      javaReturns: 'foam.core.FObject',
      args: [
        {
          name: 'context'
        },
        {
          name: 'dao'
        },
        {
          name: 'obj',
          javaType: 'foam.core.FObject'
        },
        {
          name: 'existing',
          javaType: 'foam.core.FObject'
        }
      ]
    },
    {
      name: 'read',
      returns: 'Promise',
      javaReturns: 'foam.core.FObject',
      args: [
        {
          name: 'context'
        },
        {
          name: 'dao'
        },
        {
          name: 'obj',
          javaType: 'foam.core.FObject'
        }
      ]
    },
    {
      name: 'remove',
      returns: 'Promise',
      javaReturns: 'foam.core.FObject',
      args: [
        {
          name: 'context'
        },
        {
          name: 'dao'
        },
        {
          name: 'obj',
          javaType: 'foam.core.FObject'
        }
      ]
    }
  ]
});


foam.CLASS({
  package: 'foam.dao',
  name: 'AbstractDAODecorator',
  implements: ['foam.dao.DAODecorator'],

  methods: [
    function write(X, dao, obj, existing) {
      return Promise.resolve(obj);
    },
    function read(X, dao, obj) {
      return Promise.resolve(obj);
    },
    function remove(X, dao, obj) {
      return Promise.resolve(obj);
    }
  ]
});


foam.CLASS({
  package: 'foam.dao',
  name: 'CompoundDAODecorator',

  implements: ['foam.dao.DAODecorator'],

  properties: [
    {
      class: 'Array',
      name: 'decorators'
    }
  ],

  methods: [
    function write(X, dao, obj, existing) {
      var i = 0;
      var d = this.decorators;

      return Promise.resolve(obj).then(function a(obj) {
        return d[i] ? d[i++].write(X, dao, obj, existing).then(a) : obj;
      });
    },

    function read(X, dao, obj) {
      var i = 0;
      var d = this.decorators;

      return Promise.resolve(obj).then(function a(obj) {
        return d[i] ? d[i++].read(X, dao, obj).then(a) : obj;
      });
    },

    function remove(X, dao, obj) {
      var i = 0;
      var d = this.decorators;

      return Promise.resolve(obj).then(function a(obj) {
        return d[i] ? d[i++].remove(X, dao, obj).then(a) : obj;
      });
    }
  ]
});


foam.CLASS({
  package: 'foam.dao',
  name: 'DecoratedDAO',
  extends: 'foam.dao.ProxyDAO',

  requires: [
    'foam.mlang.sink.Count',
    'foam.mlang.sink.GroupBy'
  ],

  properties: [
    {
//      class: 'FObjectProperty',
//      of: 'foam.dao.DAODecorator',
      name: 'decorator'
    },
    {
      class: 'foam.dao.DAOProperty',
      name: 'dao',
      factory: function() { return this.delegate; }
    }
  ],

  methods: [
    {
      name: 'put_',
      code: function(x, obj) {
        // TODO: obj.id can generate garbase, would be
        // slightly faster if DAO.find() could take an object
        // as well.
        var self = this;
        return ( ( ! obj.id ) ? Promise.resolve(null) : this.dao.find_(x, obj.id) ).then(function(existing) {
          return self.decorator.write(x, self.dao, obj, existing);
        }).then(function(obj) {
          return self.delegate.put_(x, obj);
        });
      }
    },

    {
      name: 'remove_',
      code: function(x, obj) {
        var self = this;
        return this.decorator.remove(x, self.dao, obj).then(function(obj) {
          if ( obj ) return self.delegate.remove_(x, obj);
          return Promise.resolve();
        });
      }
    },

    {
      name: 'find_',
      code: function(x, id) {
        var self = this;
        return this.delegate.find_(x, id).then(function(obj) {
          return self.decorator.read(x, self.dao, obj);
        });
      }
    },

    /*
    TODO: works, but is expensive, so shouldn't be used if decorator.read isn't set
    function select_(x, sink, skip, limit, order, predicate) {
      if ( ! sink ) sink = foam.dao.ArraySink.create();
      // No need to decorate if we're just counting.
      if ( this.Count.isInstance(sink) ) {
        return this.delegate.select_(x, sink, skip, limit, order, predicate);
      }

      // TODO: This is too simplistic, fix
      if ( this.GroupBy.isInstance(sink) ) {
        return this.delegate.select_(x, sink, skip, limit, order, predicate);
      }

      var self = this;

      return new Promise(function(resolve, reject) {
        var ps = [];

        self.delegate.select({
          put: function(o) {
            var p = self.decorator.read(x, self.dao, o);
            p.then(function(o) { sink.put(o); })
            ps.push(p);
          },
          eof: function() {
          }
        }, skip, limit, order, predicate).then(function() {
          Promise.all(ps).then(function() {
            resolve(sink);
          });
        })
      });
    }
    */

    // TODO: Select/removeAll support.  How do we do select
    // without breaking MDAO optimizations?
    // {
    //   name: 'select',
    //   code: function() {
    //   }
    // },
    // {
    //   name: 'removeAll',
    //   code: function() {
    //   }
    // }
  ]
});
/**
 * @license
 * Copyright 2016 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

foam.CLASS({
  package: 'foam.dao',
  name: 'AbstractDAO',
  implements: [ 'foam.dao.DAO' ],
  abstract: true,

  documentation: 'Abstract base class for implementing DAOs.',

  requires: [
    'foam.dao.ExternalException',
    'foam.dao.FilteredDAO',
    'foam.dao.InternalException',
    'foam.dao.LimitedDAO',
    'foam.dao.LimitedSink',
    'foam.dao.OrderedDAO',
    'foam.dao.OrderedSink',
    'foam.dao.PipeSink',
    'foam.dao.PredicatedSink',
    'foam.dao.ProxyDAO',
    'foam.dao.ResetListener',
    'foam.dao.SkipDAO',
    'foam.dao.SkipSink'
  ],

  topics: [
    {
      name: 'on',
      topics: [
        'put',
        'remove',
        'reset'
      ]
    }
  ],

  properties: [
    {
      /**
        Set to the name or class instance of the type of object the DAO
        will store.
      */
      class: 'Class',
      javaInfoType: 'foam.core.AbstractObjectPropertyInfo',
      javaType: 'foam.core.ClassInfo',
      name: 'of',
    },
    {
      javaType: 'foam.core.PropertyInfo',
      javaInfoType: 'foam.core.AbstractObjectPropertyInfo',
      swiftType: 'PropertyInfo',
      name: 'primaryKey',
      swiftExpressionArgs: ['of'],
      swiftExpression: 'return of.axiom(byName: "id") as! PropertyInfo',
      javaFactory: `
return getOf() == null ? null : (foam.core.PropertyInfo) getOf().getAxiomByName("id");
      `,
    },
  ],

  methods: [
    {
      /**
        Returns a filtered DAO that only returns objects which match the
        given predicate.
      */
      name: 'inX',
      code: function(x) {
        return this.ProxyDAO.create({delegate: this}, x);
      },
      javaCode: `return new ProxyDAO.Builder(x).setDelegate(this).build();`,
    },

    {
      /**
        Returns a filtered DAO that only returns objects which match the
        given predicate.
      */
      name: 'where',
      code: function where(p) {
        return this.FilteredDAO.create({
          delegate: this,
          predicate: p
        });
      },
      swiftCode: function() {/*
        return FilteredDAO_create([
          "delegate": self,
          "predicate": predicate,
        ]);
      */},
      javaCode: `
return new FilteredDAO(predicate, this);
      `,
    },

    {
      /**
        Returns a filtered DAO that orders select() by the given
        ordering.
      */
      name: 'orderBy',
      code: function orderBy() {
        return this.OrderedDAO.create({
          delegate: this,
          comparator: foam.compare.toCompare(Array.from(arguments))
        });
      },
      javaCode: `
return new OrderedDAO(comparator, this);
      `,
    },

    {
      /**
        Returns a filtered DAO that skips the given number of items
        on a select()
      */
      name: 'skip',
      code: function skip(/* Number */ s) {
        return this.SkipDAO.create({
          delegate: this,
          skip_: s
        });
      },
      swiftCode: function() {/*
return SkipDAO_create([
  "delegate": self,
  "skip_": count,
])
      */},
      javaCode: `
return new SkipDAO(count, this);
      `,
    },

    {
      /**
        Returns a filtered DAO that stops producing items after the
        given count on a select().
      */
      name: 'limit',
      code: function limit(/* Number */ l) {
        return this.LimitedDAO.create({
          delegate: this,
          limit_: l
        });
      },
      swiftCode: function() {/*
return LimitedDAO_create([
  "delegate": self,
  "limit_": count,
])
      */},
      javaCode: `
return new LimitedDAO(count, this);
      `,
    },

    {
      name: 'put',
      code: function(obj) {
        return this.put_(this.__context__, obj);
      },
      swiftCode: 'return try put_(__context__, obj)',
      javaCode: `return this.put_(this.getX(), obj);`,
    },

    /**
      Selects the contents of this DAO into a sink, then listens to keep
      the sink up to date. Returns a promise that resolves with the subscription.
      TODO: This will probably miss events that happen during the select but before the
      listen call.  We should check if this is the case and fix it if so.
    */
    {
      name: 'pipe',
      code: function(sink) {//, skip, limit, order, predicate) {
        this.pipe_(this.__context__, sink, undefined);
      },
      swiftCode: 'return try pipe_(__context__, sink)',
      javaCode: `this.pipe_(this.getX(), sink);`,
    },

    {
      name: 'pipe_',
      code: function(x, sink, predicate) {
        var dao = this;

        var sink = this.PipeSink.create({
          delegate: sink,
          dao: this
        });

        var sub = this.listen(sink); //, skip, limit, order, predicate);
        sink.reset();

        return sub;
      },
      javaCode: `
throw new UnsupportedOperationException();
      `,
    },

    {
      name: 'listen',
      code: function(sink) {
        if ( ! foam.core.FObject.isInstance(sink) ) {
          sink = foam.dao.AnonymousSink.create({ sink: sink }, this);
        }
        return this.listen_(this.__context__, sink, undefined);
      },
      swiftCode: 'return try listen_(__context__, sink)',
      javaCode: `this.listen_(this.getX(), sink, predicate);`,
    },

    /**
      Keeps the given sink up to date with changes to this DAO.
    */
    {
      name: 'listen_',
      code: function(x, sink, predicate) {
        var mySink = this.decorateListener_(sink, predicate);

        var sub = foam.core.FObject.create();

        sub.onDetach(this.on.sub(function(s, on, e, obj) {
          switch(e) {
            case 'put':
              mySink.put(obj, sub);
              break;
            case 'remove':
              mySink.remove(obj, sub);
              break;
            case 'reset':
              mySink.reset(sub);
              break;
          }
        }));

        return sub;
      },
      swiftCode: function() {/*
let mySink = decorateListener_(sink, predicate)
return on.sub(listener: { (sub: Subscription, args: [Any?]) -> Void in
  guard let topic = args[1] as? String else { return }
  switch topic {
    case "put":
      mySink.put(args.last as! FObject, sub)
      break
    case "remove":
      mySink.remove(args.last as! FObject, sub)
      break
    case "reset":
      mySink.reset(sub)
      break
    default:
      break
  }
})
      */},
      javaCode: `
sink = decorateListener_(sink, predicate);
listeners_.add(new DAOListener(sink, listeners_));
      `,
    },

    {
      name: 'decorateListener_',
      swiftReturns: 'Sink',
      javaReturns: 'Sink',
      args: [
        {
          name: 'sink',
          swiftType: 'Sink',
          javaType: 'Sink',
        },
        {
          name: 'predicate',
          swiftType: 'FoamPredicate?',
          javaType: 'foam.mlang.predicate.Predicate',
        },
      ],
      code: function decorateListener_(sink, predicate) {
        if ( predicate ) {
          return this.ResetListener.create({ delegate: sink });
        }

        return sink;
      },
      swiftCode: function() {/*
// TODO: There are probably optimizations we can make here
// but every time I try it comes out broken.  So for the time being,
// if you have any sort of skip/limit/order/predicate we will just
// issue reset events for everything.
if predicate != nil {
  return self.ResetListener_create(["delegate": sink])
}
return sink
      */},
      javaCode: `
if ( predicate != null ) {
  sink = new PredicatedSink(predicate, sink);
}

return sink;
      `,
    },

    /**
      Used by DAO implementations to apply filters to a sink, often in a
      select() or removeAll() implementation.
      @private
    */
    {
      name: 'decorateSink_',
      swiftReturns: 'Sink',
      javaReturns: 'foam.dao.Sink',
      args: [
        {
          name: 'sink',
          swiftType: 'Sink',
          javaType: 'foam.dao.Sink',
        },
        {
          name: 'skip',
          swiftType: 'Int?',
          javaType: 'long',
        },
        {
          name: 'limit',
          swiftType: 'Int?',
          javaType: 'long',
        },
        {
          name: 'order',
          swiftType: 'Comparator?',
          javaType: 'foam.mlang.order.Comparator',
        },
        {
          name: 'predicate',
          swiftType: 'FoamPredicate?',
          javaType: 'foam.mlang.predicate.Predicate',
        },
      ],
      code: function decorateSink_(sink, skip, limit, order, predicate) {
        if ( limit != undefined ) {
          sink = this.LimitedSink.create({
            limit: limit,
            delegate: sink
          });
        }

        if ( skip != undefined ) {
          sink = this.SkipSink.create({
            skip: skip,
            delegate: sink
          });
        }

        if ( order != undefined ) {
          sink = this.OrderedSink.create({
            comparator: order,
            delegate: sink
          });
        }

        if ( predicate != undefined ) {
          sink = this.PredicatedSink.create({
            predicate: predicate.partialEval ?
              predicate.partialEval() :
              predicate,
            delegate: sink
          });
        }

        return sink;
      },
      swiftCode: function() {/*
var sink = sink
if limit != nil {
  sink = LimitedSink_create([
    "limit": limit,
    "delegate": sink
  ])
}
if skip != nil {
  sink = SkipSink_create([
    "skip": skip,
    "delegate": sink
  ])
}
if order != nil {
  sink = OrderedSink_create([
    "comparator": order,
    "delegate": sink,
  ])
}
if predicate != nil {
  sink = PredicatedSink_create([
    "predicate": predicate,
    "delegate": sink,
  ])
}
return sink
      */},
      javaCode: `
return decorateSink(getX(), sink, skip, limit, order, predicate);
      `,
    },

    {
      name: 'remove',
      code: function remove(obj) {
        return this.remove_(this.__context__, obj);
      },
      swiftCode: 'return try remove_(__context__, obj)',
      javaCode: `return this.remove_(this.getX(), obj);`,
    },

    {
      name: 'removeAll',
      code: function removeAll() {
        return this.removeAll_(this.__context__, undefined, undefined, undefined, undefined);
      },
      swiftCode: 'return try removeAll_(__context__)',
      javaCode: `
this.removeAll_(this.getX(), 0, this.MAX_SAFE_INTEGER, null, null);
      `,
    },

    function compareTo(other) {
      if ( ! other ) return 1;
      return this === other ? 0 : foam.util.compare(this.$UID, other.$UID);
    },

    function prepareSink_(sink) {
      if ( ! sink ) return foam.dao.ArraySink.create();

      if ( foam.Function.isInstance(sink) )
        sink = {
          put: sink,
          eof: function() {}
        };
      else if ( sink == console || sink == console.log )
        sink = {
          put: function(o) { console.log(o, foam.json.Pretty.stringify(o)); },
          eof: function() {}
        };
      else if ( sink == global.document )
        sink = {
          put: function(o) { foam.u2.DetailView.create({data: o}).write(document); },
          eof: function() {}
        };

      if ( ! foam.core.FObject.isInstance(sink) ) {
        sink = foam.dao.AnonymousSink.create({ sink: sink });
      }

      return sink;
    },

    {
      name: 'select',
      code: function select(sink) {
        return this.select_(this.__context__, this.prepareSink_(sink), undefined, undefined, undefined, undefined);
      },
      swiftCode: 'return try select_(__context__, sink)',
      javaCode: `
sink = prepareSink(sink);
return this.select_(this.getX(), sink, 0, this.MAX_SAFE_INTEGER, null, null);
      `,
    },

    {
      name: 'find',
      code: function find(id) {
        return this.find_(this.__context__, id);
      },
      swiftCode: 'return try find_(__context__, id)',
      javaCode: `
// Temporary until DAO supports find_(Predicate) directly
if ( id instanceof foam.mlang.predicate.Predicate ) {
  java.util.List l = ((ListSink) this.where((foam.mlang.predicate.Predicate) id).limit(1).select(new ListSink())).getData();
  return l.size() == 1 ? (foam.core.FObject) l.get(0) : null;
}

return this.find_(this.getX(), id);
      `,
    },

    {
      name: 'cmd_',
      code: function cmd_(x, obj) {
        return undefined;
      },
      javaCode: `
// TODO
return null;
      `,
    },

    {
      name: 'cmd',
      code: function cmd(obj) {
        return this.cmd_(this.__context__, obj);
      },
      javaCode: `
return this.cmd_(this.getX(), obj);
      `,
    },

    // Placeholder functions to that selecting from DAO to DAO works.
    /** @private */
    function eof() {},

    /** @private */
    function reset() {},

    {
      name: 'removeAll_',
      javaCode: `
this.select_(x, new RemoveSink(x, this), skip, limit, order, predicate);
      `,
    },
  ],
  static: [
    {
      name: 'decorateSink',
      javaReturns: 'foam.dao.Sink',
      args: [
        {
          name: 'x',
          javaType: 'foam.core.X',
        },
        {
          name: 'sink',
          javaType: 'foam.dao.Sink',
        },
        {
          name: 'skip',
          javaType: 'long',
        },
        {
          name: 'limit',
          javaType: 'long',
        },
        {
          name: 'order',
          javaType: 'foam.mlang.order.Comparator',
        },
        {
          name: 'predicate',
          javaType: 'foam.mlang.predicate.Predicate',
        },
      ],
      javaCode: `
if ( ( limit > 0 ) && ( limit < AbstractDAO.MAX_SAFE_INTEGER ) ) {
  sink = new LimitedSink(limit, 0, sink);
}

if ( ( skip > 0 ) && ( skip < AbstractDAO.MAX_SAFE_INTEGER ) ) {
  sink = new SkipSink(skip, 0, sink);
}

if ( order != null ) {
  sink = new OrderedSink(order, null, sink);
}

if ( predicate != null ) {
  sink = new PredicatedSink(predicate, sink);
}

return sink;
      `,
    },
  ],
  axioms: [
    {
      buildJavaClass: function(cls) {
        cls.extras.push(`
public final static long MAX_SAFE_INTEGER = 9007199254740991l;

public Object getPK(foam.core.FObject obj) {
  return getPrimaryKey().get(obj);
}

protected class DAOListener implements foam.core.Detachable {
  protected Sink sink;
  protected java.util.Collection listeners;

  public DAOListener(Sink sink, java.util.Collection listeners) {
    this.sink = sink;
    this.listeners = listeners;
  }

  public void detach() {
    listeners.remove(this);
  }

  public void put(foam.core.FObject obj) {
    try {
      sink.put(obj, this);
    } catch (java.lang.Exception e) {
      detach();
    }
  }

  public void remove(foam.core.FObject obj) {
    try {
      sink.remove(obj, this);
    } catch (java.lang.Exception e) {
      detach();
    }
  }

  public void reset() {
    try {
      sink.reset(this);
    } catch (java.lang.Exception e) {
      detach();
    }
  }
}

protected java.util.List<DAOListener> listeners_ = new java.util.concurrent.CopyOnWriteArrayList<DAOListener>();

protected void onPut(foam.core.FObject obj) {
  java.util.Iterator<DAOListener> iter = listeners_.iterator();

  while ( iter.hasNext() ) {
    DAOListener s = iter.next();
    s.put(obj);
  }
}

protected void onRemove(foam.core.FObject obj) {
  java.util.Iterator<DAOListener> iter = listeners_.iterator();

  while ( iter.hasNext() ) {
    DAOListener s = iter.next();
    s.remove(obj);
  }
}

protected void onReset() {
  java.util.Iterator<DAOListener> iter = listeners_.iterator();

  while ( iter.hasNext() ) {
    DAOListener s = iter.next();
    s.reset();
  }
}

protected Sink prepareSink(Sink s) {
  return s == null ? new ListSink() : s;
}

public Sink select() {
  return select(null);
}

public static Sink decorateDedupSink_(Sink sink) {
  sink = new DedupSink(new java.util.HashSet(), sink);
  return sink;
}
        `);
      },
    },
  ],
});


foam.CLASS({
  package: 'foam.dao',
  name: 'InternalException',
  implements: ['foam.core.Exception']
});


foam.CLASS({
  package: 'foam.dao',
  name: 'ExternalException',
  implements: ['foam.core.Exception']
})


foam.CLASS({
  package: 'foam.dao',
  name: 'FilteredDAO',
  extends: 'foam.dao.AbstractDAO',

  requires: [
    'foam.mlang.predicate.And'
  ],

  properties: [
    {
      // TODO: FObjectProperty of Predicate. Doing this currently breaks java.
      swiftType: 'FoamPredicate',
      name: 'predicate',
      required: true
    },
    {
      name: 'of',
      factory: function() {
        return this.delegate.of;
      },
      swiftExpressionArgs: ['delegate$of'],
      swiftExpression: 'return delegate$of as! ClassInfo',
    },
    {
      class: 'Proxy',
      of: 'foam.dao.DAO',
      name: 'delegate',
      topics: [ 'on' ], // TODO: Remove this when all users of it are updated.
      forwards: [ 'put_', 'remove_', 'find_', 'select_', 'removeAll_', 'cmd_' ]
    }
  ],

  methods: [
    function find_(x, key) {
      var predicate = this.predicate;
      return this.delegate.find_(x, key).then(function(o) {
        return predicate.f(o) ? o : null;
      });
    },

    {
      name: 'select_',
      code: function(x, sink, skip, limit, order, predicate) {
        return this.delegate.select_(
          x, sink, skip, limit, order,
          predicate ?
            this.And.create({ args: [this.predicate, predicate] }) :
            this.predicate);
      },
      swiftCode: function() {/*
return try delegate.select_(
  x, sink, skip, limit, order,
  predicate != nil ?
    And_create(["args": [self.predicate, predicate!] ]) :
    self.predicate)
      */},
    },

    function removeAll_(x, skip, limit, order, predicate) {
      return this.delegate.removeAll_(
        x, skip, limit, order,
        predicate ?
          this.And.create({ args: [this.predicate, predicate] }) :
          this.predicate);
    },

    {
      name: 'listen_',
      code: function listen_(x, sink, predicate) {
        return this.delegate.listen_(
          x, sink,
          predicate ?
            this.And.create({ args: [this.predicate, predicate] }) :
            this.predicate);
      },
      swiftCode: `
return try delegate.listen_(
  x, sink,
  predicate != nil ?
    And_create(["args": [self.predicate, predicate]]) :
    predicate)
      `,
    },
  ]
});


foam.CLASS({
  package: 'foam.dao',
  name: 'OrderedDAO',
  extends: 'foam.dao.ProxyDAO',

  properties: [
    {
      name: 'comparator'
    }
  ],

  methods: [
    function select_(x, sink, skip, limit, order, predicate) {
      return this.delegate.select_(x, sink, skip, limit, order || this.comparator, predicate);
    },
    function removeAll_(x, skip, limit, order, predicate) {
      return this.delegate.removeAll_(x, skip, limit, order || this.comparator, predicate);
    }
  ]
});


foam.CLASS({
  package: 'foam.dao',
  name: 'SkipDAO',
  extends: 'foam.dao.ProxyDAO',

  properties: [
    {
      class: 'Int',
      name: 'skip_',
    }
  ],

  methods: [
    {
      name: 'select_',
      code: function select_(x, sink, skip, limit, order, predicate) {
        return this.delegate.select_(x, sink, this.skip_, limit, order, predicate);
      },
      swiftCode: function() {/*
return try delegate.select_(x, sink, skip_, limit, order, predicate)
      */},
    },
    function removeAll_(x, skip, limit, order, predicate) {
      return this.delegate.removeAll_(x, this.skip_, limit, order, predicate);
    }
  ]
});


foam.CLASS({
  package: 'foam.dao',
  name: 'LimitedDAO',
  extends: 'foam.dao.ProxyDAO',

  properties: [
    {
      class: 'Int',
      name: 'limit_'
    }
  ],

  methods: [
    {
      name: 'select_',
      code: function select_(x, sink, skip, limit, order, predicate) {
        return this.delegate.select_(
          x, sink, skip,
          limit !== undefined ? Math.min(this.limit_, limit) : this.limit_,
          order, predicate);
      },
      swiftCode: function() {/*
return try delegate.select_(
    x, sink, skip,
    min(limit_, limit),
    order, predicate);
      */},
    },

    function removeAll_(x, skip, limit, order, predicate) {
      return this.delegate.removeAll_(
        x, skip,
        limit !== undefined ? Math.min(this.limit_, limit) : this.limit_,
        order, predicate);
    }
  ]
});
/**
 * @license
 * Copyright 2016 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

foam.CLASS({
  package: 'foam.dao',
  name: 'DAOProperty',
  extends: 'FObjectProperty',

  documentation: 'Property for storing a reference to a DAO.',

  requires: [ 'foam.dao.ProxyDAO' ],

  properties: [
    {
      name: 'view',
      value: {class: 'foam.comics.InlineBrowserView'},
    },
    ['of', 'foam.dao.DAO']
  ],

  methods: [
    function installInProto(proto) {
      this.SUPER(proto);

      var name = this.name;
      var prop = this;

      Object.defineProperty(proto, name + '$proxy', {
        get: function daoProxyGetter() {
          var proxy = prop.ProxyDAO.create({delegate: this[name]});
          this[name + '$proxy'] = proxy;

          this.sub('propertyChange', name, function(_, __, ___, s) {
            proxy.delegate = s.get();
          });

          return proxy;
        },
        configurable: true
      });
    }
  ]
});
/**
  * @license
  * Copyright 2017 The FOAM Authors. All Rights Reserved.
  * http://www.apache.org/licenses/LICENSE-2.0
  */

foam.INTERFACE({
  package: 'foam.dao',
  name: 'SQLStatement',

  methods: [
    {
      name: 'createStatement',
      javaReturns: 'String'
    },
    {
      name: 'prepareStatement',
      javaReturns: 'void',
      javaThrows: ['java.sql.SQLException'],
      args: [
        {
          name: 'stmt',
          javaType: 'foam.dao.pg.IndexedPreparedStatement'
        }
      ]
    }
  ]
});/**
 * @license
 * Copyright 2017 The FOAM Authors. All Rights Reserved.
 * http://www.apache.org/licenses/LICENSE-2.0
 */

foam.INTERFACE({
  package: 'foam.mlang.order',
  name: 'Comparator',

  documentation: 'Interface for comparing two values: -1: o1 < o2, 0: o1 == o2, 1: o1 > o2.',

  methods: [
    {
      name: 'compare',
      swiftReturns: 'Int',
      args: [
        'o1',
        'o2'
      ]
    },
    {
      name: 'toIndex',
      args: [
        'tail'
      ]
    },
    {
      // TODO: why is this here?
      /** Returns remaning ordering without this first one, which may be the
        only one. */
      name: 'orderTail'
    },
    {
      // TODO: why is this here?
      /** The property, if any, sorted by this ordering. */
      name: 'orderPrimaryProperty'
    },
    {
      // TODO: why is this here?
      /** Returns 1 or -1 for ascending/descending */
      name: 'orderDirection'
    }
  ]
});
/**
 * @license
 * Copyright 2017 The FOAM Authors. All Rights Reserved.
 * http://www.apache.org/licenses/LICENSE-2.0
 */

// TODO(braden): Port the partialEval() code over here.

foam.CLASS({
  package: 'foam.mlang.sink',
  name: 'Count',
  extends: 'foam.dao.AbstractSink',
  implements: [ 'foam.core.Serializable' ],

  documentation: 'Sink which counts number of objects put().',

  properties: [
    {
      class: 'Long',
      name: 'value'
    }
  ],

  methods: [
    {
      name: 'put',
      code: function() { this.value++ },
      swiftCode: 'value+=1',
    },
    {
      name: 'remove',
      code: function() { this.value-- },
      swiftCode: 'value-=1',
    },
    {
      name: 'reset',
      code: function() { this.value = 0 },
      swiftCode: 'value = 0',
    },
    function toString() { return 'COUNT()'; }
  ]
});


foam.CLASS({
  package: 'foam.mlang.sink',
  name: 'NullSink',
  extends: 'foam.dao.AbstractSink',
  implements: ['foam.core.Serializable'],

  documentation: 'Null Pattern (do-nothing) Sink.',

  axioms: [
    foam.pattern.Singleton.create()
  ]
});


foam.INTERFACE({
  package: 'foam.mlang',
  name: 'F',

  documentation: 'F interface: f(obj) -> val.',

  methods: [
    {
      name: 'f',
      args: [
        'obj'
      ],
      swiftReturns: 'Any?',
    }
  ]
});

// Investigate: If we use "extends: 'foam.mlang.F'" it generates the content properly for both F and Expr.
// But we have the Constant that extends the AbstractExpr that implements Expr and in this case, the f method
// (that comes from the F) interface is "losing" its type and returning void instead of returning the same defined
// on the interface as it should.
foam.INTERFACE({
  package: 'foam.mlang',
  name: 'Expr',
  implements: [ 'foam.mlang.F' ],

  documentation: 'Expr interface extends F interface: partialEval -> Expr.',

  methods: [
    {
      name: 'partialEval'
    }
  ]
});


foam.CLASS({
  package: 'foam.mlang',
  name: 'ExprProperty',
  extends: 'FObjectProperty',

  documentation: 'Property for Expr values.',

  properties: [
    {
      name: 'adapt',
      value: function(_, o, p) { return p.adaptValue(o); }
    },
  ],

  methods: [
    function adaptValue(o) {
      if ( o === null )                           return foam.mlang.Constant.create({ value: null });
      if ( ! o.f && typeof o === 'function' )     return foam.mlang.predicate.Func.create({ fn: o });
      if ( typeof o !== 'object' )                return foam.mlang.Constant.create({ value: o });
      if ( o instanceof Date )                    return foam.mlang.Constant.create({ value: o });
      if ( Array.isArray(o) )                     return foam.mlang.Constant.create({ value: o });
      if ( foam.core.AbstractEnum.isInstance(o) ) return foam.mlang.Constant.create({ value: o });
      if ( foam.core.FObject.isInstance(o) ) {
           // TODO: Not all mlang expressions actually implement Expr
           // so we're just going to check for o.f
           //  ! foam.mlang.Expr.isInstance(o) )
        if ( ! foam.Function.isInstance(o.f) )      return foam.mlang.Constant.create({ value: o });
        return o;
      }

      console.error('Invalid expression value: ', o);
    }
  ]
});


foam.CLASS({
  package: 'foam.mlang',
  name: 'SinkProperty',
  extends: 'FObjectProperty',

  documentation: 'Property for Sink values.'
});


foam.INTERFACE({
  package: 'foam.mlang.predicate',
  name: 'Predicate',

  // Predicate is already a thing in Swift so avoid using that name.
  swiftName: 'FoamPredicate',

  documentation: 'Predicate interface: f(obj) -> boolean.',

  methods: [
    {
      name: 'f',
      swiftReturns: 'Bool',
      args: [
        'obj'
      ]
    },
    {
      name: 'partialEval',
      returns: 'foam.mlang.predicate.Predicate',
    },
    {
      name: 'toIndex',
      args: [
        'tail'
      ]
    },
    {
      name: 'toDisjunctiveNormalForm',
      returns: 'foam.mlang.predicate.Predicate',
    }
  ]
});


foam.CLASS({
  package: 'foam.mlang.predicate',
  name: 'PredicateProperty',
  extends: 'FObjectProperty',

  documentation: 'Property for Predicate values.',

  properties: [
    ['of', 'foam.mlang.predicate.Predicate'],
    {
      name: 'adapt',
      value: function(_, o) {
        if ( ! o.f && typeof o === "function" ) return foam.mlang.predicate.Func.create({ fn: o });
        return o;
      }
    }
  ]
});


foam.CLASS({
  package: 'foam.mlang.predicate',
  name: 'PredicateArray',
  extends: 'FObjectArray',

  documentation: 'Property for storing arrays of Predicates.',

  properties: [
    {
      name: 'of',
      value: 'foam.mlang.predicate.Predicate'
    },
    {
      name: 'adaptArrayElement',
      // TODO?: Make into a multi-method?
      value: function(o) {
        if ( o === null ) return foam.mlang.Constant.create({ value: o });
        if ( ! o.f && typeof o === "function" ) return foam.mlang.predicate.Func.create({ fn: o });
        if ( typeof o !== "object" ) return foam.mlang.Constant.create({ value: o });
        if ( Array.isArray(o) ) return foam.mlang.Constant.create({ value: o });
        if ( o === true ) return foam.mlang.predicate.True.create();
        if ( o === false ) return foam.mlang.predicate.False.create();
        if ( foam.core.FObject.isInstance(o) ) return o;
        console.error('Invalid expression value: ', o);
      }
    }
  ]
});


foam.CLASS({
  package: 'foam.mlang.predicate',
  name: 'AbstractPredicate',
  abstract: true,
  implements: [ 'foam.mlang.predicate.Predicate' ],

  documentation: 'Abstract Predicate base-class.',

  methods: [
    {
      name: 'toIndex',
      code: function() { },
      swiftCode: 'return',
    },

    {
      name: 'toDisjunctiveNormalForm',
      code: function() { return this },
      swiftCode: 'return self',
    },

    {
      name: 'partialEval',
      code: function() { return this },
      swiftCode: 'return self',
    },

    function reduceAnd(other) {
      return foam.util.equals(this, other) ? this : null;
    },

    function reduceOr(other) {
      return foam.util.equals(this, other) ? this : null;
    },

    function toString() { return this.cls_.name; }
  ]
});


foam.CLASS({
  package: 'foam.mlang',
  name: 'AbstractExpr',
  abstract: true,
  implements: [ 'foam.mlang.Expr' ],

  documentation: 'Abstract Expr base-class.',

  methods: [
    function partialEval() { return this; }
  ]
});


foam.CLASS({
  package: 'foam.mlang.predicate',
  name: 'True',
  extends: 'foam.mlang.predicate.AbstractPredicate',
  implements: [ 'foam.core.Serializable' ],

  documentation: 'Expression which always returns true.',

  axioms: [ foam.pattern.Singleton.create() ],

  methods: [
    {
      name: 'f',
      code: function() { return true; },
      swiftCode: 'return true',
    },
  ]
});


foam.CLASS({
  package: 'foam.mlang.predicate',
  name: 'False',
  extends: 'foam.mlang.predicate.AbstractPredicate',
  implements: ['foam.core.Serializable'],

  documentation: 'Expression which always returns false.',

  axioms: [ foam.pattern.Singleton.create() ],

  methods: [
    function f() { return false; }
  ]
});


foam.CLASS({
  package: 'foam.mlang.predicate',
  name: 'Unary',
  extends: 'foam.mlang.predicate.AbstractPredicate',
  abstract: true,

  documentation: 'Abstract Unary (single-argument) Predicate base-class.',

  properties: [
    {
      class: 'foam.mlang.ExprProperty',
      name: 'arg1'
    }
  ],

  methods: [
    function toIndex(tail) {
      return this.arg1 && this.arg1.toIndex(tail);
    },

    function toString() {
      return foam.String.constantize(this.cls_.name) +
          '(' + this.arg1.toString() + ')';
    }
  ]
});


foam.CLASS({
  package: 'foam.mlang.predicate',
  name: 'Binary',
  extends: 'foam.mlang.predicate.AbstractPredicate',
  abstract: true,

  documentation: 'Abstract Binary (two-argument) Predicate base-class.',

  properties: [
    {
      class: 'foam.mlang.ExprProperty',
      name: 'arg1'
    },
    {
      class: 'foam.mlang.ExprProperty',
      name: 'arg2',
      adapt: function(old, nu, prop) {
        var value = prop.adaptValue(nu);
        var arg1 = this.arg1;
        if ( foam.mlang.Constant.isInstance(value) && arg1 && arg1.adapt )
          value.value = this.arg1.adapt.call(null, old, value.value, arg1);

        return value;
      }
    }
  ],

  methods: [
    function toIndex(tail) {
      return this.arg1 && this.arg1.toIndex(tail);
    },

    function toString() {
      return foam.String.constantize(this.cls_.name) + '(' +
          this.arg1.toString() + ', ' +
          this.arg2.toString() + ')';
    }
  ]
});


foam.CLASS({
  package: 'foam.mlang.predicate',
  name: 'Nary',
  extends: 'foam.mlang.predicate.AbstractPredicate',
  abstract: true,

  documentation: 'Abstract n-ary (many-argument) Predicate base-class.',

  properties: [
    {
      class: 'foam.mlang.predicate.PredicateArray',
      name: 'args'
    }
  ],

  methods: [
    function toString() {
      var s = foam.String.constantize(this.cls_.name) + '(';
      for ( var i = 0 ; i < this.args.length ; i++ ) {
        var a = this.args[i];
        s += a.toString();
        if ( i < this.args.length - 1 ) s += ', ';
      }
      return s + ')';
    },
    function reduce_(args, shortCircuit, methodName) {
      for ( var i = 0; i < args.length - 1; i++ ) {
        for ( var j = i + 1; j < args.length; j++ ) {
          if ( args[i][methodName] ) {
            var newArg = args[i][methodName](args[j]);
            if ( newArg ) {
              if ( newArg === shortCircuit ) return shortCircuit;
              args[i] = newArg;
              args.splice(j, 1);
            }
          }
        }
      }
      return args;
    }
  ]
});


foam.CLASS({
  package: 'foam.mlang.predicate',
  name: 'Or',
  extends: 'foam.mlang.predicate.Nary',
  implements: [ 'foam.core.Serializable' ],

  documentation: 'Logical Or n-ary Predicate.',

  requires: [
    'foam.mlang.predicate.False',
    'foam.mlang.predicate.True'
  ],

  methods: [
    {
      name: 'f',
      code: function f(o) {
        for ( var i = 0 ; i < this.args.length ; i++ ) {
          if ( this.args[i].f(o) ) return true;
        }
        return false;
      },
      swiftCode: `
for arg in args {
  if arg.f(obj) { return true }
}
return false
      `,
    },

    function partialEval() {
      var newArgs = [];
      var updated = false;

      var TRUE  = this.True.create();
      var FALSE = this.False.create();

      for ( var i = 0 ; i < this.args.length ; i++ ) {
        var a    = this.args[i];
        var newA = this.args[i].partialEval();

        if ( newA === TRUE ) return TRUE;

        if ( this.cls_.isInstance(newA) ) {
          // In-line nested OR clauses
          for ( var j = 0 ; j < newA.args.length ; j++ ) {
            newArgs.push(newA.args[j]);
          }
          updated = true;
        }
        else {
          if ( newA !== FALSE ) {
            newArgs.push(newA);
          }
          if ( a !== newA ) updated = true;
        }
      }

      this.reduce_(newArgs, FALSE, 'reduceAnd');

      if ( newArgs.length === 0 ) return FALSE;
      if ( newArgs.length === 1 ) return newArgs[0];

      return updated ? this.cls_.create({ args: newArgs }) : this;
    },

    function toIndex(tail) { },

    function toDisjunctiveNormalForm() {
      // TODO: memoization around this process?
      // DNF our args, note if anything changes
      var oldArgs = this.args;
      var newArgs = [];
      var changed = false;
      for (var i = 0; i < oldArgs.length; i++ ) {
        var a = oldArgs[i].toDisjunctiveNormalForm();
        if ( a !== oldArgs[i] ) changed = true;
        newArgs[i] = a;
      }

      // partialEval will take care of nested ORs
      var self = this;
      if ( changed ) {
        self = this.clone();
        self.args = newArgs;
        self = self.partialEval();
      }

      return self;
    }
  ]
});


foam.CLASS({
  package: 'foam.mlang.predicate',
  name: 'And',
  extends: 'foam.mlang.predicate.Nary',
  implements: ['foam.core.Serializable'],

  documentation: 'Logical And n-ary Predicate.',

  requires: [
    'foam.mlang.predicate.Or'
  ],

  methods: [
    {
      name: 'f',
      code: function(o) {
        for ( var i = 0 ; i < this.args.length ; i++ ) {
          if ( ! this.args[i].f(o) ) return false;
        }
        return true;
      },
      swiftCode: function() {/*
for arg in args {
  if !arg.f(obj) { return false }
}
return true
      */},
    },

    function partialEval() {
      var newArgs = [];
      var updated = false;

      var FALSE = foam.mlang.predicate.False.create();
      var TRUE = foam.mlang.predicate.True.create();

      for ( var i = 0; i < this.args.length; i++ ) {
        var a    = this.args[i];
        var newA = this.args[i].partialEval();

        if ( newA === FALSE ) return FALSE;

        if ( this.cls_.isInstance(newA) ) {
          // In-line nested AND clauses
          for ( var j = 0 ; j < newA.args.length ; j++ ) {
            newArgs.push(newA.args[j]);
          }
          updated = true;
        }
        else {
          if ( newA === TRUE ) {
            updated = true;
          } else {
            newArgs.push(newA);
            if ( a !== newA ) updated = true;
          }
        }
      }

      this.reduce_(newArgs, TRUE, 'reduceOr');

      if ( newArgs.length === 0 ) return TRUE;
      if ( newArgs.length === 1 ) return newArgs[0];

      return updated ? this.cls_.create({ args: newArgs }) : this;
    },

    function toIndex(tail, depth) {
      /** Builds the ideal index for this predicate. The indexes will be chained
          in order of index uniqueness (put the most indexable first):
          This prevents dropping to scan mode too early, and restricts
          the remaning set more quickly.
           i.e. EQ, IN,... CONTAINS, ... LT, GT...
        @param depth {number} The maximum number of sub-indexes to chain.
      */
      depth = depth || 99;

      if ( depth === 1 ) {
        // generate indexes, find costs, use the fastest
        var bestCost = Number.MAX_VALUE;
        var bestIndex;
        var args = this.args;
        for (var i = 0; i < args.length; i++ ) {
          var arg = args[i];
          var idx = arg.toIndex(tail);
          if ( ! idx ) continue;

          var idxCost = Math.floor(idx.estimate(
             1000, undefined, undefined, undefined, undefined, arg));

          if ( bestCost > idxCost ) {
            bestIndex = idx;
            bestCost = idxCost;
          }
        }
        return bestIndex;

      } else {
        // generate indexes, sort by estimate, chain as requested
        var sortedArgs = Object.create(null);
        var costs = [];
        var args = this.args;
        var dupes = {}; // avoid duplicate indexes
        for (var i = 0; i < args.length; i++ ) {
          var arg = args[i];
          var idx = arg.toIndex(tail);
          if ( ! idx ) continue;

          // duplicate check
          var idxString = idx.toString();
          if ( dupes[idxString] ) continue;
          dupes[idxString] = true;

          var idxCost = Math.floor(idx.estimate(
             1000, undefined, undefined, undefined, undefined, arg));
          // make unique with a some extra digits
          var costKey = idxCost + i / 1000.0;
          sortedArgs[costKey] = arg;
          costs.push(costKey);
        }
        costs = costs.sort(foam.Number.compare);

        // Sort, build list up starting at the end (most expensive
        //   will end up deepest in the index)
        var tailRet = tail;
        var chainDepth = Math.min(costs.length - 1, depth - 1);
        for ( var i = chainDepth; i >= 0; i-- ) {
          var arg = sortedArgs[costs[i]];
          //assert(arg is a predicate)
          tailRet = arg.toIndex(tailRet);
        }

        return tailRet;
      }
    },

    function toDisjunctiveNormalForm() {
      // for each nested OR, multiply:
      // AND(a,b,OR(c,d),OR(e,f)) -> OR(abce,abcf,abde,abdf)

      var andArgs = [];
      var orArgs  = [];
      var oldArgs = this.args;
      for (var i = 0; i < oldArgs.length; i++ ) {
        var a = oldArgs[i].toDisjunctiveNormalForm();
        if ( this.Or.isInstance(a) ) {
          orArgs.push(a);
        } else {
          andArgs.push(a);
        }
      }

      if ( orArgs.length > 0 ) {
        var newAndGroups = [];
        // Generate every combination of the arguments of the OR clauses
        // orArgsOffsets[g] represents the array index we are lookig at
        // in orArgs[g].args[offset]
        var orArgsOffsets = new Array(orArgs.length).fill(0);
        var active = true;
        var idx = orArgsOffsets.length - 1;
        orArgsOffsets[idx] = -1; // compensate for intial ++orArgsOffsets[idx]
        while ( active ) {
          while ( ++orArgsOffsets[idx] >= orArgs[idx].args.length ) {
            // reset array index count, carry the one
            if ( idx === 0 ) { active = false; break; }
            orArgsOffsets[idx] = 0;
            idx--;
          }
          idx = orArgsOffsets.length - 1;
          if ( ! active ) break;

          // for the last group iterated, read back up the indexes
          // to get the result set
          var newAndArgs = [];
          for ( var j = orArgsOffsets.length - 1; j >= 0; j-- ) {
            newAndArgs.push(orArgs[j].args[orArgsOffsets[j]]);
          }
          newAndArgs = newAndArgs.concat(andArgs);

          newAndGroups.push(
            this.cls_.create({ args: newAndArgs })
          );
        }
        return this.Or.create({ args: newAndGroups }).partialEval();
      } else {
        // no OR args, no DNF transform needed
        return this;
      }
    }
  ]
});


foam.CLASS({
  package: 'foam.mlang.predicate',
  name: 'Contains',
  extends: 'foam.mlang.predicate.Binary',
  implements: [ 'foam.core.Serializable' ],

  documentation: 'Predicate returns true iff second arg found in first array argument.',

  methods: [
    {
      name: 'f',
      code: function(o) {
        var arg1 = this.arg1.f(o);
        var arg2 = this.arg2.f(o);
        if ( Array.isArray(arg1) ) {
          return arg1.some(function(a) {
            return a.indexOf(arg2) !== -1;
          })
        }
        return arg1 ? arg1.indexOf(arg2) !== -1 : false;      }
    }
  ]
});


foam.CLASS({
  package: 'foam.mlang.predicate',
  name: 'ContainsIC',
  extends: 'foam.mlang.predicate.Binary',
  implements: [ 'foam.core.Serializable' ],

  documentation: 'Predicate returns true iff second arg found in first array argument, ignoring case.',

  methods: [
    function f(o) {
      var arg1 = this.arg1.f(o);
      var arg2 = this.arg2.f(o).toUpperCase();
      if ( Array.isArray(arg1) ) {
        return arg1.some(function(a) {
          return a.toUpperCase().indexOf(arg2) !== -1;
        })
      }
      return arg1 ? arg1.toUpperCase().indexOf(arg2) !== -1 : false;
    },
  ]
});


foam.CLASS({
  package: 'foam.mlang.predicate',
  name: 'StartsWith',
  extends: 'foam.mlang.predicate.Binary',
  implements: [ 'foam.core.Serializable' ],

  documentation: 'Predicate returns true iff arg1 starts with arg2 or if arg1 is an array, if an element starts with arg2.',

  methods: [
    {
      name: 'f',
      code: function(o) {
        var arg1 = this.arg1.f(o);
        var arg2 = this.arg2.f(o);

        if ( Array.isArray(arg1) ) {
          return arg1.some(function(arg) {
            return arg.startsWith(arg2);
          });
        }

        return arg1.startsWith(arg2);
      }
    }
  ]
});


foam.CLASS({
  package: 'foam.mlang.predicate',
  name: 'StartsWithIC',
  extends: 'foam.mlang.predicate.Binary',
  implements: ['foam.core.Serializable'],

  documentation: 'Predicate returns true iff arg1 starts with arg2 or if arg1 is an array, if an element starts with arg2, ignoring case.',

  methods: [
    {
      name: 'f',
      code: function f(o) {
        var arg1 = this.arg1.f(o);
        var arg2 = this.arg2.f(o);

        if ( Array.isArray(arg1) ) {
          return arg1.some(function(arg) {
            return foam.String.startsWithIC(arg, arg2);
          });
        }

        return foam.String.startsWithIC(arg1, arg2);
      }
    }
  ]
});


foam.CLASS({
  package: 'foam.mlang.predicate',
  name: 'EndsWith',
  extends: 'foam.mlang.predicate.Binary',
  implements: [ 'foam.core.Serializable' ],

  documentation: 'Predicate returns true iff arg1 ends with arg2 or if arg1 is an array, if an element starts with arg2.',

  methods: [
    {
      name: 'f',
      code: function(o) {
        var arg1 = this.arg1.f(o);
        var arg2 = this.arg2.f(o);

        if ( Array.isArray(arg1) ) {
          return arg1.some(function(arg) {
            return arg.endsWith(arg2);
          });
        }

        return arg1.endsWith(arg2);
      }
    }
  ]
});


foam.CLASS({
  package: 'foam.mlang.predicate',
  name: 'ArrayBinary',
  extends: 'foam.mlang.predicate.Binary',
  abstract: true,

  documentation: 'Binary predicate that accepts an array in "arg2".',

  properties: [
    {
      name: 'arg2',
      postSet: function() {
        this.valueSet_ = null;
      },
      adapt: function(old, nu, prop) {
        var value = prop.adaptValue(nu);
        var arg1 = this.arg1;

        // Adapt constant array elements when:
        // (1) Value is a constant (array);
        // (2) Value is truthy (empty arrays can be serialized as undefined);
        // (3) Arg1 has an adapt().
        if ( foam.mlang.Constant.isInstance(value) && value.value &&
             arg1 && arg1.adapt ) {
          var arrayValue = value.value;
          for ( var i = 0; i < arrayValue.length; i++ ) {
            arrayValue[i] = arg1.adapt.call(null, old && old[i], arrayValue[i], arg1);
          }
        }

        return value;
      }
    },
    {
      // TODO: simpler to make an expression
      name: 'valueSet_'
    }
  ]
});


foam.CLASS({
  package: 'foam.mlang.predicate',
  name: 'In',
  extends: 'foam.mlang.predicate.ArrayBinary',
  implements: [
    'foam.core.Serializable',
    { path: 'foam.mlang.Expressions', java: false }
  ],

  documentation: 'Predicate returns true iff arg1 is a substring of arg2, or if arg2 is an array, arg1 is an element of arg2.',

  requires: [ 'foam.mlang.Constant' ],

  properties: [
    {
      name: 'arg1',
      postSet: function(old, nu) {
        // this is slightly slower when an expression on upperCase_
        this.upperCase_ = nu && foam.core.Enum.isInstance(nu);
      }
    },
    {
      name: 'upperCase_',
    }
  ],

  methods: [
    function f(o) {
      var lhs = this.arg1.f(o);
      var rhs = this.arg2.f(o);

      if ( ! rhs ) return false;

      for ( var i = 0 ; i < rhs.length ; i++ ) {
        var v = rhs[i];

        if ( foam.String.isInstance(v) && this.upperCase_ ) v = v.toUpperCase();
        if ( foam.util.equals(lhs, v) ) return true;
      }
      return false;

      // TODO: This is not a sufficient enough check for valueSet_.
      // We can have constants that contain other FObjects, in
      // particular with multi part id support.So this code path is
      // disabled for now.


      // If arg2 is a constant array, we use valueSet for it.
      if ( this.Constant.isInstance(this.arg2) ) {
        if ( ! this.valueSet_ ) {
          var set = {};
          for ( var i = 0 ; i < rhs.length ; i++ ) {
            var s = rhs[i];
            if ( this.upperCase_ ) s = s.toUpperCase();
            set[s] = true;
          }
          this.valueSet_ = set;
        }

        return !! this.valueSet_[lhs];
      }

      return rhs ? rhs.indexOf(lhs) !== -1 : false;
    },
    function partialEval() {
      if ( ! this.Constant.isInstance(this.arg2) ) return this;

      return ( ! this.arg2.value ) || this.arg2.value.length === 0 ?
          this.FALSE : this;
    }
  ]
});


foam.CLASS({
  package: 'foam.mlang.predicate',
  name: 'InIC',
  extends: 'foam.mlang.predicate.ArrayBinary',
  implements: [ 'foam.core.Serializable' ],

  documentation: 'Predicate returns true iff arg1 is a substring of arg2, or if arg2 is an array, is an element of arg2, case insensitive.',

  methods: [
    function f(o) {
      var lhs = this.arg1.f(o);
      var rhs = this.arg2.f(o);

      if ( lhs.toUpperCase ) lhs = lhs.toUpperCase();

      // If arg2 is a constant array, we use valueSet for it.
      if ( foam.mlang.Constant.isInstance(this.arg2) ) {
        if ( ! this.valueSet_ ) {
          var set = {};
          for ( var i = 0 ; i < rhs.length ; i++ ) {
            set[rhs[i].toUpperCase()] = true;
          }
          this.valueSet_ = set;
        }

        return !! this.valueSet_[lhs];
      } else {
        if ( ! rhs ) return false;
        return rhs.toUpperCase().indexOf(lhs) !== -1;
      }
    }
  ]
});


foam.CLASS({
  package: 'foam.mlang',
  name: 'Constant',
  extends: 'foam.mlang.AbstractExpr',
  implements: [ 'foam.core.Serializable' ],

  documentation: 'An Expression which always returns the same constant value.',

  properties: [
    {
      class: 'Object',
      name: 'value',
      adapt: function(_, nu) {
        // Deal with empty arrays that serialize as undefined.
        return foam.Undefined.isInstance(nu) ? [] : nu;
      },
    }
  ],

  methods: [
    {
      name: 'f',
      code: function() { return this.value; },
      swiftCode: `return value`,
    },

    function toString_(x) {
      return typeof x === 'number' ? '' + x :
        typeof x === 'string' ? '"' + x + '"' :
        Array.isArray(x) ? '[' + x.map(this.toString_.bind(this)).join(', ') + ']' :
        x.toString ? x.toString() :
        x;
    },

    function toString() { return this.toString_(this.value); },

    // TODO(adamvy): Re-enable when we can parse this in java more correctly.
    function xxoutputJSON(os) {
      os.output(this.value);
    }
  ]
});

foam.CLASS({
  package: 'foam.mlang',
  name: 'ArrayConstant',
  extends: 'foam.mlang.AbstractExpr',
  implements: [ 'foam.core.Serializable'],

  properties: [
    {
      class: 'Array',
      name: 'value'
    }
  ],

  methods: [
    function f() { return this.value; },

    function toString_(x) {
      return Array.isArray(x) ? '[' + x.map(this.toString_.bind(this)).join(', ') + ']' :
        x.toString ? x.toString :
        x;
    },

    function toString() { return this.toString_(this.value); }
  ]
});


foam.CLASS({
  package: 'foam.mlang.predicate',
  name: 'Func',
  extends: 'foam.mlang.predicate.AbstractPredicate',

  documentation: 'A function to Predicate adapter.',

  // TODO: rename FunctionPredicate

  properties: [
    {
      /** The function to apply to objects passed to this expression */
      name: 'fn'
    }
  ],

  methods: [
    function f(o) { return this.fn(o); },
    function toString() {
      return 'FUNC(' + fn.toString() + ')';
    }
  ]
});


/** Binary expression for equality of two arguments. */
foam.CLASS({
  package: 'foam.mlang.predicate',
  name: 'Eq',
  extends: 'foam.mlang.predicate.Binary',

  implements: [ 'foam.core.Serializable' ],

  documentation: 'Binary Predicate returns true iff arg1 EQUALS arg2.',

  methods: [
    {
      name: 'f',
      code: function(o) {
        var v1 = this.arg1.f(o);
        var v2 = this.arg2.f(o);

        // First check is so that EQ(Class.PROPERTY, null | undefined) works.
        return ( v1 === undefined && v2 === null ) || foam.util.equals(v1, v2);
      },
      swiftCode: `
let v1 = (arg1 as! Expr).f(obj)
let v2 = (arg2 as! Expr).f(obj)
return FOAM_utils.equals(v1, v2)
      `,
    },

    function reduceAnd(other) {
      var myArg1           = this.arg1;
      var myArg2           = this.arg2;
      var otherArg1        = other.arg1;
      var otherArg2        = other.arg2;
      var isConst          = foam.mlang.Constant.isInstance.bind(foam.mlang.Constant);
      var myArg1IsConst    = isConst(myArg1);
      var myArg2IsConst    = isConst(myArg2);
      var otherArg1IsConst = isConst(otherArg1);
      var otherArg2IsConst = isConst(otherArg2);

      // Require one const, one non-const in this and other.
      if ( myArg1IsConst === myArg2IsConst || otherArg1IsConst === otherArg2IsConst )
        return this.SUPER(other);

      // Require same expr.
      var myExpr    = myArg1IsConst ? myArg2 : myArg1;
      var otherExpr = otherArg1IsConst ? otherArg2 : otherArg1;
      var equals    = foam.util.equals;

      if ( ! equals(myExpr, otherExpr) ) return this.SUPER(other);

      // Reduce to FALSE when consts are not equal.
      var myConst    = myArg1IsConst    ? myArg1    : myArg2;
      var otherConst = otherArg1IsConst ? otherArg1 : otherArg2;

      return equals(myConst, otherConst) ? this.SUPER(other) : this.FALSE;
    }
  ]
});


/** Binary expression for inequality of two arguments. */
foam.CLASS({
  package: 'foam.mlang.predicate',
  name: 'Neq',
  extends: 'foam.mlang.predicate.Binary',
  implements: [ 'foam.core.Serializable' ],

  documentation: 'Binary Predicate returns true iff arg1 does NOT EQUAL arg2.',

  methods: [
    {
      name: 'f',
      code: function(o) {
        return ! foam.util.equals(this.arg1.f(o), this.arg2.f(o));
      }
    }
  ]
});


/** Binary expression for "strictly less than". */
foam.CLASS({
  package: 'foam.mlang.predicate',
  name: 'Lt',
  extends: 'foam.mlang.predicate.Binary',
  implements: [ 'foam.core.Serializable' ],

  documentation: 'Binary Predicate returns true iff arg1 is LESS THAN arg2.',

  methods: [
    {
      name: 'f',
      code: function(o) {
        return foam.util.compare(this.arg1.f(o), this.arg2.f(o)) < 0;
      }
    }
  ]
});


/** Binary expression for "less than or equal to". */
foam.CLASS({
  package: 'foam.mlang.predicate',
  name: 'Lte',
  extends: 'foam.mlang.predicate.Binary',
  implements: [ 'foam.core.Serializable' ],

  documentation: 'Binary Predicate returns true iff arg1 is LESS THAN or EQUAL to arg2.',

  methods: [
    {
      name: 'f',
      code: function(o) {
        return foam.util.compare(this.arg1.f(o), this.arg2.f(o)) <= 0;
      }
    }
  ]
});


/** Binary expression for "strictly greater than". */
foam.CLASS({
  package: 'foam.mlang.predicate',
  name: 'Gt',
  extends: 'foam.mlang.predicate.Binary',
  implements: [ 'foam.core.Serializable' ],

  documentation: 'Binary Predicate returns true iff arg1 is GREATER THAN arg2.',

  methods: [
    {
      name: 'f',
      code: function(o) {
        return foam.util.compare(this.arg1.f(o), this.arg2.f(o)) > 0;
      }
    }
  ]
});


/** Binary expression for "greater than or equal to". */
foam.CLASS({
  package: 'foam.mlang.predicate',
  name: 'Gte',
  extends: 'foam.mlang.predicate.Binary',
  implements: [ 'foam.core.Serializable' ],

  documentation: 'Binary Predicate returns true iff arg1 is GREATER THAN or EQUAL to arg2.',


  methods: [
    {
      name: 'f',
      code: function(o) {
        return foam.util.compare(this.arg1.f(o), this.arg2.f(o)) >= 0;
      }
    }
  ]
});


foam.CLASS({
  package: 'foam.mlang.predicate',
  name: 'Has',
  extends: 'foam.mlang.predicate.Unary',
  implements: [ 'foam.core.Serializable' ],

  documentation: 'Unary Predicate that returns true iff the given property has a value other than null, undefined, \'\', or [].',

  methods: [
    function f(obj) {
      var value = this.arg1.f(obj);

      return ! (
        value === undefined ||
        value === null      ||
        value === ''        ||
        (Array.isArray(value) && value.length === 0) );
    }
  ]
});


foam.CLASS({
  package: 'foam.mlang.predicate',
  name: 'Not',
  swiftName: 'NotPred',
  extends: 'foam.mlang.predicate.AbstractPredicate',
  implements: [ 'foam.core.Serializable' ],

  documentation: 'Unary Predicate which negates the value of its argument.',

  properties: [
    {
      class: 'foam.mlang.predicate.PredicateProperty',
      name: 'arg1'
    }
  ],

  methods: [
    function f(obj) { return ! this.arg1.f(obj); },

    function toString() {
      return foam.String.constantize(this.cls_.name) +
          '(' + this.arg1.toString() + ')';
    },

    /*
      TODO: this isn't ported to FOAM2 yet.
    function partialEval() {
      return this;
      var newArg = this.arg1.partialEval();

      if ( newArg === TRUE ) return FALSE;
      if ( newArg === FALSE ) return TRUE;
      if ( NotExpr.isInstance(newArg) ) return newArg.arg1;
      if ( EqExpr.isInstance(newArg)  ) return NeqExpr.create(newArg);
      if ( NeqExpr.isInstance(newArg) ) return EqExpr.create(newArg);
      if ( LtExpr.isInstance(newArg)  ) return GteExpr.create(newArg);
      if ( GtExpr.isInstance(newArg)  ) return LteExpr.create(newArg);
      if ( LteExpr.isInstance(newArg) ) return GtExpr.create(newArg);
      if ( GteExpr.isInstance(newArg) ) return LtExpr.create(newArg);

      return this.arg1 === newArg ? this : NOT(newArg);
    }*/
  ]
});


foam.CLASS({
  package: 'foam.mlang.predicate',
  name: 'Keyword',
  extends: 'foam.mlang.predicate.Unary',
  implements: [ 'foam.core.Serializable' ],

  documentation: 'Unary Predicate for generic keyword search (searching all String properties for argument substring).',

  requires: [
    {
      name: 'String',
      path: 'foam.core.String',
      flags: ['js'],
    },
  ],

  methods: [
    function f(obj) {
      var arg = this.arg1.f(obj);
      if ( ! arg || typeof arg !== 'string' ) return false;

      arg = arg.toLowerCase();

      var props = obj.cls_.getAxiomsByClass(this.String);
      for ( var i = 0; i < props.length; i++ ) {
        var s = props[i].f(obj);
        if ( ! s || typeof s !== 'string' ) continue;
        if ( s.toLowerCase().indexOf(arg) >= 0 ) return true;
      }

      return false;
    }
  ]
});


/** Map sink transforms each put with a given mapping expression. */
foam.CLASS({
  package: 'foam.mlang.sink',
  name: 'Map',
  extends: 'foam.dao.ProxySink',
  axioms: [
    {
      // TODO: Remove this when MAP works properly on java.  github issue #1020
      class: 'foam.box.Remote',
      clientClass: 'foam.dao.ClientSink'
    }
  ],

  documentation: 'Sink Decorator which applies a map function to put() values before passing to delegate.',

  properties: [
    {
      class: 'foam.mlang.ExprProperty',
      name: 'arg1'
    }
  ],

  methods: [
    function f(o) { return this.arg1.f(o); },

    function put(o, sub) { this.delegate.put(this.f(o), sub); },

    function toString() {
      return 'MAP(' + this.arg1.toString() + ')';
    }
  ]
});


foam.CLASS({
  package: 'foam.mlang.expr',
  name: 'Mul',

  extends: 'foam.mlang.predicate.Binary',

  implements: [
    'foam.core.Serializable'
  ],

  documentation: 'Multiplication Binary Expression.',

  methods: [
    function f(o) { return this.arg1.f(o) * this.arg2.f(o); }
  ]
});


foam.CLASS({
  package: 'foam.mlang.sink',
  name: 'GroupBy',
  extends: 'foam.dao.AbstractSink',
  implements: [ 'foam.core.Serializable' ],

  documentation: 'Sink which behaves like the SQL group-by command.',

  // TODO: it makes no sense to name the arguments arg1 and arg2
  // because this isn't an expression, so they should be more meaningful
  properties: [
    {
      class: 'foam.mlang.ExprProperty',
      name: 'arg1'
    },
    {
      class: 'foam.mlang.SinkProperty',
      name: 'arg2'
    },
    {
      class: 'Map',
      name: 'groups',
      factory: function() { return {}; },
      javaFactory: 'return new java.util.HashMap<Object, foam.dao.Sink>();'
    },
    {
      class: 'List',
      name: 'groupKeys',
      javaFactory: 'return new java.util.ArrayList();',
      factory: function() { return []; }
    },
    {
      class: 'Boolean',
      name: 'processArrayValuesIndividually',
      documentation: 'If true, each value of an array will be entered into a separate group.',
      factory: function() {
        // TODO: it would be good if it could also detect RelationshipJunction.sourceId/targetId
        return ! foam.core.MultiPartID.isInstance(this.arg1);
      }
    }
  ],

  methods: [
    function sortedKeys(opt_comparator) {
      this.groupKeys.sort(opt_comparator || this.arg1.comparePropertyValues);
      return this.groupKeys;
    },

    function putInGroup_(sub, key, obj) {
      var group = this.groups.hasOwnProperty(key) && this.groups[key];
      if ( ! group ) {
        group = this.arg2.clone();
        this.groups[key] = group;
        this.groupKeys.push(key);
      }
      group.put(obj, sub);
    },

    function put(obj, sub) {
      var key = this.arg1.f(obj);
      if ( this.processArrayValuesIndividually && Array.isArray(key) ) {
        if ( key.length ) {
          for ( var i = 0; i < key.length; i++ ) {
            this.putInGroup_(sub, key[i], obj);
          }
        } else {
          // Perhaps this should be a key value of null, not '', since '' might
          // actually be a valid key.
          this.putInGroup_(sub, '', obj);
        }
      } else {
        this.putInGroup_(sub, key, obj);
      }
    },

    function eof() { },

    function clone() {
      // Don't use the default clone because we don't want to copy 'groups'.
      return this.cls_.create({ arg1: this.arg1, arg2: this.arg2 });
    },

    function toString() {
      return this.groups.toString();
    }
  ]
});


foam.CLASS({
  package: 'foam.mlang.sink',
  name: 'Unique',
  extends: 'foam.dao.ProxySink',
  implements: [ 'foam.core.Serializable' ],

  documentation: 'Sink decorator which only put()\'s a single obj for each unique expression value.',

  properties: [
    {
      class: 'foam.mlang.ExprProperty',
      name: 'expr'
    },
    {
      name: 'values',
      factory: function() { return {}; }
    }
  ],

  methods: [
    function putInGroup_(key, obj) {
      var group = this.groups.hasOwnProperty(key) && this.groups[key];
      if ( ! group ) {
        group = this.arg2.clone();
        this.groups[key] = group;
        this.groupKeys.push(key);
      }
      group.put(obj);
    },

    function put(obj, sub) {
      var value = this.expr.f(obj);
      if ( Array.isArray(value) ) {
        throw 'Unique doesn\'t Array values.';
      } else {
        if ( ! this.values.hasOwnProperty(value) ) {
          this.values[value] = obj;
          this.delegate.put(obj);
        }
      }
    },

    function eof() { },

    function clone() {
      // Don't use the default clone because we don't want to copy 'uniqueValues'.
      return this.cls_.create({ expr: this.expr, delegate: this.delegate });
    },

    function toString() {
      return this.uniqueValues.toString();
    }
  ]
});


foam.CLASS({
  package: 'foam.mlang.sink',
  name: 'Explain',
  extends: 'foam.dao.ProxySink',
  implements: [ 'foam.core.Serializable' ],

  documentation: 'Pseudo-Sink which outputs a human-readable description of an MDAO\'s execution plan for evaluating it.',

  properties: [
    {
      class: 'String',
      name:  'plan',
      help:  'Execution Plan'
    }
  ],

  methods: [
    function toString() { return this.plan; },
  ]
});


foam.CLASS({
  refines: 'foam.core.Property',

  implements: [ 'foam.mlang.order.Comparator' ],

  methods: [
    {
      name: 'orderTail',
      code: function() { return; }
    },
    {
      name: 'orderPrimaryProperty',
      code: function() { return this; }
    },
    {
      name: 'orderDirection',
      code: function() { return 1; }
    }
  ]
});


foam.CLASS({
  package: 'foam.mlang.order',
  name: 'Desc',

  implements: [
    'foam.mlang.order.Comparator',
    'foam.core.Serializable'
  ],

  documentation: 'Comparator Decorator which reverses direction of comparison. Short for "descending".',

  properties: [
    {
      class: 'FObjectProperty',
      name: 'arg1',
      of: 'foam.mlang.order.Comparator',
      adapt: function(_, c) { return foam.compare.toCompare(c); }
    }
  ],

  methods: [
    function compare(o1, o2) {
      return -1 * this.arg1.compare(o1, o2);
    },
    function toString() { return 'DESC(' + this.arg1.toString() + ')'; },
    function toIndex(tail) { return this.arg1 && this.arg1.toIndex(tail); },
    function orderTail() { return; },
    function orderPrimaryProperty() { return this.arg1; },
    function orderDirection() { return -1 * this.arg1.orderDirection(); }
  ]
});


foam.CLASS({
  package: 'foam.mlang.order',
  name: 'ThenBy',

  implements: [
    'foam.mlang.order.Comparator',
    'foam.core.Serializable'
  ],

  documentation: 'Binary Comparator, which sorts for first Comparator, then second.',

  properties: [
    {
      class: 'FObjectProperty',
      of: 'foam.mlang.order.Comparator',
      adapt: function(_, a) {
        // TODO(adamvy): We should fix FObjectProperty's default adapt when the
        // of parameter is an interface rather than a class.
        return a;
      },
      name: 'arg1'
    },
    {
      class: 'FObjectProperty',
      of: 'foam.mlang.order.Comparator',
      adapt: function(_, a) {
        // TODO(adamvy): We should fix FObjectProperty's default adapt when the
        // of parameter is an interface rather than a class.
        return a;
      },
      name: 'arg2'
    },
    {
      name: 'compare',
      swiftSupport: false,
      transient: true,
      documentation: 'Is a property so that it can be bound to "this" so that it works with Array.sort().',
      factory: function() { return this.compare_.bind(this); }
    }
  ],

  methods: [
    function compare_(o1, o2) {
      // an equals of arg1.compare is falsy, which will then hit arg2
      return this.arg1.compare(o1, o2) || this.arg2.compare(o1, o2);
    },

    function toString() {
      return 'THEN_BY(' + this.arg1.toString() + ', ' +
        this.arg2.toString() + ')';
    },

    function toIndex(tail) {
      return this.arg1 && this.arg2 && this.arg1.toIndex(this.arg2.toIndex(tail));
    },

    function orderTail() { return this.arg2; },

    function orderPrimaryProperty() { return this.arg1.orderPrimaryProperty(); },

    function orderDirection() { return this.arg1.orderDirection(); }
  ]
});


foam.CLASS({
  package: 'foam.mlang.order',
  name: 'CustomComparator',
  implements: [ 'foam.mlang.order.Comparator' ],

  // TODO: rename FunctionComparator

  documentation: 'A function to Comparator adapter.',

  properties: [
    {
      class: 'Function',
      name: 'compareFn'
    }
  ],

  methods: [
    {
      name: 'compare',
      code: function(o1, o2) {
        return this.compareFn(o1, o2);
      }
    },
    {
      name: 'toString',
      code: function() {
        return 'CUSTOM_COMPARE(' + this.compareFn.toString() + ')';
      }
    },
    {
      name: 'orderTail',
      code: function() { return undefined; }
    },
    {
      /** TODO: allow user to set this to match the given function */
      name: 'orderPrimaryProperty',
      code: function() { return undefined; }
    },
    {
      name: 'orderDirection',
      code: function() { return 1; }
    }
  ]
});


foam.LIB({
  name: 'foam.compare',

  methods: [
    function desc(c) {
      return foam.mlang.order.Desc.create({ arg1: c });
    },

    function toCompare(c) {
      return foam.Array.isInstance(c) ? foam.compare.compound(c) :
        foam.Function.isInstance(c)   ? foam.mlang.order.CustomComparator.create({ compareFn: c }) :
        c ;
    },

    function compound(args) {
      /* Create a compound comparator from an array of comparators. */
      var cs = args.map(foam.compare.toCompare);

      if ( cs.length === 0 ) return;
      if ( cs.length === 1 ) return cs[0];

      var ThenBy = foam.mlang.order.ThenBy;
      var ret, tail;

      ret = tail = ThenBy.create({arg1: cs[0], arg2: cs[1]});

      for ( var i = 2 ; i < cs.length ; i++ ) {
        tail = tail.arg2 = ThenBy.create({arg1: tail.arg2, arg2: cs[i]});
      }

      return ret;
    }
  ]
});


foam.CLASS({
  package: 'foam.mlang.sink',
  name: 'AbstractUnarySink',
  extends: 'foam.dao.AbstractSink',

  implements: [
    'foam.core.Serializable'
  ],

  documentation: 'An Abstract Sink baseclass which takes only one argument.',

  properties: [
    {
      class: 'foam.mlang.ExprProperty',
      name: 'arg1'
    }
  ],

  methods: [
    function toString() {
      return foam.String.constantize(this.cls_.name) +
          '(' + this.arg1.toString() + ')';
    }
  ]
});


foam.CLASS({
  package: 'foam.mlang.sink',
  name: 'Max',
  extends: 'foam.mlang.sink.AbstractUnarySink',

  documentation: 'A Sink which remembers the maximum value put().',

  properties: [
    {
      class: 'Object',
      name: 'value'
    }
  ],

  methods: [
    function put(obj, sub) {
      if ( ! this.hasOwnProperty('value') || foam.util.compare(this.value, this.arg1.f(obj)) < 0 ) {
        this.value = this.arg1.f(obj);
      }
    }
  ]
});


foam.CLASS({
  package: 'foam.mlang.sink',
  name: 'Min',
  extends: 'foam.mlang.sink.AbstractUnarySink',

  documentation: 'A Sink which remembers the minimum value put().',

  properties: [
    {
      class: 'Object',
      name: 'value'
    }
  ],

  methods: [
    function put(obj, s) {
      if ( ! this.hasOwnProperty('value') || foam.util.compare(this.value, this.arg1.f(obj) ) > 0) {
        this.value = this.arg1.f(obj);
      }
    }
  ]
});


foam.CLASS({
  package: 'foam.mlang.sink',
  name: 'Sum',
  extends: 'foam.mlang.sink.AbstractUnarySink',

  documentation: 'A Sink which sums put() values.',

  properties: [
    {
      class: 'foam.mlang.ExprProperty',
      name: 'arg1'
    },
    {
      class: 'Double',
      name: 'value',
      value: 0
    }
  ],

  methods: [
    function put(obj, sub) { this.value += this.arg1.f(obj); }
  ]
});


foam.CLASS({
  package: 'foam.mlang.expr',
  name: 'Dot',
  extends: 'foam.mlang.predicate.Binary',
  implements: [ 'foam.core.Serializable' ],

  documentation: 'A Binary Predicate which applies arg2.f() to arg1.f().',

  methods: [
    function f(o) {
      return this.arg2.f(this.arg1.f(o));
    },

    function compare(o1, o2) {
      return this.comparePropertyValues(this.f(o1), this.f(o2));
    },

    function comparePropertyValues(o1, o2) {
      /**
         Compare property values using arg2's property value comparator.
         Used by GroupBy
      **/
      return this.arg2.comparePropertyValues(o1, o2);
    }
  ]
});


foam.CLASS({
  package: 'foam.mlang',
  name: 'Expressions',

  documentation: 'Convenience mix-in for requiring all mlangs.',

  requires: [
    'foam.mlang.Constant',
    'foam.mlang.expr.Dot',
    'foam.mlang.expr.Mul',
    'foam.mlang.order.Desc',
    'foam.mlang.order.ThenBy',
    'foam.mlang.predicate.And',
    'foam.mlang.predicate.Contains',
    'foam.mlang.predicate.ContainsIC',
    'foam.mlang.predicate.Eq',
    'foam.mlang.predicate.False',
    'foam.mlang.predicate.Func',
    'foam.mlang.predicate.Gt',
    'foam.mlang.predicate.Gte',
    'foam.mlang.predicate.Has',
    'foam.mlang.predicate.In',
    'foam.mlang.predicate.Keyword',
    'foam.mlang.predicate.Lt',
    'foam.mlang.predicate.Lte',
    'foam.mlang.predicate.Neq',
    'foam.mlang.predicate.Not',
    'foam.mlang.predicate.Or',
    'foam.mlang.predicate.StartsWith',
    'foam.mlang.predicate.StartsWithIC',
    'foam.mlang.predicate.EndsWith',
    'foam.mlang.predicate.True',
    'foam.mlang.sink.Count',
    'foam.mlang.sink.Explain',
    'foam.mlang.sink.GroupBy',
    'foam.mlang.sink.Map',
    'foam.mlang.sink.Max',
    'foam.mlang.sink.Min',
    'foam.mlang.sink.Sum',
    'foam.mlang.sink.Unique'
  ],

  constants: {
    FALSE: foam.mlang.predicate.False.create(),
    TRUE: foam.mlang.predicate.True.create()
  },

  methods: [
    function _nary_(name, args) {
      return this[name].create({ args: Array.from(args) });
    },

    function _unary_(name, arg) {
      return this[name].create({ arg1: arg });
    },

    function _binary_(name, arg1, arg2) {
      return this[name].create({ arg1: arg1, arg2: arg2 });
    },

    function OR() { return this._nary_("Or", arguments); },
    function AND() { return this._nary_("And", arguments); },
    function CONTAINS(a, b) { return this._binary_("Contains", a, b); },
    function CONTAINS_IC(a, b) { return this._binary_("ContainsIC", a, b); },
    function EQ(a, b) { return this._binary_("Eq", a, b); },
    function NEQ(a, b) { return this._binary_("Neq", a, b); },
    function IN(a, b) { return this._binary_("In", a, b); },
    function LT(a, b) { return this._binary_("Lt", a, b); },
    function GT(a, b) { return this._binary_("Gt", a, b); },
    function LTE(a, b) { return this._binary_("Lte", a, b); },
    function GTE(a, b) { return this._binary_("Gte", a, b); },
    function HAS(a) { return this._unary_("Has", a); },
    function NOT(a) { return this._unary_("Not", a); },
    function KEYWORD(a) { return this._unary_("Keyword", a); },
    function STARTS_WITH(a, b) { return this._binary_("StartsWith", a, b); },
    function STARTS_WITH_IC(a, b) { return this._binary_("StartsWithIC", a, b); },
    function ENDS_WITH(a, b) { return this._binary_("EndsWith", a, b); },
    function FUNC(fn) { return this.Func.create({ fn: fn }); },
    function DOT(a, b) { return this._binary_("Dot", a, b); },
    function MUL(a, b) { return this._binary_("Mul", a, b); },

    function UNIQUE(expr, sink) { return this.Unique.create({ expr: expr, delegate: sink }); },
    function GROUP_BY(expr, sinkProto) { return this.GroupBy.create({ arg1: expr, arg2: sinkProto }); },
    function MAP(expr, sink) { return this.Map.create({ arg1: expr, delegate: sink }); },
    function EXPLAIN(sink) { return this.Explain.create({ delegate: sink }); },
    function COUNT() { return this.Count.create(); },
    function MAX(arg1) { return this.Max.create({ arg1: arg1 }); },
    function MIN(arg1) { return this.Min.create({ arg1: arg1 }); },
    function SUM(arg1) { return this.Sum.create({ arg1: arg1 }); },

    function DESC(a) { return this._unary_("Desc", a); },
    function THEN_BY(a, b) { return this._binary_("ThenBy", a, b); }
  ]
});


foam.CLASS({
  package: 'foam.mlang',
  name: 'ExpressionsSingleton',
  extends: 'foam.mlang.Expressions',

  documentation: 'A convenience object which provides access to all mlangs.',
  // TODO: why is this needed?

  axioms: [
    foam.pattern.Singleton.create()
  ]
});

// TODO(braden): We removed Expr.pipe(). That may still be useful to bring back,
// probably with a different name. It doesn't mean the same as DAO.pipe().
// remove eof()
/**
 * @license
 * Copyright 2016 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

foam.CLASS({
  package: 'foam.mlang',
  name: 'LabeledValue',

  documentation: 'A basic model for any id-label-value triple. This is ' +
      'useful when you need essentially a DAO of strings, and need to wrap ' +
      'those strings into a modeled object.',

  properties: [
    {
      name: 'id',
      expression: function(label) { return label; }
    },
    {
      class: 'String',
      name: 'label',
      required: true
    },
    {
      name: 'value'
    }
  ]
});
/**
 * @license
 * Copyright 2012 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

foam.CLASS({
  package: 'foam.dao.index',
  name: 'Plan',

  properties: [
    {
      name: 'cost',
      value: 0
    }
  ],

  methods: [
    function execute(promise, state, sink, skip, limit, order, predicate) {},
    function toString() { return this.cls_.name+"(cost="+this.cost+")"; }
  ]
});


/** Plan indicating that there are no matching records. **/
foam.CLASS({
  package: 'foam.dao.index',
  name: 'NotFoundPlan',
  extends: 'foam.dao.index.Plan',

  axioms: [ foam.pattern.Singleton.create() ],

  properties: [
    { name: 'cost', value: 0 }
  ],

  methods: [
    function toString() { return 'no-match(cost=0)'; }
  ]
});


/** Plan indicating that an index has no plan for executing a query. **/
foam.CLASS({
  package: 'foam.dao.index',
  name: 'NoPlan',
  extends: 'foam.dao.index.Plan',

  axioms: [ foam.pattern.Singleton.create() ],

  properties: [
    { name: 'cost', value: Number.MAX_VALUE }
  ],

  methods: [
    function toString() { return 'no-plan'; }
  ]
});


/** Convenience wrapper for indexes that want to create a closure'd function
    for each plan instance */
foam.CLASS({
  package: 'foam.dao.index',
  name: 'CustomPlan',
  extends: 'foam.dao.index.Plan',

  properties: [
    {
      class: 'Function',
      name: 'customExecute'
    },
    {
      class: 'Function',
      name: 'customToString'
    }
  ],

  methods: [
    function execute(promise, state, sink, skip, limit, order, predicate) {
      this.customExecute.call(
          this,
          promise,
          state,
          sink,
          skip,
          limit,
          order,
          predicate);
    },

    function toString() {
      return this.customToString.call(this);
    }
  ]
});


foam.CLASS({
  package: 'foam.dao.index',
  name: 'CountPlan',
  extends: 'foam.dao.index.Plan',

  properties: [
    {
      class: 'Int',
      name: 'count'
    }
  ],

  methods: [
    function execute(promise, sink /*, skip, limit, order, predicate*/) {
      sink.value += this.count;
    },

    function toString() {
      return 'short-circuit-count(' + this.count + ')';
    }
  ]
});


foam.CLASS({
  package: 'foam.dao.index',
  name: 'AltPlan',
  extends: 'foam.dao.index.Plan',

  properties: [
    {
      name: 'subPlans',
      factory: function() { return []; },
      postSet: function(o, nu) {
        this.cost = 1;
        for ( var i = 0; i < nu.length; ++i ) {
          this.cost += nu[i].cost;
        }
      }
    },
    'prop'
  ],

  methods: [
    function execute(promise, sink, skip, limit, order, predicate) {
      var sp = this.subPlans;
      for ( var i = 0 ; i < sp.length ; ++i) {
        sp[i].execute(promise, sink, skip, limit, order, predicate);
      }
    },

    function toString() {
      return ( ! this.subPlans || this.subPlans.length <= 1 ) ?
        'IN(key=' + ( this.prop && this.prop.name ) + ', cost=' + this.cost + ', ' +
          ', size=' + ( this.subPlans ? this.subPlans.length : 0 ) + ')' :
        'lookup(key=' + this.prop && this.prop.name + ', cost=' + this.cost + ', ' +
          this.subPlans[0].toString();
    }
  ]
});



/**
  Merges results from multiple sub-plans and deduplicates, sorts, and
  filters the results.

  TODO: account for result sorting in cost?
*/
foam.CLASS({
  package: 'foam.dao.index',
  name: 'MergePlan',
  extends: 'foam.dao.index.AltPlan',

  requires: [
    'foam.dao.DedupSink',
    'foam.dao.LimitedSink',
    'foam.dao.OrderedSink',
    'foam.dao.SkipSink'
  ],

  properties: [
    {
      class: 'Class',
      name: 'of'
    },
    'predicates',
  ],

  methods: [
    /**
      Executes sub-plans, limiting results from each, then merges results,
      removes duplicates, sorts, skips, and limits.
    */
    function execute(promise, sink, skip, limit, order, predicate) {
      if ( order ) return this.executeOrdered(promise, sink, skip, limit, order, predicate);
      return this.executeFallback(promise, sink, skip, limit, order, predicate);
    },

    function executeOrdered(promise, sink, skip, limit, order, predicate) {
      /**
       * Executes a merge where ordering is specified, therefore
       * results from the subPlans are also sorted, and can be merged
       * efficiently.
       */
      foam.assert(order && order.compare, "Order.compare() must be supplied in MergePlan.executeOrdered()");
      foam.assert(( ! this.predicates ) || ( this.predicates.size == this.subPlans.size ), "MergePlan.predicates, when specified, must match the number of subplans." );

      // quick linked list
      var NodeProto = { next: null, data: null };

      var head = Object.create(NodeProto);
      // TODO: track list size, cut off if above skip+limit

      var sp = this.subPlans;
      var predicates = this.predicates;
      var subLimit = ( limit ? limit + ( skip ? skip : 0 ) : undefined );
      var promises = []; // track any async subplans
      var dedupCompare = ( this.of ) ? this.of.ID.compare.bind(this.of.ID) : foam.util.compare;
      var compare = order.compare.bind(order);

      // Each plan inserts into the list
      for ( var i = 0 ; i < sp.length ; ++i) {
        var insertPlanSink;
        (function() { // capture new insertAfter for each sink
          // set new insert position to head.
          // Only bump insertAfter forward when the next item is smaller,
          //   since we need to scan all equal items every time a new item
          //   comes in.
          // If the next item is larger, we insert before it
          //   and leave the insertion point where it is, so the next
          //   item can check if it is equal to the just-inserted item.
          var insertAfter = head;
          insertPlanSink = foam.dao.QuickSink.create({
            putFn: function(o) {
              function insert() {
                var nu = Object.create(NodeProto);
                nu.next = insertAfter.next;
                nu.data = o;
                insertAfter.next = nu;
              }

              // Skip past items that are less than our new item
              while ( insertAfter.next &&
                      compare(o, insertAfter.next.data) > 0 ) {
                 insertAfter = insertAfter.next;
              }

              if ( ! insertAfter.next ) {
                // end of list case, no equal items, so just append
                insert();
                return;
              } else if ( compare(o, insertAfter.next.data) === 0 ) {
                // equal items case, check for dupes
                // scan through any items that are equal, dupe check each
                var dupeAfter = insertAfter;
                while ( dupeAfter.next &&
                        compare(o, dupeAfter.next.data) === 0 ) {
                  if ( dedupCompare(o, dupeAfter.next.data) === 0 ) {
                    // duplicate found, ignore the new item
                    return;
                  }
                  dupeAfter = dupeAfter.next;
                }
                // No dupes found, so insert at position dupeAfter
                // dupeAfter.next is either end-of-list or a larger item
                var nu = Object.create(NodeProto);
                nu.next = dupeAfter.next;
                nu.data = o;
                dupeAfter.next = nu;
                dupeAfter = null;
                return;
              } else { // comp < 0
                 // existing-is-greater-than-new case, insert before it
                 insert();
              }
            }
          });
        })();
        // restart the promise chain, if a promise is added we collect it
        var nuPromiseRef = [];
        sp[i].execute(
          nuPromiseRef,
          insertPlanSink,
          undefined,
          subLimit,
          order,
          predicates ? predicates[i] : predicate // array mode (one per subplan) or repeated use of single predicate
        );
        if ( nuPromiseRef[0] ) promises.push(nuPromiseRef[0]);
      }

      // result reading may by async, so define it but don't call it yet
      var resultSink = this.decorateSink_(sink, skip, limit);

      var sub = foam.core.FObject.create();
      var detached = false;
      sub.onDetach(function() { detached = true; });

      function scanResults() {
        // The list starting at head now contains the results plus possible
        //  overflow of skip+limit
        var node = head.next;
        while ( node && ! detached ) {
          resultSink.put(node.data, sub);
          node = node.next;
        }
      }

      // if there is an async index in the above, wait for it to finish
      //   before reading out the results.
      if ( promises.length ) {
        var thisPromise = Promise.all(promises).then(scanResults);
        // if an index above us is also async, chain ourself on
        promise[0] = promise[0] ? promise[0].then(function() {
          return thisPromise;
        }) : thisPromise;
      } else {
        // In the syncrhonous case we don't have to wait on our subplans,
        //  and can ignore promise[0] as someone else is responsible for
        //  waiting on it if present.
        scanResults();
      }
    },

    function executeFallback(promise, sink, skip, limit, order, predicate) {
       /**
        * Executes a merge where ordering is unknown, therefore no
        * sorting is done and deduplication must be done separately.
        */
       var resultSink = this.DedupSink.create({
         delegate: this.decorateSink_(sink, skip, limit)
       });

       foam.assert(( ! this.predicates ) || ( this.predicates.size == this.subPlans.size ), "MergePlan.predicates, when specified, must match the number of subplans." );

       var sp = this.subPlans;
       var predicates = this.predicates;
       var subLimit = ( limit ? limit + ( skip ? skip : 0 ) : undefined );

       for ( var i = 0 ; i < sp.length ; ++i) {
         sp[i].execute(
           promise,
           resultSink,
           undefined,
           subLimit,
           order,
           predicates ? predicates[i] : predicate // array mode (one per subplan) or repeated use of single predicate
         );
       }
       // Since this execute doesn't collect results into a temporary
       // storage list, we don't need to worry about the promises. Any
       // async subplans will add their promise on, and when they are
       // resolved their results will have already put() straight into
       // the resultSink. Only the MDAO calling the first execute() needs
       // to respect the referenced promise chain.
    },

    function decorateSink_(sink, skip, limit) {
      /**
       * TODO: Share with AbstractDAO? We never need to use predicate or order
       * @private
       */
      if ( limit != undefined ) {
        sink = this.LimitedSink.create({
          limit: limit,
          delegate: sink
        });
      }
      if ( skip != undefined ) {
        sink = this.SkipSink.create({
          skip: skip,
          delegate: sink
        });
      }

      return sink;
    },

  ]
});
/**
 * @license
 * Copyright 2012 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
  The Index interface for an ordering, fast lookup, single value,
  index multiplexer, or any other MDAO select() assistance class.

  Each Index subclass also defines an IndexNode class. Index defines
  the structure of the index, including estimate() to gauge its
  probable performance for a query, while IndexNode implements the
  data nodes that hold the indexed items and plan and execute
  queries. For any particular operational Index, there may be
  many IndexNode instances:

<pre>
                 1---------> TreeIndex(id)
  MDAO: AltIndex 2---------> TreeIndex(propA) ---> TreeIndex(id) -------------> ValueIndex
        | 1x AltIndexNode    | 1x TreeIndexNode    | 14x TreeIndexNodes         | (DAO size)x ValueIndexNodes
           (2 alt subindexes)     (14 nodes)             (each has 0-5 nodes)
</pre>
  The base AltIndex has two complete subindexes (each holds the entire DAO).
  The TreeIndex on property A has created one TreeIndexNode, holding one tree of 14 nodes.
  Each tree node contains a tail instance of the next level down, thus
  the TreeIndex on id has created 14 TreeIndexNodes. Each of those contains some number
  of tree nodes, each holding one tail instance of the ValueIndex at the end of the chain.

*/
foam.CLASS({
  package: 'foam.dao.index',
  name: 'Index',

  properties: [
    {
      /**
       * The class type of the data nodes this index creates with
       * createNode(). By default it will be the Index class' name
       * with Node appended:
       * <p><code>MyIndex => MyIndexNode</code>
       */
      class: 'Class',
      name: 'nodeClass',
      factory: function() {
        return this.cls_.id + 'Node';
      }
    }
  ],

  methods: [
    function estimate(size, sink, skip, limit, order, predicate) {
      /** Estimates the performance of this index given the number of items
        it will hold and the planned parameters. */
      return size * size; // n^2 is a good worst-case estimate by default
    },

    function toPrettyString(indent) {
      /** Output a minimal, human readable, indented (2 spaces per level)
        description of the index structure */
    },

    function createNode(args) {
      args = args || {};
      args.index = this;
      return this.nodeClass.create(args, this);
    }
  ]
});


/**
  The IndexNode interface represents a piece of the index that actually
  holds data. A tree will create an index-node for each tree-node, so one
  Index will manage many IndexNode instances, each operating on part of
  the data in the DAO.

  For creation speed, do not require or import anything in a node class.
  Use the 'index' property to access requires and imports on the
  Index that created the node instance.
*/
foam.CLASS({
  package: 'foam.dao.index',
  name: 'IndexNode',

  properties: [
    {
      class: 'Simple',
      name: 'index'
    }
  ],

  methods: [
    /** Adds or updates the given value in the index */
    function put(obj) {},

    /** Removes the given value from the index */
    function remove(obj) {},

    /** @return a Plan to execute a select with the given parameters */
    function plan(sink, skip, limit, order, predicate, root) {},

    /** @return the tail index instance for the given key. */
    function get(key) {},

    /** @return the integer size of this index. */
    function size() {},

    /** Selects matching items from the index and puts them into sink.
        cache allows indexes to store query state that is discarded once
        the select() is complete.
      <p>Note: order checking has replaced selectReverse().  */
    function select(sink, skip, limit, order, predicate, cache) { },

    /** Efficiently (if possible) loads the contents of the given DAO into the index */
    function bulkLoad(dao) {}
  ]
});
/**
 * @license
 * Copyright 2016 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

foam.CLASS({
  package: 'foam.dao.index',
  name: 'ProxyIndex',
  extends: 'foam.dao.index.Index',

  properties: [
    {
      name: 'delegate',
      required: true,
    }
  ],
  methods: [
    function estimate(size, sink, skip, limit, order, predicate) {
      return this.delegate.estimate(size, sink, skip, limit, order, predicate);
    },

    function toPrettyString(indent) {
      return this.delegate.toPrettyString(indent);
    },

    function toString() {
      return '[' + this.cls_.name + ': ' + this.delegate.toString() + ']'
    }
  ]
});

foam.CLASS({
  package: 'foam.dao.index',
  name: 'ProxyIndexNode',
  extends: 'foam.dao.index.IndexNode',

  properties: [
    {
      class: 'Simple',
      name: 'delegate',
    },
  ],

  methods: [
    function init() {
      this.delegate = this.delegate || this.index.delegate.createNode();
    },

    function put(o) { return this.delegate.put(o); },

    function remove(o) { return this.delegate.remove(o); },

    function plan(sink, skip, limit, order, predicate, root) {
      return this.delegate.plan(sink, skip, limit, order, predicate, root);
    },

    function get(key) { return this.delegate.get(key); },

    function size() { return this.delegate.size(); },

    function select(sink, skip, limit, order, predicate, cache) {
      return this.delegate.select(sink, skip, limit, order, predicate, cache);
    },

    function bulkLoad(dao) { return this.delegate.bulkLoad(dao); },

  ]
});

/**
 * @license
 * Copyright 2016 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
  Provides for hetergenious indexes, where not all potential delegates
  of this AltIndex actually get populated for each instance. Each instance
  always populates an ID index, so it can serve queries even if no
  delegate indexes are explicitly added.

  Index: Alt[ID, TreeA, TreeB]
  IndexNodes: [id, a,b], [id, a], [id, b], [id, a], [id]
*/
foam.CLASS({
  package: 'foam.dao.index',
  name: 'AltIndex',
  extends: 'foam.dao.index.Index',

  requires: [
    'foam.dao.AnonymousSink',
    'foam.dao.index.NoPlan',
    'foam.mlang.sink.NullSink',
  ],

  constants: {
    /** Maximum cost for a plan which is good enough to not bother looking at the rest. */
    GOOD_ENOUGH_PLAN: 10 // put to 10 or more when not testing
  },

  properties: [
    {
      /** delegate factories */
      name: 'delegates',
      factory: function() { return []; }
    },
    {
      /** factory quick lookup */
      name: 'delegateMap_',
      factory: function() { return {}; }
    },
  ],

  methods: [

    /** Returns smallest estimate from the delegates */
    function estimate(size, sink, skip, limit, order, predicate) {
      var cost = Number.MAX_VALUE;
      for ( var i = 0; i < this.delegates.length; i++ ) {
        cost = Math.min(
          cost,
          this.delegates[i].estimate(
            size, sink, skip, limit, order, predicate)
        );
      }
      return cost;
    },

    function toPrettyString(indent) {
      var ret = "";
      for ( var i = 0; i < this.delegates.length; i++ ) {
          ret += this.delegates[i].toPrettyString(indent + 1);
      }
      return ret;
    },

    function toString() {
      return 'Alt([' + (this.delegates.join(',')) + '])';
    },
  ]
});

foam.CLASS({
  package: 'foam.dao.index',
  name: 'AltIndexNode',
  extends: 'foam.dao.index.IndexNode',

  properties: [
    {
      /** the delegate instances for each Alt instance */
      class: 'Simple',
      name: 'delegates'
    },
  ],

  methods: [
    function init() {
      this.delegates = this.delegates || [ this.index.delegates[0].createNode() ];
    },

    function addIndex(index) {
      // check for existing factory
      var dfmap = this.index.delegateMap_;
      var indexKey = index.toString();
      if ( ! dfmap[indexKey] ) {
        this.index.delegates.push(index);
        dfmap[indexKey] = index;
      } else {
        // ensure all tails are using the same factory instance
        index = dfmap[indexKey];
      }

      var newSubInst = index.createNode();
      var wrapped = this.index.AnonymousSink.create({ sink: newSubInst });
      this.delegates[0].plan(wrapped).execute([], wrapped);
      this.delegates.push(newSubInst);
    },

    function bulkLoad(a) {
      for ( var i = 0 ; i < this.delegates.length ; i++ ) {
        this.delegates[i].bulkLoad(a);
      }
    },

    function get(key) {
      return this.delegates[0].get(key);
    },

    function pickDelegate(order, cache) {
      // NOTE: this assumes one of the delegates is capable of ordering
      //  properly for a scan. We should not be asked for a select unless
      //  a previous estimate indicated one of our options was sorted properly.
      // NOTE: unbuilt portions of the index will be built immediately
      //  if picked for ordering.
      var delegates = this.delegates;
      if ( ! order ) return delegates[0];

      var c = cache[this];
      // if no cached index estimates, generate estimates
      // for each factory for this ordering
      if ( ! c ) {
        var nullSink = this.index.NullSink.create();
        var dfs = this.index.delegates;
        var bestEst = Number.MAX_VALUE;
        // Pick the best factory for the ordering, cache it
        for ( var i = 0; i < dfs.length; i++ ) {
          var est = dfs[i].estimate(1000, nullSink, undefined, undefined, order);
          if ( est < bestEst ) {
            c = dfs[i];
            bestEst = est;
          }
        }
        cache[this] = c;
      }

      // check if we have a delegate instance for the best factory
      for ( var i = 0; i < delegates.length; i++ ) {
        // if we do, it's the best one
        if ( delegates[i].index === c ) return delegates[i];
      }

      // we didn't have the right delegate generated, so add and populate it
      // as per addIndex, but we skip checking the factory as we know it's stored
      var newSubInst = c.createNode();
      var wrapped = this.index.AnonymousSink.create({ sink: newSubInst });
      this.delegates[0].plan(wrapped).execute([], wrapped);
      this.delegates.push(newSubInst);

      return newSubInst;
    },


    function select(sink, skip, limit, order, predicate, cache) {
      // find and cache the correct subindex to use
      this.pickDelegate(order, cache)
        .select(sink, skip, limit, order, predicate, cache);
    },

    function put(newValue) {
      for ( var i = 0 ; i < this.delegates.length ; i++ ) {
        this.delegates[i].put(newValue);
      }
    },

    function remove(obj) {
      for ( var i = 0 ; i < this.delegates.length ; i++ ) {
        this.delegates[i].remove(obj);
      }
    },

    function plan(sink, skip, limit, order, predicate, root) {
      var bestPlan;
      for ( var i = 0 ; i < this.delegates.length ; i++ ) {
        var p = this.delegates[i].plan(sink, skip, limit, order, predicate, root);
        if ( p.cost <= this.index.GOOD_ENOUGH_PLAN ) {
          bestPlan = p;
          break;
        }
        if ( ! bestPlan || p.cost < bestPlan.cost ) {
          bestPlan = p;
        }
      }
      if ( ! bestPlan ) {
        return this.index.NoPlan.create();
      }
      return bestPlan;
    },

    function size() { return this.delegates[0].size(); },

    function toString() {
      return 'Alt([' + (this.index.delegates.join(',')) + this.size() + '])';
    },
  ]
});
/**
 * @license
 * Copyright 2012 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
  An Index which holds only a single value. This class also functions as its
  own execution Plan, since it only has to return the single value.
**/
foam.CLASS({
  package: 'foam.dao.index',
  name: 'ValueIndex',
  extends: 'foam.dao.index.Index',

  methods: [
    function estimate(size, sink, skip, limit, order, predicate) {
      return 1;
    },

    function toPrettyString(indent) {
      return '';
    }
  ]
});


foam.CLASS({
  package: 'foam.dao.index',
  name: 'ValueIndexNode',
  extends: 'foam.dao.index.IndexNode',

  implements: [ 'foam.dao.index.Plan' ],

  properties: [
    { class: 'Simple', name: 'value' },
    { class: 'Simple', name: 'cost' }
  ],

  methods: [
    // from plan
    function execute(promise, sink, skip, limit, order, predicate) {
      /** Note that this will put(undefined) if you remove() the item but
        leave this ValueIndex intact. Usages of ValueIndex should clean up
        the ValueIndex itself when the value is removed. */
      this.select(sink, skip, limit, order, predicate);
    },

    function toString() {
      return 'ValueIndex_Plan(cost=1, value:' + this.value + ')';
    },

    // from Index
    function put(s) { this.value = s; },
    function remove() { this.value = undefined; },
    function get() { return this.value; },
    function size() { return typeof this.value === 'undefined' ? 0 : 1; },
    function plan() { this.cost = 1; return this; },

    function select(sink, skip, limit, order, predicate, cache) {
      if ( predicate && ! predicate.f(this.value) ) return;
      if ( skip && skip[0]-- > 0 ) return;
      if ( limit && limit[0]-- <= 0 ) return;
      sink.put(this.value);
    },
  ]
});
/**
 * @license
 * Copyright 2012 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
  Represents one node's state in a binary tree. Each tree operation
  can rebalance the subtree or create a new node, so those methods
  return a tree node reference to replace the one called. It may be the
  same node, a different existing node, or a new node.
  <p>
  <code>
    // replace s.right with result of operations on s.right
    s.right = s.right.maybeClone(locked).split(locked);
  </code>
*/
foam.CLASS({
  package: 'foam.dao.index',
  name: 'TreeNode',

  properties: [
    // per node properties
    { class: 'Simple', name: 'key'   },
    { class: 'Simple', name: 'value' },
    { class: 'Simple', name: 'size'  },
    { class: 'Simple', name: 'level' },
    { class: 'Simple', name: 'left'  },
    { class: 'Simple', name: 'right' }
  ],

  methods: [

    /**
       Clone is only needed if a select() is active in the tree at the
       same time we are updating it.
    */
    function maybeClone(locked) {
      return locked ? this.clone() : this;
    },

    function clone() {
      var c = this.cls_.create();
      c.key   = this.key;
      c.value = this.value;
      c.size  = this.size;
      c.level = this.level;
      c.left  = this.left;
      c.right = this.right;
      return c;
    },

    function updateSize() {
      this.size = this.left.size + this.right.size + this.value.size();
    },

    /** @return Another node representing the rebalanced AA tree. */
    function skew(locked) {
      if ( this.left.level === this.level ) {
        // Swap the pointers of horizontal left links.
        var l = this.left.maybeClone(locked);

        this.left = l.right;
        l.right = this;

        this.updateSize();
        l.updateSize();

        return l;
      }

      return this;
    },

    /** @return a node representing the rebalanced AA tree. */
    function split(locked) {
      if (
          this.right.level       &&
          this.right.right.level &&
          this.level === this.right.right.level
      ) {
        // We have two horizontal right links.
        // Take the middle node, elevate it, and return it.
        var r = this.right.maybeClone(locked);

        this.right = r.left;
        r.left = this;
        r.level++;

        this.updateSize();
        r.updateSize();

        return r;
      }

      return this;
    },

    function predecessor() {
      if ( ! this.left.level ) return this;
      for ( var s = this.left ; s.right.level ; s = s.right ) {}
      return s;
    },

    function successor() {
      if ( ! this.right.level ) return this;
      for ( var s = this.right ; s.left.level ; s = s.left ) {}
      return s;
    },

    /**
       Removes links that skip levels.
       @return the tree with its level decreased.
    */
    function decreaseLevel(locked) {
      var expectedLevel = Math.min(
          this.left.level  ? this.left.level  : 0,
          this.right.level ? this.right.level : 0) + 1;

      if ( expectedLevel < this.level ) {
        this.level = expectedLevel;
        if ( this.right.level && expectedLevel < this.right.level ) {
          this.right = this.right.maybeClone(locked);
          this.right.level = expectedLevel;
        }
      }

      return this;
    },

    /** extracts the value with the given key from the index */
    function get(key, compare) {
      var r = compare(this.key, key);

      if ( r === 0 ) return this.value; // TODO... tail.get(this.value) ???

      return r > 0 ? this.left.get(key, compare) : this.right.get(key, compare);
    },

    /** scans the entire tree and returns all matches */
    function getAll(key, compare, retArray) {
      var r = compare(this.key, key);

      if ( r === 0 ) retArray.push(this.value);

      this.left.getAll(key, compare, retArray);
      this.right.getAll(key, compare, retArray);
    },

    function putKeyValue(key, value, compare, dedup, locked) {
      var s = this.maybeClone(locked);

      var r = compare(s.key, key);

      if ( r === 0 ) {
        dedup(value, s.key);

        s.size -= s.value.size();
        s.value.put(value);
        s.size += s.value.size();
      } else {
        var side = r > 0 ? 'left' : 'right';

        if ( s[side].level ) s.size -= s[side].size;
        s[side] = s[side].putKeyValue(key, value, compare, dedup, locked);
        s.size += s[side].size;
      }

      return s.split(locked).skew(locked);
    },

    function removeKeyValue(key, value, compare, locked, nullNode) {
      var s = this.maybeClone(locked);
      var side;
      var r = compare(s.key, key);

      if ( r === 0 ) {
        s.size -= s.value.size();
        s.value.remove(value);

        // If the sub-Index still has values, then don't
        // delete this node.
        if ( s.value && s.value.size() > 0 ) {
          s.size += s.value.size();
          return s;
        }

        // If we're a leaf, easy, otherwise reduce to leaf case.
        if ( ! s.left.level && ! s.right.level ) {
          return nullNode;
        }

        side = s.left.level ? 'left' : 'right';

        // TODO: it would be faster if successor and predecessor also deleted
        // the entry at the same time in order to prevent two traversals.
        // But, this would also duplicate the delete logic.
        var l = side === 'left' ?
            s.predecessor() :
            s.successor()   ;

        s.key = l.key;
        s.value = l.value;

        s[side] = s[side].removeNode(l.key, compare, locked);
      } else {
        side = r > 0 ? 'left' : 'right';

        s.size -= s[side].size;
        s[side] = s[side].removeKeyValue(key, value, compare, locked, nullNode);
        s.size += s[side].size;
      }

      // Rebalance the tree. Decrease the level of all nodes in this level if
      // necessary, and then skew and split all nodes in the new level.
      s = s.decreaseLevel(locked).skew(locked);
      if ( s.right.level ) {
        s.right = s.right.maybeClone(locked).skew(locked);
        if ( s.right.right.level ) {
          s.right.right = s.right.right.maybeClone(locked).skew(locked);
        }
      }

      s = s.split(locked);
      s.right = s.right.maybeClone(locked).split(locked);

      return s;
    },

    function removeNode(key, compare, locked) {
      var s = this.maybeClone(locked);

      var r = compare(s.key, key);

      if ( r === 0 ) return s.left.level ? s.left : s.right;

      var side = r > 0 ? 'left' : 'right';

      s.size -= s[side].size;
      s[side] = s[side].removeNode(key, compare, locked);
      s.size += s[side].size;

      return s;
    },


    function select(sink, skip, limit, order, predicate, cache) {
      if ( limit && limit[0] <= 0 ) return;

      if ( skip && skip[0] >= this.size && ! predicate ) {
        skip[0] -= this.size;
        return;
      }

      this.left.select(sink, skip, limit, order, predicate, cache);

      this.value.select(sink, skip, limit,
        order && order.orderTail(), predicate, cache);

      this.right.select(sink, skip, limit, order, predicate, cache);
    },


    function selectReverse(sink, skip, limit, order, predicate, cache) {
      if ( limit && limit[0] <= 0 ) return;

      if ( skip && skip[0] >= this.size && ! predicate ) {
        //console.log('reverse skipping: ', this.key);
        skip[0] -= this.size;
        return;
      }

      this.right.selectReverse(sink, skip, limit, order, predicate, cache);

      // select() will pick reverse or not based on order
      this.value.select(sink, skip, limit,
        order && order.orderTail(), predicate, cache);

      this.left.selectReverse(sink,  skip, limit, order, predicate, cache);
    },

    function gt(key, compare) {
      var s = this;
      var r = compare(key, s.key);

      if ( r < 0 ) {
        var l = s.left.gt(key, compare);
        var copy = s.clone();
        copy.size = s.size - s.left.size + l.size;
        copy.left = l;
        return copy;
      }

      if ( r > 0 ) return s.right.gt(key, compare);

      return s.right;
    },

    function gte(key, compare, nullNode) {
      var s = this;
      var copy;
      var r = compare(key, s.key);

      if ( r < 0 ) {
        var l = s.left.gte(key, compare, nullNode);
        copy = s.clone();
        copy.size = s.size - s.left.size + l.size;
        copy.left = l;
        return copy;
      }

      if ( r > 0 ) return s.right.gte(key, compare, nullNode);

      copy = s.clone();
      copy.size = s.size - s.left.size;
      copy.left = nullNode;
      return copy;
    },

    function lt(key, compare) {
      var s = this;
      var r = compare(key, s.key);

      if ( r > 0 ) {
        var rt = s.right.lt(key, compare);
        var copy = s.clone();
        copy.size = s.size - s.right.size + rt.size;
        copy.right = rt;
        return copy;
      }

      if ( r < 0 ) return s.left.lt(key, compare);

      return s.left;
    },

    function lte(key, compare, nullNode) {
      var s = this;
      var copy;
      var r = compare(key, s.key);

      if ( r > 0 ) {
        var rt = s.right.lte(key, compare, nullNode);
        copy = s.clone();
        copy.size = s.size - s.right.size + rt.size;
        copy.right = rt;
        return copy;
      }

      if ( r < 0 ) return s.left.lte(key, compare, nullNode);

      copy = s.clone();
      copy.size = s.size - s.right.size;
      copy.right = nullNode;
      return copy;
    }
  ]
});


/**
  Guards the leaves of the tree. Once instance is created per instance of
  TreeIndex, and referenced by every tree node. Most of its methods are
  no-ops, cleanly terminating queries and other tree operations.
  <p>
  NullTreeNode covers creation of new nodes: when a put value hits the
  nullNode, a new TreeNode is returned and the caller replaces the
  nullNode reference with the new node.
*/
foam.CLASS({
  package: 'foam.dao.index',
  name: 'NullTreeNode',

  properties: [
    {
      /**
        The nullNode for a given tree creates all the new nodes, so it needs
        the factory for the tail index to create inside each new node.
      */
      class: 'Simple',
      name: 'tail'
    },
    {
      /**
        The tree node factory is used to create new, empty tree nodes. They
        will be initialized with a new tail index from tail.
      */
      class: 'Simple',
      name: 'treeNode'
    },
    {
      class: 'Simple',
      name: 'left',
      //getter: function() { return undefined; }
    },
    {
      class: 'Simple',
      name: 'right',
      //getter: function() { return undefined; }
    },
    {
      class: 'Simple',
      name: 'size',
      //getter: function() { return 0; }
    },
    {
      class: 'Simple',
      name: 'level',
      //getter: function() { return 0; }
    }
  ],

  methods: [
    function init() {
      this.left  = undefined;
      this.right = undefined;
      this.size  = 0;
      this.level = 0;
    },

    function clone()         { return this; },
    function maybeClone()    { return this; },
    function skew(locked)    { return this; },
    function split(locked)   { return this; },
    function decreaseLevel() { return this; },
    function get()           { return undefined; },
    function updateSize()    {  },

    /** Add a new value to the tree */
    function putKeyValue(key, value) {
      var subIndex = this.tail.createNode();
      subIndex.put(value);
      var n = this.treeNode.create();
      n.left  = this;
      n.right = this;
      n.key   = key;
      n.value = subIndex;
      n.size  = 1;
      n.level = 1;
      return n;
    },

    function removeKeyValue() { return this; },
    function removeNode()     { return this; },
    function select()         { },
    function selectReverse()  { },

    function gt()   { return this; },
    function gte()  { return this; },
    function lt()   { return this; },
    function lte()  { return this; },

    function getAll()  { return; },

    function bulkLoad_(a, start, end, keyExtractor) {
      if ( end < start ) return this;

      var tree = this;
      var m    = start + Math.floor((end-start+1) / 2);
      tree = tree.putKeyValue(keyExtractor(a[m]), a[m]);

      tree.left  = tree.left.bulkLoad_(a, start, m-1, keyExtractor);
      tree.right = tree.right.bulkLoad_(a, m+1, end, keyExtractor);
      tree.size += tree.left.size + tree.right.size;

      return tree;
    }
  ]
});
/**
 * @license
 * Copyright 2012 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

foam.CLASS({
  refines: 'foam.core.Property',

  requires: [
    'foam.dao.index.TreeIndex',
  ],

  methods: [
    function toIndex(tail) {
      /** Creates the correct type of index for this property, passing in the
          tail factory (sub-index) provided. */
      return this.TreeIndex.create({ prop: this, tail: tail });
    }
  ]
});


foam.CLASS({
  refines: 'foam.core.FObjectArray',

  requires: [
    'foam.dao.index.SetIndex',
  ],

  methods: [
    function toIndex(tail) {
       return this.SetIndex.create({ prop: this, tail: tail });
    }
  ]
});


foam.CLASS({
  refines: 'foam.core.AxiomArray',

  requires: [
    'foam.dao.index.SetIndex',
  ],

  methods: [
    function toIndex(tail) {
       return this.SetIndex.create({ prop: this, tail: tail });
    }
  ]
});


foam.CLASS({
  refines: 'foam.core.StringArray',

  requires: [
    'foam.dao.index.SetIndex',
  ],

  methods: [
    function toIndex(tail) {
       return this.SetIndex.create({ prop: this, tail: tail });
    }
  ]
});


/** A tree-based Index. Defaults to an AATree (balanced binary search tree) **/
foam.CLASS({
  package: 'foam.dao.index',
  name: 'TreeIndex',
  extends: 'foam.dao.index.Index',

  requires: [
    'foam.core.Property',
    'foam.dao.ArraySink',
    'foam.mlang.sink.NullSink',
    'foam.dao.index.MergePlan',
    'foam.dao.index.CountPlan',
    'foam.dao.index.CustomPlan',
    'foam.dao.index.NotFoundPlan',
    'foam.dao.index.NullTreeNode',
    'foam.dao.index.TreeNode',
    'foam.dao.index.ValueIndex',
    'foam.mlang.order.Desc',
    'foam.mlang.order.Comparator',
    'foam.mlang.order.ThenBy',
    'foam.mlang.predicate.And',
    'foam.mlang.predicate.Eq',
    'foam.mlang.predicate.False',
    'foam.mlang.predicate.Gt',
    'foam.mlang.predicate.Gte',
    'foam.mlang.predicate.Lt',
    'foam.mlang.predicate.Lte',
    'foam.mlang.predicate.Or',
    'foam.mlang.predicate.True',
    'foam.mlang.predicate.In',
    'foam.mlang.predicate.Contains',
    'foam.mlang.predicate.ContainsIC',
    'foam.mlang.sink.Count',
    'foam.mlang.sink.Explain',
  ],

  constants: {
    IS_EXPR_MATCH_FN: function isExprMatch(predicate, prop, model) {
      var self = this.index || this;
      if ( predicate && model && prop ) {
        // util.equals catches Properties that were cloned if the predicate has
        //  been cloned.
        if ( model.isInstance(predicate) &&
            ( predicate.arg1 === prop || foam.util.equals(predicate.arg1, prop) )
        ) {
          var arg2 = predicate.arg2;
          predicate = undefined;
          return { arg2: arg2, predicate: predicate };
        }

        if ( predicate.args && self.And.isInstance(predicate) ) {
          for ( var i = 0 ; i < predicate.args.length ; i++ ) {
            var q = predicate.args[i];
            // Util.equals to catch clones again
            if ( model.isInstance(q) &&
                (q.arg1 === prop || foam.util.equals(q.arg1, prop)) ) {
              predicate = predicate.clone();
              predicate.args[i] = self.True.create();
              predicate = predicate.partialEval();
              if ( self.True.isInstance(predicate) ) predicate = undefined;
              return { arg2: q.arg2, predicate: predicate };
            }
          }
        }
      }
      return undefined;
    }
  },

  properties: [
    {
      name: 'prop',
      required: true
    },
    {
      name: 'nullNode',
      factory: function() {
        var nn = this.NullTreeNode.create({
          tail: this.tail,
          treeNode: this.treeNode
        });
        return nn;
      }
    },
    {
      name: 'treeNode',
      factory: function() { return this.TreeNode; }
    },
    {
      name: 'tail',
      required: true
    }
  ],

  methods: [
    function init() {
      this.dedup = this.dedup.bind(this, this.prop.name);
    },

    /** Set the value's property to be the same as the key in the index.
        This saves memory by sharing objects. */
    function dedup(propName, obj, value) {
      obj[propName] = value;
    },

    function compare(o1, o2) {
      return foam.util.compare(o1, o2);
    },

    function isOrderSelectable(order) {
      // no ordering, no problem
      if ( ! order ) return true;

      // if this index can sort, it's up to our tail to sub-sort
      if ( foam.util.equals(order.orderPrimaryProperty(), this.prop) ) {
        // If the subestimate is less than sort cost (N*lg(N) for a dummy size of 1000)
        return 9965 >
          this.tail.estimate(1000, this.NullSink.create(), 0, 0, order.orderTail())
      }
      // can't use select() with the given ordering
      return false;
    },

    function estimate(size, sink, skip, limit, order, predicate) {
      // small sizes don't matter
      if ( size <= 16 ) return Math.log(size) / Math.log(2);

      // if only estimating by ordering, just check if we can scan it
      //  otherwise return the sort cost.
      // NOTE: This is conceptually the right thing to do, but also helps
      //   speed up isOrderSelectable() calls on this:
      //   a.isOrderSelectable(o) -> b.estimate(..o) -> b.isOrderSelectable(o) ...
      //   Which makes it efficient but removes the need for Index to
      //   have an isOrderSelectable() method forwarding directly.
      if ( order && ! ( predicate || skip || limit ) ) {
        return this.isOrderSelectable(order) ? size :
          size * Math.log(size) / Math.log(2);
      }

      var self = this;
      predicate = predicate ? predicate.clone() : null;
      var property = this.prop;
      // TODO: validate this assumption:
      var nodeCount = Math.floor(size * 0.25); // tree node count will be a quarter the total item count

      var isExprMatch = this.IS_EXPR_MATCH_FN.bind(this, predicate, property);

      var tail = this.tail;
      var subEstimate = ( tail ) ? function() {
          return Math.log(nodeCount) / Math.log(2) +
            tail.estimate(size / nodeCount, sink, skip, limit, order, predicate);
        } :
        function() { return Math.log(nodeCount) / Math.log(2); };

      var expr = isExprMatch(this.In);
      if ( expr ) {
        var numCmp = expr.arg2 ? expr.arg2.f().length : 0;
        // tree depth * number of compares
        return subEstimate() * numCmp;
      }

      expr = isExprMatch(this.Eq);
      if ( expr ) {
        // tree depth
        return subEstimate();
      }

      expr = isExprMatch(this.ContainsIC);
      if ( expr ) ic = true;
      expr = expr || isExprMatch(this.Contains);
      if ( expr ) {
        // TODO: this isn't quite right. Tree depth * query string length?
        // If building a trie to help with this, estimate becomes easier.
        return subEstimate() * expr.arg2.f().length;
      }

      // At this point we are going to scan all or part of the tree
      //  with select()
      var cost = size;

      // These cases are just slightly better scans, but we can't estimate
      //   how much better... maybe half
      if ( isExprMatch(this.Gt) || isExprMatch(this.Gte) ||
          isExprMatch(this.Lt) || isExprMatch(this.Lte) ) {
        cost /= 2;
      }

      // Ordering
      // if sorting required, add the sort cost
      if ( ! this.isOrderSelectable(order) ) {
        // this index or a tail index can't sort this ordering,
        // manual sort required
        if ( cost > 0 ) cost *= Math.log(cost) / Math.log(2);
      }

      return cost;
    },

    function toString() {
      return '[' + this.cls_.name + ': ' + this.prop.name + ' ' + this.tail.toString() + ']';
    },

    function toPrettyString(indent) {
      var ret = '';
      //ret += "  ".repeat(indent) + this.cls_.name + "( " + this.prop.name + "\n";
      //ret += this.tail.toPrettyString(indent + 1);
      //ret += "  ".repeat(indent) + ")\n";
      var tail = this.tail.toPrettyString(indent + 1);
      ret = '  '.repeat(indent) + this.prop.name + '(' + this.$UID + ')\n';
      if ( tail.trim().length > 0 ) ret += tail;
      return ret;
    }
  ]
});


/** A tree-based Index. Defaults to an AATree (balanced binary search tree) **/
foam.CLASS({
  package: 'foam.dao.index',
  name: 'TreeIndexNode',
  extends: 'foam.dao.index.IndexNode',

  properties: [
    {
      class: 'Simple',
      name: 'selectCount',
    },
    {
      class: 'Simple',
      name: 'root',
    }
  ],

  methods: [
    function init() {
      this.root = this.root || this.index.nullNode;
      this.selectCount = this.selectCount || 0;
    },

    /**
     * Bulk load an unsorted array of objects.
     * Faster than loading individually, and produces a balanced tree.
     **/
    function bulkLoad(a) {
      a = a.array || a;
      this.root = this.index.nullNode;

      // Only safe if children aren't themselves trees
      // TODO: should this be !TreeIndex.isInstance? or are we talking any
      // non-simple index, and is ValueIndex the only simple index?
      // It's the default, so ok for now
      if ( this.index.ValueIndex.isInstance(this.tail) ) {
        var prop = this.index.prop;
        a.sort(prop.compare.bind(prop));
        this.root = this.root.bulkLoad_(a, 0, a.length-1, prop.f);
      } else {
        for ( var i = 0 ; i < a.length ; i++ ) {
          this.put(a[i]);
        }
      }
    },

    function put(newValue) {
      this.root = this.root.putKeyValue(
          this.index.prop.f(newValue),
          newValue,
          this.index.compare,
          this.index.dedup,
          this.selectCount > 0);
    },

    function remove(value) {
      this.root = this.root.removeKeyValue(
          this.index.prop.f(value),
          value,
          this.index.compare,
          this.selectCount > 0,
          this.index.nullNode);
    },

    function get(key) {
      // does not delve into sub-indexes
      return this.root.get(key, this.index.compare);
    },

    function select(sink, skip, limit, order, predicate, cache) {
      // AATree node will extract orderDirs.next for the tail index
      if ( order && order.orderDirection() < 0 ) {
        this.root.selectReverse(sink, skip, limit, order, predicate, cache);
      } else {
        this.root.select(sink, skip, limit, order, predicate, cache);
      }
    },

    function size() { return this.root.size; },

    function plan(sink, skip, limit, order, predicate, root) {
      var index = this;
      var m = this.index;


      if ( m.False.isInstance(predicate) ) return m.NotFoundPlan.create();

      if ( ! predicate && m.Count.isInstance(sink) ) {
        var count = this.size();
        //        console.log('**************** COUNT SHORT-CIRCUIT ****************', count, this.toString());
        return m.CountPlan.create({ count: count });
      }

      var prop = m.prop;

      if ( foam.mlang.sink.GroupBy.isInstance(sink) && sink.arg1 === prop ) {
      // console.log('**************** GROUP-BY SHORT-CIRCUIT ****************');
      // TODO: allow sink to split up, for GroupBy passing one sub-sink to each tree node
      //  for grouping. Allow sink to suggest order, if order not defined
      //    sink.subSink(key) => sink
      //    sink.defaultOrder() => Comparator
      }

      var result, subPlan, cost;

      var isExprMatch = m.IS_EXPR_MATCH_FN.bind(this, predicate, prop);

      var expr = isExprMatch(m.In);
      if ( expr ) {
        predicate = expr.predicate;
        // Marshalled empty array may be undefined.
        var keys = expr.arg2.f() || [];
        // Just scan if that would be faster.
        if ( Math.log(this.size()) / Math.log(2) * keys.length < this.size() ) {
          var subPlans = [];
          cost = 1;

          for ( var i = 0 ; i < keys.length ; ++i) {
            result = this.get(keys[i]);

            if ( result ) { // TODO: could refactor this subindex recursion into .plan()
              subPlan = result.plan(sink, skip, limit, order, predicate, root);

              cost += subPlan.cost;
              subPlans.push(subPlan);
            }
          }

          if ( subPlans.length === 0 ) return m.NotFoundPlan.create();

          return m.MergePlan.create({
            subPlans: subPlans,
            prop: prop
          });
        }
      }

      expr = isExprMatch(m.Eq);
      if ( expr ) {
        predicate = expr.predicate;
        var key = expr.arg2.f();
        result = this.get(key, this.index.compare);

        if ( ! result ) return m.NotFoundPlan.create();

        subPlan = result.plan(sink, skip, limit, order, predicate, root);

        return subPlan;
      }

      var ic = false;
      expr = isExprMatch(m.ContainsIC);
      if ( expr ) ic = true;
      expr = expr || isExprMatch(m.Contains);
      if ( expr ) {
        predicate = expr.predicate;
        var key = ic ? expr.arg2.f().toLowerCase() : expr.arg2.f();

        // Substring comparison function:
        // returns 0 if nodeKey contains masterKey.
        // returns -1 if nodeKey is shorter than masterKey
        // returns 1 if nodeKey is longer or equal length, but does not contain masterKey
        var compareSubstring = function compareSubstring(nodeKey, masterKey) {
          // nodeKey can't contain masterKey if it's too short
          if ( ( ! nodeKey ) || ( ! nodeKey.indexOf ) || ( nodeKey.length < masterKey.length ) ) return -1;

          if ( ic ) nodeKey = nodeKey.toLowerCase(); // TODO: handle case-insensitive better

          return nodeKey.indexOf(masterKey) > -1 ? 0 : 1;
        }

        var indexes = [];
        if ( ! key || key.length === 0 ) {
          // everything contains 'nothing'
          this.root.getAll('', function() { return 0; }, indexes);
        } else {
          this.root.getAll(key, compareSubstring, indexes);
        }
        var subPlans = [];
        // iterate over all keys
        for ( var i = 0; i < indexes.length; i++ ) {
          subPlans.push(indexes[i].plan(sink, skip, limit, order, predicate, root));
        }

        return m.MergePlan.create({
          subPlans: subPlans,
          prop: prop
        });
      }

      // Restrict the subtree to search as necessary
      var subTree = this.root;

      expr = isExprMatch(m.Gt);
      if ( expr ) subTree = subTree.gt(expr.arg2.f(), this.index.compare);

      expr = isExprMatch(m.Gte);
      if ( expr ) subTree = subTree.gte(expr.arg2.f(), this.index.compare, this.index.nullNode);

      expr = isExprMatch(m.Lt);
      if ( expr ) subTree = subTree.lt(expr.arg2.f(), this.index.compare);

      expr = isExprMatch(m.Lte);
      if ( expr ) subTree = subTree.lte(expr.arg2.f(), this.index.compare, this.index.nullNode);

      cost = subTree.size;
      var sortRequired = ! this.index.isOrderSelectable(order);
      var reverseSort = false;

      var subOrder;
      var orderDirections;
      if ( order && ! sortRequired ) {
        // we manage the direction of the first scan directly,
        // tail indexes will use the order.orderTail()
        if ( order.orderDirection() < 0 ) reverseSort = true;
      }

      if ( ! sortRequired ) {
        if ( skip ) cost -= skip;
        if ( limit ) cost = Math.min(cost, limit);
      } else {
        // add sort cost
        if ( cost !== 0 ) cost *= Math.log(cost) / Math.log(2);
      }

      return m.CustomPlan.create({
        cost: cost,
        customExecute: function(promise, sink, skip, limit, order, predicate) {
          if ( sortRequired ) {
            var arrSink = m.ArraySink.create();
            index.selectCount++;
            subTree.select(arrSink, null, null, null, predicate, {});
            index.selectCount--;
            var a = arrSink.array;
            a.sort(order.compare.bind(order));

            skip = skip || 0;
            limit = Number.isFinite(limit) ? limit : a.length;
            limit += skip;
            limit = Math.min(a.length, limit);

            var sub = foam.core.FObject.create();
            var detached = false;
            sub.onDetach(function() { detached = true; });
            for ( var i = skip; i < limit; i++ ) {
              sink.put(a[i], sub);
              if ( detached ) break;
            }
          } else {
            index.selectCount++;
            // Note: pass skip and limit by reference, as they are modified in place
            reverseSort ?
              subTree.selectReverse(
                sink,
                skip != null ? [skip] : null,
                limit != null ? [limit] : null,
                order, predicate, {}) : subTree.select(
                  sink,
                  skip != null ? [skip] : null,
                  limit != null ? [limit] : null,
                  order, predicate, {}) ;
            index.selectCount--;
          }
        },
        customToString: function() {
          return 'scan(key=' + prop.name + ', cost=' + this.cost +
              ', sorting=' + ( sortRequired ? order.toString() : 'none' ) +
              ', reverseScan=' + reverseSort +
              (predicate && predicate.toSQL ? ', predicate: ' + predicate.toSQL() : '') +
              ')';
        }
      });
    },

    function toString() {
      return 'TreeIndex(' + (this.index || this).prop.name + ', ' + (this.index || this).tail + ')';
    }
  ]
});


/** Case-Insensitive TreeIndex **/
foam.CLASS({
  package: 'foam.dao.index',
  name: 'CITreeIndex',
  extends: 'foam.dao.index.TreeIndex',
});


foam.CLASS({
  package: 'foam.dao.index',
  name: 'CITreeIndexNode',
  extends: 'foam.dao.index.TreeIndexNode',

  methods: [
    function put(newValue) {
      this.root = this.root.putKeyValue(
          this.index.prop.f(newValue).toLowerCase(),
          newValue,
          this.index.compare,
          this.index.dedup,
          this.selectCount > 0);
    },

    function remove(value) {
      this.root = this.root.removeKeyValue(
          this.index.prop.f(value).toLowerCase(),
          value,
          this.index.compare,
          this.selectCount > 0,
          this.index.nullNode);
    },

    /**
     * Do not optimize bulkload
     **/
    function bulkLoad(a) {
      a = a.array || a;
      this.root = this.index.nullNode;
      for ( var i = 0 ; i < a.length ; i++ ) {
        this.put(a[i]);
      }
    }
  ]
});


/** An Index for storing multi-valued properties. **/
foam.CLASS({
  package: 'foam.dao.index',
  name: 'SetIndex',
  extends: 'foam.dao.index.TreeIndex',
});


foam.CLASS({
  package: 'foam.dao.index',
  name: 'SetIndexNode',
  extends: 'foam.dao.index.TreeIndexNode',

  methods: [
    // TODO: see if this can be done some other way
    function dedup() {
      // NOP, not safe to do here
    },

    /**
     * Do not optimize bulkload to SetIndex
     **/
    function bulkLoad(a) {
      a = a.array || a;
      this.root = this.index.nullNode;
      for ( var i = 0 ; i < a.length ; i++ ) {
        this.put(a[i]);
      }
    },

    function put(newValue) {
      var a = this.index.prop.f(newValue);

      if ( a.length ) {
        for ( var i = 0 ; i < a.length ; i++ ) {
          this.root = this.root.putKeyValue(
              a[i],
              newValue,
              this.index.compare,
              this.index.dedup);
        }
      } else {
        this.root = this.root.putKeyValue('', newValue, this.index.compare, this.index.dedup);
      }
    },

    function remove(value) {
      var a = this.index.prop.f(value);

      if ( a.length ) {
        for ( var i = 0 ; i < a.length ; i++ ) {
          this.root = this.root.removeKeyValue(a[i], value, this.index.compare, this.index.nullNode);
        }
      } else {
        this.root = this.root.removeKeyValue('', value, this.index.compare, this.index.nullNode);
      }
    }
  ]
});
/**
 * @license
 * Copyright 2016 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/** An Index which adds other indices as needed. **/
foam.CLASS({
  package: 'foam.dao.index',
  name: 'AutoIndex',
  extends: 'foam.dao.index.ProxyIndex',

  requires: [
    'foam.core.Property',
    'foam.dao.index.NoPlan',
    'foam.dao.index.CustomPlan',
    'foam.mlang.predicate.And',
    'foam.mlang.predicate.Or',
    'foam.dao.index.AltIndex',
    'foam.dao.index.ValueIndex',
    'foam.mlang.predicate.True',
    'foam.mlang.predicate.False',
  ],

  constants: {
    /** Maximum cost for a plan which is good enough to not bother looking at the rest. */
    GOOD_ENOUGH_PLAN: 20
  },

  properties: [
    {
      /** Used to create the delegate ID index for new instances of AutoIndex */
      name: 'idIndex',
      required: true
    },
    {
      name: 'delegate',
      factory: function() {
        return this.AltIndex.create({ delegates: [ this.idIndex ] });
      }
    }
  ],

  methods: [
    function estimate(size, sink, skip, limit, order, predicate) {
      return this.delegate.estimate(size, sink, skip, limit, order, predicate);
    },

    function toPrettyString(indent) {
      var ret = '';
      ret = '  '.repeat(indent) + 'Auto(' + this.$UID + ')\n';
      ret += this.delegate.toPrettyString(indent + 1);
      return ret;
    }

  ]
});


foam.CLASS({
  package: 'foam.dao.index',
  name: 'AutoIndexNode',
  extends: 'foam.dao.index.ProxyIndexNode',

  methods: [
    function addPropertyIndex(prop, root) {
      this.addIndex(prop.toIndex(this.index.cls_.create({
        idIndex: this.index.idIndex
      })), root);
    },

    function addIndex(index, root) {
      this.delegate.addIndex(index, root);
    },

    // TODO: mlang comparators should support input collection for
    //   index-building cases like this
    function plan(sink, skip, limit, order, predicate, root) {
      // NOTE: Using the existing index's plan as its cost when comparing
      //  against estimates is bad. An optimistic estimate from an index
      //  will cause it to always appear better than its real world
      //  performance, leading AutoIndex to keep creating new instances
      //  of the offending index. Comparing estimates to estimates is much
      //  more consistent and allows estimate() to be arbitrarily bad
      //  as long as it is indicative of relative performance of each
      //  index type.
      var existingPlan = this.delegate.plan(sink, skip, limit, order, predicate, root);
      var thisSize = this.size();

      // No need to try to auto-index if:
      //  - The existing plan is better than scanning already TODO: how much better?
      //  - We are too small to matter
      //  - There are no order/predicate constraints to optimize for
      if ( existingPlan.cost < thisSize ||
           thisSize < this.index.GOOD_ENOUGH_PLAN ||
           ! order &&
           ( ! predicate ||
             this.index.True.isInstance(predicate) ||
             this.index.False.isInstance(predicate)
           )
      ) {
        return existingPlan;
      }

      // add autoindex overhead
      existingPlan.cost += 10;

      var ARBITRARY_INDEX_CREATE_FACTOR = 1.5;
      var ARBITRARY_INDEX_CREATE_CONSTANT = 20;

      var self = this;
      var newIndex;

      var bestEstimate = this.delegate.index.estimate(this.delegate.size(), sink, skip, limit, order, predicate);
//console.log(self.$UID, "AutoEst OLD:", bestEstimate, this.delegate.toString().substring(0,20), this.size());
      if ( bestEstimate < this.index.GOOD_ENOUGH_PLAN ) {
        return existingPlan;
      }

      // Base planned cost on the old cost for the plan, to avoid underestimating and making this
      //  index build look too good
      var existingEstimate = bestEstimate;
      var idIndex = this.index.idIndex;

      if ( predicate ) {
        var candidate = predicate.toIndex(
          this.index.cls_.create({ idIndex: idIndex }), 1); // depth 1
        if ( candidate ) {
          var candidateEst = candidate.estimate(this.delegate.size(), sink,
            skip, limit, order, predicate)
            * ARBITRARY_INDEX_CREATE_FACTOR
            + ARBITRARY_INDEX_CREATE_CONSTANT;

//console.log(self.$UID, "AutoEst PRD:", candidateEst, candidate.toString().substring(0,20));
          //TODO: must beat by factor of X? or constant?
          if ( bestEstimate > candidateEst ) {
            newIndex = candidate;
            bestEstimate = candidateEst;
          }
        }
      }

      //  The order index.estimate gets the order AND predicate,
      //   so the predicate might make this index worse
      if ( order ) {
        var candidate = order.toIndex(
          this.index.cls_.create({ idIndex: idIndex }), 1); // depth 1
        if ( candidate ) {
          var candidateEst = candidate.estimate(this.delegate.size(), sink,
            skip, limit, order, predicate)
            * ARBITRARY_INDEX_CREATE_FACTOR
            + ARBITRARY_INDEX_CREATE_CONSTANT;
//console.log(self.$UID, "AutoEst ORD:", candidateEst, candidate.toString().substring(0,20));
          if ( bestEstimate > candidateEst ) {
            newIndex = candidate;
            bestEstimate = candidateEst;
          }
        }
      }


      if ( newIndex ) {
        // Since estimates are only valid compared to other estimates, find the ratio
        //  of our existing index's estimate to our new estimate, and apply that ratio
        //  to the actual cost of the old plan to determine our new index's assumed cost.
        var existingPlanCost = existingPlan.cost;
        var estimateRatio = bestEstimate / existingEstimate;

        return this.index.CustomPlan.create({
          cost: existingPlanCost * estimateRatio,
          customExecute: function autoIndexAdd(apromise, asink, askip, alimit, aorder, apredicate) {

console.log(self.$UID, "BUILDING INDEX", existingPlanCost, estimateRatio, this.cost, predicate && predicate.toString());
//console.log(newIndex.toPrettyString(0));
//console.log(self.$UID, "ROOT          ");
//console.log(root.index.toPrettyString(0));

            self.addIndex(newIndex, root);
            // Avoid a recursive call by hitting our delegate.
            // It should pick the new optimal index.
            self.delegate
              .plan(sink, skip, limit, order, predicate, root)
              .execute(apromise, asink, askip, alimit, aorder, apredicate);
          },
          customToString: function() { return 'AutoIndexAdd cost=' + this.cost + ', ' + newIndex.cls_.name; }
        });
      } else {
        return existingPlan;
      }
    },

    function toString() {
      return 'AutoIndex(' + (this.index || this).delegate.toString() + ')';
    },

  ]
});

/**
 * @license
 * Copyright 2012 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

foam.CLASS({
  package: 'foam.dao',
  name: 'MDAO',
  label: 'Indexed DAO',
  extends: 'foam.dao.AbstractDAO',

  documentation: 'Indexed in-Memory DAO.',

  requires: [
    'foam.dao.ArraySink',
    'foam.dao.ExternalException',
    'foam.dao.InternalException',
    'foam.dao.InvalidArgumentException',
    'foam.dao.index.AltIndex',
    'foam.dao.index.AutoIndex',
    'foam.dao.index.SetIndex',
    'foam.dao.index.TreeIndex',
    'foam.dao.index.ValueIndex',
    'foam.mlang.predicate.Eq',
    'foam.mlang.predicate.True',
    'foam.mlang.predicate.Or',
    'foam.mlang.sink.Explain',
    'foam.dao.index.MergePlan'
  ],

  properties: [
    {
      class: 'Class',
      name:  'of',
      required: true,
      postSet: function() {
        foam.assert(this.of.ID, "MDAO.of must be assigned a FOAM Class " +
          "with an 'id' Property or 'ids' array specified. Missing id in " +
          "class: " + ( this.of && this.of.id ));
      }
    },
    {
      class: 'Boolean',
      name: 'autoIndex'
    },
    {
      name: 'idIndex',
      transient: true
    },
    {
      /** The root IndexNode of our index. */
      name: 'index',
      transient: true
    }
  ],

  methods: [
    function init() {
      // adds the primary key(s) as an index, and stores it for fast find().
      this.addPropertyIndex();
      this.idIndex = this.index;

      if ( this.autoIndex ) {
        this.addIndex(this.AutoIndex.create({ idIndex: this.idIndex.index }));
      }
    },

    /**
     * Add a non-unique index
     * args: one or more properties
     **/
    function addPropertyIndex() {
      var props = Array.from(arguments);

      // Add ID to make each sure the object is uniquely identified
      props.push(this.of.ID);

      return this.addUniqueIndex_.apply(this, props);
    },

    /**
     * Add a unique index
     * args: one or more properties
     * @private
     **/
    function addUniqueIndex_() {
      var index = this.ValueIndex.create();

      for ( var i = arguments.length-1 ; i >= 0 ; i-- ) {
        var prop = arguments[i];

        // Pass previous index as the sub-index of the next level up.
        // (we are working from leaf-most index up to root index in the list)
        index = prop.toIndex(index);
      }

      return this.addIndex(index);
    },

    function addIndex(index) {
      if ( ! this.index ) {
        this.index = index.createNode();
        return this;
      }

      // Upgrade single Index to an AltIndex if required.
      if ( ! this.AltIndex.isInstance(this.index.index) ) {
        this.index = this.AltIndex.create({
          delegates: [ this.index.index ] // create factory
        }).createNode({
          delegates: [ this.index ] // create an instance
        });
      }

      this.index.addIndex(index, this.index);

      return this;
    },

    /**
     * Bulk load data from another DAO.
     * Any data already loaded into this DAO will be lost.
     * @param sink (optional) eof is called when loading is complete.
     **/
    function bulkLoad(dao) {
      var self = this;
      var sink = self.ArraySink.create();
      return dao.select(sink).then(function() {
        var a = sink.array;
        self.index.bulkLoad(a);
        for ( var i = 0; i < a.length; ++i ) {
          var obj = a[i];
        }
      });
    },

    function put_(x, obj) {
      var oldValue = this.findSync_(obj.id);
      if ( oldValue ) {
        this.index.remove(oldValue);
      }
      this.index.put(obj);
      this.pub('on', 'put', obj);
      return Promise.resolve(obj);
    },

    function find_(x, objOrKey) {
      if ( objOrKey === undefined ) {
        return Promise.reject(this.InvalidArgumentException.create({
          message: '"key" cannot be undefined/null'
        }));
      }

      return Promise.resolve(this.findSync_(
          this.of.isInstance(objOrKey) ? objOrKey.id : objOrKey));
    },

    /** internal, synchronous version of find, does not throw */
    function findSync_(key) {
      var index = this.idIndex;
      index = index.get(key);

      if ( index && index.get() ) return index.get();

      return null;
    },

    function remove_(x, obj) {
      if ( ! obj || obj.id === undefined ) {
        return Promise.reject(this.ExternalException.create({ id: 'no_id' })); // TODO: err
      }

      var id   = obj.id;
      var self = this;

      var found = this.findSync_(id);
      if ( found ) {
        self.index.remove(found);
        self.pub('on', 'remove', found);
      }

      return Promise.resolve();
    },

    function removeAll_(x, skip, limit, order, predicate) {
      if ( ! predicate ) predicate = this.True.create();
      var self = this;
      return self.where(predicate).select(self.ArraySink.create()).then(
        function(sink) {
          var a = sink.array;
          for ( var i = 0 ; i < a.length ; i++ ) {
            self.index.remove(a[i]);
            self.pub('on', 'remove', a[i]);
          }
          return Promise.resolve();
        }
      );
    },

    function select_(x, sink, skip, limit, order, predicate) {
      sink = sink || this.ArraySink.create();
      var plan;
//console.log("----select");
      if ( this.Explain.isInstance(sink) ) {
        plan = this.index.plan(sink.arg1, skip, limit, order, predicate, this.index);
        sink.plan = 'cost: ' + plan.cost + ', ' + plan.toString();
        sink && sink.eof && sink.eof();
        return Promise.resolve(sink);
      }

      predicate = predicate && predicate.toDisjunctiveNormalForm();
      if ( ! predicate || ! this.Or.isInstance(predicate) ) {
        plan = this.index.plan(sink, skip, limit, order, predicate, this.index);
      } else {
        plan = this.planForOr(sink, skip, limit, order, predicate);
      }

      var promise = [Promise.resolve()];
      plan.execute(promise, sink, skip, limit, order, predicate);
      return promise[0].then(
        function() {
          sink && sink.eof && sink.eof();
          return Promise.resolve(sink);
        },
        function(err) {
          return Promise.reject(err);
        }
      );
    },

    function planForOr(sink, skip, limit, order, predicate) {
      // if there's a limit, add skip to make sure we get enough results
      //   from each subquery. Our sink will throw out the extra results
      //   after sorting.
      var subLimit = ( limit ? limit + ( skip ? skip : 0 ) : undefined );

      // This is an instance of OR, break up into separate queries
      var args  = predicate.args;
      var plans = [];
      for ( var i = 0 ; i < args.length ; i++ ) {
        // NOTE: we pass sink here, but it's not going to be the one eventually
        // used.
        plans.push(
          this.index.plan(sink, undefined, subLimit, order, args[i], this.index)
        );
      }

      return this.MergePlan.create({ of: this.of, subPlans: plans, predicates: args });
    },

    function toString() {
      return 'MDAO(' + this.cls_.name + ',' + this.index + ')';
    }
  ]
});
/**
 * @license
 * Copyright 2016 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

foam.CLASS({
  package: 'foam.dao',
  name: 'ArrayDAO',
  extends: 'foam.dao.AbstractDAO',

  documentation: 'DAO implementation backed by an array.',

  requires: [
    'foam.dao.ArraySink',
    'foam.mlang.predicate.True'
  ],

  properties: [
    {
      class: 'Class',
      name: 'of',
      factory: function() {
        if ( this.array.length === 0 ) return this.lookup('foam.core.FObject');
        return null;
      }
    },
    {
      name: 'array',
      factory: function() { return []; }
    }
  ],

  methods: [
    function put_(x, obj) {
      for ( var i = 0 ; i < this.array.length ; i++ ) {
        if ( obj.ID.compare(obj, this.array[i]) === 0 ) {
          this.array[i] = obj;
          break;
        }
      }

      if ( i == this.array.length ) this.array.push(obj);
      this.on.put.pub(obj);

      return Promise.resolve(obj);
    },

    function remove_(x, obj) {
      for ( var i = 0 ; i < this.array.length ; i++ ) {
        if ( foam.util.equals(obj.id, this.array[i].id) ) {
          var o2 = this.array.splice(i, 1)[0];
          this.on.remove.pub(o2);
          break;
        }
      }

      return Promise.resolve();
    },

    function select_(x, sink, skip, limit, order, predicate) {
      var resultSink = sink || this.ArraySink.create();

      sink = this.decorateSink_(resultSink, skip, limit, order, predicate);

      var detached = false;
      var sub = foam.core.FObject.create();
      sub.onDetach(function() { detached = true; });

      var self = this;

      return new Promise(function(resolve, reject) {
        for ( var i = 0 ; i < self.array.length ; i++ ) {
          if ( detached ) break;

          sink.put(self.array[i], sub);
        }

        sink.eof();

        resolve(resultSink);
      });
    },

    function removeAll_(x, skip, limit, order, predicate) {
      predicate = predicate || this.True.create();
      skip = skip || 0;
      limit = foam.Number.isInstance(limit) ? limit : Number.MAX_VALUE;

      for ( var i = 0; i < this.array.length && limit > 0; i++ ) {
        if ( predicate.f(this.array[i]) ) {
          if ( skip > 0 ) {
            skip--;
            continue;
          }
          var obj = this.array.splice(i, 1)[0];
          i--;
          limit--;
          this.on.remove.pub(obj);
        }
      }

      return Promise.resolve();
    },

    function find_(x, key) {
      var id = this.of.isInstance(key) ? key.id : key;
      for ( var i = 0 ; i < this.array.length ; i++ ) {
        if ( foam.util.equals(id, this.array[i].id) ) {
          return Promise.resolve(this.array[i]);
        }
      }

      return Promise.resolve(null);
    }
  ]
});
/**
 * @license
 * Copyright 2016 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

foam.CLASS({
  package: 'foam.dao',
  name: 'TimestampDAO',
  extends: 'foam.dao.ProxyDAO',

  documentation: 'DAO decorator that sets the current time on each put() object, provided not already set. By default, the .id proeprty is set.',

  properties: [
    {
      /**
        The property of incoming objects to set.
      */
      class: 'String',
      name: 'property',
      value: 'id'
    }
  ],

  methods: [
    /** For each put() object, set the timestamp if .property is not
      set for that object. */
    function put_(x, obj) {
      if ( ! obj.hasOwnProperty(this.property) ) obj[this.property] = this.nextTimestamp();
      return this.delegate.put_(x, obj);
    },

    /** Generates a timestamp. Override to change the way timestamps are
      created. */
    function nextTimestamp() {
      return Date.now();
    }
  ]
});
/**
 * @license
 * Copyright 2017 The FOAM Authors. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

foam.CLASS({
  package: 'foam.dao',
  name: 'AdapterDAO',
  extends: 'foam.dao.ProxyDAO',

  documentation: `DAO for adapting between "of" input type and "to" delegate
      type. I.e., accept put(<instance-of-"of">), and
      this.delegate.of === this.to.`,

  requires: [ 'foam.dao.ArraySink' ],

  classes: [
    {
      name: 'AdapterSink',
      extends: 'foam.dao.ProxySink',

      properties: [
        {
          class: 'Function',
          name: 'adapt',
          documentation: `"adapt(o)" adapts input to type expected by
              "delegate" sink.`,
          required: true
        }
      ],

      methods: [
        function put(o, sub) {
          this.delegate.put(this.adapt(o), sub);
        },
        function remove(o, sub) {
          this.delegate.remove(this.adapt(o), sub);
        }
      ]
    }
  ],

  properties: [
    {
      name: 'delegate',
      postSet: function(old, nu) {
        if ( ! nu ) return;
        foam.assert(
            nu.of === this.to,
            'Expect AdapterDAO.delegate.of === AdapterDAO.to');
      }
    },
    {
      class: 'Class',
      name: 'to',
      documentation: '"of" of delegate.'
    },
    {
      name: 'Function',
      name: 'adaptToDelegate',
      documentation: `Adapt this's "of" type to "delegate"'s "of" type.`,
      value: function(ctx, obj) {
        if ( ! obj ) return obj;
        if ( ! this.of.isInstance(obj) ) return obj;
        return this.to.create(obj, ctx || this.__subContext__);
      }
    },
    {
      name: 'Function',
      name: 'adaptFromDelegate',
      documentation: `Adapt "delegate"'s "of" type this's "of" type.`,
      value: function(ctx, obj) {
        if ( ! obj ) return obj;
        if ( ! this.to.isInstance(obj) ) return obj;
        return this.of.create(obj, ctx || this.__subContext__);
      }
    },
    {
      name: 'Function',
      name: 'adaptOrder',
      documentation: 'Adapt select() order to order understood by "delegate".',
      // TODO(markdittmer): Smarter default?
      value: function(order) { return order; }
    },
    {
      name: 'Function',
      name: 'adaptPredicate',
      documentation: `Adapt select() predicate to predicate understood by
          "delegate".`,
      // TODO(markdittmer): Smarter default?
      value: function(predicate) { return predicate; }
    }
  ],

  methods: [
    function put_(ctx, obj) {
      return this.delegate.put_(ctx, this.adaptToDelegate(ctx, obj)).
        then(this.adaptFromDelegate.bind(this, ctx));
    },

    function remove_(ctx, obj) {
      return this.delegate.remove_(ctx, this.adaptToDelegate(ctx, obj)).
        then(this.adaptFromDelegate.bind(this, ctx));
    },

    function find_(ctx, objOrId) {
      return this.delegate.find_(ctx, this.adaptToDelegate(ctx, objOrId)).
        then(this.adaptFromDelegate.bind(this, ctx));
    },

    function select_(ctx, sink, skip, limit, order, predicate) {
      sink = sink || this.ArraySink.create();
      var adapterSink = this.AdapterSink.create({
        delegate: sink,
        adapt: this.adaptFromDelegate.bind(this, ctx)
      });
      return this.delegate.select_(
              ctx, adapterSink, skip, limit,
              this.adaptOrder(order), this.adaptPredicate(predicate)).
          then(function() { return sink; });
    },

    function removeAll_(ctx, skip, limit, order, predicate) {
      return this.delegate.removeAll_(
          ctx, skip, limit,
          this.adaptOrder(order), this.adaptPredicate(predicate));
    }
  ]
});
/**
 * @license
 * Copyright 2016 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

foam.CLASS({
  package: 'foam.dao',
  name: 'GUIDDAO',
  extends: 'foam.dao.ProxyDAO',

  documentation: function() {/*
    DAO Decorator that sets a property to a new random GUID (globally unique identifier) on put(), unless value already set.
    By default, the .id property is used.
    <p>
    Use a foam.dao.EasyDAO with guid:true to automatically set GUIDs. Set
    EasyDAO.seqProperty to the desired property name or use the default
    of 'id'.
  */},

  properties: [
    {
      /** The property to set with a random GUID value, if not already set
        on put() objects. */
      class: 'String',
      name: 'property',
      value: 'id'
    },
    {
      javaType: 'foam.core.PropertyInfo',
      javaInfoType: 'foam.core.AbstractObjectPropertyInfo',
      name: 'axiom',
      javaFactory: `
return (foam.core.PropertyInfo)(getOf().getAxiomByName(getProperty()));
      `,
    }
  ],

  methods: [
    /** Ensures all objects put() in have a unique id set.
      @param obj the object to process. */
    {
      name: 'put_',
      code: function put_(x, obj) {
        if ( ! obj.hasOwnProperty(this.property) ) {
          obj[this.property] = foam.uuid.randomGUID();
        }

        return this.delegate.put_(x, obj);
      },
      javaCode: `
Object val = obj.getProperty(getProperty());

if ( "".equals(val) ) {
  getAxiom().set(obj, java.util.UUID.randomUUID().toString());
}

return getDelegate().put_(x, obj);
      `,
    },
  ],

  axioms: [
    {
      buildJavaClass: function(cls) {
        cls.extras.push(`
public GUIDDAO(DAO delegate) {
  System.err.println("Direct constructor use is deprecated. Use Builder instead.");
  setDelegate(delegate);
}
        `);
      },
    },
  ],
});
/**
 * @license
 * Copyright 2016 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

foam.CLASS({
  package: 'foam.dao',
  name: 'ReadOnlyDAO',
  extends: 'foam.dao.ProxyDAO',
  documentation: 'DAO decorator that throws errors on put and remove.',
  methods: [
    {
      name: 'put_',
      javaCode: `throw new UnsupportedOperationException("Cannot put into ReadOnlyDAO");`,
      code: function put_(x, obj) {
      return Promise.reject('Cannot put into ReadOnlyDAO');
      }
    },
    {
      name: 'remove_',
      javaCode: `throw new UnsupportedOperationException("Cannot remove from ReadOnlyDAO");`,
      code: function remove_(x, obj) {
        return Promise.reject('Cannot remove from ReadOnlyDAO');
      }
    },
    {
      name: 'removeAll_',
      javaCode: `throw new UnsupportedOperationException("Cannot removeAll from ReadOnlyDAO");`,
      code: function removeAll() {
        return Promise.reject('Cannot removeAll from ReadOnlyDAO');
      }
    }
  ]
});
/**
 * @license
 * Copyright 2017 The FOAM Authors. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

foam.CLASS({
  package: 'foam.dao',
  name: 'StoreAndForwardDAO',
  extends: 'foam.dao.ProxyDAO',

  documentation: `Store-and-forward (i.e., store-and-retry) failed DAO
    operations. Useful for DAOs that may flake, but eventually succeed.`,


  requires: [ 'foam.dao.InternalException' ],

  classes: [
    {
      name: 'DAOOperation',

      properties: [
        {
          class: 'String',
          documentation: 'DAO method name associated with operation.',
          name: 'methodName',
        },
        {
          documentation: 'Arguments object associated with operation.',
          name: 'args',
        },
        {
          name: 'promise_',
          factory: function() {
            var self = this;
            var resolve;
            var reject;
            var promise = new Promise(function(res, rej) {
              resolve = res;
              reject = rej;
            });
            promise.resolveFunction_ = resolve;
            promise.rejectFunction_ = reject;
            return promise;
          }
        },
        {
          class: 'Function',
          name: 'resolve_',
          factory: function() {
            return this.promise_.resolveFunction_;
          }
        },
        {
          class: 'Function',
          name: 'reject_',
          factory: function() {
            return this.promise_.rejectFunction_;
          }
        }
      ],

      methods: [
        function getPromise() { return this.promise_; }
      ],

      listeners: [
        function resolve() { return this.resolve_.apply(this, arguments); },
        function reject() { return this.reject_.apply(this, arguments); }
      ]
    }
  ],

  properties: [
    {
      name: 'delegate',
      postSet: function(old, nu) {
        if ( this.isForwarding_ )
          this.warn('StoreAndForwardDAO: Delegate while flushing queue!');
        this.forward_();
      }
    },
    {
      class: 'Function',
      documentation: `Determine whether or not an error is sufficiently internal
        to the DAO that it's worth retrying the operation that yeilded the
        error. Default is to retry foam.dao.InternalException errors.`,
      name: 'shouldRetry',
      // TODO(markdittmer): These should be supported by function properties,
      // but they're not.
      /*
      returns: {
        documentation: 'Indicator: Should this error be retried?',
        typeName: 'Boolean',
      },
      args: [
        {
          documentation: 'The error thrown by the delegate DAO.',
          name: 'error',
          typeName: 'Error',
        },
      ],
      */
      value: function(error) {
        return this.InternalException.isInstance(error);
      }
    },
    {
      class: 'FObjectArray',
      of: 'FObject',
      // of: 'DAOOperation',
      documentation: 'Queue for incomplete DAO operations.',
      name: 'q_',
    },
    {
      class: 'Boolean',
      name: 'isForwarding_',
    },
  ],

  methods: [
    function put_() { return this.store_('put_', arguments); },
    function remove_() { return this.store_('remove_', arguments); },
    function find_() { return this.store_('find_', arguments); },
    function select_() { return this.store_('select_', arguments); },
    function removeAll_() { return this.store_('removeAll_', arguments); },

    function store_(methodName, args) {
      // Store DAO operations in order.
      var op = this.DAOOperation.create({
        methodName: methodName,
        args: args,
      });
      this.q_.push(op);
      // If no forwarding in progress then forward this op immediately.
      // Otherwise, in-progress forwarding will get to it eventually.
      if ( ! this.isForwarding_ ) this.forward_();
      // Return Promise associated with completing operation.
      return op.getPromise();
    },
    function forward_() {
      // Guard against flush-to-(no delegate) or attempt to flush empty queue.
      if ( ( ! this.delegate ) || this.q_.length === 0 ) {
        this.isForwarding_ = false;
        return;
      }

      this.isForwarding_ = true;

      var op = this.q_[0];
      this.delegate[op.methodName].apply(this.delegate, op.args)
          .then(this.onComplete.bind(this, op))
          .catch(this.onError.bind(this, op));
    }
  ],

  listeners: [
    {
      name: 'onQ',
      documentation: `Attempt to forward failed operations no more frequently
        than "mergeDelay"ms.`,
      isMerged: 'true',
      mergeDelay: 2000,
      code: function() {
        this.forward_();
      }
    },
    {
      name: 'onComplete',
      documentation: `Operation, "op", just completed successfully, yielding
        "result". Since order is presvered, "op" is at the head of "q_".
        Dequeue "op" and resolve its promise.`,
      code: function(op, result) {
        // Dequeue and resolve completed op; attempt to forward next op.
        this.q_.shift();
        op.resolve(result);
        this.forward_();
      }
    },
    {
      name: 'onError',
      documentation: `Operation, "op", failed, yielding "error". If it should be
        retried, tickle merged listener "onQ" to ensure that it is tried again
        later. Otherwise, discard it from "q_" and reject its promise.`,
      code: function(op, error) {
        // Trigger merged listener to initiate another forwarding attempt.
        if ( this.shouldRetry(error) ) {
          this.isForwarding_ = false;
          this.onQ();
          return;
        }

        // Thrown error not retryable:
        // Dequeue and reject op; attempt to forward next op.
        this.q_.shift();
        op.reject(error);
        this.forward_();
      }
    }
  ]
});
/**
 * @license
 * Copyright 2016 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @license
 * Copyright 2018 The FOAM Authors. All Rights Reserved.
 * http://www.apache.org/licenses/LICENSE-2.0
 */

foam.CLASS({
  package: 'foam.dao',
  name: 'Relationship',
  implements: [ { path: 'foam.mlang.Expressions', java: false } ],

  documentation: 'An Axiom for defining Relationships between models.',

  requires: [
    'foam.dao.RelationshipDAO',
    'foam.dao.ManyToManyRelationshipDAO',
    'foam.dao.ReadOnlyDAO',
    'foam.dao.OneToManyRelationshipProperty',
    'foam.dao.ManyToManyRelationshipProperty'
  ],

  properties: [
    {
      name: 'id',
      hidden: true,
      transient: true,
      getter: function() {
        return this.package ? this.package + '.' + this.name : this.name;
      }
    },
    {
      name: 'package',
      // Default to sourceModel's package if not specified.
      factory: function() {
        return this.lookup(this.sourceModel).package;
      }
    },
    {
      name: 'name',
      class: 'String',
      transient: true,
      hidden: true,
      getter: function() {
        return this.lookup(this.sourceModel).name +
          this.lookup(this.targetModel).name + 'Relationship';
      }
    },
    'forwardName',
    {
      name: 'inverseName',
      class: 'String'
    },
    {
      name: 'cardinality',
      assertValue: function(value) {
        foam.assert(value === '1:*' || value === '*:*',
          'Supported cardinalities are 1:* and *:*');
      },
      value: '1:*'
    },
    {
      class: 'String',
      name: 'sourceModel'
    },
    {
      class: 'String',
      name: 'targetModel'
    },
    {
      class: 'String',
      name: 'junctionModel',
      expression: function(sourceModel, targetModel) {
        return ( this.package ? this.package + '.' : '' ) + this.lookup(sourceModel).name + this.lookup(targetModel).name + 'Junction'; }
    },
    {
      class: 'String',
      name: 'sourceDAOKey',
      expression: function(sourceModel) {
        return foam.String.daoize(this.lookup(sourceModel).name);
      }
    },
    {
      class: 'String',
      name: 'targetDAOKey',
      expression: function(targetModel) {
        return foam.String.daoize(this.lookup(targetModel).name);
      }
    },
    {
      class: 'String',
      name: 'junctionDAOKey',
      expression: function(junctionModel) {
        return foam.String.daoize(this.lookup(junctionModel).name);
      }
    },
    {
      name: 'adaptTarget',
      factory: function() {
        var inverseName = this.inverseName;

        return function(source, target) {
          target[inverseName] = source.id;

          return target;
        }
      }
    },
    {
      class: 'Boolean',
      name: 'oneWay'
    },
    {
      class: 'Map',
      name: 'sourceProperty'
    },
    {
      class: 'Map',
      name: 'targetProperty'
    },
    /* FUTURE:
    {
      name: 'deleteStrategy'
      // prevent, cascade, orphan
    }
    */
  ],

  methods: [
    function init() {
      var sourceProp;
      var targetProp;
      var cardinality   = this.cardinality;
      var forwardName   = this.forwardName;
      var inverseName   = this.inverseName;
      var relationship  = this;
      var sourceModel   = this.sourceModel;
      var targetModel   = this.targetModel;
      var junctionModel = this.junctionModel;
      var source        = this.lookup(sourceModel);
      var target        = this.lookup(targetModel);
      var junction      = this.lookup(junctionModel, true);
      var sourceDAOKey  = this.sourceDAOKey;
      var targetDAOKey  = this.targetDAOKey;

      // Add Relationship to axioms lists for each model, for reference
      source.axiomMap_[this.id] = this;
      // Could be related to itself, so avoid adding twice
      if ( source !== target ) target.axiomMap_[this.id] = this;

      if ( cardinality === '1:*' ) {
        sourceProp = foam.dao.OneToManyRelationshipProperty.create({
          name: forwardName,
          target: target,
          targetPropertyName: inverseName,
          targetDAOKey: targetDAOKey
        }).copyFrom(this.sourceProperty);

        targetProp = foam.core.Reference.create({
          name: inverseName,
          of: sourceModel,
          targetDAOKey: sourceDAOKey
        }).copyFrom(this.targetProperty);
      } else { /* cardinality === '*.*' */
        if ( ! junction ) {
          var name = this.junctionModel.substring(
            this.junctionModel.lastIndexOf('.') + 1);
          var id = this.package + '.' + name;

          foam.CLASS({
            package: this.package,
            name: name,
            ids: [ 'sourceId', 'targetId' ],
            properties: [
              {
                class: 'Reference',
                name: 'sourceId',
                shortName: 's',
                of: source,
              },
              {
                class: 'Reference',
                name: 'targetId',
                shortName: 't',
                of: target
              }
            ]
          });

          junction = this.lookup(this.junctionModel);
        }

        var junctionDAOKey = this.junctionDAOKey;

        sourceProp = foam.dao.ManyToManyRelationshipProperty.create({
          name: forwardName,
          junction: junction,
          junctionDAOKey: junctionDAOKey,
          targetDAOKey: targetDAOKey,
          targetProperty: junction.TARGET_ID,
          sourceProperty: junction.SOURCE_ID
        }).copyFrom(this.sourceProperty);

          // Same as sourceProp except we swap target/source so that this relationship
          // works in the opposite direction.
        targetProp = foam.dao.ManyToManyRelationshipProperty.create({
          name: inverseName,
          junction: junction,
          junctionDAOKey: junctionDAOKey,
          targetDAOKey: sourceDAOKey,
          targetProperty: junction.SOURCE_ID,
          sourceProperty: junction.TARGET_ID
        }).copyFrom(this.targetProperty);
      }

      source.installAxiom(sourceProp);

      if ( ! this.oneWay && ! target.getAxiomByName(targetProp.name) ) {
        target.installAxiom(targetProp);
      }

      /*
      if ( ! this.oneWay ) {
        sourceProperty.preSet = function(_, newValue) {
          if ( newValue ) {
            for ( var i = 0 ; i < sourceProps.length ; i++ ) {
              newValue[targetProps[i].name] = this[sourceProps[i]];
            }
          }
          return newValue;
        };
      }
      */
    }
  ]
});


foam.LIB({
  name: 'foam',
  methods: [
    function RELATIONSHIP(m, opt_ctx) {
      var r = foam.dao.Relationship.create(m, opt_ctx);

      r.validate && r.validate();
      foam.package.registerClass(r);

      return r;
    }
  ]
});

foam.INTERFACE({
  package: 'foam.dao',
  name: 'ManyToManyRelationship',
  methods: [
    {
      name: 'add',
      returns: 'Promise',
      javaReturns: 'void',
      args: [
        { name: 'target', of: 'foam.core.FObject' }
      ]
    },
    {
      name: 'remove',
      returns: 'Promise',
      javaReturns: 'void',
      args: [
        { name: 'target', of: 'foam.core.FObject' }
      ]
    },
    // TODO: These should really be properties.
    {
      name: 'getDAO',
      javaReturns: 'foam.dao.DAO'
    },
    {
      name: 'getJunctionDAO',
      javaReturns: 'foam.dao.DAO'
    },
    {
      name: 'getTargetDAO',
      javaReturns: 'foam.dao.DAO'
    },
  ]
});

foam.CLASS({
  package: 'foam.dao',
  name: 'ManyToManyRelationshipImpl',
  implements: [ 'foam.dao.ManyToManyRelationship' ],
  properties: [
    {
      class: 'Class',
      name: 'junction',
      hidden: true
    },
    {
      class: 'Object',
      name: 'sourceId',
      hidden: true
    },
    {
      class: 'String',
      name: 'targetDAOKey',
      hidden: true
    },
    {
      class: 'String',
      name: 'junctionDAOKey',
      hidden: true
    },
    {
      class: 'Object',
      javaType: 'foam.core.PropertyInfo',
      name: 'targetProperty',
      hidden: true
    },
    {
      class: 'Object',
      javaType: 'foam.core.PropertyInfo',
      name: 'sourceProperty',
      hidden: true
    },
    {
      class: 'foam.dao.DAOProperty',
      name: 'dao',
      label: '',
      // Exclude DAOs (which use object identity for comparison) from comparison
      // of relationship impls.
      comparePropertyValues: function() { return 0; },
      factory: function() {
        return foam.dao.ReadOnlyDAO.create({
          delegate: foam.dao.ManyToManyRelationshipDAO.create({
            relationship: this,
            delegate: this.__context__[this.targetDAOKey]
          }, this)
        }, this);
      },
      javaFactory: `return new foam.dao.ReadOnlyDAO.Builder(getX()).
  setDelegate(new foam.dao.ManyToManyRelationshipDAO.Builder(getX()).
    setRelationship(this).
    setDelegate((foam.dao.DAO)getX().get(getTargetDAOKey())).
    build()).
  build();`
    },
    {
      class: 'foam.dao.DAOProperty',
      name: 'junctionDAO',
      hidden: true,
      // Exclude DAOs (which use object identity for comparison) from comparison
      // of relationship impls.
      comparePropertyValues: function() { return 0; },
      factory: function() {
        return this.__context__[this.junctionDAOKey];
      },
      javaFactory: 'return (foam.dao.DAO)getX().get(getJunctionDAOKey());'
    },
    {
      class: 'foam.dao.DAOProperty',
      name: 'targetDAO',
      hidden: true,
      // Exclude DAOs (which use object identity for comparison) from comparison
      // of relationship impls.
      comparePropertyValues: function() { return 0; },
      factory: function() {
        return this.__context__[this.targetDAOKey];
      },
      javaFactory: 'return (foam.dao.DAO)getX().get(getTargetDAOKey());'
    }
  ],
  methods: [
    {
      name: 'add',
      args: [ { name: 'target', of: 'foam.core.FObject' } ],
      javaCode: 'getJunctionDAO().put(createJunction(((foam.core.Identifiable)target).getPrimaryKey()));',
      code: function add(target) {
        return this.junctionDAO.put(this.createJunction(target.id));
      }
    },
    {
      name: 'remove',
      javaCode: 'getJunctionDAO().put(createJunction(((foam.core.Identifiable)target).getPrimaryKey()));',
      code: function remove(target) {
        return this.junctionDAO.remove(this.createJunction(target.id));
      }
    },
    {
      name: 'createJunction',
      args: [ { name: 'targetId', of: 'Object' } ],
      returns: 'foam.core.FObject',
      javaReturns: 'foam.core.FObject',
      code: function createJunction(targetId) {
        foam.assert( ( ! foam.Undefined.isInstance(this.sourceId) ) &&
                     ( ! foam.Undefined.isInstance(targetId) ),
                    "Cannot create an association with an object that isn't stored in a DAO yet.");
        var junction = this.junction.create(null, this);
        this.targetProperty.set(junction, targetId);
        this.sourceProperty.set(junction, this.sourceId);
        return junction;
      },
      javaCode: `foam.core.FObject junction = (foam.core.FObject)getX().create(getJunction().getObjClass());
getTargetProperty().set(junction, targetId);
getSourceProperty().set(junction, getSourceId());
return junction;
`
    },
    {
      // TODO: Should we remove this, or maybe just the java portion?
      name: 'getDAO',
      returns: 'foam.dao.DAO',
      javaCode: 'return getDao();',
      code: function getDAO() { return this.dao; }
    }
  ],
  actions: [
    {
      name: 'addItem',
      label: 'Add',
      code: function(x) {
        var self = this;
        var dao = x[self.targetDAOKey];

        var controller = foam.comics.DAOController.create({
          createEnabled: false,
          editEnabled: false,
          selectEnabled: true,
          addEnabled: false,
          relationship: this,
          data: dao
        }, x);

        controller.sub('select', function(s, _, id) {
          dao.find(id).then(function(obj) { self.add(obj); });
        });

        x.stack.push({ class: 'foam.comics.DAOControllerView', data: controller });
      }
    },
    {
      name: 'removeItem',
      label: 'Remove',
      code: function(x) {
        var self = this;
        var dao = self.dao;

        var controller = foam.comics.DAOController.create({
          createEnabled: false,
          editEnabled: false,
          selectEnabled: true,
          addEnabled: false,
          relationship: this,
          data: dao
        }, x);

        controller.sub('select', function(s, _, id) {
          dao.find(id).then(function(obj) { self.remove(obj); });
        });

        x.stack.push({ class: 'foam.comics.DAOControllerView', data: controller });
      }
    }
  ]
});

foam.CLASS({
  package: 'foam.dao',
  name: 'OneToManyRelationshipProperty',
  extends: 'foam.dao.DAOProperty',
  properties: [
    ['transient', true],
    ['tableCellFormatter', null],
    ['cloneProperty', function(value, map){}],
    ['javaCloneProperty', '//noop'],
    ['javaDiffProperty', '//noop'],
    {
      class: 'String',
      name: 'targetPropertyName',
      documentation: "We don't just use targetProperty here because at the time that this axiom is created, the target property may not even be installed yet on the target.  So instead we use a combination of targetPropertyName and target class and get the actual property when needed."
    },
    {
      class: 'Class',
      name: 'target'
    },
    {
      class: 'String',
      name: 'targetDAOKey'
    },
    {
      name: 'expression',
      factory: function() {
        // Again, delay resolving the target property until as late as
        // possible.  This factory gets triggered before RELATIONSHIP
        // has a chance to install the target property.
        var target = this.target;
        var targetPropertyName = this.targetPropertyName;
        var targetDAOKey = this.targetDAOKey;

        return function(id) {
          return foam.dao.RelationshipDAO.create({
            sourceId: id,
            targetProperty: target.getAxiomByName(targetPropertyName),
            targetDAOKey: targetDAOKey
          }, this);
        }
      }
    },
    {
      name: 'javaFactory',
      factory: function() {
        return `return new foam.dao.RelationshipDAO.Builder(getX()).
  setSourceId(getId()).
  setTargetProperty(${this.target.id}.${foam.String.constantize(this.targetPropertyName)}).
  setTargetDAOKey("${this.targetDAOKey}").
  build();`;
      }
    }
  ]
});

foam.CLASS({
  package: 'foam.dao',
  name: 'ManyToManyRelationshipProperty',
  extends: 'foam.core.FObjectProperty',
  properties: [
    ['of', 'foam.dao.ManyToManyRelationship'],
    ['transient', true],
    ['tableCellFormatter', null],
    ['cloneProperty', function(value, map) {}],
    ['javaCloneProperty', '//noop'],
    ['javaDiffProperty', '//noop'],
    ['view', { class: 'foam.u2.DetailView', showActions: true } ],
    {
      class: 'Class',
      name: 'junction'
    },
    {
      class: 'Class',
      name: 'target'
    },
    'sourceProperty',
    {
      class: 'String',
      name: 'junctionDAOKey'
    },
    {
      class: 'String',
      name: 'targetDAOKey'
    },
    'targetProperty',
    {
      name: 'expression',
      factory: function() {
        var sourceProperty = this.sourceProperty;
        var targetProperty = this.targetProperty;
        var targetDAOKey = this.targetDAOKey;
        var junctionDAOKey = this.junctionDAOKey;
        var junction = this.junction;

        return function(id) {
          return foam.dao.ManyToManyRelationshipImpl.create({
            sourceId: id,
            sourceProperty: sourceProperty,
            targetProperty: targetProperty,
            targetDAOKey: targetDAOKey,
            junctionDAOKey: junctionDAOKey,
            junction: junction
          }, this);
        };
      }
    },
    {
      name: 'javaFactory',
      factory: function() {
        return `return new foam.dao.ManyToManyRelationshipImpl.Builder(getX()).
  setSourceId(getId()).
  setSourceProperty(${this.sourceProperty.forClass_}.${foam.String.constantize(this.sourceProperty.name)}).
  setTargetProperty(${this.targetProperty.forClass_}.${foam.String.constantize(this.targetProperty.name)}).
  setTargetDAOKey("${this.targetDAOKey}").
  setJunctionDAOKey("${this.junctionDAOKey}").
  setJunction(${this.junction.id}.getOwnClassInfo()).
  build();
`;
      }
    }
  ]
});
/**
 * @license
 * Copyright 2016 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @license
 * Copyright 2018 The FOAM Authors. All Rights Reserved.
 * http://www.apache.org/licenses/LICENSE-2.0
 */

foam.CLASS({
  package: 'foam.dao',
  name: 'RelationshipDAO',
  extends: 'foam.dao.FilteredDAO',
  requires: [
    'foam.mlang.predicate.Eq'
  ],

  documentation: 'Adapts a DAO based on a Relationship.',

  properties: [
    {
      class: 'Object',
      name: 'sourceId'
    },
    {
      class: 'String',
      name: 'targetDAOKey'
    },
    {
      class: 'Object',
      name: 'targetProperty',
      javaType: 'foam.core.PropertyInfo'
    },
    {
      name: 'predicate',
      factory: function() {
        return this.Eq.create({ arg1: this.targetProperty, arg2: this.sourceId });
      },
      javaFactory: 'throw new RuntimeException("TODO");'
    },
    {
      name: 'delegate',
      factory: function() {
        var key      = this.targetDAOKey;
        var delegate = this.__context__[key];

        foam.assert(delegate, 'Missing relationship DAO:', key);

        return delegate;
      },
      javaFactory: 'return (foam.dao.DAO)getX().get(getTargetDAOKey());'
    }
  ],

  methods: [
    {
      name: 'put_',
      javaReturns: 'foam.core.FObject',
      code: function put_(x, obj) {
        return this.SUPER(x, this.adaptTarget(obj));
      },
      javaCode: `return super.put_(x, adaptTarget(obj));`
    },
    {
      name: 'adaptTarget',
      javaReturns: 'foam.core.FObject',
      args: [
        {
          name: 'target',
          javaType: 'foam.core.FObject'
        }
      ],
      javaCode:`getTargetProperty().set(target, getSourceId());
return target;`,
      code: function(target) {
        this.targetProperty.set(target, this.sourceId);
        return target;
      }
    },

    function clone() {
      // Prevent cloneing
      return this;
    }
  ]
});
/**
 * @license
 * Copyright 2017 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @license
 * Copyright 2018 The FOAM Authors. All Rights Reserved.
 * http://www.apache.org/licenses/LICENSE-2.0
 */

foam.CLASS({
  package: 'foam.dao',
  name: 'ManyToManyRelationshipDAO',
  extends: 'foam.dao.ProxyDAO',

  implements: [ { path: 'foam.mlang.Expressions', java: false } ],

  documentation: 'Adapts a DAO based on a *:* Relationship.',

  properties: [
    {
      class: 'FObjectProperty',
      of: 'foam.dao.ManyToManyRelationshipImpl',
      name: 'relationship'
    }
  ],

  methods: [
    {
      name: 'find_',
      code: function find_(x, id) {
        var self = this;
        var junction = this.relationship.createJunction(id)

        return this.relationship.junctionDAO.find(junction.id).then(function(a) {
          return a && self.delegate.find_(x, id);
        });
      }
    },
    {
      name: 'select_',
      code: function select_(x, sink, skip, limit, order, predicate) {
        var self = this;

        return this.relationship.junctionDAO.
          where(self.EQ(this.relationship.sourceProperty, this.relationship.sourceId)).
          select(self.MAP(this.relationship.targetProperty)).then(function(map) {
            return self.delegate.select_(x, sink, skip, limit, order, self.AND(
              predicate || self.TRUE,
              self.IN(self.of.ID, map.delegate.array)));
          });
      },
      javaCode: `foam.mlang.sink.Map junction = (foam.mlang.sink.Map)getRelationship().getJunctionDAO().where(
    foam.mlang.MLang.EQ(getRelationship().getSourceProperty(), getRelationship().getSourceId())).
  select(foam.mlang.MLang.MAP(getRelationship().getTargetProperty(), new foam.dao.ListSink()));

  return getDelegate().where(foam.mlang.MLang.IN(getPrimaryKey(), ((foam.dao.ListSink)(junction.getDelegate())).getData().toArray())).select_(
    x, sink, skip, limit, order, predicate);`
    }
  ]
});
/**
 * @license
 * Copyright 2017 The FOAM Authors. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

foam.CLASS({
  package: 'foam.dao.grid',
  name: 'ManyToManyGridRecord',

  properties: [
    {
      name: 'id',
      getter: function() { return this.target.id; }
    },
    {
      class: 'FObjectProperty',
      name: 'target',
      required: true
    },
    {
      class: 'Array',
      of: 'Boolean',
      name: 'data'
    }
  ]
});
/**
 * @license
 * Copyright 2017 The FOAM Authors. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

foam.CLASS({
  package: 'foam.dao.grid',
  name: 'ManyToManyGridDAO',
  extends: 'foam.dao.ReadOnlyDAO',
  implements: [ 'foam.mlang.Expressions' ],

  documentation: `A DAO that delegates to the "target" side of a many-to-many
      relationship, and maintains a reference to a "sources" DAO of "source"
      objects. This DAO is "of":

      { target, data: Boolean[](is "target" related to ith source) }.

      The DAO is designed for adapting to table views of a relationship grid.
      The preprocessing is implemented at the DAO layer so that it can easily
      pushed off the UI thread.`,

  requires: [ 'foam.dao.ArraySink' ],

  imports: [ 'relationship' ],

  properties: [
    {
      name: 'delegate',
      factory: function() {
        return this.__context__[this.relationship.targetDAOKey];
      }
    },
    {
      class: 'Class',
      name: 'junctionCls',
      factory: function() {
        return this.lookup(this.relationship.junctionModel);
      }
    },
    {
      class: 'foam.dao.DAOProperty',
      name: 'sourceDAO',
      factory: function() {
        return this.__context__[this.relationship.sourceDAOKey];
      }
    },
    {
      class: 'foam.dao.DAOProperty',
      name: 'junctionDAO',
      factory: function() {
        return this.__context__[this.relationship.junctionDAOKey];
      }
    },
    {
      class: 'String',
      name: 'gridClsId',
      factory: function() {
        return this.relationship.junctionModel + 'Grid';
      }
    },
    {
      class: 'Class',
      name: 'of',
      value: 'foam.dao.grid.ManyToManyGridRecord'
    }
  ],

  methods: [
    function find_(x, o) {
      return this.delegate.find_(x, o).
          then(this.addSourcesToTarget.bind(this, x));
    },
    function select_(x, sink, skip, limit, order, predicate) {
      sink = sink || this.ArraySink.create();
      return this.delegate.
          select_(x, this.ArraySink.create(), skip, limit, order, predicate).
          then(this.addSourcesToTargets.bind(this, x, sink)).
          then(function() { sink && sink.eof && sink.eof(); return sink; });
    }
  ],

  listeners: [
    function addSourcesToTarget(x, target) {
      var Cls = this.of;
      return this.sourceDAO.select().
          then(this.getDataForTarget.bind(this, target)).
          then(function(data) {
            return Cls.create({ target: target, data: data }, x);
          });
    },

    function addSourcesToTargets(x, sink, localSink) {
      var put = sink.put.bind(sink);
      var array = localSink.array;
      var promises = new Array(array.length);
      for ( var i = 0; i < array.length; i++ ) {
        promises.push(this.addSourcesToTarget(x, array[i]).then(put));
      }
      return Promise.all(promises);
    },

    function getDataForTarget(target, sink) {
      var sources = sink.array;
      return Promise.all(
          sources.map(this.getDatumForTarget.bind(this, target)));
    },
    
    function getDatumForTarget(target, source) {
      return this.junctionDAO.where(this.AND(
          this.EQ(this.junctionCls.SOURCE_ID, source.id),
          this.EQ(this.junctionCls.TARGET_ID, target.id))).select().
          then(function(arraySink) { return !! arraySink.array[0]; });
    }
  ]
});
/**
 * @license
 * Copyright 2014 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
  LazyCacheDAO can cache successful results from find() and select() on its
  delegate. It only updates after new queries come in, and returns cached
  results immediately, even if new results arrive from the delegate.
  listen or pipe from this DAO to stay up to date.
*/
foam.CLASS({
  package: 'foam.dao',
  name: 'LazyCacheDAO',
  extends: 'foam.dao.ProxyDAO',

  implements: [ 'foam.mlang.Expressions' ],

  requires: [
    'foam.dao.ArraySink',
    'foam.dao.DAOSink'
  ],

  classes: [
    {
      name: 'AnySink',
      properties: [ { class: 'Boolean', name: 'hasAny' } ],
      methods: [ function put() { this.hasAny = true; }, function eof() {} ]
    }
  ],

  properties: [
    {
      /** Set to the desired cache, such as a foam.dao.MDAO. */
      name: 'cache',
      required: true
    },
    {
      /**
        TODO: This is attempting to express a link between two other properties,
        and a side-effect (subscription) is what is desired, not a value. Also
        the cacheSync_ prop needs to be tickled to ensure the link exists.
        Change this to define an expression that defines a run-time 'thing'
        to be done between properties, and allows cleanup when re-evaluating.
        @private
      */
      name: 'cacheSync_',
      expression: function(delegate, cache) {
        var s = this.cacheSyncSub_ = delegate.on.remove.sub(
          function(sub_, on_, remove_, obj) {
            cache.remove(obj);
          }
        );
        return s;
      }
    },
    {
      /** Stores cleanup info for the cache sychronization subscription.
        @private */
      name: 'cacheSyncSub_',
      postSet: function(old, nu) {
        if ( old && old.detach ) old.detach();
      }
    },
    {
      /**
        When true, makes a network call in the background to
        update the record, even on a cache hit.
      */
      class: 'Boolean',
      name: 'refreshOnCacheHit',
      value: false,
    },
    {
      /**
        Whether to populate the cache on select().
      */
      class: 'Boolean',
      name: 'cacheOnSelect',
      value: false
    },
    {
      /**
        Time in milliseconds before we consider the delegate
        results to be stale for a particular predicate and will issue a new
        select.
      */
      class: 'Int',
      name: 'staleTimeout',
      value: 500,
      //units: 'ms',
    },
    {
      /**
        The active promises for remote finds in progress, for re-use
        by subsequent finds made before the previous resolves.
        @private
      */
      name: 'finds_',
      hidden: true,
      transient: true,
      factory: function() { return {}; }
    },
    {
      /**
        The active promises for remote selects in progress, for re-use
        by subsequent selects made before the previous resolves.
        @private
      */
      name: 'selects_',
      hidden: true,
      transient: true,
      factory: function() { return {}; }
    },
    {
      /**
        Generates an internal key to uniquely identify a select.
        @private
      */
      class: 'Function',
      name: 'selectKey',
      value: function(sink, skip, limit, order, predicate /*string*/) {
        return ( predicate && predicate.toString() ) || "" + "," +
          limit + "," + skip + "," + ( order && order.toString() ) || "";
      }
    }
  ],

  methods: [
    /** Ensures removal from both cache and delegate before resolving. */
    function remove_(x, obj) {
      var self = this;
      return self.cache.remove_(x, obj).then(function() {
        return self.delegate.remove_(x, obj);
      });
    },

    /**
      Explicitly update cache, else caller will query stale data if
      the staleTimeout is large
    */
    function put_(x, obj) {
      var self = this;
      return self.delegate.put_(x, obj).then(function(o) {
        return self.cache.put_(x, o);
      });
    },

    /**
      Executes the find on the cache first, and if it fails triggers an
      update from the delegate.
    */
    function find_(x, id) {
      var self = this;
      // TODO: Express this better.
      // Assigning to unused variable to keep Closure happy.
      var _ = self.cacheSync_; // ensures listeners are set
      // TODO: stale timeout on find?

      // Check the in-flight remote finds_
      if ( self.finds_[id] ) {
        // Attach myself if there's one for this id, since the cache must
        // have already failed
        return self.finds_[id];
      } else {
        // Try the cache
        return self.cache.find_(x, id).then(

          function (val) {
            // Cache hit, but create background request if required
            if ( val ) {
              if ( self.refreshOnCacheHit ) {
                // Don't record in finds_, since we don't want anyone waiting for it
                self.delegate.find_(x, id).then(function (val) {
                  val && self.cache.put_(x, val);
                });
              }
              return val;
            }
            // Failed to find in cache, so try remote.
            // Another request may have come in the meantime, so check again for
            // an in-flight find for this ID.
            if ( ! self.finds_[id] ) {
              self.finds_[id] = self.delegate.find_(x, id);
              // we created the remote request, so clean up finds_ later
              var errorHandler = function(err) {
                delete self.finds_[id]; // in error case, still clean up
                throw err;
              };

              return self.finds_[id].then(function (val) {
                // once the cache is updated, remove this stale promise
                if ( ! val ) {
                  delete self.finds_[id];
                  return null;
                }

                return self.cache.put_(x, val).then(function(val) {
                  delete self.finds_[id];
                  return val;
                }, errorHandler);
              }, errorHandler);
            } else {
              // piggyback on an existing update request, cleanup already handled
              return self.finds_[id];
            }
          }
        );
      }
    },

    /**
      Executes the select on the cache first, and if it fails triggers an
      update from the delegate.
      <p>
      If .cacheOnSelect is false, the select()
      bypasses the cache and goes directly to the delegate.
    */
    function select_(x, sink, skip, limit, order, predicate) {
      if ( ! this.cacheOnSelect ) {
        return this.SUPER(x, sink, skip, limit, order, predicate);
      }
      sink = sink || this.ArraySink.create();
      var key = this.selectKey(sink, skip, limit, order, predicate);
      var self = this;
      // Assigning to unused variable to keep Closure happy.
      // TODO: Express this better.
      var _ = self.cacheSync_; // Ensures listeners are set.

      // Check for missing or stale remote request. If needed, immediately
      // start a new one that will trigger a reset of this when complete.
      // TODO: Entries are retained for every query, never deleted. Is that ok?
      var entry = self.selects_[key];
      if ( ! entry || ( Date.now() - entry.time ) > self.staleTimeout ) {
        self.selects_[key] = entry = {
          time: Date.now(),
          promise:
            self.delegate.select_(x, self.DAOSink.create({ dao: self.cache }), skip, limit, order, predicate)
              .then(function(cache) {
                self.onCacheUpdate();
                return cache;
              })
        };
      }

      function readFromCache() {
        return self.cache.select_(x, sink, skip, limit, order, predicate);
      }

      // If anything exists in the cache for this query, return it (updates
      // may arrive later and trigger a reset notification). If nothing,
      // wait on the pending cache update.
      return self.cache.select_(
          x, this.AnySink.create(), skip, 1, order, predicate)
              .then(function(hasAny) {
                if ( hasAny.hasAny ) {
                  return readFromCache();
                } else {
                  return entry.promise.then(readFromCache);
                }
              });
    }
  ],

  listeners: [
    {
      /* replaces self.pub('on', 'reset') in select promise select
         which was triggering repeated/cyclic onDAOUpdate in caller */
      name: 'onCacheUpdate',
      isMerged: true,
      code: function() {
        this.pub('on', 'reset');
      }
    }
  ]
});
/**
 * @license
 * Copyright 2016 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
  CachingDAO will do all queries from its fast cache. Writes
  are sent through to the src and cached before resolving any put() or
  remove().
  <p>
  You can use a foam.dao.EasyDAO with caching:true to use caching
  automatically with an indexed MDAO cache.
  <p>
  The cache maintains full copy of the src, but the src is considered the
  source of truth.
*/
foam.CLASS({
  package: 'foam.dao',
  name: 'CachingDAO',
  extends: 'foam.dao.ProxyDAO',

  requires: [
    'foam.dao.DAOSink',
    'foam.dao.PromisedDAO',
    'foam.dao.QuickSink',
  ],

  properties: [
    {
      /** The source DAO on which to add caching. Writes go straight
        to the src, and cache is updated to match.
      */
      class: 'foam.dao.DAOProperty',
      name: 'src'
    },
    {
      /** The cache to read items quickly. Cache contains a complete
        copy of src. */
      name: 'cache',
    },
    {
      /**
        Set .cache rather than using delegate directly.
        Read operations and notifications go to the cache, waiting
        for the cache to preload the complete src state. 'Unforward'
        ProxyDAO's default forwarding of put/remove/removeAll.
        @private
      */
      class: 'Proxy',
      of: 'foam.dao.DAO',
      name: 'delegate',
      hidden: true,
      topics: [ 'on' ],
      forwards: [ 'find_', 'select_' ],
      expression: function(src, cache) {
        // Preload src into cache, then proxy everything to cache that we
        // don't override explicitly.
        var self = this;
        var cacheFilled = cache.removeAll().then(function() {
          // First clear cache, then load the src into the cache
          return src.select(self.DAOSink.create({dao: cache})).then(function() {
            return cache;
          });
        });
        // The PromisedDAO resolves as our delegate when the cache is ready to use
        return this.PromisedDAO.create({
          promise: cacheFilled
        });
      }
    },
  ],

  methods: [
    function init() {
      this.SUPER();

      var proxy = this.src$proxy;
      proxy.listen(this.QuickSink.create({
        putFn: this.onSrcPut,
        removeFn: this.onSrcRemove,
        resetFn: this.onSrcReset,
      }));
    },

    /** Puts are sent to the cache and to the source, ensuring both
      are up to date. */
    function put_(x, o) {
      var self = this;
      // ensure the returned object from src is cached.
      return self.src.put(o).then(function(srcObj) {
        return self.delegate.put_(x, srcObj);
      })
    },

    /** Removes are sent to the cache and to the source, ensuring both
      are up to date. */
    function remove_(x, o) {
      var self = this;
      return self.src.remove(o).then(function() {
        return self.delegate.remove_(x, o);
      })
    },
   /** removeAll is executed on the cache and the source, ensuring both
      are up to date. */
    function removeAll_(x, skip, limit, order, predicate) {
      var self = this;
      return self.src.removeAll_(x, skip, limit, order, predicate).then(function() {
        return self.delegate.removeAll_(x, skip, limit, order, predicate);
      })
    }
  ],

  listeners: [
    /** Keeps the cache in sync with changes from the source.
      @private */
    function onSrcPut(obj) {
      this.delegate.put(obj);
    },

    /** Keeps the cache in sync with changes from the source.
      @private */
    function onSrcRemove(obj) {
      this.delegate.remove(obj);
    },

    /** Keeps the cache in sync with changes from the source.
      @private */
    function onSrcReset() {
      // TODO: Should this removeAll from the cache?
    }
  ]
});
/**
 * @license
 * Copyright 2015 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

foam.CLASS({
  package: 'foam.dao',
  name: 'DeDupDAO',
  extends: 'foam.dao.ProxyDAO',

  documentation: function() {/*
    DeDupDAO is a decorator that internalizes strings in put() objects to save memory.
    Useful for indexed or cached data.
    <p>
    Use a foam.dao.EasyDAO with dedup:true to automatically apply deduplication.
  */},

  methods: [
    /** Scan each object for strings and internalize them. */
    function put_(x, obj) {
      this.dedup(obj);
      return this.delegate.put_(x, obj);
    },

    /** Internalizes strings in the given object.
      @private */
    function dedup(obj) {
      var inst = obj.instance_;
      for ( var key in inst ) {
        var val = inst[key];
        if ( typeof val === 'string' ) {
          inst[key] = foam.String.intern(val);
        }
      }
    }
  ]
});
/**
 * @license
 * Copyright 2015 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

foam.CLASS({
  package: 'foam.dao',
  name: 'LRUDAOManager',
  implements: [ 'foam.mlang.Expressions' ],

  documentation: 'Manages a DAO\'s size by removing old items. Commonly applied inside a cache to limit the cache\'s size. Item freshness is tracked in a separate DAO.',

  requires: [ 'foam.dao.MDAO' ],

  classes: [
    {
      /** Links an object id to a last-accessed timestamp */
      name: 'LRUCacheItem',
      properties: [
        {
          name: 'id',
        },
        {
          class: 'Int',
          name: 'timestamp'
        }
      ]
    }
  ],

  properties: [
    {
      /** The maximum size to allow the target dao to be. */
      class: 'Int',
      name: 'maxSize',
      value: 100
    },
    {
      /** Tracks the age of items in the target dao. */
      name: 'trackingDAO',
      factory: function() {
        return this.MDAO.create({ of: this.LRUCacheItem });
      }
    },
    {
      /** The DAO to manage. Items will be removed from this DAO as needed. */
      class: 'foam.dao.DAOProperty',
      name: 'dao'
    },
    {
      /** By starting at the current time, this should always be higher
        than previously stored timestamps. (only relevant if trackingDAO
        is persisted.) */
      class: 'Int',
      name: 'lastTimeUsed_',
      factory: function() { return Date.now(); }
    }
  ],

  methods: [
    function init() {
      this.SUPER();

      var proxy = this.dao$proxy;
      proxy.sub('on', 'put',    this.onPut);
      proxy.sub('on', 'remove', this.onRemove);
      proxy.sub('on', 'reset',  this.onReset);
    },

    /** Calculates a timestamp to use in the tracking dao. Override to
      provide a different timestamp calulation. */
    function getTimestamp() {
      // Just increment on each request.
      return this.lastTimeUsed_++;
    },

    function cleanup() {
      var self = this;
      self.trackingDAO
        .orderBy(this.DESC(self.LRUCacheItem.TIMESTAMP))
        .skip(self.maxSize)
        .select({
          put: function(obj) {
            self.dao.remove(obj);
          }
        });
    }
  ],

  listeners: [
    /** Adds the put() item to the tracking dao, runs cleanup() to check
      the dao size. */
    function onPut(s, on, put, obj) {
      var self = this;
      this.trackingDAO.put(
        this.LRUCacheItem.create({
          id: obj.id,
          timestamp: self.getTimestamp()
        })
      ).then(function() {
        self.cleanup();
      });
    },

    /** Clears the remove()'d item from the tracking dao. */
    function onRemove(s, on, remove, obj) {
      // ensure tracking DAO is cleaned up
      this.trackingDAO.remove(obj);
    },

    /** On reset, clear the tracking dao. */
    function onReset(s, on, reset, obj) {
      this.trackingDAO.removeAll(obj);
    }
  ]
});
/**
 * @license
 * Copyright 2014 The FOAM Authors. All Rights Reserved.
 * http://www.apache.org/licenses/LICENSE-2.0
 */

foam.CLASS({
  package: 'foam.dao',
  name: 'SequenceNumberDAO',
  extends: 'foam.dao.ProxyDAO',

  implements: [
    'foam.mlang.Expressions'
  ],

  requires: [
    'foam.dao.InternalException'
  ],

  documentation: 'DAO Decorator which sets a specified property\'s value with an auto-increment sequence number on DAO.put() if the value is set to the default value.',

  properties: [
    {
      /** The property to set uniquely. */
      class: 'String',
      name: 'property',
      value: 'id'
    },
    {
      javaType: 'foam.core.PropertyInfo',
      javaInfoType: 'foam.core.AbstractObjectPropertyInfo',
      name: 'axiom',
      javaFactory: 'return (foam.core.PropertyInfo)(getOf().getAxiomByName(getProperty()));'
    },
    {
      /** The starting sequence value. This will be calclated from the
        existing contents of the delegate DAO, so it is one greater
        than the maximum existing value. */
      class: 'Long',
      name: 'value',
      value: 1
    },
    { /** Returns a promise that fulfills when the maximum existing number
          has been found and assigned to this.value */
      name: 'calcDelegateMax_',
      hidden: true,
      expression: function(delegate, property) {
        // TODO: validate property self.of[self.property.toUpperCase()]
        var self = this;
        return self.delegate.select( // TODO: make it a pipe?
          self.MAX(self.property_)
        ).then(
          function(max) {
            if ( max.value ) self.value = max.value + 1;
          }
        );
      }
    },
    {
      /** @private */
      name: 'property_',
      hidden: true,
      expression: function(property, of) {
        var a = this.of.getAxiomByName(property);
        if ( ! a ) {
          throw this.InternalException.create({message:
              'SequenceNumberDAO specified with invalid property ' +
              property + ' for class ' + this.of
          });
        }
        return a;
      }
    }
  ],

  methods: [
    /** Sets the property on the given object and increments the next value.
      If the unique starting value has not finished calculating, the returned
      promise will not resolve until it is ready. */
    {
      name: 'put_',
      code: function put_(x, obj) {
        var self = this;
        return this.calcDelegateMax_.then(function() {
          if ( ! obj.hasOwnProperty(self.property_.name) ) {
            obj[self.property_.name] = self.value++;
          }

          return self.delegate.put_(x, obj);
        });
      },
      javaCode: `
synchronized (this) {
  if ( ! isPropertySet("value") ) calcDelegateMax_();

  if ( ! getAxiom().isSet(obj) ) {
    getAxiom().set(obj, getValue());
    setValue(getValue() + 1);
  }
}

return getDelegate().put_(x, obj);
      `,
    },
  ],

  axioms: [
    {
      buildJavaClass: function(cls) {
        cls.extras.push(`
/**
 * Calculates the next largest value in the sequence
 */
private void calcDelegateMax_() {
  Sink sink = foam.mlang.MLang.MAX(getAxiom());
  sink = getDelegate().select(sink);
  setValue((long) ( ( (foam.mlang.sink.Max) sink ).getValue() == null ? 1 : ( (Number) ( (foam.mlang.sink.Max) sink ).getValue() ).longValue() + 1.0 ));
}

public SequenceNumberDAO(foam.dao.DAO delegate) {
  System.err.println("Direct constructor use is deprecated. Use Builder instead.");
  setDelegate(delegate);
}
        `);
      },
    },
  ],
});
/**
 * @license
 * Copyright 2016 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

foam.CLASS({
  package: 'foam.dao',
  name: 'ContextualizingDAO',
  extends: 'foam.dao.ProxyDAO',

  documentation: function() {/*
    ContextualizingDAO recreates objects returned by find(), giving them
    access to the exports that this ContextualizingDAO has access to.
    <p>
    If using a foam.dao.EasyDAO, set contextualize:true to automatically
    contextualize objects returned by find().
  */},

  methods: [
    /** Found objects are cloned into the same context as this DAO */
    {
      name: 'find_',
      code: function(x, id) {
        var self = this;
        return self.delegate.find_(x, id).then(function(obj) {
          if ( obj ) return obj.clone(self);
          return null;
        });
      },
      javaCode: `foam.core.FObject ret = super.find_(x, id);
if ( ret != null ) ret.setX(x);
return ret;`
    }
  ]
});
/**
 * @license
 * Copyright 2017 The FOAM Authors. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// TODO(markdittmer): foam.dao.InternalException should be unnecessary here;
// make this a PromisedDAO.
foam.CLASS({
  package: 'foam.dao',
  name: 'VersionNoDAO',
  extends: 'foam.dao.ProxyDAO',
  implements: [ 'foam.mlang.Expressions' ],

  documentation: `DAO decorator that applies an incrementing version number
      to all objects put() and remove()d. Instead of deleting objects that
      are remove()d, a placeholder with a deleted flag is put() in its place.
      This allows foam.dao.SyncDAO clients that are polling a VersionNoDAO to
      recieve deletes from other clients.

      This DAO expects to be "of" a class that has the trait
      foam.version.VersionTrait.

      Note that marking records as deleted violates certain expectaions DAO
      expectations. For example, removing an object and then finding it will not
      yield null, it will yield a record marked as deleted.

      This DAO throws an InternalException when writes are issued before it has
      synchronized its delegate. To get a DAO of this class that can accept
      writes immediately, decorate it with a StoreAndForwardDAO.`,

  requires: [
    'foam.dao.InternalException',
    'foam.version.VersionTrait'
  ],

  properties: [
    {
      name: 'of',
      required: true
    },
    {
      name: 'delegate',
      required: true,
      final: true
    },
    {
      class: 'Int',
      name: 'version',
      value: 1
    },
    {
      class: 'Boolean',
      name: 'ready_'
    }
  ],

  methods: [
    function init() {
      this.validate();
      this.SUPER();

      // Get largest version number in delegate's records.
      this.delegate
          // Like MAX(), but faster on DAOs that can optimize order+limit.
          .orderBy(this.DESC(this.VersionTrait.VERSION_)).limit(1)
          .select().then(function(sink) {
            var propName = this.VersionTrait.VERSION_.name;
            if ( sink.array[0] && sink.array[0][propName] )
              this.version = sink.array[0][propName] + 1;
            this.ready_ = true;
          }.bind(this));
    },
    function validate() {
      this.SUPER();
      if ( ! this.VersionTrait.isSubClass(this.of) ) {
        throw new Error(`VersionNoDAO.of must have trait
                            foam.version.VersionTrait`);
      }
    },
    function put_(x, obj) {
      if ( ! this.ready_ )
        return Promise.reject(this.InternalException.create());

      // Increment version number and put to delegate.
      obj[this.VersionTrait.VERSION_.name] = this.version;
      this.version++;
      return this.delegate.put_(x, obj);
    },
    function remove_(x, obj) {
      if ( ! this.ready_ )
        return Promise.reject(this.InternalException.create());

      // Increment version number and put empty object (except for "id"
      // and "deleted = true") to delegate.
      var deleted = obj.clone(x);
      deleted[this.VersionTrait.DELETED_.name] = true;
      deleted[this.VersionTrait.VERSION_.name] = this.version;
      this.version++;
      return this.delegate.put_(x, deleted);
    },
    function removeAll_(x, skip, limit, order, predicate) {
      if ( ! this.ready_ )
        return Promise.reject(this.InternalException.create());

      // Select relevant records and mark each as deleted via remove_().
      return this.select_(x, null, skip, limit, order, predicate).
          then(function(sink) {
            var array = sink.array;
            var promises = [];
            for ( var i = 0; i < array.length; i++ ) {
              promises.push(this.remove_(x, array[i]));
            }
            return Promise.all(promises);
          }.bind(this));
    }
  ]
});
/**
 * @license
 * Copyright 2017 The FOAM Authors. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

foam.CLASS({
  package: 'foam.dao.sync',
  name: 'SyncRecord',

  documentation: `Used by foam.dao.SyncDAO to track object updates and
      deletions.`,

  properties: [ 'id' ]
});

// Define foam.dao.sync.VersionedSyncRecord.
foam.lookup('foam.version.VersionedClassFactorySingleton').create().get(
    foam.lookup('foam.dao.sync.SyncRecord'));
/**
 * @license
 * Copyright 2016 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

foam.CLASS({
  package: 'foam.dao',
  name: 'SyncDAO',
  extends: 'foam.dao.ProxyDAO',

  documentation: `SyncDAO synchronizes data between multiple clients' offline
      caches and a server. When syncronizing, each client tracks the last-seen
      version of each object, or if the object was deleted. The most recent
      version is retained.

      Objects put to this DAO must be subclasses of foam.version.VersionTrait.
      The "version_" property will be automatically be incremented as changes
      are put() into the SyncDAO. The SyncDAO will expect to find objects in
      remoteDAO that have been marked as deleted; this is interpreted as a
      signal to delete records (during initial sync or polling). Details on
      versioned class generation, and the "version_" and "deleted_" properties
      are in the foam.version package.

      Remote DAOs that interact with SyncDAO clients should be decorated with
      foam.dao.VersionNoDAO, or similar, to provision new version numbers for
      records being stored.`,

  requires: [
    'foam.dao.ArraySink',
    'foam.dao.sync.VersionedSyncRecord',
    'foam.version.VersionTrait'
  ],

  implements: [ 'foam.mlang.Expressions' ],

  imports: [ 'setInterval' ],

  classes: [
    {
      name: 'AdapterSink',
      extends: 'foam.dao.ProxySink',

      properties: [
        {
          class: 'Class',
          name: 'of'
        }
      ],

      methods: [
        function put(o, sub) {
          this.delegate.put(this.of.create(o, this.__subContext__), sub);
        }
      ]
    }
  ],

  properties: [
    {
      class: 'foam.dao.DAOProperty',
      name: 'remoteDAO',
      documentation: 'The shared server DAO to synchronize to.',
      transient: true,
      required: true
    },
    {
      name: 'delegate',
      documentation: 'The local cache to sync with the server DAO.'
    },
    {
      class: 'foam.dao.DAOProperty',
      name: 'syncRecordDAO',
      documentation: `The DAO in which to store VersionedSyncRecords for each
          object. Each client tracks their own sync state in a separate
          syncRecordDAO.`,
      transient: true,
      required: true
    },
    {
      name: 'of',
      documentation: 'The class of object this DAO will store.',
      required: true,
      transient: true
    },
    {
      class: 'Boolean',
      name: 'polling',
      documentation: `If using a remote DAO without push capabilities, such as
          an HTTP server, polling will periodically attempt to synchronize.`,
      postSet: function(old, nu) {
        this.sync_ = nu ? this.pollingSync_ : this.syncToRemote_;
      }
    },
    {
      class: 'Int',
      name: 'pollingFrequency',
      documentation: `If using polling, pollingFrequency will determine the
        number of milliseconds to wait between synchronization attempts.`,
      value: 1000
    },
    {
      name: 'synced',
      documentation: `A promise that resolves after any in-flight
          synchronization pass completes.`,
      factory: function() { return Promise.resolve(); }
    },
    {
      name: 'syncRecordWriteSync_',
      factory: function() { return Promise.resolve(); }
    },
    {
      class: 'Function',
      name: 'sync_',
      documentation: `Selected sync strategy; either syncToRemote_() or
          pollingSync_().`,
      factory: function() {
        return this.polling ? this.pollingSync_ : this.syncToRemote_;
      }
    }
  ],

  methods: [
    function init() {
      this.SUPER();

      this.validate();

      // Only listen to DAOs that support push (i.e., do not require polling).
      if ( ! this.polling )
        this.remoteDAO$proxy.sub('on', this.onRemoteUpdate);

      // Push initial data from delegate.
      var self = this;
      self.synced = self.delegate.select().
          then(function(sink) {
            var minVersionNo = 0;
            var array = sink.array;
            for ( var i = 0; i < array.length; i++ ) {
              var version = self.VersionTrait.VERSION_.f(array[i]);
              self.syncRecordDAO.put(self.VersionedSyncRecord.create({
                id: array[i].id,
                version_: version
              }));
              minVersionNo = Math.max(minVersionNo, version);
            }
            return self.syncFromRemote_(minVersionNo);
          });

      // Setup polling after initial sync.
      if ( ! self.polling ) return;
      self.synced.then(function() {
        self.setInterval(function() {
          self.sync();
        }, self.pollingFrequency);
      });
    },
    function validate() {
      this.SUPER();
      if ( ! this.VersionTrait.isSubClass(this.of) ) {
        throw new Error(`SyncDAO.of must have trait foam.version.VersionTrait`);
      }
    },
    function sync() {
      // Sync after any sync(s) in progress complete.
      return this.synced = this.synced.then(function() {
        return this.sync_();
      }.bind(this));
    },

    //
    // DAO overrides.
    //

    function put_(x, obj) {
      var self = this;
      var ret;
      return self.withSyncRecordTx_(function() {
        return self.delegate.put_(x, obj).then(function(o) {
          ret = o;
          // Updates the object's last seen info.
          return self.syncRecordDAO.put_(x, self.VersionedSyncRecord.create({
            id: o.id,
            version_: -1
          }));
        });
      }).then(self.onLocalUpdate).then(function() { return ret; });
    },
    function remove_(x, obj) {
      var self = this;
      var ret;
      return self.withSyncRecordTx_(function() {
        return self.delegate.remove_(x, obj).then(function(o) {
          ret = o;
          // Marks the object as deleted.
          self.syncRecordDAO.put_(x, self.VersionedSyncRecord.create({
            id: obj.id,
            deleted_: true,
            version_: -1
          }));
        });
      }).then(self.onLocalUpdate).then(function() { return ret; });
    },
    function removeAll_(x, skip, limit, order, predicate) {
      // Marks all the removed objects' sync records as deleted via remove_().
      return this.delegate.select_(x, null, skip, limit, order, predicate).
          then(function(a) {
            a = a.array;
            var promises = [];

            for ( var i = 0 ; i < a.length ; i++ ) {
              promises.push(this.remove_(x, a[i]));
            }

            return Promise.all(promises);
          }.bind(this));
    },

    //
    // Private synchronization details.
    //

    {
      name: 'putFromRemote_',
      documentation: 'Process a put() to cache from remote.',
      code: function(obj) {
        var self = this;
        var ret;
        return self.withSyncRecordTx_(function() {
          return self.delegate.put(obj).then(function(o) {
            ret = o;
            return self.syncRecordDAO.put(self.VersionedSyncRecord.create({
              id: o.id,
              version_: self.VersionTrait.VERSION_.f(o)
            }));
          });
        }).then(function() { return ret; });
      }
    },
    {
      name: 'removeFromRemote_',
      documentation: 'Process a remove() on cache from remote.',
      code: function(obj) {
        var self = this;
        var ret;
        return self.withSyncRecordTx_(function() {
          return self.delegate.remove(obj).then(function(o) {
            ret = o;
            return self.syncRecordDAO.put(self.VersionedSyncRecord.create({
              id: obj.id,
              version_: self.VersionTrait.VERSION_.f(obj),
              deleted_: true
            }));
          });
        }).then(function() { return ret; });
      }
    },
    {
      name: 'resetFromRemote_',
      documentation: 'Process a reset signal on cache from remote.',
      code: function(obj) {
        // Clear sync records and data not associated with unsynced data, then
        // sync.
        var self = this;
        var ret;
        return self.withSyncRecordTx_(function() {
          return self.syncRecordDAO.
              where(self.GT(self.VersionedSyncRecord.VERSION_, -1)).
              removeAll().
              then(self.syncRecordDAO.select.bind(self.syncRecordDAO)).
              then(function(sink) {
                var idsToKeep = sink.array.map(function(syncRecord) {
                  return syncRecord.id;
                });
                return self.delegate.where(
                    self.NOT(self.IN(self.of.ID, idsToKeep))).
                    removeAll();
              });
        }).then(self.sync.bind(self));
      }
    },
    {
      name: 'pollingSync_',
      documentation: `Polling synchronization strategy. Determine current
          version, then push to remote, then pull update from remote.`,
      code: function() {
        var self = this;
        var VERSION_ = self.VersionedSyncRecord.VERSION_;
        return self.syncRecordDAO.
            // Like MAX(), but faster on DAOs that can optimize order+limit.
            orderBy(self.DESC(VERSION_)).limit(1).
            select().then(function(sink) {
              var minVersionNo = sink.array[0] && VERSION_.f(sink.array[0]) ||
                  0;
              return self.syncToRemote_().
                  then(self.syncFromRemote_.bind(self, minVersionNo));
            });
      }
    },
    {
      name: 'syncToRemote_',
      documentation: `Push synchronization strategy: Push data from cach to
          remote; rely on pushed updates from server.`,
      code: function() {
        var self = this;

        return this.syncRecordDAO.
          where(self.EQ(self.VersionedSyncRecord.VERSION_, -1)).
          select().then(function(records) {
            records = records.array;
            var promises = [];

            for ( var i = 0 ; i < records.length ; i++ ) {
              var record = records[i];
              var id = record.id;
              var deleted = self.VersionedSyncRecord.DELETED_.f(record);

              if ( deleted ) {
                var obj = self.of.create(undefined, self);
                obj.id = id;
                var promise = self.remoteDAO.remove(obj);

                // When not polling, server result will processed when
                // onRemoteUpdate listener is fired.
                if ( self.polling ) {
                  promises.push(promise.then(function() {
                    var propName = self.VersionTrait.VERSION_.name;
                    // Ensure that obj SyncRecord does not remain queued (i.e.,
                    // does not have version_ = -1).
                    obj[propName] = Math.max(obj[propName], 0);
                    return self.removeFromRemote_(obj);
                  }));
                } else {
                  promises.push(promise);
                }
              } else {
                // TODO(markdittmer): Deal appropriately with failed updates.
                promises.push(self.delegate.find(id).then(function(obj) {
                  if ( ! obj ) return null;
                  var ret = self.remoteDAO.put(obj);

                  // When not polling, server result will processed when
                  // onRemoteUpdate listener is fired.
                  if ( self.polling ) {
                    ret = ret.then(function(o) {
                      return self.putFromRemote_(o);
                    });
                  }

                  return ret;
                }));
              }
            }

            return Promise.all(promises);
          });
      }
    },
    {
      name: 'syncFromRemote_',
      documentation: `Pull updates from remote; used for initial sync and
          polling sync strategy.`,
      code: function(minVersionNo) {
        var self = this;
        return self.remoteDAO.
            where(self.GT(self.VersionTrait.VERSION_, minVersionNo)).
            orderBy(self.VersionTrait.VERSION_).
            select().then(function(sink) {
              var array = sink.array;
              var promises = [];

              for ( var i = 0 ; i < array.length ; i++ ) {
                if ( self.VersionTrait.DELETED_.f(array[i]) ) {
                  promises.push(self.removeFromRemote_(array[i]));
                } else {
                  promises.push(self.putFromRemote_(array[i]));
                }
              }

              return Promise.all(promises);
            });
      }
    },
    {
      name: 'withSyncRecordTx_',
      documentation: `Run a computation that writes to syncRecordDAO
          transactionally with respect to other syncRecordDAO writes.`,
      code: function(f) {
        return this.syncRecordWriteSync_ = this.syncRecordWriteSync_.then(f);
      }
    }
  ],

  listeners: [
    {
      name: 'onRemoteUpdate',
      documentation: 'Respond to push event from remote.',
      code: function(s, on, event, obj) {
        if ( event == 'put' ) {
          if ( this.VersionTrait.DELETED_.f(obj) ) this.removeFromRemote_(obj);
          else                                     this.putFromRemote_(obj);
        } else if ( event === 'remove' ) {
          throw new Error(`SyncDAO recieved remove() event;
                              expected put(deleted)-as-remove()`);
        } else if ( event === 'reset' ) {
          this.resetFromRemote_();
        }
      }
    },
    {
      name: 'onLocalUpdate',
      isMerged: true,
      mergeDelay: 100,
      code: function() {
        this.sync();
      }
    }
  ]
});
/**
 * @license
 * Copyright 2014 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

foam.CLASS({
  package: 'foam.dao',
  name: 'EasyDAO',
  extends: 'foam.dao.ProxyDAO',
  implements: [ 'foam.mlang.Expressions' ],

  documentation: function() {/*
    Facade for easily creating decorated DAOs.
    <p>
    Most DAOs are most easily created and configured with EasyDAO.
    Simply require foam.dao.EasyDAO and create() with the flags
    to indicate what behavior you're looking for. Under the hood, EasyDAO
    will create one or more DAO instances to service your requirements and then
  */},

  requires: [
    'foam.box.Context',
    'foam.box.HTTPBox',
    'foam.box.SessionClientBox',
    'foam.box.SocketBox',
    'foam.box.WebSocketBox',
    'foam.box.TimeoutBox',
    'foam.box.RetryBox',
    'foam.dao.CachingDAO',
    'foam.dao.CompoundDAODecorator',
    'foam.dao.ContextualizingDAO',
    'foam.dao.DecoratedDAO',
    'foam.dao.DeDupDAO',
    'foam.dao.GUIDDAO',
    'foam.dao.IDBDAO',
    'foam.dao.JDAO',
    'foam.dao.LoggingDAO',
    'foam.dao.MDAO',
    'foam.dao.PromisedDAO',
    'foam.dao.RequestResponseClientDAO',
    'foam.dao.SequenceNumberDAO',
    'foam.dao.SyncDAO',
    'foam.dao.TimingDAO'
  ],

  imports: [ 'document' ],

  constants: {
    // Aliases for daoType
    ALIASES: {
      ARRAY:  'foam.dao.ArrayDAO',
      CLIENT: 'foam.dao.RequestResponseClientDAO',
      IDB:    'foam.dao.IDBDAO',
      LOCAL:  'foam.dao.LocalStorageDAO',
      MDAO:   'foam.dao.MDAO'
    }
  },

  properties: [
    {
      /** The developer-friendly name for this EasyDAO. */
      class: 'String',
      name: 'name',
      factory: function() { return this.of.id; }
    },
    {
      /** This is set automatically when you create an EasyDAO.
        @private */
      name: 'delegate',
      javaFactory: `
foam.dao.DAO delegate = getInnerDAO() == null ?
  new foam.dao.MapDAO(getX(), getOf()) :
  getInnerDAO();

if ( delegate instanceof foam.dao.MDAO ) setMdao((foam.dao.MDAO)delegate);

if ( getJournaled() ) {
  delegate = new foam.dao.JDAO(getX(), delegate, getJournalName());
}

if ( getGuid() && getSeqNo() ) {
  throw new RuntimeException("EasyDAO GUID and SeqNo are mutually exclusive");
}

if ( getGuid() ) {
  delegate = new foam.dao.GUIDDAO.Builder(getX()).setDelegate(delegate).build();
}

if ( getSeqNo() ) {
  delegate = new foam.dao.SequenceNumberDAO.Builder(getX()).
    setDelegate(delegate).
    setProperty(getSeqPropertyName()).
    build();
}

if ( getContextualize() ) {
  delegate = new foam.dao.ContextualizingDAO.Builder(getX()).
    setDelegate(delegate).
    build();
}

if ( getAuthenticate() ) {
  delegate = new foam.dao.AuthenticatedDAO(
    getName(),
    getAuthenticateRead(),
    delegate);
}

if ( getPm() ) {
  delegate = new foam.dao.PMDAO(delegate);
}

return delegate;
`
    },
    {
      class: 'Object',
      javaType: 'foam.dao.DAO',
      name: 'innerDAO'
    },
    {
      /** Have EasyDAO use a sequence number to index items. Note that
        .seqNo and .guid features are mutually
        exclusive. */
      class: 'Boolean',
      name: 'seqNo',
      value: false
    },
    {
      /** Have EasyDAO generate guids to index items. Note that .seqNo and .guid features are mutually exclusive. */
      class: 'Boolean',
      name: 'guid',
      label: 'GUID',
      value: false
    },
    {
      class: 'String',
      name: 'seqPropertyName',
      value: 'id'
    },
    {
      /** The property on your items to use to store the sequence number or guid. This is required for .seqNo or .guid mode. */
      name: 'seqProperty',
      generateJava: false,
      class: 'Property'
    },
    {
      /** Enable local in-memory caching of the DAO. */
      class: 'Boolean',
      name: 'cache',
      generateJava: false,
      value: false
    },
    {
      /** Enable standard authentication. */
      class: 'Boolean',
      name: 'authenticate',
      value: true
    },
    {
      /** Enable standard read authentication. */
      class: 'Boolean',
      name: 'authenticateRead',
      value: true
    },
    {
      /** Enable value de-duplication to save memory when caching. */
      class: 'Boolean',
      name: 'dedup',
      generateJava: false,
      value: false,
    },
    {
      /** Keep a history of all state changes to the DAO. */
      class: 'Boolean',
      name: 'journaled',
      value: false
    },
    {
      class: 'String',
      name: 'journalName'
    },
    {
      class: 'FObjectProperty',
      of: 'foam.dao.Journal',
      generateJava: false,
      name: 'journal'
    },
    {
      /** Enable logging on the DAO. */
      class: 'Boolean',
      name: 'logging',
      value: false,
      generateJava: false
    },
    {
      /** Enable time tracking for concurrent DAO operations. */
      class: 'Boolean',
      name: 'timing',
      generateJava: false,
      value: false
    },
    {
      class: 'Boolean',
      name: 'pm',
      value: false
    },
    {
      /** Contextualize objects on .find, re-creating them with this EasyDAO's
        exports, as if they were children of this EasyDAO. */
      class: 'Boolean',
      name: 'contextualize',
      value: false
    },
//     {
//       class: 'Boolean',
//       name: 'cloning',
//       value: false,
//       //documentation: "True to clone results on select"
//     },
    {
      /**
        <p>Selects the basic functionality this EasyDAO should provide.
        You can specify an instance of a DAO model definition such as
        MDAO, or a constant indicating your requirements.</p>
        <p>Choices are:</p>
        <ul>
          <li>IDB: Use IndexDB for storage.</li>
          <li>LOCAL: Use local storage.</li>
          <li>MDAO: Use non-persistent in-memory storage.</li>
        </ul>
      */
      name: 'daoType',
      generateJava: false,
      value: 'foam.dao.IDBDAO'
    },
    {
      class: 'FObjectProperty',
      of: 'foam.dao.MDAO',
      name: 'mdao'
    },
    {
      /** Automatically generate indexes as necessary, if using an MDAO or cache. */
      class: 'Boolean',
      generateJava: false,
      name: 'autoIndex',
      value: false
    },
//     {
//       /** Creates an internal MigrationDAO and applies the given array of MigrationRule. */
//       class: 'FObjectArray',
//       name: 'migrationRules',
//       of: 'foam.core.dao.MigrationRule',
//     },
    {
      /** Turn on to activate synchronization with a server. Specify serverUri
        and syncProperty as well. */
      class: 'Boolean',
      name: 'syncWithServer',
      generateJava: false,
      value: false
    },
    {
      /** Turn on to enable remote listener support. Only useful with daoType = CLIENT. */
      class: 'Boolean',
      generateJava: false,
      name: 'remoteListenerSupport',
      value: false
    },
    {
      /** Setting to true activates polling, periodically checking in with
        the server. If sockets are used, polling is optional as the server
        can push changes to this client. */
      class: 'Boolean',
      generateJava: false,
      name: 'syncPolling',
      value: true
    },
    {
      /** Set to true if you are running this on a server, and clients will
        synchronize with this DAO. */
      class: 'Boolean',
      generateJava: false,
      name: 'isServer',
      value: false
    },
    {
      /** The property to synchronize on. This is typically an integer value
        indicating the version last seen on the remote. */
      name: 'syncProperty',
      generateJava: false
    },
    {
      /** Destination address for server. */
      name: 'serverBox',
      generateJava: false,
      factory: function() {
        // TODO: This should come from the server via a lookup from a NamedBox.
        return this.SessionClientBox.create({ delegate: this.RetryBox.create({ delegate:
          this.TimeoutBox.create({ delegate:
          this.remoteListenerSupport ?
              this.WebSocketBox.create({ uri: this.serviceName }) :
              this.HTTPBox.create({ url: this.serviceName })
        })})});
      }
    },
    {
      /** Simpler alternative than providing serverBox. */
      name: 'serviceName',
      generateJava: false
    },
    {
      class: 'FObjectArray',
      of: 'foam.dao.DAODecorator',
      generateJava: false,
      name: 'decorators'
    },
    {
      name: 'testData',
      generateJava: false
    }
  ],

  methods: [
    function init() {
      /**
        <p>On initialization, the EasyDAO creates an appropriate chain of
        internal EasyDAO instances based on the EasyDAO
        property settings.</p>
        <p>This process is transparent to the developer, and you can use your
        EasyDAO like any other DAO.</p>
      */
      this.SUPER.apply(this, arguments);

      var daoType = typeof this.daoType === 'string' ?
        this.ALIASES[this.daoType] || this.daoType :
        this.daoType;

      var params = { of: this.of };

      if ( daoType == 'foam.dao.RequestResponseClientDAO' ) {
        foam.assert(this.hasOwnProperty('serverBox') || this.serviceName, 'EasyDAO "client" type requires a serveBox or serviceName');

        // The RequestResonseClientDAO generates listener events locally
        // but with remoteListenerSupport, this isn't needed, so switch
        // to the regular ClientDAO instead.
        if ( this.remoteListenerSupport ) {
          daoType = 'foam.dao.ClientDAO';
        }

        params.delegate = this.serverBox;
      }

      var daoModel = typeof daoType === 'string' ?
        this.lookup(daoType) || global[daoType] :
        daoType;

      if ( ! daoModel ) {
        this.warn(
          "EasyDAO: Unknown DAO Type.  Add '" + daoType + "' to requires: list."
        );
      }

      if ( this.name && daoModel.getAxiomByName('name') ) params.name = this.name;
      if ( daoModel.getAxiomByName('autoIndex') ) params.autoIndex = this.autoIndex;
      //if ( this.seqNo || this.guid ) params.property = this.seqProperty;

      var dao = daoModel.create(params, this.__subContext__);

      // Not used by decorators.
      delete params['name'];

      if ( this.MDAO.isInstance(dao) ) {
        this.mdao = dao;
        if ( this.dedup ) dao = this.DeDupDAO.create({delegate: dao});
      } else {
//         if ( this.migrationRules && this.migrationRules.length ) {
//           dao = this.MigrationDAO.create({
//             delegate: dao,
//             rules: this.migrationRules,
//             name: this.model.id + "_" + daoModel.id + "_" + this.name
//           });
//         }
        if ( this.cache ) {
          this.mdao = this.MDAO.create({of: params.of});
          dao = this.CachingDAO.create({
            cache: this.dedup ?
              this.mdao :
              this.DeDupDAO.create({delegate: this.mdao}),
            src: dao,
            of: this.model});
        }
      }

      if ( this.journal ) {
        dao = this.JDAO.create({
          delegate: dao,
          journal: this.journal
        });
      }

      if ( this.seqNo && this.guid ) throw "EasyDAO 'seqNo' and 'guid' features are mutually exclusive.";

      if ( this.seqNo ) {
        var args = {__proto__: params, delegate: dao, of: this.of};
        if ( this.seqProperty ) args.property = this.seqProperty;
        dao = this.SequenceNumberDAO.create(args);
      }

      if ( this.guid ) {
        var args = {__proto__: params, delegate: dao, of: this.of};
        if ( this.seqProperty ) args.property = this.seqProperty;
        dao = this.GUIDDAO.create(args);
      }

      var cls = this.of;

      if ( this.syncWithServer && this.isServer ) throw "isServer and syncWithServer are mutually exclusive.";

      if ( this.syncWithServer || this.isServer ) {
        if ( ! this.syncProperty ) {
          this.syncProperty = cls.SYNC_PROPERTY;
          if ( ! this.syncProperty ) {
            throw "EasyDAO sync with class " + cls.id + " invalid. Sync requires a sync property be set, or be of a class including a property 'sync_property'.";
          }
        }
      }

      if ( this.syncWithServer ) {
        foam.assert(this.serverBox, 'syncWithServer requires serverBox');

        dao = this.SyncDAO.create({
          remoteDAO: this.RequestResponseClientDAO.create({
              name: this.name,
              delegate: this.serverBox
          }, boxContext),
          syncProperty: this.syncProperty,
          delegate: dao,
          pollingFrequency: 1000
        });
        dao.syncRecordDAO = foam.dao.EasyDAO.create({
          of: dao.SyncRecord,
          cache: true,
          daoType: this.daoType,
          name: this.name + '_SyncRecords'
        });
      }

//       if ( this.isServer ) {
//         dao = this.VersionNoDAO.create({
//           delegate: dao,
//           property: this.syncProperty,
//           version: 2
//         });
//       }

      if ( this.contextualize ) {
        dao = this.ContextualizingDAO.create({delegate: dao});
      }

      if ( this.decorators.length ) {
        var decorated = this.DecoratedDAO.create({
          decorator: this.CompoundDAODecorator.create({
            decorators: this.decorators
          }),
          delegate: dao
        });
        dao = decorated;
      }

      if ( this.timing  ) {
        dao = this.TimingDAO.create({ name: this.name + 'DAO', delegate: dao });
      }

      if ( this.logging ) {
        dao = this.LoggingDAO.create({ delegate: dao });
      }

      var self = this;

      if ( decorated ) decorated.dao = dao;

      if ( this.testData ) {
        var delegate = dao;

        dao = this.PromisedDAO.create({
          promise: new Promise(function(resolve, reject) {
            delegate.select(self.COUNT()).then(function(c) {
              // Only load testData if DAO is empty
              if ( c.value ) {
                resolve(delegate);
                return;
              }

              self.log("Loading test data");
              Promise.all(foam.json.parse(self.testData, self.of, self).map(
                function(o) { return delegate.put(o); }
              )).then(function() {
                self.log("Loaded", self.testData.length, "records.");
                resolve(delegate);
              }, reject);
            });
          })
        });
      }

      this.delegate = dao;
    },

    /** Only relevant if cache is true or if daoType
       was set to MDAO, but harmless otherwise. Generates an index
       for a query over all specified properties together.
       @param var_args specify any number of Properties to be indexed.
    */
    {
      name: 'addPropertyIndex',
      returns: 'foam.dao.EasyDAO',
      javaReturns: 'foam.dao.EasyDAO',
      args: [ { javaType: 'foam.core.PropertyInfo', name: 'prop' } ],
      code:     function addPropertyIndex() {
        this.mdao && this.mdao.addPropertyIndex.apply(this.mdao, arguments);
        return this;
      },
      javaCode: `
if ( getMdao() != null ) {
  getMdao().addIndex(prop);
}
return this;
`
    },

    /** Only relevant if cache is true or if daoType
      was set to MDAO, but harmless otherwise. Adds an existing index
      to the MDAO.
      @param index The index to add.
    */
    {
      name: 'addIndex',
      returns: 'foam.dao.EasyDAO',
      javaReturns: 'foam.dao.EasyDAO',
      args: [ { javaType: 'foam.dao.index.Index', name: 'index' } ],
      code: function addIndex(index) {
        this.mdao && this.mdao.addIndex.apply(this.mdao, arguments);
        return this;
      },
      javaCode: `
if ( getMdao() != null ) {
  getMdao().addIndex(index);
}
return this;
`
    }
  ]
});
/**
 * @license
 * Copyright 2015 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

foam.CLASS({
  package: 'foam.dao',
  name: 'NoSelectAllDAO',
  extends: 'foam.dao.ProxyDAO',

  requires: [
    'foam.dao.ArraySink',
    'foam.mlang.predicate.True',
    'foam.mlang.predicate.False'
  ],

  documentation: 'DAO Decorator which prevents \'select all\', ie. a select() with no query, limit, or skip.',

  methods: [
    function select_(x, sink, skip, limit, order, predicate) {
        if ( predicate &&
             ( ! this.True.isInstance(predicate) &&
               ! this.False.isInstance(predicate) ) ||
          ( foam.Number.isInstance(limit) && Number.isFinite(limit) && limit != 0 ) ||
          ( foam.Number.isInstance(skip) && Number.isFinite(skip) && skip != 0 ) ) {
        return this.delegate.select_(x, sink, skip, limit, order, predicate);
      } else {
        sink && sink.eof();
        return Promise.resolve(sink || this.ArraySink.create());
      }
    }
    // TODO: removeAll?
  ]
});
/**
 * @license
 * Copyright 2016 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

foam.CLASS({
  package: 'foam.dao',
  name: 'NullDAO',
  extends: 'foam.dao.AbstractDAO',

  documentation: 'A Null pattern (do-nothing) DAO implementation.',

  methods: [
    {
      name: 'put_',
      code: function put_(x, obj) {
        this.pub('on', 'put', obj);
        return Promise.resolve(obj);
      },
      swiftCode: `
_ = on["put"].pub([obj])
return obj
      `,
      javaCode: `
onPut(obj);
return obj;
      `,
    },

    {
      name: 'remove_',
      code: function remove_(x, obj) {
        this.pub('on', 'remove', obj);
        return Promise.resolve();
      },
      swiftCode: `
_ = on["remove"].pub([obj])
return obj
      `,
      javaCode: `
onRemove(obj);
return null;
      `,
    },

    {
      name: 'find_',
      code: function find_(x, id) {
        return Promise.resolve(null);
      },
      swiftCode: 'return nil',
      javaCode: 'return null;',
    },

    {
      name: 'select_',
      code: function select_(x, sink, skip, limit, order, predicate) {
        sink = sink || foam.dao.ArraySink.create();
        sink.eof();
        return Promise.resolve(sink);
      },
      swiftCode: `
sink.eof()
return sink
      `,
      javaCode: `
if ( sink == null ) {
  sink = new ArraySink();
}
sink.eof();
return sink;
      `,
    },

    {
      name: 'removeAll_',
      code: function removeAll_(x, skip, limit, order, predicate) {
        return Promise.resolve();
      },
      swiftCode: 'return',
      javaCode: '// NOOP',
    },
  ]
});
/**
 * @license
 * Copyright 2015 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

foam.CLASS({
  package: 'foam.dao',
  name: 'TimingDAO',
  extends: 'foam.dao.ProxyDAO',

  documentation: 'Times access to the delegate DAO; useful for debugging and profiling.',

  properties: [
    'name',
    {
      name: 'id',
      value: 0
    },
    ['activeOps', {put: 0, remove:0, find: 0, select: 0}],
    {
      /** High resolution time value function */
      class: 'Function',
      name: 'now',
      factory: function() {
        if ( global.window && global.window.performance ) {
          return function() {
            return window.performance.now();
          }
        } else if ( global.process && global.process.hrtime ) {
          return function() {
            var hr = global.process.hrtime();
            return ( hr[0] * 1000 ) + ( hr[1] / 1000000 );
          }
        } else {
          return function() { return Date.now(); }
        }
      }
    }
  ],

  methods: [
    function start(op) {
      var str = this.name + '-' + op;
      var key = this.activeOps[op]++ ? str + '-' + (this.id++) : str;
      console.time(key);
      return [key, str, this.now(), op];
    },

    function end(act) {
      this.activeOps[act[3]]--;
      this.id--;
      console.timeEnd(act[0]);
      console.log('Timing: ', act[1], ' ', (this.now()-act[2]).toFixed(3), ' ms');
    },

    function put_(x, obj) {
      var act = this.start('put');
      var self = this;
      return this.SUPER(x, obj).then(function(o) { self.end(act); return o; });
    },
    function remove_(x, obj) {
      var act = this.start('remove');
      var self = this;
      return this.SUPER(x, obj).then(function() { self.end(act); });
    },
    function find_(x, key) {
      var act = this.start('find');
      var self = this;
      return this.SUPER(x, key).then(function(o) { self.end(act); return o; });
    },
    function select() {
      var act = this.start('select');
      var self = this;
      return this.SUPER.apply(this, arguments).then(function(s) {
        self.end(act);
        return s;
      })
    }
  ]
});
/**
 * @license
 * Copyright 2015 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

foam.CLASS({
  package: 'foam.dao',
  name: 'LoggingDAO',
  extends: 'foam.dao.ProxyDAO',

  documentation: 'DAO Decorator which logs access to the delegate; useful for debugging.',

  requires: [ 'foam.dao.ArraySink' ],

  properties: [
    {
      name: 'name',
    },
    {
      name: 'logger',
      expression: function(name) {
        return console.log.bind(console, name);
      }
    },
    {
      class: 'Boolean',
      name: 'logReads',
      value: false
    },
  ],

  methods: [
    function put_(x, obj) {
      this.logger('put', obj);
      return this.SUPER(x, obj);
    },

    function remove_(x, obj) {
      this.logger('remove', obj);
      return this.SUPER(x, obj);
    },

    function select_(x, sink, skip, limit, order, predicate) {
      this.logger('select',
                  'skip', skip,
                  'limit', limit,
                  'order', order && order.toString(),
                  'predicate', predicate && predicate.toString());
      sink = sink || this.ArraySink.create();
      if ( this.logReads ) {
        var put = sink.put.bind(sink);
        var newSink = { __proto__: sink };
        newSink.put = function(o) {
          this.logger('read', foam.json.objectify(o));
          return put.apply(null, arguments);
        }.bind(this);
        return this.SUPER(x, newSink, skip, limit, order, predicate).then(function() {
          return sink;
        });
      }
      return this.SUPER(x, sink, skip, limit, order, predicate);
    },

    function removeAll_(x, sink, skip, limit, order, predicate) {
      this.logger('removeAll', skip, limit, order, predicate);
      return this.SUPER(x, sink, skip, limit, order, predicate);
    },

    function find_(x, id) {
      this.logger('find', id);
      return this.SUPER(x, id);
    }
  ]
});
/**
 * @license
 * Copyright 2018 The FOAM Authors. All Rights Reserved.
 * http://www.apache.org/licenses/LICENSE-2.0
 */

foam.CLASS({
  package: 'foam.dao',
  name: 'IDBInternalException',
  extends: 'foam.dao.InternalException',

  // TODO: Which errors are internal (system problems) vs. external
  // (i.e. invalid data for clone, but you can try again with different data)
  properties: [
    'id',
    'error',
    {
      name: 'message',
      expression: function(id, error) {
        return "IndexedDB Error for " + id +
          ( error ? ": " + error.toString() : "" );
      }
    }
  ]
});
/**
 * @license
 * Copyright 2014 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*
TODO:
-verify that multi part keys work properly
*/
foam.CLASS({
  package: 'foam.dao',
  name: 'IDBDAO',
  extends: 'foam.dao.AbstractDAO',

  requires: [
    'foam.dao.ArraySink',
    'foam.dao.IDBInternalException',
    'foam.mlang.predicate.True',
    'foam.mlang.predicate.Eq'
  ],

  imports: [
    'async'
  ],

  properties: [
    {
      name: 'of',
      required: true
    },
    {
      name:  'name',
      label: 'Store Name',
      factory: function() { return this.of.id; }
    },
    {
      name: 'indicies',
      factory: function() { return []; }
    },
    {
      name: 'version',
      value: 1
    },
    {
      /** The future that holds the open DB. Call this.withDB.then(function(db) { ... }); */
      name: 'withDB',
      factory: function() {
        var self = this;

        return new Promise(function(resolve, reject) {
          var indexedDB = global.indexedDB ||
            global.webkitIndexedDB         ||
            global.mozIndexedDB;

          var request = indexedDB.open("FOAM:" + self.name, self.version);

          request.onupgradeneeded = function(e) {
            var db = e.target.result;

            // FUTURE: Provide migration support here?  Or just have people create a new dao?
            if ( db.objectStoreNames.contains(self.name) ) {
              db.deleteObjectStore(self.name);
            }

            var store = e.target.result.createObjectStore(self.name);
            for ( var i = 0; i < self.indicies.length; i++ ) {
              store.createIndex(
                  self.indicies[i][0],
                  self.indicies[i][0],
                  { unique: self.indicies[i][1] });
            }
          }

          request.onsuccess = function(e) {
            resolve(e.target.result);
          }

          request.onerror = function (e) {
            reject(self.IDBInternalException.create({ id: 'open', error: e }));
          };
        });
      }
    },
  ],

  methods: [
    function deserialize(json) {
      return foam.json.parse(json, this.of, this.__subContext__);
    },

    function serialize(obj) {
      return foam.json.Storage.objectify(obj);
    },
    function serializeId(id) {
      return this.of.ID.toJSON(id);
    },

    function withStore(mode, fn) {
      return this.withStore_(mode, fn);
      if ( mode !== 'readwrite' ) return this.withStore_(mode, fn);

      var self = this;

      if ( ! this.q_ ) {
        var q = [fn];
        this.q_ = q;
        this.async(function() {
          self.withStore_(mode, function(store) {
            // console.log('q length: ', q.length);
            if ( self.q_ == q ) self.q_ = undefined;
            for ( var i = 0 ; i < q.length ; i++ ) q[i](store);
          });
        })();
      } else {
        this.q_.push(fn);
        // Diminishing returns after 10000 per batch
        if ( this.q_.length == 10000 ) this.q_ = undefined;
      }
    },

    function withStore_(mode, fn) {
      // NOTE: Large numbers of insertions can be made
      // faster by keeping the transaction between puts.
      // But due to Promises being async, the transaction
      // is usually closed by the next put.
      var self = this;
      self.withDB.then(function (db) {
        var tx = db.transaction([self.name], mode);
        var os = tx.objectStore(self.name);
        fn.call(self, os);
      });
    },

    function put_(x, value) {
      var self = this;
      return new Promise(function(resolve, reject) {
        self.withStore("readwrite", function(store) {
          var request = store.put(self.serialize(value),
                                  self.serializeId(value.id));
          request.transaction.addEventListener(
            'complete',
            function(e) {
              self.pub('on','put', value);
              resolve(value);
            });
          request.transaction.addEventListener(
            'error',
            function(e) {
              reject(self.IDBInternalException.create({ id: value.id, error: e }));
            });
        });
      });
    },

    function find_(x, obj) {
      var self = this;
      var key = this.serializeId(obj.id !== undefined ? obj.id : obj);

      return new Promise(function(resolve, reject) {
        self.withStore("readwrite", function(store) {
          var request = store.get(key);
          request.transaction.addEventListener(
            'complete',
            function() {
              if (!request.result) {
                resolve(null);
                return;
              }
              var result = self.deserialize(request.result);
              resolve(result);
            });
          request.onerror = function(e) {
            reject(self.IDBInternalException.create({ id: key, error: e }));
          };
        });
      });
    },

    function remove_(x, obj) {
      var self = this;
      var key = this.serializeId(obj.id !== undefined ? obj.id : obj);
      return new Promise(function(resolve, reject) {
        self.withStore("readwrite", function(store) {
          var getRequest = store.get(key);
          getRequest.onsuccess = function(e) {
            if (!getRequest.result) {
              // not found? as good as removed!
              resolve();
              return;
            }
            var data = self.deserialize(getRequest.result);
            var delRequest = store.delete(key);
            delRequest.transaction.addEventListener('complete', function(e) {
              self.pub('on','remove', data);
              resolve();
            });

            delRequest.onerror = function(e) {
              reject(self.IDBInternalException.create({ id: key, error: e }));
            };
          };
          getRequest.onerror = function(e) {
            reject(self.IDBInternalException.create({ id: key, error: e }));
          };
        });
      });
    },

    function removeAll_(x, skip, limit, order, predicate) {
      var query = predicate || this.True.create();

      var self = this;

      // If the caller doesn't care to see the objects as they get removed,
      // then just nuke them in one go.
      if ( ! predicate && ! self.hasListeners('on', 'remove') ) {
        return new Promise(function(resolve, reject) {
          self.withStore('readwrite', function(store) {
            var req = store.clear();
            req.onsuccess = function() {
              resolve();
            };
            req.onerror = function(e) {
              reject(self.IDBInternalException.create({ id: 'remove_all', error: e }));
            };
          });
        });
      } else {
        // send items to the sink and remove one by one
        return new Promise(function(resolve, reject) {
          self.withStore('readwrite', function(store) {
            var request = store.openCursor();
            request.onsuccess = function(e) {
              var cursor = e.target.result;
              if (cursor) {
                var value = self.deserialize(cursor.value);
                if (query.f(value)) {
                  var deleteReq = cursor.delete();
                  deleteReq.addEventListener(
                    'success',
                    function() {
                      self.pub('on','remove', value);
                    });
                  deleteReq.onerror = function(e) {
                  };
                }
                cursor.continue();
              }
            };
            request.transaction.addEventListener('complete', function() {
              resolve();
            });
            request.onerror = function(e) {
              reject(self.IDBInternalException.create({ id: 'remove_all', error: e }));
            };
          });
        });
      }
    },

    function select_(x, sink, skip, limit, order, predicate) {
      var resultSink = sink || this.ArraySink.create();
      sink = this.decorateSink_(resultSink, skip, limit, order, predicate);

      var sub = foam.core.FObject.create();
      var detached = false;
      sub.onDetach(function() { detached = true; });

      var self = this;

      return new Promise(function(resolve, reject) {
        self.withStore("readwrite", function(store) {
          var useIndex = predicate &&
            this.Eq.isInstance(predicate) &&
            store.indexNames.contains(predicate.arg1.name);

          var request = useIndex ?
            store.index(predicate.arg1.name).openCursor(IDBKeyRange.only(predicate.arg2.f())) :
            store.openCursor() ;

          request.onsuccess = function(e) {
            var cursor = e.target.result;
            if ( e.target.error ) {
              reject(e.target.error);
              return;
            }

            if ( ! cursor || detached ) {
              sink.eof && sink.eof();
              resolve(resultSink);
              return;
            }

            var value = self.deserialize(cursor.value);
            sink.put(value, sub);
            cursor.continue();
          };
          request.onerror = function(e) {
            reject(self.IDBInternalException.create({ id: 'select', error: e }));
          };
        });
      });
    },

    function addIndex(prop) {
      this.indicies.push([prop.name, false]);
      return this;
    }
  ]
});
/**
 * @license
 * Copyright 2017 The FOAM Authors. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

foam.ENUM({
  package: 'foam.dao',
  name: 'IDBMutationType',

  values: [
    {
      name: 'PUT',
      label: 'put'
    },
    {
      name: 'REMOVE',
      label: 'remove'
    }
  ]
});

foam.CLASS({
  package: 'foam.dao',
  name: 'IDBMutation',

  properties: [
    {
      class: 'Enum',
      of: 'foam.dao.IDBMutationType',
      name: 'type'
    },
    {
      documentation: 'Data to be put or removed.',
      name: 'data'
    },
    {
      class: 'Function',
      documentation: 'Resolve function for DAO operation promise.',
      name: 'resolve'
    },
    {
      class: 'Function',
      documentation: 'Reject function for DAO operation promise.',
      name: 'reject'
    }
  ]
});

foam.CLASS({
  package: 'foam.dao',
  name: 'BatchMutationIDBDAO',
  extends: 'foam.dao.IDBDAO',

  documentation: `Indexed DB DAO that batches put() and remove(). This improves
      performance by decreasing the number of transactions created for writes.`,

  requires: [
    'foam.dao.IDBMutation',
    'foam.dao.IDBMutationType'
  ],

  properties: [
    {
      class: 'Int',
      documentation: `Maximum number of operations to include in a batch.`,
      name: 'batchSize',
      value: 1000
    },
    {
      class: 'Int',
      documentation: `Maximum number of in-flight batches
          (i.e., transactions). Default to 1 in case clients expect strict
          ordering of operations.`,
      name: 'numBatches',
      value: 1
    },
    {
      class: 'FObjectArray',
      of: 'foam.dao.IDBMutation',
      name: 'mutations_'
    },
    {
      class: 'Int',
      documentation: 'Number of in-flight transactions.',
      name: 'numActiveTransactions_'
    }
  ],

  methods: [
    function put_(x, o) {
      var self = this;
      return new Promise(function(resolve, reject) {
        self.mutations_.push(self.IDBMutation.create({
          type: self.IDBMutationType.PUT,
          data: o,
          resolve: function(result) {
            self.pub('on', 'put', result);
            resolve(result);
          },
          reject: reject
        }));
        self.onBatchedOperation();
      });
    },
    function remove_(x, o) {
      var self = this;
      return new Promise(function(resolve, reject) {
        self.mutations_.push(self.IDBMutation.create({
          type: self.IDBMutationType.REMOVE,
          data: o,
          resolve: function(didRemove) {
            if ( didRemove ) self.pub('on', 'remove', o);
            resolve(o);
          },
          reject: reject
        }));
        self.onBatchedOperation();
      });
    },
    function beginBatchTransaction() {
      if ( this.mutations_.length === 0 ) return Promise.resolve();

      var mutations = this.mutations_.slice(0, this.batchSize);
      this.mutations_ = this.mutations_.slice(this.batchSize);

      this.numActiveTransactions_++;

      var deletes = [];
      for ( var i = 0; i < mutations.length; i++ ) {
        if ( mutations[i].type === this.IDBMutationType.REMOVE )
        deletes.push(mutations[i]);
      }
      if ( deletes.length === 0 )
        return this.onGatheredDeletes(mutations, []).
            then(this.onTransactionComplete).
            catch(this.onTransactionError);

      var promises = new Array(deletes.length);
      for ( var i = 0; i < deletes.length; i++ ) {
        promises[i] = this.find(deletes[i]);
      }

      return Promise.all(promises).
          then(this.onGatheredDeletes.bind(this, mutations)).
          then(this.onTransactionComplete).
          catch(this.onTransactionError);
    }
  ],

  listeners: [
    {
      name: 'onBatchedOperation',
      isMerged: true,
      mergeDelay: 150,
      code: function() {
        foam.assert(
            this.mutations_.length > 0,
            'BatchedMutationIDBDAO: Attempt to batch no operations');

        var promises = [];
        for ( var i = this.numActiveTransactions_; i < this.numBatches; i++ ) {
          this.beginBatchTransaction();
        }

        return Promise.all(promises);
      }
    },

    function onGatheredDeletes(mutations, deletesFound) {
      var self = this;
      return new Promise(function(resolve, reject) {
        self.withStore('readwrite', function(store) {
          var deletesI = 0;
          for ( var i = 0; i < mutations.length; i++ ) {
            var mutation = mutations[i];
            var obj = mutation.data;
            var request;
            if ( mutation.type === self.IDBMutationType.PUT ) {
              request = store.put(self.serialize(obj),
                                  self.serializeId(obj.id));
            } else {
              if ( deletesFound[deletesI] === null ) {
                deletesI++;
                continue;
              }
              request = store.delete(
                  this.serializeId(obj.id !== undefined ? obj.id : obj));
              deletesI++;
            }
          }

          request.transaction.addEventListener(
              'complete',
              function() {
                var deletesI = 0;
                for ( var i = 0; i < mutations.length; i++ ) {
                  var mutation = mutations[i];
                  if ( mutation.type === self.IDBMutationType.PUT ) {
                    self.pub('on', 'put', mutation.data);
                  } else {
                    if ( deletesFound[deletesI] !== null )
                      self.pub('on', 'remove', mutation.data);
                    deletesI++;
                  }
                  mutation.resolve(mutation.data);
                }
                resolve();
              });
            request.transaction.addEventListener(
                'error',
                function(error) {
                  for ( var i = 0; i < mutations.length; i++ ) {
                    mutations[i].reject(error);
                  }
                  reject(error);
                });
        });
      });
    },
    function onTransactionComplete() {
      this.numActiveTransactions_--;
    },
    function onTransactionError() {
      this.numActiveTransactions_--;
    }
  ]
});
/**
 * @license
 * Copyright 2017 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

foam.CLASS({
  package: 'foam.dao',
  name: 'RestDAO',
  extends: 'foam.dao.AbstractDAO',

  documentation: function() {/*
    A client-side DAO for interacting with a REST endpoint.

    Sinks are managed on the client (i.e., sinks passed to
    select() will not serialize the sink and send it to the
    endpoint for server-side logic implementation).
  */},

  requires: [
    'foam.core.Serializable',
    'foam.dao.ArraySink',
    'foam.json.Outputter',
    'foam.net.HTTPRequest'
  ],

  properties: [
    {
      class: 'String',
      name: 'baseURL',
      documentation: 'URL for most rest calls. Some calls add "/<some-info>".',
      final: true,
      required: true
    },
    {
      class: 'FObjectProperty',
      of: 'foam.json.Outputter',
      name: 'outputter',
      factory: function() {
        // NOTE: Configuration must be consistent with parser in
        // corresponding foam.net.node.RestDAOHandler.
        return this.Outputter.create({
          pretty: false,
          formatDatesAsNumbers: true,
          outputDefaultValues: false,
          strict: true,
          propertyPredicate: function(o, p) { return ! p.networkTransient; }
        });
      }
    }
  ],

  methods: [
    function put_(x, o) {
      /**
       * PUT baseURL
       * <network-foam-jsonified FOAM object>
       */
      return this.createRequest_({
        method: 'PUT',
        url: this.baseURL,
        payload: this.outputter.stringify(o)
      }).send().then(this.onResponse.bind(this, 'put'))
          .then(this.onPutResponse);
    },

    function remove_(x, o) {
      /**
       * DELETE baseURL/<network-foam-jsonified FOAM object id>
       */
      return this.createRequest_({
        method: 'DELETE',
        url: this.baseURL + '/' +
            encodeURIComponent(this.outputter.stringify(o.id))
      }).send().then(this.onResponse.bind(this, 'remove'))
          .then(this.onRemoveResponse);
    },

    function find_(x, key) {
      /**
       * GET baseURL/<network-foam-jsonified FOAM object id>
       */
      var id = this.of.isInstance(key) ? key.id : key;
      return this.createRequest_({
        method: 'GET',
        url: this.baseURL + '/' +
            encodeURIComponent(this.outputter.stringify(id))
      }).send().then(this.onResponse.bind(this, 'find'))
          .then(this.onFindResponse);
    },

    function select_(x, sink, skip, limit, order, predicate) {
      /**
       * GET baseURL
       * { skip, limit, order, predicate }
       *
       * Each key's value is network-foam-jsonified.
       */
      var payload = {};

      var networkSink = this.Serializable.isInstance(sink) && sink;
      if ( networkSink )
        payload.sink = networkSink;

      if ( typeof skip !== 'undefined' )
        payload.skip = skip;
      if ( typeof limit !== 'undefined' )
        payload.limit = limit;
      if ( typeof order !== 'undefined' )
        payload.order = order;
      if ( typeof predicate !== 'undefined' )
        payload.predicate = predicate;

      return this.createRequest_({
        method: 'POST',
        url: this.baseURL + ':select',
        payload: this.outputter.stringify(payload)
      }).send().then(this.onResponse.bind(this, 'select'))
          .then(this.onSelectResponse.bind(
              this, sink || this.ArraySink.create()));
    },

    function removeAll_(x, skip, limit, order, predicate) {
      /**
       * POST baseURL/removeAll
       * { skip, limit, order, predicate }
       *
       * Each key's value is network-foam-jsonified.
       */
      var payload = {};
      if ( typeof skip  !== 'undefined' ) payload.skip = skip;
      if ( typeof limit !== 'undefined' ) payload.limit = limit;
      if ( typeof order !== 'undefined' ) payload.order = order;
      if ( typeof predicate !== 'undefined' ) payload.predicate = predicate;

      return this.createRequest_({
        method: 'POST',
        url: this.baseURL + ':removeAll',
        payload: this.outputter.stringify(payload)
      }).send().then(this.onResponse.bind(this, 'removeAll'))
          .then(this.onRemoveAllResponse);
    },

    function createRequest_(o) {
      // Demand that required properties are set before using DAO.
      this.validate();
      // Each request should default to a json responseType.
      return this.HTTPRequest.create(Object.assign({responseType: 'json'}, o));
    }
  ],

  listeners: [
    function onResponse(name, response) {
      if ( response.status !== 200 ) {
        throw new Error(
          'Unexpected ' + name + ' response code from REST DAO endpoint: ' +
            response.status);
      }
      return response.payload;
    },

    function onPutResponse(payload) {
      var o = foam.json.parse(payload);
      this.pub('on', 'put', o);
      return o;
    },

    function onRemoveResponse(payload) {
      var o = foam.json.parse(payload);
      if ( o !== null ) this.pub('on', 'remove', o);
      return o;
    },

    function onFindResponse(payload) {
      return foam.json.parse(payload);
    },

    function onSelectResponse(localSink, payload) {
      var wasSerializable = this.Serializable.isInstance(localSink);
      var remoteSink = foam.json.parse(payload);

      // If not proxying a local unserializable sink, just return the remote.
      if ( wasSerializable ) return remoteSink;

      var array = remoteSink.array;
      if ( ! array )
        throw new Error('Expected ArraySink from REST endpoint when proxying local sink');

      if ( localSink.put ) {
        var sub = foam.core.FObject.create();
        var detached = false;
        sub.onDetach(function() { detached = true; });
        for ( var i = 0; i < array.length; i++ ) {
          localSink.put(array[i], sub);
          if ( detached ) break;
        }
      }
      if ( localSink.eof ) localSink.eof();

      return localSink;
    },

    function onRemoveAllResponse(payload) {
      return undefined;
    }
  ]
});
/**
 * @license
 * Copyright 2017 The FOAM Authors. All Rights Reserved.
 * http://www.apache.org/licenses/LICENSE-2.0
 */

foam.CLASS({
  package: 'foam.dao',
  name: 'EnabledAwareDAO',
  extends: 'foam.dao.FilteredDAO',

  documentation: 'Filter out disabled EnabledAware objects.',

  implements: [
    'foam.mlang.Expressions'
  ],

  requires: [
    'foam.nanos.auth.EnabledAware'
  ],

  properties: [
    {
      class: 'FObjectProperty',
      of: 'foam.mlang.predicate.Predicate',
      name: 'predicate',
      factory: function() {
        return this.EQ(this.EnabledAware.ENABLED, true);
      },
      javaFactory: 'return foam.mlang.MLang.EQ(EnabledAware.ENABLED, true);'
    }
  ]
});
/**
 * @license
 * Copyright 2017 The FOAM Authors. All Rights Reserved.
 * http://www.apache.org/licenses/LICENSE-2.0
 */

foam.CLASS({
  package: 'foam.dao',
  name: 'LastModifiedAwareDAO',
  extends: 'foam.dao.ProxyDAO',

  documentation: 'Sets lastModified timestamp on put() of LastModifiedAware objects.',

  javaImports: [
    'foam.nanos.auth.LastModifiedAware',
    'java.util.Calendar',
    'java.util.TimeZone'
  ],

  methods: [
    {
      name: 'put_',
      code: function(value) {
        value.lastModified = new Date();
        return SUPER(value);
      },
      javaCode:
`((LastModifiedAware) obj).setLastModified(Calendar.getInstance(TimeZone.getTimeZone("UTC")).getTime());
return super.put_(x, obj);`
    }
  ]
});
/**
 * @license
 * Copyright 2016 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

foam.CLASS({
  package: 'foam.dao',
  name: 'ValidationDAODecorator',
  extends: 'foam.dao.AbstractDAODecorator',
  documentation: 'DAO decorator that rejects puts of objects that are invalid.',
  methods: [
    function write(X, dao, obj, existing) {
      if ( obj.errors_ ) {
        return Promise.reject(foam.dao.ValidationException.create({
          errors: obj.errors_,
        }));
      }
      return Promise.resolve(obj);
    },
  ]
});

foam.CLASS({
  package: 'foam.dao',
  name: 'ValidationException',
  extends: 'foam.dao.ExternalException',
  properties: [
    'errors',
    {
      name: 'message',
      expression: function(errors) {
        return errors.join(', ');
      },
    },
  ],
});
/**
 * @license
 * Copyright 2016 The FOAM Authors. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

foam.CLASS({
  package: 'foam.dao',
  name: 'NoDisjunctionDAO',
  extends: 'foam.dao.ProxyDAO',
  implements: [ 'foam.mlang.Expressions' ],

  documentation: 'DAO decorator for DAOs that do not support disjunction.',

  requires: [
    'foam.dao.DAOSink',
    'foam.dao.MDAO',
    'foam.mlang.Constant',
    'foam.mlang.predicate.Eq',
    'foam.mlang.predicate.Or'
  ],

  methods: [
    function select_(x, sink, skip, limit, order, predicate) {
      if ( ! predicate )
        return this.SUPER(x, sink, skip, limit, order, predicate);

      // Get predicate in reduced form of OR( ... <no ORs or INs> ... ).
      var newPredicate = this.inToOr_(predicate)
          .toDisjunctiveNormalForm()
          .partialEval();

      // Do not bother disjunction-only DAOs with returning empty set or
      // implementing select(..., TRUE) = select(..., <no predicate>).
      if ( this.FALSE.equals(newPredicate) ) {
        sink.eof && sink.eof();
        return Promise.resolve(sink);
      }
      if ( this.TRUE.equals(newPredicate) ) newPredicate = undefined;

      if ( ! this.Or.isInstance(newPredicate) )
        return this.SUPER(x, sink, skip, limit, order, newPredicate);

      // Perform query over each arg of top-level OR.
      var predicates = newPredicate.args;
      var dao = this.MDAO.create({ of: this.of });
      // TODO(markdittmer): Create indices based on predicate.
      var sharedSink = this.DAOSink.create({ dao: dao });
      var promises = [];
      for ( var i = 0; i < predicates.length; i++ ) {
        promises.push(
            this.SUPER(x, sharedSink, skip, limit, order, predicates[i]));
      }

      return Promise.all(promises).then(function() {
        // Perform "actual" query over DAO of merged results.
        return dao.select_(x, sink, skip, limit, order, predicate);
      });
    },
    {
      name: 'inToOr_',
      documentation: 'Convert IN() mLangs in input to OR(EQ(...), ...).',
      code: foam.mmethod({
        'foam.mlang.predicate.In': function(predicate) {
          foam.assert(this.Constant.isInstance(predicate.arg2),
                      'NoDisjunctionDAO expects constant IN.arg2');

          var orArgs = [];
          var arg2 = predicate.arg2.value;

          for ( var i = 0; i < arg2.length; i++ ) {
            orArgs.push(this.Eq.create({
              arg1: predicate.arg1.clone(),
              arg2: arg2[i]
            }, predicate));
          }
          return this.Or.create({ args: orArgs }, predicate);
        },
        'foam.mlang.predicate.Binary': function(predicate) {
          return predicate.cls_.create({
            arg1: this.inToOr_(predicate.arg1),
            arg2: this.inToOr_(predicate.arg2)
          }, predicate);
        },
        'foam.mlang.predicate.Nary': function(predicate) {
          var oldArgs = predicate.args;
          var newArgs = new Array(oldArgs.length);
          for ( var i = 0; i < oldArgs.length; i++ ) {
            newArgs[i] = this.inToOr_(oldArgs[i]);
          }
          return predicate.cls_.create({ args: newArgs });
        },
        'foam.mlang.predicate.AbstractPredicate': function(predicate) {
          return predicate.clone();
        },
        'foam.mlang.AbstractExpr': function(expr) {
          return expr.clone();
        },
        'foam.core.Property': function(property) {
          return property;
        }
      }, function(predicate) {
        throw new Error('Unrecognized predicate: ' +
                        ( predicate && predicate.cls_ && predicate.cls_.id ));
      })
    }
  ]
});
/**
 * @license
 * Copyright 2017 The FOAM Authors. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

foam.CLASS({
  package: 'foam.dao',
  name: 'NoNeqDAO',
  extends: 'foam.dao.ProxyDAO',

  documentation: 'DAO decorator for DAOs that do not support NEQ().',

  requires: [
    'foam.mlang.predicate.Gt',
    'foam.mlang.predicate.Lt',
    'foam.mlang.predicate.Neq',
    'foam.mlang.predicate.Or'
  ],

  methods: [
    function select_(x, sink, skip, limit, order, predicate) {
      if ( ! predicate )
        return this.SUPER(x, sink, skip, limit, order, predicate);

      return this.SUPER(x, sink, skip, limit, order,
                        this.transformNeq_(predicate));
    },
    {
      name: 'transformNeq_',
      documentation: 'Convert NEQ() mLangs in input to OR(LT(), GT()).',
      code: foam.mmethod({
        'foam.mlang.predicate.Neq': function(predicate) {
          return this.Or.create({
            args: [
              this.Lt.create({ arg1: predicate.arg1, arg2: predicate.arg2 }),
              this.Gt.create({ arg1: predicate.arg1, arg2: predicate.arg2 }),
            ]
          }, predicate);
        },
        'foam.mlang.predicate.Binary': function(predicate) {
          return predicate.cls_.create({
            arg1: this.transformNeq_(predicate.arg1),
            arg2: this.transformNeq_(predicate.arg2)
          }, predicate);
        },
        'foam.mlang.predicate.Nary': function(predicate) {
          var oldArgs = predicate.args;
          var newArgs = new Array(oldArgs.length);
          for (var i = 0; i < oldArgs.length; i++) {
            newArgs[i] = this.transformNeq_(oldArgs[i]);
          }
          return predicate.cls_.create({ args: newArgs });
        },
        'foam.mlang.predicate.AbstractPredicate': function(predicate) {
          return predicate.clone();
        },
        'foam.mlang.AbstractExpr': function(expr) {
          return expr.clone();
        },
        'foam.core.Property': function(property) {
          return property;
        }
      }, function(predicate) {
        throw new Error('Unrecognized predicate: ' +
                        (predicate && predicate.cls_ && predicate.cls_.id));
      })
    }
  ]
});
/**
 * @license
 * Copyright 2016 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

foam.CLASS({
  package: 'foam.parse',
  name: 'QueryParser',

  documentation:
      'Create a query strings to MLangs parser for a particular class.',

  axioms: [
    // Reuse parsers if created for same 'of' class.
    foam.pattern.Multiton.create({ property: 'of' })
  ],

  // TODO(braden): Support KEYWORD predicates and queries on them.

  requires: [
    'foam.mlang.predicate.And',
    'foam.mlang.predicate.ContainsIC',
    'foam.mlang.predicate.Eq',
    'foam.mlang.predicate.Gt',
    'foam.mlang.predicate.Gte',
    'foam.mlang.predicate.Has',
    'foam.mlang.predicate.In',
    'foam.mlang.predicate.InIC',
    'foam.mlang.predicate.Lt',
    'foam.mlang.predicate.Lte',
    'foam.mlang.predicate.Not',
    'foam.mlang.predicate.Or',
    'foam.mlang.predicate.True',
    'foam.parse.Alternate',
    'foam.parse.ImperativeGrammar',
    'foam.parse.LiteralIC',
    'foam.parse.Parsers',
    'foam.parse.PropertyRefinement',
    'foam.parse.StringPStream'
  ],

  properties: [
    {
      class: 'Class',
      name: 'of'
    },
    /** An optional input. If this is defined, 'me' is a keyword in the search
     * and can be used for queries like <tt>owner:me</tt>. Note that since
     * there is exactly one parser instance per 'of' value, the value of 'me' is
     * also shared.
     */
    {
      class: 'String',
      name: 'me'
    },
    {
      // The core query parser. Needs a fieldname symbol added to function
      // properly.
      name: 'baseGrammar_',
      value: function(alt, literal, literalIC, not, notChars, optional, range,
          repeat, seq, seq1, str, sym) {
        return {
          START: sym('query'),
          query: sym('or'),

          or: repeat(sym('and'), alt(literalIC(' OR '), literal(' | ')), 1),

          and: repeat(
              sym('expr'),
              alt(literalIC(' AND '),
                  not(alt(literalIC(' OR'), literal(' |')), literal(' '))),
              1),

          expr: alt(
              sym('paren'),
              sym('negate'),
              sym('has'),
              sym('is'),
              sym('equals'),
              sym('before'),
              sym('after'),
              sym('id')
          ),

          paren: seq1(1, '(', sym('query'), ')'),

          negate: alt(
              seq(literal('-'), sym('expr')),
              seq(literalIC('NOT '), sym('expr'))
          ),

          id: sym('number'),

          has: seq(literalIC('has:'), sym('fieldname')),

          is: seq(literalIC('is:'), sym('fieldname')),

          equals: seq(sym('fieldname'), alt(':', '='), sym('valueList')),

          // TODO(kgr): Merge with 'equals'.
          before: seq(sym('fieldname'), alt('<=', '<', literalIC('-before:')),
              sym('value')),
          after: seq(sym('fieldname'), alt('>=', '>', literalIC('-after:')),
              sym('value')),

          value: alt(
              sym('me'),
              sym('date'),
              sym('string'),
              sym('number')
          ),

          compoundValue: alt(
              sym('negateValue'),
              sym('orValue'),
              sym('andValue')
          ),

          negateValue: seq(
              '(',
              alt('-', literalIC('not ')),
              sym('value'),
              ')'
          ),

          orValue: seq(
              '(',
              repeat(sym('value'), alt('|', literalIC(' or '), ' | '), 1),
              ')'
          ),

          andValue: seq(
              '(',
              repeat(sym('value'), alt(literalIC(' and '), ' '), 1),
              ')'
          ),

          valueList: alt(sym('compoundValue'), repeat(sym('value'), ',', 1)),

          me: seq(literalIC('me'), not(sym('char'))),

          date: alt(
              sym('range date'),
              sym('literal date'),
              sym('relative date')
          ),

          'range date': seq(
              alt(sym('literal date'), sym('number')),
              '..',
              alt(sym('literal date'), sym('number'))),

          'literal date': alt(
              // YYYY-MM-DDTHH:MM
              seq(sym('number'), '-', sym('number'), '-', sym('number'), 'T',
                  sym('number'), ':', sym('number')),
              // YYYY-MM-DDTHH
              seq(sym('number'), '-', sym('number'), '-', sym('number'), 'T',
                  sym('number')),
              // YYYY-MM-DD
              seq(sym('number'), '-', sym('number'), '-', sym('number')),
              // YYYY-MM
              seq(sym('number'), '-', sym('number')),
              // YY/MM/DD
              seq(sym('number'), '/', sym('number'), '/', sym('number'))
          ),

          'relative date': seq(literalIC('today'),
                optional(seq('-', sym('number')))),

          string: alt(sym('word'), sym('quoted string')),

          'quoted string': seq1(1, '"',
                repeat(alt(literal('\\"', '"'), notChars('"'))),
                '"'),

          word: repeat(sym('char'), null, 1),

          char: alt(range('a', 'z'), range('A', 'Z'), range('0', '9'), '-', '^',
              '_', '@', '%', '.'),
          number: repeat(range('0', '9'), null, 1)
        };
      }
    },
    {
      name: 'grammar_',
      factory: function() {
        var cls = this.of;
        var fields = [];
        var properties = cls.getAxiomsByClass(foam.core.Property);
        for ( var i = 0; i < properties.length; i++ ) {
          var prop = properties[i];
          fields.push(this.LiteralIC.create({
            s: prop.name,
            value: prop
          }));
          if ( prop.shortName ) {
            fields.push(this.LiteralIC.create({
              s: prop.shortName,
              value: prop
            }));
          }
          if ( prop.aliases ) {
            for ( var j = 0; j < prop.aliases.length; j++ ) {
              fields.push(this.LiteralIC.create({
                s: prop.aliases[j],
                value: prop
              }));
            }
          }
        }
        fields.sort(function(a, b) {
          var d = b.lower.length - a.lower.length;
          if ( d !== 0 ) return d;
          if ( a.lower === b.lower ) return 0;
          return a.lower < b.lower ? 1 : -1;
        });

        var base = foam.Function.withArgs(this.baseGrammar_,
            this.Parsers.create(), this);
        var grammar = {
          __proto__: base,
          fieldname: this.Alternate.create({ args: fields })
        };

        // This is a closure that's used by some of the actions that follow.
        // If a Date-valued field is set to a single number, it expands into a
        // range spanning that whole year.
        var maybeConvertYearToDateRange = function(prop, num) {
          var isDateField = foam.core.Date.isInstance(prop) ||
              foam.core.Date.isInstance(prop);
          var isDateRange = Array.isArray(num) && num[0] instanceof Date;

          if ( isDateField && ! isDateRange ) {
            // Convert the number, a single year, into a date.
            var start = new Date(0); // Jan 1 1970, midnight UTC.
            var end   = new Date(0);
            start.setUTCFullYear(+num);
            end.setUTCFullYear(+num + 1);
            return [ start, end ];
          }
          return num;
        };

        var compactToString = function(v) {
          return v.join('');
        };

        var self = this;

        // TODO: Fix me to just build the object directly.
        var actions = {
          id: function(v) {
            return self.Eq.create({
              arg1: cls.ID,
              arg2: v
            });
          },

          or: function(v) {
            return self.Or.create({ args: v });
          },

          and: function(v) {
            return self.And.create({ args: v });
          },

          negate: function(v) {
            return self.Not.create({ arg1: v[1] });
          },

          number: function(v) {
            return parseInt(compactToString(v));
          },

          me: function() {
            return self.me || '';
          },

          has: function(v) {
            return self.Has.create({ arg1: v[1] });
          },

          is: function(v) {
            return self.Eq.create({
              arg1: v[1],
              arg2: self.True.create()
            });
          },

          before: function(v) {
            // If the property (v[0]) is a Date(Time)Property, and the value
            // (v[2]) is a single number, expand it into a Date range for that
            // whole year.
            v[2] = maybeConvertYearToDateRange(v[0], v[2]);

            // If the value (v[2]) is a Date range, use the appropriate end point.
            if ( Array.isArray(v[2]) && v[2][0] instanceof Date ) {
              v[2] = v[1] === '<=' ? v[2][1] : v[2][0];
            }
            return (v[1] === '<=' ? self.Lte : self.Lt).create({
              arg1: v[0],
              arg2: v[2]
            });
          },

          after: function(v) {
            // If the property (v[0]) is a Date(Time)Property, and the value
            // (v[2]) is a single number, expand it into a Date range for that
            // whole year.
            v[2] = maybeConvertYearToDateRange(v[0], v[2]);

            // If the value (v[2]) is a Date range, use the appropriate end point.
            if ( Array.isArray(v[2]) && v[2][0] instanceof Date ) {
              v[2] = v[1] === '>=' ? v[2][0] : v[2][1];
            }
            return (v[1] === '>=' ? self.Gte : self.Gt).create({
              arg1: v[0],
              arg2: v[2]
            });
          },

          equals: function(v) {
            // v[2], the values, is an array, which might have an 'and', 'or' or
            // 'negated' property on it. The default is 'or'. The partial
            // evaluator for expressions can simplify the resulting Mlang further.
            var prop = v[0];
            var values = v[2];
            // Int is actually the parent of Float and Long, so this captures all
            // numeric properties.
            var isNum = foam.core.Int.isInstance(prop);
            var isFloat = foam.core.Float.isInstance(prop);

            var isDateField = foam.core.Date.isInstance(prop) ||
                foam.core.DateTime.isInstance(prop);
            var isDateRange = Array.isArray(values[0]) &&
                values[0][0] instanceof Date;

            if ( isDateField || isDateRange ) {
              if ( ! isDateRange ) {
                // Convert the single number, representing a year, into a
                // date.
                var start = new Date(0); // Jan 1 1970 at midnight UTC
                var end = new Date(0);
                start.setUTCFullYear(values[0]);
                end.setUTCFullYear(+values[0] + 1);
                values = [ [ start, end ] ];
              }
              return self.And.create({
                args: [
                  self.Gte.create({ arg1: prop, arg2: values[0][0] }),
                  self.Lt.create({ arg1: prop, arg2: values[0][1] })
                ]
              });
            }

            var expr;

            if ( isNum ) {
              for ( var i = 0; i < values.length; i++ ) {
                values[i] = isFloat ? parseFloat(values[i]) :
                    parseInt(values[i]);
              }

              expr = self.In.create({ arg1: prop, arg2: values });
            } else if ( foam.core.Enum.isInstance(prop) ) {
              expr = self.In.create({ arg1: prop, arg2: values });
            } else {
              expr = (v[1] === '=') ?
                  self.InIC.create({ arg1: prop, arg2: values }) :
                  self.Or.create({
                    args: values.map(function(v) {
                      return self.ContainsIC.create({ arg1: prop, arg2: v });
                    })
                  });
            }

            if ( values.negated ) {
              return self.Not.create({ arg1: expr });
            } else if ( values.and ) {
              return self.And.create({
                args: values.map(function(x) {
                  expr.class_.create({ arg1: expr.arg1, arg2: [ x ] });
                })
              });
            } else {
              return expr;
            }
          },

          negateValue: function(v) {
            v.negated = true;
            return v;
          },

          orValue: function(v) {
            v = v[1];
            v.or = true;
            return v;
          },

          andValue: function(v) {
            v = v[1];
            v.and = true;
            return v;
          },

          // All dates are actually treated as ranges. These are arrays of Date
          // objects: [start, end]. The start is inclusive and the end exclusive.
          // Using these objects, both ranges (date:2014, date:2014-05..2014-06)
          // and open-ended ranges (date > 2014-01-01) can be computed higher up.
          // Date formats:
          // YYYY-MM-DDTHH:MM, YYYY-MM-DDTHH, YYYY-MM-DD, YYYY-MM, YY/MM/DD, YYYY
          'literal date': function(v) {
            var start;
            var end;

            // Previously we used just new Date() (ie. right now). That breaks
            // when the current date is eg. 31 but the parsed date wants to be a
            // shorter month (eg. April with 30 days). We would set the month to
            // April, but "April 31" gets corrected to "May 1" and then our
            // parsed dates are wrong.
            //
            // We fix that by using a fixed starting date that won't get
            // adjusted like that.
            start = new Date(2000, 0, 1);
            end   = new Date(2000, 0, 1);
            var ops = [ 'FullYear', 'Month', 'Date', 'Hours', 'Minutes',
                'Seconds' ];
            var defaults = [ 0, 1, 1, 0, 0, 0 ];
            for ( var i = 0; i < ops.length; i++ ) {
              var x = i * 2 > v.length ? defaults[i] : v[i * 2];
              // Adjust for months being 0-based.
              var val = x - (i === 1 ? 1 : 0);
              start['setUTC' + ops[i]](val);
              end['setUTC' + ops[i]](val);
            }

            start.setUTCMilliseconds(0);
            end.setUTCMilliseconds(0);

            // start and end are currently clones of each other. We bump the last
            // portion of the date and set it in end.
            var last = Math.floor(v.length / 2);
            var op = 'UTC' + ops[last];
            end['set' + op](end['get' + op]() + 1);

            return [ start, end ];
          },

          'relative date': function(v) {
            // We turn this into a Date range for the current day, or a day a few
            // weeks before.
            var d = new Date();
            var year  = d.getFullYear();
            var month = d.getMonth();
            var date  = d.getDate();
            if ( v[1] ) date -= v[1][1];

            return actions['literal date']([ year, '-', month + 1, '-', date ]);
          },

          'range date': function(v) {
            // This gives two dates, but each has already been converted to a
            // range. So we take the start of the first and the end of the second.
            var start = Array.isArray(v[0]) ? v[0][0] :
                typeof v[0] === 'number' ? new Date(v[0], 0, 1) : v[0];
            var end = Array.isArray(v[2]) ? v[2][1] :
                typeof v[2] === 'number' ? new Date(+v[2] + 1, 0, 1) : v[2];
            return [ start, end ];
          },

          'quoted string': compactToString,
          word: compactToString
        };

        var g = this.ImperativeGrammar.create({
          symbols: grammar
        });

        g.addActions(actions);
        return g;
      }
    }
  ],

  methods: [
    function parseString(str, opt_name) {
      var query = this.grammar_.parseString(str, opt_name);
      return query && query.partialEval ? query.partialEval() : query;
    }
  ]
});


foam.CLASS({
  package: 'foam.parse',
  name: 'PropertyRefinement',
  refines: 'foam.core.Property',

  properties: [
    {
      class: 'StringArray',
      name: 'aliases'
    }
  ]
});
/**
 * @license
 * Copyright 2014 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

foam.CLASS({
  package: 'foam.physics',
  name: 'Physical',

  documentation: 'A Physical object has velocity and mass and may optionally be subject to friction and gravity.',

  constants: {
    INFINITE_MASS: 10000
  },

  properties: [
    { class: 'Float', name: 'friction' },
    { class: 'Float', name: 'gravity', value: 1 },
    { class: 'Float', name: 'vx', value: 0 },
    { class: 'Float', name: 'vy', value: 0 },
    {
      class: 'Float',
      name: 'velocity',
      getter: function() { return this.distance(this.vx, this.vy); },
      setter: function(v) { this.setVelocityAndAngle(v, this.angleOfVelocity); }
    },
    {
      class: 'Float',
      name: 'angleOfVelocity',
      getter: function() { return Math.atan2(this.vy, this.vx); },
      setter: function(a) { this.setVelocityAndAngle(this.velocity, a); }
    },
    { class: 'Float', name: 'mass', value: 1 }
  ],

  methods: [
    function distance(dx, dy) {
      return Math.sqrt(dx*dx + dy*dy);
    },

    function applyMomentum(m, a) {
      this.vx += (m * Math.cos(a) / this.mass);
      this.vy += (m * Math.sin(a) / this.mass);
    },

    function momentumAtAngle(a) {
      if ( this.mass === this.INFINITE_MASS ) return 0;
      var v = this.velocityAtAngle(a);
      return v * this.mass;
    },

    function velocityAtAngle(a) {
      if ( this.mass === this.INFINITE_MASS ) return 0;
      return Math.cos(a-this.angleOfVelocity) * this.velocity;
    },

    function setVelocityAndAngle(v, a) {
      this.vx = v * Math.cos(a);
      this.vy = v * Math.sin(a);

      return this;
    },

    function distanceTo(other) {
      return this.distance(this.x-other.x, this.y-other.y);
    }
  ]
});
/**
 * @license
 * Copyright 2014 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/** Collision detection manager. **/
foam.CLASS({
  package: 'foam.physics',
  name: 'Collider',

  documentation: 'Apply physics when objects collide.',

  topics: [ 'onTick' ],

  properties: [
    {
      class: 'Boolean',
      name: 'bounceOnWalls'
    },
    {
      name: 'bounds',
      hidden: true
    },
    {
      name: 'children',
      factory: function() { return []; },
      hidden: true
    },
    {
      class: 'Boolean',
      name: 'stopped_',
      value: true,
      hidden: true
    }
  ],

  methods: [
    function updateChild(c) {
      if ( this.bounceOnWalls && this.bounds ) {

        if ( c.left_   < this.bounds.x      ) { c.vx =  Math.abs(c.vx); c.x++; }
        if ( c.top_    < this.bounds.y      ) { c.vy =  Math.abs(c.vy); c.y++; }
        if ( c.right_  > this.bounds.width  ) { c.vx = -Math.abs(c.vx); c.x--; }
        if ( c.bottom_ > this.bounds.height ) { c.vy = -Math.abs(c.vy); c.y--; }
      }
    },

    function updateChildren() {
      var cs = this.children;
      for ( var i = 0 ; i < cs.length ; i++ ) {
        this.updateChild(cs[i]);
      }
    },

    function detectCollisions() {
      /* implicit k-d-tree divide-and-conquer algorithm */
            this.detectCollisions_(0, this.children.length-1, 'x', false, '');

      // TODO: put back above line when properly supports mixing circles and squares
      //this.detectCollisions__(0, this.children.length-1, 'x', false, '');
    },

    function detectCollisions__(start, end) {
      /*
        Simple O(n^2) algorithm, used by more complex algorithm
        once data is partitioned.
      */
      var cs = this.children;
      for ( var i = start ; i <= end ; i++ ) {
        var c1 = cs[i];
        for ( var j = i+1 ; j <= end ; j++ ) {
          var c2 = cs[j];
          if ( c1.intersects && c1.intersects(c2) ) this.collide(c1, c2);
        }
      }
    },

    function choosePivot(start, end, axis) {
      var p = 0, cs = this.children, n = end-start;
      for ( var i = start ; i <= end ; i++ ) p += cs[i][axis] / n;
      return p;
    },

    // TODO: Add support for rectangular objects
    function detectCollisions_(start, end, axis, oneD) {
      if ( start >= end ) return;

      var cs = this.children;
      var pivot = this.choosePivot(start, end, axis);
      var nextAxis = oneD ? axis : axis === 'x' ? 'y' : 'x' ;

      var p = start;
      for ( var i = start ; i <= end ; i++ ) {
        var c = cs[i];
        if ( c[axis] - c.radius < pivot ) {
          var t = cs[p];
          cs[p] = c;
          cs[i] = t;
          p++;
        }
      }

      if ( p === end + 1 ) {
        if ( oneD ) {
          this.detectCollisions__(start, end);
        } else {
          this.detectCollisions_(start, end, nextAxis, true);
        }
      } else {
        this.detectCollisions_(start, p-1, nextAxis, oneD);

        p--;
        for ( var i = p ; i >= start ; i-- ) {
          var c = cs[i];
          if ( c[axis] + c.radius > pivot ) {
            var t = cs[p];
            cs[p] = c;
            cs[i] = t;
            p--;
          }
        }
        if ( p === start-1 ) {
          if ( oneD ) {
            this.detectCollisions__(start, end);
          } else {
            this.detectCollisions_(start, end, nextAxis, true);
          }
        } else {
          this.detectCollisions_(p+1, end, nextAxis, oneD);
        }
      }
    },

    // TODO: add support for rectangles
    function collide(c1, c2) {
      c1.collideWith && c1.collideWith(c2);
      c2.collideWith && c2.collideWith(c1);

      if ( ! c1.mass || ! c2.mass ) return;

      var a  = Math.atan2(c2.y-c1.y, c2.x-c1.x);
      var m1 =  c1.momentumAtAngle(a);
      var m2 = -c2.momentumAtAngle(a);
      var m  = ( m1 + m2 )/2;

      // ensure a minimum amount of momentum so that objects don't overlap
      if ( m >= 0 ) {
        m = Math.max(1, m);
        var tMass = c1.mass + c2.mass;
        c1.applyMomentum(-m * c2.mass/tMass, a);
        c2.applyMomentum( m * c1.mass/tMass, a);
      }
    },

    // add one or more components to be monitored for collisions
    function add() {
      for ( var i = 0 ; i < arguments.length ; i++ ) {
        this.children.push(arguments[i]);
      }
      return this;
    },

    function findChildAt(x, y) {
      var c2 = { x: x, y: y, r: 1 };

      var cs = this.children;
      // Start from the end to find the child in the foreground
      for ( var i = cs.length-1 ; i >= 0 ; i-- ) {
        var c1 = cs[i];
        if ( c1.intersects(c2) ) return c1;
      }
    },

    function selectChildrenAt(x, y) {
      var c2 = { x: x, y: y, r: 1 };

      var children = [];
      var cs = this.children;
      for ( var i = 0 ; i < cs.length ; i++ ) {
        var c1 = cs[i];
        if ( c1.intersects(c2) ) children.push(c1);
      }
      return children;
    },

    function remove() {
      for ( var i = 0 ; i < arguments.length ; i++ ) {
        foam.Array.remove(this.children, arguments[i]);
      }
      return this;
    },

    function detach() {
      this.stopped_ = true;
      this.children = [];
    }
  ],

  actions: [
    {
      name: 'start',
      isEnabled: function(stopped_) { return stopped_; },
      code: function start() {
        this.stopped_ = false;
        this.tick();
      }
    },
    {
      name: 'stop',
      isEnabled: function(stopped_) { return ! stopped_; },
      code: function start() { this.stopped_ = true; }
    }
  ],

  listeners: [
    {
      name: 'tick',
      isFramed: true,
      code: function tick() {
        if ( this.stopped_ ) return;
        this.onTick.pub();
        this.detectCollisions();
        this.updateChildren();

        this.tick();
      }
    }
  ]
});
/**
 * @license
 * Copyright 2015 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

foam.CLASS({
  package: 'foam.physics',
  name: 'PhysicsEngine',
  extends: 'foam.physics.Collider',

  documentation: 'PhysicsEngine is a sub-type of Collider which adds support for friction and gravity.',

  properties: [
    {
      class: 'Boolean',
      name: 'gravity',
      value: false
    },
    {
      class: 'Float',
      name: 'gravityStrength',
      value: 1
    }
  ],

  methods: [
    function updateChild(c) {
      this.SUPER(c);

      var gravity  = c.gravity;
      var friction = c.friction;

      if ( gravity && this.gravity ) {
        c.vy += gravity * this.gravityStrength;
      }

      if ( friction ) {
        c.vx = Math.abs(c.vx) < 0.001 ? 0 : c.vx * friction;
        c.vy = Math.abs(c.vy) < 0.001 ? 0 : c.vy * friction;
      }

      // Inertia
      if ( Math.abs(c.vx) > 0.001 ) c.x += c.vx;
      if ( Math.abs(c.vy) > 0.001 ) c.y += c.vy;
    }
  ]
});
/**
 * @license
 * Copyright 2016 Google Inc. All Rights Reserved.
 * Copyright 2017 The FOAM Authors. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

foam.CLASS({
  package: 'foam.blob',
  name: 'Buffer',

  properties: [
    {
      class: 'Long',
      name: 'length'
    },
    {
      name: 'data',
      factory: function() {
        return new ArrayBuffer(this.length);
      }
    }
  ],

  methods: [
    function slice(start, end) {
      return foam.blob.Buffer.create();
    }
  ]
});

foam.INTERFACE({
  package: 'foam.blob',
  name: 'Blob',

  javaExtends: [ 'java.io.Closeable' ],

  methods: [
    {
      name: 'read',
      returns: 'Promise',
      args: [
        {
          name: 'buffer',
        },
        {
          class: 'Long',
          swiftType: 'Int',
          name: 'offset'
        }
      ]
    },
    {
      name: 'getSize',
      returns: 'Long',
      swiftReturns: 'Int',
    }
  ]
});

foam.INTERFACE({
  package: 'foam.blob',
  name: 'BlobService',

  documentation: 'BlobService Interface',

  methods: [
    {
      name: 'put',
      returns: 'Promise',
      args: [
        {
          class: 'Blob',
          name: 'blob'
        }
      ]
    },
    {
      name: 'put_',
      returns: 'Promise',
      args: [
        {
          name: 'x',
          of: 'foam.core.X'
        },
        {
          class: 'Blob',
          name: 'blob'
        }
      ]
    },
    {
      name: 'find',
      returns: 'Promise',
      args: [
        {
          class: 'String',
          name: 'id'
        }
      ]
    },
    {
      name: 'find_',
      returns: 'Promise',
      args: [
        {
          name: 'x',
          of: 'foam.core.X'
        },
        {
          class: 'String',
          name: 'id'
        }
      ]
    },
    {
      name: 'urlFor',
      returns: 'String',
      args: [
        {
          class: 'Blob',
          name: 'blob'
        }
      ]
    },
    {
      name: 'urlFor_',
      returns: 'String',
      args: [
        {
          name: 'x',
          of: 'foam.core.X'
        },
        {
          class: 'Blob',
          name: 'blob'
        }
      ]
    }
  ]
});


foam.CLASS({
  package: 'foam.blob',
  name: 'AbstractBlob',
  abstract: true,

  implements: [ 'foam.blob.Blob' ],

  methods: [
    function pipe(writeFn) {
      var self = this;

      var offset = 0;
      var buf    = Buffer.alloc(8192 * 4);
      var limit  = self.size;

      function a() {
        if ( offset > limit ) {
          throw 'Offest beyond limit?';
        }

        if ( offset == limit ) return;

        return self.read(buf, offset).then(function(buf2) {
          offset += buf2.length;
          return writeFn(Buffer.from(buf2));
        }).then(a);
      };

      return a();
    },

    function slice(offset, length) {
      return foam.blob.SubBlob.create({
        parent: this,
        offset: offset,
        size: length
      });
    }
  ]
});


foam.CLASS({
  package: 'foam.blob',
  name: 'AbstractBlobService',
  abstract: true,

  implements: [ 'foam.blob.BlobService' ],

  requires: [
    'foam.blob.ProxyBlobService'
  ],

  methods: [
    {
      name: 'inX',
      code: function (x) {
        return this.ProxyBlobService.create({ delegate: this }, x);
      }
    },

    function put(blob) {
      return this.put_(this.__context__, blob);
    },

    function find(id) {
      return this.find_(this.__context__, id);
    },

    function urlFor(blob) {
      return this.urlFor_(this.__context__, blob);
    }
  ]
});


foam.CLASS({
  package: 'foam.blob',
  name: 'ProxyBlob',
  extends: 'foam.blob.AbstractBlob',

  documentation: 'Proxy implementation for the Blob interface',

  properties: [
    {
      class: 'Proxy',
      of: 'foam.blob.Blob',
      name: 'delegate',
      forwards: [ 'read', 'getSize' ]
    }
  ]
});


foam.CLASS({
  package: 'foam.blob',
  name: 'ProxyBlobService',
  extends: 'foam.blob.AbstractBlobService',

  documentation: 'Proxy implementation for the BlobService interface',

  properties: [
    {
      class: 'Proxy',
      of: 'foam.blob.BlobService',
      name: 'delegate',
      forwards: [ 'put_', 'find_', 'urlFor_' ]
    }
  ]
});


foam.CLASS({
  package: 'foam.blob',
  name: 'SubBlob',
  extends: 'foam.blob.AbstractBlob',

  properties: [
    {
      class: 'Blob',
      name: 'parent',
    },
    {
      class: 'Long',
      name: 'offset'
    },
    {
      class: 'Long',
      name: 'size',
      assertValue: function(value) {
        foam.assert(this.offset + value <= this.parent.size, 'Cannot create sub blob beyond end of parent.');
      }
    }
  ],

  methods: [
    function read(buffer, offset) {
      if ( buffer.length > this.size - offset) {
        buffer = buffer.slice(0, this.size - offset);
      }

      return this.parent.read(buffer, offset + this.offset);
    },
    function slice(offset, length) {
      return foam.blob.SubBlob.create({
        parent: this.parent,
        offset: this.offset + offset,
        size: length
      });
    }
  ]
});


foam.CLASS({
  package: 'foam.blob',
  name: 'BlobBlob',
  extends: 'foam.blob.AbstractBlob',

  properties: [
    'blob',
    {
      name: 'size',
      factory: function() {
        return this.blob.size;
      }
    }
  ],

  methods: [
    function read(buffer, offset) {
      var self = this;
      var reader = new FileReader();

      var b = this.blob.slice(offset, offset + buffer.length);

      return new Promise(function(resolve, reject) {
        reader.onload = function(e) {
          resolve(e.result);
        };

        reader.onerror = function(e) {
          reject(e);
        };

        reader.readAsArrayBuffer(b);
      });
    }
  ]
});


foam.CLASS({
  package: 'foam.blob',
  name: 'IdentifiedBlob',
  extends: 'foam.blob.ProxyBlob',

  imports: [
    'blobStore?',
    'blobService'
  ],

  properties: [
    {
      class: 'String',
      name: 'id'
    },
    {
      name: 'delegate',
      transient: true,
      cloneProperty: function(){},
      javaCloneProperty: '//nop',
      factory: function() {
        return this.blobService.find(this.id);
      },
      javaFactory: 'return ((BlobService) getBlobStore()).find(getId());'
    }
  ],

  methods: [
    function compareTo(other) {
      return foam.blob.IdentifiedBlob.isInstance(other) && other.id == this.id;
    },

    function read(buffer, offset) {
      return this.delegate.then(function(d) {
        return d.read(buffer, offset);
      });
    }
  ]
});


foam.CLASS({
  package: 'foam.core',
  name: 'Blob',
  extends: 'foam.core.FObjectProperty',

  properties: [
    [ 'of', 'foam.blob.Blob' ],
    [ 'tableCellView', function() {} ],
    [ 'view', { class: 'foam.u2.view.BlobView' } ]
  ]
});


foam.CLASS({
  package: 'foam.blob',
  name: 'ClientBlob',
  extends: 'foam.blob.AbstractBlob',

  properties: [
    {
      class: 'Stub',
      of: 'foam.blob.Blob',
      name: 'delegate'
    }
  ]
});


foam.CLASS({
  package: 'foam.blob',
  name: 'FdBlob',
  extends: 'foam.blob.AbstractBlob',

  properties: [
    {
      name: 'fd'
    },
    {
      class: 'Long',
      name: 'size',
      expression: function(fd) {
        return __webpack_require__(16).fstatSync(fd).size;
      }
    }
  ],

  methods: [
    function read(buffer, inOffset) {
      inOffset = inOffset || 0;
      var self = this;
      var outOffset = 0;
      var length = Math.min(buffer.length, this.size - inOffset);

      if ( length < buffer.length ) buffer = buffer.slice(0, length);

      return new Promise(function(resolve, reject) {
        function onRead(err, bytesRead, buffer) {
          if ( err ) {
            reject(err);
            return;
          }

          outOffset += bytesRead;
          inOffset += bytesRead;

          if ( outOffset < length ) {
            throw new Error('Does this ever happen.');
//            require('fs').read(self.fd, buffer, outOffset, length - outOffset, inOffset, onRead);
          } else {
            resolve(buffer);
          }
        }

        __webpack_require__(16).read(self.fd, buffer, outOffset, length - outOffset, inOffset, onRead);
      });
    }
  ]
});


foam.CLASS({
  package: 'foam.blob',
  name: 'BlobStore',
  extends: 'foam.blob.AbstractBlobService',

  requires: [
    'foam.blob.IdentifiedBlob'
  ],

  properties: [
    {
      class: 'String',
      name: 'root'
    },
    {
      class: 'String',
      name: 'tmp',
      transient: true,
      expression: function(root) {
        return root + '/tmp';
      }
    },
    {
      class: 'String',
      name: 'sha256',
      transient: true,
      expression: function(root) {
        return root + '/sha256';
      }
    },
    {
      class: 'Boolean',
      name: 'isSet',
      value: false,
      hidden: true,
      transient: true
    }
  ],

  methods: [
    function setup() {
      if ( this.isSet ) return;

      var parsed = __webpack_require__(68).parse(this.root);

      if ( ! __webpack_require__(16).statSync(parsed.dir).isDirectory() ) {
        throw new Error(parsed.dir + ' is not a directory.');
      }

      this.ensureDir(this.root);
      this.ensureDir(this.tmp);
      this.ensureDir(this.sha256);

      this.isSet = true;
    },

    function ensureDir(path) {
      var stat;

      try {
        stat = __webpack_require__(16).statSync(path);
        if ( stat && stat.isDirectory() ) return;
      } catch(e) {
        if ( e.code === 'ENOENT' ) return __webpack_require__(16).mkdirSync(path);

        throw e;
      }
    },

    function allocateTmp() {
      var fd;
      var path;
      //      var name = Math.floor(Math.random() * 0xFFFFFF)
      var name = 1;
      var self = this;

      return new Promise(function aaa(resolve, reject) {
        path = self.tmp + __webpack_require__(68).sep + (name++);
        fd = __webpack_require__(16).open(path, 'wx', function onOpen(err, fd) {
          if ( err && err.code !== 'EEXIST' ) {
            reject(err);
            return;
          }

          if ( err ) aaa(resolve, reject);
          else resolve({ path: path, fd: fd});
        });
      });
    },

    function put_(x, obj) {
      if ( this.IdentifiedBlob.isInstance(obj) ) {
        return obj;
      }

      this.setup();
      // This process could probably be sped up a bit by
      // requesting chunks of the incoming blob in advance,
      // currently we wait until they're put into the write-stream's
      // buffer before requesitng the next chunk.

      var hash = __webpack_require__(815).createHash('sha256');

      var bufsize = 8192;
      var buffer = Buffer.alloc(bufsize);

      var size = obj.size
      var remaining = size;
      var offset = 0;
      var self = this;

      var chunks = Math.ceil(size / bufsize);

      function chunkOffset(i) {
        return i * bufsize;
      }

      var tmp;

      function writeChunk(chunk) {
        return obj.read(buffer, chunkOffset(chunk)).then(function(buf) {
          hash.update(buf);
          return new Promise(function(resolve, reject) {
            __webpack_require__(16).write(tmp.fd, buf, 0, buf.length, function cb(err, written, buffer) {
              if ( err ) {
                reject(err);
                return;
              }

              if ( written !== buf.length ) {
                console.warn("Didn't write entire chunk, does this ever happen?");
                __webpack_require__(16).write(tmp.fd, buf.slice(written), cb);
                return;
              }

              resolve();
            });
          });
        });
      }

      var chunk = 0;
      return this.allocateTmp().then(function(tmpfile) {
        tmp = tmpfile;
      }).then(function a() {
        if ( chunk < chunks ) return writeChunk(chunk++).then(a);
      }).then(function() {
        return new Promise(function(resolve, reject) {
          __webpack_require__(16).close(tmp.fd, function() {
            var digest = hash.digest('hex');
            __webpack_require__(16).rename(tmp.path, self.sha256 + __webpack_require__(68).sep + digest, function(err) {
              if ( err ) {
                reject(err);
                return;
              }
              resolve(self.IdentifiedBlob.create({ id: digest }));
            });
          });
        });
      });
    },

    function filename(blob) {
      if ( ! foam.blob.IdentifiedBlob.isInstance(blob) ) return null;

      var path = this.sha256 + __webpack_require__(68).sep + blob.id;
      try {
        __webpack_require__(16).statSync(path);
      } catch(e) {
        return null;
      }

      return path;
    },

    function find_(x, id) {
      this.setup();
      if ( id.indexOf(__webpack_require__(68).sep) != -1 ) {
        return Promise.reject(new Error("Invalid file name"));
      }

      var self = this;

      return new Promise(function(resolve, reject) {
        __webpack_require__(16).open(self.sha256 + __webpack_require__(68).sep + id, "r", function(err, fd) {
          if ( err ) {
            if ( err.code == 'ENOENT' ) {
              resolve(null);
              return;
            }

            reject(err);
            return;
          }
          resolve(foam.blob.FdBlob.create({ fd: fd }));
        });
      });
    }
  ]
});


foam.CLASS({
  package: 'foam.blob',
  name: 'RestBlobService',
  extends: 'foam.blob.AbstractBlobService',

  documentation: 'Implementation of a BlobService against a REST interface.',

  requires: [
    'foam.net.HTTPRequest',
    'foam.blob.BlobBlob',
    'foam.blob.IdentifiedBlob'
  ],

  properties: [
    {
      class: 'String',
      name: 'serviceName'
    },
    {
      class: 'String',
      name: 'address',
      factory: function() {
        var sessionId = localStorage['defaultSession'];
        var url = window.location.origin + '/' + this.serviceName
        // attach session id if available
        if ( sessionId ) {
          url += '?sessionId=' + sessionId;
        }
        return url;
      }
    }
  ],

  methods: [
    function put_(x, blob) {
      if ( this.IdentifiedBlob.isInstance(blob) ) {
        // Already stored.
        return Promise.resolve(blob);
      }

      var req = this.HTTPRequest.create();
      req.fromUrl(this.address);
      req.method = 'PUT';
      req.payload = blob;

      var self = this;

      return req.send().then(function(resp) {
        return resp.payload;
      }).then(function(payload) {
        return foam.json.Parser.create({ creationContext: self }).parseString(payload);
      });
    },

    function urlFor_(x, blob) {
      if ( ! foam.blob.IdentifiedBlob.isInstance(blob) ) {
        return null;
      }

      return this.address + '/' + blob.id;
    },

    function find_(x, id) {
      var req = this.HTTPRequest.create();
      req.fromUrl(this.address + '/' + id);
      req.method = 'GET';
      req.responseType = 'blob';

      var self = this;
      return req.send().then(function(resp) {
        return resp.payload;
      }).then(function(blob) {
        return self.BlobBlob.create({
          blob: blob
        });
      });
    }
  ]
});


foam.CLASS({
  package: 'foam.blob',
  name: 'BlobServiceDecorator',
  extends: 'foam.dao.AbstractDAODecorator',

  imports: [
    'blobService'
  ],

  properties: [
    {
      class: 'Class',
      name: 'of'
    }
  ],

  methods: [
    function write(X, dao, obj, existing) {
      var i = 0;
      var props = obj.cls_.getAxiomsByClass(foam.core.Blob);
      var self = this;

      return Promise.resolve().then(function a() {
        var prop = props[i++];

        if ( ! prop ) return obj;

        var blob = prop.f(obj);

        if ( ! blob ) return obj;

        return self.blobService.put(blob).then(function(b) {
          prop.set(obj, b);
          return a();
        });
      });
    }
  ]
});


foam.CLASS({
  package: 'foam.blob',
  name: 'TestBlobService',
  extends: 'foam.blob.AbstractBlobService',

  requires: [
    'foam.blob.IdentifiedBlob',
    'foam.blob.BlobBlob'
  ],

  properties: [
    {
      class: 'Map',
      name: 'blobs'
    },
    {
      class: 'Int',
      name: 'nextId',
      value: 1
    }
  ],

  methods: [
    function put_(x, file) {
      var id = this.nextId++;
      this.blobs[id] = file;
      return Promise.resolve(this.IdentifiedBlob.create({ id: id }));
    },

    function find_(x, id) {
      return Promise.resolve(this.blobs[id] ?
                             this.BlobBlob.create({ blob: this.blobs[id] }) :
                             null);
    },

    function urlFor_(x, blob) {
      if ( this.IdentifiedBlob.isInstance(blob) ) {
        return URL.createObjectURL(this.blobs[blob.id]);
      } else if ( this.BlobBlob.isInstance(blob) ) {
        return URL.createObjectURL(blob.blob);
      }

      return null;
    }
  ]
});
/**
 * @license
 * Copyright 2016 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

foam.CLASS({
  package: 'foam.encodings',
  name: 'UTF8',

  properties: [
    {
      name: 'charcode'
    },
    {
      class: 'Int',
      name: 'remaining',
      value: 0
    },
    {
      class: 'String',
      name: 'string'
    }
  ],

  methods: [
    function reset() {
      this.string = '';
      this.remaining = 0;
      this.charcode = null;
    },

    function put(byte) {
      if ( byte instanceof ArrayBuffer ) {
        var data = new Uint8Array(byte);
        this.put(data);
        return;
      }

      if ( byte instanceof Uint8Array ) {
        for ( var i = 0 ; i < byte.length ; i++ ) {
          this.put(byte[i]);
        }
        return;
      }

      if (this.charcode == null) {
        this.charcode = byte;
        if (!(this.charcode & 0x80)) {
          this.remaining = 0;
          this.charcode = (byte & 0x7f) << (6 * this.remaining);
        } else if ((this.charcode & 0xe0) == 0xc0) {
          this.remaining = 1;
          this.charcode = (byte & 0x1f) << (6 * this.remaining);
        } else if ((this.charcode & 0xf0) == 0xe0) {
          this.remaining = 2;
          this.charcode = (byte & 0x0f) << (6 * this.remaining);
        } else if ((this.charcode & 0xf8) == 0xf0) {
          this.remaining = 3;
          this.charcode = (byte & 0x07) << (6 * this.remaining);
        } else if ((this.charcode & 0xfc) == 0xf8) {
          this.remaining = 4;
          this.charcode = (byte & 0x03) << (6 * this.remaining);
        } else if ((this.charcode & 0xfe) == 0xfc) {
          this.remaining = 5;
          this.charcode = (byte & 0x01) << (6 * this.remaining);
        } else throw 'Bad charcode value';
      } else if ( this.remaining > 0 ) {
        this.remaining--;
        this.charcode |= (byte & 0x3f) << (6 * this.remaining);
      }

      if ( this.remaining == 0 ) {
        this.string += String.fromCodePoint(this.charcode);
        this.charcode = undefined;
      }
    }
   ]
});
/**
 * @license
 * Copyright 2018 The FOAM Authors. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

foam.CLASS({
  package :'foam.net',
  name: 'NotConnectedException',
  implements: [ 'foam.core.Exception' ]
});
/**
 * @license
 * Copyright 2018 The FOAM Authors. All Rights Reserved.
 */

foam.CLASS({
  package :'foam.net',
  name: 'ConnectionFailedException',
  implements: [ 'foam.core.Exception' ]
});
/**
 * @license
 * Copyright 2016 Google Inc. All Rights Reserved.
 * Copyright 2017 The FOAM Authors. All Rights Reserved.
 * http://www.apache.org/licenses/LICENSE-2.0
 */

foam.CLASS({
  package: 'foam.net.web',
  name: 'WebSocket',

  requires: [
    'foam.net.NotConnectedException',
    'foam.net.ConnectionFailedException'
  ],

  topics: [
    'message',
    'connected',
    'disconnected'
  ],

  properties: [
    {
      name: 'uri'
    },
    {
      name: 'socket',
      transient: true
    }
  ],

  methods: [
    function send(msg) {
      // Apparently you can't catch exceptions from calling .send()
      // when the socket isn't open.  So we'll try to predict an exception
      // happening and throw early.
      //
      // There could be a race condition here if the socket
      // closes between our check and .send().
      if ( this.socket.readyState !== this.socket.OPEN ) {
        throw this.NotConnectedException.create();
      }
      this.socket.send(msg);
    },

    function connect() {
      var socket = this.socket = new WebSocket(this.uri);
      var self = this;

      return new Promise(function(resolve, reject) {
        function onConnect() {
          socket.removeEventListener('open', onConnect);
          resolve(self);
        }
        function onConnectError(e) {
          socket.removeEventListener('error', onConnectError);
          reject(self.ConnectionFailedException.create());
        }

        socket.addEventListener('open', onConnect);
        socket.addEventListener('error', onConnectError);

        socket.addEventListener('open', function() {
          self.connected.pub();
        });
        socket.addEventListener('message', self.onMessage);
        socket.addEventListener('close', function() {
          self.disconnected.pub();
        });
      });
    },

    function disconnect() {
      this.socket && this.socket.close();
    }
  ],

  listeners: [
    {
      name: 'onMessage',
      code: function(msg) {
        this.message.pub(msg.data);
      }
    }
  ]
});
/**
 * @license
 * Copyright 2016 Google Inc. All Rights Reserved.
 * Copyright 2017 The FOAM Authors. All Rights Reserved.
 * http://www.apache.org/licenses/LICENSE-2.0
 */

foam.CLASS({
  package: 'foam.net.web',
  name: 'WebSocketService',

  requires: [
    'foam.box.Message',
    'foam.json.Parser',
    'foam.net.web.WebSocket',
    'foam.box.RawWebSocketBox'
  ],

  imports: [ 'creationContext' ],

  properties: [
    {
      name: 'delegate'
    },
    {
      class: 'FObjectProperty',
      of: 'foam.json.Parser',
      name: 'parser',
      factory: function() {
        return this.Parser.create({
          strict: true,
          creationContext: this.creationContext
        });
      }
    }
  ],

  methods: [
    function addSocket(socket) {
      var X = this.creationContext.createSubContext({
        returnBox: this.RawWebSocketBox.create({ socket: socket })
      });

      var sub1 = socket.message.sub(function onMessage(s, _, msgStr) {
        try {
          var msg = this.parser.parseString(msgStr, X);

          if ( ! this.Message.isInstance(msg) ) {
            console.warn('Got non-message', msg.cls_.id);
            console.warn('  payload was: ', msgStr);
            return;
          }

          this.delegate.send(msg);
        } catch (e) {
          console.error("WSS Error:", e);
        }
      }.bind(this));

      socket.disconnected.sub(function(s) {
        s.detach();
        sub1.detach();
      });
    }
  ]
});
/**
 * @license
 * Copyright 2017 The FOAM Authors. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

foam.CLASS({
  package: 'foam.net.web',
  name: 'HTTPResponse',

  topics: [
    'data',
    'err',
    'end'
  ],

  properties: [
    {
      class: 'Int',
      name: 'status'
    },
    {
      class: 'String',
      name: 'responseType'
    },
    {
      class: 'Map',
      name: 'headers'
    },
    {
      name: 'payload',
      factory: function() {
        if ( this.streaming ) {
          return null;
        }

        switch ( this.responseType ) {
          case 'text':        return this.resp.text();
          case 'blob':        return this.resp.blob();
          case 'arraybuffer': return this.resp.arraybuffer();
          case 'json':        return this.resp.json();
        }

        // TODO: responseType should be an enum and/or have validation
        throw new Error('Unsupported response type: ' + this.responseType);
      }
    },
    {
      class: 'Boolean',
      name: 'streaming',
      value: false
    },
    {
      class: 'Boolean',
      name: 'success',
      expression: function(status) {
        return status >= 200 && status <= 299;
      }
    },
    {
      name: 'resp',
      postSet: function(_, r) {
        if ( r.headers.entries ) this.copyHeaders_(r);
        else                     this.copyHeadersEdge_(r);
        this.status = r.status;
      }
    }
  ],

  methods: [
    function start() {
      var reader = this.resp.body.getReader();
      this.streaming = true;

      var onError = foam.Function.bind(function(e) {
        this.err.pub();
        this.end.pub();
      }, this);

      var onData = foam.Function.bind(function(e) {
        if ( e.value ) {
          this.data.pub(e.value);
        }

        if ( e.done || ! this.streaming) {
          this.end.pub();
          return this;
        }
        return reader.read().then(onData, onError);
      }, this);

      return reader.read().then(onData, onError);
    },

    function stop() {
      this.streaming = false;
    },
    function copyHeaders_(r) {
      var iterator = r.headers.entries();
      var next = iterator.next();
      while ( ! next.done ) {
        this.headers[next.value[0]] = next.value[1];
        next = iterator.next();
      }
    },
    function copyHeadersEdge_(r) {
      // Deal with https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/13928907/
      var headers = this.headers;
      r.headers.forEach(function(value, key) {
        headers[key] = value;
      });
    }
  ]
});
/**
 * @license
 * Copyright 2017 The FOAM Authors. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

foam.CLASS({
  package: 'foam.net.web',
  name: 'HTTPRequest',

  requires: [
    'foam.net.web.HTTPResponse',
    'foam.blob.Blob',
    'foam.blob.BlobBlob'
  ],

  topics: [
    'data'
  ],

  properties: [
    {
      class: 'String',
      name: 'hostname'
    },
    {
      class: 'Int',
      name: 'port'
    },
    {
      class: 'String',
      name: 'protocol',
      preSet: function(old, nu) {
        return nu.replace(':', '');
      }
    },
    {
      class: 'String',
      name: 'path',
      preSet: function(old, nu) {
        if ( ! nu.startsWith('/') ) return '/' + nu;
        return nu;
      }
    },
    {
      class: 'String',
      name: 'url'
    },
    {
      class: 'String',
      name: 'method',
      value: 'GET'
    },
    {
      class: 'Map',
      name: 'headers'
    },
    {
      name: 'payload'
    },
    {
      // TODO: validate acceptable types
      class: 'String',
      name: 'responseType',
      value: 'text'
    },
    {
      class: 'String',
      name: 'contentType',
      factory: function() { return this.responseType; }
    },
    {
      class: 'String',
      name: 'mode',
      value: 'cors'
    }
  ],

  methods: [
    function fromUrl(url) {
      var u = new URL(url);
      this.protocol = u.protocol.substring(0, u.protocol.length-1);
      this.hostname = u.hostname;
      if ( u.port ) this.port = u.port;
      this.path = u.pathname + u.search;
      return this;
    },

    function send() {
      if ( this.url ) {
        this.fromUrl(this.url);
      }
      this.addContentHeaders();

      var self = this;

      var headers = new Headers();
      for ( var key in this.headers ) {
        headers.set(key, this.headers[key]);
      }

      var options = {
        method: this.method,
        headers: headers,
        mode: this.mode,
        redirect: "follow",
        credentials: "same-origin"
      };

      if ( this.payload ) {
        if ( this.BlobBlob.isInstance(this.payload) ) {
          options.body = this.payload.blob;
        } else if ( this.Blob.isInstance(this.payload) ) {
          foam.assert(false, 'TODO: Implemented sending of foam.blob.Blob over HTTPRequest.');
        } else {
          options.body = this.payload;
        }
      }

      var request = new Request(
          this.protocol + "://" +
          this.hostname +
          ( this.port ? ( ':' + this.port ) : '' ) +
          this.path,
          options);

      return fetch(request).then(function(resp) {
        var resp = this.HTTPResponse.create({
          resp: resp,
          responseType: this.responseType
        });

        if ( resp.success ) return resp;

        // Use Promise.reject so crappy debuggers don't pause here
        // throw resp;
        return Promise.reject(resp);
      }.bind(this));
    },
    function addContentHeaders() {
      // Specify Content-Type header when it can be deduced.
      if ( ! this.headers['Content-Type'] ) {
        switch ( this.contentType ) {
          case 'text':
          this.headers['Content-Type'] = 'text/plain';
          break;
          case 'json':
          this.headers['Content-Type'] = 'application/json';
          break;
        }
      }
      // Specify this.contentType when it can be deduced.
      if ( ! this.headers['Accept'] ) {
        switch ( this.contentType ) {
          case 'json':
          this.headers['Accept'] = 'application/json';
          break;
        }
      }
    }
  ]
});
/**
 * @license
 * Copyright 2017 The FOAM Authors. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


// Registering BaseHTTPRequest facilitates decoration when HTTPRequest has been
// re-overridden.
foam.register(foam.lookup('foam.net.web.HTTPRequest'),
              'foam.net.web.BaseHTTPRequest');
/**
 * @license
 * Copyright 2017 The FOAM Authors. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

foam.CLASS({
  package: 'foam.net.web',
  name: 'EventSource',

  requires: [
    'foam.parse.Grammar',
    'foam.net.web.HTTPRequest',
    'foam.encodings.UTF8'
  ],

  imports: [
    'setTimeout',
    'clearTimeout'
  ],

  topics: [
    {
      name: 'message'
    }
  ],

  properties: [
    {
      name: 'grammar',
      factory: function() {
        var self = this;
        return this.Grammar.create({
          symbols: function(repeat, alt, sym, notChars, seq) {
            return {
              START: sym('line'),

              line: alt(
                sym('event'),
                sym('data')),

              event: seq('event: ', sym('event name')),
              'event name': repeat(notChars('\r\n')),

              data: seq('data: ', sym('data payload')),
              'data payload': repeat(notChars('\r\n'))
            }
          }
        }).addActions({
          'event name': function(v) {
            self.eventName = v.join('');
          },
          'data payload': function(p) {
            self.eventData = p.join('');
          }
        });
      }
    },
    {
      class: 'String',
      name: 'uri'
    },
    {
      class: 'Boolean',
      name: 'running',
      value: false
    },
    {
      name: 'resp'
    },
    {
      name: 'decoder',
      factory: function() {
        return this.UTF8.create()
      }
    },
    {
      name: 'retryTimer'
    },
    {
      class: 'Int',
      name: 'delay',
      preSet: function(_, a) {
        if ( a > 30000 ) return 30000;
        return a;
      },
      value: 1
    },
    'eventData',
    'eventName'
  ],

  methods: [
    function start() {
      var req = this.HTTPRequest.create({
        method: "GET",
        url: this.uri,
        headers: {
          'accept': 'text/event-stream'
        }
      });

      this.running = true;
      this.keepAlive();
      req.send().then(function(resp) {
        if ( ! resp.success ) {
          this.onError();
          return;
        }

        this.clearProperty('decoder');
        resp.data.sub(this.onData);
        resp.end.sub(this.onError);
        this.resp = resp;
        resp.start();
      }.bind(this), this.onError);
    },

    function keepAlive() {
      if ( this.retryTimer ) {
        this.clearTimeout(this.retryTimer);
      }

      this.retryTimer = this.setTimeout(foam.Function.bind(function() {
        this.retryTimer = 0;
        this.onError();
      }, this), 30000);
    },

    function close() {
      this.running = false;
      this.resp.stop();
    },

    function dispatchEvent() {
      // Known possible events names
      // put
      // patch
      // keep-alive
      // cancel
      // auth revoked

      this.message.pub(this.eventName, this.eventData);
      this.eventName = null;
      this.eventData = null;
    },

    function processLine(line) {
      // TODO: This can probably be simplified by using state machine based
      // parsers, but in the interest of saving time we're going to do it line
      // by line for now.  Something we know works from previous interations.

      if ( line.length == 0 ) {
        this.dispatchEvent();
        return;
      }

      this.grammar.parseString(line);
    }
  ],

  listeners: [
    function onData(s, _, data) {
      this.delay = 1;
      this.keepAlive();

      this.decoder.put(data);
      var string = this.decoder.string;
      while ( string.indexOf('\n') != -1 ) {
        var line = string.substring(0, string.indexOf('\n'));
        this.processLine(line);
        string = string.substring(string.indexOf('\n') + 1);
      }
      this.decoder.string = string;
    },

    function onError() {
      this.delay *= 2;
      this.setTimeout(this.onEnd, this.delay);
    },

    function onEnd() {
      if ( this.running ) {
        this.start();
      }
    }
  ]
});
/**
 * @license
 * Copyright 2017 The FOAM Authors. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

foam.CLASS({
  package: 'foam.net.web',
  name: 'XMLHTTPRequest',
  extends: 'foam.net.web.HTTPRequest',

  requires: [
    'foam.net.web.XMLHTTPResponse as HTTPResponse'
  ],

  methods: [
    function send() {
      if ( this.url ) {
        this.fromUrl(this.url);
      }

      var xhr = new XMLHttpRequest();
      xhr.open(
          this.method,
          this.protocol + "://" +
          this.hostname + ( this.port ? ( ':' + this.port ) : '' ) +
          this.path);
      xhr.responseType = this.responseType;
      for ( var key in this.headers ) {
        xhr.setRequestHeader(key, this.headers[key]);
      }

      var self = this;
      return new Promise(function(resolve, reject) {
        xhr.addEventListener('readystatechange', function foo() {
          if ( this.readyState === this.LOADING ||
               this.readyState === this.DONE ) {
            this.removeEventListener('readystatechange', foo);
            var resp = self.HTTPResponse.create({
              xhr: this
            });

            if ( resp.success ) resolve(resp);
            else reject(resp);
          }
        });
        xhr.send(self.payload);
      });
    }
  ]
});
/**
 * @license
 * Copyright 2017 The FOAM Authors. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

foam.CLASS({
  package: 'foam.net.web',
  name: 'XMLHTTPResponse',
  extends: 'foam.net.web.HTTPResponse',

  constants: {
    STREAMING_LIMIT: 10 * 1024 * 1024
  },

  properties: [
    {
      name: 'xhr',
      postSet: function(_, xhr) {
        this.status = xhr.status;
        var headers = xhr.getAllResponseHeaders().split('\r\n');
        for ( var i = 0 ; i < headers.length ; i++ ) {
          var sep = headers[i].indexOf(':');
          var key = headers[i].substring(0, sep);
          var value = headers[i].substring(sep+1);
          this.headers[key.trim()] = value.trim();
        }
        this.responseType = xhr.responseType;
      }
    },
    {
      name: 'payload',
      factory: function() {
        if ( this.streaming ) {
          return null;
        }

        var self = this;
        var xhr = this.xhr;

        if ( xhr.readyState === xhr.DONE )
          return Promise.resolve(xhr.response);
        else
          return new Promise(function(resolve, reject) {
            xhr.addEventListener('readystatechange', function() {
              if ( this.readyState === this.DONE )
                resolve(this.response);
            });
          });
      }
    },
    {
      class: 'Int',
      name: 'pos',
      value: 0
    }
  ],

  methods: [
    function start() {
      this.streaming = true;
      this.xhr.addEventListener('loadend', function() {
        this.done.pub();
      }.bind(this));

      this.xhr.addEventListener('progress', function() {
        var substr = this.xhr.responseText.substring(this.pos);
        this.pos = this.xhr.responseText.length;
        this.data.pub(substr);

        if ( this.pos > this.STREAMING_LIMIT ) {
          this.xhr.abort();
        }
      }.bind(this));
    }
  ]
});
/**
 * @license
 * Copyright 2017 The FOAM Authors. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

foam.CLASS({
  package: 'foam.net.web',
  name: 'SafariEventSource',
  extends: 'foam.net.web.EventSource',

  requires: [
    'foam.net.web.XMLHTTPRequest as HTTPRequest'
  ],

  properties: [
    {
      class: 'String',
      name: 'buffer'
    }
  ],

  listeners: [
    function onData(s, _, data) {
      this.delay = 1;
      this.keepAlive();

      this.buffer += data;
      var string = this.buffer;

      while ( string.indexOf('\n') != -1 ) {
        var line = string.substring(0, string.indexOf('\n'));
        this.processLine(line);
        string = string.substring(string.indexOf('\n') + 1);
      }

      this.buffer = string;
    }
  ]
});
/**
 * @license
 * Copyright 2016 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

foam.CLASS({
  package: 'foam.messageport',
  name: 'MessagePortService',

  requires: [
    'foam.box.NamedBox',
    'foam.box.RawMessagePortBox',
    'foam.box.RegisterSelfMessage',
    'foam.json.Parser'
  ],
  imports: [
    'creationContext'
  ],

  topics: [ 'connect' ],

  properties: [
    {
      name: 'source',
      postSet: function() {
        this.source.addEventListener('connect', this.onConnect);
        this.source.addEventListener('message', this.onConnect);
      }
    },
    {
      name: 'delegate',
      required: true
    },
    {
      class: 'FObjectProperty',
      of: 'foam.json.Parser',
      name: 'parser',
      factory: function() {
        // NOTE: Configuration must be consistent with outputters in
        // foam.box.MessagePortBox and foam.box.RawMesagePortBox.
        return this.Parser.create({
          strict: true,
          creationContext: this.creationContext
        });
      }
    }
  ],

  methods: [
    function addPort(p) {
      p.onmessage = this.onMessage.bind(this, p);
    }
  ],

  listeners: [
    function onConnect(e) {
      for ( var i = 0 ; i < e.ports.length ; i++ ) {
        this.addPort(e.ports[i]);
      }
    },

    function onMessage(port, e) {
      var msg = this.parser.parseString(e.data);

      if ( this.RegisterSelfMessage.isInstance(msg.object) ) {
        var named = this.NamedBox.create({ name: msg.object.name });
        named.delegate = this.RawMessagePortBox.create({
          port: port
        });
        this.connect.pub(named);
        return;
      }

      this.delegate && this.delegate.send(msg);
    }
  ]
});
/**
 * @license
 * Copyright 2014 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*
TODO:
-better serialization/deserialization
-error handling if firebase contains malformed data, since we're not the only
ones who can write to it.
-multi part keys
*/

foam.CLASS({
  package: 'com.firebase',
  name: 'ExpectedObjectNotFound',
  extends: 'foam.dao.InternalException'
});

foam.CLASS({
  package: 'com.firebase',
  name: 'FirebaseDAO',
  extends: 'foam.dao.AbstractDAO',

  requires: [
    'foam.dao.ArraySink',
    'foam.net.web.HTTPRequest',
    'com.firebase.FirebaseEventSource',
    'foam.mlang.predicate.Gt',
    'foam.mlang.Constant'
  ],

  properties: [
    'of',
    'apppath',
    'secret',
    'eventSource_',
    {
      name: 'timestampProperty'
    },
    {
      name: 'basepath',
      expression: function(apppath, of) {
        return apppath + of.id.replace(/\./g, '/');
      }
    },
    {
      class: 'Boolean',
      name: 'enableStreaming',
      value: true
    },
    'startEventsAt_'
  ],

  methods: [
    function put_(x, obj) {
      var req = this.HTTPRequest.create();

      if ( obj.id ) {
        req.method = "PUT";
        req.url = this.basepath
          + "/"
          + encodeURIComponent(obj.id) + ".json";
      } else {
        throw new Error('Server generated IDs not supported.');
        // req.method = 'POST';
        // req.url = this.basepath + '.json';
      }

      if ( this.secret ) {
        req.url += '?auth=' + encodeURIComponent(this.secret);
      }

      req.payload = JSON.stringify({
        data: foam.json.stringify(obj),
        lastUpdate: {
          ".sv": "timestamp"
        }
      });
      req.headers['content-type'] = 'application/json';
      req.headers['accept']       = 'application/json';

      return req.send().then(function(resp) {
        return resp.payload;
      }).then(function(payload) {
        payload = JSON.parse(payload);

        //        if ( obj.id ) {
        var o2 = foam.json.parseString(payload.data, this);
          if ( this.timestampProperty ) {
            this.timestampProperty.set(o2, payload.lastUpdate);
          }
          return o2;
        //        } else {
        //           Server created id
        //        }
      }.bind(this), function(resp) {
        // TODO: Handle various errors.
        return Promise.reject(foam.dao.InternalException.create());
      });
    },

    function remove_(x, obj) {
      var req = this.HTTPRequest.create();
      req.method = 'DELETE',
      req.url = this.basepath + "/" + encodeURIComponent(obj.id) + ".json";

      if ( this.secret ) {
        req.url += "?auth=" + encodeURIComponent(this.secret);
      }

      return req.send().then(function() {
        return Promise.resolve();
      }, function() {
        return Promise.reject(foam.dao.InternalException.create());
      });
    },

    function find_(x, id) {
      var req = this.HTTPRequest.create();
      req.method = "GET";
      req.url = this.basepath + "/" + encodeURIComponent(id) + ".json";
      if ( this.secret ) {
        req.url += "?auth=" + encodeURIComponent(this.secret);
      }

      return req.send().then(function(resp) {
        return resp.payload;
      }).then(function(data) {
        if ( data == "null" ) {
          return Promise.resolve(null);
        }
        try {
          data = JSON.parse(data);

          var obj = foam.json.parseString(data.data, this);

          if ( this.timestampProperty ) {
            this.timestampProperty.set(obj, data.lastUpdate);
          }

          return obj;
        } catch(e) {
          return Promise.reject(foam.dao.InternalException.create());
        }
      }.bind(this));
    },

    function startEvents() {
      if ( this.eventSource_ || ! this.enableStreaming ) {
        return;
      }

      var params = [];
      if ( this.secret ) params.push(['auth', this.secret]);
      if ( this.startEventsAt_ ) {
        params.push(['orderBy', '"lastUpdate"']);
        params.push(['startAt', this.startEventsAt_]);
      }

      var uri = this.basepath + '.json';
      if ( params.length ) {
        uri += '?' + params.map(function(p) { return p.map(encodeURIComponent).join('='); }).join('&');
      }

      this.eventSource_ = this.FirebaseEventSource.create({
        uri: uri
      });

      this.eventSource_.put.sub(this.onPut);
      this.eventSource_.patch.sub(this.onPatch);
      this.eventSource_.start();
    },

    function stopEvents() {
      if ( this.eventSource_ ) {
        this.eventSource_.close();
        this.eventSource_.message.put.unsub(this.onPut);
        this.eventSource_.message.patch.unsub(this.onPatch);
        this.clearProperty('eventSource_');
      }
    },

    function select_(x, sink, skip, limit, order, predicate) {
      var req = this.HTTPRequest.create();
      req.method = "GET";

      var params = [];
      if ( this.secret ) params.push(['auth', this.secret]);

      // Efficiently handle GT(lastupdate, #) queries.  Used by the SyncDAO to get
      // all changes.

      if ( predicate && this.timestampProperty &&
           this.Gt.isInstance(predicate) &&
           this.Constant.isInstance(predicate.arg2) &&
           predicate.arg1 === this.timestampProperty ) {

        // TODO: This is a hack to ensure that
        if ( ! this.startEventsAt_ )  {
          this.startEventsAt_ = predicate.arg2.f() + 1;
          this.startEvents();
        }

        params.push(['orderBy', '"lastUpdate"']);
        params.push(['startAt', predicate.arg2.f() + 1]);
      }

      var url = this.basepath + '.json';
      if ( params.length ) {
        url += '?' + params.map(function(p) { return p.map(encodeURIComponent).join('='); }).join('&');
      }

      req.url = url;

      var resultSink = sink || this.ArraySink.create();
      sink = this.decorateSink_(resultSink, skip, limit, order, predicate);

      // TODO: This should be streamed for better handling of large responses.
      return req.send().then(function(resp) {
        if ( ! resp.success ) {
          return Promise.reject(foam.dao.InternalException.create());
        }
        return resp.payload;
      }).then(function(payload) {
        var data = JSON.parse(payload);

        var detached = false;
        var sub = foam.core.FObject.create();
        sub.onDetach(function() { detached = true; });

        for ( var key in data ) {
          if ( detached ) break;

          var obj = foam.json.parseString(data[key].data, this);
          if ( this.timestampProperty ) {
            this.timestampProperty.set(obj, data[key].lastUpdate);
          }

          sink.put(obj, sub);
        }
        sink.eof();

        return resultSink;
      }.bind(this), function(resp) {
        var e = foam.dao.InternalException.create();
        return Promise.reject(e);
      });
    }
  ],

  listeners: [
    function onPut(s, _, data) {
      // PATH is one of
      // / -> new objects
      // /key -> new object
      // /key/data -> updated object

      var path = data.path;
      if ( path == "/" ) {
        // All data removed?
        if ( data.data == null ) {
          this.on.reset.pub();
          return;
        }

        for ( var key in data.data ) {
          var obj = foam.json.parseString(data.data[key].data, this);
          if ( this.timestampProperty ) {
            this.timestampProperty.set(obj, data.data[key].lastUpdate);
          }
          this.on.put.pub(obj);
        }
        return;
      } else if ( path.lastIndexOf('/') === 0 ) {
        if ( data.data == null ) {
          var obj = this.of.create();
          obj.id = path.substring(1)
          this.on.remove.pub(obj);
          return;
        }
        var obj = foam.json.parseString(data.data.data, this);
        if ( this.timestampProperty ) {
          this.timestampProperty.set(obj, data.data.lastUpdate);
        }
        this.on.put.pub(obj);
      } else if ( path.indexOf('/data') === path.length - 5 ) {
        // These last two events shouldn't happen unless somebody is editing
        // the underlying firebase data by hand.

        // Data of an existing row updated.
        debugger;
        var id = path.substring(1);
        id = id.substring(0, id.indexOf('/'));
        this.find(id).then(function(obj) {
          if ( ! obj ) throw com.firebase.ExpectedObjectNotFound.create();
          this.on.put.pub(obj);
        }.bind(this));

        // var obj = foam.json.parseString(data.data, this);
        // this.on.put.pub(obj);
      } else if ( path.indexOf('/lastUpdate') === path.length - 11 ) {
        // Timestamp of an existing row updated, do anything?
        // presumably if the object itself hasn't been updated we don't care
        // if it has been updated we should get an event for that.

        debugger;
        var id = path.substring(1);
        id = id.substring(0, id.indexOf('/'));
        this.find(id).then(function(obj) {
          if ( ! obj ) throw com.firebase.ExpectedObjectNotFound.create();
          this.on.put.pub(obj);
        }.bind(this));
      }
    },

    function onPatch(s, _, __, data) {
          // TODO: What does a patch even look like?
      debugger;
    }
  ]
});


foam.CLASS({
  package: 'com.firebase',
  name: 'SafariFirebaseDAO',
  extends: 'com.firebase.FirebaseDAO',

  requires: [
    'foam.net.web.XMLHTTPRequest as HTTPRequest',
    'foam.net.web.SafariEventSource as EventSource'
  ],

  properties: [
    [ 'enableStreaming', false ]
  ]
});


foam.CLASS({
  package: 'com.firebase',
  name: 'FirebaseEventSource',

  requires: [
    'foam.net.web.EventSource'
  ],

  topics: [
    'put',
    'patch',
    'keep-alive',
    'cancel',
    'auth_revoked'
  ],

  properties: [
    {
      name: 'uri',
      required: true
    },
    {
      name: 'eventSource',
      postSet: function(old, nu) {
        nu.message.sub(this.onMessage);
      },
      factory: function() {
        return this.EventSource.create({
          uri: this.uri
        });
      }
    },
    {
      class: 'String',
      name: 'buffer'
    }
  ],

  methods: [
    function start() {
      this.eventSource.start();
    }
  ],

  listeners: [
    function onMessage(s, msg, name, data) {
      switch (name) {
      case 'put':
        this.onPut(name, data);
        break;
      case 'patch':
        this.onPatch(name, data);
        break;
      case 'keep-alive':
        this.onKeepAlive(name, data);
        break;
      case 'cancel':
        this.onCancel(name, data);
        break;
      case 'auth_revoked':
        this.onAuthRevoked(name, data);
        break;
      default:
        this.onUnknown(name, data);
      }
    },

    function onPut(name, data) {
      this.put.pub(JSON.parse(data));
      return;

      // this.buffer += data;
      // try {
      //   var payload = JSON.parse(this.buffer);
      // } catch(e) {
      //   this.warn('Failed to parse payload, assuming its incomplete.', e, this.buffer.length);
      //   return;
      // }

      // this.buffer = '';
      // this.put.pub(payload);
    },

    function onPatch() {
      debugger;
    },

    function onKeepAlive() {
    },

    function onCancel() {
    },

    function onUnknown(name, data) {
      this.warn('Unknown firebase event', name, data);
    }
  ]
});
/**
 * @license
 * Copyright 2016 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// TODO: doc
foam.CLASS({
  package: 'com.firebase',
  name: 'CloudMessaging',

  requires: [
    'foam.net.node.HTTPRequest',
  ],

  properties: [
    {
      name: 'serverKey'
    }
  ],

  methods: [
    function send(id, payload, collapseKey) {
      return this.HTTPRequest.create({
        url: 'https://fcm.googleapis.com/fcm/send',
        method: 'POST',
        headers: {
          "content-type": "application/json",
          "Authorization": "key=" + this.serverKey
        },
        responseType: 'json',
        payload: JSON.stringify({
          to: id,
          data: payload
        })
      }).send().then(function(resp) {
        if ( ! resp.success ) {
          return resp.payload.then(function(p) { return Promise.reject(p); });
        }
      });
    }
  ]
});
/**
 * @license
 * Copyright 2017 The FOAM Authors. All Rights Reserved.
 * http://www.apache.org/licenses/LICENSE-2.0
 */

foam.CLASS({
  package: 'foam.core',
  name: 'StubMethod',
  extends: 'Method',

  properties: [
    'replyPolicyName',
    'boxPropName',
    {
      name: 'code',
      factory: function() {
        var returns         = foam.String.isInstance(this.returns) ?
            this.returns :
            this.returns && this.returns.typeName;
        var replyPolicyName = this.replyPolicyName;
        var boxPropName     = this.boxPropName;
        var name            = this.name;

        return function() {
          var returnBox = this.RPCReturnBox.create();
          var replyBox = this.ReplyBox.create({delegate: returnBox});

          var ret = returnBox.promise;

          // Automatically wrap RPCs that return a "PromisedAbc" or similar
          // TODO: Move this into RPCReturnBox ?
          if ( returns && returns !== 'Promise' ) {
            ret = this.lookup(returns).create({ delegate: ret });
          }

          var msg = this.Message.create({
            object: this.RPCMessage.create({
              name: name,
              args: Array.from(arguments)
            })
          });

          msg.attributes.replyBox = replyBox;

          this[boxPropName].send(msg);

          return ret;
        };
      }
    }
  ]
});


foam.CLASS({
  package: 'foam.core',
  name: 'StubAction',
  extends: 'Action',

  properties: [
    'replyPolicyName',
    'boxPropName',
    {
      name: 'stubMethod',
      factory: function() {
        return foam.core.StubMethod.create({
          name: this.name,
          replyPolicyName: this.replyPolicyName,
          boxPropName: this.boxPropName
        });
      }
    },
    {
      name: 'code',
      factory: function() {
        return function(ctx, action) {
          action.stubMethod.code.call(this);
        };
      }
    }
  ],
  methods: [
    function installInProto(proto) {
      proto[this.name] = this.stubMethod.code;
    }
  ]
});


foam.CLASS({
  package: 'foam.core',
  name: 'Stub',
  extends: 'Property',

  properties: [
    'of',
    {
      name: 'replyPolicyName',
      expression: function(name) {
        return name + 'ReplyPolicy'
      }
    },
    {
      class: 'StringArray',
      name: 'methods',
      factory: function() { return null; }
    },
    {
      name: 'methods_',
      expression: function(of, name, methods, replyPolicyName) {
        var cls = this.lookup(of);

        return (
          methods ?
            methods.map(function(m) { return cls.getAxiomByName(m); }) :
          cls.getAxiomsByClass(foam.core.Method).filter(function (m) { return cls.hasOwnAxiom(m.name); }) ).
          map(function(m) {
            var returns = foam.String.isInstance(m.returns) ? m.returns :
                m.returns && m.returns.typeName;
            if ( returns && returns !== 'Promise' ) {
              var id = returns.split('.');
              id[id.length - 1] = 'Promised' + id[id.length - 1];
              returns = id.join('.');
            }

            return foam.core.StubMethod.create({
              name: m.name,
              replyPolicyName: replyPolicyName,
              boxPropName: name,
              swiftReturns: m.swiftReturns,
              args: m.args,
              returns: returns
            });
          });
      }
    },
    {
      class: 'StringArray',
      name: 'notifications',
      factory: function() { return null; }
    },
    {
      name: 'notifications_',
      expression: function(of, name, notifications) {
        var cls = this.lookup(of);

        return notifications && notifications.
          map(function(m) { return cls.getAxiomByName(m); }).
          map(function(m) {
            return foam.core.StubNotification.create({
              name: m.name,
              boxPropName: name,
              args: m.args
            });
          });
      }
    },
    {
      class: 'StringArray',
      name: 'actions',
      factory: function() { return null; }
    },
    {
      name: 'actions_',
      expression: function(of, name, actions, replyPolicyName) {
        var cls = this.lookup(of);

        return (
          actions ? actions.map(function(a) { return cls.getAxiomByName(a); }) :
          cls.getAxiomsByClass(foam.core.Action).filter(function(m) { return cls.hasOwnAxiom(m.name); }) ).
          map(function(m) {
            return foam.core.StubAction.create({
              name: m.name,
              isEnabled: m.isEnabled,
              replyPolicyName: replyPolicyName,
              boxPropName: name
            });
          });
      }
    },
    ['javaType',     'foam.box.Box'],
    ['javaInfoType', 'foam.core.AbstractFObjectPropertyInfo']
  ],

  methods: [
    function installInClass(cls) {
      var model = this.lookup(this.of);
      var propName = this.name;

      cls.installAxiom(foam.core.Object.create({
        name: this.replyPolicyName,
        javaType: 'foam.box.BoxService',
        hidden: true
      }));

      cls.installAxioms(this.methods_);
      cls.installAxioms(this.notifications_);
      cls.installAxioms(this.actions_);

      cls.installAxioms([
        'foam.box.RPCReturnBox',
        'foam.box.ReplyBox',
        'foam.box.RPCMessage',
        'foam.box.Message'
      ].map(function(s) {
        var path = s.split('.');
        return foam.core.Requires.create({
          path: s,
          name: path[path.length - 1]
        });
      }));

      cls.installAxiom(foam.core.Import.create({
        key: 'registry',
        name: 'registry',
        javaType: 'foam.box.BoxRegistry',
      }));
    }
  ]
});


foam.CLASS({
  package: 'foam.core',
  name: 'StubClass',

  axioms: [
    foam.pattern.Multiton.create({ property: 'of' })
  ],

  requires: [
    'foam.core.Model',
  ],

  properties: [
    {
      class: 'Class',
      name: 'of',
      required: true
    },
    {
      class: 'String',
      name: 'package',
      factory: function() { return this.of.package; }
    },
    {
      class: 'String',
      name: 'name',
      factory: function() { return `${this.of.name}Stub`; }
    },
    {
      class: 'String',
      name: 'id',
      factory: function() { return `${this.package}.${this.name}`; }
    },
    {
      class: 'FObjectProperty',
      of: 'Model',
      name: 'stubModel',
      factory: function() {
        return this.Model.create({
          package: this.package,
          name: this.name,
          implements: [this.of.id],

          properties: [
            {
              class: 'Stub',
              of: this.of.id,
              name: 'delegate'
            }
          ]
        });
      }
    },
    {
      name: 'stubCls',
      factory: function() {
        return this.buildClass_();
      }
    }
  ],

  methods: [
    function init() {
      this.validate();
      this.SUPER();
    },
    function buildClass_() {
      this.stubModel.validate();
      var cls = this.stubModel.buildClass();
      cls.validate();
      this.__subContext__.register(cls);
      foam.package.registerClass(cls);

      return this.stubModel.buildClass();
    }
  ]
});

foam.CLASS({
  package: 'foam.core',
  name: 'StubNotification',
  documentation: "Similar to a StubMethod but doesn't register a reply box.  Useful when you don't care whether the method evaluates successfully on the target but just want to send a notification to the target.",
  extends: 'Method',

  properties: [
    'boxPropName',
    {
      name: 'code',
      factory: function() {
        var boxPropName = this.boxPropName;
        var name        = this.name;

        return function() {
          var msg = this.Message.create({
            object: this.RPCMessage.create({
              name: name,
              args: Array.from(arguments)
            })
          });

          this[boxPropName].send(msg);

          return;
        };
      }
    }
  ]
});

foam.CLASS({
  package: 'foam.core',
  name: 'StubFactory',

  requires: [ 'foam.core.StubClass' ],

  methods: [
    function get(cls) {
      return this.StubClass.create({ of: cls }).stubCls;
    }
  ]
});


foam.CLASS({
  package: 'foam.core',
  name: 'StubFactorySingleton',
  extends: 'foam.core.StubFactory',

  axioms: [ foam.pattern.Singleton.create() ],
});
/**
 * @license
 * Copyright 2017 The FOAM Authors. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

foam.INTERFACE({
  package: 'foam.box',
  name: 'Box',

  methods: [
    {
      name: 'send',
      args: [
        {
          name: 'msg',
          swiftType: 'Message'
        }
      ],
      swiftThrows: true,
    },
  ]
});
/**
 * @license
 * Copyright 2018 The FOAM Authors. All Rights Reserved.
 */

foam.CLASS({
  package: 'foam.box',
  name: 'AnonymousBox',
  implements: ['foam.box.Box'],
  properties: [
    {
      class: 'Function',
      name: 'f'
    }
  ],
  methods: [
    function send(m) {
      this.f(m);
    }
  ]
});
/**
 * @license
 * Copyright 2017 The FOAM Authors. All Rights Reserved.
 * http://www.apache.org/licenses/LICENSE-2.0
 */

foam.CLASS({
  package: 'foam.box',
  name: 'RemoteException',
  implements: ['foam.core.Exception'],
  properties: [
    {
      class: 'String',
      name: 'id'
    },
    {
      class: 'String',
      name: 'message'
    }
  ],

  methods: [
    {
      name: 'toString',
      javaReturns: 'String',
      javaCode: 'return getMessage();'
    }
  ]
});
/**
 * @license
 * Copyright 2017 The FOAM Authors. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

foam.INTERFACE({
  package: 'foam.box',
  name: 'Skeleton',
  extends: 'foam.box.Box',
  documentation: 'Skeleton marker interface.',

  methods: [
    {
      name: 'setDelegateObject',
      args: [
        {
          name: 'obj',
          javaType: 'Object'
        }
      ]
    }
  ]
});
/**
 * @license
 * Copyright 2017 The FOAM Authors. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

foam.CLASS({
  package: 'foam.box',
  name: 'PromisedBox',
  implements: [ 'foam.box.Box' ],

  properties: [
    {
      class: 'Promised',
      of: 'foam.box.Box',
      transient: true,
      name: 'delegate'
    }
  ]
});
/**
 * @license
 * Copyright 2017 The FOAM Authors. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

foam.CLASS({
  package: 'foam.box',
  name: 'ProxyBox',
  implements: [ 'foam.box.Box' ],

  properties: [
    {
      class: 'Proxy',
      of: 'foam.box.Box',
      name: 'delegate'
    }
  ]
});
/**
 * @license
 * Copyright 2017 The FOAM Authors. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

foam.CLASS({
  package: 'foam.box',
  name: 'Message',

  properties: [
    {
      class: 'Map',
      name: 'attributes',
      javaFactory: 'return new java.util.HashMap();'
    },
    {
      class: 'Object',
      name: 'object'
    },
    {
      class: 'Map',
      transient: true,
      name: 'localAttributes',
      javaFactory: 'return new java.util.HashMap();'
    }
  ],

  methods: [
    {
      name: 'replyWithException',
      javaReturns: 'void',
      args: [
        { name: 't', javaType: 'Throwable' }
      ],
      javaCode: `
        Box replyBox = (Box) getAttributes().get("replyBox");

        if ( replyBox == null ) return;

        RemoteException wrapper = new RemoteException();
        wrapper.setId(t.getClass().getName());
        wrapper.setMessage(t.getMessage());

        RPCErrorMessage reply = new RPCErrorMessage();
        reply.setData(wrapper);

        Message replyMessage = new Message();
        replyMessage.setObject(reply);

        replyBox.send(replyMessage);
      `
    }
  ]
});
/**
 * @license
 * Copyright 2017 The FOAM Authors. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

foam.CLASS({
  package: 'foam.box',
  name: 'SubBoxMessage',
  extends: 'foam.box.Message',
  properties: [
    {
      class: 'String',
      name: 'name'
    }
  ]
});
/**
 * @license
 * Copyright 2017 The FOAM Authors. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

foam.CLASS({
  package: 'foam.box',
  name: 'HelloMessage'
});
/**
 * @license
 * Copyright 2017 The FOAM Authors. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

foam.CLASS({
  package: 'foam.box',
  name: 'TimeoutException',
  implements: ['foam.core.Exception']
});

foam.CLASS({
  package: 'foam.box',
  name: 'TimeoutBox',
  //  implements: ['foam.box.Box'],
  extends: 'foam.box.ProxyBox',
  requires: [
    'foam.box.TimeoutException',
    'foam.box.Message'
  ],
  properties: [
    {
      class: 'Int',
      name: 'timeout',
      value: 5000
    }
  ],
  methods: [
    function send(msg) {
      var replyBox = msg.attributes.replyBox;

      if ( ! replyBox ) {
        this.delegate.send(msg);
        return;
      }

      var tooLate = false;
      var timer = setTimeout(function() {
        tooLate = true;
        replyBox.send(this.Message.create({
          object: this.TimeoutException.create()
        }));
      }.bind(this), this.timeout);

      var self = this;

      msg.attributes.replyBox = {
        send: function(msg) {
          if ( ! tooLate ) {
            clearTimeout(timer);
            replyBox.send(msg);
            return;
          }

          // TODO: Is it wise to increase the timeout?  Seems
          // reasonable, if our timeout value is too conservative and
          // the server is just slow we're better to wait longer
          // rather than hit it with additional requests while its
          // still processing our old ones.
          self.timeout *= 2;
        }
      };

      this.delegate.send(msg);
    }
  ]
});
/**
 * @license
 * Copyright 2017 The FOAM Authors. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

foam.CLASS({
  package: 'foam.box',
  name: 'BackoffBox',
  extends: 'foam.box.ProxyBox',
  imports: [
    'setTimeout'
  ],
  properties: [
    {
      class: 'Int',
      name: 'delay',
      preSet: function(_, a) {
        return a < this.maxDelay ? a : this.maxDelay;
      },
      value: 1
    },
    {
      class: 'Int',
      name: 'maxDelay',
      value: 20000
    }
  ],
  methods: [
    function send(m) {
      var self = this;
      this.setTimeout(function() {
        self.delegate.send(m);
      }, this.delay);

      this.delay *= 2;
    }
  ]
});

foam.CLASS({
  package: 'foam.box',
  name: 'RetryReplyBox',
  extends: 'foam.box.ProxyBox',
  requires: [
    'foam.core.Exception'
  ],
  properties: [
    {
      name: 'attempt',
      value: 0
    },
    {
      name: 'maxAttempts'
    },
    {
      name: 'message'
    },
    {
      name: 'destination'
    }
  ],
  methods: [
    {
      name: 'send',
      code: function send(msg) {
        if ( this.Exception.isInstance(msg.object) &&
             ( this.maxAttempts == -1 || this.attempt < this.maxAttempts ) ) {
          this.attempt++;
          this.destination.send(this.message);
          return;
        }

        this.delegate && this.delegate.send(msg);
      }
    }
  ]
});

foam.CLASS({
  package: 'foam.box',
  name: 'RetryBox',
  extends: 'foam.box.ProxyBox',

  requires: [
    'foam.box.BackoffBox',
    'foam.box.RetryReplyBox'
  ],

  properties: [
    'attempts',
    {
      name: 'maxAttempts',
      documentation: 'Set to -1 to infinitely retry.',
      value: 3
    }
  ],

  methods: [
    function send(msg) {
      var replyBox = msg.attributes.replyBox;

      if ( replyBox ) {
        var clone = msg.cls_.create(msg);

        msg.attributes.replyBox = this.RetryReplyBox.create({
          delegate: replyBox,
          maxAttempts: this.maxAttempts,
          message: clone,
          destination: this.BackoffBox.create({
            delegate: this.delegate
          })
        });

        clone.attributes = {};
        for ( var key in msg.attributes ) {
          clone.attributes[key] = msg.attributes[key];
        }
      }

      this.delegate.send(msg);
    }
  ]
});
/**
 * @license
 * Copyright 2017 The FOAM Authors. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

foam.CLASS({
  package: 'foam.box',
  name: 'SubBox',
  extends: 'foam.box.ProxyBox',

  requires: [
    'foam.box.SubBoxMessage'
  ],

  properties: [
    {
      class: 'String',
      name: 'name'
    }
  ],

  methods: [
    {
      name: 'send',
      code: function(msg) {
        msg.object = this.SubBoxMessage.create({
          name: this.name,
          object: msg.object
        });
        this.delegate.send(msg);
      },
      swiftCode: function() {/*
msg.object = SubBoxMessage_create([
  "name": name,
  "object": msg.object
])
try delegate.send(msg);
      */}
    }
  ]
});
/**
 * @license
 * Copyright 2017 The FOAM Authors. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

foam.CLASS({
  package: 'foam.box',
  name: 'NameAlreadyRegisteredException',

  properties: [
    {
      class: 'String',
      name: 'name'
    }
  ]
});
/**
 * @license
 * Copyright 2017 The FOAM Authors. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

foam.CLASS({
  package: 'foam.box',
  name: 'NoSuchNameException',
  implements: ['foam.core.Exception'],

  properties: [
    {
      class: 'String',
      name: 'name'
    },
    {
      class: 'String',
      name: 'message',
      transient: true,
      expression: function(name) {
        return 'Could not find registration for ' + name;
      },
      swiftExpressionArgs: ['name'],
      swiftExpression: 'return "Could not find registration for " + name',
    }
  ]
});
/**
 * @license
 * Copyright 2017 The FOAM Authors. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

foam.INTERFACE({
  package: 'foam.box',
  name: 'BoxRegistry',
  methods: [
    {
      name: 'doLookup',
      returns: 'foam.box.Box',
      javaReturns: 'foam.box.Box',
      swiftThrows: true,
      args: [
        {
          name: 'name',
          swiftType: 'String',
          javaType: 'String'
        }
      ]
    },
    {
      name: 'register',
      returns: 'foam.box.Box',
      javaReturns: 'foam.box.Box',
      args: [
        {
          name: 'name',
          swiftType: 'String?',
          javaType: 'String'
        },
        {
          name: 'service',
          swiftType: 'BoxService?',
          javaType: 'foam.box.BoxService'
        },
        {
          name: 'box',
          swiftType: 'Box',
          javaType: 'foam.box.Box'
        }
      ],
    },
    {
      name: 'unregister',
      returns: '',
      javaReturns: 'void',
      args: [
        {
          name: 'name',
          javaType: 'String'
        }
      ]
    }
  ]
});
/**
 * @license
 * Copyright 2017 The FOAM Authors. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

foam.CLASS({
  package: 'foam.box',
  name: 'LocalBoxRegistry',
  implements: [ 'foam.box.BoxRegistry' ],

  requires: [
    'foam.box.NoSuchNameException',
    'foam.box.SubBox'
  ],

  imports: [
    {
      name: 'me',
      key: 'me',
      javaType: 'foam.box.Box'
    }
  ],

  properties: [
    {
      class: 'Map',
      name: 'registry_',
      hidden: true,
      javaFactory: 'return new java.util.concurrent.ConcurrentHashMap();'
    }
  ],

  classes: [
    {
      name: 'Registration',
      properties: [
        {
          class: 'FObjectProperty',
          of: 'foam.box.Box',
          required: true,
          name: 'exportBox'
        },
        {
          class: 'FObjectProperty',
          of: 'foam.box.Box',
          required: true,
          name: 'localBox'
        }
      ]
    }
  ],

  methods: [
    {
      name: 'doLookup',
      code: function doLookup(name) {
        if ( this.registry_[name] &&
             this.registry_[name].exportBox )
          return this.registry_[name].exportBox;

        throw this.NoSuchNameException.create({ name: name });
      },
      swiftCode: function() {/*
if let exportBox = (registry_[name] as? Registration)?.exportBox {
  return exportBox
}
throw NoSuchNameException_create(["name": name])
      */},
      javaCode: `
Object registration = getRegistry_().get(name);
if ( registration == null ) {
  throw new RuntimeException("No such name");
}
return ((Registration)registration).getExportBox();
`
    },
    {
      name: 'register',
      code: function(name, service, localBox) {
        name = name || foam.next$UID();

        var exportBox = this.SubBox.create({ name: name, delegate: this.me });
        exportBox = service ? service.clientBox(exportBox) : exportBox;

        this.registry_[name] = {
          exportBox: exportBox,
          localBox: service ? service.serverBox(localBox) : localBox
        };

        return this.registry_[name].exportBox;
      },
      swiftSynchronized: true,
      swiftCode: function() {/*
let name: String = name ?? UUID().uuidString

var exportBox: Box = SubBox_create([
  "name": name,
  "delegate": me
])
exportBox = service?.clientBox(exportBox) ?? exportBox

let registration = Registration_create([
  "exportBox": exportBox,
  "localBox": service?.serverBox(box) ?? box
])
registry_[name] = registration
return registration.exportBox
      */},
      javaCode: `
if ( name == null ) name = Integer.toString(foam.box.IdGenerator.nextId());

foam.box.SubBox exportBox = getX().create(foam.box.SubBox.class);
exportBox.setName(name);
exportBox.setDelegate(getMe());
Registration registration = new Registration();
registration.setX(getX());
registration.setExportBox(exportBox);
registration.setLocalBox(box);
// TODO(adamvy): Apply service policy

getRegistry_().put(name, registration);
return exportBox;
`
    },
    {
      name: 'unregister',
      code: function(name) {
        if ( foam.box.Box.isInstance(name) ) {
          for ( var key in this.registry_ ) {
            // TODO(markdittmer): Should there be a specialized compare() should
            // be implemented by NamedBox (to cut out delegate) and
            // foam.util.compare()?
            if ( this.registry_[key].exportBox === name ) {
              delete this.registry_[key];
              return;
            }
          }
          return;
        }

        delete this.registry_[name];
      },
      swiftSynchronized: true,
      swiftCode: function() {/*
if let name = name as? String {
  registry_.removeValue(forKey: name)
} else if let name = name as? AnyClass {
  for key in registry_.keys {
    if ((registry_[key] as! Registration).exportBox as? AnyClass) === name {
      registry_.removeValue(forKey: key)
      return
    }
  }
}
      */},
      javaCode: `
getRegistry_().remove(name);
`
    }
  ]
});
/**
 * @license
 * Copyright 2017 The FOAM Authors. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

foam.CLASS({
  package: 'foam.box',
  name: 'BoxRegistryBox',
  extends: 'foam.box.LocalBoxRegistry',

  implements: [ 'foam.box.Box' ],

  requires: [
    'foam.box.SubBoxMessage',
    'foam.box.Message',
    'foam.box.HelloMessage',
    'foam.box.SkeletonBox'
  ],

  properties: [
    {
      class: 'FObjectProperty',
      of: 'foam.box.Box',
      name: 'registrySkeleton',
      factory: function() {
        return this.SkeletonBox.create({ data: this });
      },
      // TODO check if this leaks.
      swiftFactory: 'return SkeletonBox_create(["data": self])',
      swiftPostSet: function() {/*
if let oldValue = oldValue as? SkeletonBox {
  oldValue.clearProperty("data")
}
      */},
    }
  ],

  methods: [
    {
      name: 'init',
      swiftCode: function() {/*
self.onDetach(Subscription(detach: {
  if self.hasOwnProperty("registrySkeleton") {
    (self.registrySkeleton as? FObject)?.clearProperty("data")
  }
}))
      */},
      code: function() { this.SUPER() },
    },
    {
      name: 'send',
      swiftCode: function() {/*
if let object = msg.object as? SubBoxMessage {
  let name = object.name

  if let reg = registry_[name] as? Registration {
    msg.object = object.object;
    try reg.localBox.send(msg);
  } else {
    if let errorBox = msg.attributes["errorBox"] as? Box {
      try errorBox.send(
        Message_create([
          "object": NoSuchNameException_create(["name": name ])
        ]))
    }
  }
} else if let _ = msg.object as? HelloMessage {
} else {
  try registrySkeleton!.send(msg)
}
      */},
      code: function(msg) {
        if ( this.SubBoxMessage.isInstance(msg.object) ) {
          var name = msg.object.name;

          if ( this.registry_[name] && this.registry_[name].localBox ) {
            // Unpack sub box object... is this right?
            msg.object = msg.object.object;
            this.registry_[name].localBox.send(msg);
          } else {
            if ( msg.attributes.replyBox ) {
              msg.attributes.replyBox.send(
                this.Message.create({
                  object: this.NoSuchNameException.create({ name: name })
                }));
            }
          }
        } else if ( this.HelloMessage.isInstance(msg.object) ) {
        } else {
          this.registrySkeleton.send(msg);
        }
      },
      javaCode: `
Object obj = message.getObject();

if ( obj instanceof foam.box.SubBoxMessage ) {
  foam.box.SubBoxMessage sbm = (foam.box.SubBoxMessage)obj;
  String name = sbm.getName();

  Registration dest = (Registration)getRegistry_().get(name);

  if ( dest != null ) {
    message.setObject(sbm.getObject());
    dest.getLocalBox().send(message);
  } else if ( message.getAttributes().containsKey("replyBox") ) {
    foam.box.Box replyBox = (foam.box.Box)message.getAttributes().get("replyBox");
    foam.box.Message errorMessage = getX().create(foam.box.Message.class);
    errorMessage.setObject(getX().create(foam.box.NoSuchNameException.class));

    replyBox.send(errorMessage);
  }
}
`
    }
  ]
});
/**
 * @license
 * Copyright 2017 The FOAM Authors. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// TODO: Use ContextFactories to create these on demand.
foam.CLASS({
  package: 'foam.box',
  name: 'ClientBoxRegistry',
  implements: ['foam.box.BoxRegistry'],
  properties: [
    {
      class: 'Stub',
      of: 'foam.box.BoxRegistry',
      name: 'delegate'
    }
  ]
});
/**
 * @license
 * Copyright 2017 The FOAM Authors. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

foam.CLASS({
  package: 'foam.box',
  name: 'PromisedBoxRegistry',

  properties: [
    {
      class: 'Promised',
      of: 'foam.box.BoxRegistry',
      name: 'delegate'
    }
  ]
});
/**
 * @license
 * Copyright 2017 The FOAM Authors. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

foam.INTERFACE({
  package: 'foam.box',
  name: 'RegistrySelector',

  documentation: `A function that selects a registry where a service should be
      registered, based on the requested name, service policy, box, and any
      state internal to the selector. RegistrySelectors are used by
      SelectorRegistries to route registration requests.

      NOTE: SelectorRegistry's delegation strategy expects registries returned
      by from RegistrySelectors to reside in a different foam.box.Context (with
      a different foam.box.Context.myname) than the SelectorRegistry.`,

  methods: [
    function select(name, service, box) {}
  ]
});
/**
 * @license
 * Copyright 2017 The FOAM Authors. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

foam.CLASS({
  package: 'foam.box',
  name: 'SelectorRegistry',
  extends: 'foam.box.BoxRegistryBox',

  documentation: `A registry that routes registration requests to other
      registries according to its "selector".

      NOTE: SelectorRegistry's delegation strategy expects registries returned
      by "selector" to reside in a different foam.box.Context (with a different
      foam.box.Context.myname) than the SelectorRegistry.`,

  requires: [ 'foam.box.Box' ],
  exports: [ 'as registry' ],

  classes: [
    {
      name: 'Registration',

      documentation: `Mapping between a delegate registry and a box returned
          from registering with the delegate.`,

      properties: [
        {
          class: 'String',
          name: 'name',
          documentation: `Name under which registration was stored in
              SelectorRegistry.`
        },
        {
          class: 'FObjectProperty',
          of: 'foam.box.BoxRegistry',
          name: 'delegateRegistry',
          documentation: `The registry that SelectorRegistry delegated to for
              managed registration.`
        },
        {
          class: 'String',
          name: 'delegateRegisteredName',
          documentation: `Name under which registration was stored in
              "delegateRegistry".`
        },
        {
          class: 'FObjectProperty',
          of: 'foam.box.Box',
          name: 'delegateRegisteredBox',
          documentation: `Box returned from register() on "delegateRegistry".`
        }
      ]
    }
  ],

  properties: [
    {
      class: 'FObjectProperty',
      of: 'foam.box.RegistrySelector',
      name: 'selector',
      documentation: `A (potentially stateful) function that selects a delegate
          registry on a per-registration-request basis.`,
      required: true
    },
    {
      class: 'Array',
      // of: 'Registration',
      name: 'selectorRegistrations_',
      documentation: `Array of bindings:
          <selector-chosen-delegate, box-returned-from-register-in-delegate>.`
    }
  ],

  methods: [
    function register(name, service, box) {
      name = name || foam.next$UID();

      var delegate = this.selector.select(name, service, box);

      var delegateRegisteredName = foam.uuid.randomGUID();
      var delegateRegisteredBox = delegate.register(
          delegateRegisteredName, null, box);

      // Create relay to desired service name, but return box from delegate.
      // This creates a consistent namespace for clients of this registry while
      // also returning NamedBoxes that resolve to delegate Context names.
      this.SUPER(name, service, delegateRegisteredBox);

      this.selectorRegistrations_.push(this.Registration.create({
        name: name,
        delegateRegistry: delegate,
        delegateRegisteredName: delegateRegisteredName,
        delegateRegisteredBox: delegateRegisteredBox
      }));

      return delegateRegisteredBox;
    },
    function unregister(nameOrBox) {
      var delegateRegisteredBox;
      var inputIsBox = this.Box.isInstance(nameOrBox);
      if ( inputIsBox ) {
        delegateRegisteredBox = nameOrBox;
      } else {
        delegateRegisteredBox = this.registry_[nameOrBox].localBox;

        // When name is known, delete from this registry immediately.
        this.SUPER(nameOrBox);
      }

      var registrations = this.selectorRegistrations_;
      var delegateRegistry = null;
      var delegateRegisteredName = '';
      for ( var i = 0; i < registrations.length; i++ ) {
        if ( registrations[i].delegateRegisteredBox !== delegateRegisteredBox )
          continue;

        delegateRegistry = registrations[i].delegateRegistry;
        delegateRegisteredName = registrations[i].delegateRegisteredName;

        // When name was not previously known, delete from this registry after
        // finding associated Registration.
        if ( inputIsBox ) delete this.registry_[registrations[i].name];
        break;
      }

      foam.assert(delegateRegistry,
                  'SelectorRegistry: Expected to find delegate registry');

      delegateRegistry.unregister(delegateRegisteredName);
    }
  ]
});
/**
 * @license
 * Copyright 2017 The FOAM Authors. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

foam.CLASS({
  package: 'foam.box',
  name: 'BroadcastRegistry',
  extends: 'foam.box.BoxRegistryBox',

  requires: [
    'foam.box.Box',
    'foam.box.RoundRobinBox'
  ],
  exports: [ 'as registry' ],

  classes: [
    {
      name: 'Registration',

      documentation: `Mapping between registered names and boxes returned
          from registering with the delegates.`,

      properties: [
        {
          class: 'String',
          name: 'name',
          documentation: `Name under which registration was stored in
              BroadcastRegistry.`
        },
        {
          class: 'Array',
          of: 'String',
          name: 'delegateNames',
          documentation: `Name under which registration delegate services
              are registered.`
        },
        {
          class: 'FObjectProperty',
          of: 'foam.box.Box',
          name: 'registeredBox',
          documentation: `Box returned from BroadcastRegistry.register() SUPER()
              implementation.`
        }
      ]
    }
  ],

  properties: [
    {
      class: 'Array',
      of: 'foam.box.BoxRegistryBox',
      name: 'delegates',
      documentation: 'Delegates that recieve register()/unregister() calls.',
    },
    {
      class: 'FObjectProperty',
      of: 'foam.box.MultiDelegateBox',
      name: 'dispatchBoxPrototype',
      documentation: `Prototype that is clone()d to produce a box that
          encapsulates dispatch to services registered in "delegates".`,
      factory: function() { return this.RoundRobinBox.create(); }
    },
    {
      class: 'Array',
      // of: 'Registration',
      name: 'registrations_',
      documentation: `Array of Registration bindings used to coordinate
          unregister() among self and delegates.`
    }
  ],

  methods: [
    function register(name, service, box) {
      var delegates = this.delegates;
      var dispatchDelegates = new Array(delegates.length);
      var dispatchDelegateNames = new Array(delegates.length);
      for ( var i = 0; i < delegates.length; i++ ) {
        var delegateName = dispatchDelegateNames[i] = foam.uuid.randomGUID();
        dispatchDelegates[i] = delegates[i].register(delegateName, null, box);
      }
      var dispatchBox = this.dispatchBoxPrototype.clone(this);
      dispatchBox.delegates = dispatchDelegates;

      var ret = this.SUPER(name, service, dispatchBox);
      this.registrations_.push(this.Registration.create({
        name: name,
        delegateNames: dispatchDelegateNames,
        registeredBox: ret
      }));

      return ret;
    },
    function unregister(nameOrBox) {
      var registeredBox;
      var inputIsBox = this.Box.isInstance(nameOrBox);
      if ( inputIsBox ) {
        registeredBox = nameOrBox;
      } else {
        registeredBox = this.registry_[nameOrBox].exportBox;
        // When name is known, unregister it.
        this.SUPER(nameOrBox);
      }

      var registration;
      var registrations = this.registrations_;
      for ( var i = 0; i < registrations.length; i++ ) {
        if ( registrations[i].registeredBox !== registeredBox )
          continue;

        // When name was previously unknown, remove from registry_ now that
        // it is known.
        if ( inputIsBox ) delete this.registry_[registrations[i].name];

        registration = registrations[i];
        break;
      }

      foam.assert(registration,
                  'BroadcastRegistry expects to find registration');

      var delegates = this.delegates;
      for ( var i = 0; i < delegates.length; i++ ) {
        delegates[i].unregister(registration.delegateNames[i]);
      }
    }
  ]
});
/**
 * @license
 * Copyright 2017 The FOAM Authors. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

foam.CLASS({
  package: 'foam.box',
  name: 'LookupBox',
  extends: 'foam.box.ProxyBox',

  requires: [
    'foam.box.ClientBoxRegistry',
    'foam.box.AnonymousBox'
  ],

  properties: [
    {
      class: 'String',
      name: 'name'
    },
    {
      name: 'parentBox'
    },
    {
      class: 'FObjectProperty',
      of: 'foam.box.BoxRegistry',
      name: 'registry',
      transient: true,
      factory: function() {
        return this.ClientBoxRegistry.create({
          delegate: this.parentBox
        });
      },
      swiftFactory: function() {/*
return ClientBoxRegistry_create([
  "delegate": parentBox
])
      */}
    },
    {
      name: 'delegate',
      transient: true,
      factory: function() {
        return this.registry.doLookup(this.name);
      },
      swiftFactory: 'return try! registry!.doLookup(name)',
    }
  ],
  methods: [
    function send(msg) {
      var self = this;
      var replyBox = msg.attributes.replyBox;

      msg.attributes.replyBox = this.AnonymousBox.create({
        f: function(m) {
          if ( foam.core.Exception.isInstance(m.object) ) {
            self.delegate = undefined;
          }
          replyBox && replyBox.send(m);
        }
      });

      this.delegate.send(msg);
    }
  ]
});
/**
 * @license
 * Copyright 2017 The FOAM Authors. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

foam.CLASS({
  package: 'foam.box',
  name: 'NamedBox',
  extends: 'foam.box.ProxyBox',

  requires: [
    'foam.box.LookupBox',
  ],

  axioms: [
    foam.pattern.Multiton.create({ property: 'name' })
  ],

  properties: [
    {
      class: 'String',
      name: 'name'
    },
    {
      name: 'delegate',
      transient: true,
      factory: function() {
        // RetryBox(LookupBox(name, NamedBox(subName)))
        // TODO Add retry box
        return this.LookupBox.create({
          name: this.getBaseName(),
          parentBox: this.getParentBox()
        });
      },
      swiftFactory: function() {/*
return self.LookupBox_create([
  "name": self.getBaseName(),
  "parentBox": self.getParentBox()
])
      */}
    }
  ],

  methods: [
    {
      name: 'getParentBox',
      returns: 'foam.box.Box',
      code: function() {
        return this.cls_.create({
          name: this.name.substring(0, this.name.lastIndexOf('/'))
        }, this);
      },
      swiftCode: function() {/*
var name = ""
if let index = self.name.range(of: "/", options: .backwards)?.lowerBound {
  name = String(self.name[..<index])
}
return ownClassInfo().create(args: [
  "name": name
], x: __subContext__) as! Box
      */},
    },
    {
      name: 'getBaseName',
      returns: 'String',
      code: function getBaseName() {
        return this.name.substring(this.name.lastIndexOf('/') + 1);
      },
      swiftCode: function getBaseName() {/*
if let index = name.range(of: "/", options: .backwards)?.lowerBound {
  return String(name[name.index(after: index)..<name.endIndex])
}
return ""
      */},
    },
  ]
});
/**
 * @license
 * Copyright 2017 The FOAM Authors. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

foam.CLASS({
  package: 'foam.box',
  name: 'ReplyBox',
  extends: 'foam.box.ProxyBox',

  imports: [
    {
      name: 'registry',
      key: 'registry',
      javaType: 'foam.box.BoxRegistry'
    }
  ],

  properties: [
    {
      class: 'String',
      name: 'id',
      factory: function() {
        // TODO: Do these need to be long lived?
        // Someone could store a box for days and then use it
        // at that point the ID might no longer be valid.
        return foam.next$UID();
      },
      swiftFactory: 'return UUID().uuidString',
    },
    {
      name: 'delegate',
      transient: true
    }
  ],

  methods: [
    {
      name: 'send',
      code: function send(msg) {
        this.registry.unregister(this.id);
        this.delegate.send(msg);
      },
      swiftCode: function() {/*
(registry as! BoxRegistry).unregister(id)
try delegate.send(msg)
      */},
      javaCode: `
getRegistry().unregister(getId());
getDelegate().send(message);
`
    }
  ]
});
/**
 * @license
 * Copyright 2017 The FOAM Authors. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

foam.CLASS({
  package: 'foam.box',
  name: 'FunctionBox',
  implements: ['foam.box.Box'],
  properties: [
    {
      class: 'Function',
      swiftType: '((Any?) -> ())',
      swiftRequiresEscaping: true,
      name: 'fn'
    }
  ],
  methods: [
    {
      name: 'send',
      code: function send(m) {
        this.fn(m.object);
      },
      swiftCode: 'fn(msg.object)',
    },
  ]
});
/**
 * @license
 * Copyright 2017 The FOAM Authors. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

foam.CLASS({
  package: 'foam.box',
  name: 'RPCReturnMessage',
  extends: 'foam.box.Message',
  properties: [
    {
      class: 'Object',
      name: 'data'
    }
  ]
});
/**
 * @license
 * Copyright 2017 The FOAM Authors. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

foam.CLASS({
  package: 'foam.box',
  name: 'RPCErrorMessage',
  implements: ['foam.core.Exception'],
  properties: [
    {
      class: 'Object',
      name: 'data'
    }
  ]
});
/**
 * @license
 * Copyright 2017 The FOAM Authors. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

foam.CLASS({
  package: 'foam.box',
  name: 'SubscribeMessage',
  properties: [
    {
      name: 'topic'
    },
    {
      name: 'destination'
    }
  ]
});
/**
 * @license
 * Copyright 2017 The FOAM Authors. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

foam.CLASS({
  package: 'foam.box',
  name: 'RPCReturnBox',

  implements: [ 'foam.box.Box' ],

  requires: [
    'foam.box.RPCReturnMessage',
    'foam.box.RPCErrorMessage'
  ],

  properties: [
    {
      name: 'promise',
      factory: function() {
        return new Promise(function(resolve, reject) {
          this.resolve_ = resolve;
          this.reject_ = reject;
        }.bind(this));
      }
    },
    {
      name: 'resolve_'
    },
    {
      name: 'reject_'
    },
    {
      class: 'Object',
      name: 'semaphore',
      javaType: 'java.util.concurrent.Semaphore',
      javaFactory: 'return new java.util.concurrent.Semaphore(0);'
    },
    {
      class: 'Object',
      name: 'message',
      javaType: 'foam.box.Message'
    }
  ],

  methods: [
    {
      name: 'send',
      code: function send(msg) {
        if ( this.RPCReturnMessage.isInstance(msg.object) ) {
          this.resolve_(msg.object.data);
          return;
        }
        if ( this.RPCErrorMessage.isInstance(msg.object) ) {
          this.reject_(msg.object.data);
          return;
        }
        if ( foam.core.Exception.isInstance(msg.object) ) {
          this.reject_(msg.object);
          return;
        }
        if ( msg.object instanceof Error ) {
          this.reject_(msg.object);
          return;
        }

        this.warn('Invalid message to RPCReturnBox.');
      },
      javaCode: `
setMessage(message);
getSemaphore().release();
`
    }
  ]
});
/**
 * @license
 * Copyright 2017 The FOAM Authors. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

foam.CLASS({
  package: 'foam.box',
  name: 'RPCMessage',
  extends: 'foam.box.Message',
  properties: [
    {
      class: 'String',
      name: 'name'
    },
    {
      class: 'Array',
      name: 'args'
    }
  ]
});
/**
 * @license
 * Copyright 2017 The FOAM Authors. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

foam.CLASS({
  package: 'foam.dao',
  name: 'BaseClientDAO',
  extends: 'foam.dao.AbstractDAO',

  properties: [
    {
      class: 'Stub',
      of: 'foam.dao.DAO',
      name: 'delegate',
      methods: [
        'put_',
        'remove_',
        'removeAll_',
        'select_',
        'listen_',
        'find_'
      ]
    }
  ]
});
/**
 * @license
 * Copyright 2017 The FOAM Authors. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

foam.CLASS({
  package: 'foam.dao',
  name: 'MergeBox',
  extends: 'foam.box.ProxyBox',
  properties: [
    {
      class: 'Int',
      name: 'delay',
      value: 100
    },
    {
      name: 'msg',
      transient: true
    },
    {
      class: 'Array',
      name: 'queue',
      transient: true
    }
  ],
  methods: [
    function send(m) {
      if ( ! this.timeout ) {
      }
    }
  ],
  listeners: [
    function doSend() {
      var queue = this.queue;
      this.queue = undefined;
      this.timeout = undefined;
    }
  ]
});
/**
 * @license
 * Copyright 2017 The FOAM Authors. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

foam.CLASS({
  package: 'foam.dao',
  name: 'ResetSink',
  extends: 'foam.dao.ProxySink',
  methods: [
    {
      name: 'put',
      code: function(obj, sub) { this.reset(sub); },
      javaCode: 'reset(sub);'
    },
    {
      name: 'remove',
      code: function(obj, sub) { this.reset(sub); },
      javaCode: 'reset(sub);'
    }
  ]
});

foam.CLASS({
  package: 'foam.dao',
  name: 'MergedResetSink',
  extends: 'foam.dao.ResetSink',
  methods: [
    {
      name: 'reset',
      code: function(sub) { this.doReset(sub); },
      javaCode: `doReset(sub);`
    }
  ],
  listeners: [
    {
      name: 'doReset',
      isMerged: true,
      mergeDelay: 200,
      code: function(sub) {
        this.delegate.reset(sub);
      },
      javaCode: `
try {
  getDelegate().reset(sub);
} catch(Exception e) {
  sub.detach();
}
`
    }
  ]
});

foam.CLASS({
  package: 'foam.dao',
  name: 'ClientDAO',
  extends: 'foam.dao.BaseClientDAO',

  requires: [
    'foam.box.SkeletonBox',
    'foam.core.Serializable',
    'foam.dao.ArraySink',
    'foam.dao.ClientSink',
  ],

  methods: [
    {
      name: 'put_',
      code:     function put_(x, obj) {
        return this.SUPER(null, obj);
      },
      javaCode: `
return super.put_(null, obj);
`,
      swiftCode: 'return try super.put_(nil, obj)',
    },
    {
      name: 'remove_',
      code: function remove_(x, obj) {
        return this.SUPER(null, obj);
      },
      javaCode: `
return super.remove_(null, obj);
`,
      swiftCode: 'return try super.remove_(nil, obj)',
    },
    {
      name: 'find_',
      code:     function find_(x, key) {
        return this.SUPER(null, key);
      },
      javaCode: `
return super.find_(null, id);
`,
      swiftCode: 'return try super.find_(nil, id)',
    },
    {
      name: 'select_',
      code: function select_(x, sink, skip, limit, order, predicate) {
        if ( predicate === foam.mlang.predicate.True.create() ) predicate = null;
        if ( ! skip ) skip = 0;
        if ( foam.Undefined.isInstance(limit) ) limit = Number.MAX_SAFE_INTEGER;

        if ( ! this.Serializable.isInstance(sink) ) {
          var self = this;

          return this.SUPER(null, foam.dao.ArraySink.create(), skip, limit, order, predicate).then(function(result) {
            var items = result.array;

            if ( ! sink ) return result;

            var sub = foam.core.FObject.create();
            var detached = false;
            sub.onDetach(function() { detached = true; });

            for ( var i = 0 ; i < items.length ; i++ ) {
              if ( detached ) break;

              sink.put(items[i], sub);
            }

            sink.eof();

            return sink;
          });
        }

        return this.SUPER(null, sink, skip, limit, order, predicate);
      },
      javaCode: `
return super.select_(null, sink, skip, limit, order, predicate);
`,
      swiftCode: `
if sink is Serializable {
  return try super.select_(nil, sink, skip, limit, order, predicate)
}
let result = try super.select_(nil, ArraySink_create(), skip, limit, order, predicate) as! ArraySink
var detached = false
let sub = Subscription { detached = true }
for o in result.array {
  if detached { break }
  sink.put(o, sub)
}
sink.eof()
return sink
`,
    },

    {
      name: 'removeAll_',
      code: function removeAll_(x, skip, limit, order, predicate) {
        if ( predicate === foam.mlang.predicate.True.create() ) predicate = null;
        if ( ! skip ) skip = 0;
        if ( foam.Undefined.isInstance(limit) ) limit = Number.MAX_SAFE_INTEGER;

        return this.SUPER(null, skip, limit, order, predicate);
      },
      javaCode: `
super.removeAll_(null, skip, limit, order, predicate);
`,
      swiftCode: 'try super.removeAll_(nil, skip, limit, order, predicate)',
    },

    {
      name: 'listen_',
      code: function listen_(x, sink, predicate) {
        this.SUPER(null, sink, predicate);
        return foam.core.FObject.create();
      },
      javaCode: `super.listen_(null, sink, predicate);`,
      swiftCode: `return try super.listen_(nil, sink, predicate)`,
    }
  ]
});
/**
 * @license
 * Copyright 2017 The FOAM Authors. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

foam.CLASS({
  package: 'foam.dao',
  name: 'EventlessClientDAO',
  extends: 'foam.dao.AbstractDAO',

  properties: [
    {
      class: 'Stub',
      of: 'foam.dao.DAO',
      name: 'delegate',
      methods: [
        'put_',
        'remove_',
        'select_',
        'removeAll_',
        'find_'
      ],
      eventProxy: false
    }
  ]
});
/**
 * @license
 * Copyright 2017 The FOAM Authors. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

foam.CLASS({
  package: 'foam.dao',
  name: 'PollingClientDAO',
  extends: 'foam.dao.ClientDAO',

  requires: [
    'foam.dao.ArraySink'
  ],

  methods: [
    function put_(x, obj) {
      var self = this;
      return this.SUPER(x, obj).then(function(o) {
        self.on.put.pub(o);
        return o;
      });
    },

    function remove_(x, obj) {
      var self = this;
      return this.SUPER(x, obj).then(function(o) {
        self.on.remove.pub(obj);
        return o;
      });
    },

    function removeAll_(x, skip, limit, order, predicate) {
      this.SUPER(x, skip, limit, order, predicate);
      this.on.reset.pub();
    }
  ]
});
/**
 * @license
 * Copyright 2017 The FOAM Authors. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

foam.CLASS({
  package: 'foam.dao',
  name: 'StreamingClientDAO',
  extends: 'foam.dao.BaseClientDAO',

  requires: [
    'foam.dao.ArraySink',
    'foam.dao.BoxDAOListener'
  ],
  imports: [ 'registry' ],

  classes: [
    {
      name: 'StreamingReplyBox',
      implements: [ 'foam.box.Box' ],

      imports: [ 'registry' ],

      properties: [
        {
          name: 'id',
          factory: function() { return foam.next$UID(); }
        },
        {
          class: 'FObjectProperty',
          of: 'foam.dao.Sink',
          name: 'sink'
        },
        {
          class: 'Boolean',
          name: 'detachOnEOF'
        },
        {
          name: 'promise',
          factory: function() {
            var self = this;
            return new Promise(function(resolve, reject) {
              self.resolve_ = resolve;
              self.reject_ = reject;
            });
          }
        },
        {
          name: 'sinkSub',
          factory: function() {
            var sub = foam.core.FObject.create();
            // TODO(markdittmer): Notify remote DAO of detachment.
            sub.onDetach(this.unregisterSelf);
            return sub;
          }
        },
        'resolve_',
        'reject_'
      ],

      methods: [
        function send(msg) {
          // TODO(markdittmer): Error check message type.

          switch ( msg.object.name ) {
            case 'put':
              this.sink.put(msg.object.obj, this.sinkSub);
              break;
            case 'remove':
              this.sink.remove(msg.object.obj, this.sinkSub);
              break;
            case 'eof':
              this.sink.eof();
              this.resolve_(this.sink);
              if ( this.detachOnEOF ) this.sinkSub.detach();
              break;
            case 'reset':
              this.sink.reset();
              break;
          }
        }
      ],

      listeners: [
        function registerSelf() {
          return this.exportBox_ = this.registry.register(this.id, null, this);
        },
        function unregisterSelf() { this.registry.unregister(this.id); }
      ]
    }
  ],

  methods: [
    function put_(x, obj) { return this.SUPER(null, obj); },
    function remove_(x, obj) { return this.SUPER(null, obj); },
    function find_(x, key) { return this.SUPER(null, key); },
    function select_(x, sink, skip, limit, order, predicate) {
      var replyBox = this.StreamingReplyBox.create({
        sink: sink || this.ArraySink.create(),
        detachOnEOF: true
      });
      var promise = replyBox.promise;

      var registeredReplyBox = replyBox.registerSelf();

      // TODO(markdittmer): Shouldn't there be an annotation for an errorBox
      // somewhere here?
      this.SUPER(
          null, this.BoxDAOListener.create({ box: registeredReplyBox }),
          skip, limit, order, predicate)
              .catch(function(error) { replyBox.reject_(error); });
      return promise;
    },
    function listen_(x, sink, predicate) {
      var replyBox = this.StreamingReplyBox.create({
        sink: sink || this.ArraySink.create()
      });

      // TODO(markdittmer): Shouldn't there be an annotation for an errorBox
      // somewhere here?
      this.SUPER(null, this.BoxDAOListener.create({
        box: replyBox.registerSelf()
      }), predicate);

      return replyBox.sinkSub;
    }
  ]
});
/**
 * @license
 * Copyright 2017 The FOAM Authors. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

foam.CLASS({
  package: 'foam.dao',
  name: 'RequestResponseClientDAO',
  extends: 'foam.dao.BaseClientDAO',

  requires: [
    'foam.core.Serializable'
  ],

  documentation: function() {/*A ClientDAO implementation which publishes its own events upon put/remove.
Suitable for usage against backends that don't support listen(), such as plain HTTP based servers.*/},

  methods: [
    function put_(x, obj) {
      var self = this;
      return this.SUPER(null, obj).then(function(obj) {
        self.on.put.pub(obj);
        return obj;
      });
    },

    function remove_(x, obj) {
      var self = this;
      return this.SUPER(null, obj).then(function(o) {
        self.on.remove.pub(obj);
        return o;
      });
    },

    function find_(x, key) {
      return this.SUPER(null, key);
    },

    function select_(x, sink, skip, limit, order, predicate) {
      if ( predicate === foam.mlang.predicate.True.create() ) predicate = null;
      if ( ! skip ) skip = 0;
      if ( ! limit ) limit = Number.MAX_SAFE_INTEGER;

      if ( ! this.Serializable.isInstance(sink) ) {
        var self = this;

        return this.SUPER(null, foam.dao.ArraySink.create(), skip, limit, order, predicate).then(function(result) {
          var items = result.array;

          if ( ! sink ) return result;

          var sub = foam.core.FObject.create();
          var detached = false;
          sub.onDetach(function() { detached = true; });

          for ( var i = 0 ; i < items.length ; i++ ) {
            if ( detached ) break;

            sink.put(items[i], sub);
          }

          sink.eof();

          return sink;
        });
      }

      return this.SUPER(null, sink, skip, limit, order, predicate);
    },

    function removeAll_(x, skip, limit, order, predicate) {
      var self = this;
      return this.SUPER(null, skip, limit, order, predicate).then(function() {
        self.on.reset.pub();
        return;
      });
    },

    function listen_(x, sink, predicate) {
      return this.__context__.lookup('foam.dao.AbstractDAO').
        prototype.listen_.call(this, x, sink, predicate);
    }
  ]
});
/**
 * @license
 * Copyright 2017 The FOAM Authors. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

foam.CLASS({
  package :'foam.box',
  name: 'InvalidMessageException',
  swiftImplements: ['Error'],

  properties: [
    'messageType'
  ]
});
/**
 * @license
 * Copyright 2017 The FOAM Authors. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

foam.CLASS({
  package: 'foam.box',
  name: 'EventMessage',

  properties: [
    {
      class: 'Array',
      name: 'args'
    }
  ]
});
/**
 * @license
 * Copyright 2017 The FOAM Authors. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

foam.CLASS({
  package: 'foam.box',
  name: 'EventDispatchBox',

  implements: ['foam.box.Box'],

  requires: [
    'foam.box.EventMessage',
    'foam.box.InvalidMessageException'
  ],

  properties: [
    {
      name: 'target'
    }
  ],

  methods: [
    function send(msg) {
      if ( ! this.EventMessage.isInstance(msg.object) ) {
        throw this.InvalidMessageException.create({
          messageType: message.cls_.id
        });
      }

      this.target.pub.apply(this.target, msg.object.args);
    }
  ]
});
/**
 * @license
 * Copyright 2017 The FOAM Authors. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

foam.CLASS({
  package: 'foam.box',
  name: 'SkeletonBox',
  implements: ['foam.box.Box'],

  requires: [
    'foam.box.Message',
    'foam.box.RPCMessage',
    'foam.box.RPCReturnMessage',
    'foam.box.RPCErrorMessage',
    'foam.box.InvalidMessageException'
  ],

  properties: [
    {
      name: 'data'
    }
  ],

  methods: [
    {
      name: 'call',
      args: [
        {
          swiftType: 'Message?',
          name: 'message',
        },
      ],
      code: function(message) {
        var p;

        try {
          var method = this.data.cls_.getAxiomByName(message.object.name);
          var args = message.object.args.slice();

          // TODO: This is pretty hackish.  Context-Oriented methods should just be modeled.
          if ( method && method.args && method.args[0] && method.args[0].name == 'x' ) {
            var x = this.__context__.createSubContext({
              message: message
            });
            args[0] = x;
          }
          p = this.data[message.object.name].apply(this.data, args);
        } catch(e) {
          message.attributes.replyBox && message.attributes.replyBox.send(this.Message.create({
            object: this.RPCErrorMessage.create({ data: e.message })
          }));

          return;
        }

        var replyBox = message.attributes.replyBox;

        var self = this;

        if ( p instanceof Promise ) {
          p.then(
            function(data) {
              replyBox.send(self.Message.create({
                object: self.RPCReturnMessage.create({ data: data })
              }));
            },
            function(error) {
              message.attributes.replyBox && message.attributes.replyBox.send(self.Message.create({
                object: self.RPCErrorMessage.create({ data: error && error.toString() })
              }));
            });
        } else {
          replyBox && replyBox.send(this.Message.create({
            object: this.RPCReturnMessage.create({ data: p })
          }));
        }
      },
      swiftCode: function() {/*
do {
  guard let object = message?.object as? RPCMessage,
        let data = self.data as? FObject,
        let method = data.ownClassInfo().axiom(byName: object.name) as? MethodInfo
  else {
    throw InvalidMessageException_create()
  }

  // TODO handle context oriented methods.

  var p = try method.call(data, args: object.args)

  guard let replyBox = message?.attributes["replyBox"] as? Box else { return }
  if let pFut = p as? Future<Any> { p = try pFut.get() }
  try replyBox.send(Message_create([
    "object": RPCReturnMessage_create(["data": p])
  ]))
} catch let e {
  if let errorBox = message?.attributes["errorBox"] as? Box {
    try? errorBox.send(Message_create([
      "object": RPCErrorMessage_create([
        "data": e.localizedDescription
      ])
    ]))
  }
}
      */},
    },

    {
      name: 'send',
      code: function(message) {
        if ( this.RPCMessage.isInstance(message.object) ) {
          this.call(message);
          return;
        }

        throw this.InvalidMessageException.create({
          messageType: message.cls_ && message.cls_.id
        });
      },
      swiftCode: function() {/*
if let _ = msg.object as? RPCMessage {
  call(msg)
  return
}

throw InvalidMessageException_create([
  "messageType": msg.ownClassInfo().id,
])
      */},
    },
  ]
});
/**
 * @license
 * Copyright 2017 The FOAM Authors. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

foam.CLASS({
  package: 'foam.box',
  name: 'NullBox',

  implements: ['foam.box.Box'],

  methods: [
    {
      name: 'send',
      code: function() {}
    }
  ]
});
/**
 * @license
 * Copyright 2017 The FOAM Authors. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

foam.CLASS({
  package: 'foam.box',
  name: 'SocketBox',
  extends: 'foam.box.ProxyBox',

  requires: [
    'foam.box.SocketConnectBox'
  ],

  axioms: [
    foam.pattern.Multiton.create({
      property: 'address'
    })
  ],

  properties: [
    {
      class: 'String',
      name: 'name'
    },
    {
      class: 'String',
      name: 'address'
    },
    {
      name: 'delegate',
      transient: true,
      factory: function() {
        return foam.box.SocketConnectBox.create({
          address: this.address
        }, this);
      },
      swiftFactory: `
return SocketConnectBox_create([
  "address$": address$,
])
      `
    }
  ]
});
/**
 * @license
 * Copyright 2017 The FOAM Authors. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

foam.CLASS({
  package: 'foam.box',
  name: 'SocketBox2',

  imports: [
    'socketService',
  ],

  axioms: [
    foam.pattern.Multiton.create({
      property: 'address'
    })
  ],

  properties: [
    {
      class: 'String',
      name: 'address'
    },
    {
      name: 'promise',
      transient: true,
      factory: function() {
      }
    }
  ],

  methods: [
    function send(m) {
    }
  ],

  listeners: [
    function onConnect() {
      this.socketService.addSocket(this);
      this.send(this.RegisterSelfMessage.create({
        name: this.me.name
      }));
      this.connect.pub();
    },
    function onError() {
    }
  ]
});
/**
 * @license
 * Copyright 2017 The FOAM Authors. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

foam.CLASS({
  package: 'foam.box',
  name: 'SocketConnectBox',
  extends: 'foam.box.PromisedBox',

  requires: [
    {
      flags: ['js'],
      path: 'foam.box.RawSocketBox',
    },
  ],

  properties: [
    {
      class: 'String',
      name: 'address'
    },
    {
      name: 'delegate',
      factory: function() {
        // Use default FOAM implementation of Socket. Do not attempt to lookup
        // sensitive "foam.net.node.Socket" class in box context.
        return foam.lookup('foam.net.node.Socket').create(null, this).
            connectTo(this.address).then(function(s) {
              return this.RawSocketBox.create({ socket: s });
            }.bind(this));
      },
      swiftFactory: `
let socketService = __context__["socketService"] as! SocketService // TODO import
return socketService.getSocketBoxFuture(address)
      `
    }
  ]
});
/**
 * @license
 * Copyright 2017 The FOAM Authors. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

foam.CLASS({
  package: 'foam.box',
  name: 'RawSocketBox',
  implements: [ 'foam.box.Box' ],

  requires: [ 'foam.box.ReplyBox' ],
  imports: [
    'me',
    'registry',
  ],

  properties: [
    {
      class: 'Object',
      name: 'socket',
      javaType: 'org.java_websocket.WebSocket'
    }
  ],

  classes: [
    {
      name: 'JSONOutputter',
      extends: 'foam.json.Outputter',

      requires: [ 'foam.box.ReturnBox' ],
      imports: [ 'me' ],
      methods: [
        function output(o) {
          if ( o === this.me ) {
            return this.SUPER(this.ReturnBox.create());
          }
          return this.SUPER(o);
        }
      ]
    }
  ],

  methods: [
    {
      name: 'send',
      code: function send(msg) {
        var replyBox = msg.attributes.replyBox;
        if ( replyBox ) {
          // TODO: We should probably clone here, but often the message
          // contains RPC arguments that don't clone properly.  So
          // instead we will mutate replyBox and put it back after.

          // Even better solution would be to move replyBox to a
          // property on Message and have custom serialization in it to
          // do the registration.

          msg.attributes.replyBox = this.__context__.registry.
              register(msg.attributes.replyBox.id, null,
                       msg.attributes.replyBox);
        }

        try {
          this.socket.write(msg);
          if ( replyBox ) {
            msg.attributes.replyBox = replyBox;
          }
        } catch (error) {
          replyBox && replyBox.send(foam.box.Message.create({ object: error }));
        }
      }
    }
  ]
});
/**
 * @license
 * Copyright 2017 The FOAM Authors. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

foam.CLASS({
  package: 'foam.box',
  name: 'SendFailedError',
  extends: 'foam.box.Message',

  properties: [
    {
      name: 'original'
    },
    {
      name: 'error'
    }
  ]
});
/**
 * @license
 * Copyright 2017 The FOAM Authors. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

foam.CLASS({
  package: 'foam.box',
  name: 'RegisterSelfMessage',
  extends: 'foam.box.Message',

  properties: [
    {
      class: 'String',
      name: 'name'
    }
  ]
});
/**
 * @license
 * Copyright 2017 The FOAM Authors. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

foam.CLASS({
  package: 'foam.box',
  name: 'RawWebSocketBox',
  implements: ['foam.box.Box'],
  requires: [
    'foam.box.ReplyBox'
  ],
  imports: [
    {
      name: 'me',
      key: 'me',
      javaType: 'foam.box.Box'
    },
    {
      key: 'registry',
      name: 'registry',
      javaType: 'foam.box.BoxRegistry',
    }
  ],

  properties: [
    {
      class: 'Object',
      name: 'socket',
      javaType: 'foam.net.WebSocket'
    }
  ],

  classes: [
    foam.core.InnerClass.create({
      generateJava: false,
      model: {
        name: 'JSONOutputter',
        extends: 'foam.json.Outputter',
        requires: [
          'foam.box.ReturnBox'
        ],
        imports: [
          'me'
        ],
        methods: [
          function output(o) {
            if ( o === this.me ) {
              return this.SUPER(this.ReturnBox.create());
            }
            return this.SUPER(o);
          }
        ]
      }
    })
  ],

  methods: [
    {
      name: 'send',
      code: function send(msg) {
        var replyBox = msg.attributes.replyBox;
        if ( replyBox ) {
          // TODO: Should replyBox just be a property on message with
          // custom serialization?

          // TODO: Add one-time service policy

          msg.attributes.replyBox = this.__context__.registry.
              register(msg.attributes.replyBox.id, null,
                       msg.attributes.replyBox);
        }

        var payload = this.JSONOutputter.create().copyFrom(foam.json.Network).stringify(msg);

        try {
          this.socket.send(payload);
        } catch(e) {
          replyBox && replyBox.send(foam.box.Message.create({ object: e }));
        }
      },
      javaCode: `
foam.lib.json.Outputter outputter = new Outputter();
outputter.setX(getX());

// TODO: Clone message or something when it clones safely.
foam.box.Box replyBox = (foam.box.Box)message.getAttributes().get("replyBox");

if ( replyBox != null ) {
  foam.box.SubBox export = (foam.box.SubBox)getRegistry().register(null, null, replyBox);

  replyBox = new foam.box.ReplyBox(getX(), export.getName(), replyBox);
}

String payload = outputter.stringify(message);

message.getAttributes().put("replyBox", replyBox);

try {
  getSocket().send(payload);
} catch ( java.io.IOException e ) {
  foam.box.Message reply = new foam.box.Message();
  reply.setObject(e);
  if ( replyBox != null ) replyBox.send(reply);
}
`
    }
  ],

  axioms: [
    {
      name: 'javaExtras',
      buildJavaClass: function(cls) {
        cls.extras.push(foam.java.Code.create({
          data: `
protected class Outputter extends foam.lib.json.Outputter {
  public Outputter() {
    super(foam.lib.json.OutputterMode.NETWORK);
  }

  protected void outputFObject(foam.core.FObject o) {
    if ( o == getMe() ) {
      o = getX().create(foam.box.ReturnBox.class);
    }
    super.outputFObject(o);
  }
}
`}));
      }
    }
  ]
});
/**
 * @license
 * Copyright 2017 The FOAM Authors. All Rights Reserved.
 * http://www.apache.org/licenses/LICENSE-2.0
 */

foam.CLASS({
  package: 'foam.box',
  name: 'ReturnBox',
  documentation: 'A box that sends messages back over the connection it came in on.',
  implements: ['foam.box.Box'],
  methods: [
    {
      name: 'send',
      code: function(message) {
        this.__context__.returnBox.send(message);
      },
      swiftCode: `try (__context__["returnBox"] as! Box).send(msg)`,
      javaCode: `
((foam.box.Box)getX().get("returnBox")).send(message);
`
    }
  ]
});
/**
 * @license
 * Copyright 2017 The FOAM Authors. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

foam.CLASS({
  package: 'foam.box',
  name: 'RawMessagePortBox',
  implements: [ 'foam.box.Box' ],
  requires: [
    'foam.json.Outputter',
    'foam.box.ReplyBox'
  ],

  properties: [
    {
      name: 'port'
    },
    {
      class: 'FObjectProperty',
      of: 'foam.json.Outputter',
      name: 'outputter',
      factory: function() {
        // NOTE: Configuration must be consistent with parser in
        // foam.messageport.MessagePortService.
        //
        // Use default FOAM implementation of Outputter. Do not attempt to
        // lookup sensitive "foam.json.Outputter" class in box context.
        return this.Outputter.create().copyFrom(foam.json.Network)
      }
    }
  ],
  methods: [
    function send(message) {
      var replyBox = message.attributes.replyBox;
      if ( replyBox ) {
        // TODO: We should probably clone here, but often the message
        // contains RPC arguments that don't clone properly.  So
        // instead we will mutate replyBox and put it back after.

        // Even better solution would be to move replyBox to a
        // property on Message and have custom serialization in it to
        // do the registration.
        message.attributes.replyBox = this.__context__.registry.register(
            message.attributes.replyBox.id, null, message.attributes.replyBox);

        // TODO: There should be a better way to do this.
        replyBox = this.ReplyBox.create({
          id: message.attributes.replyBox.name
        });
      }

      var payload = this.outputter.stringify(message);

      if ( replyBox ) {
        message.attributes.replyBox = replyBox;
      }

      this.port.postMessage(payload);
    }
  ]
});
/**
 * @license
 * Copyright 2017 The FOAM Authors. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

foam.CLASS({
  package: 'foam.box',
  name: 'WebSocketBox',

  requires: [
    'foam.net.web.WebSocket',
    'foam.box.Message',
    'foam.box.RawWebSocketBox'
  ],

  imports: [
    'webSocketService',
    'me',
    'window'
  ],

  axioms: [
    foam.pattern.Multiton.create({
      property: 'uri'
    })
  ],

  properties: [
    {
      name: 'uri',
    },
    {
      name: 'delegate',
      factory: function() {
        var ws = this.WebSocket.create({
          uri: this.prepareURL(this.uri),
        });

        return ws.connect().then(function(ws) {
          ws.disconnected.sub(function(sub) {
            sub.detach();
            this.delegate = undefined;
          }.bind(this));

          this.webSocketService.addSocket(ws);

          return this.RawWebSocketBox.create({ socket: ws });
        }.bind(this), function(e) {
          // Failed to connect, clear the delegate so that the next send
          // will reconnect.
          this.delegate = undefined;
        }.bind(this));
      }
    }
  ],

  methods: [
    function prepareURL(url) {
      /* Add window's origin if url is not complete. */
      if ( this.window && url.indexOf(':') == -1 ) {
        var protocol = "ws://";
        if ( this.window.location.protocol === "https:" ) {
          protocol = "wss://";
        }

        return protocol + this.window.location.hostname +
          ( this.window.location.port ? ':' + ( parseInt(this.window.location.port) + 1 ) : '' ) +
          '/' + url;
      }

      return url;
    },

    {
      name: 'send',
      code: function send(msg) {
        this.delegate.then(function(d) {
          d.send(msg);
        }, function(e) {
          // Failed to connect.
          if ( msg.attributes.replyBox ) msg.attributes.replyBox.send(foam.box.Message.create({
            object: e
          }));
        });
      }
    }
  ]
});
/**
 * @license
 * Copyright 2017 The FOAM Authors. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

foam.CLASS({
  package: 'foam.box',
  name: 'ClassWhitelistContext',
  exports: [
    'lookup'
  ],
  properties: [
    {
      class: 'StringArray',
      name: 'whitelist'
    },
    {
      name: 'whitelist_',
      expression: function(whitelist) {
        var w = {};
        for ( var i = 0 ; i < whitelist.length ; i++ ) {
          w[whitelist[i]] = true;
        }
        return w;
      },
      swiftType: 'Set<String>',
      swiftExpressionArgs: ['whitelist'],
      swiftExpression: function() {/*
var w = Set<String>()
for i in whitelist {
  w.insert(i)
}
return w
      */}
    }
  ],
  methods: [
    {
      class: 'ContextMethod',
      name: 'lookup',
      swiftReturns: 'ClassInfo?',
      swiftThrows: true,
      args: [
        {
          swiftType: 'Context',
          name: 'X',
        },
        {
          swiftType: 'String',
          name: 'id',
        },
      ],
      code: function(X, id) {
        // TODO: This should be:
        // if ( ! this.whitelist_[id] ) { ... }
        // Change it back once #777 is closed.
        if ( this.whitelist.indexOf(id) === -1 ) {
          throw new Error('Class "' + id + '" is not whitelisted.');
        }
        return this.__context__.lookup.call(X, id);
      },
      swiftCode: function() {/*
if whitelist.contains(id) {
  throw FoamError("Class " + id + " is not whitelisted.")
}
return X.lookup(id)
      */}
    }
  ]
});
/**
 * @license
 * Copyright 2017 The FOAM Authors. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

foam.CLASS({
  package: 'foam.box',
  name: 'LoggedLookupContext',

  exports: [
    'lookup',
  ],

  properties: [
    {
      class: 'Map',
      name: 'record'
    }
  ],

  methods: [
    {
      class: 'ContextMethod',
      name: 'lookup',
      swiftReturns: 'ClassInfo?',
      swiftThrows: true,
      args: [
        {
          swiftType: 'Context',
          name: 'X',
        },
        {
          swiftType: 'String',
          name: 'id',
        },
      ],
      code: function(X, id, opt_suppress) {
        this.record[id] = id;
        return this.__context__.lookup.call(X, id, opt_suppress);
      },
      swiftCode: function() {/*
record[id] = id;
return X.lookup(id)
      */}
    }
  ]
});
/**
 * @license
 * Copyright 2017 The FOAM Authors. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

foam.CLASS({
  package: 'foam.box',
  name: 'Context',
  swiftName: 'BoxContext',

  requires: [
    'foam.box.BoxRegistryBox',
    'foam.box.NamedBox',
    'foam.box.ClassWhitelistContext',
    'foam.box.LoggedLookupContext',
  ],

  exports: [
    'creationContext',
    'me',
    'messagePortService',
    'registry',
    'root',
    'socketService',
    'webSocketService'
  ],

  properties: [
    {
      name: 'messagePortService',
      hidden: true,
      factory: function() {
        var model = this.lookup('foam.messageport.MessagePortService', true);
        if ( model ) {
          return model.create({
            delegate: this.registry
          }, this);
        }
      }
    },
    {
      name: 'socketService',
      hidden: true,
      factory: function() {
        var model = this.lookup('foam.net.node.SocketService', true);
        if ( model ) {
          return model.create({
            port: Math.floor( 10000 + ( Math.random() * 10000 ) ),
            delegate: this.registry
          }, this);
        }
      },
      swiftFactory: `
return __context__.lookup("foam.swift.net.SocketService")!.create(args: [
  "delegate$": registry$,
], x: __subContext__)
      `,
    },
    {
      name: 'webSocketService',
      hidden: true,
      factory: function() {
        var model = this.lookup('foam.net.node.WebSocketService', true) ||
            this.lookup('foam.net.web.WebSocketService', true);

        if ( model ) {
          return model.create({
            delegate: this.registry
          }, this);
        }
      }
    },
    {
      class: 'FObjectProperty',
      of: 'foam.box.Box',
      name: 'registry',
      hidden: true,
      factory: function() {
        return this.BoxRegistryBox.create();
      },
      swiftFactory: 'return BoxRegistryBox_create()',
    },
    {
      class: 'FObjectProperty',
      of: 'foam.box.Box',
      name: 'root',
      hidden: true,
      postSet: function(_, root) {
        foam.box.NamedBox.create({ name: '' }).delegate = root;
      },
      swiftPostSet: 'NamedBox_create(["name": ""]).delegate = newValue!',
    },
    {
      class: 'String',
      name: 'myname',
      hidden: true,
      swiftFactory:
          'return "/com/foamdev/anonymous/" + UUID().uuidString',
      factory: function() {
        return foam.isServer ?
          '/proc/' + __webpack_require__(19).pid + '/' + foam.uuid.randomGUID() :
          '/com/foamdev/anonymous/' + foam.uuid.randomGUID();
      }
    },
    {
      name: 'me',
      hidden: true,
      transient: true,
      factory: function() {
        var me = this.NamedBox.create({ name: this.myname });
        me.delegate = this.registry;
        return me;
      },
      swiftFactory: function() {/*
        let me = NamedBox_create(["name": self.myname])
        me.delegate = self.registry!
        return me
      */},
    },
    {
      class: 'Boolean',
      name: 'unsafe',
      value: true
    },
    {
      class: 'StringArray',
      name: 'classWhitelist'
    },
    {
      name: 'creationContext',
      documentation: `Provides required import for boxes that parse strings into
          FObjects.`,
      hidden: true,
      factory: function() {
        // TODO: Better way to inject the class whitelist.
        if ( this.unsafe ) {
          console.warn('**** Boxes are running in UNSAFE mode.  Turn this off before you go to production!');
          return this.LoggedLookupContext.create(null, this).__subContext__;
        }

        return this.ClassWhitelistContext.create({
          whitelist: this.classWhitelist
        }, this).__subContext__;
      },
      swiftFactory: `
return ClassWhitelistContext_create([
  "whitelist$": classWhitelist$,
]).__subContext__
      `,
    }
  ]
});
/**
 * @license
 * Copyright 2017 The FOAM Authors. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

foam.CLASS({
  package: 'foam.box',
  name: 'BoxService',

  properties: [
    {
      class: 'Class',
      name: 'server'
    },
    {
      class: 'Class',
      name: 'client'
    },
    {
      class: 'FObjectProperty',
      of: 'foam.box.BoxService',
      name: 'next'
    }
  ],

  methods: [
    {
      name: 'serverBox',
      args: [
        {
          swiftType: 'Box',
          name: 'box',
        },
      ],
      returns: 'foam.box.Box',
      code: function serverBox(box) {
        box = this.next ? this.next.serverBox(box) : box;
        return this.server ? this.server.create({ delegate: box }) : box;
      },
      swiftCode: function() {/*
let box2: Box = next?.serverBox(box) ?? box
return server.create(args: ["delegate": box2], x: __subContext__) as! Box
      */},
    },
    {
      name: 'clientBox',
      args: [
        {
          name: 'box',
          swiftType: 'Box',
        },
      ],
      returns: 'foam.box.Box',
      code: function(box) {
        box = this.client ? this.client.create({ delegate: box }) : box;
        return this.next ?
          this.next.clientBox(box) :
          box;
      },
      swiftCode: function() {/*
let box2 = client.create(args: ["delegate": box], x: __subContext__) as! Box
return next?.clientBox(box2) ?? box2
      */},
    },
  ]
});
/**
 * @license
 * Copyright 2017 The FOAM Authors. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

foam.CLASS({
  package: 'foam.box',
  name: 'HTTPReplyBox',
  implements: ['foam.box.Box'],

  imports: [
    // Optional import.
    //    'httpResponse'
  ],

  methods: [
    {
      name: 'send',
      code: function(m) {
        throw 'unimplemented';
      },
      swiftCode: 'throw FoamError("unimplemented")',
    }
  ]
});
/**
 * @license
 * Copyright 2017 The FOAM Authors. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

foam.CLASS({
  package: 'foam.box',
  name: 'AuthenticatedBox',
  extends: 'foam.box.ProxyBox',

  imports: [
    'idToken'
  ],

  methods: [
    function send(m) {
      m.attributes.idToken = this.idToken;
      this.SUPER(m);
    }
  ]
});
/**
 * @license
 * Copyright 2017 The FOAM Authors. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

foam.CLASS({
  package: 'foam.box',
  name: 'CheckAuthenticationBox',
  extends: 'foam.box.ProxyBox',

  imports: [
    'tokenVerifier'
  ],

  methods: [
    {
      name: 'send',
      code: function send() {
        throw new Error('Unimplemented.');
      }
    }
  ]
});
/**
 * @license
 * Copyright 2017 The FOAM Authors. All Rights Reserved.
 * http://www.apache.org/licenses/LICENSE-2.0
 */
foam.CLASS({
  package: 'foam.box',
  name: 'HTTPException',
  implements: [ 'foam.core.Exception' ],
  properties: [
    'response'
  ]
});

foam.CLASS({
  package: 'foam.box',
  name: 'HTTPBox',

  implements: [ 'foam.box.Box' ],

  requires: [
    {
      path: 'foam.json.Parser',
      flags: ['js'],
    },
    {
      path: 'foam.net.web.HTTPRequest',
      flags: ['js'],
    },
    {
      path: 'foam.json.Outputter',
      flags: ['js'],
    },
    {
      path: 'foam.swift.parse.json.FObjectParser',
      flags: ['swift'],
    },
    {
      name: 'SwiftOutputter',
      path: 'foam.swift.parse.json.output.Outputter',
      flags: ['swift'],
    },
    'foam.box.HTTPReplyBox',
  ],

  imports: [
    'creationContext',
    {
      name: 'me',
      key: 'me',
      javaType: 'foam.box.Box'
    },
    'window'
  ],

  properties: [
    {
      class: 'String',
      name: 'url'
    },
    {
      class: 'String',
      name: 'method',
      value: 'POST'
    },
    {
      class: 'FObjectProperty',
      of: 'foam.json.Parser',
      swiftType: 'FObjectParser',
      name: 'parser',
      generateJava: false,
      factory: function() {
        return this.Parser.create({
          strict:          true,
          // Trust our own server, but force other servers to go through
          // whitelist.
          creationContext: this.url.indexOf(':') == -1 ?
            this.__context__     :
            this.creationContext
        });
      },
      swiftFactory: 'return FObjectParser_create()',
    },
    {
      class: 'FObjectProperty',
      of: 'foam.json.Outputter',
      name: 'outputter',
      generateJava: false,
      swiftFactory: 'return SwiftOutputter_create()',
      factory: function() {
        return this.Outputter.create().copyFrom(foam.json.Network);
      }
    }
  ],

  axioms: [
    {
      name: 'javaExtras',
      buildJavaClass: function(cls) {
        cls.extras.push(foam.java.Code.create({
          data: `
protected class Outputter extends foam.lib.json.Outputter {
  public Outputter() {
    super(foam.lib.json.OutputterMode.NETWORK);
  }

  protected void outputFObject(foam.core.FObject o) {
    if ( o == getMe() ) {
      o = getX().create(foam.box.HTTPReplyBox.class);
    }
    super.outputFObject(o);
  }
}

protected class ResponseThread implements Runnable {
  protected java.net.URLConnection conn_;
  public ResponseThread(java.net.URLConnection conn) {
    conn_ = conn;
  }

  public void run() {
  }
}
`}));
      }
    }
  ],

  methods: [
    function prepareURL(url) {
      /* Add window's origin if url is not complete. */
      if ( this.window && url.indexOf(':') == -1 ) {
        return this.window.location.origin + '/' + url;
      }

      return url;
    },

    {
      name: 'send',
      code: function(msg) {
        // TODO: We should probably clone here, but often the message
        // contains RPC arguments that don't clone properly.  So
        // instead we will mutate replyBox and put it back after.
        var replyBox = msg.attributes.replyBox;

        msg.attributes.replyBox = this.HTTPReplyBox.create();

        var payload = this.outputter.stringify(msg);

        msg.attributes.replyBox = replyBox;

        var req = this.HTTPRequest.create({
          url:     this.prepareURL(this.url),
          method:  this.method,
          payload: payload
        }).send();

        req.then(function(resp) {
          return resp.payload;
        }).then(function(p) {
          return this.parser.aparse(p);
        }.bind(this)).then(function(rmsg) {
          rmsg && replyBox && replyBox.send(rmsg);
        }.bind(this), function(r) {
          replyBox && replyBox.send(foam.box.Message.create({ object: foam.box.HTTPException.create({ response: r }) }));
        });
      },
      swiftCode: function() {/*
let replyBox = msg.attributes["replyBox"] as? Box
msg.attributes["replyBox"] = HTTPReplyBox_create()

var request = URLRequest(url: Foundation.URL(string: self.url)!)
request.httpMethod = "POST"
request.httpBody = outputter?.swiftStringify(msg).data(using: .utf8)

msg.attributes["replyBox"] = replyBox

let task = URLSession.shared.dataTask(with: request) { data, response, error in
  do {
    guard let data = data else {
      throw FoamError("HTTPBox no response")
    }
    guard let str = String(data: data, encoding: .utf8),
          let obj = self.parser.parseString(str) as? Message else {
      throw FoamError("Failed to parse HTTPBox response")
    }
    try replyBox?.send(obj)
  } catch let e {
    try? replyBox?.send(self.__context__.create(Message.self, args: ["object": e])!)
  }
}
task.resume()
      */},
      javaCode: `
// TODO: Go async and make request in a separate thread.
java.net.HttpURLConnection conn;
foam.box.Box replyBox = (foam.box.Box)message.getAttributes().get("replyBox");

try {
  java.net.URL url = new java.net.URL(getUrl());
  conn = (java.net.HttpURLConnection)url.openConnection();
  conn.setDoOutput(true);
  conn.setRequestMethod("POST");
  conn.setRequestProperty("Accept", "application/json");
  conn.setRequestProperty("Content-Type", "application/json");

  java.io.OutputStreamWriter output = new java.io.OutputStreamWriter(conn.getOutputStream(),
                                                                     java.nio.charset.StandardCharsets.UTF_8);


  // TODO: Clone message or something when it clones safely.
  message.getAttributes().put("replyBox", getX().create(foam.box.HTTPReplyBox.class));


  foam.lib.json.Outputter outputter = new foam.lib.json.Outputter(foam.lib.json.OutputterMode.NETWORK);
  outputter.setX(getX());
  output.write(outputter.stringify(message));

  message.getAttributes().put("replyBox", replyBox);

  output.close();

// TODO: Switch to ReaderPStream when https://github.com/foam-framework/foam2/issues/745 is fixed.
byte[] buf = new byte[8388608];
java.io.InputStream input = conn.getInputStream();

int off = 0;
int len = buf.length;
int read = -1;
while ( len != 0 && ( read = input.read(buf, off, len) ) != -1 ) {
  off += read;
  len -= read;
}

if ( len == 0 && read != -1 ) {
  throw new RuntimeException("Message too large.");
}

String str = new String(buf, 0, off, java.nio.charset.StandardCharsets.UTF_8);

foam.core.FObject responseMessage = getX().create(foam.lib.json.JSONParser.class).parseString(str);

if ( responseMessage == null ) {
  throw new RuntimeException("Error parsing response.");
}

if ( ! ( responseMessage instanceof foam.box.Message ) ) {
  throw new RuntimeException("Invalid response type: " + responseMessage.getClass().getName() + " expected foam.box.Message.");
}


replyBox.send((foam.box.Message)responseMessage);

} catch(java.io.IOException e) {
  foam.box.Message replyMessage = getX().create(foam.box.Message.class);
  replyMessage.setObject(e);
  replyBox.send(replyMessage);
}
`
    }
  ]
});

/**
 * @license
 * Copyright 2017 The FOAM Authors. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

foam.CLASS({
  package: 'foam.box',
  name: 'MessagePortBox',
  extends: 'foam.box.ProxyBox',

  requires: [
    'foam.box.RawMessagePortBox',
    'foam.box.RegisterSelfMessage',
    'foam.box.Message',
    'foam.json.Outputter'
  ],

  imports: [
    'me',
    'messagePortService'
  ],

  properties: [
    {
      name: 'target'
    },
    {
      name: 'delegate',
      factory: function() {
	var channel = new MessageChannel();
	this.messagePortService.addPort(channel.port1);

	this.target.postMessage(channel.port2, [ channel.port2 ]);

        channel.port1.postMessage(this.outputter.stringify(
            this.Message.create({
              object: this.RegisterSelfMessage.create({ name: this.me.name })
            })));

	return this.RawMessagePortBox.create({ port: channel.port1 });
      }
    },
    {
      class: 'FObjectProperty',
      of: 'foam.json.Outputter',
      name: 'outputter',
      factory: function() {
        // NOTE: Configuration must be consistent with parser in
        // foam.messageport.MessagePortService.
        //
        // Use default FOAM implementation of Outputter. Do not attempt to
        // lookup sensitive "foam.json.Outputter" class in box context.
        return this.Outputter.create().copyFrom(foam.json.Network)
      }
    }
  ]
});
/**
 * @license
 * Copyright 2017 The FOAM Authors. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

foam.CLASS({
  package: 'foam.box',
  name: 'ForwardedMessage',

  properties: [
    {
      class: 'FObjectProperty',
      of: 'foam.box.Box',
      name: 'destination'
    },
    {
      class: 'FObjectProperty',
      name: 'payload'
    }
  ]
});
/**
 * @license
 * Copyright 2017 The FOAM Authors. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

foam.CLASS({
  package: 'foam.box',
  name: 'ForwardBox',
  extends: 'foam.box.ProxyBox',

  requires: [
    'foam.box.ForwardedMessage'
  ],

  properties: [
    {
      name: 'destination'
    }
  ],

  methods: [
    function send(m) {
      m.object = this.ForwardedMessage.create({
        destination: this.destination,
        payload: m.object
      });
      this.SUPER(m);
    }
  ]
});
/**
 * @license
 * Copyright 2017 The FOAM Authors. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

foam.CLASS({
  package: 'foam.box',
  name: 'ForwardingBox',
  implements: [ 'foam.box.Box' ],

  requires: [
    'foam.box.ForwardedMessage'
  ],

  methods: [
    function send(m) {
      if ( ! this.ForwardedMessage.isInstance(m.object) )
        throw foam.box.InvalidMessageException.create();

      var wrapper = m.object;
      m.object = wrapper.payload;

      wrapper.destination.describe();
      wrapper.destination.send(m);
    }
  ]
});
/**
 * @license
 * Copyright 2017 The FOAM Authors. All Rights Reserved.
 * http://www.apache.org/licenses/LICENSE-2.0
 */

foam.CLASS({
  package: 'foam.box',
  name: 'Remote',
  properties: [
    {
      class: 'String',
      name: 'clientClass'
    }
  ],
  methods: [
    function installInClass(cls) {
      var clientClass = this.clientClass || cls.getAxiomsByClass(foam.core.Implements)[0].path;

      cls.installAxiom(foam.core.Method.create({
        name: 'outputJSON',
        code: function(outputter) {
          var cls = this.__context__.lookup(clientClass, true);

          if ( ! cls ) {
            throw new Error('Could not find ' + clientClass + ' to serialize ' + this.cls_.id);
          }

          if ( ! foam.core.Stub.isInstance(cls.getAxiomByName('delegate')) ) {
            throw new Error('Expected stub property to be named "delegate" for ' + cls.id);
          }

          var X = this.__subContext__;
          var registry = X.registry;

          var box = foam.box.SkeletonBox.create({ data: this }, X);
          box = registry.register(null, null, box);

          var obj = cls.create(null, X);
          obj.delegate = box;

          outputter.output(obj);
        }
      }));
    }
  ]
});
/**
 * @license
 * Copyright 2017 The FOAM Authors. All Rights Reserved.
 * http://www.apache.org/licenses/LICENSE-2.0
 */

foam.CLASS({
  package: 'foam.box',
  name: 'SessionReplyBox',
  extends: 'foam.box.ProxyBox',

  requires: [
    'foam.box.RPCErrorMessage'
  ],

  imports: [
    'requestLogin'
  ],

  properties: [
    'msg',
    'clientBox'
  ],

  methods: [
    {
      name: 'send',
      code: function send(msg) {
        var self = this;

        // TODO: if I get an AuthException the call the requestLogin
        // handler then retry once it finishes.
        // console.log('************************* REPLY: ', foam.json.stringify(msg));
        // Exception looks like this:
        // {class:"foam.box.Message",attributes:{},object:{class:"foam.box.RPCErrorMessage",data:{class:"foam.box.RemoteException",id:"java.security.AccessControlException",message:"not logged in"}}}
        if ( this.RPCErrorMessage.isInstance(msg.object) && msg.object.data.id === 'java.security.AccessControlException' ) {
          this.requestLogin().then(function() {
            self.clientBox.send(self.msg);
          });
        } else {
          this.delegate.send(msg);
        }
      }
    }
  ]
});


foam.CLASS({
  package: 'foam.box',
  name: 'SessionClientBox',
  extends: 'foam.box.ProxyBox',

  requires: [ 'foam.box.SessionReplyBox' ],

  constants: [
    {
      name: 'SESSION_KEY',
      value: 'sessionId',
      type: 'String',
      swiftValue: '"sessionId"',
      swiftType: 'String',
    }
  ],

  properties: [
    {
      class: 'String',
      name: 'sessionName',
      value: 'defaultSession'
    },
    {
      class: 'String',
      name: 'sessionID',
      factory: function() {
        return localStorage[this.sessionName] ||
            ( localStorage[this.sessionName] = foam.uuid.randomGUID() );
      },
      swiftExpressionArgs: [ 'sessionName' ],
      swiftExpression: `
let defaults = UserDefaults.standard // TODO allow us to configure?
if let id = defaults.string(forKey: sessionName) {
  return id
}
let id = UUID().uuidString
defaults.set(id, forKey: sessionName)
return id
      `,
      javaFactory:
`String uuid = (String) getX().get(getSessionName());
if ( "".equals(uuid) ) {
  uuid = java.util.UUID.randomUUID().toString();
  getX().put(getSessionName(), uuid);
}
return uuid;`
    }
  ],

  methods: [
    {
      name: 'send',
      code: function send(msg) {
        msg.attributes[this.SESSION_KEY] = this.sessionID;

        // console.log('***** SEND SESSION ID: ', this.sessionID/*foam.json.stringify(msg)*/);

        msg.attributes.replyBox = this.SessionReplyBox.create({
          msg:       msg,
          clientBox: this,
          delegate:  msg.attributes.replyBox
        });

        this.delegate.send(msg);
      },
      swiftCode: `
msg.attributes[SessionClientBox.SESSION_KEY] = sessionID
msg.attributes["replyBox"] = SessionReplyBox_create([
  "msg": msg,
  "clientBox": self,
  "delegate": msg.attributes["replyBox"] as? Box,
])
try delegate.send(msg)
      `,
    }
  ]
});

/**
 * @license
 * Copyright 2017 The FOAM Authors. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

foam.CLASS({
  package: 'foam.box',
  name: 'Runnable',

  documentation: `An asynchronous computation that produces one or more outputs,
      and sends them to its outputBox, reporting any errors to errorBox.`,

  requires: [ 'foam.box.Message' ],

  properties: [
    {
      class: 'String',
      name: 'ioRelationshipType',
      documentation: 'The n:m relationship type of input-to-output.',
      value: '1:1'
    },
    {
      class: 'Class',
      documentation: 'Type of input parameter of run().',
      name: 'inputType',
      factory: function() { return foam.core.FObject; }
    },
    {
      class: 'Class',
      documentation: 'Type of input vaules produced by run().',
      name: 'outputType',
      factory: function() { return foam.core.FObject; }
    },
    {
      class: 'FObjectProperty',
      of: 'foam.box.Box',
      documentation: 'Box to send to for computation output(s).',
      name: 'outputBox'
    },
    {
      class: 'FObjectProperty',
      of: 'foam.box.Box',
      documentation: 'Box to send to for internal errors(s).',
      name: 'errorBox'
    }
  ],

  methods: [
    {
      name: 'run',
      documentation: 'Modeled computation for outputing to a box.',
      code: function() {}
    },
    {
      name: 'output',
      args: [
        {
          typeName: 'this.outputType',
          documentation: 'Helper function for outputing a value.',
        }
      ],
      code: function(value) {
        this.outputBox.send(this.Message.create({
          object: value
        }));
      }
    },
    {
      name: 'error',
      args: [
        {
          typeName: 'Error',
          documentation: 'Helper function for reporting an error.',
        }
      ],
      code: function(error) {
        this.errorBox.send(this.Message.create({
          object: error
        }));
      }
    }
  ]
});
/**
 * @license
 * Copyright 2017 The FOAM Authors. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

foam.CLASS({
  package: 'foam.box',
  name: 'LogBox',
  extends: 'foam.box.ProxyBox',

  documentation: 'Log input messages before passing to optional delegate.',

  requires: [ 'foam.log.LogLevel' ],

  imports: [
    'debug',
    'log',
    'info',
    'warn',
    'error'
  ],

  swiftImports: ['os'],

  properties: [
    {
      class: 'String',
      name: 'name',
      factory: function() { return `LogBox${this.$UID}`; },
      swiftFactory: 'return "LogBox$"+UUID().uuidString',
    },
    {
      class: 'FObjectProperty',
      of: 'foam.log.LogLevel',
      name: 'logLevel',
      factory: function() { return this.LogLevel.INFO; },
      swiftFactory: 'return LogLevel.INFO',
    }
  ],

  methods: [
    {
      name: 'send',
      code: function(message) {
        var output = message.object;
        this[this.logLevel.consoleMethodName].apply(this, [
          this.name,
          output instanceof Error ? output.toString() :
            foam.json.Pretty.stringify(message)
        ]);
        this.delegate && this.delegate.send(message);
      },
      swiftCode: `
let output = msg.object;
let logMsg = [
  name,
  output is Error ? (output as! Error).localizedDescription : msg.toString()
].joined(separator: " ")
if let logLevelStr = logLevel?.consoleMethodName,
   let logMethod = get(key: logLevelStr) as? (String) -> Void {
  logMethod(logMsg)
} else {
  os_log("%@", logMsg)
}
try delegate.send(msg)
      `,
    },
  ]
});
/**
 * @license
 * Copyright 2017 The FOAM Authors. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

foam.CLASS({
  package: 'foam.box',
  name: 'MultiDelegateBox',
  implements: [ 'foam.box.Box' ],

  documentation: `Base class for boxes that manage dispatch to multiple
      delegates.`,

  properties: [
    {
      class: 'FObjectArray',
      of: 'foam.box.Box',
      name: 'delegates'
    }
  ],

  methods: [
    function send(message) {
      throw new Error('Call to abstract MultiDelegateBox.send(message)');
    }
  ]
});
/**
 * @license
 * Copyright 2017 The FOAM Authors. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

foam.CLASS({
  package: 'foam.box',
  name: 'BroadcastBox',
  extends: 'foam.box.MultiDelegateBox',

  documentation: `Broadcast all messages to multiple delegate boxes.`,

  methods: [
    function send(message) {
      var ds = this.delegates;
      for ( var i = 0; i < ds.length; i++ ) {
        ds[i].send(message);
      }
    }
  ]
});
/**
 * @license
 * Copyright 2017 The FOAM Authors. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

foam.CLASS({
  package: 'foam.box',
  name: 'RoundRobinBox',
  extends: 'foam.box.MultiDelegateBox',

  documentation: `Delegates messages to box workers using round robin
      strategy.`,

  properties: [
    {
      name: 'currentBoxId_',
      value: 0,
      preSet: function(_, val) {
        return val % this.delegates.length;
      }
    }
  ],

  methods: [
    function send(message) {
      this.delegates[this.currentBoxId_++].send(message);
    }
  ]
});
/**
 * @license
 * Copyright 2017 The FOAM Authors. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

foam.CLASS({
  package: 'foam.box.pipeline',
  name: 'RunnableRPCBox',
  extends: 'foam.box.ProxyBox',

  documentation: 'A box that wraps input messages in Runnable.run() RPC calls.',

  requires: [
    'foam.box.Message',
    'foam.box.RPCMessage'
  ],

  properties: [
    {
      class: 'FObjectProperty',
      of: 'foam.box.Box',
      documentation: `Error box for routing errors when sending to
              runnable.`,
      name: 'errorBox'
    },
  ],

  methods: [
    function send(inputMessage) {
      return this.delegate && this.delegate.send(this.Message.create({
        object: this.RPCMessage.create({
          name: 'run',
          args: [ inputMessage.object ]
        }),
        attributes: { errorBox: this.errorBox }
      }));
    }
  ]
});
/**
 * @license
 * Copyright 2017 The FOAM Authors. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

foam.CLASS({
  package: 'foam.box.pipeline',
  name: 'PipelineNode',

  documentation: `foam.box.PipelineManager object that encapsulates data related
      to runnable.`,

  requires: [
    'foam.box.LogBox',
    'foam.box.PromisedBox',
    'foam.box.SkeletonBox',
    'foam.log.LogLevel'
  ],
  imports: [ 'defaultErrorBox?' ],

  properties: [
    {
      class: 'FObjectProperty',
      of: 'foam.box.Runnable',
      name: 'runnable'
    },
    {
      class: 'FObjectProperty',
      of: 'foam.box.Box',
      name: 'localInput',
      transient: true,
      expression: function(runnable) {
        return this.SkeletonBox.create({
          data: runnable
        });
      }
    },
    {
      class: 'FObjectProperty',
      of: 'foam.box.PromisedBox',
      name: 'remoteInput',
      factory: function() { return this.PromisedBox.create(); }
    },
    {
      class: 'FObjectProperty',
      of: 'foam.box.Box',
      name: 'errorBox',
      documentation: 'Error box for RPC-related errors external to runnable.',
      factory: function() {
        return this.defaultErrorBox || this.LogBox.create({
          logLevel: this.LogLevel.ERROR
        });
      }
    }
  ]
});
/**
 * @license
 * Copyright 2017 The FOAM Authors. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

foam.CLASS({
  package: 'foam.box.pipeline',
  name: 'PipelineManager',

  documentation: `A manager for composing pipelines of foam.box.Runnable
    instances. Pipelines may fork via multiple then()s. Manager's current
    runnables may be bound together with bind(); this can be used to merge
    pipelines. Pipelines may not contain cycles.

    Note that each runnable is registered as a service exactly once, even if
    a builder referring to pipeline stages is built multiple times.

    E.g.,

    var b = PipelineManager.create();
    var shared = b.then(sharedRunnable);

    shared.then(forkRunnable1);
    shared.then(forkRunnable2);

    var merge1Builder = PipelineManager.create().then(mergeRunnable1);
    var merge2Builder = PipelineManager.create().then(mergeRunnable1);
    merge1Builder.bind(shared);
    merge2Builder.bind(shared);

    var inputToMerge1Runnable = merge1Builder.build();
    var inputToMerge2Runnable = merge2Builder.build();
    // Yields input boxes for mergeRunnable1 and mergeRunnable2
    // on pipeline:
    //
    // mergeRunnable1 --                       -- forkRunnable1
    //                  >-- sharedRunnable -- <
    // mergeRunnable2 --                       -- forkRunnable2`,

  requires: [
    'foam.box.Box',
    'foam.box.BroadcastBox',
    'foam.box.LogBox',
    'foam.box.Message',
    'foam.box.RPCMessage',
    'foam.box.RPCReturnBox',
    'foam.box.pipeline.PipelineNode',
    'foam.box.pipeline.RunnableRPCBox'
  ],

  imports: [
    'registry',
    'defaultOutputBox? as ctxDefaultOutputBox'
  ],

  properties: [
    {
      class: 'FObjectProperty',
      of: 'foam.box.Box',
      name: 'defaultOutputBox',
      documentation: `Output box used for end-of-computation (when no
          next-to-run delegates bound to this step in the pipeline).`,
      factory: function() {
        return this.ctxDefaultOutputBox || this.LogBox.create();
      }
    },
    {
      class: 'FObjectProperty',
      of: 'foam.box.pipeline.PipelineNode',
      name: 'pipeline',
      documentation: 'PipelineNode step for encapsulating runnable.',
      factory: function() { this.PipelineNode.create(); }
    },
    {
      class: 'FObjectArray',
      of: 'foam.box.pipeline.PipelineManager',
      name: 'delegates',
      documentation: `Immediate next step(s) in the pipeline after this runnable
          step.`,
      postSet: function(old, nu) {
        var pl = this.pipeline;

        if ( nu.length === 0 ) {
          // End of the line. Do not wrap RPCMessage around output box.
          pl.runnable.outputBox = this.defaultOutputBox;
        } else if ( this.delegates.length === 1 ) {
          // Just one delegate. Wrap RPCMessage around output value.
          pl.runnable.outputBox = this.RunnableRPCBox.create({
            delegate: nu[0].pipeline.remoteInput,
            errorBox: nu[0].pipeline.errorBox
          });
        } else {
          // Many delegates. Wrap RPCMessage around output value and pass along
          // to all delegates.
          pl.runnable.outputBox = this.BroadcastBox.create({
              delegates: nu.map(function(pipelineBuilder) {
                return this.RunnableRPCBox.create({
                  delegate: pipelineBuilder.pipeline.remoteInput,
                  errorBox: pipelineBuilder.pipeline.errorBox
                });
              }.bind(this))
          });
        }
      }
    },
    {
      class: 'FObjectArray',
      of: 'foam.box.pipeline.PipelineManager',
      name: 'parents',
      documentation: `Immediate previous step(s) in the pipeline before this
          runnable step.`,
    },
    {
      class: 'FObjectProperty',
      of: 'foam.box.Box',
      name: 'builtInputBox_',
      documentation: `Input box that can be returned from building this
          builder. Accepts messages containing this runnable step's inputType.`,
      value: null
    }
  ],

  methods: [
    function init() {
      this.validate();
      foam.assert(this.Box.isInstance(this.registry),
                  'PipelineNode requires registry that implements Box');
      this.SUPER();
    },
    {
      name: 'then',
      returns: { typeName: 'foam.box.pipeline.PipelineManager' },
      args: [ { typeName: 'foam.box.Runnable' } ],
      documentation: `Append an immediate next step to pipeline.`,
      code: function(runnable) {
        var pl = this.pipeline;
        if ( ! pl ) {
          this.pipeline = this.PipelineNode.create({ runnable: runnable });
          return this;
        }

        var next = this.cls_.create({
          pipeline: this.PipelineNode.create({ runnable: runnable }),
          parents: [ this ]
        }, this.__subContext__);
        this.delegates = this.delegates.concat([ next ]);
        return next;
      }
    },
    {
      name: 'bind',
      args: [ { typeName: 'foam.box.pipeline.PipelineManager' } ],
      documentation: `Bind this pipeline manager's current runnable to
          parameter's current runnable. Not a continuation (no return value).`,
      code: function(pipelineBuilder) {
        this.delegates = this.delegates.concat([ pipelineBuilder ]);
        pipelineBuilder.parents = pipelineBuilder.parents.concat([ this ]);
      }
    },
    {
      name: 'build',
      documentation: `Build the entire pipeline, allowing multiple heads.`,
      returns: {
        typeName: 'Array[foam.box.Box]',
        documentation: `Input boxes accepting messages containing the inputTypes
            of each head's runnable. Boxes are in the order they first()ed to
            the merge points in the pipeline.`
      },
      code: function() {
        var ret = this.build_();
        if ( this.parents.length === 0 ) return ret;

        // Flatten arrays of heads build_()ing backwards in the pipeline.
        this.parents.map(function(parent) { return parent.build(); })
            .reduce(function(acc, v) { return acc.concat(v); }, []);

        return ret;
      }
    },
    function build_() {
      if ( this.builtInputBox_ ) return this.builtInputBox_;

      // Build forward, just in case build() was initiated in the middle of a
      // pipeline. NOTE: This is incompatible with circular pipelines.
      this.delegates.map(function(delegate) { return delegate.build_(); });

      if ( this.builtInputBox_ ) return this.builtInputBox_;

      var pl = this.pipeline;
      var onRegisteredBox = this.RPCReturnBox.create();
      var onRegisteredPromise = onRegisteredBox.promise;
      this.registry.send(this.Message.create({
        object: this.RPCMessage.create({
          name: 'register',
          args: [ null, null, pl.localInput ]
        }),
        attributes: {
          replyBox: onRegisteredBox,
          errorBox: pl.errorBox
        }
      }));
      pl.remoteInput.delegate = onRegisteredPromise;

      // Accept input objects as input; return box that will wrap them in RPCs
      // to runnable.
      return this.builtInputBox_ = this.RunnableRPCBox.create({
        delegate: pl.remoteInput,
        errorBox: pl.errorBox
      });
    }
  ]
});
/**
 * @license
 * Copyright 2017 The FOAM Authors. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

foam.CLASS({
  package: 'foam.box.pipeline',
  name: 'PipelineBuilder',

  documentation: `Simplified builder pattern for constructing pipeliens.

    E.g.,

    var merge1 = PipelineBuilder.create().append(mergeRunnable1);
    var merge2 = PipelineBuilder.create().append(mergeRunnable2);
    var sharedAndF1 = PipelineBuilder.create().append(sharedRunnable);
    var f2 = sharedAndF1.fork(forkRunnable2);

    sharedAndF1.append(forkRunnable1);
    merge1.append(sharedAndF1);
    merge2.append(sharedAndF1);

    var inputBoxForMerge1 = merge1.build();
    var inputBoxForMerge2 = merge2.build();
    // Yields input boxes for mergeRunnable1 and mergeRunnable2
    // on pipeline:
    //
    // mergeRunnable1 --                       -- forkRunnable1
    //                  >-- sharedRunnable -- <
    // mergeRunnable2 --                       -- forkRunnable2`,

  requires: [
    'foam.box.Runnable',
    'foam.box.pipeline.PipelineManager'
  ],

  properties: [
    {
      class: 'FObjectProperty',
      of: 'foam.box.pipeline.PipelineManager',
      name: 'head_',
      value: null
    },
    {
      class: 'FObjectProperty',
      of: 'foam.box.pipeline.PipelineManager',
      name: 'tail_',
      value: null
    }
  ],

  methods: [
    function append(o) {
      if ( this.Runnable.isInstance(o) )
        return this.appendRunnable_(o);
      else if ( this.cls_.isInstance(o) )
        return this.appendPipeline_(o);

      throw new Error('Pipeline: Do not know how to append ' + o.toString());
    },
    function fork(o) {
      var ret = this.cls_.create(null, this.__subContext__).append(o);
      this.tail_.bind(ret.head_);
      return ret;
    },
    function build() {
      return this.head_.build();
    },
    function appendRunnable_(runnable) {
      if ( ! this.head_ ) {
        this.head_ = this.tail_ = this.PipelineManager.create().then(runnable);
        return this;
      }

      this.tail_ = this.tail_.then(runnable);
      return this;
    },
    function appendPipeline_(pipeline) {
      this.tail_.bind(pipeline.head_);
      // Don't use clone(); shallow copy.
      return this.cls_.create({
        head_: this.head_ || pipeline.head_,
        tail_: pipeline.tail_
      }, this.__subContext__);
    }
  ]
});
/**
 * @license
 * Copyright 2016 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
Async functions compose other asynchronous functions that return promises.

<p>One key to using these functions is to note that they return a function
that does the real work, so calling foam.async.sequence(myFuncArray),
for instance, doesn't create a promise or call any of the functions passed
to it. It instead sets up and returns a function that will return a promise
and evaluate arguments as needed.

<p>To use the returned function, pass it to a Promise.then call:
<pre>Promise.resolve().then(foam.async.sequence( [ fn1, fn2 ] ));</pre>
<p>Or create a new promise:
<pre>var p = new Promise(foam.async.sequence( [ fn1, fn2 ] ));</pre>

<p>Async functions can also be nested:
<pre>
var seq = foam.async.sequence([
  foam.async.log("Starting..."),
  foam.async.repeat(10, foam.async.sequence([
    function(i) { console.log("iteration", i); }),
    foam.async.sleep(1000)
  ])
]);
Promise.resolve().then(seq).then(foam.async.log("Done!"));
</pre>
 */
foam.LIB({
  name: 'foam.async',

  methods: [
    function sequence(s) {
      /** Takes an array of functions (that may return a promise) and runs
        them one after anther. Functions that return a promise will have that
        promise chained, such that the next function will not run until the
        previous function's returned promise is resolved.

        <p>Errors are not handled, so chain any desired error handlers
        onto the promise returned.

        <p>You can use sequence's returned function directly in a then call:
        <pre>promise.then(foam.async.sequence(...));</pre>
        <p>Or call it directly:
        <pre>(foam.async.sequence(...))().then(...);</pre>

        @param {Array} s An array of functions that return Promises
        @returns {Function}  A function that returns a promise that will
                       resolve after the last function's return is resolved.
      */
      return function() {
        if ( ! s.length ) return Promise.resolve();

        var p = Promise.resolve();
        for ( var i = 0; i < s.length; ++i ) {
          p = p.then(s[i]);
        }
        return p;
      }
    },

    function repeat(times, fn) {
      /** Takes a function (that may return a promise) and runs it multiple
        times. A function that returns a promise will have that
        promise chained, such that the next call will not run until the
        previous call's returned promise is resolved. The function passed in
        will be called with one argument, the number of the iteration, from
        0 to times - 1.

        <p>Errors are not handled, so chain any desired error handlers
        onto the promise returned.

        <p>You can use repeat's returned function directly in a then call:
        <pre>promise.then(foam.async.repeat(...));</pre>
        <p>Or call it directly:
        <pre>(foam.async.repeat(...))().then(...);</pre>

        @param {Number} times number of times to repeat in sequence.
        @param {Function} fn Function that returns a Promise.
        @returns {Function}  A function that returns a Promise that will resolve
                       after the last repetition's return resolves.
      */
      return function() {
        var p = Promise.resolve();
        var n = 0;
        for ( var i = 0; i < times; ++i ) {
          p = p.then(function() { return fn(n++); });
        }
        return p;
      };
    },

    /**
      Takes a function (that may return a promise) and runs it multiple
      times in parallel. A function that returns a promise will have that
      promise chained, such that the entire group will not resolve until
      all returned promises have resolved (as in the standard Promise.all);
      The function passed in
      will be called with one argument, the number of the iteration, from
      0 to times - 1.

      <p>Errors are not handled, so chain any desired error handlers
      onto the promise returned.

      <p>You can use repeatParallel's returned function directly in a then call:
      <pre>promise.then(foam.async.repeatParallel(...));</pre>
      <p>Or call it directly:
      <pre>(foam.async.repeatParallel(...))().then(...);</pre>


      @param {Number} times number of times to repeat in sequence.
      @param {Function} fn Function that returns a Promise.
      @returns {Function}  A function that returns a Promise that will resolve
                   after every repetition's return resolves
    */
    function repeatParallel(times, fn) {
      return function() {
        var promises = [];
        for ( var i = 0; i < times; ++i ) {
          promises[i] = fn(i); // TODO: what if not returned a promise?
        }
        return Promise.all(promises);
      };
    },

    function log() {
      /** Returns a function you can pass to a .then call, or other foam.async
        functions. Takes variable arguments that are passed to console.log. */
      var args = arguments;
      return function() {
        console.log.apply(console, args);
        return Promise.resolve();
      };
    },

    function sleep(/* Number */ time) {
      /** Returns a function that returns a promise that delays by the given
        time before resolving. */
      return function() {
        return new Promise(function(resolve, reject) {
          setTimeout(function() { resolve(); }, time);
        });
      };
    }
  ]
});
/**
 * @license
 * Copyright 2017 The FOAM Authors. All Rights Reserved.
 * http://www.apache.org/licenses/LICENSE-2.0
 */

foam.CLASS({
  package: 'foam.dao',
  name: 'ClientSink',
  implements: [ 'foam.dao.Sink' ],
  properties: [
    {
      class: 'Stub',
      of: 'foam.dao.Sink',
      name: 'delegate',
      notifications: [ 'put', 'remove', 'eof', 'error', 'reset' ]
    }
  ]
});
/**
 * @license
 * Copyright 2016 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

foam.CLASS({
  package: 'foam.u2',
  name: 'ViewFactory',
  extends: 'foam.core.Property',

  documentation: 'Set a ViewFactory to be a string containing a class name, ' +
      'a Class object, or a factory function(args, context). this.myFactory ' +
      'is the original value, but you can call this.myFactory$f(args, ctx) ' +
      'to create an instance. Useful for rowViews and similar.',

  methods: [
    function installInProto(proto) {
      this.SUPER(proto);

      var name = this.name;

      proto[name + '$f'] = function(args, ctx) {
        console.warn('Deprecated use of ViewFactory; use ViewSpec instead!');
        ctx = ctx || this;
        var raw = this[name];

        if ( typeof raw === 'function' ) {
          return raw.call(this, args, ctx);
        }

        if ( typeof raw === 'string' ) {
          return ctx.lookup(raw).create(args, ctx);
        }

        return raw.create(args, ctx);
      };
    }
  ]
});
/**
 * @license
 * Copyright 2016 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

foam.CLASS({
  package: 'foam.u2',
  name: 'DAOList',
  extends: 'foam.u2.Element',

  topics: [ 'rowClick' ],

  exports: [
    'selection',
    'hoverSelection'
  ],

  imports: [
    'editRecord?',
    'selection? as importSelection'
  ],

  properties: [
    {
      class: 'foam.dao.DAOProperty',
      name: 'data'
    },
    {
      class: 'foam.u2.ViewSpec',
      name: 'rowView'
    },
    {
      // deprecated
      class: 'foam.u2.ViewFactory',
      name: 'rowFactory'
    },
    'selection',
    'hoverSelection'
  ],

  methods: [
    function initE() {
      var view = this;
      this.
        addClass(this.myClass()).
        select(this.data$proxy, function(obj) {
          return ( this.rowView ?
                       foam.u2.ViewSpec.createView(this.rowView, { data: obj }, this, this.__subSubContext__) :
                       this.rowFactory$f({ data: obj }) ).
              on('mouseover', function() { view.hoverSelection = obj; }).
              on('click', function() {
                view.selection = obj;
                if ( view.importSelection$ ) view.importSelection = obj;
                if ( view.editRecord$ ) view.editRecord(obj);
                view.rowClick.pub(obj)
              }).
              addClass(this.slot(function(selection) {
                if ( obj === selection ) return view.myClass('selected');
                  return '';
              }, view.selection$));
        });
    }
  ]
});

foam.CLASS({
  refines: 'foam.dao.RelationshipDAO',

  requires: [
    'foam.u2.CitationView',
    'foam.u2.DAOList'
  ],

  methods: [
    function toE(args, ctx) {
      args = args || {};
      args.data = this;
      args.rowView = this.CitationView;
      return this.DAOList.create(args, ctx);
    }
  ]

})
/**
 * @license
 * Copyright 2016 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

foam.CLASS({
  package: 'foam.u2',
  name: 'TableCellPropertyRefinement',
  refines: 'foam.core.Property',

  properties: [
    {
      name: 'columnLabel',
      factory: function() {
        return this.label;
      }
    },
    {
      name: 'tableCellView',
      value: function(obj) {
        return obj[this.name];
      }
    }
  ]
});


foam.CLASS({
  package: 'foam.u2',
  name: 'TableCellActionRefinement',
  refines: 'foam.core.Action',

  properties: [
    {
      class: 'String',
      name: 'columnLabel'
    },
    {
      name: 'tableCellView',
      value: function(obj, e) {
        //       return foam.u2.ActionView.create({action: this, data: obj});

        return this.toE(null, e.__subContext__.createSubContext({data: obj}));
      }
    }
  ]
});


foam.CLASS({
  package: 'foam.u2',
  name: 'TableBody',
  extends: 'foam.u2.Element',

  requires: [
    // TODO(braden): This should implement Expressions instead.
    'foam.mlang.predicate.And',
    'foam.mlang.predicate.Eq',
    'foam.mlang.predicate.Not',
    'foam.mlang.predicate.Or',
    'foam.u2.CheckBox',
    'foam.u2.TableCellRefinement'
  ],

  imports: [
    'selectionQuery', // Optional. Installed by the TableSelection decorator.
    'tableView'
  ],

  properties: [
    [ 'nodeName', 'tbody' ],
    [ 'columns_' ],
    'selectionFeedback_',
    {
      name: 'rows_',
      factory: function() { return {}; }
    }
  ],

  methods: [
    function initE() {
      var self = this;
      this.on('click', function(event) {
        var obj = self.eToObj(event);
        if ( obj ) self.tableView.selection = obj;
      }).
      on('dblclick', function(event) {
        var obj = self.eToObj(event);
        if ( obj ) 1;
      });
    },

    function eToObj(event) {
      /** Find the object associated with a DOM element. **/
      var me = this.el();
      var e = event.target;
      while ( e.nodeName !== 'TR' && e !== me )
        e = e.parentNode;

      // If we managed to click between rows, do nothing.
      if ( e === me ) return;

      // Otherwise, we found the tr.
      return this.rows_[e.id];
    },

    function addObj(obj) {
      var e = this.start('tr')
          .enableClass(this.tableView.myClass('selected'),
              this.tableView.selection$.map(function(sel) {
                return sel === obj;
              }));

      if ( this.selectionQuery$ ) {
        var cb;
        e.start('td')
            .start(this.CheckBox).call(function() { cb = this; }).end()
        .end();

        this.selectionQuery$.sub(foam.Function.bind(this.selectionUpdate, this,
            cb, obj));
        this.selectionUpdate(cb, obj);
        cb.data$.sub(foam.Function.bind(this.selectionClick, this, obj));
      }

      for ( var j = 0 ; j < this.columns_.length ; j++ ) {
        var prop = this.columns_[j];
        e = e.start('td').add(prop.tableCellView(obj, e)).end();
      }
      e.end();
      this.rows_[e.id] = obj;
    }
  ],

  listeners: [
    {
      name: 'selectionUpdate',
      code: function(checkbox, obj) {
        var selected = this.selectionQuery.f(obj);
        if ( selected !== checkbox.data ) {
          // Need to prevent feedback between these two listeners.
          this.selectionFeedback_ = true;
          checkbox.data = selected;
          this.selectionFeedback_ = false;
        }
      }
    },
    {
      name: 'selectionClick',
      code: function(obj, _, __, ___, slot) {
        if ( this.selectionFeedback_ ) return;

        var q = this.Eq.create({ arg1: obj.ID, arg2: obj.id });
        if ( slot.get() ) {
          this.selectionQuery = this.Or.create({
            args: [ q, this.selectionQuery ]
          }).partialEval();
        } else {
          this.selectionQuery = this.And.create({
            args: [ this.Not.create({ arg1: q }), this.selectionQuery ]
          }).partialEval();
        }
      }
    }
  ]
});


foam.CLASS({
  package: 'foam.u2',
  name: 'TableBodySink',
  extends: 'foam.dao.AbstractSink',

  requires: [
    'foam.u2.TableBody'
  ],

  properties: [
    'columns_',
    {
      name: 'body',
      factory: function() { return this.TableBody.create({ columns_: this.columns_ }); }
    }
  ],
  methods: [
    function put(obj) {
      this.body.addObj(obj);
    }
  ]
});


foam.CLASS({
  package: 'foam.u2',
  name: 'TableHeader',
  extends: 'foam.u2.Element',

  requires: [
    'foam.mlang.order.Desc',
    'foam.u2.Entity'
  ],

  imports: [
    'selectionQuery', // Optional. Exported by TableSelection.
    'tableView'
  ],

  properties: [
    {
      name: 'columns_',
      required: true
    },
    'sortOrder'
  ],

  methods: [
    function initE() {
      var self = this;
      this.nodeName = 'thead';

      var e = this.start('tr');
      if ( this.selectionQuery$ ) {
        e.tag('td');
      }

      for ( var i = 0 ; i < this.columns_.length ; i++ ) {
        var sorting$ = this.sortOrder$.map(function(prop, order) {
          if ( ! order ) return '';
          var desc = this.Desc.isInstance(order);
          var baseOrder = desc ? order.arg1 : order;
          return prop.name === baseOrder.name ?
              this.Entity.create({ name: desc ? 'darr' : 'uarr' }) : '';
        }.bind(this, this.columns_[i]));

        e.start('td')
            .enableClass(this.myClass('sorting'), sorting$)
            .start('span')
                .addClass(this.myClass('sort-direction'))
                .add(sorting$)
            .end()
            .add(this.columns_[i].columnLabel)
            .on('click', this.tableView.sortBy.bind(this.tableView, this.columns_[i]))
            .end();
      }
      e.end();
    }
  ]
});


foam.CLASS({
  package: 'foam.u2',
  name: 'TableView',
  extends: 'foam.u2.Element',

  requires: [
    'foam.mlang.order.Desc',
    'foam.u2.TableBodySink',
    'foam.u2.TableHeader'
  ],

  exports: [
    'as tableView'
  ],

  css: `
    ^sorting {
      font-weight: bold;
    }

    ^sort-direction {
      display: none;
      margin-right: 8px;
    }
    ^sorting ^sort-direction {
      display: initial;
    }
  `,

  properties: [
    {
      class: 'Class',
      name: 'of',
      factory: function() { return this.data.of; }
    },
    [ 'nodeName', 'table' ],
    {
      name: 'columns_',
      expression: function(columns, of) {
        var cls = this.of;
        return columns.map(function(p) {
          // Lookup String values as Axiom names, otherwise,
          // treat the object as the column object itself.
          return typeof p === 'string' ?
              cls.getAxiomByName(p) :
              p ;
        });
      }
    },
    {
      // TODO: remove when all code ported
      name: 'properties',
      setter: function(_, ps) {
        console.warn("Deprecated use of TableView.properties. Use 'columns' instead.");
        this.columns = ps;
      }
    },
    {
      name: 'columns',
      expression: function(of) {
        if ( ! this.of ) return [];

        var tableColumns = this.of.getAxiomByName('tableColumns');

        if ( tableColumns ) return tableColumns.columns;

        return this.of.getAxiomsByClass(foam.core.Property)
            .filter(function(p) { return ! p.hidden; })
            .map(foam.core.Property.NAME.f);
      }
    },
    {
      name: 'config'
      // Map of property-name: {map of property overrides} for configuring properties
      // values include 'label', 'units', and 'view'
    },
    {
      class: 'foam.dao.DAOProperty',
      name: 'data'
    },
    {
      name: 'header',
      expression: function(columns_) {
        return this.TableHeader.create({
          columns_: columns_,
          sortOrder$: this.sortOrder$
        });
      }
    },
    {
      name: 'body',
      factory: function() { return this.E('tbody'); }
    },
    {
      name: 'sortOrder'
    },
    {
      name: 'selection'
    }
  ],

  methods: [
    function init() {
      this.SUPER();

      console.log('Deprecated use of foam.u2.TableView. Use foam.u2.view.TableView instead.');
    },

    function initE() {
      // Configure columns if 'config' set.
      if ( this.config ) {
        for ( var i = 0 ; i < this.columns_.length ; i++ ) {
          var col = this.columns_[i];
          var cfg = this.config[col.name];

          if ( cfg ) this.columns_[i] = col.clone().copyFrom(cfg);
        }
      }

      this.onDAOUpdate();
      this.data$proxy.sub('on', this.onDAOUpdate);

      return this.
          addClass(this.myClass()).
          add(this.header$, this.body$);
    },

    function sortBy(prop) {
      // Two cases: same as the current prop, or different.
      var sortName = this.sortOrder ?
          (this.Desc.isInstance(this.sortOrder) ? this.sortOrder.arg1.name :
              this.sortOrder.name) :
          '';
      if ( sortName === prop.name ) {
        // Invert the previous order.
        this.sortOrder = this.Desc.isInstance(this.sortOrder) ?
            prop : this.Desc.create({ arg1: prop });
      } else {
        // Set it to the new column.
        this.sortOrder = prop;
      }
      this.onDAOUpdate();
    }
  ],

  listeners: [
    {
      name: 'onDAOUpdate',
      isFramed: true,
      code: function() {
        var dao = this.data;
        if ( this.sortOrder ) {
          dao = dao.orderBy(this.sortOrder);
        }
        dao.select(this.TableBodySink.create({
          columns_: this.columns_
        })).then(function(a) {
          this.body = a.body;
        }.bind(this));
      }
    }
  ]
});
/**
 * @license
 * Copyright 2016 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

foam.CLASS({
  package: 'foam.u2',
  name: 'TableSelection',
  extends: 'foam.u2.Element',

  requires: [
    'foam.dao.ArraySink',
    'foam.mlang.predicate.False',
    'foam.mlang.predicate.In',
    'foam.mlang.predicate.Or',
    'foam.mlang.predicate.Not',
    'foam.mlang.sink.Count',
    'foam.mlang.sink.Map',
    'foam.u2.TableView'
  ],

  imports: [
    'unfilteredDAO'
  ],

  exports: [
    'bulkActions',
    'selectionQuery'
  ],

  properties: [
    {
      name: 'data',
      postSet: function(old, nu) {
        if ( this.daoSub_ ) {
          this.daoSub_.detach();
          this.daoSub_ = null;
        }
        if ( nu ) this.daoSub_ = nu.on.sub(this.updateCounts);
        this.updateCounts();
      }
    },
    'daoSub_',
    {
      class: 'Class',
      name: 'of',
      expression: function(data) { return data.of; }
    },
    {
      name: 'selectionQuery',
      factory: function() { return this.False.create(); }
    },
    'filteredCount_',
    'totalCount_',
    {
      class: 'String',
      name: 'selectionText_',
      expression: function(filteredCount_, totalCount_) {
        if ( ! totalCount_ ) return '';
        var s = (totalCount_ || '0') + ' selected';
        if ( totalCount_ !== filteredCount_ ) {
          s += ' (' + (filteredCount_ || '0') + ' shown)';
        }
        return s;
      }
    },
    'selectAllState',
    {
      class: 'FObjectArray',
      of: 'Action',
      name: 'bulkActions'
    },
    {
      class: 'foam.u2.ViewSpec',
      name: 'view',
      value: { class: 'foam.u2.TableView' }
    }
  ],

  methods: [
    function initE() {
      var self = this;
      this.start()
          .start('div')
              .add('Select')
              .start('a')
                  .attrs({ href: 'javascript:' })
                  .on('click', this.selectAll)
                  .addClass(this.myClass('link'))
                  .add('All')
              .end()
              .start('a')
                  .attrs({ href: 'javascript:' })
                  .on('click', this.selectNone)
                  .addClass(this.myClass('link'))
                  .add('None')
              .end()
          .end()
          .start('span').add(this.selectionText_$).end()
          .start()
              .addClass(this.myClass('actions'))
              .add(this.bulkActions)
          .end()
      .end()
      .start(this.view, {
        of: this.of,
        data$: this.data$
      }).end();

      this.selectionQuery$.sub(this.updateCounts);
    }
  ],

  listeners: [
    {
      name: 'selectNone',
      isFramed: true,
      code: function() {
        this.selectionQuery = this.False.create();
      }
    },
    {
      name: 'selectAll',
      isFramed: true,
      code: function() {
        var self = this;
        this.data.select(this.Map.create({
          arg1: this.of.ID,
          delegate: this.ArraySink.create()
        })).then(function(array) {
          var q = self.In.create({
            arg1: self.of.ID,
            arg2: array.delegate.a
          });

          self.selectionQuery = self.Or.create({
            args: [ self.selectionQuery, q ]
          }).partialEval();
        });
      }
    },
    {
      name: 'updateCounts',
      isFramed: true,
      code: function() {
        var self = this;
        this.unfilteredDAO.where(this.selectionQuery)
            .select(this.Count.create())
            .then(function(c) { self.totalCount_ = c.value; });
        this.data.where(this.selectionQuery)
            .select(this.Count.create())
            .then(function(c) { self.filteredCount_ = c.value; });
      }
    }
  ],

  axioms: [
    foam.u2.CSS.create({
      code: function CSS() {/*
        ^link {
          color: #00c;
          margin: 0 8px;
          text-decoration: none;
        }
      */}
    })
  ]
});
/**
 * @license
 * Copyright 2016 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

foam.CLASS({
  package: 'foam.u2',
  name: 'Scroller',
  extends: 'foam.u2.Element',

  /**
   * Wraps a TableView or similar and adds a ScrollView to it.
   * Configure the table view with the tableView property, and the scrollbar
   * with the scrollView property.
   * Set data to the DAO, and the tableView will receive that DAO with skip
   * applied correctly.
   *
   * This view needs to know the size of its container, in order to size the
   * tableView and scrollbar accordingly. Therefore it needs a fixed row height
   * to use for the table. Set rowHeight to the number of pixels per row.
   */
  requires: [
    'foam.graphics.Canvas',
    'foam.graphics.ScrollCView',
    'foam.mlang.sink.Count',
    'foam.u2.TableView',
    'foam.u2.ViewSpec'
  ],

  imports: [
    'window'
  ],

  css: `
    ^ {
      display: flex;
      flex-grow: 1;
      overflow: hidden;
    }
    ^container {
      flex-grow: 1;
      overflow-x: auto;
      overflow-y: hidden;
    }
    ^ canvas {
      align-self: flex-start;
      flex-grow: 0;
      flex-shrink: 0;
    }
  `,

  properties: [
    {
      name: 'of',
      expression: function(data) { return data.of; }
    },
    {
      class: 'foam.dao.DAOProperty',
      name: 'data',
      required: true
    },
    {
      class: 'Int',
      name: 'rowHeight',
      value: 36
    },
    {
      class: 'foam.u2.ViewSpec',
      name: 'tableView',
      value: { class: 'foam.u2.TableView' }
    },
    {
      class: 'foam.u2.ViewSpec',
      name: 'scrollView',
      value: { class: 'foam.graphics.ScrollCView' }
    },
    {
      /** The actual TableView instance. */
      name: 'table'
    },
    {
      /** The actual ScrollCView instance. */
      name: 'scrollBar'
    },
    'scrollValue_',
    'scrollHeight_',
    'scrollExtent_',
    'pointer'
  ],

  methods: [
    function initE() {
      var self = this;

      this.data$proxy.sub('on', this.onDAOUpdate);
      this.onDAOUpdate();

      this.scrollBar = this.createChild_(this.scrollView, {
        value$:  this.scrollValue_$,
        extent$: this.scrollExtent_$,
        height$: this.scrollHeight_$
      });

      this.addClass(this.myClass())
          .start()
              .addClass(this.myClass('container'))
              .call(function() { self.table = this; })
              .start(this.tableView, {
                of: this.of,
                data$: this.slot(function(dao, extent, value) {
                  return dao.limit(extent).skip(value);
                }, this.data$, this.scrollExtent_$, this.scrollValue_$)
              }).end()
          .end()
          .start(this.Canvas)
              .attrs({ height: this.scrollHeight_$ })
              .call(function() { this.cview = self.scrollBar; })
          .end()
          .on('wheel', function(e) {
            var negative = e.deltaY < 0;
            // Convert to rows, rounding up. (Therefore minumum 1.)
            var rows = Math.ceil(Math.abs(e.deltaY) / self.rowHeight);
            self.scrollValue_ += negative ? -rows : rows;
          });

      this.onload.sub(function() {
        self.onResize();
        self.window.addEventListener('resize', self.onResize);
      });

      this.onunload.sub(function() {
        self.window.removeEventListener('resize', self.onResize);
      });
    }
  ],

  listeners: [
    {
      name: 'onResize',
      isFramed: true,
      code: function() {
        if ( ! this.el() ) return;

        // Determine the height of the table's space.
        var height = this.el().getBoundingClientRect().height;
        this.scrollHeight_ = height;
        this.scrollExtent_ = Math.floor(height / this.rowHeight);
      }
    },
    {
      name: 'onDAOUpdate',
      isFramed: true,
      code: function() {
        var self = this;
        this.data.select(this.Count.create()).then(function(c) {
          self.scrollBar.size = c.value;
        });
      }
    }
  ]
});
/**
 * @license
 * Copyright 2016 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

foam.CLASS({
  package: 'foam.u2',
  name: 'ActionView',
  extends: 'foam.u2.UnstyledActionView',

  css: `
    button^ {
      -webkit-box-shadow: inset 0 1px 0 0 #ffffff;
      box-shadow: inset 0 1px 0 0 #ffffff;
      background: -webkit-gradient( linear, left top, left bottom, color-stop(0.05, #ededed), color-stop(1, #dfdfdf) );
      background: -moz-linear-gradient( center top, #ededed 5%, #dfdfdf 100% );
      background-color: #ededed;
      -moz-border-radius: 3px;
      -webkit-border-radius: 3px;
      border-radius: 3px;
      border: 1px solid #dcdcdc;
      display: inline-block;
      color: #777777;
      font-family: Arial;
      font-size: 12px;
      font-weight: bold;
      margin: 2px;
      padding: 4px 16px;
      text-decoration: none;
    }

    ^unavailable {
      display: none;
    }

    ^:hover {
      background: -webkit-gradient( linear, left top, left bottom, color-stop(0.05, #dfdfdf), color-stop(1, #ededed) );
      background: -moz-linear-gradient( center top, #dfdfdf 5%, #ededed 100% );
      background-color: #dfdfdf;
    }

    ^ img {
      vertical-align: middle;
    }

    ^:disabled { filter: grayscale(80%); }

    ^.material-icons {
      cursor: pointer;
    }
  `,

  properties: [
    {
      class: 'Boolean',
      name: 'showLabel',
      expression: function(icon, iconFontName ) { return ! ( icon || iconFontName); }
    },
    {
      class: 'URL',
      name: 'icon',
      factory: function(action) { return this.action.icon; }
    },
    {
      class: 'String',
      name: 'iconFontFamily',
      factory: function(action) { return this.action.iconFontFamily; }
    },
    {
      class: 'String',
      name: 'iconFontClass',
      factory: function(action) { return this.action.iconFontClass; }
    },
    {
      class: 'String',
      name: 'iconFontName',
      factory: function(action) { return this.action.iconFontName; }
    },
    'data',
    'action',
    [ 'nodeName', 'button' ],
    {
      name: 'label',
      factory: function(action) { return this.action.label; }
    }
  ],

  methods: [
    function initE() {
      this.initCls();

      this.
        on('click', this.click);

      if ( this.icon ) {
        // this.nodeName = 'a';
        this.start('img').attr('src', this.icon).end();
      } else if ( this.iconFontName ) {
        this.nodeName = 'i';
        this.cssClass(this.action.name);
        this.cssClass(this.iconFontClass); // required by font package
        this.style({'font-family': this.iconFontFamily});
        this.add(this.iconFontName);
      }

      if ( this.showLabel ) {
        this.add(this.label$);
      }

      this.setAttribute('title', this.action.toolTip); // hover text

      if ( this.action ) {
        if ( this.action.isAvailable ) {
          this.enableClass(this.myClass('unavailable'), this.action.createIsAvailable$(this.data$), true);
        }

        if ( this.action.isEnabled ) {
          this.attrs({disabled: this.action.createIsEnabled$(this.data$).map(function(e) { return e ? false : 'disabled'; })});
        }
      }
    },

    function initCls() {
      this.addClass(this.myClass());
      this.addClass(this.myClass(this.action.name));
    }
  ],

  listeners: [
    function click(e) {
      e.stopPropagation();
      e.preventDefault();
      this.action && this.action.maybeCall(this.__subContext__, this.data);
    }
  ]
});
/**
 * @license
 * Copyright 2016 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
foam.CLASS({
  package: 'foam.u2.md',
  name: 'ActionView',
  extends: 'foam.u2.Element',

  axioms: [
    foam.u2.CSS.create({
      code: function CSS() {/*
        ^unavailable {
          display: none;
        }
      */}
    })
  ],

  properties: [
    'data',
    'action',
    {
      class: 'Boolean',
      name: 'raised',
      documentation: 'Controls the "raised" attribute in Polymer. Defaults ' +
          'to false; set this to true for a raised, bordered button.'
    },
    {
      name: 'label',
      expression: function(action) { return action.label; }
    }
  ],

  methods: [
    function initE() {
      this.nodeName = 'paper-button';
      this.addClass(this.myClass())
          .attrs({ raised: this.raised$ })
          .on('click', this.click)
          .add(this.label$);

      if ( this.action.isAvailable ) {
        this.enableClass(this.myClass('unavailable'),
              this.action.createIsAvailable$(this.data$), true /* negate */);
      }

      if ( this.action.isEnabled ) {
        this.attrs({
          disabled: this.action.createIsEnabled$(this.data$).map(function(e) {
            return e ? false : 'disabled';
          })
        });
      }
    }
  ],

  listeners: [
    function click() {
      this.action.maybeCall(this.__subContext__, this.data);
    }
  ]
});
/**
 * @license
 * Copyright 2016 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

foam.CLASS({
  package: 'foam.u2',
  name: 'UnstyledActionView',
  extends: 'foam.u2.Element',

  documentation: function() {`
    A button View for triggering Actions.

    Icon Fonts
    If using icon-fonts a css stylesheet link to the fonts is required in index.html.
    The default of foam.core.Action.js is 'Material Icons' supported by the following
    link: <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet"></link>
  `},

  enums: [
    {
      name: 'ButtonState',

      values: [
        { name: 'NO_CONFIRM' }, // No confirmation required, fire on click
        { name: 'CONFIRM' },    // Confirmation required, debounce on click
        { name: 'DEBOUNCE' },   // Move to Armed after delay, NOP on click
        { name: 'ARMED' }       // Waiting for confirmation, fire on click
      ]
    }
  ],

  messages: [
    { name: 'confirm', message: 'Confirm' }
  ],

  properties: [
    {
      class: 'Boolean',
      name: 'showLabel',
      expression: function(icon, iconFontName ) { return ! ( icon || iconFontName); }
    },
    {
      class: 'URL',
      name: 'icon',
      factory: function(action) { return this.action.icon; }
    },
    {
      class: 'String',
      name: 'iconFontFamily',
      factory: function(action) { return this.action.iconFontFamily; }
    },
    {
      class: 'String',
      name: 'iconFontClass',
      factory: function(action) { return this.action.iconFontClass; }
    },
    {
      class: 'String',
      name: 'iconFontName',
      factory: function(action) { return this.action.iconFontName; }
    },
    {
      class: 'String',
      name: 'labelPlaceholder',
      expression: function(label) { return this.action.label; }
    },
    {
      name: 'buttonState',
      factory: function() { return this.action && this.action.confirmationRequired ? this.ButtonState.CONFIRM : this.ButtonState.NO_CONFIRM; }
    },
    'data',
    'action',
    [ 'nodeName', 'button' ],
    {
      name: 'label',
      factory: function(action) { return this.action.label; }
    }
  ],

  methods: [
    function initE() {
      this.initCls();

      this.
        on('click', this.click);

      this.addContent();

      this.setAttribute('title', this.action.toolTip); // hover text

      if ( this.action ) {
        if ( this.action.isAvailable ) {
          this.enableClass(this.myClass('unavailable'), this.action.createIsAvailable$(this.data$), true);
        }

        if ( this.action.isEnabled ) {
          this.attrs({disabled: this.action.createIsEnabled$(this.data$).map(function(e) { return e ? false : 'disabled'; })});
        }
      }
    },

    function initCls() {
      this.addClass(this.myClass());
      this.addClass(this.myClass(this.action.name));
    },

    function addContent() {
      /** Add text or icon to button. **/
      if ( this.icon ) {
        // this.nodeName = 'a';
        this.start('img').attr('src', this.icon).end();
      } else if ( this.iconFontName ) {
        this.nodeName = 'i';
        this.cssClass(this.action.name);
        this.cssClass(this.iconFontClass); // required by font package
        this.style({'font-family': this.iconFontFamily});
        this.add(this.iconFontName);
      }

      if ( this.showLabel ) {
        this.add(this.label$);
      }
    }
  ],

  listeners: [
    function click(e) {
      if ( this.buttonState == this.ButtonState.NO_CONFIRM ) {
        this.action && this.action.maybeCall(this.__subContext__, this.data);
      }
      else if ( this.buttonState == this.ButtonState.CONFIRM ) {
        this.buttonState = this.ButtonState.DEBOUNCE;
        this.removeAllChildren();
        this.add(this.confirm);
        this.debounce();
      }
      else if ( this.buttonState == this.ButtonState.ARMED ) {
        this.removeAllChildren();
        this.addContent();
        this.action && this.action.maybeCall(this.__subContext__, this.data);
      }

      e.stopPropagation();
    },
    {
      name: 'debounce',
      isMerged: true,
      mergeDelay: 200,
      code: function() {
        this.buttonState = this.ButtonState.ARMED;
        this.deactivateConfirm();
      }
    },
    {
      name: 'deactivateConfirm',
      isMerged: true,
      mergeDelay: 6000,
      code: function() {
        this.removeAllChildren();
        this.addContent();
        this.buttonState = this.ButtonState.CONFIRM;
      }
    }
  ]
});
/**
 * @license
 * Copyright 2015 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

foam.CLASS({
  package: 'foam.u2',
  name: 'DetailPropertyView',
  extends: 'foam.u2.Element',

  documentation: 'View for one row/property of a DetailView.',

  properties: [
    'prop',
    [ 'nodeName', 'tr' ]
  ],

  axioms: [
    foam.u2.CSS.create({code: `
      .foam-u2-PropertyView-label {
        color: #444;
        display: block;
        float: left;
        font-size: 13px;
        padding: 4px 8px 4px 8px;
        text-align: left;
        vertical-align: top;
        white-space: nowrap;
      }
      .foam-u2-PropertyView-view {
        padding: 2px 8px 2px 6px;
      }
      .foam-u2-PropertyView-units  {
        color: #444;
        font-size: 12px;
        padding: 4px;
        text-align: right;
      }
    `})
  ],

  methods: [
    function initE() {
      var prop = this.prop;

      // TODO: hide this element if the prop changes it's mode to HIDDEN.
      this.
        addClass('foam-u2-PropertyView').
        start('td').addClass('foam-u2-PropertyView-label').add(prop.label).end().
        start('td').addClass('foam-u2-PropertyView-view').add(
          prop,
          prop.units && this.E('span').addClass('foam-u2-PropertyView-units').add(' ', prop.units)).
        end();
    }
  ]
});
/**
 * @license
 * Copyright 2015 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

foam.CLASS({
  package: 'foam.u2',
  name: 'DetailView',
  extends: 'foam.u2.View',

  documentation: 'A generic property-sheet style View for editing an FObject.',

  requires: [
    'foam.core.Property',
    'foam.u2.DetailPropertyView'
  ],

  exports: [
    'currentData as data',
    'controllerMode'
  ],

  axioms: [
    foam.pattern.Faceted.create()
  ],

  properties: [
    {
      name: 'data',
      attribute: true,
      preSet: function(_, data) {
        var of = data && data.cls_;
        if ( of !== this.of ) {
          this.of = of;
        } else {
          this.currentData = data;
        }
        return data;
      }
    },
    'currentData',
    {
      class: 'Class',
      name: 'of'
    },
    {
      class: 'Boolean',
      name: 'showActions'
    },
    {
      name: 'properties',
      // TODO: Make an FObjectArray when it validates properly
      preSet: function(_, ps) {
        foam.assert(ps, 'Properties required.');
        for ( var i = 0 ; i < ps.length ; i++ ) {
          foam.assert(
              foam.core.Property.isInstance(ps[i]),
              "Non-Property in 'properties' list:",
              ps);
        }
        return ps;
      },
      expression: function(of) {
        if ( ! of ) return [];
        return this.of.getAxiomsByClass(foam.core.Property).
          // TODO: this is a temporary fix, but Visibility.HIDDEN should be included and could be switched
          filter(function(p) { return ! ( p.hidden || p.visibility === foam.u2.Visibility.HIDDEN ); });
      }
    },
    {
      name: 'config'
      // Map of property-name: {map of property overrides} for configuring properties
      // values include 'label', 'units', and 'view'
    },
    {
      name: 'actions',
      expression: function(of) {
        if ( ! of ) return [];
        return this.of.getAxiomsByClass(foam.core.Action);
      }
    },
    {
      name: 'title',
      attribute: true,
      expression: function(of) { return this.of ? this.of.model_.label : ''; },
      // documentation: function() {/*
      //  <p>The display title for the $$DOC{ref:'foam.ui.View'}.
      //  </p>
      //*/}
    },
    [ 'nodeName', 'div' ]
  ],

  css: `
    ^toolbar {
      padding-top: 4px;
    }
  `,

  /*
  TODO: port old FOAM1 CSS
      ^ {
        background: #fdfdfd;
        border: solid 1px #dddddd;
        box-shadow: 0 3px 6px rgba(0,0,0,0.16), 0 3px 6px rgba(0,0,0,0.23);
        display: inline-block;
        margin: 5px;
        padding: 3px;
      }
      ^ table {
        padding-bottom: 2px;
      }
      ^title {
        color: #333;
        float: left;
        font-size: 14px;
        font-weight: bold;
        margin-bottom: 8px;
        padding: 2px;
      }
      ^toolbar {
        margin-left: 5px;
      }
      ^ input {
        border: solid 1px #aacfe4;
        font-size: 10px;
        margin: 2px 0 0px 2px;
        padding: 4px 2px;
      }
      ^ textarea {
        border: solid 1px #aacfe4;
        float: left;
        font-size: 10px;
        margin: 2px 0 0px 2px;
        overflow: auto;
        padding: 4px 2px;
        width: 191px;
      }
      ^ select {
        border: solid 1px #aacfe4;
        font-size: 10px;
        margin: 2px 0 0px 2px;
        padding: 4px 2px;
      }
  */

  methods: [
    function initE() {
      var self = this;
      this.add(this.slot(function(of, properties, actions) {
        if ( ! of ) return '';

        // Binds view to currentData instead of data because there
        // is a delay from when data is updated until when the UI
        // is rebuilt if the data's class changes. Binding directly
        // to data causes views and actions from the old class to get
        // bound to data of a new class, which causes problems.
        self.currentData = self.data;

        var title = self.title && this.E('tr').
          start('td').addClass(this.myClass('title')).attrs({colspan: 2}).
            add(self.title$).
          end();

        return self.actionBorder(
          this.
            E('table').
            addClass(this.myClass()).
            add(title).
            forEach(properties, function(p) {
              var config = self.config && self.config[p.name];

              if ( config ) {
                p = p.clone();
                for ( var key in config ) {
                  p[key] = config[key];
                }
              }

              this.tag(self.DetailPropertyView, { prop: p });
            }));
      }));
    },

    function actionBorder(e) {
      if ( ! this.showActions || ! this.actions.length ) return e;

      return this.E().add(e).
        start('div').addClass(this.myClass('toolbar')).add(this.actions).end();
    }
  ]
});
/**
 * @license
 * Copyright 2016 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

foam.CLASS({
  package: 'foam.u2.md',
  name: 'DetailView',
  extends: 'foam.u2.DetailView',

  requires: [
    'foam.core.Property'
  ],

  exports: [
    'data'
  ],

  properties: [
    {
      name: 'data',
      postSet: function(old, nu) {
        if ( nu && nu.cls_ !== this.of ) this.of = nu.cls_;
      }
    },
    {
      name: 'of'
    },
    {
      name: 'properties',
      expression: function(of) {
        return of.getAxiomsByClass(foam.core.Property).filter(function(p) {
          return ! p.hidden;
        });
      }
    },
    {
      name: 'title',
      expression: function(of) {
        return of.model_.label;
      }
    },
    [ 'showTitle', true ],
    [ 'nodeName', 'div' ]
  ],

  methods: [
    function initE() {
      this.add(this.properties$);
    }
  ]
});
/**
 * @license
 * Copyright 2016 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

foam.CLASS({
  package: 'foam.u2.tag',
  name: 'Image',
  extends: 'foam.u2.View',

  properties: [
    {
      name: 'displayWidth',
      attribute: true
    },
    {
      name: 'displayHeight',
      attribute: true
    },
    ['alpha', 1.0],
    ['nodeName', 'img']
  ],

  methods: [
    function initE() {
      this.
        attrs({ src: this.data$ }).
        style({
          height:  this.displayHeight$,
          width:   this.displayWidth$,
          opacity: this.alpha$
        });
    }
  ]
});

foam.__context__.registerElement(foam.u2.tag.Image);
/**
 * @license
 * Copyright 2015 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

foam.CLASS({
  package: 'foam.u2.tag',
  name: 'Input',
  extends: 'foam.u2.View',

  css: '^:read-only { border: none; background: rgba(0,0,0,0); }',

  properties: [
    [ 'nodeName', 'input' ],
    {
      name: 'data',
      preSet: function(o, d) {
        var f = ! d || typeof d === 'string' || typeof d === 'number' || typeof d === 'boolean' || foam.Date.isInstance(d);
        if ( ! f ) {
          this.warn('Set Input data to non-primitive:' + d);
          return o;
        }
        return d;
      }
      /*
      assertValue: function(d) {
        foam.assert(! d || typeof d === 'string' || typeof d === 'number' || typeof d === 'boolean' || foam.Date.isInstance(d), 'Set Input data to non-primitive.');
      }*/
    },
    {
      class: 'Boolean',
      name: 'onKey',
      attribute: true,
      // documentation: 'When true, $$DOC{ref:".data"} is updated on every keystroke, rather than on blur.'
    },
    {
      class: 'Int',
      name: 'size'
    },
    {
      class: 'Int',
      name: 'maxLength',
      attribute: true,
      // documentation: 'When set, will limit the length of the input to a certain number'
    },
    'type',
    'placeholder'
  ],

  methods: [
    function initE() {
      this.SUPER();

      if ( this.size          ) this.setAttribute('size',        this.size);
      if ( this.type          ) this.setAttribute('type',        this.type);
      if ( this.placeholder   ) this.setAttribute('placeholder', this.placeholder);
      if ( this.maxLength > 0 ) this.setAttribute('maxlength',   this.maxLength);

      this.initCls();
      this.link();
    },

    function initCls() {
      // Template method, can be overriden by sub-classes
      this.addClass(this.myClass());
    },

    function link() {
      // Template method, can be overriden by sub-classes
      this.attrSlot(null, this.onKey ? 'input' : null).linkFrom(this.data$);
    },

    function updateMode_(mode) {
      // TODO: make sure that DOM is updated if values don't change
      this.setAttribute('readonly', mode === foam.u2.DisplayMode.RO);
      this.setAttribute('disabled', mode === foam.u2.DisplayMode.DISABLED);
    }
  ]
});
/**
 * @license
 * Copyright 2015 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

foam.CLASS({
  package: 'foam.u2.tag',
  name: 'TextArea',
  extends: 'foam.u2.View',

  properties: [
    [ 'nodeName', 'textarea' ],
    {
      class: 'Int',
      name: 'rows',
      value: 4
    },
    {
      class: 'Int',
      name: 'cols',
      value: 60
    },
    {
      class: 'Boolean',
      name: 'onKey',
      attribute: true,
      documentation: 'When true, $$DOC{ref:".data"} is updated on every ' +
          'keystroke, rather than on blur.',
    },
  ],

  methods: [
    function initE() {
      this.SUPER();
      this.addClass(this.myClass());
      this.style({'white-space': 'pre'});
      this.attrs({rows: this.rows, cols: this.cols});

      // This is required because textarea accepts setting the 'value'
      // after it's output, but before requires output to be between
      // the tags when it's first output.
     // this.add((this.data + '').replace(/</g, '&lt;').replace(/>/g, '&gt;'));

      this.attrSlot(
        'value',
        this.onKey ? 'input' : 'change').linkFrom(this.data$);
    },

    function load() {
      // value can't be set before object is created, so set value
      // once loaded
      this.SUPER();
      this.attrs({value: this.data + ''});
    },

    function updateMode_(mode) {
      // TODO: make sure that DOM is updated if values don't change
      this.setAttribute('readonly', mode === foam.u2.DisplayMode.RO);
      this.setAttribute('disabled', mode === foam.u2.DisplayMode.DISABLED);
    }
  ]
});
/**
 * @license
 * Copyright 2015 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

foam.CLASS({
  package: 'foam.u2',
  name: 'TextField',
  extends: 'foam.u2.tag.Input',

  css: `
    input[type="search"] { -webkit-appearance: textfield !important; }
    ^:read-only { border: none; background: rgba(0,0,0,0); }
  `,

  properties: [
    {
      class: 'Int',
      name: 'displayWidth'
    }
  ],

  methods: [
    function fromProperty(prop) {
      this.SUPER(prop);

      if ( ! this.displayWidth ) {
        this.size = this.displayWidth = prop.displayWidth;
      }

      if ( prop.visibility ) {
        this.visibility = prop.visibility;
      }
    }
  ]
});
/**
 * @license
 * Copyright 2015 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

foam.CLASS({
  package: 'foam.u2',
  name: 'IntView',
  extends: 'foam.u2.TextField',

  css: '^:read-only { border: none; background: rgba(0,0,0,0); }',

  properties: [
    [ 'type', 'number' ],
    { class: 'Int', name: 'data' },
    'min',
    'max'
  ],

  methods: [
    function initE() {
      this.SUPER();
      if ( this.min != undefined ) this.setAttribute('min', this.min);
      if ( this.max != undefined ) this.setAttribute('max', this.max);
    },

    function link() {
      this.attrSlot(null, this.onKey ? 'input' : null).linkFrom(this.data$)
    },

    function fromProperty(p) {
      this.SUPER(p);
      this.min = p.min;
      this.max = p.max;
    }
  ]
});
/**
 * @license
 * Copyright 2015 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

foam.CLASS({
  package: 'foam.u2',
  name: 'FloatView',
  extends: 'foam.u2.TextField',

  documentation: 'View for editing Float Properties.',

  css: '^:read-only { border: none; background: rgba(0,0,0,0); }',
   
  properties: [
    [ 'type', 'number' ],
    { class: 'Float', name: 'data' },
    'precision',
    'min',
    'max'
  ],

  methods: [
    function initE() {
      this.SUPER();
      this.addClass(this.myClass());
      if ( this.min != undefined ) this.setAttribute('min', this.min);
      if ( this.max != undefined ) this.setAttribute('max', this.max);
    },

    function link() {
      this.attrSlot(null, this.onKey ? 'input' : null).relateFrom(
          this.data$,
          this.textToData.bind(this),
          this.dataToText.bind(this));
    },

    function fromProperty(p) {
      this.SUPER(p);

      this.precision = p.precision;
      this.min       = p.min;
      this.max       = p.max;
    },

    function formatNumber(val) {
      if ( ! val ) return '0';
      val = val.toFixed(this.precision);
      var i = val.length - 1;
      for ( ; i > 0 && val.charAt(i) === '0' ; i-- ) {}
      return val.substring(0, val.charAt(i) === '.' ? i : i + 1);
    },

    function dataToText(val) {
      return this.precision !== undefined ?
        this.formatNumber(val) :
        '' + val ;
    },

    function textToData(text) {
      return parseFloat(text) || 0;
    }
  ]
});
/**
 * @license
 * Copyright 2017 The FOAM Authors. All Rights Reserved.
 * http://www.apache.org/licenses/LICENSE-2.0
 */

foam.CLASS({
  package: 'foam.u2',
  name: 'CurrencyView',
  extends: 'foam.u2.FloatView',

  documentation: 'View for formatting cents into dollars.',

  axioms: [
    foam.u2.CSS.create({
      code: '^:read-only { border: none; background: rgba(0,0,0,0); }'
    })
  ],

  properties: [
    ['precision', '2']
  ],

  methods: [
    function dataToText(val) {
      return this.SUPER(val / 100);
    },

    function textToData(text) {
      return this.SUPER(text) * 100;
    },

    function formatNumber(val) {
      return val.toFixed(2);
    }
  ]
});
/**
 * @license
 * Copyright 2015 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

foam.CLASS({
  package: 'foam.u2',
  name: 'CheckBox',
  extends: 'foam.u2.tag.Input',

  documentation: 'Checkbox View.',

  properties: [
    { 
      class: 'Boolean', 
      name: 'data' 
    },
    {
      class: 'Boolean',
      name: 'showLabel',
      factory: function() { return !!this.label },
    },
    { 
      class: 'String', 
      name: 'label' 
    }
  ],

  methods: [
    function initE() {
      this.SUPER();
      this.setAttribute('type', 'checkbox');

      if ( this.showLabel ) { 
        this.start('label')
          .addClass(this.myClass('label'))
          .addClass(this.myClass('noselect'))
          .add(this.label$)
          .on('click', function() { 
            this.data = !this.data; 
          }.bind(this))
        .end();
      }
    },
    function updateMode_(mode) {
      var disabled = mode === foam.u2.DisplayMode.RO ||
                     mode === foam.u2.DisplayMode.DISABLED;
      this.setAttribute('disabled', disabled);
    },
    function link() {
      this.data$.linkTo(this.attrSlot('checked'));
    }
  ],

  css: `
    ^ {
      margin: 8px;
      padding: 8px;
    }

    ^label {
      color: #444;
      flex-grow: 1;
      margin-left: 12px;
      overflow: hidden;
      white-space: nowrap;
      display: inline;
    }

    ^noselect {
      -webkit-touch-callout: none;
      -webkit-user-select: none;
      -khtml-user-select: none;
      -moz-user-select: none;
      -ms-user-select: none;
      user-select: none;
    }
  `
});
/**
 * @license
 * Copyright 2017 The FOAM Authors. All Rights Reserved.
 * http://www.apache.org/licenses/LICENSE-2.0
 */

foam.CLASS({
  package: 'foam.u2.md',
  name: 'CheckBox',
  extends: 'foam.u2.CheckBox',

  axioms: [
    foam.u2.CSS.create({
      code: `
        ^ {
          padding: 0px !important;

          -webkit-appearance: none;
          border-radius: 2px;
          border: solid 2px #5a5a5a;
          box-sizing: border-box;
          display: inline-block;
          fill: rgba(0, 0, 0, 0);

          height: 18px;
          width: 18px;

          opacity: 1;

          transition: background-color 140ms, border-color 140ms;
        }

        ^:checked {
          background-color: #04a9f4;
          border-color: #04a9f4;
          fill: white;
        }

        ^:focus{
          outline:0;
        }

        ^:checked:after {
          content: url(data:image/svg+xml,%3Csvg%20viewBox%3D%220%200%2048%2048%22%20xmlns%3D%22http%3A//www.w3.org/2000/svg%22%20width%3D%2215%22%20height%3D%2215%22%20version%3D%221.1%22%3E%0A%20%20%20%3Cpath%20fill%3D%22white%22%20stroke-width%3D%223%22%20d%3D%22M18%2032.34L9.66%2024l-2.83%202.83L18%2038l24-24-2.83-2.83z%22/%3E%0A%3C/svg%3E);
        }

        ^label {
          margin-top: 9px;
          position: absolute;
        }
      `
    })
  ]
});
/**
 * @license
 * Copyright 2016 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

foam.CLASS({
  package: 'foam.u2',
  name: 'CitationView',
  extends: 'foam.u2.Element',

  documentation: 'A simple default View to display the ID of an object.',

  properties: [
    'data',
    [ 'nodeName', 'span' ],
  ],

  methods: [
   function initE() {
      this.SUPER();
      this.add(this.data$.dot('id')).add(' ');
    }
  ]
});

//    TODO: name/label detection */
/**
 * @license
 * Copyright 2014 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

foam.CLASS({
  package: 'foam.u2',
  name: 'PopupView',
  extends: 'foam.u2.Element',

  css: `
    ^ {
      background: #999;
      box-shadow: 3px 3px 6px 0 gray;
      color: white;
      font-size: 18px;
      opacity: 0.9;
      position: absolute;
      box-sizing: border-box;
      z-index: 999;
    }
  `,

  properties: [
    'x',
    'y',
    'width',
    'height',
    'maxWidth',
    'maxHeight',
    'padding'
  ],

  methods: [
    function initE() {
      var self     = this;
      var parent   = this.parentNode;
      var close    = function() {
        self.remove();
        bg.remove();
      };

      if ( ! this.padding ) this.padding = 20;
      if ( ! this.y       ) this.y = (parent.el().clientHeight - this.height)/2;
      if ( ! this.x       ) this.x = (parent.el().clientWidth  - this.width )/2;
      if ( this.width     ) this.style({width    : this.width     + 'px'});
      if ( this.height    ) this.style({height   : this.height    + 'px'});
      if ( this.maxWidth  ) this.style({maxWidth : this.maxWidth  + 'px'});
      if ( this.maxHeight ) this.style({maxHeight: this.maxHeight + 'px'});

      // Make a full-screen transparent background, which when clicked,
      // closes this Popup
      var bg = this.E('div').
        style({
          position: 'absolute',
          width: '100%',
          height: '100%',
          opacity: 0,
          top: 0,
          zIndex: 998
        }).
        on('click', close).
        write();

      this.
        addClass(this.myClass()).
        style({
          padding: this.padding + 'px',
          left:    this.x + 'px',
          top:     this.y + 'px'
        }).
        onunload.sub(close);

      parent.style({position: 'relative'});
    }
  ]
});
/**
 * @license
 * Copyright 2015 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// TODO: Add datalist support.

foam.CLASS({
  package: 'foam.u2',
  name: 'DateView',
  extends: 'foam.u2.tag.Input',

  documentation: 'View for editing Date values.',

  css: '^:read-only { border: none; background: rgba(0,0,0,0); }',

  properties: [
    [ 'placeholder', 'yyyy-mm-dd' ]
  ],

  methods: [
    function initE() {
      this.SUPER();
      this.setAttribute('type', 'date');
    },

    function link() {
      this.data$.relateTo(
          this.attrSlot(null, this.onKey ? 'input' : null),
          function(date) {
            return date ? date.toISOString().substring(0,10) : date;
          },
          function(value) {
            return new Date(value);
          }
      );
    }
  ]
});
/**
 * @license
 * Copyright 2017 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// TODO: Add datalist support.

foam.CLASS({
  package: 'foam.u2',
  name: 'DateTimeView',
  extends: 'foam.u2.tag.Input',

  documentation: 'View for editing DateTime values.',

  methods: [
    function initE() {
      this.SUPER();
      this.setAttribute('type', 'datetime-local');
    },

    function link() {
      this.data$.relateTo(
          this.attrSlot(null, this.onKey ? 'input' : null),
          function(date) {
            return date ? date.toISOString().substring(0,16) : date;
          },
          function(value) {
            return new Date(value);
          }
      );
    }
  ]
});
/**
 * @license
 * Copyright 2015 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

foam.CLASS({
  package: 'foam.u2',
  name: 'RangeView',
  extends: 'foam.u2.tag.Input',

  properties: [
    [ 'type', 'range' ],
    [ 'step', 0 ],
    [ 'minValue', 0 ],
    [ 'maxValue', 100 ]
  ],

  methods: [
    function initE() {
      this.SUPER();
      if ( this.step ) this.attrs({step: this.step});
      this.attrs({min: this.minValue, max: this.maxValue$});
    }
  ]
});
/**
 * @license
 * Copyright 2015 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// TODO: doc
foam.CLASS({
  package: 'foam.u2',
  name: 'ReadWriteView',
  extends: 'foam.u2.View',

  requires: [ 'foam.u2.tag.Input' ],

  methods: [
    function initE() {
      // Don't create ReadView if no data (saves memory and startup time).
      if ( this.isLoaded() ) {
        this.initReadView();
      } else {
        this.listenForLoad();
      }
    },

    // Template Methods

    function isLoaded() {
      /** Return true iff data is available for this view. **/
      return this.data;
    },

    function listenForLoad() {
      this.data$.sub(this.onDataLoad);
    },

    function toReadE() {
      return this.E('span').add(this.data$);
    },

    function toWriteE() {
      this.data$.sub(this.onDataLoad);
      return this.Input.create({data$: this.data$});
    }
  ],

  listeners: [
    function onDataLoad(s) {
      s.detach();
      this.initReadView();
    },

    function initReadView() {
      this.removeAllChildren().add(this.toReadE().on('click', this.initWriteView));
    },

    function initWriteView() {
      this.removeAllChildren().add(this.toWriteE().on('blur', this.initReadView).focus());
    }
  ]
});
/**
 * @license
 * Copyright 2016 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 */

foam.CLASS({
  package: 'foam.u2',
  name: 'HTMLValidator',
  extends: 'foam.u2.DefaultValidator',

  axioms: [ foam.pattern.Singleton.create() ],

  methods: [
    function sanitizeText(text) {
      // TODO: validate text
      return text;
    }
  ]
});


// An Element which does not escape HTML content
foam.CLASS({
  package: 'foam.u2',
  name: 'HTMLElement',
  extends: 'foam.u2.Element',

  exports: [ 'validator as elementValidator' ],

  properties: [
    {
      class: 'Proxy',
      of: 'foam.u2.DefaultValidator',
      name: 'validator',
      value: foam.u2.HTMLValidator.create()
    }
  ]
});
/**
 * @license
 * Copyright 2017 The FOAM Authors. All Rights Reserved.
 * http://www.apache.org/licenses/LICENSE-2.0
 */

foam.CLASS({
  package: 'foam.u2.tag',
  name: 'Select',
  extends: 'foam.u2.View',

  css: `
    ^:disabled {
      appearance: none;
      -moz-appearance:none;
      -webkit-appearance:none;
      border: none;
      background: rgba(0,0,0,0);
      color: initial;
    }
  `,

  properties: [
    [ 'nodeName', 'select' ],
    {
      name: 'choices',
      factory: function() {
        return [];
      }
    },
    {
      name: 'placeholder',
      factory: function() {
        return undefined;
      }
    },
    'size'
  ],

  methods: [
    function initE() {
      this.SUPER();
      var self = this;

      this
        .addClass(this.myClass())
        .attrs({size: this.size$})
        .attrSlot().linkFrom(this.data$);

      this.setChildren(this.slot(function(choices, placeholder) {
        var cs = [];

        if ( placeholder ) {
          cs.push(self.E('option').attrs({
            value: -1,
            selected: self.data == -1 ? true : undefined
          }).add(self.placeholder));
        }

        for ( var i = 0 ; i < choices.length ; i++ ) {
          var c = choices[i];
          var value = c[1];
          var e = self.E('option').attrs({
            value: i,
            selected: self.data === i ? true : undefined
          }).add(value);

          if ( value.indexOf('  ') != -1 ) {
            // Hack to display spaces as nbsp's
            e.onload.sub(function() {
              e.el().innerHTML = value.replace(/ /g, '&nbsp;');
            });
          }

          cs.push(e);
        }

        return cs;
      }));
    },

    function updateMode_(mode) {
      this.setAttribute(
        'disabled',
        mode === foam.u2.DisplayMode.DISABLED || mode === foam.u2.DisplayMode.RO);
    }
  ]
});
/**
 * @license
 * Copyright 2015 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// TODO: don't instantiate tabs until viewed

foam.CLASS({
  package: 'foam.u2',
  name: 'Tab',
  extends: 'foam.u2.Element',

  properties: [
    { class: 'String',  name: 'label' },
    { class: 'Boolean', name: 'selected' }
  ]
});


foam.CLASS({
  package: 'foam.u2',
  name: 'Tabs',
  extends: 'foam.u2.Element',

  requires: [ 'foam.u2.Tab' ],

  css: `
    ^ {
      display: block;
    }
    ^tabRow { height: 37px; }
    ^tab {
      background: lightgray;
      border-bottom: none;
      border-top: 1px solid black;
      border-left: 1px solid black;
      border-right: 1px solid black;
      border-top-right-radius: 4px;
      border-top-left-radius: 4px;
      float: left;
      padding: 6px;
    }
    ^tab.selected {
      background: white;
      position: relative;
      z-index: 1;
    }
    ^content {
      background: white;
      border: 1px solid black;
      box-shadow: 3px 3px 6px 0 gray;
      left: -4px;
      margin: 4px;
      padding: 0;
      position: relative;
      top: -13px;
    }
  `,

  properties: [
    /* not used
    {
      name: 'tabs',
      factory: function() { return []; }
    },
    */
    {
      name: 'selected',
      postSet: function(o, n) {
        if ( o ) o.selected = false;
        n.selected = true;
      }
    },
    'tabRow'
  ],

  methods: [
    function init() {
      this.
        addClass(this.myClass()).
        start('div', null, this.tabRow$).
          addClass(this.myClass('tabRow')).
        end().
        start('div', null, this.content$).
          addClass(this.myClass('content')).
        end();
    },

    function add(tab) {
      if ( this.Tab.isInstance(tab) ) {

        if ( ! this.selected ) this.selected = tab;

        this.tabRow.start('span').
          addClass(this.myClass('tab')).
          enableClass('selected', tab.selected$).
          on('click', function() { this.selected = tab; }.bind(this)).
          add(tab.label).
        end();

        tab.shown$ = tab.selected$;
      }

      this.SUPER(tab);
    }
  ]
});
/**
 * @license
 * Copyright 2018 The FOAM Authors. All Rights Reserved.
 * http://www.apache.org/licenses/LICENSE-2.0
 */

foam.CLASS({
  package: 'foam.u2',
  name: 'TimeView',
  extends: 'foam.u2.tag.Input',

  documentation: 'View for editing Time values.',

  methods: [
    function initE() {
      this.SUPER();
      this.setAttribute('type', 'time');
    }
  ]
});/**
 * @license
 * Copyright 2017 The FOAM Authors. All Rights Reserved.
 * http://www.apache.org/licenses/LICENSE-2.0
 */

foam.INTERFACE({
  package: 'foam.u2.history',
  name: 'HistoryItemView',
  extends: 'foam.u2.View',

  documentation: 'View displaying history item',

  methods: [
    function outputRecord(parentView, record) {}
  ]
});
/**
 * @license
 * Copyright 2017 The FOAM Authors. All Rights Reserved.
 * http://www.apache.org/licenses/LICENSE-2.0
 */

foam.CLASS({
  package: 'foam.u2.history',
  name: 'HistoryView',
  extends: 'foam.u2.View',
  requires: [ 'foam.u2.history.HistoryItemView' ],

  documentation: 'View displaying history',

  css: `
    ^ {
      height: 370px;
      background: white;
      position: relative;
      vertical-align: top;
      border-radius: 2px;
      overflow: auto;
      font-size: 12px;
      padding-left: 20px;
      padding-right: 20px;
      z-index: 0;
    }
    ^ h2 {
      height: 20px;
      opacity: 0.6;
      font-family: Roboto;
      font-size: 20px;
      font-weight: 300;
      font-style: normal;
      font-stretch: normal;
      line-height: 1;
      letter-spacing: 0.3px;
      text-align: left;
      color: #093649;
    }
    ^ .timelineRecord {
      position: relative;
    }
    ^ .timeline {
      width: 2px;
      height: 100%;
      background: rgba(164, 179, 184, 0.3);
      position: absolute;
      left: 23px;
      top: 5px;
      z-index: -1;
      margin-bottom: 20px;
      content: '';
    }
  `,

  properties: [
    'data',
    'historyItemView',
    { class: 'String', name: 'title', value: 'History' }
  ],

  methods: [
    function initE() {
      var view = this;

      this
        .addClass(this.myClass())
        .start('h2').add(this.title).end()
        .call(function outputRecords() {
          // Gets records from DAO
          view.data.select().then(function(records) {
            // Reverses records array for chronological output
            view.forEach(records.array.reverse(), function(record) {
              view.start('div')
                .addClass('timelineRecord')
                .start('div').addClass('timeline').end()
                .call(function() {
                  view.historyItemView.outputRecord(this, record)
                })
              .end();
            })
          })
        });
    }
  ]
});
/**
 * @license
 * Copyright 2017 The FOAM Authors. All Rights Reserved.
 * http://www.apache.org/licenses/LICENSE-2.0
 */

foam.CLASS({
  package: 'foam.u2.view',
  name: 'FObjectView',
  extends: 'foam.u2.Controller',

  documentation: 'View for editing FObjects.',

  // css: '^:read-only { border: none; background: rgba(0,0,0,0); }'

  properties: [
    {
      class: 'String',
      name: 'objectClass',
      displayWidth: 70,
      postSet: function(oldValue, newValue) {
        if ( newValue !== oldValue ) {
          var m = this.lookup(newValue, true);
          if ( m ) {
            this.data = m.create(this.data);
          }
        }
      }
    },
    {
      name: 'data',
      view: { class: 'foam.u2.DetailView' },
      postSet: function(_, data) {
        if ( ! data ) {
          this.objectClass = '';
        } else if ( data.cls_.id != this.objectClass ) {
          this.objectClass = data.cls_.id;
        }
      }
    },
    'choices'
  ],

  methods: [
    function initE() {
      if ( this.choices && Array.isArray(this.choices) ) {
        this.tag({class: 'foam.u2.view.ChoiceView', choices: this.choices, data$: this.objectClass$});
        /*
         * NOTE:
         * Displays the first choice on init.
         * Compensates for both types of choices accepted in ChoicesView.
         */
        if ( ! this.objectClass ) {
          if ( Array.isArray(this.choices[0]) ) {
            this.objectClass = this.choices[0][0];
          } else {
            this.objectClass = this.choices[0];
          }
        }
      } else {
        this.add(this.OBJECT_CLASS);
      }
      this.add(this.DATA);
    }
  ]
});
/**
 * @license
 * Copyright 2017 The FOAM Authors. All Rights Reserved.
 * http://www.apache.org/licenses/LICENSE-2.0
 */

foam.CLASS({
  package: 'foam.u2.view',
  name: 'FObjectArrayView',
  extends: 'foam.u2.View',

  documentation: 'View for editing FObjects inside of FObjectArrays.',

  requires: [
    'foam.core.Property',
    'foam.u2.DetailPropertyView'
  ],
  exports: [ 'as data' ],

  css: `
    .rmv-button{
      background: rgba(216, 30, 5, 0.3);
      width: 125px;
      text-align: center;
      color: indianred;
      padding: 10px;
      font-size: 12px;
      border-radius: 3px;
    }
  `,

  properties: [
    {
      class: 'Class',
      name: 'of'
    },
    {
      name: 'data'
    },
    'choices',
    {
      name: 'detailView',
      value: 'foam.u2.DetailView'
    }
  ],

  methods: [
    function initE() {
      var self = this;

      var controllerMode = this.mode === foam.u2.DisplayMode.RW &&
          (this.data.visibility === foam.u2.Visibility.RW ||
           this.controllerMode === foam.u2.ControllerMode.CREATE) ?
          this.controllerMode : foam.u2.ControllerMode.VIEW;
      this.add(this.ADD_ITEM).add(this.slot(function(data) {
        return this.E().forEach(data, function(o, index) {
          var tag = this.tag({
            class: self.detailView,
            controllerMode: controllerMode,
          }, {data: o});
          if ( this.mode === foam.u2.DisplayMode.RW ) {
            tag.start().add('Remove').addClass('rmv-button')
                .on('click', function(){ self.removeIt(index) }).end();
          }
        });
      }));
    },

    function fromProperty(p) {
      this.SUPER(p);
      console.assert(p.of, 'Property "of" required for FObjectArrayView.');
      this.of = p.of;
    }
  ],

  listeners: [
    function removeIt(index){
      var data = foam.Array.clone(this.data);
      data.pop(index);
      this.data = data;
    }
  ],

  actions: [
    {
      name: 'addItem',
      isAvailable: function(mode) {
        return mode === foam.u2.DisplayMode.RW;
      },
      code: function() {
        var data = foam.Array.clone(this.data);
        data.push(this.of.create(null, this));
        this.data = data;
      }
    }
  ]
});
/**
 * @license
 * Copyright 2016 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

foam.CLASS({
  package: 'foam.u2.view',
  name: 'ChoiceView',
  extends: 'foam.u2.View',

  documentation: 'Wraps a tag that represents a singular choice. That is, ' +
      'this controller shows the user a fixed, probably small set of ' +
      'choices, and the user picks one. ' +
      'The choices are [value, label] pairs. this.choice is the current ' +
      'pair, this.data the current value. this.text is the current label, ' +
      'this.label is the label for the whole view (eg. "Medal Color", not ' +
      '"Gold"). ' +
      'The choices can be provided either as an array (this.choices) or as ' +
      'a DAO plus the function this.objToChoice which turns objects from the ' +
      'DAO into [value, label] pairs. ' +
      'this.selectSpec is a ViewSpec for the inner view. It defaults to ' +
      'foam.u2.tag.Select.',

  properties: [
    {
      class: 'String',
      name: 'label',
      documentation: 'User-visible label. Not to be confused with "text", ' +
          'which is the user-visible name of the currently selected choice.'
    },
    {
      name: 'choice',
      // 'choice' is the canonical source of truth. Updating 'choice' is
      // responsible for updating 'index', 'data', and 'text'. Updating any
      // of those properties calls back to updating 'choice'.
      documentation: 'The current choice. (That is, a [value, text] pair.)',
      postSet: function(o, n) {
        if ( o === n || this.feedback_ ) return;

        this.feedback_ = true;

        if ( ! n && this.placeholder ) {
          this.data = undefined;
          this.text = this.placeholder;
          this.index = -1;
        } else {
          this.data  = n && n[0];
          this.text  = n && n[1];
          this.index = this.findIndexOfChoice(n);
        }
        this.feedback_ = false;
      }
    },
    {
      name: 'choices',
      documentation: 'Array of [value, text] choices. You can pass in just ' +
          'an array of strings, which are expanded to [str, str]. Can also ' +
          'be a map, which results in [key, value] pairs listed in ' +
          'enumeration order.',
      factory: function() { return []; },
      adapt: function(old, nu) {
        if ( typeof nu === 'object' && ! Array.isArray(nu) ) {
          var out = [];
          for ( var key in nu ) {
            if ( nu.hasOwnProperty(key) ) out.push([ key, nu[key] ]);
          }
          return out;
        }

        nu = foam.Array.clone(nu);

        // Upgrade single values to [value, value].
        for ( var i = 0; i < nu.length; i++ ) {
          if ( ! Array.isArray(nu[i]) ) {
            nu[i] = [ nu[i], nu[i] ];
          }
        }

        return nu;
      },
    },
    {
      class: 'Int',
      name: 'index',
      documentation: 'The index of the current choice in the choices array.',
      transient: true,
      value: -1,
      preSet: function(old, nu) {
        if ( this.choices.length === 0 && this.dao ) return nu;
        if ( nu < 0 && this.placeholder ) return nu;
        if ( nu < 0 || this.choices.length === 0 ) return 0;
        if ( nu >= this.choices.length ) return this.choices.length - 1;
        return nu;
      },
      postSet: function(o, n) {
        if ( o !== n ) this.choice = n === -1 ? null : this.choices[n];
      }
    },
    {
      class: 'String',
      name: 'placeholder',
      factory: function() { return undefined; },
      documentation: 'When provided the placeholder will be prepended to the selection list, and selected if the choices array is empty or no choice in the choices array is selected.'
    },
    {
      class: 'Function',
      name: 'objToChoice',
      documentation: 'A function which adapts an object from the DAO to a ' +
          '[key, value] choice. Required when a DAO is provided.'
    },
    {
      class: 'foam.dao.DAOProperty',
      name: 'dao'
    },
    {
      name: 'text',
      postSet: function(o, n) {
        if ( o !== n ) this.choice = this.findChoiceByText(n);
      }
    },
    {
      name: 'data',
      postSet: function(o, n) {
        if ( o !== n ) this.choice = this.findChoiceByData(n) || [ n, n ];
      }
    },
    {
      class: 'foam.u2.ViewSpec',
      name: 'selectSpec',
      value: { class: 'foam.u2.tag.Select' }
    },
    {
      class: 'Boolean',
      name: 'alwaysFloatLabel'
    },
    {
      name: 'view_'
    },
    'feedback_',
    'defaultValue',
    'size'
  ],

  methods: [
    function init() {
      this.onDetach(this.choices$.sub(this.onChoicesUpdate));
    },

    function initE() {
      // If no item is selected, and data has not been provided, select the 0th
      // entry.
      if ( ! this.data && ! this.index ) {
        this.index = 0;
      }

      if ( this.dao ) this.onDAOUpdate();

      this.start(this.selectSpec, {
        data$: this.index$,
        label$: this.label$,
        alwaysFloatLabel: this.alwaysFloatLabel,
        choices$: this.choices$,
        placeholder$: this.placeholder$,
        mode$: this.mode$,
        size: this.size
      }).end();

      this.dao$proxy.on.sub(this.onDAOUpdate);
    },

    function findIndexOfChoice(choice) {
      if ( ! choice ) return -1;
      var choices = this.choices;
      var data = choice[0];
      for ( var i = 0 ; i < choices.length ; i++ ) {
        if ( foam.util.equals(choices[i][0], data) ) return i;
      }
      var text = choice[1];
      for ( var i = 0 ; i < choices.length ; i++ ) {
        if ( choices[i][1] === text ) return i;
      }
      return -1;
    },

    function findChoiceByData(data) {
      var choices = this.choices;
      for ( var i = 0 ; i < choices.length ; i++ ) {
        if ( foam.util.equals(choices[i][0], data) ) return choices[i];
      }
      return null;
    },

    function findChoiceByText(text) {
      var choices = this.choices;
      for ( var i = 0 ; i < choices.length ; i++ ) {
        if ( choices[i][1] === text ) return choices[i];
      }
      return null;
    },

    function fromProperty(p) {
      this.SUPER(p);
      this.defaultValue = p.value;
    }
  ],

  listeners: [
    {
      name: 'onChoicesUpdate',
      isFramed: true,
      code: function() {
        var d = this.data;
        if ( this.choices.length ) {
          this.choice = ( d && this.findChoiceByData(d) ) || this.defaultValue;
        }
      }
    },
    {
      name: 'onDAOUpdate',
      isFramed: true,
      code: function() {
        this.dao.select().then(function(s) {
          this.choices = s.array.map(this.objToChoice);
          if ( ! this.data && this.index === -1 ) this.index = this.placeholder ? -1 : 0;
        }.bind(this));
      }
    }
  ]
});
/**
 * @license
 * Copyright 2016 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

foam.CLASS({
  package: 'foam.u2.view',
  name: 'RadioView',
  extends: 'foam.u2.view.ChoiceView',

  axioms: [
    foam.u2.CSS.create({
      code: function CSS() {/*
        ^ label {
          position: relative;
        }
      */}
    })
  ],

  methods: [
    function initE() {
      // If no item is selected, and data has not been provided, select the 0th
      // entry.
      this.addClass(this.myClass());
      if ( ! this.data && ! this.index ) {
        this.index = 0;
      }

      if ( this.dao ) this.onDAOUpdate();
      this.choices$.sub(this.onChoicesUpdate);
      this.onChoicesUpdate();
    }
  ],

  listeners: [
    function onChoicesUpdate() {
      var self = this;
      var id;

      this.removeAllChildren();

      this.add(this.choices.map(function(c) {
        return this.E('div').
          addClass(this.myClass()).
          start('input').
            attrs({
              type: 'radio',
              name: this.id,
              value: c[0],
              checked: self.slot(function (data) { return data === c[0]; })
            }).
            setID(id = self.NEXT_ID()).
            on('change', function(evt) {
              self.data = evt.srcElement.value;
            }).
          end().
          start('label').
            attrs({
              for: id
            }).
            start('span').
              add(c[1]).
            end()
          .end();
      }.bind(this)));
    }
  ]
});
/**
 * @license
 * Copyright 2016 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

foam.CLASS({
  package: 'foam.u2.view',
  name: 'TextField',
  extends: 'foam.u2.Element',

  requires: [
    'foam.u2.tag.Input'
  ],

  properties: [
    'data',
    {
      class: 'Boolean',
      name: 'onKey',
      attribute: true
      // documentation: 'When true, $$DOC{ref:".data"} is updated on every keystroke, rather than on blur.'
    },
    {
      class: 'foam.u2.ViewSpec',
      name: 'view',
      value: { class: 'foam.u2.tag.Input' }
    },
    'label',
    'alwaysFloatLabel',
    'type',
    'placeholder',
    'autocompleter',
    'autocompleteList_'
  ],

  methods: [
    function initE() {
      var e = this.start(this.view, {
        data$:            this.data$,
        label$:           this.label$,
        alwaysFloatLabel: this.alwaysFloatLabel,
        type:             this.type,
        onKey:            this.onKey
      });
      e.attrs({
        placeholder: this.placeholder$,
      });
      e.end();

      if ( this.autocompleter ) {
        this.onload.sub(function() {
          var list = foam.u2.Element.create({ nodeName: 'datalist' });
          this.autocompleteList_ = list;
          this.autocompleter.dao.on.sub(this.updateAutocompleteList);
          this.updateAutocompleteList();
          this.document.body.insertAdjacentHTML('beforeend', list.outerHTML);
          list.load();

          // Actually set the list attribute on our input field.
          e.attrs({ list: list.id });
        }.bind(this));

        this.onunload.sub(function() {
          this.autocompleteList_.remove();
        }.bind(this));
      }
    }
  ],

  listeners: [
    {
      name: 'updateAutocompleteList',
      isFramed: true,
      code: function() {
        var list = this.autocompleteList_;
        this.autocompleteList_.removeAllChildren();
        this.autocompleter.dao.select(foam.dao.ArraySink.create())
            .then(function(sink) {
              sink.array.forEach(function(x) {
                list.start('option').attrs({ value: x.label }).end();
              });
            });
      }
    }
  ]
});
/**
 * @license
 * Copyright 2016 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

foam.CLASS({
  package: 'foam.u2.view',
  name: 'TreeViewRow',
  extends: 'foam.u2.Element',

  requires: [
    'foam.mlang.ExpressionsSingleton'
  ],

  exports: [
    'data'
  ],

  imports: [
    'selection',
    'onObjDrop'
  ],

  axioms: [
    foam.u2.CSS.create({
      code: function() {/*
        ^ { white-space: nowrap; margin-left:16px; }
        ^selected { outline: 2px solid #dddd00; }
      */}
    })
  ],

  properties: [
    {
      name: 'data'
    },
    {
      name: 'relationship'
    },
    {
      class: 'Boolean',
      name: 'expanded',
      value: false
    },
    {
      class: 'Function',
      name: 'formatter'
    }
  ],

  methods: [
    function initE() {
      var self = this;
      this.
        addClass(this.myClass()).
        addClass(this.slot(function(selected, id) {
          if ( selected && foam.util.equals(selected.id, id) ) {
            return this.myClass('selected');
          }
          return '';
        }, this.selection$, this.data$.dot('id'))).
        attrs({ draggable: 'true' }).
        start('span').
          on('click', this.toggleExpanded).
          add(this.expanded$.map(function(v) { return v ? '\u25BD' : '\u25B7'; })).
          entity('nbsp').
        end().
        on('click', this.selected).
        on('dragstart', this.onDragStart).
        on('dragenter', this.onDragOver).
        on('dragover', this.onDragOver).
        on('drop', this.onDrop).
        call(this.formatter).
        add(this.slot(function(e) {
          if ( ! e ) return this.E('div');
          var e2 = this.E('div');
          e2.select(this.data[self.relationship.forwardName]/*.dao*/, function(obj) {
            return self.cls_.create({
              data: obj,
              formatter: self.formatter,
              relationship: self.relationship
            }, this);
          });
          return e2;
        }, this.expanded$));
    }
  ],

  listeners: [
    function onDragStart(e) {
      e.dataTransfer.setData('application/x-foam-obj-id', this.data.id);
      e.stopPropagation();
    },

    function onDragOver(e) {
      if ( ! e.dataTransfer.types.some(function(m) { return m === 'application/x-foam-obj-id'; }) )
        return;

      var id = e.dataTransfer.getData('application/x-foam-obj-id');

      if ( foam.util.equals(id, this.data.id) )
        return;

      e.preventDefault();
      e.stopPropagation();
    },

    function onDrop(e) {
      if ( ! e.dataTransfer.types.some(function(m) { return m === 'application/x-foam-obj-id'; }) )
        return;

      var id = e.dataTransfer.getData('application/x-foam-obj-id');

      if ( foam.util.equals(id, this.data.id) ) return;

      e.preventDefault();
      e.stopPropagation();

      var self = this;
      var dao  = this.__context__[this.relationship.targetDAOKey];
      dao.find(id).then(function(obj) {
        if ( ! obj ) return null;

        // TODO: We shouldn't have to remove then put,
        // We currently have to because the FLOW editor is not updating properly
        // on a put event for an object that it already has.
        dao.remove(obj).then(function() {
          self.data[self.relationship.forwardName].dao.put(obj).then(function(obj) {
            self.onObjDrop(obj, id);
          });
        });
      });
    },

    function selected(e) {
      this.selection = this.data;
      e.preventDefault();
      e.stopPropagation();
    },

    function toggleExpanded(e) {
      this.expanded = ! this.expanded;
      e.preventDefault();
      e.stopPropagation();
    }
  ]
});


foam.CLASS({
  package: 'foam.u2.view',
  name: 'TreeView',
  extends: 'foam.u2.Element',

  requires: [
    'foam.mlang.ExpressionsSingleton',
    'foam.u2.view.TreeViewRow'
  ],

  exports: [
    'onObjDrop',
    'selection'
  ],

  properties: [
    {
      class: 'foam.dao.DAOProperty',
      name: 'data'
    },
    {
      name: 'relationship'
    },
    {
      name: 'selection'
    },
    {
      class: 'Function',
      name: 'formatter'
    },
    {
      class: 'Boolean',
      name: 'startExpanded',
      value: false
    }
  ],

  methods: [
    function initE() {
      var M  = this.ExpressionsSingleton.create();
      var of = this.lookup(this.relationship.sourceModel);

      var dao = this.data$proxy.where(
        M.NOT(M.HAS(of.getAxiomByName(this.relationship.inverseName))));

      var self = this;
      this.addClass(this.myClass()).
        select(dao, function(obj) {
          return self.TreeViewRow.create({
            data: obj,
            relationship: self.relationship,
            expanded: self.startExpanded,
            formatter: self.formatter
          }, this);
        });
    },

    function onObjDrop(obj, target) {
      // Template Method
    }
  ]
});
/**
 * @license
 * Copyright 2017 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
*/

foam.CLASS({
  package: 'foam.u2.view',
  name: 'AltView',
  extends: 'foam.u2.View',

  documentation: "Provides the ability to switch between multiple views for data set" +
  "Takes a views property which should be the value of an array containing arrays that contain desired views, and label." +
  "Ex. views: [[ { class: 'foam.u2.view.TableView' }, 'Table' ]]",

  requires: [
    'foam.u2.stack.Stack'
  ],

  properties: [
    {
      name: 'of',
      factory: function() { return this.data.of }
    },
    {
      name: 'views',
      value: []
    },
    {
      name: 'altStack'
    },
    {
      name: 'viewChoices',
      view: function(_, X) {
        return foam.u2.view.ChoiceView.create({
          choices: X.data.views
        });
      }
    }
  ],

  css: `
    ^ {
      width: 992px;
      margin: auto;
    }
    ^ .foam-u2-tag-Select{
      width: 100px;
      height: 40px;
    }
    ^ .property-viewChoices{
      margin: 0 0 25px 15px;
    }
  `,

  methods: [
    function initE() {
      this.SUPER();
      var self = this;
      this.altStack = null;
      this.altStack = this.Stack.create();
      this.viewChoices$.sub(this.changeView);

      this.views.forEach(function(view){
        view[0].data = view[0].data ? view[0].data : self.data;
      });
      this.altStack.push(this.views[0][0]);

      this.addClass(this.myClass())
      this.startContext({data: this})
        this.start()
          .add(this.VIEW_CHOICES)
        .end()
      .endContext()
      .start('div').addClass('stack-wrapper')
        .tag({class: 'foam.u2.stack.StackView', data: this.altStack, showActions: false})
      .end();
    }
  ],

  listeners: [
    function changeView(){
      this.altStack.push(this.viewChoices);
    }
  ]
});
/**
 * @license
 * Copyright 2016 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

foam.CLASS({
  package: 'foam.u2.view',
  name: 'DualView',
  extends: 'foam.u2.Element',

  properties: [
    {
      class: 'foam.u2.ViewSpec',
      name: 'viewa'
    },
    {
      class: 'foam.u2.ViewSpec',
      name: 'viewb'
    },
    'data',
    'prop'
  ],

  methods: [
    function initE() {
      var a = foam.u2.ViewSpec.createView(this.viewa, {
        data$: this.data$ }, this, this);
      var b = foam.u2.ViewSpec.createView(this.viewb, {
        data$: this.data$ }, this, this);

      if ( this.prop ) {
        a.fromProperty && a.fromProperty(this.prop);
        b.fromProperty && b.fromProperty(this.prop);
      }

      this.add(a).nbsp().add(b);
    },

    function fromProperty(prop) {
      this.prop  = prop;
    }
  ]
});
/**
 * @license
 * Copyright 2016 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

foam.CLASS({
  package: 'foam.u2.view',
  name: 'ColorPicker',
  extends: 'foam.u2.tag.Input',

  constants: {
    NAME_TO_COLOR: {
      black: "#000000",
      navy: "#000080",
      darkblue: "#00008b",
      mediumblue: "#0000cd",
      blue: "#0000ff",
      darkgreen: "#006400",
      green: "#008000",
      teal: "#008080",
      darkcyan: "#008b8b",
      deepskyblue: "#00bfff",
      darkturquoise: "#00ced1",
      mediumspringgreen: "#00fa9a",
      lime: "#00ff00",
      springgreen: "#00ff7f",
      aqua: "#00ffff",
      cyan: "#00ffff",
      midnightblue: "#191970",
      dodgerblue: "#1e90ff",
      lightseagreen: "#20b2aa",
      forestgreen: "#228b22",
      seagreen: "#2e8b57",
      darkslategray: "#2f4f4f",
      darkslategrey: "#2f4f4f",
      limegreen: "#32cd32",
      mediumseagreen: "#3cb371",
      turquoise: "#40e0d0",
      royalblue: "#4169e1",
      steelblue: "#4682b4",
      darkslateblue: "#483d8b",
      mediumturquoise: "#48d1cc",
      indigo: "#4b0082",
      darkolivegreen: "#556b2f",
      cadetblue: "#5f9ea0",
      cornflowerblue: "#6495ed",
      rebeccapurple: "#663399",
      mediumaquamarine: "#66cdaa",
      dimgray: "#696969",
      dimgrey: "#696969",
      slateblue: "#6a5acd",
      olivedrab: "#6b8e23",
      slategray: "#708090",
      slategrey: "#708090",
      lightslategray: "#778899",
      lightslategrey: "#778899",
      mediumslateblue: "#7b68ee",
      lawngreen: "#7cfc00",
      chartreuse: "#7fff00",
      aquamarine: "#7fffd4",
      maroon: "#800000",
      purple: "#800080",
      olive: "#808000",
      gray: "#808080",
      grey: "#808080",
      skyblue: "#87ceeb",
      lightskyblue: "#87cefa",
      blueviolet: "#8a2be2",
      darkred: "#8b0000",
      darkmagenta: "#8b008b",
      saddlebrown: "#8b4513",
      darkseagreen: "#8fbc8f",
      lightgreen: "#90ee90",
      mediumpurple: "#9370db",
      darkviolet: "#9400d3",
      palegreen: "#98fb98",
      darkorchid: "#9932cc",
      yellowgreen: "#9acd32",
      sienna: "#a0522d",
      brown: "#a52a2a",
      darkgray: "#a9a9a9",
      darkgrey: "#a9a9a9",
      lightblue: "#add8e6",
      greenyellow: "#adff2f",
      paleturquoise: "#afeeee",
      lightsteelblue: "#b0c4de",
      powderblue: "#b0e0e6",
      firebrick: "#b22222",
      darkgoldenrod: "#b8860b",
      mediumorchid: "#ba55d3",
      rosybrown: "#bc8f8f",
      darkkhaki: "#bdb76b",
      silver: "#c0c0c0",
      mediumvioletred: "#c71585",
      indianred: "#cd5c5c",
      peru: "#cd853f",
      chocolate: "#d2691e",
      tan: "#d2b48c",
      lightgray: "#d3d3d3",
      lightgrey: "#d3d3d3",
      thistle: "#d8bfd8",
      orchid: "#da70d6",
      goldenrod: "#daa520",
      palevioletred: "#db7093",
      crimson: "#dc143c",
      gainsboro: "#dcdcdc",
      plum: "#dda0dd",
      burlywood: "#deb887",
      lightcyan: "#e0ffff",
      lavender: "#e6e6fa",
      darksalmon: "#e9967a",
      violet: "#ee82ee",
      palegoldenrod: "#eee8aa",
      lightcoral: "#f08080",
      khaki: "#f0e68c",
      aliceblue: "#f0f8ff",
      honeydew: "#f0fff0",
      azure: "#f0ffff",
      sandybrown: "#f4a460",
      wheat: "#f5deb3",
      beige: "#f5f5dc",
      whitesmoke: "#f5f5f5",
      mintcream: "#f5fffa",
      ghostwhite: "#f8f8ff",
      salmon: "#fa8072",
      antiquewhite: "#faebd7",
      linen: "#faf0e6",
      lightgoldenrodyellow: "#fafad2",
      oldlace: "#fdf5e6",
      red: "#ff0000",
      fuchsia: "#ff00ff",
      magenta: "#ff00ff",
      deeppink: "#ff1493",
      orangered: "#ff4500",
      tomato: "#ff6347",
      hotpink: "#ff69b4",
      coral: "#ff7f50",
      darkorange: "#ff8c00",
      lightsalmon: "#ffa07a",
      orange: "#ffa500",
      lightpink: "#ffb6c1",
      pink: "#ffc0cb",
      gold: "#ffd700",
      peachpuff: "#ffdab9",
      navajowhite: "#ffdead",
      moccasin: "#ffe4b5",
      bisque: "#ffe4c4",
      mistyrose: "#ffe4e1",
      blanchedalmond: "#ffebcd",
      papayawhip: "#ffefd5",
      lavenderblush: "#fff0f5",
      seashell: "#fff5ee",
      cornsilk: "#fff8dc",
      lemonchiffon: "#fffacd",
      floralwhite: "#fffaf0",
      snow: "#fffafa",
      yellow: "#ffff00",
      lightyellow: "#ffffe0",
      ivory: "#fffff0",
      white: "#ffffff"
    },
    COLOR_TO_NAME: { '#000000': 'black',
      '#000080': 'navy',
      '#00008b': 'darkblue',
      '#0000cd': 'mediumblue',
      '#0000ff': 'blue',
      '#006400': 'darkgreen',
      '#008000': 'green',
      '#008080': 'teal',
      '#008b8b': 'darkcyan',
      '#00bfff': 'deepskyblue',
      '#00ced1': 'darkturquoise',
      '#00fa9a': 'mediumspringgreen',
      '#00ff00': 'lime',
      '#00ff7f': 'springgreen',
      '#00ffff': 'cyan',
      '#191970': 'midnightblue',
      '#1e90ff': 'dodgerblue',
      '#20b2aa': 'lightseagreen',
      '#228b22': 'forestgreen',
      '#2e8b57': 'seagreen',
      '#2f4f4f': 'darkslategrey',
      '#32cd32': 'limegreen',
      '#3cb371': 'mediumseagreen',
      '#40e0d0': 'turquoise',
      '#4169e1': 'royalblue',
      '#4682b4': 'steelblue',
      '#483d8b': 'darkslateblue',
      '#48d1cc': 'mediumturquoise',
      '#4b0082': 'indigo',
      '#556b2f': 'darkolivegreen',
      '#5f9ea0': 'cadetblue',
      '#6495ed': 'cornflowerblue',
      '#663399': 'rebeccapurple',
      '#66cdaa': 'mediumaquamarine',
      '#696969': 'dimgrey',
      '#6a5acd': 'slateblue',
      '#6b8e23': 'olivedrab',
      '#708090': 'slategrey',
      '#778899': 'lightslategrey',
      '#7b68ee': 'mediumslateblue',
      '#7cfc00': 'lawngreen',
      '#7fff00': 'chartreuse',
      '#7fffd4': 'aquamarine',
      '#800000': 'maroon',
      '#800080': 'purple',
      '#808000': 'olive',
      '#808080': 'grey',
      '#87ceeb': 'skyblue',
      '#87cefa': 'lightskyblue',
      '#8a2be2': 'blueviolet',
      '#8b0000': 'darkred',
      '#8b008b': 'darkmagenta',
      '#8b4513': 'saddlebrown',
      '#8fbc8f': 'darkseagreen',
      '#90ee90': 'lightgreen',
      '#9370db': 'mediumpurple',
      '#9400d3': 'darkviolet',
      '#98fb98': 'palegreen',
      '#9932cc': 'darkorchid',
      '#9acd32': 'yellowgreen',
      '#a0522d': 'sienna',
      '#a52a2a': 'brown',
      '#a9a9a9': 'darkgrey',
      '#add8e6': 'lightblue',
      '#adff2f': 'greenyellow',
      '#afeeee': 'paleturquoise',
      '#b0c4de': 'lightsteelblue',
      '#b0e0e6': 'powderblue',
      '#b22222': 'firebrick',
      '#b8860b': 'darkgoldenrod',
      '#ba55d3': 'mediumorchid',
      '#bc8f8f': 'rosybrown',
      '#bdb76b': 'darkkhaki',
      '#c0c0c0': 'silver',
      '#c71585': 'mediumvioletred',
      '#cd5c5c': 'indianred',
      '#cd853f': 'peru',
      '#d2691e': 'chocolate',
      '#d2b48c': 'tan',
      '#d3d3d3': 'lightgrey',
      '#d8bfd8': 'thistle',
      '#da70d6': 'orchid',
      '#daa520': 'goldenrod',
      '#db7093': 'palevioletred',
      '#dc143c': 'crimson',
      '#dcdcdc': 'gainsboro',
      '#dda0dd': 'plum',
      '#deb887': 'burlywood',
      '#e0ffff': 'lightcyan',
      '#e6e6fa': 'lavender',
      '#e9967a': 'darksalmon',
      '#ee82ee': 'violet',
      '#eee8aa': 'palegoldenrod',
      '#f08080': 'lightcoral',
      '#f0e68c': 'khaki',
      '#f0f8ff': 'aliceblue',
      '#f0fff0': 'honeydew',
      '#f0ffff': 'azure',
      '#f4a460': 'sandybrown',
      '#f5deb3': 'wheat',
      '#f5f5dc': 'beige',
      '#f5f5f5': 'whitesmoke',
      '#f5fffa': 'mintcream',
      '#f8f8ff': 'ghostwhite',
      '#fa8072': 'salmon',
      '#faebd7': 'antiquewhite',
      '#faf0e6': 'linen',
      '#fafad2': 'lightgoldenrodyellow',
      '#fdf5e6': 'oldlace',
      '#ff0000': 'red',
      '#ff00ff': 'magenta',
      '#ff1493': 'deeppink',
      '#ff4500': 'orangered',
      '#ff6347': 'tomato',
      '#ff69b4': 'hotpink',
      '#ff7f50': 'coral',
      '#ff8c00': 'darkorange',
      '#ffa07a': 'lightsalmon',
      '#ffa500': 'orange',
      '#ffb6c1': 'lightpink',
      '#ffc0cb': 'pink',
      '#ffd700': 'gold',
      '#ffdab9': 'peachpuff',
      '#ffdead': 'navajowhite',
      '#ffe4b5': 'moccasin',
      '#ffe4c4': 'bisque',
      '#ffe4e1': 'mistyrose',
      '#ffebcd': 'blanchedalmond',
      '#ffefd5': 'papayawhip',
      '#fff0f5': 'lavenderblush',
      '#fff5ee': 'seashell',
      '#fff8dc': 'cornsilk',
      '#fffacd': 'lemonchiffon',
      '#fffaf0': 'floralwhite',
      '#fffafa': 'snow',
      '#ffff00': 'yellow',
      '#ffffe0': 'lightyellow',
      '#fffff0': 'ivory',
      '#ffffff': 'white'
    }
  },

  properties: [
    {
      name: 'type',
      value: 'color'
    }
  ],

  methods: [
    function link() {
      var self = this;
      this.attrSlot(null, this.onKey ? 'input' : null).relateFrom(this.data$,
        function(value) {
          if ( typeof value !== 'string' ) return value;

          var v = value.toLowerCase();
          if ( self.COLOR_TO_NAME[v] ) return self.COLOR_TO_NAME[v];
          return value;
        },
        function (value) {
          if ( typeof value !== 'string' ) return value;

          var v = value.toLowerCase();
          if ( self.NAME_TO_COLOR[v] ) return self.NAME_TO_COLOR[v];
          return value;
        });
    }
  ]
});
/**
 * @license
 * Copyright 2016 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

foam.CLASS({
  package: 'foam.u2.view',
  name: 'PasswordView',
  extends: 'foam.u2.tag.Input',

  properties: [ [ 'type', 'password' ] ]
});
/**
 * @license
 * Copyright 2017 The FOAM Authors. All Rights Reserved.
 * http://www.apache.org/licenses/LICENSE-2.0
 */

foam.CLASS({
  package: 'foam.u2.view',
  name: 'ChipView',
  extends: 'foam.u2.View',

  documentation: 'View to display tags with labels',

  imports: [
    'removeChip'
  ],

  css: `
    ^ {
      height: 30px;
      border-radius: 100px;
      background-color: #a4b3b8;
      margin: auto;
      position: relative;
      float: left;
      margin: 5px;
    }

    ^ .label {
      font-family: Roboto;
      font-size: 12px;
      line-height: 1.33;
      letter-spacing: 0.2px;
      text-align: left;
      color: #ffffff;
      padding: 8px 15px 6px 10px;
      display: table-cell;
    }

    ^ .foam-u2-ActionView-removeSelf {
      width: 10px;
      height: 10px;
      object-fit: contain;
      margin: 0;
      margin-top: -11;
      float: right;
      cursor: pointer;
      display: inline-block;
      outline: 0;
      border: none;
      background: transparent;
      padding-right: 15x;
    }

    ^ .foam-u2-ActionView-removeSelf img {
      width: 15px;
      height: 15px;
    }

    ^ .foam-u2-ActionView-removeSelf:hover {
      background: transparent;
      background-color: transparent;
    }
  `,

  methods: [
    function initE(){
      this.SUPER();

      this
        .addClass(this.myClass())
        .start()
          .start('p')
            .addClass('label')
            .add(this.data)
            .startContext({ data: this })
              .add(this.REMOVE_SELF)
            .endContext()
          .end()
        .end();
    }
  ],

  actions: [
    {
      name: 'removeSelf',
      icon: 'images/ic-cancelwhite.svg',
      code: function() {
        this.removeChip(this.data);
      }
    }
  ]
});
/**
 * @license
 * Copyright 2016 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

foam.INTERFACE({
  package: 'foam.u2.view',
  name: 'Formatter',
  methods: [
    {
      name: 'format',
      args: ['e', 'value', 'obj', 'axiom']
    }
  ]
});

foam.CLASS({
  package: 'foam.u2.view',
  name: 'FnFormatter',
  implements: [ 'foam.u2.view.Formatter' ],
  properties: [
    {
      class: 'Function',
      name: 'f'
    }
  ],
  methods: [
    function format(e, value, obj, axiom) {
      this.f.call(e, value, obj, axiom);
    }
  ]
});


foam.CLASS({
  package: 'foam.u2.view',
  name: 'TableCellFormatter',
  extends: 'FObjectProperty',
  properties: [
    {
      name: 'of',
      value: 'foam.u2.view.Formatter'
    },
    {
      name: 'adapt',
      value: function(o, f, prop) {
        if ( foam.Function.isInstance(f) ) {
          return foam.u2.view.FnFormatter.create({
            f: f
          });
        }
        return foam.core.FObjectProperty.ADAPT.value.call(this, o, f, prop);
      }
    },
    {
      name: 'value',
      adapt: function(_, v) {
        return this.adapt.call(this, _, v, this);
      }
    }
  ]
});

foam.CLASS({
  package: 'foam.u2.view',
  name: 'TableCellPropertyRefinement',

  refines: 'foam.core.Property',

  properties: [
    {
      name: 'tableHeaderFormatter',
      value: function(axiom) {
        this.add(axiom.label);
      }
    },
    {
      class: 'foam.u2.view.TableCellFormatter',
      name: 'tableCellFormatter',
      adapt: function(o, f, prop) {
        if ( foam.Function.isInstance(f) ) {
          return foam.u2.view.FnFormatter.create({
            f: f
          });
        }
        return foam.core.FObjectProperty.ADAPT.value.call(this, o, f, prop);
      },
      factory: function() {
        return foam.u2.view.FnFormatter.create({
          class: 'foam.u2.view.FnFormatter',
          f: function(value, obj, axiom) {
            this.add(value);
          }
        })
      }
    },
    {
      class: 'Int',
      name: 'tableWidth'
    }
  ]
});


foam.CLASS({
  refines: 'foam.core.Action',

  properties: [
    {
      class: 'foam.u2.view.TableCellFormatter',
      name: 'tableCellFormatter',
      value: function(_, obj, axiom) {
        this.
          startContext({ data: obj }).
          add(axiom).
          endContext();
      }
    },
    {
      name: 'tableHeaderFormatter',
      value: function(axiom) {
        this.add(axiom.label);
      }
    }
  ]
});


foam.CLASS({
  refines: 'foam.core.Enum',

  properties: [
    {
      class: 'foam.u2.view.TableCellFormatter',
      name: 'tableCellFormatter',
      value: function(value) {
        this.add(value.label)
      }
    }
  ]
});


foam.CLASS({
  refines: 'foam.core.FObjectProperty',

  properties: [ [ 'tableCellFormatter', null ] ]
});


foam.CLASS({
  refines: 'foam.core.Currency',

  properties: [
    {
      class: 'foam.u2.view.TableCellFormatter',
      name: 'tableCellFormatter',
      value: function(value) {
        this.start()
          .style({'text-align': 'left', 'padding-right': '20px'})
          .add('$' + (value/100).toFixed(2).replace(/(\d)(?=(\d{3})+\.)/g, '$1,'))
        .end();
      }
    }
  ]
});


foam.CLASS({
  refines: 'foam.core.Date',

  properties: [
    {
      class: 'foam.u2.view.TableCellFormatter',
      name: 'tableCellFormatter',
      value: function(date) {
        if ( date ) this.add(date.toLocaleDateString());
      }
    }
  ]
});


foam.CLASS({
  refines: 'foam.core.DateTime',

  properties: [
    {
      class: 'foam.u2.view.TableCellFormatter',
      name: 'tableCellFormatter',
      value: function(date) {
        if ( date ) this.add(date.toLocaleString());
      }
    }
  ]
});


foam.CLASS({
  package: 'foam.u2.view',
  name: 'TableView',
  extends: 'foam.u2.Element',

  implements: [ 'foam.mlang.Expressions' ],

  requires: [
    'foam.u2.view.EditColumnsView',
    'foam.u2.md.OverlayDropdown'
  ],

  exports: [
    'columns',
    'selection',
    'hoverSelection'
  ],

  imports: [
    'dblclick?',
    'editRecord?',
    'selection? as importSelection'
  ],

  axioms: [
    foam.u2.CSS.create({
      code: function CSS() {/*
        ^ {
          border-spacing: 14px 8px;
        }

        ^ th {
          text-align: left;
          white-space: nowrap;
        }

        ^row:hover {
          background: #eee;
          cursor: pointer;
        }

        ^selected {
          background: #eee;
        }

        ^vertDots {
          font-size: 20px;
          font-weight: bold;
          padding-right: 12px;
        }

        ^noselect {
          -webkit-touch-callout: none;
          -webkit-user-select: none;
          -khtml-user-select: none;
          -moz-user-select: none;
          -ms-user-select: none;
          user-select: none;
        }
    */}
    })
  ],

  properties: [
    {
      class: 'Class',
      name: 'of'
    },
    {
      class: 'foam.dao.DAOProperty',
      name: 'data',
      postSet: function(_, data) {
        if ( ! this.of && data ) this.of = data.of;
      }
    },
    {
      class: 'foam.dao.DAOProperty',
      name: 'orderedDAO',
      expression: function(data, order) {
        return data ? data.orderBy(order) : foam.dao.NullDAO.create();
      }
    },
    {
      name: 'order'
    },
    {
      name: 'columns_',
      expression: function(columns, of) {
        var of = this.of;
        if ( ! of ) return [];

        return columns.map(function(p) {
          var c = typeof p == 'string' ?
            of.getAxiomByName(p) :
            p ;

           if ( ! c ) {
             console.error('Unknown table column: ', p);
           }

          return c;
        }).filter(function(c) { return c; });
      }
    },
    {
      name: 'columns',
      expression: function(of) {
        var of = this.of;
        if ( ! of ) return [];

        var tableColumns = of.getAxiomByName('tableColumns');

        if ( tableColumns ) return tableColumns.columns;

        return of.getAxiomsByClass(foam.core.Property).
            filter(function(p) { return p.tableCellFormatter && ! p.hidden; }).
            map(foam.core.Property.NAME.f);
      }
    },
    {
      class: 'Boolean',
      name: 'editColumnsEnabled',
      value: true,
      documentation: 'Set this to true to let the user select columns.'
    },
    {
      name: 'ascIcon',
      documentation: 'HTML entity representing unicode Up-Pointing Triangle',
      factory: function() {
        return this.Entity.create({ name: '#9650' });
      }
    },
    {
      name: 'descIcon',
      documentation: 'HTML entity representing unicode Down-Pointing Triangle',
      factory: function() {
        return this.Entity.create({ name: '#9660' });
      }
    },
    {
      name: 'vertMenuIcon',
      documentation: 'HTML entity representing unicode Vertical Ellipsis',
      factory: function() {
        return this.Entity.create({ name: '#8942' });
      }
    },
    {
      name: 'selection',
      expression: function(importSelection) { return importSelection || null; },
    },
    'hoverSelection',
    'dropdownOrigin',
    'overlayOrigin'
  ],

  methods: [
    function sortBy(column) {
      this.order = this.order === column ?
        this.DESC(column) :
        column;
    },

    function createColumnSelection() {
      var editor = this.EditColumnsView.create({
        columns: this.columns,
        columns_$: this.columns_$,
        table: this.of
      });

      return this.OverlayDropdown.create().add(editor);
    },

    /** Adds offset for edit columns overlay dropdown
     * OverlayDropdown adds element to top right of parent container.
     * We want the table dropdown to appear below the dropdown icon.
     */
    function positionOverlayDropdown(columnSelectionE) {
      // Dynamic position calculation
      var origin  = this.dropdownOrigin.el();
      var current = this.overlayOrigin.el();

      var boundingBox = origin.getBoundingClientRect();
      var dropdownMenu = current.getBoundingClientRect();

      columnSelectionE.style({ top: boundingBox.top - dropdownMenu.top + 'px'});
    },

    function initE() {
      var view = this;
      var columnSelectionE;

      if ( view.editColumnsEnabled ) {
        columnSelectionE = view.createColumnSelection();
        this.start('div', null, this.overlayOrigin$).add(columnSelectionE).end();
      }

      this.
        addClass(this.myClass()).
        addClass(this.myClass(this.of.id.replace(/\./g,'-'))).
        setNodeName('table').
        start('thead').
          add(this.slot(function(columns_) {
            return this.E('tr').
              forEach(columns_, function(column) {
                this.start('th').
                  addClass(view.myClass('th-' + column.name)).
                  callIf(column.tableWidth, function() {
                    this.style({width: column.tableWidth});
                  }).
                  on('click', function(e) { view.sortBy(column); }).
                  call(column.tableHeaderFormatter, [column]).
                  add(' ', this.slot(function(order) {
                    return column === order ? view.ascIcon :
                        (view.Desc.isInstance(order) && order.arg1 === column) ? view.descIcon : ''
                  }, view.order$)).
                end();
              }).
              call(function() {
                if ( view.editColumnsEnabled ) {
                  this.start('th').
                    addClass(view.myClass('th-editColumns')).
                    on('click', function(e) {
                      view.positionOverlayDropdown(columnSelectionE);
                      columnSelectionE.open();
                    }).
                    add(' ', view.vertMenuIcon).
                    addClass(view.myClass('vertDots')).
                    addClass(view.myClass('noselect')).
                    tag('div', null, view.dropdownOrigin$)
                  .end();
                }
              })
          })).
          add(this.slot(function(columns_) {
            return this.
              E('tbody').
              select(this.orderedDAO$proxy, function(obj) {
                return this.E('tr').
                  on('mouseover', function() { view.hoverSelection = obj; }).
                  callIf(view.dblclick, function() { this.on('dblclick', function() { view.dblclick && view.dblclick(obj); }); }).
                  on('click', function() {
                    view.selection = obj;
                    if ( view.importSelection$ ) view.importSelection = obj;
                    if ( view.editRecord$ ) view.editRecord(obj);
                  }).
                  addClass(view.slot(function(selection) {
                    return selection && foam.util.equals(obj.id, selection.id) ?
                        view.myClass('selected') : '';
                  })).
                  addClass(view.myClass('row')).
                  forEach(columns_, function(column) {
                    this.
                      start('td').
                        callOn(column.tableCellFormatter, 'format', [
                          column.f ? column.f(obj) : null, obj, column
                        ]).
                      end();
                  }).
                  call(function() {
                    if ( view.editColumnsEnabled ) return this.tag('td');
                  })
              });
          }));
    }
  ]
});
/** 
 * @license
 * Copyright 2017 The FOAM Authors. All Rights Reserved.
 * http://www.apache.org/licenses/LICENSE-2.0
 */

foam.CLASS({
  package: 'foam.u2.view',
  name: 'EditColumnsView',
  extends: 'foam.u2.Element',

  requires: [
    'foam.u2.md.CheckBox'
  ],

  properties: [
    {
      name: 'columns'
    },
    {
      name: 'table'
    },
    {
      name: 'columns_'
    },
    {
      name: 'selected'
    },
    {
      class: 'Boolean',
      name: 'displaySorted',
      value: false
    }
  ],
  
  methods: [
    function initE() {
      // if ( this.displaySorted ) {
      //   // TODO: How should this block be tested?
      //   var props = this.properties;
      //   props = this.properties.slice();
      //   props.sort(function(a, b) {
      //     return a.label.toLowerCase().compareTo(b.label.toLowerCase());
      //   });
      // } else { ...

      this.selected = []

      for ( var i = 0 ; i < this.columns_.length ; i++ ) {
        var cb = this.CheckBox.create({
          label: this.columns_[i].label,
          data: true
        });

        this.selected.push(cb.data$);
        var name = this.columns_[i].name;

        // Subscribes updateTable listener to checkbox data
        cb.data$.sub(this.updateTable.bind(this, name));

        this.add(cb);

        // Ensures each selection is on a new line
        if ( i != this.columns_.length - 1 ) this.start('br').end();
      }
    }
  ],

  listeners: [
    function updateTable(changedProp) {
      var cols = [];

      // if ( this.displaySorted ) {
      //   // TODO: How should this block be tested?
      //   out = this.selectedProperties.slice();
      //   if ( nu && !selected[changedProp.name] ) {
      //     out.push(changedProp);
      //   }
      //   if ( !nu && selected[changedProp.name] ) {
      //     out.splice(out.indexOf(changedProp), 1);
      //   }
      // }
      // else { ...

      for ( var i = 0 ; i < this.columns.length ; i++ ) {
        var cbData = this.selected[i].obj.data;
        var isColShown = this.columns_.some(c => c.name === this.columns[i]);
        var curProp = this.columns[i];

        // Determines if the curProp is the one which has changed,
        // if so adds col if cb is checked. Otherwise if curProp hasn't
        // changed, then checks if it was previously shown, if so, keeps in view.
        if ( ((changedProp == curProp) && cbData) ||
             ((changedProp != curProp) && isColShown) ) {
          // Gets the table column from the column name, and pushes to cols array
          cols.push(this.table.getAxiomByName(curProp))
        }
      }

      this.columns_ = cols;
    }
  ]
});
/**
 * @license
 * Copyright 2017 The FOAM Authors. All Rights Reserved.
 * http://www.apache.org/licenses/LICENSE-2.0
 */

foam.CLASS({
  package: 'foam.u2.md',
  name: 'OverlayDropdown',
  extends: 'foam.u2.Element',

  imports: [
    'window'
  ],

  exports: [
    'as dropdown'
  ],

  documentation: 'A popup overlay that grows from the top-right corner of ' +
      'its container. Useful for e.g. "..." overflow menus in action bars. ' +
      'Just $$DOC{ref:".add"} things to this container.',

  css: `
    ^overlay {
      position: fixed;
      z-index: 1009;
    }

    ^container {
      position: absolute;
      right: 0;
      top: 0;
      z-index: 100;
    }

    ^ {
      background: white;
      box-shadow: 0 1px 3px rgba(0, 0, 0, 0.38);
      display: block;
      font-size: 13px;
      font-weight: 400;
      overflow-x: hidden;
      overflow-y: hidden;
      position: absolute;
      width: 125px;
      padding: 10px;
      padding-bottom: -20px;
      margin-bottom: -20px;
      right: 3px;
      top: 4px;
      transition: height 0.25s cubic-bezier(0, .3, .8, 1);
      z-index: 1010;
    }

    ^open {
      overflow-y: auto;
    }

    ^zeroOverlay {
      top: 0;
      bottom: 0;
      left: 0;
      right: 0;
    }

    ^initialOverlay {
      top: initial;
      bottom: initial;
      left: initial;
      right: initial;
    }

    ^parents {
      z-index: 1000 !important;
    }
  `,

  constants: {
    BOTTOM_OFFSET: -25,
  },

  properties: [
    {
      class: 'Float',
      name: 'height',
      value: 0
    },
    {
      class: 'Boolean',
      name: 'opened',
      documentation: 'True when the overlay has been commanded to be open. ' +
          'It might still be animating; see $$DOC{ref:".animationComplete"}.',
    },
    {
      class: 'Boolean',
      name: 'animationComplete',
      documentation: 'True when an animation is running. The overlay hasn\'t ' +
          'really reached the state commanded by $$DOC{ref:".opened"} until ' +
          'this is true.',
      value: true
    },
    {
      name: 'dropdownE_',
      factory: function() {
        return this.E('dropdown');
      }
    },
    {
      name: 'addToSelf_',
      value: false
    }
  ],

  methods: [
    function add() {
      // TODO: Replace with content @kgr
      if ( this.addToSelf_ ) {
        this.SUPER.apply(this, arguments);
      } else {
        this.dropdownE_.add.apply(this.dropdownE_, arguments);
      }

      return this;
    },

    function open() {
      if ( this.opened ) return;

      this.onOpenStart();

      this.animationComplete = false;
      this.opened = true;
      this.dropdownE_.style({ height: this.getFullHeight() + 'px' });
    },

    function close() {
      if ( ! this.opened ) return;
      this.height = 0;
      this.animationComplete = false;
      this.opened = false;
      this.dropdownE_.style({ height: 0 + 'px' });
    },

    function getFullHeight() {
      if ( this.state !== this.LOADED ) return 0;

      var myStyle = this.window.getComputedStyle(this.dropdownE_.el());

      var first = this.dropdownE_.children[0].el();
      var top = first.offsetTop;
      var last = this.dropdownE_.children[this.dropdownE_.children.length - 1]
          .el();
      var margin = parseInt(
          this.window.getComputedStyle(last)['margin-bottom']);
      if ( Number.isNaN(margin) ) margin = 0;
      var bottom = last.offsetTop + last.offsetHeight + margin;

      var childrenHeight = bottom - top;
      var maxHeight = this.window.innerHeight -
            this.dropdownE_.el().getBoundingClientRect().top +
            this.BOTTOM_OFFSET;

      return Math.min(childrenHeight, maxHeight);
    },

    function initE() {
      this.addToSelf_ = true;
      this.addClass(this.myClass('container'));
      var view = this;

      this.addClass(this.slot(function(open, animationComplete) {
        this.shown = open || ! animationComplete;
      }, this.opened$, this.animationComplete$));

      this.start('dropdown-overlay')
        .addClass(this.myClass('overlay'))
        .addClass(this.slot(function(open) {
          return open ? view.myClass('zeroOverlay') :
              view.myClass('initialOverlay');
        }, this.opened$))
        .on('click', this.onCancel)
      .end();

      this.dropdownE_.addClass(this.myClass()).style({height: '0px'})
        .addClass(this.slot(function(opened, animationComplete) {
          var openComplete = opened && animationComplete;
          return openComplete ? this.myClass('open') : '';
        }, this.opened$, this.animationComplete$))
        .on('transitionend', this.onTransitionEnd)
        .on('mouseleave', this.onMouseLeave)
        .on('click', this.onClick);

      this.add(this.dropdownE_);

      this.addToSelf_ = false;
    }
  ],

  listeners: [
    function onCancel() {
      this.close();
    },

    function onTransitionEnd() {
      this.animationComplete = true;
      if (!this.opened) this.onCloseComplete();
    },

    function onMouseLeave(e) {
      console.assert(e.target === this.dropdownE_.el(),
          'mouseleave should only fire on this, not on children');
      this.close();
    },

    /**
     * Prevent clicks inside the dropdown from closing it.
     * Block them before they reach the overlay.
     */
    function onClick(e) {
      e.stopPropagation();
    },

    function onOpenStart() {
      var parent = this.el().parentElement;
      var parentClass = this.myClass('parents');
      while (parent) {
        parent.classList.add(parentClass);
        parent = parent.parentElement;
      }
    },

    function onCloseComplete() {
      var parent = this.el().parentElement;
      var parentClass = this.myClass('parents');
      while (parent) {
        parent.classList.remove(parentClass);
        parent = parent.parentElement;
      }
    }
  ]
});
/**
 * @license
 * Copyright 2017 The FOAM Authors. All Rights Reserved.
 * http://www.apache.org/licenses/LICENSE-2.0
 */

 foam.CLASS({
  package: 'foam.u2.view',
  name: 'ScrollTableView',
  extends: 'foam.u2.Element',

  requires: [
    'foam.dao.FnSink',
    'foam.graphics.ScrollCView',
    'foam.mlang.sink.Count',
    'foam.u2.view.TableView'
  ],

  properties: [
    {
      class: 'foam.dao.DAOProperty',
      name: 'data'
    },
    {
      class: 'Int',
      name: 'limit',
      value: 18,
      // TODO make this a funciton of the height.
    },
    {
      class: 'Int',
      name: 'skip',
    },
    {
      class: 'foam.dao.DAOProperty',
      name: 'scrolledDao',
      expression: function(data, limit, skip) {
        return data.limit(limit).skip(skip);
      },
    },
    'columns',
    {
      class: 'Int',
      name: 'daoCount'
    },
    'selection'
  ],

  methods: [
    function init() {
      this.onDetach(this.data$proxy.listen(this.FnSink.create({fn:this.onDaoUpdate})));
      this.onDaoUpdate();
    },

    function initE() {
      // TODO probably shouldn't be using a table.
      this.start('table').
        on('wheel', this.onWheel).
        start('tr').
          start('td').
            style({ 'vertical-align': 'top' }).
            start(this.TableView, {data$: this.scrolledDao$, columns: this.columns, selection$: this.selection$}).
            end().
          end().
          start('td').style({ 'vertical-align': 'top' }).
            add(this.ScrollCView.create({
              value$: this.skip$,
              extent$: this.limit$,
              height: 40*18+41, // TODO use window height.
              width: 15,
              size$: this.daoCount$,
            })).
          end().
        end().
      end();
    }
  ],

  listeners: [
    {
      name: 'onWheel',
      code: function(e) {
        var negative = e.deltaY < 0;
        // Convert to rows, rounding up. (Therefore minumum 1.)
        var rows = Math.ceil(Math.abs(e.deltaY) / /*self.rowHeight*/ 40);
        this.skip += negative ? -rows : rows;
        e.preventDefault();
      }
    },
    {
      // TODO Avoid onDaoUpdate approaches.
      name: 'onDaoUpdate',
      isFramed: true,
      code: function() {
        var self = this;
        this.data$proxy.select(this.Count.create()).then(function(s) {
          self.daoCount = s.value;
        })
      },
    },
  ]
});
/**
 * @license
 * Copyright 2017 The FOAM Authors. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

foam.CLASS({
  package: 'foam.u2.view',
  name: 'ScrollDAOView',
  extends: 'foam.u2.Element',
  implements: [ 'foam.mlang.Expressions' ],

  documentation: 'A DOM-based native scrolling view over for a DAO.',

  css: `
    ^ {
      margin: 0;
      padding: 0;
      overflow-x: hidden;
      overflow-y: scroll;
      -webkit-overflow-scrolling: touch;
      width: 100%;
      height: 100%;
      position: absolute;
      box-sizing: border-box;
      contain: layout;
      will-change: transform;
    }
  `,

  requires: [
    'foam.dao.QuickSink',
    'foam.u2.ViewSpec'
  ],
  imports: [
    'selection as importedSelection',
    'selectionEnabled as importedSelectionEnabled'
  ],
  // Provide most state to inner controller and views.
  exports: [
    'anchorDAOIdx_',
    'anchorRowIdx_',
    'batchSize',
    'count_',
    'data',
    'modNumRows_',
    'negativeRunway',
    'numRows',
    'positiveRunway',
    'rows_',
    'rowFormatter',
    'selection',
    'selectionEnabled'
  ],

  properties: [
    {
      class: 'foam.dao.DAOProperty',
      name: 'data',
      documentation: 'The DAO to the full set of data visible to this view.',
      postSet: function(old, nu) {
        if ( old === nu ) return;
        this.listenSub_ && this.listenSub_.detach();
        if ( ! nu ) return;

        var self = this;
        self.listenSub_ = nu.listen(this.QuickSink.create({
          // TODO(markdittmer): Model this?
          resetFn: function() { self.countRecords_(); }
        }));
        self.countRecords_();
      },
      required: true
    },
    {
      class: 'FObjectProperty',
      of: 'foam.u2.RowFormatter',
      name: 'rowFormatter',
      documentation: `data => HTML-markup-string formatter for individual rows.
          This strategy is used instead of Elements to maximize scroll
          performance.`,
      preSet: function(_, nu) {
        return nu && nu.clone ? nu.clone(this) : nu;
      },
      required: true
    },
    {
      class: 'Int',
      name: 'rowHeight',
      documentation: 'Fixed of pixels per row.',
      value: 40,
      required: true,
      final: true
    },
    {
      class: 'Int',
      name: 'numRows',
      documentation: 'Fixed number of rows to recycle within this view.',
      value: 20,
      required: true,
      final: true
    },
    {
      class: 'Int',
      name: 'negativeRunway',
      documentation: 'Number of records to load before anchor row.',
      value: 500
    },
    {
      class: 'Int',
      name: 'positiveRunway',
      documentation: 'Number of records to load after+including anchor row.',
      value: 500
    },
    {
      class: 'Int',
      name: 'rowOffset',
      expression: function(numRows) { return Math.floor(numRows * 0.4); }
    },
    {
      class: 'Int',
      name: 'batchSize',
      documentation: `Size for batch of data to fetch from DAO. This view will
          keep fetching batches until it fills out all rows, but requesting
          batches limits the number of rows to be processed per animation
          frame.`,
      value: 25
    },
    {
      class: 'Boolean',
      name: 'selectionEnabled',
      factory: function() {
        return !! this.importedSelectionEnabled;
      }
    },
    {
      class: 'Array',
      name: 'selection',
      adapt: function(_, nu) {
        if ( foam.Null.isInstance(nu) || foam.Undefined.isInstance(nu) )
          return [];

        return foam.Array.isInstance(nu) ? nu : [nu];
      },
    },
    {
      class: 'FObjectProperty',
      // of: 'DAOController',
      name: 'daoController_',
      documentation: `Private component responsible for fetching batches of data
          and efficiently rendering in-view data as it arrives.`,
      factory: function() { return this.DAOController.create(); }
    },
    {
      name: 'listenSub_',
      documentation: 'Subscription used to listen for DAO reset.',
      value: null,
      transient: true
    },
    {
      class: 'Int',
      name: 'anchorRowIdx_',
      documentation: 'Anchor index in "rows_" array.',
      factory: function() { return this.negativeRunway; },
      transient: true
    },
    {
      class: 'Int',
      name: 'anchorDAOIdx_',
      documentation: `Anchor index relative to top of view (i.e., to first
          record in "dao").`,
      transient: true
    },
    {
      class: 'Int',
      name: 'count_',
      documentation: 'Count of records to display in this view.'
    },
    {
      class: 'FObjectArray',
      of: 'foam.u2.Element',
      name: 'rows_',
      documentation: 'Direct child views of this view to recycle.',
      factory: function() {
        var rows = new Array(this.numRows);
        for ( var i = 0; i < rows.length; i++ ) {
          rows[i] = this.Row.create();
        }
        return rows;
      },
      transient: true
    },
    {
      class: 'FObjectProperty',
      of: 'foam.u2.Element',
      name: 'sentinel_',
      documentatin: `Absolutely positioned single pixel that establishes the
          height of the scroll container.`,
      factory: function() {
        return this.E('div').style({
          width: '1px',
          height: '1px',
          'font-size': '1px',
          position: 'absolute',
          transform: this.sentinelTransform_$
        }).entity('nbsp');
      },
      transient: true
    },
    {
      class: 'Int',
      name: 'sentinelY_',
      documentation: `Y-index (in pixels) of "sentinel_", relative to top of
          this view (the scroll container).`,
      expression: function(rowHeight, count_) {
        return ( count_ * rowHeight ) - 1;
      },
      transient: true
    },
    {
      class: 'String',
      name: 'sentinelTransform_',
      documentation: 'CSS transform for "sentinel_".',
      expression: function(sentinelY_) {
        return 'translate(0px, ' + sentinelY_ + 'px)';
      },
      transient: true
    },
    {
      class: 'Boolean',
      name: 'anchorLock_',
      documentation: `A synchronization variable to prevent unhandled scroll
          events from firing when "count_" (and therefore "sentinel_" location)
          changes.`,
      transient: true
    },
    {
      class: 'Int',
      name: 'fetchId_',
      documentation: `A synchronization variable to prevent halt batch fetching
          of results if fetching from a new starting point has already
          commenced.`,
      transient: true
    },
    {
      class: 'Function',
      name: 'modNumRows_',
      documentation: `Helper function for row arithmetic. A property rather than
          a method for easy export to inner class instances that use it.`,
      value: function(num) {
        if ( this.numRows === 0 ) return 0;
        var ret = num % this.numRows;
        if ( ret < 0 ) ret = ret + this.numRows;
        return ret;
      },
      transient: true
    }
  ],

  classes: [
    {
      name: 'Row',
      extends: 'foam.u2.Element',

      documentation: `Recycled DOM rows. The "view" ViewSpec is used to manually
          tear down and rebuild row contents whenever "data" changes. Scroll
          performance is optimized by using an inner view with no dynamic
          bindings so that the only DOM operation is the row completely
          replacing its contents.`,

      imports: [
        'columns?',
        'rowFormatter',
        'selection',
        'selectionEnabled'
      ],

      axioms: [
        foam.u2.CSS.create({
          code: function CSS() {/*
            ^ {
              display: block;
              contain: layout;
              will-change: transform;
              padding: 5px;
              box-sizing: border-box;
              -webkit-user-select: none;
              -moz-user-select: none;
              -ms-user-select: none;
              user-select: none;
            }
            ^selectable:hover {
              filter: opacity(0.8);
              cursor: pointer;
            }
            ^selected {
              filter: opacity(0.7) !important;
            }
        */}
        })
      ],

      properties: [
        [ 'nodeName', 'li' ],
        {
          name: 'data',
          postSet: function(old, nu) {
            if ( this.state !== this.LOADED ) return;
            const htmlStr = this.rowFormatter.format(
              nu, this.columns);
            this.el().innerHTML = htmlStr;
          }
        }
      ],

      methods: [
        function init() {
          this.onload.sub(this.render);
        },
        function initE() {
          var self = this;
          this.addClass(this.myClass());
          this.enableClass(this.myClass('selectable'), this.selectionEnabled$);
          this.enableClass(
              this.myClass('selected'),
              this.slot(function(selectionEnabled, data, selection) {
                if ( ! data || ! selectionEnabled ||
                     selection.length === 0 ) {
                  return false;
                }

                return selection.some(function(d) {
                  return d.id === data.id;
                });
              }, this.selectionEnabled$, this.data$, this.selection$));
          this.on('click', function(evt) {
            if ( ! self.data ) return;

            var oldNum = self.selection.length;
            var newSelection = self.selection.filter(function(d) {
              return ! foam.util.equals(d.id, self.data.id);
            });

            // If length didn't change, add to selection. Otherwise, filter()
            // already committed removal action.
            if ( newSelection.length === oldNum ) {
              newSelection.push(self.data);
            }

            self.selection = newSelection;
          });
          this.columns$ && this.columns$.sub(this.render);
        }
      ],

      listeners: [
        function render() {
          this.el().innerHTML = this.rowFormatter.format(this.data,
                                                         this.columns);
        }
      ]
    },
    {
      name: 'DAOController',

      documentation: `Controller responsible for fetching batches of data for
          ScrollDAOView. Data are fetched in multiple small batch to avoid
          blocking the main thread to parse large amounts of data.

          Data are fetched in a window around the current scroll position and
          inserted into row views as soon as they are available. Since the user
          may "jump" to a far away scroll position, this controller keeps track
          of a list of ranges, and only fetches missing data in the current
          scroll window. The onReset() listener throws away data and ranges.

          A smaller window (the "buffer") must contain gaps to trigger a data
          fetch. When a fetch is triggered a larger window (the "runway")
          defines which records to fetch:

                    anchorDAOIdx_ ----v
                                      <-- numRows -->
                  <- negativeBuffer ->               <- positiveBuffer ->
            <------- negativeRunway ->               <-- positiveRunway ------->
            |||||||||||||||| records filled after batched fetch ||||||||||||||||
          `,

      // ScrollDAOView state needed for data fetching and immediate row
      // insertion.
      imports: [
        'anchorDAOIdx_',
        'anchorRowIdx_',
        'batchSize',
        'count_',
        'data as dao',
        'modNumRows_',
        'negativeRunway',
        'numRows',
        'positiveRunway',
        'rows_'
      ],

      properties: [
        {
          class: 'Int',
          name: 'negativeBuffer',
          documentation: `The area behind the current anchor where a gap may
              trigger a data fetch`,
          expression: function(negativeRunway, numRows) {
            return Math.max(Math.ceil(negativeRunway / 5, numRows));
          }
        },
        {
          class: 'Int',
          name: 'positiveBuffer',
          documentation: `The area in front of the current anchor where a gap
              may trigger a data fetch`,
          expression: function(positiveRunway, numRows) {
            return Math.max(Math.ceil(positiveRunway / 5, numRows));
          }
        },
        {
          name: 'data',
          factory: function() { return {}; }
        },
        {
          class: 'Array',
          name: 'ranges'
        }
      ],

      methods: [
        function init() {
          this.anchorDAOIdx_$.sub(this.onMove);
          this.negativeRunway$.sub(this.onMove);
          this.numRows$.sub(this.onMove);
          this.positiveRunway$.sub(this.onMove);
          this.onMove();
          this.SUPER();
        },
        function missingData_(start, end) {
          var ranges = this.ranges;
          var iterAfterRange = true;
          var i;
          for ( i = this.ranges.length - 1; i >= 0; i-- ) {
            if ( ranges[i][0] <= end ) break;
          }
          if ( i < 0 ) return [ [ start, end ] ];
          if ( ranges[i][0] <= start && ranges[i][1] >= end ) return null;
          var foundGaps = ranges[i][1] < end ? [ [ ranges[i][1], end ] ] : [];
          var gapEnd = ranges[i][0];
          for ( i--; i >= 0; i-- ) {
            var range = ranges[i];
            if ( range[1] < start ) {
              foundGaps.push([ start, gapEnd ]);
              break;
            }
            foundGaps.push([ range[1], gapEnd ]);
            gapEnd = range[0];
          }
          return foundGaps;
        },
        function fetchData_(start, end, gaps) {
          var viewStart = this.anchorDAOIdx_;
          var viewEnd = viewStart + this.numRows;
          var runwayStart = Math.max(0, viewStart - this.negativeRunway);
          var runwayEnd = Math.min(this.count_, viewEnd + this.positiveRunway);

          if ( runwayStart < start ) {
            var before = this.missingData_(runwayStart, gaps[0][1]);
            gaps = before ? before.concat(gaps.slice(1)) : gaps;
          }
          if ( runwayEnd > end ) {
            var after = this.missingData_(gaps[gaps.length - 1][0], runwayEnd);
            gaps = after ? gaps.slice(0, -1).concat(after) : gaps;
          }

          this.fetchChunks_(gaps);

          var a = this.ranges;
          var b = gaps;
          var i = 0;
          var j = 0;
          while ( i < a.length || j < b.length ) {
            if ( j >= b.length ) break;
            if ( i >= a.length ) {
              a = a.concat(b.slice(j));
              break;
            }
            if ( a[i][0] <= b[j][0] ) {
              if ( b[j][0] <= a[i][1] ) {
                a[i][1] = Math.max(a[i][1], b[j][1]);
                j++;
              }
            } else {
              if ( a[i][0] <= b[j][1] ) {
                a[i][0] = b[j][0];
                a[i][1] = Math.max(a[i][1], b[j][1]);
              }
              j++;
            }
            for ( var k = i + 1; k < a.length; k++ ) {
              if ( a[i][1] < a[k][0] ) break;
              a[i][1] = a[k][1];
            }
            i = k;
          }

          this.ranges = a;
        },
        function fetchChunks_(chunks) {
          for ( var i = 0; i < chunks.length; i++ ) {
            this.fetchBatches_(chunks[i][0], chunks[i][1]);
          }
        },
        function fetchBatches_(start, end) {
          var self = this;
          var batchSize = self.batchSize;
          var skip = start;
          var limit = Math.min(start + self.batchSize, end);
          var fetchBatch = function() {
            self.dao.skip(skip).limit(limit).
              select().then(function(sink) {
                while ( ! sink.array ) {
                  sink = sink.delegate;
                }
                var array = sink.array;
                var daoStart = self.anchorDAOIdx_;
                var daoEnd = Math.min(self.count_,
                                      self.anchorDAOIdx_ + self.numRows);
                for ( var i = 0; i < array.length; i++ ) {
                  var daoIdx = skip + i;
                  self.data[daoIdx] = array[i];
                  if ( daoIdx >= daoStart && daoIdx < daoEnd ) {
                    var anchorRelativeIdx = daoIdx - daoStart;
                    var rowIdx = self.modNumRows_(self.anchorRowIdx_ +
                                                  anchorRelativeIdx);
                    var row = self.rows_[rowIdx];
                    row.data = array[i];
                  }
                }

                skip += batchSize;
                limit = Math.min(batchSize, end - skip);
                // TODO(markdittmer): Import rAF.
                if ( limit > 0 ) window.requestAnimationFrame(fetchBatch);
              });
          };
          fetchBatch();
        }
      ],

      listeners: [
        function onMove() {
          var viewStart = this.anchorDAOIdx_;
          var viewEnd = viewStart + this.numRows;
          var bufferStart = Math.max(0, viewStart -
                                     ( this.negativeRunway / 4 ));
          var bufferEnd = Math.min(this.count_,
                                   viewEnd + ( this.positiveRunway / 4 ));

          var gaps = this.missingData_(bufferStart, bufferEnd);
          if ( ! gaps ) return;
          this.fetchData_(bufferStart, bufferEnd, gaps);
        },
        function onReset() {
          this.data = {};
          this.ranges = [];
          this.onMove();
        }
      ]
    }
  ],

  methods: [
    function init() {
      if ( this.importedSelection$ ) {
        this.selection$.linkFrom(this.importedSelection$);
      }
      if ( this.data ) this.countRecords_();
      this.SUPER();
    },
    function initE() {
      this.addEventListener('scroll', this.onScroll);
      this.
        setNodeName('ul').
        add(this.sentinel_).
        addClass(this.myClass()).
        forEach(this.rows_, function(row, idx) {
          this.add(row);
          // Lay out row either:
          // (1) Where it belongs in positive runway,
          // or
          // (2) Just above first record.
          var y = idx < this.count_ ?
                ( idx - this.negativeRunway ) * this.rowHeight :
                -this.rowHeight;
          row.style({
            position: 'absolute',
            transform: 'translateY(' + y +'px)',
            height: this.rowHeight + 'px',
            width: '100%'
          });
        });

      this.SUPER();
    },
    {
      name: 'moveAnchor_',
      documentation: `Layout rows according to new anchor "DAO idx" (i.e.,
          idx relative to first record in view).`,
      code: function(anchorDAOIdx) {
        var daoIdxDelta = anchorDAOIdx - this.anchorDAOIdx_;
        if ( Math.abs(daoIdxDelta) >= this.numRows )
          return this.resetAnchor_(anchorDAOIdx);

        if ( daoIdxDelta >= 0 ) return this.moveAnchorForward_(anchorDAOIdx);
        return this.moveAnchorBackward_(anchorDAOIdx);
      }
    },
    {
      name: 'resetAnchor_',
      documentation: `Layout all rows according to new anchor DAO idx. Generally
          used when scroll jump exceeds row window size or on data reset.`,
      code: function(anchorDAOIdx) {
        var baseDAOIdx = anchorDAOIdx;
        for ( var i = 0; i < this.numRows; i++ ) {
          var row = this.rows_[i];
          var idx = baseDAOIdx + i;
          row.data = this.daoController_.data[idx] || null;
          this.translateRowTo_(idx < this.count_ ? idx : -1, row);
        }

        this.anchorDAOIdx_ = anchorDAOIdx;
        this.anchorRowIdx_ = 0;
      }
    },
    {
      name: 'moveAnchorForward_',
      documentation: `Layout necessary rows for anchor moving forward within row
          window.`,
      code: function(anchorDAOIdx) {
        var delta = anchorDAOIdx - this.anchorDAOIdx_;
        var daoStart = this.anchorDAOIdx_ + this.numRows;
        for ( var i = 0; i < delta; i++ ) {
          var rowIdx = this.modNumRows_(this.anchorRowIdx_ + i);
          var row = this.rows_[rowIdx];
          var idx = daoStart + i < this.count_ ? daoStart + i : -1;
          row.data = this.daoController_.data[idx] || null;
          this.translateRowTo_(idx, row);
        }
        this.anchorDAOIdx_ = anchorDAOIdx;
        this.anchorRowIdx_ = this.modNumRows_(this.anchorRowIdx_ + delta);
      }
    },
    {
      name: 'moveAnchorBackward_',
      documentation: `Layout necessary rows for anchor moving backward within
          row window.`,
      code: function(anchorDAOIdx) {
        var delta = this.anchorDAOIdx_ - anchorDAOIdx;
        var rowStart = this.anchorRowIdx_ + this.numRows;
        for ( var i = 1; i <= delta; i++ ) {
          var rowIdx = this.modNumRows_(rowStart - i);
          var row = this.rows_[rowIdx];
          var idx = this.anchorDAOIdx_ - i >= 0 ?
              this.anchorDAOIdx_ - i : -1;
          row.data = this.daoController_.data[idx] || null;
          this.translateRowTo_(idx, row);
        }
        this.anchorDAOIdx_ = anchorDAOIdx;
        this.anchorRowIdx_ = this.modNumRows_(this.anchorRowIdx_ - delta);
      }
    },
    {
      name: 'translateRowTo_',
      documentation: 'Helper to change row CSS transform to a new DAO idx.',
      code: function(daoIdx, row) {
        row.style({
          transform: 'translateY(' + ( daoIdx * this.rowHeight ) + 'px)'
        });
      }
    },
    {
      name: 'countRecords_',
      documentation: `Count records in "dao", then update view accordingly.
          Assume that a (re)count implies any data may change (and therefore
          data should be re-fetched). Any change in the location of "count_"
          within the row window triggers layout of all rows.`,
      code: function() {
        var self = this;
        return self.data.select(self.COUNT()).then(function(count) {
          // Prevent unhandled scroll events from firing and potentially laying
          // out rows past the new "sentinel_" location.
          self.anchorLock_ = true;

          var oldCount = self.count_;
          var newCount = self.count_ = count.value;
          var endIdx = self.anchorDAOIdx_ + self.numRows;

          // Choose a reasonable anchor for new count.
          var anchorDAOIdx = Math.min(
            self.anchorDAOIdx_,
            Math.max(0, self.count_ - self.numRows));

          // Update scroll-indicating state first, then reset DAOController.
          self.anchorDAOIdx_ = anchorDAOIdx;
          self.anchorRowIdx_ = 0;
          self.daoController_.onReset();

          // Like resetAnchor_, but lay out all rows.
          var baseDAOIdx = anchorDAOIdx;
          for ( var i = 0; i < self.numRows; i++ ) {
            var row = self.rows_[i];
            var idx = baseDAOIdx + i;
            row.data = self.daoController_.data[idx] || null;
            self.translateRowTo_(idx < self.count_ ? idx : -1, row);
          }
        });
      }
    }
  ],

  actions: [
    {
      name: 'clearSelection',
      isEnabled: function(selectionEnabled) { return selectionEnabled; },
      keyboardShortcuts: [27], // Escape.
      code: function() { this.selection = []; }
    }
  ],

  listeners: [
    {
      name: 'onScroll',
      documentation: 'Respond to scroll: Move the anchor.',
      isFramed: true,
      code: function(domEvt) {
        if ( this.anchorLock_ ) {
          this.anchorLock_ = false;
          return;
        }

        var top = domEvt.target.scrollTop;
        var recordTop = Math.floor(top / this.rowHeight);

        // Situate anchor with 40% of rows scrolled above. This makes any lag
        // from fast scrolling roughly symmetrical on scroll-up/scroll-down.
        var rowsAbove = 0.4 * this.numRows;
        var anchorDAOIdx;
        if ( recordTop < rowsAbove ) {
          anchorDAOIdx = 0;
        } else {
          anchorDAOIdx = recordTop - rowsAbove;
        }
        if ( anchorDAOIdx === this.anchorDAOIdx_ ) return;

        this.moveAnchor_(anchorDAOIdx);
      }
    }
  ]
});
/**
 * @license
 * Copyright 2017 The FOAM Authors. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

foam.CLASS({
  package: 'foam.u2.view',
  name: 'BlobView',
  extends: 'foam.u2.Element',
  requires: [
    'foam.blob.BlobBlob'
  ],
  imports: [
    'blobService'
  ],
  properties: [
    'data',
    {
      class: 'String',
      name: 'filename'
    },
    {
      class: 'String',
      name: 'type'
    },
    {
      class: 'DateTime',
      name: 'timestamp'
    }
  ],
  methods: [
    function initE() {
      var view = this;
      this.
        setNodeName('span').
        start('input').attrs({ type: 'file' }).on('change', this.onChange).end().
        add(this.slot(function(data) {
          var url = data && view.blobService.urlFor(data);
          return ! url ? this.E('span') :
            this.E('a').attrs({ href: url }).add('Download')
        }, this.data$));
    }
  ],
  listeners: [
    function onChange(e) {
      var file = e.target.files[0];

      this.data = this.BlobBlob.create({
        blob: file
      });
      this.filename = file.name;
      this.timestamp = new Date(file.lastModified);
      this.type = file.type;
    }
  ]
});
/**
 * @license
 * Copyright 2018 The FOAM Authors. All Rights Reserved.
 * http://www.apache.org/licenses/LICENSE-2.0
 */

foam.CLASS({
  package: 'foam.u2.view',
  name: 'FileView',
  extends: 'foam.u2.Element',

  requires: [
    'foam.blob.BlobBlob',
    'foam.nanos.fs.File'
  ],

  imports: [
    'blobService'
  ],

  properties: [
    'data'
  ],

  methods: [
    function initE() {
      var view = this;
      this.setNodeName('span')
        .start('input').attrs({ type: 'file' }).on('change', this.onChange).end()
        .add(this.slot(function(data) {
          var file = data && data.data;
          var url = file && view.blobService.urlFor(file);
          return ! url ? this.E('span') : this.E('a').attrs({ href: url }).add('Download')
        }, this.data$));
    }
  ],

  listeners: [
    function onChange (e) {
      var file = e.target.files[0];

      this.data = this.File.create({
        filename: file.name,
        filesize: file.size,
        mimeType: file.type,
        data: this.BlobBlob.create({
          blob: file
        })
      });
    }
  ]
});
/**
 * @license
 * Copyright 2017 The FOAM Authors. All Rights Reserved.
 * http://www.apache.org/licenses/LICENSE-2.0
 */

foam.CLASS({
  package: 'foam.u2.view',
  name: 'ImageBlobView',
  extends: 'foam.u2.View',
  requires: [
    'foam.blob.BlobBlob'
  ],
  imports: [
    'blobService'
  ],
  properties: [
    'data',
  ],
  methods: [
    function initE() {
      var view = this;
      this.
        start('img').
        attrs({
          src: this.data$.map(function(data) {
            return view.BlobBlob.isInstance(data) ?
              URL.createObjectURL(data.blob) :
              ( view.blobService.urlFor(data) || '' );
          })
        }).
        end().
        add(this.slot(function(mode) {
          if ( mode == foam.u2.DisplayMode.RW ) {
            return this.
              E('input').
              attrs({ type: 'file' }).
              on('change', this.onChange);
          }
          return this.E('span');
        }, this.mode$));
    }
  ],
  listeners: [
    function onChange(e) {
      var file = e.target.files[0];

      this.data = this.BlobBlob.create({
        blob: file
      });
    }
  ]
});
/**
 * @license
 * Copyright 2017 The FOAM Authors. All Rights Reserved.
 * http://www.apache.org/licenses/LICENSE-2.0
 */

foam.CLASS({
  package: 'foam.u2.view',
  name: 'StringArrayView',
  extends: 'foam.u2.tag.Input',

  properties: [
    {
      name: 'data',
      preSet: function(o, d) { return d; }
    },
    {
      class: 'Function',
      name: 'valueToText',
      value: function(value) {
        return value.map(function(m) {
          return m.replace("\\", "\\\\").replace(",", "\\,");
        }).join(',');
      }
    },
    {
      class: 'Function',
      name: 'textToValue',
      value: function(text) {
        if ( ! text ) return [];

        var value  = [];
        var escape = false;
        var start  = 0;
        for ( var i = 0 ; i < text.length ; i++ ) {
          if ( escape ) {
            escape = false;
            continue;
          }

          if ( i == text.length - 1 ) {
            value.push(text.substring(start, i+1).replace(/\\(.)/, "$0"));
          } else if ( text[i] == ',' || i == text.length - 1 ) {
            value.push(text.substring(start, i).replace(/\\(.)/, "$0"));
            start = i + 1;
          } else if ( text[i] == '\\' ) {
            escape = true;
          }
        }

        return value;
      }
    }
  ],

  methods: [
    function link() {
      this.attrSlot().relateFrom(this.data$, this.textToValue, this.valueToText);
    }
  ]
});
/**
 * @license
 * Copyright 2017 The FOAM Authors. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

foam.CLASS({
  package: 'foam.u2.view',
  name: 'ImageView',
  extends: 'foam.u2.Element',
  properties: [
    'data',
    ['nodeName', 'img']
  ],
  methods: [
    function initE() {
      this.attrs({ src: this.data$ });
    }
  ]
});
/**
 * @license
 * Copyright 2017 The FOAM Authors. All Rights Reserved.
 * http://www.apache.org/licenses/LICENSE-2.0
 */

foam.CLASS({
  package: 'foam.u2',
  name: 'EnumView',
  extends: 'foam.u2.view.ChoiceView',

  properties: [
    {
      class: 'Class',
      name: 'of',
      required: true
    },
    {
      name: 'choices',
      expression: function(of) {
        return of ? of.VALUES.map(function(v) { return [ v, v.label ]; }) : [];
      }
    }
  ],

  methods: [
    function fromProperty(p) {
      this.SUPER(p);
      if ( ! this.of ) this.of = p.of;
    }
  ]
})
/**
 * @license
 * Copyright 2017 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

foam.CLASS({
  package: 'foam.u2',
  name: 'ClassView',
  extends: 'foam.u2.TextField',

  documentation: 'View for editing a Class Property.',

  properties: [
    { class: 'Class', name: 'data' }
  ],

  methods: [
    function link() {
      this.attrSlot(null, null).relateFrom(
          this.data$,
          this.textToData.bind(this),
          this.dataToText.bind(this));
    },

    function dataToText(c) {
      return c ? c.id : '';
    },

    function textToData(text) {
      return text.trim();
    }
  ]
});
/**
 * @license
 * Copyright 2016 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

foam.CLASS({
  package: 'foam.u2.view',
  name: 'ReferenceView',
  extends: 'foam.u2.view.ChoiceView',

  imports: [
    'data as parentObj'
  ],

  properties: [
    {
      name: 'objToChoice',
      factory: function() {
        var f;
        return function(obj) {
          if ( f ) return f(obj);
        };
      }
    }
  ],

  methods: [
    function fromProperty(prop) {
      this.SUPER(prop);

      if ( ! this.hasOwnProperty('objToChoice') ) {
        var of = prop.of;

        var props = of.getAxiomsByClass(foam.core.String);
        var f;

        // Find the first non-hidden string property.
        for ( var i = 0 ; i < props.length ; i++ ) {
          var p = props[i];
          if ( ! p.hidden ) {
            this.objToChoice = function(obj) {
              return [obj.id, p.f(obj)];
            };
            break;
          }
        }

        if ( i === props.length ) {
          this.objToChoice = function(obj) {
            return [obj.id, obj.id];
          };
        }
      }

      var dao = this.parentObj.__context__[prop.targetDAOKey];
      this.dao = dao;
    }
  ]
});
/**
 * @license
 * Copyright 2016 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
 
foam.CLASS({
  package: 'foam.u2.tag',
  name: 'Card',
  extends: 'foam.u2.Element',

  documentation: 'This is a simple div in non-MD. Likely to be overridden ' +
      'later with Polymer\'s <paper-card> or similar.'
});
/**
 * @license
 * Copyright 2014 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

foam.CLASS({
  package: 'foam.u2.dialog',
  name: 'Popup',
  extends: 'foam.u2.Element',

  documentation: 'This is a container for a whole-screen, modal overlay. It ' +
      'fills the viewport with a transparent grey background, and then ' +
      'centers the "content" element. Clicking the background closes the ' +
      'dialog. Exports itself as "overlay", for use by OK and CANCEL buttons.',

  exports: [
    'close as closeDialog'
  ],

  axioms: [
    foam.u2.CSS.create({
      code: function() {/*
        ^ {
          align-items: center;
          bottom: 0;
          display: flex;
          justify-content: space-around;
          left: 0;
          position: fixed;
          right: 0;
          top: 0;
          z-index: 1000;
        }
        ^container {
          align-items: center;
          display: flex;
          height: 100%;
          justify-content: space-around;
          position: relative;
          width: 100%;
        }
        ^background {
          background-color: #000;
          bottom: 0;
          left: 0;
          opacity: 0.4;
          position: absolute;
          right: 0;
          top: 0;
        }
        ^inner {
          z-index: 3;
        }
      */}
    })
  ],

  properties: [
    [ 'backgroundColor', '#fff' ]
  ],

  methods: [
    function init() {
      this.SUPER();
      var content;

      this.addClass(this.myClass())
          .start()
          .addClass(this.myClass('container'))
          .start()
              .addClass(this.myClass('background'))
              .on('click', this.close)
          .end()
          .start()
              .call(function() { content = this; })
              .addClass(this.myClass('inner'))
              .style({ 'background-color': this.backgroundColor })
          .end()
      .end();

      this.content = content;
    },

    function open() {
      this.document.body.insertAdjacentHTML('beforeend', this.outerHTML);
      this.load();
    }
  ],

  listeners: [
    function close() {
      this.remove();
    }
  ]
});
/**
 * @license
 * Copyright 2018 The FOAM Authors. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

foam.CLASS({
  package: 'foam.u2.dialog',
  name: 'NotificationMessage',
  extends: 'foam.u2.View',

  documentation: 'error message handler for merchant app.',

  properties: [
    {
      class: 'String',
      name: 'type'
    },
    'message',
    'data'
  ],

  axioms: [
    foam.u2.CSS.create({
      code: function CSS() { /*
        ^ {
          width: 250px;
          padding: 20px 60px;
          background: #cff0e1;
          position: fixed;
          top: 100px;
          right: 100px;
          border: 1px solid #2cab70;
          animation-name: fade;
          animation-duration: 4s;
          font-size: 12px;
          line-height: 1.33;
          letter-spacing: 0.2px;
          text-align: center;
          z-index: 15000;
        }
        @keyframes fade {
          0% { opacity: 0; }
          10% { opacity: 1; }
          80% { opacity: 1; }
          100% { opacity: 0; }
        }
        ^error-background{
          background: #f4cccc;
          border: 1px solid #f33d3d;
        }
        ^ .close-x{
          right: 5px;
          top: 10px;
        }
        ^ .foam-u2-ActionView-close{
          width: 30px;
          height: 30px;
          position: absolute;
          left: 0px;
          top: -5px;
          z-index: 101;
          opacity: 0.01;
        }
        ^ .close-x {
          position: absolute;
          width: 32px;
          height: 32px;
          opacity: 0.3;
        }
        ^ .close-x:hover {
          opacity: 1;
        }
        ^ .close-x:before, .close-x:after {
          position: absolute;
          content: ' ';
          height: 20px;
          width: 2px;
          background-color: #333;
        }
        ^ .close-x:before {
          transform: rotate(45deg);
        }
        ^ .close-x:after {
          transform: rotate(-45deg);
        }
      */
      }
    })
  ],

  methods: [
    function initE(){
      var self = this;

      this
        .addClass(this.myClass()).enableClass(this.myClass('error-background'), this.type === 'error')
        .start()
          .add(this.message)
        .end()
        .startContext({ data: this })
          .start().addClass('close-x').add(this.CLOSE).end()
        .endContext()

        setTimeout(function(){ self.remove() }, 3900);
    }
  ],

  actions: [
    {
      name: 'close',
      label: '',
      code: function(X){
        X.data.remove();
      }
    }
  ]
});
/**
 * @license
 * Copyright 2016 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

foam.CLASS({
  package: 'foam.u2',
  name: 'Autocompleter',

  documentation: 'Basic autocomplete controller. Supports simple ' +
      'autocomplete, defaulting to querying by Keyword. Use this as a base ' +
      'class for other, more sophisticated autocompleters.',

  properties: [
    {
      name: 'dao',
      required: true,
      documentation: 'The DAO to complete against.'
    },
    {
      class: 'String',
      name: 'partial',
      documentation: 'The string the user has entered so far. Usually bound ' +
          'to some text field.'
    },
    {
      name: 'queryFactory',
      documentation: 'Turns the user\'s string into an mLang query. Defaults ' +
          'to Keyword.',
      value: function(str) {
        return foam.mlang.predicate.Keyword.create({ arg1: str });
      }
    },
    {
      class: 'Function',
      name: 'objToString',
      documentation: 'When the user has selected an object from the DAO as ' +
          'the chosen completion, we need to turn it back into a string for ' +
          'the text field.',
      required: true
    },
    'filteredDAO'
  ],

  methods: [
    function init() {
      this.SUPER();
      this.slot(function(dao, partial) {
        this.onUpdate();
      }.bind(this), this.dao$, this.partial$);
    }
  ],

  listeners: [
    {
      name: 'onUpdate',
      isFramed: true,
      code: function onUpdate() {
        if ( ! this.dao ) return;
        this.filteredDAO = this.partial ?
            this.dao.where(this.queryFactory(this.partial)) : this.dao;
      }
    }
  ]
});
/**
 * @license
 * Copyright 2016 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

foam.CLASS({
  package: 'foam.u2.search',
  name: 'FilterController',
  extends: 'foam.u2.View',

  requires: [
    'foam.mlang.sink.Count',
    'foam.u2.TableView',
    'foam.u2.ViewSpec',
    'foam.u2.tag.Card',
    'foam.u2.tag.Input',
    'foam.u2.view.ChoiceView',
    //'foam.u2.search.DateFieldSearchView',
    'foam.u2.search.BooleanRefinement',
    'foam.u2.search.EnumRefinement',
    'foam.u2.search.GroupAutocompleteSearchView',
    'foam.u2.search.GroupBySearchView',
    'foam.u2.search.PropertyRefinement',
    'foam.u2.search.SearchManager',
    'foam.u2.search.TextSearchView'
  ],

  exports: [
    'as filterController',
    'data as unfilteredDAO'
  ],

  axioms: [
    foam.u2.CSS.create({
      code: function CSS() {/*
        ^ {
          display: flex;
          overflow: hidden;
          flex-grow: 1;
          width: 100%;
        }
        ^search-panel {
          display: flex;
          flex-direction: column;
          flex-shrink: 0;
          overflow: hidden;
          min-width: 250px;
        }
        ^adding {
          border: none;
          flex-shrink: 0;
          flex-grow: 0;
          padding: 8px;
        }
        ^add-filter {
          align-items: center;
          display: flex;
          justify-content: space-between;
        }
        ^count {
          align-items: center;
          display: flex;
          justify-content: space-between;
        }
        ^results {
          display: flex;
          flex-grow: 1;
          overflow: hidden;
        }
        ^filter-area {
          flex-grow: 1;
          overflow-y: auto;
        }
        ^filter-header {
          align-items: center;
          display: flex;
        }
        ^filter-label {
          flex-grow: 1;
        }
        ^filter-container {
          margin: 6px 8px 0px;
        }
      */}
    })
  ],

  properties: [
    'count',
    'totalCount',
    {
      name: 'countString',
      expression: function(count, totalCount) {
        return (count || '0') + ' of ' + (totalCount || '0');
      }
    },
    {
      class: 'foam.dao.DAOProperty',
      name: 'data',
      required: true
    },
    'filteredDAO',
    {
      name: 'filterChoice',
      label: 'New Filter',
      factory: function() {
        return this.defaultFilter;
      }
    },
    {
      name: 'filters',
      adapt: function(old, nu) {
        // Convert from a list of strings to the full set of filters.
        if ( nu && nu.length && typeof nu[0] === 'string' ) {
          var out = [];
          for ( var i = 0; i < nu.length; i++ ) {
            var f = this.data.of.getAxiomByName(nu[i]);
            out.push([ f.name, f.label ]);
          }
          return out;
        }

        return nu;
      },
      factory: function() {
        var props = this.data.of.getAxiomsByClass(foam.core.Property)
            .filter(function(p) { return ! p.hidden; });
        return props.sort(function(a, b) {
          return a.LABEL.compare(a, b);
        }).map(function(p) {
          return [ p.name, p.label ];
        });
      }
    },
    {
      class: 'Boolean',
      name: 'allowDuplicateFilters',
      help: 'When this is true, you can create multiple filters for one ' +
          'property.',
      value: false
    },
    {
      class: 'Boolean',
      name: 'allowAddingFilters',
      help: 'When this is true, the controls for adding new filters is shown ' +
          'at the top. When it is false, just the CLEAR button and count are ' +
          'present.',
      value: true
    },
    {
      class: 'foam.u2.ViewSpec',
      name: 'filterAreaSpec',
      value: 'div'
    },
    {
      class: 'Boolean',
      name: 'textSearch',
      help: 'Set this to true to enable freeform text search.',
      value: false
    },
    {
      class: 'Function',
      name: 'buildFilter',
      value: function buildFilter(args) {
        var e = this.Card.create();
        e.style({
          'margin-bottom': '0',
          overflow: 'visible'
        }).addClass(this.myClass('filter-container'))
            .start('div')
                .addClass(this.myClass('filter-header'))
                .add(args.label)
            .end()
            .startContext({ data: args.key })
                .add(args.showRemove ? this.REMOVE_FILTER : undefined)
            .endContext()
        .end();

        e.start('div')
            .addClass(this.myClass('filter-body'))
            .add(args.view)
        .end();
        return e;
      }
    },
    {
      name: 'searchMgr_',
      factory: function() {
        return this.SearchManager.create({
          dao$: this.data$,
          filteredDAO$: this.filteredDAO$
        });
      }
    },
    {
      class: 'StringArray',
      name: 'searchFields',
      documentation: 'Property names that are currently selected as filters.',
      factory: function() {
        return ( this.data && this.data.of && this.data.of.tableColumns ) || [];
      }
    },
    {
      name: 'searchViews_',
      factory: function() { return {}; }
    },
    {
      name: 'search',
      factory: function() {
        var of = this.data.of;
        if ( of.id ) of = of.id;
        return this.TextSearchView.create({
          of: of,
          richSearch: true,
          keywordSearch: true
        });
      }
    },
    {
      name: 'filtersE_'
    },
    {
      class: 'foam.u2.ViewSpec',
      name: 'tableView',
      value: { class: 'foam.u2.TableView' }
    },
    {
      name: 'table'
    },
    {
      name: 'loaded_',
      value: false
    },
    [ 'oldSearchFields_', null ],
    [ 'addingSpec', undefined ]
  ],

  methods: [
    function initE() {
      // Assigning to unused variable to keep Closure happy.
      var _ = this.searchMgr_; // Force the factory to run.
      this.filteredDAO$.sub(this.onPredicateChange);
      this.onPredicateChange();

      this.addClass(this.myClass());
      this.startContext({ data: this });
      var searchPanel = this.start().addClass(this.myClass('search-panel'));
      var topPanel = searchPanel.start(this.addingSpec)
          .addClass(this.myClass('adding'));
      if ( this.allowAddingFilters ) {
        topPanel.start()
            .addClass(this.myClass('add-filter'))
            .start(this.ChoiceView, {
              data$: this.filterChoice$,
              choices: this.filters
            }).end()
            .add(this.NEW_FILTER)
        .end();
      }

      topPanel.start()
          .addClass(this.myClass('count'))
          .start('span')
              .addClass(this.myClass('count-text'))
              .add(this.countString$)
          .end()
          .start(this.CLEAR, { raised: true }).end()
      .end();
      this.filtersE_ = searchPanel.start(this.filterAreaSpec)
          .addClass(this.myClass('filter-area'));
      this.filtersE_.end();
      this.endContext();
      searchPanel.end();

      this.start().addClass(this.myClass('results'))
          .start(this.tableView, { of: this.data.of, data$: this.filteredDAO$ })
          .end()
      .end();

      var self = this;
      this.onload.sub(function() {
        if ( self.textSearch ) {
          self.filtersE_.add(self.buildFilter({
            label: 'Search',
            showRemove: false,
            view: self.search
          }));
          self.searchMgr_.add(self.search);
        }

        self.loaded_ = true;
      });

      this.data$.sub(this.updateSearchFields);
      this.loaded_$.sub(this.updateSearchFields);
      this.searchFields$.sub(this.updateSearchFields);

      this.data$proxy.on.reset.sub(this.updateCount);
      if ( this.data ) this.updateCount();
    },

    function addGroup(spec, prop, opt_map) {
      var map = opt_map || {};
      map.property = prop;
      map.size = map.size || 1;
      map.dao = this.data;

      var e = this.ViewSpec.createView(spec, map, this, this.searchMgr_);
      var view = this.searchMgr_.add(e);
      var filterView = this.buildFilter({
        key: view.name,
        label: prop.label,
        prop: prop,
        showRemove: this.allowAddingFilters,
        view: view
      });

      this.searchViews_[view.name] = filterView;
      return filterView;
    },

    function renderFilter(key) {
      this.filtersE_.add(this.searchViews_[key]);
    },

    function addFilter_(name) {
      // Look for existing filters for this property, and count the total
      // filters to ensure we can build a unique key.
      // This is how the multiple-fields-for-one-property support is achieved.
      var highestCount = 0;
      var alreadyExists = false;
      for ( var i = 0; i < this.searchFields.length; i++ ) {
        var split = this.splitName(this.searchFields[i]);
        if ( split.count > highestCount ) highestCount = split.count;
        if ( split.name === name ) alreadyExists = true;
      }

      if ( alreadyExists && ! this.allowDuplicateFilters ) return undefined;

      var key = name + (highestCount === 0 ? '' : '_' + (+highestCount + 1));
      var temp = foam.Array.clone(this.searchFields);
      temp.push(key);
      this.searchFields = temp;
      return key;
    },

    function addFilter(name) {
      var key = this.addFilter_(name);
    },

    function removeFilter(key) {
      var temp = foam.Array.clone(this.searchFields);
      for ( var i = 0; i < temp.length; i++ ) {
        if ( temp[i] === key ) {
          temp.splice(i, 1);
          break;
        }
      }
      this.searchFields = temp;
    },

    function splitName(key) {
      var match = key.match(/^(.*)_(\d+)$/);
      return match ?
          { name: match[1], count: match[2] } :
          { name: key, count: 1 };
    }
  ],

  listeners: [
    {
      name: 'onPredicateChange',
      isFramed: true,
      code: function() {
        this.filteredDAO.select(this.Count.create())
            .then(function(c) { this.count = c.value; }.bind(this));
      }
    },
    {
      name: 'updateCount',
      isFramed: true,
      code: function() {
        this.data.select(this.Count.create()).then(function(c) {
          this.totalCount = c.value;
        }.bind(this));
        this.onPredicateChange();
      }
    },
    {
      name: 'updateSearchFields',
      isFramed: true,
      code: function() {
        if ( ! this.loaded_ || ! this.data ) return;
        var fields = this.searchFields;
        var oldFields = this.oldSearchFields_;

        // Check for every filter that has been removed, and every filter that
        // is freshly added.
        // This function is responsible for choosing the view for each property.
        // Eg. drop-downs for Booleans and Enums, before/after for dates, etc.
        if ( oldFields ) {
          for ( var i = 0; i < oldFields.length; i++ ) {
            if ( ! fields || fields.indexOf(oldFields[i]) < 0 ) {
              this.searchMgr_.remove(oldFields[i]);
              this.searchViews_[oldFields[i]].remove();
              delete this.searchViews_[oldFields[i]];
            }
          }
        }

        if ( fields ) {
          for ( var i = 0; i < fields.length; i++ ) {
            if ( ! oldFields || oldFields.indexOf(fields[i]) < 0 ) {
              var split = this.splitName(fields[i]);
              var prop = this.data.of.getAxiomByName(split.name);
              var spec = prop.searchView;
              // TODO(braden): Bring in date support when it's ready.
              var options = {
                name: fields[i]
              };
              if ( prop.tableSeparator ) {
                options.split = prop.tableSeparator;
              }
              this.addGroup(spec, prop, options);
              this.renderFilter(fields[i]);
            }
          }
        }

        this.oldSearchFields_ = fields;
      }
    }
  ],

  actions: [
    {
      name: 'clear',
      code: function() { this.searchMgr_.clear(); }
    },
    {
      name: 'newFilter',
      code: function() {
        this.addFilter_(this.filterChoice);
      }
    }
  ]
});


foam.CLASS({
  package: 'foam.u2.search',
  name: 'PropertyRefinement',
  refines: 'foam.core.Property',

  properties: [
    {
      // Set this field to override the default logic for choosing a view.
      class: 'foam.u2.ViewSpec',
      name: 'searchView',
      value: { class: 'foam.u2.search.GroupAutocompleteSearchView' }
    }
  ]
});


foam.CLASS({
  package: 'foam.u2.search',
  name: 'BooleanRefinement',
  refines: 'foam.core.Boolean',

  properties: [
    {
      class: 'foam.u2.ViewSpec',
      name: 'searchView',
      value: {
        class: 'foam.u2.search.GroupBySearchView',
        viewSpec: { class: 'foam.u2.view.ChoiceView', size: 3 }
      }
    }
  ]
});


foam.CLASS({
  package: 'foam.u2.search',
  name: 'EnumRefinement',
  refines: 'foam.core.Enum',

  properties: [
    {
      class: 'foam.u2.ViewSpec',
      name: 'searchView',
      value: { class: 'foam.u2.search.GroupBySearchView' }
    }
  ]
});
/**
 * @license
 * Copyright 2016 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

foam.CLASS({
  package: 'foam.u2.search',
  name: 'GroupCompleter',
  extends: 'foam.u2.Autocompleter',

  requires: [
    'foam.dao.MDAO',
    'foam.dao.ProxyDAO',
    'foam.mlang.LabeledValue',
    'foam.mlang.predicate.ContainsIC'
  ],

  documentation: 'Expects "groups" to be an array of strings, and ' +
      'autocompletes on them.',

  properties: [
    'groups',
    {
      name: 'dao',
      factory: function() {
        return this.ProxyDAO.create({
          of: this.LabeledValue,
          delegate$: this.innerDAO_$
        });
      }
    },
    {
      name: 'innerDAO_',
      expression: function(groups) {
        var dao = this.MDAO.create({ of: this.LabeledValue });
        if ( ! groups || ! groups.length ) return dao;

        for ( var i = 0; i < groups.length; i++ ) {
          var str = '' + groups[i];
          if ( ! str ) continue;
          dao.put(this.LabeledValue.create({
            id: str,
            label: str,
            value: groups[i]
          }));
        }
        return dao;
      }
    },
    {
      name: 'queryFactory',
      value: function(str) {
        return this.ContainsIC.create({
          arg1: this.LabeledValue.LABEL,
          arg2: str
        });
      }
    },
    {
      name: 'objToString',
      value: function(lv) {
        return lv.value;
      }
    }
  ]
});
/**
 * @license
 * Copyright 2016 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

foam.CLASS({
  package: 'foam.u2.search',
  name: 'GroupAutocompleteSearchView',
  extends: 'foam.u2.View',

  documentation: 'Uses a TextField with autocomplete driven by a list. This ' +
      'depends on the browser\'s native support for the input.list ' +
      'attribute, which is also polyfilled by Polymer.',

  requires: [
    'foam.mlang.predicate.True',
    'foam.u2.search.GroupCompleter',
    // TODO(braden): Implement and uncomment the split-completer.
    //'foam.u2.search.GroupSplitCompleter',
    'foam.u2.view.TextField'
  ],

  properties: [
    {
      class: 'String',
      name: 'split',
      documentation: 'Set this to a string, and group values will be split ' +
          'on it. This can be used to split a comma-separated string into ' +
          'its component parts.',
      value: ''
    },
    {
      class: 'foam.u2.ViewSpec',
      name: 'viewSpec',
      value: { class: 'foam.u2.view.TextField', onKey: true }
    },
    {
      name: 'dao',
      label: 'DAO',
      required: true,
      postSet: function() {
        this.updateDAO();
      }
    },
    {
      name: 'property',
      required: true,
      postSet: function(o, property) {
        if ( ! this.op ) this.op = foam.core.Int.isInstance(property) ? foam.mlang.predicate.Eq : foam.mlang.predicate.ContainsIC;
      }
    },
    {
      name: 'name',
      documentation: 'All SearchViews require a name. Defaults to the ' +
          'property name.',
      expression: function(property) {
        return property.name;
      }
    },
    {
      class: 'Class',
      name: 'op'/*,
      expression: function(property) {
        // TODO: broken by CLASS, fix
        // All the numeric types extend from Int, so I'll use that as my base.
        return foam.core.Int.isInstance(property) ? foam.mlang.predicate.Eq :
            foam.mlang.predicate.ContainsIC;
      }*/
    },
    {
      name: 'predicate',
      documentation: 'My filter for the SearchManager to read.',
      factory: function() {
        return this.True.create();
      }
    },
    {
      name: 'label',
      expression: function(property) {
        return property.label;
      }
    },
    {
      name: 'groups',
      documentation: 'List of groups found the last time the DAO was updated.'
    },
    {
      name: 'autocompleter',
      factory: function() {
        var model = this.GroupCompleter;
        var args = { groups$: this.groups$ };
        if ( this.split ) {
          model = this.GroupSplitCompleter;
          args.split = this.split;
        }

        return model.create(args, this);
      }
    },
    {
      name: 'view'
    }
  ],

  methods: [
    function clear() {
      this.view.data = '';
    },

    function initE() {
      this.view = this.start(this.viewSpec, {
        prop: this.property,
        label$: this.label$,
        alwaysFloatLabel: true,
        autocompleter: this.autocompleter
      });

      this.dao.on.sub(this.updateDAO);
      this.view.data$.sub(this.updatePredicate);
    }
  ],

  listeners: [
    {
      name: 'updateDAO',
      isMerged: true,
      mergeDelay: 100,
      code: function() {
        // Makes a select query, grouping by the value of this.property.
        // That builds the this.groups list, which is what we're autocompleting
        // against.
        this.dao.select(foam.mlang.sink.GroupBy.create({
          arg1: this.property,
          arg2: foam.mlang.sink.Count.create()
        })).then(function(groups) {
          this.groups = groups.sortedKeys();
        }.bind(this));
      }
    },
    {
      name: 'updatePredicate',
      code: function(sub, _, __, slot) {
        var str = slot.get();
        this.predicate = str ? this.op.create({
          arg1: this.property,
          arg2: this.property.fromString ? this.property.fromString(str) : str
        }) : this.True.create();
      }
    }
  ]
});
/**
 * @license
 * Copyright 2016 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

foam.CLASS({
  package: 'foam.u2.search',
  name: 'GroupBySearchView',
  extends: 'foam.u2.View',

  requires: [
    'foam.mlang.Constant',
    'foam.mlang.predicate.True',
    'foam.mlang.sink.Count',
    'foam.mlang.sink.GroupBy',
    'foam.dao.FnSink',
    'foam.u2.view.ChoiceView'
  ],

  css: "^ select { min-width: 220px; }",

  properties: [
    {
      name: 'view'
    },
    {
      class: 'foam.u2.ViewSpec',
      name: 'viewSpec',
      value: { class: 'foam.u2.view.ChoiceView', size: 10 }
    },
    {
      class: 'foam.dao.DAOProperty',
      name: 'dao',
      required: true,
    },
    {
      name: 'property',
      required: true
    },
    {
      name: 'name',
      expression: function(property) { return property.name; }
    },
    {
      class: 'Class',
      name: 'op',
      value: 'foam.mlang.predicate.Eq'
    },
    {
      name: 'predicate',
      factory: function() {
        return this.True.create();
      }
    },
    {
      class: 'Int',
      name: 'width',
      value: 17
    },
    {
      class: 'String',
      name: 'label',
      expression: function(property) {
        return property.label;
      }
    },
    {
      class: 'Function',
      name: 'aFormatLabel',
      value: function(key) { return Promise.resolve(''+key); }
    },
    'previewMode',
    'hardData'
  ],

  methods: [
    function clear() {
      this.view.data = '';
    },

    function initE() {
      var self = this;

      this
        .addClass(this.myClass())
        .tag(this.viewSpec, {
          label$: this.label$,
          alwaysFloatLabel: true
        }, this.view$)
        .on('click', function(e) {
          try {
            self.previewMode = false;
            var data         = self.view.choices[e.target.value][0];
            self.hardData    = data;
          } catch(x) {}
        })
        .on('mouseover', function(e) {
          try {
            var data = self.view.choices[e.target.value][0];

            if ( ! self.previewMode ) {
              self.previewMode = true;
              self.hardData = self.view.data;
            }

            self.view.data = data;
          } catch(x) {}
        })
        .on('mouseout', function(e) {
          self.view.data = self.hardData;
          if ( ! self.hardData ) self.view.data = '';
        })
        .onDetach(
          this.dao$proxy.listen(
            this.FnSink.create({fn: this.updateDAO})
          )
        );

      this.updateDAO();

      this.view.data$.sub(this.updatePredicate);
    },

    function updatePredicate_(choice) {
      var exists = typeof choice !== 'undefined' && choice !== '';
      this.predicate = exists ? this.op.create({
        arg1: this.property,
        arg2: this.Constant.create({ value: choice })
      }) : this.True.create();
    },

    function formatLabels(keys) {
      return Promise.all(keys.map(this.aFormatLabel.bind(this)));
    }
  ],

  listeners: [
    {
      name: 'updateDAO',
      isMerged: true,
      mergeDelay: 100,
      code: function() {
        var self = this;
        this.dao.select(this.GroupBy.create({
          arg1: this.property,
          arg2: this.Count.create()
        })).then(function(groups) {
          var options = [];
          var selected;
          var sortedKeys = groups.sortedKeys();
          self.formatLabels(sortedKeys).then(function (labels) {
            for ( var i = 0 ; i < sortedKeys.length ; i++ ) {
              var key = sortedKeys[i];
              if ( typeof key === 'undefined' ) continue;
              if ( key === '' ) continue;
              var count = foam.String.intern(
                  '(' + groups.groups[key].value + ')');
              var subKey = labels[i].substring(0, self.width - count.length - 3);
              // ???: Why do we need to clean the key?
              var cleanKey = foam.core.Enum.isInstance(self.property) ?
                  self.property.of[key].label :
                  subKey.replace(/</g, '&lt;').replace(/>/g, '&gt;')
                      .replace(/"/g, '&quot;');

              if ( self.view && self.view.data === key ) {
                selected = key;
              }

              options.push([
                key,
                cleanKey + foam.String.intern(
                    Array(self.width - subKey.length - count.length).join(' ')) +
                    count
              ]);
            }

            options.splice(0, 0, [ '', '--' ]);

            self.view.choices = options;
            if ( typeof selected !== 'undefined' ) {
              var oldData = self.view.data;
              self.view.data = selected;
              if ( typeof oldData === 'undefined' || oldData === '' ) {
                self.updatePredicate_(selected);
              }
            }
          });
        });
      }
    },
    {
      name: 'updatePredicate',
      code: function(_, __, ___, slot) {
        this.updatePredicate_(slot.get());
      }
    }
  ]
});
/**
 * @license
 * Copyright 2016 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

foam.CLASS({
  package: 'foam.u2.search',
  name: 'SearchManager',

  requires: [
    'foam.mlang.predicate.And',
    'foam.mlang.predicate.True'
  ],

  properties: [
    {
      name: 'views',
      factory: function() { return {}; }
    },
    {
      name: 'subs_',
      factory: function() { return {}; }
    },
    // TODO(braden): See if there's a clever way to write the memento logic as
    // an expression, instead of a set of clever postSets.
    {
      name: 'predicate',
      factory: function() {
        return foam.mlang.predicate.True.create();
      }
    },
    {
      name: 'dao'
    },
    {
      name: 'filteredDAO',
      expression: function(dao, predicate) {
        if ( ! dao ) return;
        var d = dao.where(predicate);
        this.updateViews();
        return d;
      }
    }
  ],

  methods: [
    function and(views) {
      return this.And.create({
        args: Object.keys(views).map(function(k) { return views[k].predicate; })
      }).partialEval();
    },

    function add(view) {
      // Check the view's name, and if it's a duplicate, change its name to add
      // a number.
      if ( this.views[view.name] ) {
        var num = 2;
        while ( this.views[view.name + '_' + num] ) {
          num++;
        }
        view.name = view.name + '_' + num;
      }

      this.views[view.name] = view;
      this.subs_[view.name] = view.predicate$.sub(this.onViewUpdate);
      this.updateViews();
      return view;
    },

    function remove(viewOrName) {
      var view;
      var name;
      if ( typeof viewOrName === 'string' ) {
        name = viewOrName;
        view = this.views[viewOrName];
      } else {
        view = viewOrName;
        name = view.name;
      }

      if ( ! this.views[name] ) return;

      view.clear();
      this.subs_[name].detach();
      delete this.views[name];
      delete this.subs_[name];
    },

    function removeAll() {
      this.clear();
      foam.Object.forEach(this.subs_, function(sub) {
        sub.detach();
      });
      this.views = {};
      this.subs_ = {};
    },

    function clear() {
      foam.Object.forEach(this.views, function(view) { view.clear(); });
    }
  ],

  listeners: [
    {
      name: 'onViewUpdate',
      isMerged: true,
      mergeDelay: 10,
      code: function() {
        this.predicate = this.and(this.views);
        // That will tickle the expression for filteredDAO.
        this.updateViews();
      }
    },
    {
      name: 'updateViews',
      isMerged: true,
      mergeDelay: 20,
      code: function() {
        // Deliberately a longer delay than onViewUpdate, since updating the
        // views is less important.
        foam.Object.forEach(this.views, function(view, name) {
          var temp = {};
          foam.Object.forEach(this.views, function(v, n) {
            if ( name === n ) return;
            temp[n] = v;
          });
          // Temp now holds all the other views. Combine all their predicates to
          // get the reciprocal predicate for this view.
          this.views[name].dao = this.dao.where(this.and(temp));
        }.bind(this));
      }
    }
  ]
});
/**
 * @license
 * Copyright 2016 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

foam.CLASS({
  package: 'foam.u2.search',
  name: 'TextSearchView',
  extends: 'foam.u2.View',

  requires: [
    'foam.mlang.predicate.ContainsIC',
    'foam.mlang.predicate.True',
    'foam.parse.QueryParser',
    'foam.u2.tag.Input'
  ],

  properties: [
    {
      class: 'Class',
      name: 'of'
    },
    {
      class: 'Boolean',
      name: 'richSearch',
      value: false
    },
    {
      class: 'Boolean',
      name: 'keywordSearch',
      value: false
    },
    {
      name: 'queryParser',
      factory: function() {
        return this.QueryParser.create({ of: this.of });
      }
    },
    {
      class: 'Int',
      name: 'width',
      value: 47
    },
    'property',
    {
      name: 'predicate',
      factory: function() { return this.True.create(); }
    },
    {
      class: 'foam.u2.ViewSpec',
      name: 'viewSpec',
      value: { class: 'foam.u2.tag.Input' }
    },
    {
      name: 'view'
    },
    {
      name: 'label',
      expression: function(property) {
        return property && property.label ? property.label : 'Search';
      }
    },
    {
      // All search views (in the SearchManager) need a name.
      // This defaults to 'query'.
      name: 'name',
      value: 'query'
    }
  ],

  methods: [
    function initE() {
      this
        .addClass(this.myClass())
        .tag(this.viewSpec, { alwaysFloatLabel: true, label$: this.label$ }, this.view$);

      this.view.data$.sub(this.updateValue);
    },

    function clear() {
      this.view.data = '';
      this.predicate = this.True.create();
    }
  ],

  listeners: [
    {
      name: 'updateValue',
      code: function() {
        var value = this.view.data;
        this.predicate = ! value ?
            this.True.create() :
            this.richSearch ?
                this.queryParser.parseString(value) :
                this.ContainsIC(this.property, value);
      }
    }
  ]
});
/**
 * @license
 * Copyright 2016 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

foam.CLASS({
  package: 'foam.u2.stack',
  name: 'Stack',

  properties: [
    {
      name: 'stack_',
      hidden: true,
      factory: function() { return []; }
    },
    {
      class: 'Int',
      name: 'depth',
      value: 0
    },
    {
      class: 'Int',
      name: 'pos',
      value: -1,
      preSet: function(_, p) {
        if ( isNaN(p) || p > this.depth ) return this.depth - 1;
        if ( p < 0 ) return 0;
        return p;
      }
    },
    {
      class: 'foam.u2.ViewSpec',
      name: 'top',
      hidden: true,
      expression: function(pos) {
        return this.stack_[pos] || null;
      }
    }
  ],

  methods: [
    function slotAt(i) {
      return this.StackSlot.create({
        pos: i,
        stack: this
      });
    },

    function at(i) {
      return i < 0 ? this.stack_[this.pos + i + 1] : this.stack_[i];
    },

    function push(v, parent) {
      if ( foam.u2.Element.isInstance(v) ) {
        console.warn("Views are not recommended to be pushed to a stack. Please use a viewSpec.");
      }
      // "parent" is the parent object for this view spec.  A view of this stack
      // should ensure that the context that "v" is rendered in extends from
      // both the u2.Element is it being rendered under, and from the "parent"
      // parameter.  This way views on the stack can export values to views
      // that get rendered after them.
      var pos = this.pos + 1;

      this.depth = pos + 1;
      this.stack_.length = this.depth;
      this.stack_[pos] = [v, parent];
      this.pos = pos;
    }
  ],

  actions: [
    {
      name: 'back',
      icon: 'arrow_back',
      isEnabled: function(pos) { return pos > 0; },
      code: function() { this.pos--; }
    },
    {
      name: 'forward',
      icon: 'arrow_forward',
      isEnabled: function(pos, depth) { return pos < depth - 1; },
      code: function() { this.pos++; }
    }
  ],

  classes: [
    {
      name: 'StackSlot',

      implements: [ 'foam.core.Slot' ],

      properties: [
        {
          name: 'stack'
        },
        {
          class: 'Int',
          name: 'pos'
        }
      ],

      methods: [
        function init() {
          this.onDetach(this.stack.pos$.sub(this.onStackChange));
        },

        function get() {
          return this.stack.at(this.pos);
        },

        function set() {
          // unimplemnted.
        },

        function sub(l) {
          return this.SUPER('update', l);
        },

        function toString() {
          return 'StackSlot(' + this.pos + ')';
        }
      ],

      listeners: [
        function onStackChange(s) {
          if ( this.pos < 0 || this.pos === this.stack.pos ) {
            this.pub('update');
          }
        }
      ]
    }
  ]
});
/**
 * @license
 * Copyright 2016 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

foam.CLASS({
  package: 'foam.u2.stack',
  name: 'StackView',
  extends: 'foam.u2.View',

  requires: [
    'foam.u2.stack.Stack'
  ],

  exports: [ 'data as stack' ],

  properties: [
    {
      name: 'data',
      factory: function() { return this.Stack.create(); }
    },
    {
      class: 'Boolean',
      name: 'showActions',
      value: true
    }
  ],

  methods: [
    function initE() {
      this.setNodeName('div');
      this.addClass(this.myClass());

      if ( this.showActions ) {
        this.start('actions')
            .add(this.data.cls_.getAxiomsByClass(foam.core.Action))
            .end();
      }

      this.add(this.slot(function(s) {
        if ( ! s ) return this.E('span');

        var view = s[0];
        var parent = s[1];


        // Do a bit of a dance with the context, to ensure that exports from "parent"
        // are available to "view"
        var X = parent ? this.__subSubContext__.createSubContext(parent) : this.__subSubContext__;

        return foam.u2.ViewSpec.createView(view, null, this, X);

      }, this.data$.dot('top')));
    }
  ]
});
foam.CLASS({
  package: 'foam.apploader',
  name: 'ModelRefines',
  refines: 'foam.core.Model',
  methods: [
    {
      name: 'getClassDeps',
      code: function() {
        var deps = this.requires ?
            this.requires.map(function(r) { return r.path }) :
            [];

        deps = deps.concat(this.implements ?
                           this.implements.map(function(i) { return i.path }) :
                           []);

        if ( this.extends ) deps.push(this.extends);
        return deps;
      }
    },
  ],
});
/**
 * @license
 * Copyright 2018 The FOAM Authors. All Rights Reserved.
 * http://www.apache.org/licenses/LICENSE-2.0
 */

/*
TODO:

 - Remove foam.classloader classes
 - Remove arequire, or change it to use classloader.load
 - Make GENMODEL work when running without a classloader
 - Fix WebSocketBox port autodetection to work when running with tomcat and also without


*/

foam.CLASS({
  package: 'foam.apploader',
  name: 'ClassLoader',
  /* todo: [
    `Don't register classes globally, register in a subcontext so we can
have multiple classloaders running alongside eachother`
],*/
  requires: [
    'foam.classloader.OrDAO'
  ],
  properties: [
    {
      class: 'Map',
      name: 'pending'
    },
    {
      class: 'Map',
      name: 'latched'
    },
    {
      class: 'foam.dao.DAOProperty',
      name: 'modelDAO'
    }
  ],
  methods: [
    {
      name: 'addClassPath',
      code: function(path, json2) {
        var cls = foam.lookup(foam.isServer ?
            'foam.apploader.NodeModelFileDAO' :
            'foam.apploader.WebModelFileDAO');
        var modelDAO = cls.create({root: path, json2: json2}, this);

        if ( this.modelDAO ) {
          modelDAO = this.OrDAO.create({
            primary: this.modelDAO,
            delegate: modelDAO
          });
        }
        this.modelDAO = modelDAO;
      }
    },
    {
      name: 'load',
      returns: 'Promise',
      args: [ { class: 'String', name: 'id' } ],
      code: function(id) {
        return this.load_(id, []);
      }
    },
    {
      name: 'maybeLoad',
      returns: 'Promise',
      documentation: "Like load, but don't throw if not found.",
      args: [ { name: 'id', of: 'String' } ],
      code: function(id) {
        return this.load(id).catch(function() { return null; });
      }
    },
    {
      name: 'maybeLoad_',
      returns: 'Promise',
      args: [ { name: 'id', of: 'String' },
              { name: 'path', of: 'Array' } ],
      code: function(id, path) {
        return this.load_(id, path).catch(function() { return null; });
      }
    },
    {
      name: 'latch',
      returns: 'Promise',
      args: [ { name: 'json' } ],
      code: function(json) {
        var id = json.package ?
            json.package + '.' + json.name :
            json.name;

        this.latched[id] = json;
      }
    },
    {
      name: 'load_',
      returns: 'Promise',
      args: [ { class: 'String', name: 'id' },
              { class: 'StringArray', name: 'path' } ],
      code: function(id, path) {
        var self = this;

        if ( foam.String.isInstance(id) ) {
          // Prevent infinite loops, if we're loading this class as a
          // dependency to something that this class depends upon then
          // we can just resolve right away.
          for ( var i = 0 ; i < path.length ; i++ ) {
            if ( path[i].id === id ) return Promise.resolve();
          }

          if ( this.pending[id] ) return this.pending[id];

          // Latched models come from when someone defines a class
          // with foam.CLASS during regular execution (like a script
          // tag).  We hook into those so that they can still use the
          // classloader to ensure any dependencies of that model are
          // loaded before they use it.
          if ( this.latched[id] ) {
            var json = this.latched[id];
            delete this.latched[id];
            return this.pending[id] = Promise.all(foam.json.references(this.__context__, json)).then(function() {
              var cls = json.class ? foam.lookup(json.class) : foam.core.Model;
              return self.modelDeps_(cls.create(json), path);
            }).then(function() {
              // Latched models will already be registered in the
              // context via foam.CLASS as defined in EndBoot.js
              return foam.lookup(id);
            });
          }

          if ( foam.lookup(id, true) ) return Promise.resolve(foam.lookup(id));

          return this.pending[id] = this.modelDAO.find(id).then(function(m) {
            if ( ! m ) return Promise.reject(new Error('Class Not Found: ' + id));

            return this.buildClass_(m, path);
          }.bind(this), function() {
            throw new Error("Failed to load class " + id);
          });
        }

        if ( foam.core.Model.isInstance(id) ) {
          return this.pending[id] = this.buildClass_(id, path);
        }

        throw new Error("Invalid parameter to ClassLoader.load_");
      }
    },
    {
      name: 'modelDeps_',
      args: [ { name: 'model', of: 'foam.core.Model' },
              { name: 'path' } ],
      code: function(model, path) {
        var self = this;
        return Promise.all(model.getClassDeps().map(function(d) {
          return self.maybeLoad_(d, path);
        }));
      }
    },
    {
      name: 'buildClass_',
      args: [ { name: 'model', of: 'foam.core.Model' },
              { name: 'path', of: 'Array' } ],
      code: function(model, path) {
        var self = this;

        path = path.concat(model);

        var deps = this.modelDeps_(model, path);

        return deps.then(function() {
          model.validate();
          cls = model.buildClass();
          cls.validate();

          if ( ! model.refines ) {
            // Register class in global context.
            foam.register(cls);

            // Register the class in the global package path.
            foam.package.registerClass(cls);
          } else if ( model.name ) {
            // Register refinement id in global context.
            foam.register(cls, ( model.package || 'foam.core' ) + '.' + model.name);
          }
          // TODO(markdittmer): Identify and name anonymous refinements with:
          // else {
          //   console.warn('Refinement without unique id', cls);
          //   debugger;
          // }

          return cls;
        });
      }
    }
  ]
});
foam.CLASS({
  package: 'foam.apploader',
  name: 'JSON2ModelFileDAO',
  documentation: 'Model DAO that reads json2 models.',
  extends: 'foam.dao.AbstractDAO',
  requires: [
    'foam.json2.Deserializer',
  ],
  properties: [
    {
      name: 'd',
      factory: function() {
        return this.Deserializer.create({parseFunctions: true});
      },
    },
    'fetcher',
  ],
  methods: [
    {
      name: 'find_',
      code: function(x, id) {
        var self = this;
        var promise = self.fetcher.getFile(id);
        return promise.then(function(text) {
          return self.d.aparseString(x, text);
        }, function() { return null });
      }
    }
  ]
});
foam.CLASS({
  package: 'foam.apploader',
  name: 'WebModelFileFetcher',
  requires: [
    'foam.net.HTTPRequest'
  ],
  properties: [
    'root',
  ],
  methods: [
    function getFile(id) {
      return this.HTTPRequest.create({
        method: 'GET',
        url: this.root + '/' + id.replace(/\./g, '/') + '.js'
      }).send().then(function(payload) {
        return payload.resp.text();
      })
    },
  ]
});
foam.CLASS({
  package: 'foam.apploader',
  name: 'ModelFileDAO',
  documentation: 'ModelDAO which reads hand written models.',
  extends: 'foam.dao.AbstractDAO',
  properties: [
    {
      class: 'Map',
      name: 'cache'
    },
    'fetcher',
  ],
  methods: [
    {
      name: 'find_',
      code: function(x, id) {
        var promise;
        if ( this.cache[id] ) {
          promise = Promise.resolve(this.cache[id]);
        } else {
          promise = this.fetcher.getFile(id);
        }

        var self = this;

        return promise.then(function(text) {
          if ( ! text ) return null;
          var json;
          var genmodel = false;
          var relationship = false;

          var context = {
            foam: Object.create(foam)
          };

          context.foam.GENMODEL = function(m) {
            json = m;
            genmodel = true;
          };

          context.foam.CLASS = function(m) {
            var jsonId = m.package ?
                m.package + '.' + m.name :
                m.name;

            if ( jsonId !== id ) {
              self.cache[jsonId] = m;
              return;
            }

            json = m;
          };

          context.foam.INTERFACE = function(json) {
            json.class = json.class || 'foam.core.InterfaceModel',
            context.foam.CLASS(json);
          };

          context.foam.ENUM = function(json) {
            json.class = json.class || 'foam.core.EnumModel';
            context.foam.CLASS(json);
          };

          context.foam.RELATIONSHIP = function(r) {
            var references = foam.json.references(x, r);

            Promise.all(references.concat([
              foam.package.waitForClass(r.sourceModel),
              foam.package.waitForClass(r.targetModel)
            ])).then(function() {
              var obj = foam.dao.Relationship.create(r, x);

              obj.validate && obj.validate();
              foam.package.registerClass(obj);
            });
          };

          with ( context ) { eval(text); }

          if ( ! json ) {
            throw new Error('No model found for ' + id);
          }

          var references = foam.json.references(x, json);

          if ( genmodel ) {
            references = references.concat(json.requires.map(x.classloader.load.bind(x.classloader)));
          }

          return Promise.all(references).then(function() {
            if ( genmodel ) {
              return json.build(x);
            }

            return foam.lookup(json.class || 'Model').create(json, x);
          });
        }, function() {
          return null;
        });
      }
    }
  ]
});

/**
 * @license
 * Copyright 2018 The FOAM Authors. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

foam.CLASS({
  package: 'foam.apploader',
  name: 'WebModelFileDAO',
  extends: 'foam.dao.ProxyDAO',
  requires: [
    'foam.apploader.JSON2ModelFileDAO',
    'foam.apploader.ModelFileDAO',
    'foam.apploader.WebModelFileFetcher',
    'foam.net.HTTPRequest',
  ],
  imports: [
    'window',
  ],
  properties: [
    'root',
    'json2',
    {
      name: 'delegate',
      factory: function() {
        var cls = this.json2 ? this.JSON2ModelFileDAO : this.ModelFileDAO;
        return cls.create({
          fetcher: this.WebModelFileFetcher.create({root: this.root}), });
      },
    },
  ],
});
/**
 * @license
 * Copyright 2018 The FOAM Authors. All Rights Reserved.
 * http://www.apache.org/licenses/LICENSE-2.0
 */

foam.CLASS({
  package: "foam.apploader",
  name: "ClassLoaderContext",
  requires: [
    "foam.apploader.ClassLoader",
    "foam.apploader.WebModelFileDAO"
  ],
  exports: [
    'classloader'
  ],
  properties: [
    {
      name: "classloader",
      factory: function() { return this.ClassLoader.create() },
    }
  ]
});
(function() {
  var classLoaderContext = foam.apploader.ClassLoaderContext.create(
      null, foam.__context__);
  classLoaderContext.classloader.addClassPath(global.FOAM_ROOT);
  foam.__context__ = classLoaderContext.__subContext__;

  var CLASS = foam.CLASS;
  foam.CLASS = function(m) {
    foam.__context__.classloader.latch(m);
    CLASS(m);
  };
})();
/**
 * @license
 * Copyright 2016 Google Inc. All Rights Reserved.
 * Copyright 2018 The FOAM Authors.  All Rights Reserved.
 * http://www.apache.org/licenses/LICENSE-2.0
 */

foam.CLASS({
  package: 'foam.u2',
  name: 'FoamTagLoader',

  documentation: 'Converts <foam> tags in document into Views.',

  imports: [ 'document', 'window', 'classloader' ],

  methods: [
    function init() {
      this.window.addEventListener('load', this.onLoad, false);
    },

    function findPropertyIC(cls, name) {
      var ps = cls.getAxiomsByClass(foam.core.Property);
      for ( var i = 0 ; i < ps.length ; i++ ) {
        if ( name === ps[i].name.toLowerCase() ) return ps[i];
      }
    },

    function loadTag(el) {
      var clsName = el.getAttribute('class');

      this.classloader.load(clsName).then(function(cls) {
        var id  = el.id;

        var view = cls.create(null, foam.__context__);

        if ( view.toE ) {
          view = view.toE({}, foam.__context__);
        } else if ( ! foam.u2.Element.isInstance(view) )  {
          view = foam.u2.DetailView.create({data: view, showActions: true});
        }

        for ( var j = 0 ; j < el.attributes.length ; j++ ) {
          var attr = el.attributes[j];
          var p    = this.findPropertyIC(view.cls_, attr.name);
          if ( p ) p.set(view, attr.value);
        }

        el.outerHTML = view.outerHTML;
        view.load();

        // Store view in global variable if named. Useful for testing.
        if ( id ) global[id] = view;

      }.bind(this), function(e) {
        console.error(e);
        console.error('Failed to load class: ', clsName);
      });
    }
  ],

  listeners: [
    function onLoad() {
      var els = Array.from(this.document.getElementsByTagName('foam'));
      this.window.removeEventListener('load', this.onLoad);

      // Install last to first to avoid messing up the 'els' list.
      els.forEach(this.loadTag.bind(this));
    }
  ]
});

foam.u2.FoamTagLoader.create();
/**
 * @license
 * Copyright 2016 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

foam.CLASS({
  package: 'foam.graphics',
  name: 'Transform',

  documentation: 'Affine transform.',

  properties: [
    { class: 'Simple', name: 'a' },
    { class: 'Simple', name: 'b' },
    { class: 'Simple', name: 'c' },
    { class: 'Simple', name: 'd' },
    { class: 'Simple', name: 'e' },
    { class: 'Simple', name: 'f' },
    { class: 'Simple', name: 'g' },
    { class: 'Simple', name: 'h' },
    { class: 'Simple', name: 'i' },
    {
      name: 'inverse_',
      factory: function() { return this.cls_.create(); },
      // Exclude from compareTo()
      compare: function() { return 0; }
    }
  ],

  methods: [
    function initArgs() {
      this.a = 1; this.b = 0; this.c = 0;
      this.d = 0; this.e = 1; this.f = 0;
      this.g = 0; this.h = 0; this.i = 1;
    },

    function mul(a, b, c, d, e, f, g, h, i) {
      var ta = this.a, tb = this.b, tc = this.c,
          td = this.d, te = this.e, tf = this.f,
          tg = this.g, th = this.h, ti = this.i;

      this.a = ta * a + tb * d + tc * g;
      this.b = ta * b + tb * e + tc * h;
      this.c = ta * c + tb * f + tc * i;

      this.d = td * a + te * d + tf * g;
      this.e = td * b + te * e + tf * h;
      this.f = td * c + te * f + tf * i;

      this.g = tg * a + th * d + ti * g;
      this.h = tg * b + th * e + ti * h;
      this.i = tg * c + th * f + ti * i;

      return this;
    },

    function mulT(t) {
      return this.mul(t.a, t.b, t.c, t.d, t.e, t.f, t.g, t.h, t.i);
    },

    function mulP(p) {
      var ta = this.a, tb = this.b, tc = this.c,
          td = this.d, te = this.e, tf = this.f,
          tg = this.g, th = this.h, ti = this.i;

      var a = p.x;
      var d = p.y;
      var g = p.w;

      p.x = ta * a + tb * d + tc * g;
      p.y = td * a + te * d + tf * g;
      p.w = tg * a + th * d + ti * g;

      return this;
    },

    function affine(m) {
      return this.mul(m.a, m.b, m.c, m.d, m.e, m.f, m.g, m.h, m.i);
    },

    function transpose() {
      // a b c    a d g
      // d e f -> b e h
      // g h i    c f i
      var tmp = this.b;
      this.b = this.d;
      this.d = tmp;

      tmp = this.c;
      this.c = this.g;
      this.g = tmp;

      tmp = this.f;
      this.f = this.h;
      this.h = tmp;
      return this;
    },

    function invert() {
      var ta = this.a, tb = this.b, tc = this.c,
          td = this.d, te = this.e, tf = this.f,
          tg = this.g, th = this.h, ti = this.i;

      var det = ta*(te*ti  - tf*th) - tb*(td*ti - tf*tg) + tc*(td*th-te*tg);
      var detinv = 1 / det;

      var inv = this.inverse_;

      inv.a = detinv * (te*ti - tf*th);
      inv.b = detinv * (tc*th - tb*ti);
      inv.c = detinv * (tb*tf - tc*te);

      inv.d = detinv * (tf*tg - td*ti);
      inv.e = detinv * (ta*ti - tc*tg);
      inv.f = detinv * (tc*td - ta*tf);

      inv.g = detinv * (td*th - te*tg);
      inv.h = detinv * (tb*tg - ta*th);
      inv.i = detinv * (ta*te - tb*td);

      return inv;
    },

    function det() {
      // Compute the determinant
      var a = this.a, b = this.b, c = this.c,
          d = this.d, e = this.e, f = this.f,
          g = this.g, h = this.h, i = this.i;

      return a*(e*i  - f*h) - b*(d*i - f*g) + c*(d*h-e*g);
    },

    function reset() {
      this.initArgs();
      return this;
    },

    function translate(dx, dy) {
      if ( dx || dy ) this.mul(1, 0, dx, 0, 1, dy, 0, 0, 1);
      return this;
    },

    function skew(x, y) {
      if ( x || y ) this.mul(1, x, 0, y, 1, 0, 0, 0, 1);
      return this;
    },

    function scale(x, y) {
      if ( y === undefined ) y = x;
      if ( x != 1 || y != 1 ) this.mul(x, 0, 0, 0, y, 0, 0, 0, 1);
      return this;
    },

    function rotate(a) {
      if ( a ) this.mul(Math.cos(a), Math.sin(a), 0, -Math.sin(a), Math.cos(a), 0, 0, 0, 1);
      return this;
    },

    function rotateAround(a, x, y) {
      return this.translate(-x, -y).rotate(a).translate(x, y);
    }
  ]
});


foam.CLASS({
  package: 'foam.graphics',
  name: 'Transform3D',

  documentation: 'Three-dimensional affine transform.',

  properties: [
    { class: 'Simple', name: 'a' },
    { class: 'Simple', name: 'b' },
    { class: 'Simple', name: 'c' },
    { class: 'Simple', name: 'd' },

    { class: 'Simple', name: 'e' },
    { class: 'Simple', name: 'f' },
    { class: 'Simple', name: 'g' },
    { class: 'Simple', name: 'h' },

    { class: 'Simple', name: 'i' },
    { class: 'Simple', name: 'j' },
    { class: 'Simple', name: 'k' },
    { class: 'Simple', name: 'l' },

    { class: 'Simple', name: 'm' },
    { class: 'Simple', name: 'n' },
    { class: 'Simple', name: 'o' },
    { class: 'Simple', name: 'p' }
  ],

  methods: [
    function init() {
      this.a = 1; this.b = 0; this.c = 0; this.d = 0;
      this.e = 0; this.f = 1; this.g = 0; this.h = 0;
      this.i = 0; this.j = 0; this.k = 1; this.l = 0;
      this.m = 0; this.n = 0; this.o = 0; this.p = 1;
    },

    function mulM(o) {
      return this.mul(
        o.a, o.b, o.c, o.d,
        o.e, o.f, o.h, o.i,
        o.j, o.j, o.k, o.l,
        o.m, o.n, o.o, o.p);
    },

    function mulP(p) {
      var ta = this.a, tb = this.b, tc = this.c, td = this.d,
          te = this.e, tf = this.f, tg = this.g, th = this.h,
          ti = this.i, tj = this.j, tk = this.k, tl = this.l,
          tm = this.m, tn = this.n, to = this.o, tp = this.p;

      var a = p.x;
      var b = p.y;
      var c = p.z
      var d = p.w;

      p.x = ta * a + tb * b + tc * c + td * d;
      p.y = te * a + tf * b + tg * c + th * d;
      p.z = ti * a + tj * b + tk * c + tl * d;
      p.w = tm * a + tn * b + to * c + tp * d;

      return this;
    },

    function mul(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p) {
      var ta = this.a, tb = this.b, tc = this.c, td = this.d,
          te = this.e, tf = this.f, tg = this.g, th = this.h,
          ti = this.i, tj = this.j, tk = this.k, tl = this.l,
          tm = this.m, tn = this.n, to = this.o, tp = this.p;

      this.a = ta * a + tb * e + tc * i + td * m;
      this.b = ta * b + tb * f + tc * j + td * n;
      this.c = ta * c + tb * g + tc * k + td * o;
      this.d = ta * d + tb * h + tc * l + td * p;

      this.e = te * a + tf * e + tg * i + th * m;
      this.f = te * b + tf * f + tg * j + th * n;
      this.g = te * c + tf * g + tg * k + th * o;
      this.h = te * d + tf * h + tg * l + th * p;

      this.i = ti * a + tj * e + tk * i + tl * m;
      this.j = ti * b + tj * f + tk * j + tl * n;
      this.k = ti * c + tj * g + tk * k + tl * o;
      this.l = ti * d + tj * h + tk * l + tl * p;

      this.m = tm * a + tn * e + to * i + tp * m;
      this.n = tm * b + tn * f + to * j + tp * n;
      this.o = tm * c + tn * g + to * k + tp * o;
      this.p = tm * d + tn * h + to * l + tp * p;

      return this;
    },

    function affine(m) {
      return this.mul(m.a, m.b, m.c, m.d,
                      m.e, m.f, m.g, m.h,
                      m.i, m.j, m.k, m.l,
                      m.m, m.n, m.o, m.p);
    },

    function invert() {
      // a b c d    a e i m
      // e f g h -> b f j n
      // i j k l    c g k o
      // m n o p    d h l p
      var tmp = this.b;
      this.b = this.e;
      this.e = tmp;

      tmp = this.c;
      this.c = this.i;
      this.i = tmp;

      tmp = this.d;
      this.d = this.m;
      this.m = tmp;

      tmp = this.g;
      this.g = this.j;
      this.j = tmp;

      tmp = this.h;
      this.h = this.n;
      this.n = tmp;

      tmp = this.l;
      this.l = this.o;
      this.o = tmp;

      return this;
    },

    function reset() {
      this.init();
      return this;
    },

    function translate(dx, dy, dz) {
      if ( ! dx && ! dy && ! dz ) return;
      this.mul(1, 0, 0, dx,
               0, 1, 0, dy,
               0, 0, 1, dz,
               0, 0, 0, 1);
    },

    function skew(x, y, z) {
      if ( ! x && ! y && ! z ) return;
      throw new Error('not implemented yet.');
    },

    function scale(x, y, z) {
      if ( x === 1 && y === 1 && z == 1 ) return;
      this.mul(x, 0, 0, 0,
               0, y, 0, 0,
               0, 0, z, 0,
               0, 0, 0, 1);
    },

    function rotateX(a) {
      if ( ! a ) return;
      var c = Math.cos(a);
      var s = Math.sin(a);

      this.mul(
        1,  0,  0,  0,
        0,  c, -s,  0,
        0,  s,  c,  0,
        0,  0,  0,  1);
    },

    function rotateY(a) {
      if ( ! a ) return;
      var c = Math.cos(a);
      var s = Math.sin(a);

      this.mul(
        c,  0,  s,  0,
        0,  1,  0,  0,
       -s,  0,  c,  0,
        0,  0,  0,  1);
    },


    function rotateZ(a) {
      if ( ! a ) return;
      var c = Math.cos(a);
      var s = Math.sin(a);

      this.mul(
        c, -s,  0,  0,
        s,  c,  0,  0,
        0,  0,  1,  0,
        0,  0,  0,  1);
    },

    function rotate(x, y, z, r) {
      var d = Math.sqrt(x*x + y*y + z*z);
      x /= d;
      y /= d;
      z /= d;

      var cos = Math.cos(r);
      var sin = Math.sin(r);

      this.mul(
        cos + x*x*(1 - cos),     x*y*(1 - cos) - z*sin,   x*z*(1 - cos) + y*sin,  0,
        y*x*(1 - cos) + z*sin,   cos + y*y*(1-cos),       y*z*(1 - cos) - x*sin,  0,
        z*x*(1 - cos) - y*sin,   z*y*(1 - cos) + x*sin,   cos + z*z*(1 - cos),    0,
        0,                       0,                       0,                      1);

    }
  ]
});


foam.CLASS({
  package: 'foam.graphics',
  name: 'CView',

  documentation: 'A Canvas-View; base-class for all graphical view components.',

  requires: [
    'foam.graphics.Canvas',
    'foam.graphics.Transform'
  ],

  // Fires when this CView is invalidated and needs a repaint.
  // Is listened to a foam.u2.Canvas() if one was created for
  // this CView.
  topics: [ 'invalidated' ],

  properties: [
    {
      class: 'Float',
      name: 'width'
    },
    {
      class: 'Float',
      name: 'height'
    },
    {
      class: 'Float',
      name: 'rotation',
      preSet: function(_, r) {
        if ( r > 2 * Math.PI  ) return r - 2 * Math.PI;
        if ( r < -2 * Math.PI ) return r + 2 * Math.PI;
        return r;
      },
      view: {
        class: 'foam.u2.view.DualView',
        viewa: { class: 'foam.u2.FloatView', precision: 4, onKey: true },
        viewb: { class: 'foam.u2.RangeView', step: 0.00001, minValue: -Math.PI*2, maxValue: Math.PI*2, onKey: true }
      }
    },
    {
      name: 'originX',
      class: 'Float'
    },
    {
      name: 'originY',
      class: 'Float'
    },
    {
      name: 'scaleX',
      class: 'Float',
      value: 1
    },
    {
      name: 'scaleY',
      class: 'Float',
      value: 1
    },
    {
      name: 'skewX',
      class: 'Float',
      hidden: true
    },
    {
      name: 'skewY',
      class: 'Float',
      hidden: true
    },
    {
      name: 'x',
      class: 'Float'
    },
    {
      name: 'y',
      class: 'Float'
    },
    {
      name: 'alpha',
      class: 'Float',
      view: {
        class: 'foam.u2.view.DualView',
        viewa: { class: 'foam.u2.FloatView', precision: 4, onKey: true },
        viewb: { class: 'foam.u2.RangeView', step: 0.0001, maxValue: 1, onKey: true }
      },
      value: 1
    },
    {
      class: 'Color',
      name: 'border'
    },
    {
      class: 'Color',
      name: 'color'
    },
    {
      class: 'Color',
      name: 'shadowColor'
    },
    {
      class: 'Int',
      name: 'shadowBlur',
      units: 'pixels'
    },
    {
      name: 'children',
      factory: function() { return []; },
      postSet: function(o, n) {
        for ( var i = 0 ; o && i < o.length ; i++ ) this.removeChild_(o[i]);
        for ( var i = 0 ; n && i < n.length ; i++ ) this.addChild_(n[i]);
      },
      hidden: true
    },
    {
      name: 'state',
      value: 'initial',
      hidden: 'true',
      transient: true
    },
    {
      name: 'parent',
      hidden: 'true',
      transient: true
    },
    {
      name: 'canvas',
      hidden: 'true',
      transient: true
    },
    {
      name: 'transform_',
      hidden: 'true',
      transient: true,
      factory: function() { return this.Transform.create(); }
    },
    {
      name: 'transform',
      hidden: 'true',
      expression: function getTransform(x, originX, y, originY, rotation, skewX, skewY, scaleX, scaleY) {
        var t = this.transform_.reset();

        t.translate(x+originX, y+originY);
        t.rotate(rotation);
        t.skew(skewX, skewY);
        t.scale(scaleX, scaleY);
        t.translate(-originX, -originY);

        return t;
      }
    },
    {
      // If set to true, then this CView will automatically repaint
      // whenever a child is added or removed, a property changes, or
      // a property of a child changes. Only works if this CView has
      // an associated Canvas (by calling toE()).
      class: 'Boolean',
      name: 'autoRepaint',
      hidden: true,
      value: true
    },
    { name: 'top_',    hidden: true, transient: true, getter: function() { return this.y; } },
    { name: 'left_',   hidden: true, transient: true, getter: function() { return this.x; } },
    { name: 'bottom_', hidden: true, transient: true, getter: function() { return this.y+this.height; } },
    { name: 'right_',  hidden: true, transient: true, getter: function() { return this.x+this.width; } },
    {
      name: 'invalidate_',
      transient: true,
      hidden: true,
      // TODO: Would be more efficient to be a factory, but doesn't work. Investigate.
      getter: function() {
        return this.parent ? this.parent.invalidate_ :
          this.autoRepaint ? this.invalidated.pub    :
          null ;
      }
    }
  ],

  methods: [
    function initCView() {
      this.invalidate_ && this.propertyChange.sub(this.invalidate_);
    },

    function invalidate() {
      this.invalidate_ && this.invalidate_();
    },

    function parentToLocalCoordinates(p) {
      this.transform.invert().mulP(p);
      p.x /= p.w;
      p.y /= p.w;
      p.w = 1;
    },

    function globalToLocalCoordinates(p) {
      if ( this.parent ) this.parent.globalToLocalCoordinates(p);
      this.parentToLocalCoordinates(p);
    },

    function findFirstChildAt(p) {
      if ( arguments.length > 1 ) {
        var tmp = foam.graphics.Point.create();
        tmp.x = arguments[0];
        tmp.y = arguments[1];
        tmp.w = 1;
        p = tmp;
      }

      this.parentToLocalCoordinates(p);

      if ( this.children.length ) {
        var p2 = foam.graphics.Point.create();

        for ( var i = 0 ; i < this.children.length ; i++ ) {
          p2.x = p.x;
          p2.y = p.y;
          p2.w = p.w;

          var c = this.children[i].findFirstChildAt(p2);
          if ( c ) return c;
        }
      }

      if ( this.hitTest(p) ) return this;
    },

    // p must be in local coordinates.
    function hitTest(p) {
      return p.x >= 0 && p.y >= 0 && p.x < this.width && p.y < this.height;
    },

    function maybeInitCView(x) {
      if ( this.state === 'initial' ) {
        this.state = 'initailized'
        this.initCView(x);
      }
    },

    function paint(x) {
      this.maybeInitCView(x);

      x.save();

      var
        alpha       = this.alpha,
        border      = this.border,
        color       = this.color,
        shadowColor = this.shadowColor,
        shadowBlur  = this.shadowBlur;

      if ( alpha !== 1 ) {
        x.globalAlpha *= alpha;
      }

      if ( border ) {
        x.strokeStyle = border.toCanvasStyle ?
          border.toCanvasStyle(x) :
          border ;
      }

      if ( color ) {
        x.fillStyle = color.toCanvasStyle ?
          color.toCanvasStyle(x) :
          color ;
      }

      this.doTransform(x);

      if ( shadowColor && shadowBlur ) {
        x.shadowColor = shadowColor;
        x.shadowBlur  = shadowBlur;
      }

      this.paintSelf(x);
      this.paintChildren(x);

      x.restore();
    },

    function doTransform(x) {
      var t = this.transform;
      x.transform(t.a, t.d, t.b, t.e, t.c, t.f);
    },

    function paintChildren(x) {
      for ( var i = 0 ; i < this.children.length ; i++ ) {
        this.children[i].paint(x);
      }
    },

    function remove(c) {
      for ( var i = 0 ; i < this.children.length ; i++ ) {
        if ( this.children[i] === c ) {
          this.children.splice(i, 1);
          this.removeChild_(c);
          return;
        }
      }
    },

    function removeAllChildren() {
      var children = this.children;
      this.children = [];
      for ( var i = 0 ; i < children.length ; i++ ) {
        this.removeChild_(children[i]);
      }
    },

    function removeChild(c) {
      console.log('Deprecated use of CView.removeChild(). Use .remove() instead.');
      this.remove(c);
    },

    function addChild_(c) {
      c.parent = this;
      c.canvas = this.canvas;
      return c;
    },

    function removeChild_(c) {
      c.parent = undefined;
      c.canvas = undefined;
      this.invalidate();
      return c;
    },

    function add() {
      for ( var i = 0 ; i < arguments.length ; i++ ) {
        this.children.push(arguments[i]);
        this.addChild_(arguments[i]);
      }
      this.invalidate();
      return this;
    },

    function addChildren() {
      console.warn('Deprecated use of CView.addChildren(). Use add() instead.');
      return this.add.apply(this, arguments);
    },

    function paintSelf(x) {},

    function hsl(h, s, l) {
      return 'hsl(' + h + ',' + s + '%,' + l + '%)';
    },

    function write() {
      return this.toE().write();
    },

    function toE(args, X) {
      return this.Canvas.create({ cview: this }, X).attrs({
        width:  this.slot(function(x, width,  scaleX) { return x + width*scaleX; }),
        height: this.slot(function(y, height, scaleY) { return y + height*scaleY; })
      });
    },

    function intersects(c) {
      if ( c.radius ) {
        return ! (
            this.x + this.width  < c.x - c.radius ||
            this.y + this.height < c.y - c.radius ||
            c.x    + c.radius    < this.x         ||
            c.y    + c.radius    < this.y );
      }
      return ! (
          this.x + this.width  < c.x ||
          this.y + this.height < c.y ||
          c.x    + c.width  < this.x ||
          c.y    + c.height < this.y );
    },

    function equals(b) { return this === b; }
  ]
});


foam.CLASS({
  package: 'foam.graphics',
  name: 'CView3D',

  requires: [
    'foam.graphics.Transform3D'
  ],

  properties: [
    { class: 'Float', name: 'x' },
    { class: 'Float', name: 'y' },
    { class: 'Float', name: 'z' },
    { class: 'Float', name: 'rotateX' },
    { class: 'Float', name: 'rotateY' },
    { class: 'Float', name: 'rotateZ' },
    { class: 'Float', name: 'scaleX', value: 1 },
    { class: 'Float', name: 'scaleY', value: 1 },
    { class: 'Float', name: 'scaleZ', value: 1 },
    {
      name: 'transform_',
      factory: function() {
        return this.Transform3D.create();
      }
    },
    {
      name: 'transform',
      getter: function() {
        var t = this.transform_.reset();

        t.translate(this.x, this.y, this.z);
        t.rotateX(this.rotateX);
        t.rotateY(this.rotateY);
        t.rotateZ(this.rotateZ);
        t.scale(this.scaleX, this.scaleY, this.scaleZ);

        return t;
      }
    }
  ],

  methods: [
    function paint3D(gl) {
      // TODO: transform
      this.paintSelf(gl);
    },

    function paintSelf(gl) {
      gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);
      gl.enableVertexAttribArray(this.positionAttribute);
      gl.vertexAttribPoint(this.positionAttribute);
      gl.drawArrays(this.drawType, 0, this.vertexCount);
    }
  ]
});


foam.CLASS({
  package: 'foam.graphics',
  name: 'Box',
  extends: 'foam.graphics.CView',

  documentation: 'A CView for drawing a rectangular box.',

  properties: [
    {
      class: 'Float',
      name: 'width'
    },
    {
      class: 'Float',
      name: 'height'
    },
    {
      class: 'Float',
      name: 'borderWidth',
      value: 1
    },
    {
      name: 'border',
      value: '#000000'
    }
  ],

  methods: [
    function paintSelf(x) {
      x.beginPath();
      x.rect(0, 0, this.width, this.height);
      if ( this.border && this.borderWidth ) {
        x.lineWidth = this.borderWidth;
        x.stroke();
      }
      if ( this.color  ) x.fill();
    }
  ]
});


foam.CLASS({
  package: 'foam.graphics',
  name: 'Line',
  extends: 'foam.graphics.CView',

  documentation: 'A CView for drawing a line.',

  properties: [
    {
      class: 'Float',
      name: 'startX',
      getter: function() { return this.x; },
      setter: function(v) { this.x = v; }
    },
    {
      class: 'Float',
      name: 'startY',
      getter: function() { return this.y; },
      setter: function(v) { this.y = v; }
    },
    { class: 'Float',  name: 'endX' },
    { class: 'Float',  name: 'endY' },
    { class: 'Float',  name: 'lineWidth', value: 1 },
    { class: 'String', name: 'color',     value: '#000000' },
    { name: 'lineDash', documentation: 'An Array of numbers which specify distances to alternately draw lines and gaps. Full line if not set.' },
  ],

  methods: [
    function paintSelf(x) {
      x.beginPath();
      if ( this.lineDash ) x.setLineDash(this.lineDash);
      x.moveTo(0, 0);
      x.lineTo(this.endX-this.x, this.endY-this.y);
      x.lineWidth = this.lineWidth;
      x.strokeStyle = this.color;
      x.stroke();
    },

    function hitTest(p) {
      // There is probably a better way to do this.
      // This checks if the given point is

      // A is the vector from the start of the line to point p
      var ax = p.x - this.startX;
      var ay = p.y - this.startY;

      // B a vector representing the line (from start to end).
      var bx = this.endX - this.startX;
      var by = this.endY - this.startY;
      var blen = Math.sqrt(bx * bx + by * by);

      // Project A onto B
      var scalarProj = (ax * bx + ay * by ) / blen;
      var factor = scalarProj / blen;
      var projX = bx * factor;
      var projY = by * factor;

      // Calculate vector rejection "perpendicular distance"
      var rejX = ax - projX;
      var rejY = ay - projY;

      // Hit's if the perpendicular distance is less than some factor,
      // and the point is within some factor of the line start/finish

      var distance = Math.sqrt(rejX * rejX + rejY * rejY);
      var pos = scalarProj;

      return distance < 5 && pos > -5 && pos < (blen + 5)

      return false;
    }
  ]
});


foam.CLASS({
  package: 'foam.graphics',
  name: 'Polygon',
  extends: 'foam.graphics.CView',

  documentation: 'A CView for drawing a polygon.',

  properties: [
    { class: 'Array', of: 'Float', name: 'xCoordinates' },
    { class: 'Array', of: 'Float', name: 'yCoordinates' },
    { class: 'String', name: 'color', value: '#000' },
    { class: 'Float', name: 'lineWidth', value: 1 }
  ],

  methods: [
    function paintSelf(x) {
      x.beginPath();
      x.moveTo(this.xCoordinates[0], this.yCoordinates[0]);
      for ( var i = 1; i < this.xCoordinates.length; i++ ) {
        x.lineTo(this.xCoordinates[i], this.yCoordinates[i]);
      }
      x.lineWidth = this.lineWidth;
      x.strokeStyle = this.color;
      x.stroke();
    }
  ]
});


foam.CLASS({
  package: 'foam.graphics',
  name: 'Arc',
  extends: 'foam.graphics.CView',

  documentation: 'A CView for drawing an arc.',

  properties: [
    {
      name: 'radius',
      class: 'Float',
      preSet: function(_, r) { return Math.max(0, r); }
    },
    {
      name: 'start',
      class: 'Float'
    },
    {
      name: 'end',
      class: 'Float'
    },
    {
      // TODO: rename this
      name: 'arcWidth',
      class: 'Float'
    },
    {
      name: 'border',
      value: '#000000'
    },
    { name: 'top_',    hidden: true, transient: true, getter: function() { return this.y-this.radius; } },
    { name: 'left_',   hidden: true, transient: true, getter: function() { return this.x-this.radius; } },
    { name: 'bottom_', hidden: true, transient: true, getter: function() { return this.y+this.radius; } },
    { name: 'right_',  hidden: true, transient: true, getter: function() { return this.x+this.radius; } }
  ],

  methods: [
    function paintSelf(x) {
      x.beginPath();
      x.arc(0, 0, this.radius, this.start, this.end);
	  x.lineTo(0,0);

      if ( this.color ) x.fill();

      if ( this.border ) {
        x.lineWidth = this.arcWidth;
        x.stroke();
      }
    },

    function toE(X) {
      return this.Canvas.create({ cview: this }, X).attrs({
        width: this.x + this.radius + this.arcWidth,
        height: this.y + this.radius + this.arcWidth
      });
    }
  ]
});


foam.CLASS({
  package: 'foam.graphics',
  name: 'Circle',
  extends: 'foam.graphics.Arc',

  documentation: 'A CView for drawing a Circle.',

  properties: [
    {
      name: 'start',
      value: 0,
      view: {
        class: 'foam.u2.view.DualView',
        viewa: { class: 'foam.u2.FloatView', precision: 4, onKey: true },
        viewb: { class: 'foam.u2.RangeView', maxValue: Math.PI*2, step: 0.01, onKey: true }
      }
    },
    {
      name: 'end',
      value: 2*Math.PI,
      view: {
        class: 'foam.u2.view.DualView',
        viewa: { class: 'foam.u2.FloatView', precision: 4, onKey: true },
        viewb: { class: 'foam.u2.RangeView', maxValue: Math.PI*2, step: 0.01, onKey: true }
      }
    }
  ],

  methods: [
    function hitTest(p) {
      var r = this.radius + this.arcWidth/2 - 1;
      return p.x*p.x + p.y*p.y <= r*r;
    },

    function intersects(c) {
      if ( ! c.radius ) return c.intersects(this);
      var r = this.radius + c.radius;
      if ( this.border ) r += this.arcWidth/2-1;
      if ( c.border    ) r += c.arcWidth/2-1;
      var dx = this.x-c.x;
      var dy = this.y-c.y;
      return dx * dx + dy * dy <= r * r;
    }
  ]
});


foam.CLASS({
  package: 'foam.graphics',
  name: 'Ellipse',
  extends: 'foam.graphics.CView',

  documentation: 'A CView for drawing an ellipse.',

  properties: [
    {
      class: 'Float',
      name: 'radiusX',
      preSet: function(_, r) { return Math.max(0, r); }
    },
    {
      class: 'Float',
      name: 'radiusY',
      preSet: function(_, r) { return Math.max(0, r); }
    },
    {
      name: 'start',
      value: 0,
      view: {
        class: 'foam.u2.view.DualView',
        viewa: { class: 'foam.u2.FloatView', precision: 4, onKey: true },
        viewb: { class: 'foam.u2.RangeView', maxValue: Math.PI*2, step: 0.01, onKey: true }
      }
    },
    {
      name: 'end',
      value: 2*Math.PI,
      view: {
        class: 'foam.u2.view.DualView',
        viewa: { class: 'foam.u2.FloatView', precision: 4, onKey: true },
        viewb: { class: 'foam.u2.RangeView', maxValue: Math.PI*2, step: 0.01, onKey: true }
      }
    },
    {
      name: 'borderWidth',
      class: 'Float'
    },
    {
      name: 'border',
      value: '#000000'
    },
    {
      class: 'Float',
      name: 'width',
      getter: function() { return 2 * this.radiusX; },
      setter: function(w) { this.radiusX = w / 2; }
    },
    {
      class: 'Float',
      name: 'height',
      getter: function() { return 2 * this.radiusY; },
      setter: function(h) { this.radiusY = h / 2; }
    },
    { name: 'top_',    hidden: true, transient: true, getter: function() { return this.y; } },
    { name: 'left_',   hidden: true, transient: true, getter: function() { return this.x; } },
    { name: 'bottom_', hidden: true, transient: true, getter: function() { return this.y+2*this.radiusY; } },
    { name: 'right_',  hidden: true, transient: true, getter: function() { return this.x+2*this.radiusX; } },
  ],

  methods: [
    function paintSelf(x) {
      x.beginPath();
      x.ellipse(this.radiusX, this.radiusY, this.radiusX, this.radiusY, 0, this.start, this.end);

      if ( this.color ) x.fill();

      if ( this.border ) {
        x.lineWidth = this.borderWidth;
        x.stroke();
      }
    }

    // TODO: implement intersects()
  ]
});


foam.CLASS({
  package: 'foam.graphics',
  name: 'Point',

  // TODO: where/how is this used?
  // documentation: '',

  properties: [
    {
      class: 'Simple',
      name: 'x'
    },
    {
      class: 'Simple',
      name: 'y'
    },
    {
      class: 'Simple',
      name: 'w'
    }
  ],

  methods: [
    function clone() {
      var p = this.cls_.create();
      p.x = this.x;
      p.y = this.y;
      p.w = this.w;
      return p;
    },

    function toCartesian() {
      // TODO: What is the right name for this function?
      // It's related to perspective transformations
      // It transforms this point from the homogeneous coordinate space
      // to the cartesian coordiate space.

      this.x = this.x / this.w;
      this.y = this.y / this.w;
      this.w = 1;
    }
  ]
});


foam.CLASS({
  package: 'foam.graphics',
  name: 'Canvas',
  extends: 'foam.u2.Element',

  documentation: 'A Canvas U2 Element for drawing CViews in. Don\'t create directly, use CView.toE() instead.',

  requires: [
    'foam.input.Pointer'
  ],

  properties: [
    [ 'nodeName', 'CANVAS' ],
    {
      name: 'context',
      factory: function() {
        return this.el().getContext('2d');
      }
    },
    {
      name: 'context3D',
      factory: function() {
        return this.el().getContext('webgl');
      }
    },
    {
      name: 'cview',
      postSet: function(o, n) {
        n.canvas = this;

        if ( this.attributeMap.width === undefined || this.attributeMap.height === undefined ) {
          this.setAttribute('width',  n.width);
          this.setAttribute('height', n.height);
        }

        this.paint();
      }
    },
    {
      name: 'pointer',
      factory: function() {
        return this.Pointer.create({ element: this });
      }
    }
  ],

  methods: [
    function initE() {
      this.SUPER();
      this.on('load', this.paint);
      this.cview$.valueSub('invalidated', this.paint);
    },

    function erase() {
      this.el().width = this.el().width;
    }
  ],

  listeners: [
    {
      name: 'paint',
      isFramed: true,
      code: function paintCanvas() {
        // Only paint after being loaded
        if ( this.state !== this.LOADED || ! this.cview ) return;

        var ctx = this.cview.paint3D ? this.context3D : this.context;
        this.erase(ctx);
        if ( this.cview.paint3D ) {
          this.cview.paint3D(ctx);
        } else {
          this.cview.paint(ctx);
        }
      }
    }
  ]
});


foam.CLASS({
  package: 'foam.graphics',
  name: 'Gradient',

  // TODO: where/how is this used?
//   documentation: '',

  properties: [
    'x0', 'y0', 'r0',
    'x1', 'y1', 'r1',
    {
      name: 'radial',
      class: 'Boolean',
      value: false
    },
    {
      name: 'colors',
      factory: function() {
        return [];
      }
    }
  ],

  methods: [
    function toCanvasStyle(x) {
      var t = this;
      var g = this.radial ?
        x.createRadialGradient(t.x0, t.y0, t.r0, t.x1, t.y1, t.r1) :
        x.createLinearGradient(t.x0, t.y0, t.x1, t.y1) ;

      for ( var i = 0 ; i < t.colors.length ; i++ )
        g.addColorStop(t.colors[i][0], t.colors[i][1]);

      return g;
    }
  ]
});

// TODO: add configurable repaint strategy. Ex. explicit, on property change, on child change


foam.CLASS({
  package: 'foam.graphics',
  name:  'Label',
  extends: 'foam.graphics.CView',

  documentation: 'A CView drawing text.',

  properties: [
    {
      class: 'String',
      name:  'text',
      view: { class: 'foam.u2.TextField', onKey: true }
    },
    {
      name:  'align',
      label: 'Alignment',
      value: 'start',
      view: {
        class: 'foam.u2.view.RadioView',
        choices: [ 'start', /*'left',*/ 'center', /*'right',*/ 'end' ]
      }
    },
    {
      class: 'String',
      name:  'font'
    },
    {
      class: 'Color',
      name:  'color',
      value: '#000000'
    },
    {
      class: 'Color',
      name: 'border',
      label: 'Border Color'
    },
    {
      class: 'Float',
      name:  'maxWidth',
      label: 'Maximum Width',
      value: -1
    }
  ],

  methods: [
    function paintSelf(c) {
      if ( this.font ) c.font = this.font;

      c.textAlign = this.align;
      c.fillStyle = this.color;

      c.fillText(
        this.text,
          this.align === 'start'  ? 0 :
          this.align === 'center' ? this.width/2 :
          this.width,
        this.height/2+10);

      if ( this.border ) {
        c.strokeStyle = this.border;
        c.strokeRect(0, 0, this.width-1, this.height-1);
      }
    }
  ]
});

/*
a : 1 // H scale
b : 0 // V skew
c : 3821.142407877334 // H move
d : 0 // H skew
e : 1 // V scale
f : -6796.176219640322 // V move
g : 0
h : 0
i : 1
*/
/**
 * @license
 * Copyright 2016 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

foam.CLASS({
  package: 'foam.graphics',
  name: 'ScrollCView',
  extends: 'foam.graphics.CView',

  properties: [
    {
      class: 'Float',
      name: 'width',
      value: 20
    },
    {
      class: 'Float',
      name: 'height',
      value: 100
    },
    {
      class: 'Boolean',
      name: 'vertical',
      value: true
    },
    {
      class: 'Int',
      name: 'value',
//      help: 'The first element being shown, starting at zero.',
      preSet: function(_, value) {
        return Math.max(0, Math.min(this.size-this.extent, value));
      },
      postSet: function(old, nu) {
        if ( old !== nu ) this.invalidated.pub();
      }
    },
    {
      class: 'Int',
      name: 'extent',
//      help: 'Number of elements shown.',
//      minValue: 1, // TODO: add back when minValue supported
      value: 10,
      postSet: function(old, nu) {
        if ( old !== nu ) this.invalidated.pub();
      }
    },
    {
      class: 'Int',
      name: 'size',
//      help: 'Total number of elements being scrolled through.',
      value: 0,
      postSet: function(old, size) {
        if ( old !== size ) this.invalidated.pub();
        // Trigger the preSet for value, so it stays within range.
        this.value = this.value;
      }
    },
    {
      class: 'Int',
      name: 'minHandleSize',
//      help: 'Minimum size to make the drag handle.'
      value: 10
    },
    {
      class: 'Float',
      name: 'handleSize',
      expression: function(minHandleSize, size, extent, height, innerBorder) {
        var h  = height - 2 * innerBorder;
        var hs = size > 0 ? extent * h / size : 0;

        return hs < minHandleSize ? minHandleSize : hs;
      }
    },
    {
      class: 'Int',
      name: 'innerBorder',
      value: 2
    },
    {
      class: 'String',
      name: 'handleColor',
      value: 'rgb(107,136,173)'
    },
    {
      class: 'String',
      name: 'borderColor',
      value: '#999'
    },
    {
      name: 'yMax',
      expression: function(height, innerBorder, handleSize)  {
        return height - innerBorder - handleSize;
      }
    },
    {
      name: 'rate',
      expression: function(size, extent, yMax, innerBorder) {
        return size ? ( yMax - innerBorder ) / (size - extent) : 0;
      }
    },
  ],

  methods: [
    function initCView() {
      this.onDetach(this.canvas.pointer.touch.sub(this.onTouch));

      var self = this;
      var mouseInput = this.canvas.pointer.mouseInput;
      this.onDetach(mouseInput.down.sub(function() {
        var moveSub = mouseInput.move.sub(function() {
          self.value = self.yToValue(mouseInput.y);
        });
        mouseInput.up.sub(function(s) {
          moveSub.detach();
          s.detach();
        });
      }));
    },

    function yToValue(y) {
      return ( y - this.innerBorder ) / this.rate;
    },

    function valueToY(value) {
      return value * this.rate + this.innerBorder;
    },

    function paintSelf(c) {
      if ( ! this.size ) return;

      if ( ! c ) return;

      if ( this.extent >= this.size ) return;

      c.strokeStyle = this.borderColor;
      c.lineWidth = 0.4;
      c.strokeRect(0, 0, this.width-7, this.height);

      c.fillStyle = this.handleColor;

      c.fillRect(
        2,
        this.valueToY(this.value),
        this.width - 11,
        this.handleSize);
    }
  ],

  listeners: [
    {
      name: 'onTouch',
      code: function(_, __, touch) {
        this.value = this.yToValue(touch.y);

        // prevents highlighting of other elements while scrolling
        touch.claimed = true;
      }
    },
  ]
});
/**
 * @license
 * Copyright 2015 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

foam.CLASS({
  package: 'foam.physics',
  name: 'PhysicalCircle',
  extends: 'foam.graphics.Circle',
  implements: [ 'foam.physics.Physical' ],

  documentation: 'A Circle with Physical support.'
});
/**
 * @license
 * Copyright 2016 Google Inc. All Rights Reserved.
 * Copyright 2017 The FOAM Authors. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

foam.CLASS({
  package: 'foam.comics',
  name: 'DAOController',

  topics: [
    'finished'
  ],

  properties: [
    {
      name: 'data',
      hidden: true
    },
    {
      name: 'predicate',
      view: { class: 'foam.u2.view.ReciprocalSearch' }
    },
    {
      name: 'filteredDAO',
      view: { class: 'foam.u2.view.ScrollTableView' },
      expression: function(data, predicate) {
        return predicate ? data.where(predicate) : data;
      }
    },
    {
      name: 'relationship'
    },
    {
      name: 'selection',
      hidden: true
    },
    {
      class: 'Boolean',
      name: 'createEnabled',
      documentation: 'True to enable the create button.',
      value: true
    },
    {
      class: 'Boolean',
      name: 'editEnabled',
      documentation: 'True to enable the edit button',
      value: true
    },
    {
      class: 'Boolean',
      name: 'selectEnabled',
      documentation: 'True to enable the select button.',
      value: false
    },
    {
      class: 'Boolean',
      name: 'addEnabled',
      documentation: 'True to enable the Add button for adding to a relationship',
      value: false
    }
  ],

  actions: [
    {
      name: 'create',
      isAvailable: function(createEnabled) { return createEnabled; },
      code: function() { }
    },
    {
      name: 'edit',
      isEnabled: function(selection) { return !! selection; },
      isAvailable: function(editEnabled) { return editEnabled; },
      code: function() {
        this.pub('edit', this.selection.id);
      }
    },
    {
      name: 'findRelatedObject',
      label: 'Add',
      isAvailable: function(relationship, addEnabled) {
        // Only enable the Add button if we're not already trying to choose a selected item for a relationship.
        return !! ( relationship && relationship.junctionDAO ) && ! addEnabled;
      },
      code: function() { }
    },
    {
      name: 'addSelection',
      label: 'Add',
      isAvailable: function(addEnabled) { return addEnabled; },
      code: function() {
        var self = this;
        this.relationship.add(this.selection).then(function() {
          self.finished.pub();
        });
      }
    },
    {
      name: 'select',
      isAvailable: function(selectEnabled) { return selectEnabled; },
      isEnabled: function(selection) { return !! selection; },
      code: function() {
        this.pub('select', this.selection.id);
        this.finished.pub();
      }
    }
  ]
});
/**
 * @license
 * Copyright 2017 The FOAM Authors. All Rights Reserved.
 * http://www.apache.org/licenses/LICENSE-2.0
 */

foam.CLASS({
  package: 'foam.comics',
  name: 'DAOControllerView',
  extends: 'foam.u2.View',

  requires: [
    'foam.comics.DAOController',
    'foam.u2.view.ScrollTableView'
  ],

  imports: [
    'stack',
    'summaryView? as importedSummaryView',
    'data? as importedData',
    'window'
  ],

  exports: [
    'data.selection as selection',
    'data.data as dao',
    'dblclick'
  ],

  // TODO: wrong class name, fix when ActionView fixed.
  css: `
    ^ .net-nanopay-ui-ActionView {
      background: #59aadd;
      color: white;
      margin-right: 4px;
    }
  `,

  properties: [
    {
      class: 'FObjectProperty',
      of: 'foam.comics.DAOController',
      name: 'data',
      expression: function(importedData) { return importedData; }
    },
    {
      name: 'cls',
      expression: function(data) { return data.cls_; }
    },
    {
      name: 'summaryView',
      factory: function() {
        return this.importedSummaryView$ ?
            this.importedSummaryView :
            { class: 'foam.u2.view.ScrollTableView' };
      }
    },
    {
      class: 'String',
      name: 'title',
      expression: function(data$data$of) {
        return 'Browse ' + data$data$of.name;
      }
    }
  ],

  reactions: [
    [ 'data', 'action.create', 'onCreate' ],
    [ 'data', 'edit', 'onEdit' ],
    [ 'data', 'action.findRelatedObject', 'onFindRelated' ],
    [ 'data', 'finished', 'onFinished' ]
  ],

  methods: [
    function initE() {
      var self = this;

      this.
        addClass(this.myClass()).
        start('table').
          start('tr').
            start('td').style({display: 'block', padding: '8px'}).add(this.cls.PREDICATE).end().
            start('td').style({'vertical-align': 'top', 'width': '100%'}).
              start('span').
                style({background: 'rgba(0,0,0,0)'}).
                show(self.mode$.map(function(m) { return m == foam.u2.DisplayMode.RW; })).
                  start().
                    style({padding: '4px 4px 4px 1px'}).
                    add(self.cls.getAxiomsByClass(foam.core.Action)).
                  end().
                end().
              tag(this.summaryView, {data$: this.data.filteredDAO$}).
            end().
          end().
        end();
    },

    function dblclick(obj) {
      this.onEdit(null, null, obj.id);
    }
  ],

  listeners: [
    function onCreate() {
      this.stack.push({
        class: 'foam.comics.DAOCreateControllerView'
      }, this);
    },

    function onEdit(s, edit, id) {
      this.stack.push({
        class: 'foam.comics.DAOUpdateControllerView',
        key: id
      }, this);
    },

    function onFindRelated() {
      var data = this.DAOController.create({
        data: this.data.relationship.targetDAO,
        addEnabled: true,
        relationship: this.data.relationship
      });

      this.stack.push({
        class: 'foam.comics.DAOControllerView',
        data: data
      }, this);
    },

    function onFinished() {
      this.stack.back();
    }
  ]
});
/**
 * @license
 * Copyright 2017 The FOAM Authors. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

foam.CLASS({
  package: 'foam.comics',
  name: 'InlineDAOControllerView',
  extends: 'foam.comics.DAOControllerView',
  
  methods: [
    function initE() {
      this.
        add(this.cls.FILTERED_DAO).
        start('span').
          show(this.mode$.map(function(m) { return m == foam.u2.DisplayMode.RW; })).
          add(this.cls.getAxiomsByClass(foam.core.Action)).
        end();
    }
  ]
});
/**
 * @license
 * Copyright 2016 Google Inc. All Rights Reserved.
 * Copyright 2017 The FOAM Authors. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

foam.CLASS({
  package: 'foam.comics',
  name: 'DAOCreateController',

  topics: [
    'finished'
  ],

  properties: [
    {
      name: 'dao'
    },
    {
      class: 'Boolean',
      name: 'inProgress'
    },
    {
      name: 'exception'
    },
    {
      name: 'data',
      view: { class: 'foam.u2.DetailView' },
      factory: function() {
        return this.dao ? this.dao.of.create({}, this) : null;
      }
    }
  ],

  actions: [
    {
      name: 'save',
      isEnabled: function(dao, data$errors_, inProgress) { return !! dao && ! inProgress && ! data$errors_; },
      code: function() {
        this.inProgress = true;
        this.clearProperty('exception');
        var self = this;
        this.dao.put(this.data.clone()).then(function() {
          self.inProgress = false;
          self.finished.pub();
        }, function(e) {
          self.inProgress = false;
          self.exception = e;
        });
      }
    },
    {
      name: 'cancel',
      code: function() {
        this.finished.pub();
      }
    }
  ]
});
/**
 * @license
 * Copyright 2017 The FOAM Authors. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

foam.CLASS({
  package: 'foam.comics',
  name: 'DAOCreateControllerView',
  extends: 'foam.u2.View',

  requires: [
    'foam.comics.DAOCreateController'
  ],

  imports: [
    'stack',
    'dao'
  ],

  exports: [
    'data'
  ],

  css: `
    ^ .net-nanopay-ui-ActionView {
      background: #59aadd;
      color: white;
      margin-right: 4px;
    }
  `,

  properties: [
    {
      class: 'FObjectProperty',
      of: 'foam.comics.DAOCreateController',
      name: 'data',
      factory: function() {
        return this.DAOCreateController.create({ dao: this.dao });
      }
    },
    {
      class: 'String',
      name: 'title',
      expression: function(data$dao$of) {
        return 'Create ' + data$dao$of.name;
      }
    }
  ],

  reactions: [
    [ 'data', 'finished', 'onFinished' ]
  ],

  methods: [
    function initE() {
      this.
      addClass(this.myCls()).
      start('table').
        start('tr').
          start('td').style({'vertical-align': 'top', 'width': '100%'}).
            start('span').
              style({background: 'rgba(0,0,0,0)'}).
              show(this.mode$.map(function(m) { return m == foam.u2.DisplayMode.RW; })).
              start().
                style({'padding-bottom': '4px'}).
                add(this.data.cls_.getAxiomsByClass(foam.core.Action)).
              end().
            end().
            add(this.DAOCreateController.DATA).
          end().
        end().
      end();
      /*
      this.
        add(this.DAOCreateController.DATA,
            this.data.cls_.getAxiomsByClass(foam.core.Action))
            */
    }
  ],

  listeners: [
    function onFinished() {
      this.stack.back();
    }
  ]
});
/**
 * @license
 * Copyright 2017 The FOAM Authors. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

foam.CLASS({
  package: 'foam.comics',
  name: 'DAOUpdateController',

  topics: [
    'finished'
  ],

  properties: [
    {
      name: 'dao'
    },
    {
      name: 'data'
    },
    {
      name: 'obj',
      view: { class: 'foam.u2.DetailView', showActions: true },
      factory: function() {
        var self = this;
        this.dao.find(this.data).then(function(obj) {
          self.obj = obj.clone();
        });
        return null;
      }
    }
  ],

  actions: [
    function cancel() {
      this.finished.pub();
    },
    {
      name: 'save',
      isEnabled: function(obj) { return !! obj; },
      code: function() {
        var self = this;
        this.dao.put(this.obj.clone()).then(function() {
          self.finished.pub();
        }, function(e) {
          // TODO: Display error in view.
          console.error(e);
        });
      }
    },
    {
      name: 'delete',
      isEnabled: function(obj) { return !! obj; },
      confirmationRequired: true,
      code: function() {
        var self = this;
        this.dao.remove(this.obj).then(function() {
          self.finished.pub();
        }, function(e) {
          // TODO: Display error in view.
          console.error(e);
        });
      }
    }
  ]
});
/**
 * @license
 * Copyright 2017 The FOAM Authors. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

foam.CLASS({
  package: 'foam.comics',
  name: 'DAOUpdateControllerView',
  extends: 'foam.u2.View',

  requires: [
    'foam.comics.DAOUpdateController'
  ],

  imports: [
    'stack',
    'dao'
  ],

  exports: [
    'data'
  ],

  css: `
    ^ .net-nanopay-ui-ActionView {
      background: #59aadd;
      color: white;
      margin-right: 4px;
    }
    ^ .net-nanopay-ui-ActionView-delete {
      background: #d55;
    }
  `,

  properties: [
    {
      name: 'key'
    },
    {
      class: 'FObjectProperty',
      of: 'foam.comics.DAOUpdateController',
      name: 'data',
      factory: function() {
        return this.DAOUpdateController.create({
          data: this.key,
          dao: this.dao
        });
      }
    },
    {
      class: 'String',
      name: 'title',
      expression: function(data$dao$of) {
        return 'Edit ' + data$dao$of.name;
      }
    }
  ],

  reactions: [
    [ 'data', 'finished', 'onFinished' ]
  ],

  methods: [
    function initE() {
      /* Doesn't work because obj isn't known yet.
      this.startContext({data: this.data.obj})
        .add(this.data.dao.of.getAxiomsByClass(foam.core.Action))
      .endContext()
      */
      this.
      addClass(this.myCls()).
      start('table').
        start('tr').
          start('td').style({'vertical-align': 'top', 'width': '100%'}).
            start('span').
              style({background: 'rgba(0,0,0,0)'}).
              show(this.mode$.map(function(m) { return m == foam.u2.DisplayMode.RW; })).
              start().
                style({'padding-bottom': '4px'}).
                add(this.data.cls_.getAxiomsByClass(foam.core.Action)).
              end().
            end().
            add(this.DAOUpdateController.OBJ).
          end().
        end().
      end();
    }
  ],

  listeners: [
    function onFinished() {
      this.stack.back();
    }
  ]
});
/**
 * @license
 * Copyright 2017 The FOAM Authors. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

foam.CLASS({
  package: 'foam.comics',
  name: 'BrowserView',
  extends: 'foam.u2.View',

  requires: [
    'foam.comics.DAOController',
    'foam.comics.DAOControllerView'
  ],

  exports: [
    'controller as data',
    'summaryView'
  ],

  properties: [
    {
      name: 'data'
    },
    {
      name: 'title',
      expression: function(data$of) {
        return 'Browse ' + data$of.name;
      }
    },
    {
      name: 'controller',
      expression: function(data) {
        return this.DAOController.create({ data: data });
      }
    },
    {
      class: 'foam.u2.ViewSpec',
      name: 'summaryView',
      value: { class: 'foam.u2.view.ScrollTableView' },
      // TODO: remove next line when permanently fixed in ViewSpec
      fromJSON: function fromJSON(value, ctx, prop, json) { return value; }
    }
  ],

  methods: [
    function initE() {
      this
        .addClass(this.myClass())
        .addClass(this.myClass(this.data.of.id.replace(/\./g, '-')))
        .tag(this.DAOControllerView);
    }
  ]
});
/**
 * @license
 * Copyright 2017 The FOAM Authors. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

foam.CLASS({
  package: 'foam.comics',
  name: 'InlineBrowserView',
  extends: 'foam.comics.BrowserView',

  requires: [
    'foam.comics.InlineDAOControllerView as DAOControllerView'
  ]
});
/**
 * @license
 * Copyright 2017 The FOAM Authors. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

foam.CLASS({
  package: 'foam.comics',
  name: 'RelationshipView',
  extends: 'foam.comics.InlineBrowserView',
  
  properties: [
    {
      name: 'controller',
      expression: function(data) {
        return this.DAOController.create({
          data: data.dao,
          relationship: data
        });
      }
    }
  ]
});
/**
 * @license
 * Copyright 2017 The FOAM Authors. All Rights Reserved.
 * http://www.apache.org/licenses/LICENSE-2.0
 */

foam.CLASS({
  package: 'foam.u2.view',
  name: 'ReciprocalSearch',
  extends: 'foam.u2.Element', // TODO: make be a View

  requires: [
    'foam.u2.search.SearchManager'
  ],

  imports: [
    'dao'
  ],

  exports: [
    'as filterController',
    'as data'
  ],

  // TODO: CSS classname shouldn't be .net-nanopay-ui-ActionView, fix.
  css: `
    ^ {
      min-width: 180px;
      font-size: medium;
    }

    ^ input {
      font-size: medium;
    }

    ^count {
      font-size: 14pt;
      color: #555;
    }

    ^ .net-nanopay-ui-ActionView-clear {
      background: #59aadd;
      color: white;
      margin-top: 14px;
      padding: 12px;
      width: auto;
    }
  `,

  properties: [
    {
      class: 'Class',
      name: 'of'
    },
    {
      name: 'data'
    },
    {
      class: 'Array',
      name: 'filters',
      factory: null,
      expression: function(dao) {
        var of = dao && dao.of;

        if ( ! of ) return [];

        if ( of.model_.searchColumns )
          return of.model_.searchColumns;

        if ( of.model_.tableColumns )
          return of.model_.tableColumns.filter(function(c) {
            var axiom = of.getAxiomByName(c);
            return axiom && axiom.searchView;
          });

        return of.getAxiomsByClass(foam.core.Property)
            .filter(function(p) { return p.searchView && ! p.hidden })
            .map(foam.core.Property.NAME.f);
      }
    },
    {
      class: 'Int',
      name: 'selectedCount'
    },
    {
      class: 'Int',
      name: 'totalCount'
    },
  ],

  methods: [
    function initE() {
      var self = this;

      this.dao.on.sub(this.updateTotalCount);
      this.updateTotalCount();

      this.
        addClass(self.myClass()).
        add(this.slot(function(filters) {
          self.show(filters.length);

          var searchManager = self.SearchManager.create({
            dao$: self.dao$,
            predicate$: self.data$
          });

//          searchManager.filteredDAO.on.sub(self.updateSelectedCount);
          searchManager.filteredDAO$.sub(self.updateSelectedCount);
          self.updateSelectedCount(0,0,0,searchManager.filteredDAO$);

          var e = this.E('div');

          e.onDetach(searchManager);

          e.forEach(filters, function(f) {
            // TODO: See if this can be cleaned up somehow, if searchView didn't require the proprety explicitly, or
            // could find the search manager via the context and add itself to that.
            var axiom = self.dao.of.getAxiomByName(f);
            var spec  = axiom.searchView;
            var view  = foam.u2.ViewSpec.createView(spec, { property: axiom, dao: self.dao }, this, this.__subSubContext__);

            searchManager.add(view);
            this
              .start()
                .addClass(self.myClass('filter-header'))
                .add(axiom.label)
              .end()
              .start(view)
                .addClass(self.myClass('filter'))
              .end();
          });

          return e;
        }, this.filters$))
        .start()
          .addClass(self.myClass('count'))
          // TODO: move formatting function to stdlib
          .add(self.selectedCount$.map(function(a) { return a.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ","); }))
          .entity('nbsp')
          .add('of')
          .entity('nbsp')
          .add(self.totalCount$.map(function(a) { return a.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ","); }))
          .entity('nbsp')
          .add('selected')
        .end()
        .tag(this.CLEAR);
    },

    function addFilter(key) {
      this.filters = this.filters.concat(key);
    },

    function removeFilter(key) {
      this.filters = this.filters.filter(function(k) {
        return key !== k;
      });
    }
  ],

  actions: [
    {
      name: 'clear',
      code: function() {
        this.data = undefined;
        this.filters = this.filters.slice();
      }
    }
  ],

  /*
  reactions: [
    [ 'data', 'on', 'updateTotalCount' ]
  ],
  */

  listeners: [
    {
      name: 'updateTotalCount',
      isFramed: true,
      code: function() {
        this.dao.select(foam.mlang.sink.Count.create()).then(function(c) {
          this.totalCount = c.value;
        }.bind(this));
      }
    },
    {
      name: 'updateSelectedCount',
      isFramed: true,
      code: function(_, __, ___, dao) {
        dao.get().select(foam.mlang.sink.Count.create()).then(function(c) {
          this.selectedCount = c.value;
        }.bind(this));
      }
    }
  ]
});
/**
 * @license
 * Copyright 2016 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

foam.CLASS({
  package: 'foam.net',
  name: 'HTTPMethod',
  extends: 'foam.core.Method',

  documentation: `
  A method that is configured to call a service over HTTP.
  No code or function body is required here, as the actual body is generated to
  call the remote service. This will always return a promise that supplies the
  return value of the service call.

  <p>Overriding by an HTTPMethod is not supported. You can override an
  HTTPMethod with a normal one.
  `,

  requires: [
    'foam.net.HTTPArgument',
    'foam.core.Imports'
  ],

  constants: {
    OUTPUTTER: {
      __proto__: foam.json.Strict,
      outputDefaultValues: false,
      outputClassNames: false
    }
  },

  properties: [
    {
      /** The path prefix. Parameters may add to the path */
      name: 'path'
    },
    {
      name: 'httpMethod',
      value: 'GET',
    },
    {
      /** The args to call with, in order */
      class: 'FObjectArray',
      name: 'args',
      of: 'foam.net.HTTPArgument',
      factory: function() { return []; }
    },
    {
      /** If the request should build a request body object and fill in the
        supplied args, the request object's Class is specified here. */
      class: 'Class',
      name: 'buildRequestType',
    },
    {
      /** HTTPMethods will always return a Promise, but the Promise will pass
        along a parameter of the type specified here. */
      name: 'promisedType',
      of: 'foam.core.Argument'
    },
    [ 'returns', 'Promise' ],
    {
      /** The name of the HTTP factory to import at run time. Instances of
        HTTPMethod on a class will cause the class to import this name, and
        when called will call hostInstance.yourHttpFactoryName.create() to
        create a partially filled request object. */
      name: 'HTTPRequestFactoryName',
      value: 'HTTPRequestFactory'
    },
    {
      name: 'code',
      required: false,
      transient: true,
      expression: function(args) {
        // set up function with correct args, pass them into the
        // actual implementation, callRemote_()
        var axiom = this;
        // Get list of argument names
        var argNames = args.map(axiom.HTTPArgument.NAME.f);
        // load named values into opt_args object and pass to the generic callRemote_()
        return function() {
          var opt_args = {};
          for ( var i = 0; i < arguments.length && i < argNames.length; i ++ ) {
            opt_args[argNames[i]] = arguments[i];
          }
          return axiom.callRemote_(opt_args, this);
        }

      }
    }
  ],

  methods: [
    function installInClass(c) {
      // add an import for the HTTPRequestFactory on our host class

      // May have many HTTPMethods in a host class, but only do service import once.
      var existing = c.getAxiomByName(this.HTTPRequestFactoryName);
      foam.assert( existing,
        "HTTPMethod installInClass did not find an import or property", this.HTTPRequestFactoryName, ".",
        "Provide one, or set HTTPMethod.HTTPRequestFactoryName to the name of your request factory function.");
    },

    function installInProto(p) {
      // set code on proto
      p[this.name] = this.code;
    },

    function callRemote_(opt_args, host) {
      foam.assert( typeof host[this.HTTPRequestFactoryName] === 'function',
        "HTTPMethod call can't find HTTPRequestFactory",
        this.HTTPRequestFactoryName, "on", host);

      // 'this' is the axiom instance
      var self = this;
      var path = this.path;
      var query = "";
      var request = host[this.HTTPRequestFactoryName]();

      // if building a request object, start with an empty instance
      var requestObject = self.buildRequestType ?
        self.buildRequestType.create(undefined, foam.__context__) : null;

      // add on args passed as part of the path or query
      self.args.forEach(function(param) {
        var val = opt_args[param.name];
        if ( typeof val === 'undefined' ) return; // skip missing args // TODO: assert non-optional

        // put the dot back if we removed one from the name
        var pname = param.name.replace('__dot__','.');
        if ( param.location === 'body' ) {
          // set the request body content
          // TODO: assert it's the first param, no more than one body
          if ( requestObject ) {
            throw "Can't set both RequestObject " +
              self.buildRequestType + " and param.location==body for " + pname;
          }
          request.payload = self.OUTPUTTER.stringify(val);
        } else if ( param.location === 'path' ) {
          // find the placeholder and replace it
          path = path.replace("{"+pname+"}", val.toString());
          if ( requestObject ) requestObject[pname] = val;
        } else if ( param.location === 'query' ) {
          // add to query string
          query += "&" + pname + "=" + val.toString();
          if ( requestObject ) requestObject[pname] = val;
        }
      });
      path = path + ( query ? "?" + query.substring(1) : "" );
      request.path += path;
      request.method = self.httpMethod;
      if ( requestObject ) {
        request.payload = self.OUTPUTTER.stringify(requestObject);
      }

      return request.send().then(function(response) {
        if ( response.status >= 400 ) {
          throw "HTTP error status: " + response.status;
        }
        foam.assert(response.responseType === 'json', "HTTPMethod given a request not configured to return JSON", request);
        return response.payload.then(function(json) {
          if ( ! self.promisedType ) {
            // no return
            return;
          }
          if ( ! self.promisedType.type ) { // TODO: should not need this check. Getter in Arg.type?
            self.promisedType.type = this.lookup(self.promisedType.typeName, true);
          }
          if ( self.promisedType.type ) {
            // a modelled return type
            return self.promisedType.type.create(json, host);
          }
          // else return raw json
          return json;
        });
      });
    }
  ]
});


foam.CLASS({
  package: 'foam.net',
  name: 'HTTPArgument',
  extends: 'foam.core.Argument',

  properties: [
    {
      /** The location to put this value in the request: 'query', 'path', or 'body' */
      name: 'location',
      value: 'query',
    }
  ]
});
/**
 * @license
 * Copyright 2016 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

(function() {
  var pkg = 'foam.net.' + (foam.isServer ? 'node' : 'web');
  var clss = [
    'BaseHTTPRequest',
    'HTTPRequest',
    'HTTPResponse',
    'WebSocket',
    'WebSocketService'
  ];

  // For each class with a "web" (browser) and "node" (Node JS)
  // implementation, register "foam.net.[environment].[class]" as
  // "foam.net.[class]".
  //
  // TODO: This should be provided via a sort of "ContextFactory" or similar.
  for ( var i = 0; i < clss.length; i++ ) {
    foam.register(foam.lookup(pkg + '.' + clss[i]), 'foam.net.' + clss[i]);
  }
})();
/**
 * @license
 * Copyright 2017 The FOAM Authors. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

foam.CLASS({
  package: 'foam.net',
  name: 'RetryHTTPRequest',
  extends: 'foam.net.BaseHTTPRequest',

  documentation: `HTTP request for retrying requests that fail at the service
      level; e.g., network timeout, connection reset. This class does not check
      HTTP status codes, it simply retries requests that reject-on-send().`,

  requires: [ 'foam.net.BaseHTTPRequest' ],
  imports: [ 'error', 'warn' ],

  properties: [
    {
      class: 'Int',
      name: 'numTries',
      value: 4
    },
    {
      class: 'Proxy',
      of: 'foam.net.BaseHTTPRequest',
      name: 'delegate',
      factory: function() {
        return this.BaseHTTPRequest.create(this);
      }
    },
    {
      class: 'Int',
      name: 'currentTry_'
    }
  ],

  methods: [
    function send() {
      return this.delegate.send().catch(this.onError);
    }
  ],

  listeners: [
    function onError(error) {
      this.currentTry_++;
      this.warn('RetryHTTPRequest: Try #' + this.currentTry_ +
                ' failed on ' + error);
      if ( this.currentTry_ < this.numTries ) {
        return this.send();
      } else {
        this.error('RetryHTTPRequest: Max tries reached');
        throw new Error('RetryHTTPRequest: Max tries reached');
      }
    }
  ]
});
/**
 * @license
 * Copyright 2017 The FOAM Authors. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

foam.CLASS({
  package: 'foam.net.auth',
  name: 'TokenBearerCredential',

  documentation: `Data class for "Authorization: Bearer <access token>"-style
      authentication.`,

  properties: [
    {
      class: 'String',
      documentation: `Token used for "Authorization: Bearer <token>"-style HTTP
          request authentication.`,
      name: 'accessToken'
    },
    {
      class: 'Int',
      documentation: `date.getTime()-style time stamp of "accessToken"
          expiration.`,
      name: 'expiry'
    }
  ]
});
/**
 * @license
 * Copyright 2017 The FOAM Authors. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

foam.CLASS({
  package: 'foam.net.auth',
  name: 'AuthAwareHTTPRequest',
  extends: 'foam.net.BaseHTTPRequest',

  documentation: 'Abstract class for HTTP requests that require authorization.',

  requires: [ 'foam.net.BaseHTTPRequest' ],
  imports: [ 'authAgent? as ctxAuthAgent' ],

  properties: [
    {
      class: 'Proxy',
      of: 'foam.net.BaseHTTPRequest',
      name: 'delegate',
      factory: function() {
        return this.BaseHTTPRequest.create(this);
      }
    },
    {
      class: 'FObjectProperty',
      of: 'foam.net.auth.AuthAgent',
      name: 'authAgent',
      factory: function() { return this.ctxAuthAgent || null; }
    }
  ],

  methods: [
    function send() {
      var send = this.delegate.send.bind(this.delegate);
      if ( ! this.authAgent ) return send();
      if ( ! this.authAgent.requiresAuthorization(this) ) return send();

      return this.authAgent.getCredential().then(this.onGetCredential)
          .then(send).then(this.onAuthorizedResponse);
    }
  ],

  listeners: [
    {
      name: 'onGetCredential',
      documentation: 'Prepare request using credential from "authAgent".',
      code: function() {
        throw new Error("Abstract AuthAwareHTTPRequest doesn't understand " +
            'credentials');
      }
    },
    {
      name: 'onAuthorizedResponse',
      documentation: `Check response on authorized request for HTTP 401, in
          which case, retry.`,
      code: function(response) {
        if ( response.status !== 401 ) return response;

        var send = this.delegate.send.bind(this.delegate);
        return this.authAgent.refreshCredential().then(this.onGetCredential)
            .then(send).then(this.onRetryResponse);
      }
    },
    {
      name: 'onRetryResponse',
      documentation: `Check response on authorized request for HTTP 401, in
          which case, throw: forced  credential refresh didn't work.`,
      code: function(response) {
        if ( response.status !== 401 ) return response;

        throw new Error('Authorization failed: Request rejected after forced credential refresh');
      }
    }
  ]
});
/**
 * @license
 * Copyright 2017 The FOAM Authors. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

foam.CLASS({
  package: 'foam.net.auth',
  name: 'TokenBearerHTTPRequest',
  extends: 'foam.net.auth.AuthAwareHTTPRequest',

  documentation: `Auth-aware HTTP request that uses the TOKEN_BEARER
      CredentialType for "Authorization: Bearer <access token>"-style
      authorization.`,

  listeners: [
    function onGetCredential(credential) {
      this.delegate.headers['Authorization'] =
          'Bearer ' + credential.accessToken;
    }
  ]
});
/**
 * @license
 * Copyright 2017 The FOAM Authors. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

foam.CLASS({
  package: 'foam.net.auth',
  name: 'AuthAgent',

  documentation: `An agent that is able to authenticate on application's behalf
      for HTTP requests that require authorization. Implementations must do the
      following:

      (0) Export self as "authAgent" (already done in base class);
      (1) Register an auto-authenticating HTTPRequest as 'foam.net.HTTPRequest'
          in agents' sub-contexts;
      (2) Implement getCredential() and refreshCredential().

      Clients instantiating agents must provide a requiresAuthorization(request)
      implementation; this allows authenticating HTTPRequests to determine
      whether or not to authenticate before attempting a request.`,

  exports: [ 'as authAgent' ],

  properties: [
    {
      class: 'Function',
      documentation: `Determine whether or not a URL requires authorization
          via an authentication step managed by this agent. This procedure is
          treated as data rather than a method because it is typically injected
          for an agent at runtime. E.g., a particular Google 2LO agent would be
          bound to particular URLs and particular scopes.`,
      name: 'requiresAuthorization',
      required: true
    },
  ],

  methods: [
    function init() {
      this.validate();
      this.SUPER();
    },
    function validate() {
      this.SUPER();
      foam.assert(
          this.__context__.lookup('foam.net.BaseHTTPRequest') !==
              this.__subContext__.lookup('foam.net.HTTPRequest'),
          'AuthAgent implementation must register its HTTPRequest decorator ' +
              'as foam.net.HTTPRequest');
    },
    {
      name: 'getCredential',
      documentation: 'Aynchronously get an unexpired credential.',
      code: function() {
        return Promise.reject(new Error('Unable to get credential'));
      }
    },
    {
      name: 'refreshCredential',
      documentation: 'Aynchronously get a new credential.',
      code: function() {
        return Promise.reject(new Error('Unable to refresh credential'));
      }
    }
  ]
});
/**
 * @license
 * Copyright 2017 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

//
// Refine stdlib types to implement toDatastoreValue(o).
//

foam.LIB({
  name: 'foam.Undefined',

  methods: [
    function toDatastoreValue() {
      throw new Error('Attempt to use undefined as datastore value');
    }
  ]
});

foam.LIB({
  name: 'foam.Null',

  methods: [
    {
      name: 'toDatastoreValue',
      code: (function() {
        var NULL = { nullValue: null };
        return function toDatastoreValue() { return NULL; };
      })()
    },
    function fromDatastoreValue() {
      return null;
    }
  ]
});

foam.LIB({
  name: 'foam.Boolean',

  methods: [
    {
      name: 'toDatastoreValue',
      code: (function() {
        var TRUE = { booleanValue: true };
        var FALSE = { booleanValue: false };
        return function toDatastoreValue(b) { return b ? TRUE : FALSE; };
      })()
    },
    function fromDatastoreValue(v) {
      return v.booleanValue;
    }
  ]
});

foam.LIB({
  name: 'foam.Function',

  methods: [
    function toDatastoreValue(f) { return { stringValue: f.toString() }; }
  ]
});

foam.LIB({
  name: 'foam.Number',

  methods: [
    function toDatastoreValue(n) {
      return Number.isInteger(n) ? { integerValue: n.toString(10) } :
          { doubleValue: n };
    },
    function fromDatastoreValue(v) {
      if ( v.value_type === 'doubleValue' || v.integerValue === undefined ) {
        foam.assert(v.doubleValue !== undefined,
                    'Non-integer number expects doubleValue');
        return v.doubleValue;
      }

      return parseInt(v.integerValue);
    }
  ]
});

foam.LIB({
  name: 'foam.String',

  methods: [
    function toDatastoreValue(s) { return { stringValue: s }; },
    function fromDatastoreValue(v) { return v.stringValue; }
  ]
});

foam.LIB({
  name: 'foam.Array',

  methods: [
    function toDatastoreValue(a) {
      var values = new Array(a.length);
      for ( var i = 0; i < a.length; i++) {
        values[i] = com.google.cloud.datastore.toDatastoreValue(a[i]);
      }
      return { arrayValue: { values: values } };
    },
    function fromDatastoreValue(v, opt_ctx) {
      var values = v.arrayValue.values || [];
      var arr = new Array(values.length);
      for ( var i = 0; i < values.length; i++ ) {
        arr[i] = com.google.cloud.datastore.fromDatastoreValue(
            values[i], opt_ctx);
      }
      return arr;
    }
  ]
});

foam.LIB({
  name: 'foam.Date',

  methods: [
    function toDatastoreValue(d) {
      return { timestampValue: d.toISOString() };
    },
    function fromDatastoreValue(v) {
      var tv = v.timestampValue;
      if ( typeof tv === 'string' )
        return new Date(Date.parse(tv));

      var seconds = parseInt(tv.seconds);
      var nanos = tv.nanos;
      foam.assert( ! isNaN(seconds),
                   'Expected non-string Datastore timestampValue to contain: ' +
                   '{ seconds: "<seconds-since-epoch>", nanos: <nanos> }');

      return new Date( ( seconds * 1000 ) + Math.floor(nanos / 1000000) );
    }
  ]
});

(function() {
  var MultiPartID = foam.core.MultiPartID;

  foam.LIB({
    name: 'foam.core.FObject',

    methods: [
      function toDatastoreValue(o) { return o.toDatastoreValue(); },
      function fromDatastoreValue(v, opt_ctx) {
        return this.fromDatastoreEntity(v.entityValue, opt_ctx);
      },
      function fromDatastoreEntity(entity, opt_ctx) {
        var keys = entity.key.path;
        var key = keys[keys.length - 1];
        var cls = foam.lookup(key.kind);
        var id = key.name;
        var idProp = cls.ids && cls.ids.length === 1 ?
            cls.getAxiomByName(cls.ids[0]) :
            cls.getAxiomByName('id');
        var opts = {};

        if ( idProp && ! MultiPartID.isInstance(idProp) )
          opts[idProp.name] = idProp.fromDatastoreKeyName(id);

        var props = entity.properties;
        for ( var name in props ) {
          if ( props.hasOwnProperty(name) ) {
            opts[name] = com.google.cloud.datastore.fromDatastoreValue(
                props[name], opt_ctx);
          }
        }

        return cls.create(opts, opt_ctx);
      },
      function getOwnClassDatastoreKind() {
        return this.id;
      },
      function getClassDatastoreKind() {
        return { name: this.getOwnClassDatastoreKind() };
      }
    ]
  });
})();

//
// Provide base to/from datastore value operations.
//

foam.LIB({
  name: 'com.google.cloud.datastore',

  methods: [
    function toDatastoreValue(o) {
      var t = foam.typeOf(o);
      if ( ! ( t && t.toDatastoreValue ) ) {
        throw new Error('Attempt to compute datastore value from ' +
            'incompatible type');
      }

      return t.toDatastoreValue(o);
    },
    function fromDatastoreValue(v, opt_ctx) {
      return this.typeOfDatastoreValue(v).fromDatastoreValue(v, opt_ctx);
    },
    function fromDatastoreEntity(v, opt_ctx) {
      return foam.core.FObject.fromDatastoreEntity(v, opt_ctx);
    },
    {
      name: 'typeOfDatastoreValue',
      documentation: function() {/*
                                   Determine the primitive type of Value from
                                   Google Cloud Datastore REST API. These
                                   values are objects with one key denoting
                                   their Datastore representation; e.g.,
                                   "booleanValue", "integerValue", etc..

                                   https://cloud.google.com/datastore/docs/reference/rest/v1/projects/runQuery#value
                                  */},
      code: (function() {
        var typeMap = {
          nullValue: foam.Null,
          booleanValue: foam.Boolean,
          integerValue: foam.Number,
          doubleValue: foam.Number,
          timestampValue: foam.Date,
          stringValue: foam.String,
          arrayValue: foam.Array,
          entityValue: foam.core.FObject
        };
        return function typeOfDatastoreValue(v) {
          if ( v.hasOwnProperty('value_type') ) {
            foam.assert(typeMap[v.value_type],
                        'Expected datastore value with "value_type" to have ' +
                        'known type; value_type = ' + v.value_type);
            return typeMap[v.value_type];
          }
          for ( var key in v ) {
            if ( typeMap[key] && v.hasOwnProperty(key) ) return typeMap[key];
          }

          throw new Error('Failed to identify type of datastore value: ' +
              JSON.stringify(v));
        };
      })()
    },
    {
      name: 'toDatastoreKeyName',
      code: foam.mmethod({
        Number: function(n) { return n + ''; },
        String: function(str) { return str; },
        FObject: function(o) {
          var idProp = o.cls_.ID;
          if ( ! idProp ) {
            throw new Error('Attempt to construct datastore key from ' +
                'unidentified object');
          }
          return idProp.toDatastoreKeyName(o);
        },
        Array: function(a) {
          throw new Error('Multi-part keys must be derived from objects, not values');
        },
        Object: function(o) {
          throw new Error('Cannot convert plain object to datastore key name');
        }
      }, function(o) {
        throw new Error('Cannot convert ' + o + ' to datastore key name');
      })
    }
  ]
});

//
// Refine properties and multi-part ids to support conversion:
// property-on-object => datastore-key-name
//

foam.CLASS({
  refines: 'foam.core.Property',

  methods: [
    {
      name: 'toDatastoreKeyName',
      documentation: `Construct a Datastore Key PathElement "name" from this
        property. I.e.,
        https://cloud.google.com/datastore/docs/reference/rest/v1/Key#PathElement
        "name" property.`,
      code: function(o) {
        return this.toDatastoreKeyNamePart(o);
      }
    },
    {
      name: 'toDatastoreKeyNamePart',
      documentation: `Provide this property's contribution to a composite
        Datastore Key PathElement "name" from this property. This is used by
        MultiPartIDs to gather string fragments from multiple properies. See
        https://cloud.google.com/datastore/docs/reference/rest/v1/Key#PathElement
        "name" property for Datastore API usage details.`,
      code: function(o) {
        return this.f(o).toString();
        return this.toDatastoreKeyNamePart(o);
      }
    }
  ]
});

foam.CLASS({
  refines: 'foam.core.Date',

  methods: [
    function toDatastoreKeyNamePart(o) {
      return this.f(o).toISOString();
    }
  ]
});

foam.CLASS({
  refines: 'foam.core.MultiPartID',

  properties: [
    {
      class: 'String',
      name: 'stringSeparator',
      value: ':'
    }
  ],

  methods: [
    function toDatastoreKeyName(o) {
      var sep = this.stringSeparator;
      var props = this.props;
      var str = '';
      for ( var i = 0; i < props.length; i++ ) {
        str += props[i].toDatastoreKeyNamePart(o);
        if ( i !== props.length - 1 ) str += sep;
      }
      return str;
    },
    function fromDatastoreKeyName(name) {
      return name.split(this.stringSeparator);
    }
  ]
});

//
// Refine Enum values to output integer: enumValue.ordinal.
//

foam.CLASS({
  refines: 'foam.core.AbstractEnum',

  methods: [
    function toDatastoreValue() {
      return { integerValue: this.ordinal };
    }
  ]
});

//
// Refine foam.core.FObject to support datastore's:
// (1) "kinds" (i.e., types);
// (2) "keys" (i.e., <type, name|auto-generated-id> pairs);
// (3) "entities" (i.e., objects);
// (4) "values" (i.e., primitives or entities).
//

foam.CLASS({
  refines: 'foam.core.FObject',

  methods: [
    function getOwnDatastoreKind() {
      return this.cls_.getOwnClassDatastoreKind();
    },
    function getDatastoreKind() {
      return this.cls_.getClassDatastoreKind();
    },
    function getOwnDatastoreKey() {
      return {
        kind: this.getOwnDatastoreKind(),
        name: com.google.cloud.datastore.toDatastoreKeyName(this)
      };
    },
    function getDatastoreKey(partitionId, opt_propertyPath) {
      if ( ! opt_propertyPath ) {
        return {
          partitionId: partitionId,
          path: [ this.getOwnDatastoreKey() ]
        };
      }

      var o = this;
      var path = new Array(opt_propertyPath.length + 1);

      path[0] = this.getOwnDatastoreKey();

      for ( var i = 0; i < opt_propertyPath.length; i++ ) {
        var next = opt_propertyPath[i];
        var o = ( typeof next === 'string' ) ? o[next] : next.f(o);

        if ( ! foam.core.FObject.isInstance(o) ) {
          throw new Error('Attempt to get datastore key from non-keyable ' +
              'object');
        }

        path[i + 1] = o.getOwnDatastoreKey();
      }

      return { partitionId: partitionId, path: path };
    },
    function toDatastoreEntity(partitionId) {
      var properties = {};
      var ps = this.cls_.getAxiomsByClass(foam.core.Property);

      for ( var i = 0; i < ps.length; i++ ) {
        // TODO(markdittmer): MLangs that refer to storageTransient
        // properties could cause the DatastoreDAO to misbehave. This could be
        // fixed by auditing predicates and throwing an error when they contain
        // properties that are dropped by the DAO processing the predicate.
        if ( ps[i].storageTransient ) continue;

        var value = ps[i].f(this);
        properties[ps[i].name] = com.google.cloud.datastore.toDatastoreValue(
            value);
      }

      return { key: this.getDatastoreKey(partitionId), properties: properties };
    },
    function toDatastoreValue() {
      return { entityValue: this.toDatastoreEntity() };
    },
    function fromDatastoreKeyName(name) { return name; }
  ]
});
/**
 * @license
 * Copyright 2017 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

//
// Refine COUNT to perform two optimizations:
// (1) Perform a key-only query when the sink is a COUNT;
// (2) Do not bother construction FObjects on query result batches.
//

foam.CLASS({
  refines: 'foam.mlang.sink.Count',

  methods: [
    {
      name: 'decorateDatastoreQuery',
      documentation: `Optimize plain COUNT() queries by requesting keys only.
          This entails filling in runQuery.projection [1] with the magic
          "__key__" key.

          [1] https://cloud.google.com/datastore/docs/reference/rest/v1/projects/runQuery#Projection`,
      code: function(query) {
        query.projection = [ { property: { name: "__key__" } } ];
      }
    },
    {
      name: 'fromDatastoreEntityResults',
      documentation: `Optimize plain COUNT() queries by not constructing
          FObjects to store results. Input paramter is
          QueryResultBatch.entityResults [1].

          [1] https://cloud.google.com/datastore/docs/reference/rest/v1/projects/runQuery#QueryResultBatch`,
      code: function(entityResults) { this.value += entityResults.length; }
    }
  ]
});

//
// Refine Property and DOT to produce datastore property.
//

foam.CLASS({
  refines: 'foam.core.Property',

  methods: [
    {
      name: 'toDatastorePropertyReference',
      documentation:
      function() {/*
                    Provides a PropertyReference for the Cloud Datastore REST
                    API.
                    https://cloud.google.com/datastore/docs/reference/rest/v1/projects/runQuery#PropertyReference
                  */},
      code: function() { return { name: this.name }; }
    }
  ]
});


foam.CLASS({
  refines: 'foam.mlang.expr.Dot',

  methods: [
    {
      name: 'toDatastorePropertyReference',
      code: function() {
        return { name: this.arg1.name + '.' + this.arg2.name };
      }
    }
  ]
});


//
// Refine constants to produce datastore values. This is needed because
// mLangs will attempt to access datastore values on the arguments.
//

foam.CLASS({
  refines: 'foam.mlang.Constant',

  methods: [
    {
      name: 'toDatastoreValue',
      documentation:
      function() {/*
                    Provides Value for the Cloud Datastore REST API.
                    https://cloud.google.com/datastore/docs/reference/rest/v1/projects/runQuery#Value
                  */},
      code: function() {
        return com.google.cloud.datastore.toDatastoreValue(this.value);
      }
    }
  ]
});


//
// Refine AND and subset of binary ops to support toDatastoreFilter().
//

foam.CLASS({
  refines: 'foam.mlang.predicate.AbstractPredicate',

  methods: [
    {
      name: 'toDatastoreFilter',
      documentation:
      function() {/*
                    Provides Filter for the Cloud Datastore REST API.
                    https://cloud.google.com/datastore/docs/reference/rest/v1/projects/runQuery#filter
                  */},
      code: function() {
        throw new Error('Predicate not supported in datastore ' +
            'implementation: ' + this.cls_.id);
      }
    }
  ]
});


foam.CLASS({
  refines: 'foam.mlang.predicate.And',

  methods: [
    {
      name: 'toOwnDatastoreFilter',
      documentation:
      function() {/*
                    Provides (CompositeFilter|PropertyFilter) for a Filter in
                    the Cloud Datastore REST API.
                    https://cloud.google.com/datastore/docs/reference/rest/v1/projects/runQuery#filter
                  */},
      code: function() {
        var filters = new Array(this.args.length);

        for ( var i = 0; i < this.args.length; i++ ) {
          filters[i] = this.args[i].toDatastoreFilter();
        }

        return { op: 'AND', filters: filters };
      }
    },

    function toDatastoreFilter() {
      return { compositeFilter: this.toOwnDatastoreFilter() };
    }
  ]
});


foam.CLASS({
  refines: 'foam.mlang.predicate.Binary',

  properties: [
    {
      class: 'String',
      documentation: `Provides Operator for the Cloud Datastore REST API.
          https://cloud.google.com/datastore/docs/reference/rest/v1/projects/runQuery#Operator_1`,
      name: 'datastoreOpName'
    }
  ],

  methods: [
    function toOwnDatastoreFilter() {
      foam.assert(foam.core.Property.isInstance(this.arg1),
          'Left-hand-side of datastore binary op is not a property');
      foam.assert(this.datastoreOpName,
          'Predicate has no datastore op name:', this.cls_.id);

      return {
        property: this.arg1.toDatastorePropertyReference(),
        op: this.datastoreOpName,
        value: com.google.cloud.datastore.toDatastoreValue(this.arg2)
      };
    },

    function toDatastoreFilter() {
      return { propertyFilter: this.toOwnDatastoreFilter() };
    }
  ]
});


//
// Use above Binary implementation on Google Cloud Datastore-supported
// predicates by refining them with a particular "datastoreOpName" value.
//

foam.CLASS({refines: 'foam.mlang.predicate.Eq',  properties: [ {class: 'String', name: 'datastoreOpName', value: 'EQUAL' }] });
foam.CLASS({refines: 'foam.mlang.predicate.Lt',  properties: [ {class: 'String', name: 'datastoreOpName', value: 'LESS_THAN' }] });
foam.CLASS({refines: 'foam.mlang.predicate.Lte', properties: [ {class: 'String', name: 'datastoreOpName', value: 'LESS_THAN_OR_EQUAL' }] });
foam.CLASS({refines: 'foam.mlang.predicate.Gt',  properties: [ {class: 'String', name: 'datastoreOpName', value: 'GREATER_THAN' }] });
foam.CLASS({refines: 'foam.mlang.predicate.Gte', properties: [ {class: 'String', name: 'datastoreOpName', value: 'GREATER_THAN_OR_EQUAL' }] });


//
// Refine properties and ThenBy mLang to behave as orderings.
//

foam.CLASS({
  refines: 'foam.core.Property',

  methods: [
    {
      name: 'toDatastoreOrder',
      documentation:
      function() {/*
                    Provides PropertyOrder for the Cloud Datastore REST API.
                    https://cloud.google.com/datastore/docs/reference/rest/v1/projects/runQuery#propertyorder
                  */},
      code: function(opt_orderDirection) {
        var orderDirection = opt_orderDirection || 1;
        return orderDirection === 1 ?
            [ { property: { name: this.name } } ] :
            [ { property: { name: this.name }, direction: 'DESCENDING' } ];
      }
    }
  ]
});


foam.CLASS({
  refines: 'foam.mlang.order.Desc',

  methods: [
    function toDatastoreOrder(opt_orderDirection) {
      var orderDirection = -1 * (opt_orderDirection || 1);
      return this.arg1.toDatastoreOrder(orderDirection);
    }
  ]
});


foam.CLASS({
  refines: 'foam.mlang.order.ThenBy',

  methods: [
    function toDatastoreOrder(opt_orderDirection) {
      var order1 = this.arg1.toDatastoreOrder(opt_orderDirection);
      var order2 = this.arg2.toDatastoreOrder(opt_orderDirection);
      return order1.concat(order2);
    }
  ]
});
/**
 * @license
 * Copyright 2017 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

foam.CLASS({
  package: 'com.google.cloud.datastore',
  name: 'SelectData',

  documentation: `State passed around by intermediate callbacks during a
      select() in progress. These data must be retained to notify the sink, send
      the correct payload to subsequent API calls, and return results in the
      Promise.`,

  properties: [
    {
      name: 'ctx'
    },
    {
      name: 'sink'
    },
    {
      name: 'requestPayload'
    },
    {
      class: 'Array',
      name: 'results'
    },
    {
      class: 'Boolean',
      name: 'halted'
    },
    {
      name: 'sub',
      factory: function() {
        var sub = foam.core.FObject.create();
        sub.onDetach(function() { this.halted = true; }.bind(this));
        return sub;
      }
    }
  ]
});

foam.CLASS({
  package: 'com.google.cloud.datastore',
  name: 'DatastoreDAO',
  extends: 'foam.dao.AbstractDAO',

  documentation: `DAO implementation for the Google Cloud Datastore v1 REST API.

      https://cloud.google.com/datastore/docs/reference/rest/

      This implementation uses structured queries, not GQL queries.`,

  requires: [
    'com.google.cloud.datastore.SelectData',
    'foam.dao.ArraySink',
    'foam.net.HTTPRequest'
  ],
  imports: [
    'gcloudProjectId?',
    'datastoreNamespaceId?'
  ],

  constants: {
    INT32_MAX: Math.pow(2, 31) - 1
  },

  properties: [
    {
      class: 'String',
      name: 'projectId',
      factory: function() {
        foam.assert(this.gcloudProjectId, 'DatastoreDAO missing ' +
            '"gcloudProjectId" from context or "projectId" on construction');
        return this.gcloudProjectId;
      },
      final: true
    },
    {
      class: 'String',
      name: 'namespaceId',
      factory: function() {
        return this.datastoreNamespaceId || '';
      },
      final: true
    },
    {
      class: 'String',
      name: 'protocol',
      value: 'https',
      final: true
    },
    {
      class: 'String',
      name: 'host',
      value: 'datastore.googleapis.com',
      final: true
    },
    {
      class: 'Int',
      name: 'port',
      value: 443,
      final: true
    },
    {
      class: 'String',
      name: 'baseURL',
      factory: function() {
        return this.protocol + '://' + this.host + ':' + this.port +
            '/v1/projects/' + this.projectId;
      }
    },
    {
      name: 'partitionId_',
      factory: function() {
        return this.namespaceId ?
            { projectId: this.projectId, namespaceId: this.namespaceId } :
            { projectId: this.projectId };
      }
    }
  ],

  methods: [
    function sendRequest(name, objPayload) {
      return this.getRequest(name, objPayload && JSON.stringify(objPayload))
          .send();
    },
    function getRequest(name, payload) {
      var headers = { Accept: 'application/json' };
      if ( payload ) headers['Content-Type'] = 'application/json';
      return this.HTTPRequest.create({
        method: 'POST',
        url: this.baseURL + ':' + name,
        headers: headers,
        responseType: 'json',
        payload: payload
      });
    },

    function find_(x, idOrObj) {
      var key = foam.core.FObject.isInstance(idOrObj) ?
          idOrObj.getDatastoreKey(this.partitionId_) :
          this.getDatastoreKeyFromId_(idOrObj, this.partitionId_);
      return this.sendRequest('lookup', { keys: [ key ] })
          .then(this.onResponse.bind(this, 'find'))
          .then(this.onFindResponse.bind(this, x));
    },
    function put_(x, o) {
      return this.sendRequest('commit', {
        mode: 'NON_TRANSACTIONAL',
        mutations: [ { upsert: o.toDatastoreEntity(this.partitionId_) } ]
      }).then(this.onResponse.bind(this, 'put'))
          .then(this.onPutResponse.bind(this, x, o));
    },
    function remove_(x, o) {
      return this.sendRequest('commit', {
        mode: 'NON_TRANSACTIONAL',
        mutations: [ { delete: o.getDatastoreKey(this.partitionId_) } ]
      }).then(this.onResponse.bind(this, 'remove'))
          .then(this.onRemoveResponse.bind(this, x, o));
    },
    function select_(x, sink, skip, limit, order, predicate) {
      sink = sink || this.ArraySink.create();
      var payload = { query: { kind: [
        this.of.getClassDatastoreKind()
      ] } };
      var query = payload.query;
      payload.partitionId = this.partitionId_;
      if ( predicate ) query.filter = predicate.toDatastoreFilter();
      if ( order ) query.order = order.toDatastoreOrder();
      if ( skip ) query.offset = Math.min(skip, this.INT32_MAX);
      if ( limit ) query.limit = Math.min(limit, this.INT32_MAX);
      // Optional Sink interface extension:
      // Allow datastore-aware sinks to decorate query.
      if ( sink.decorateDatastoreQuery )
        sink.decorateDatastoreQuery(query);

      return this.sendRequest('runQuery', payload)
          .then(this.onResponse.bind(this, 'select'))
          .then(this.onSelectResponse.bind(
              this, this.SelectData.create({
                ctx: x,
                sink: sink,
                requestPayload: payload
              })));
    },
    function removeAll_(x, skip, limit, order, predicate) {
      return this.select_(x, undefined, skip, limit, order, predicate)
          .then(this.onRemoveAll);
    },

    {
      name: 'getDatastoreKeyFromId_',
      documentation: `Helper for find() to construct the appropriate :lookup
        Datastore query.`,
      code: function(id, partitionId) {
        return {
          partitionId: partitionId,
          path: [ {
            kind: this.of.getOwnClassDatastoreKind(),
            name: com.google.cloud.datastore.toDatastoreKeyName(id)
          } ]
        };
      }
    },
    {
      name: 'selectNextBatch_',
      documentation: `Massage data.query and re-issue Datastore :runQuery to get
        the next batch of results requested by select().`,
      code: function(data, batch) {
        var payload = data.requestPayload;
        var query = payload.query;

        payload.partitionId = this.partitionId_;

        // Update query to get next batch of results.
        if ( query.offset )
          query.offset = query.offset - ( batch.skippedResults || 0 );
        if ( query.limit ) {
          query.limit = query.limit -
              ( batch.entityResults ? batch.entityResults.length : 0 );
        }
        query.startCursor = batch.endCursor;

        return this.sendRequest('runQuery', payload)
            .then(this.onResponse.bind(this, 'select'))
            .then(this.onSelectResponse.bind(this, data));
      }
    },
    {
      name: 'resultsAreIncomplete_',
      documentation: `Determine whether or not a batch contains the last results
        in a (potentially "limit"ed) query result. Abstracted out of
        onSelectResponse() to support faked batching in tests.`,
      code: function(batch, data) {
        return ( ! data.halted ) && batch.entityResults &&
            batch.entityResults.length > 0 &&
            ( batch.moreResults === 'NOT_FINISHED' ||
              batch.moreResults === 'MORE_RESULTS_AFTER_CURSOR' );
      }
    }
  ],

  listeners: [
    function onRemoveAll(arraySink) {
      var arr = arraySink.array;
      if ( arr.length === 0 ) return undefined;

      return this.sendRequest('beginTransaction')
          .then(this.onResponse.bind(this, 'removeAll transaction'))
          .then(this.onRemoveAllTransactionResponse.bind(this, arr));
    },

    function onResponse(name, response) {
      if ( response.status !== 200 ) {
        return response.payload.then(function(payload) {
          throw new Error('Unexpected ' + name + ' response code from Cloud ' +
              'Datastore endpoint: ' + response.status + '\nPayload: ' +
              JSON.stringify(payload, null, 2));
        }, function(error) {
          throw new Error('Unexpected ' + name + ' response code from Cloud ' +
              'Datastore endpoint: ' + response.status +
              '\nError retrieving payload: ' + error);
        });
      }

      return response.payload;
    },
    function onFindResponse(x, json) {
      if ( ! ( json.found && json.found[0] && json.found[0].entity ) )
        return null;
      if ( json.found.length > 1 ) {
        throw new Error('Multiple Cloud Datastore entities match ' +
            'unique id');
      }

      return com.google.cloud.datastore.fromDatastoreEntity(
          json.found[0].entity, x);
    },
    function onPutResponse(x, o, json) {
      var results = json.mutationResults;
      for ( var i = 0; i < results.length; i++ ) {
        if ( results[i].conflictDetected )
          throw new Error('Put to Cloud Datastore yielded conflict');
      }

      var newO = o.cls_.create(o, x);
      this.pub('on', 'put', newO);
      return newO;
    },
    function onRemoveResponse(x, o, json) {
      var results = json.mutationResults;
      for ( var i = 0; i < results.length; i++ ) {
        if ( results[i].conflictDetected )
          throw new Error('Remove from Cloud Datastore yielded conflict');
      }

      var newO = o.cls_.create(o, x);

      // Cloud Datastore will provide results with version numbers even if
      // the entity did not exist. Use indexUpdates defined-and-non-0 as a
      // proxy found-and-deleted.
      if ( json.indexUpdates ) {
        this.pub('on', 'remove', newO);
      }
      return newO;
    },
    function onSelectResponse(data, json) {
      var batch = json.batch;
      var entities = batch.entityResults;

      if ( ! entities ) {
        data.sink && data.sink.eof && data.sink.eof();
        return data.sink;
      }

      // Optional Sink interface extension:
      // Allow datastore-aware sinks to unpack query result batches manually
      // instead of DAO put()ing to them.
      if ( data.sink && data.sink.fromDatastoreEntityResults ) {
        data.sink.fromDatastoreEntityResults(entities, data.ctx);
      } else {
        var fromDatastoreEntity =
            com.google.cloud.datastore.fromDatastoreEntity;
        for ( var i = 0; i < entities.length; i++ ) {
          var obj = fromDatastoreEntity(entities[i].entity, data.ctx);
          data.results.push(obj);
          data.sink && data.sink.put && data.sink.put(obj, data.sub);
          if ( data.halted ) break;
        }
      }

      if ( this.resultsAreIncomplete_(batch, data) ) {
        return this.selectNextBatch_(data, batch);
      } else {
        data.sink && data.sink.eof && data.sink.eof();
        return data.sink;
      }
    },
    function onRemoveAllTransactionResponse(arr, json) {
      var transaction = json.transaction;
      var deletes = new Array(arr.length);
      for ( var i = 0; i < deletes.length; i++ ) {
        deletes[i] = { delete: arr[i].getDatastoreKey(this.partitionId_) };
      }

      return this.sendRequest('commit', {
        mode: 'TRANSACTIONAL',
        mutations: deletes,
        transaction: transaction
      }).then(this.onResponse.bind(this, 'removeAll commit'))
          .then(this.onRemoveAllResponse);
    },
    function onRemoveAllResponse(json) {
      var results = json.mutationResults;
      for ( var i = 0; i < results.length; i++ ) {
        if ( results[i].conflictDetected )
          throw new Error('Remove from Cloud Datastore yielded conflict');
      }
    }
  ]
});
/**
 * @license
 * Copyright 2017 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

foam.ENUM({
  package: 'com.google.cloud.datastore',
  name: 'DatastoreMutationType',

  properties: [
    {
      class: 'String',
      documentation: `"key" in Datastore API's mutations: [{<key>: <data>}].`,
      name: 'datastoreMutationKey'
    }
  ],

  values: [
    {
      name: 'UPSERT',
      datastoreMutationKey: 'upsert'
    },
    {
      name: 'DELETE',
      datastoreMutationKey: 'delete'
    }
  ]
});

foam.CLASS({
  package: 'com.google.cloud.datastore',
  name: 'DatastoreMutation',

  properties: [
    {
      class: 'Enum',
      of: 'com.google.cloud.datastore.DatastoreMutationType',
      name: 'type'
    },
    {
      documentation: `"data" in Datastore API's mutations: [{<key>: <data>}].`,
      name: 'data'
    },
    {
      class: 'Function',
      documentation: `Resolve function for datastore operation promise,
          pre-bound to return payload.`,
      name: 'resolve'
    },
    {
      class: 'Function',
      documentation: `Reject function for datastore operation promise,,
          pre-bound to error reporting payload.`,
      name: 'reject'
    }
  ]
});

foam.CLASS({
  package: 'com.google.cloud.datastore',
  name: 'BatchMutationDatastoreDAO',
  extends: 'com.google.cloud.datastore.DatastoreDAO',

  documentation: `Datastore DAO that batches put() and remove(). This can be
      crucial to avoid blowing API quota when performing bulk updates.`,

  requires: [
    'com.google.cloud.datastore.DatastoreMutation',
    'com.google.cloud.datastore.DatastoreMutationType'
  ],
  imports: [ 'info' ],

  properties: [
    {
      class: 'Int',
      documentation: `Maximum number of operations to include in a batch.
          Since each entity may be in a different entity group, default to
          transaction entity group limit of 25 [1].

          [1] https://cloud.google.com/datastore/docs/concepts/transactions#transactions_and_entity_groups`,
      name: 'batchSize',
      value: 25
    },
    {
      class: 'Int',
      documentation: `Maximum number of in-flight batches
          (i.e., transactions). Default to 1 in case clients expect strict
          ordering of operations. Increasing to ~25 seems to work well for bulk
          updates where order-of-operations doesn't matter.`,
      name: 'numBatches',
      value: 1
    },
    {
      class: 'FObjectArray',
      of: 'com.google.cloud.datastore.DatastoreMutation',
      name: 'mutations_'
    },
    {
      class: 'Int',
      documentation: 'Number of in-flight transactions.',
      name: 'numActiveTransactions_'
    }
  ],

  methods: [
    function put_(x, o) {
      var self = this;
      return new Promise(function(resolve, reject) {
        self.mutations_.push(self.DatastoreMutation.create({
          type: self.DatastoreMutationType.UPSERT,
          data: o.toDatastoreEntity(this.partitionId_),
          resolve: function() {
            self.pub('on', 'put', o);
            resolve(o);
          },
          reject: function() {
            reject(new Error('Cloud Datastore transaction for put() failed'));
          }
        }));
        self.onBatchedOperation();
      });
    },
    function remove_(x, o) {
      var self = this;
      return new Promise(function(resolve, reject) {
        self.mutations_.push(self.DatastoreMutation.create({
          type: self.DatastoreMutationType.DELETE,
          data: o.getDatastoreKey(this.partitionId_),
          resolve: function(didRemove) {
            if ( didRemove ) self.pub('on', 'remove', o);
            resolve(o);
          },
          reject: function() {
            reject(new Error('Cloud Datastore transaction for remove() failed'));
          }
        }));
        self.onBatchedOperation();
      });
    },
    function beginBatchTransaction() {
      if ( this.mutations_.length === 0 ) return Promise.resolve();

      this.info(`BatchedMutationDatastoreDAO: Sending batch from ${this.mutations_.length} backlog`);

      var mutations = this.mutations_.slice(0, this.batchSize);
      this.mutations_ = this.mutations_.slice(this.batchSize);

      this.numActiveTransactions_++;

      return this.getRequest('beginTransaction').send()
          .then(this.onResponse.bind(this, 'batch transaction'))
          .then(this.onBatchTransactionResponse.bind(this, mutations));
    }
  ],

  listeners: [
    {
      name: 'onBatchedOperation',
      isMerged: true,
      mergeDelay: 150,
      code: function() {
        foam.assert(
          this.mutations_.length > 0,
          'BatchedMutationDatastoreDAO: Attempt to batch no operations');

        var promises = [];
        for ( var i = this.numActiveTransactions_; i < this.numBatches; i++ ) {
          this.beginBatchTransaction();
        }

        return Promise.all(promises);
      }
    },

    function onBatchTransactionResponse(mutations, json) {
      var mutationData = new Array(mutations.length);
      var transaction = json.transaction;

      for ( var i = 0; i < mutations.length; i++ ) {
        mutationData[i] = {};
        mutationData[i][mutations[i].type.datastoreMutationKey] =
          mutations[i].data;
      }

      return this.getRequest('commit', JSON.stringify({
        mode: 'TRANSACTIONAL',
        mutations: mutationData,
        transaction: transaction
      })).send().then(this.onResponse.bind(this, 'batch commit'))
          .then(this.onBatchResponse.bind(this, mutations))
          .catch(this.onBatchFailure.bind(this, mutations));
    },
    function onBatchResponse(mutations, json) {
      var results = json.mutationResults;
      for ( var i = 0; i < results.length; i++ ) {
        if ( results[i].conflictDetected )
          throw new Error('Batched mutations in Cloud Datastore yielded conflict');
      }

      // Cloud Datastore will provide results with version numbers even if
      // the entity did not exist. Use indexUpdates defined-and-non-0 as a
      // proxy found-and-deleted.
      //
      // TODO(markdittmer): This is a poor proxy when operations are batched.
      var operationComplete = !! json.indexUpdates;
      for ( var i = 0; i < mutations.length; i++ ) {
        mutations[i].resolve(operationComplete);
      }

      this.numActiveTransactions_--;

      // Replace this transaction with a new one.
      this.beginBatchTransaction();
    },
    function onBatchFailure(mutations) {
      for ( var i = 0; i < mutations.length; i++ ) {
        mutations[i].reject();
      }

      this.numActiveTransactions_--;

      // Replace this transaction with a new one.
      this.beginBatchTransaction();
    }
  ]
});
/**
 * @license
 * Copyright 2017 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

(function() {
  // By decree of:
  // http://xahlee.info/js/html5_non-closing_tag.html
  var selfClosingNodeNames = {
    area: true,
    base: true,
    br: true,
    col: true,
    command: true,
    embed: true,
    hr: true,
    img: true,
    input: true,
    keygen: true,
    link: true,
    meta: true,
    param: true,
    source: true,
    track: true,
    wbr: true
  };

  // By decree of:
  // http://www.theukwebdesigncompany.com/articles/entity-escape-characters.php
  var unescapeMap = {
    '#100': 'd',
    '#101': 'e',
    '#102': 'f',
    '#103': 'g',
    '#104': 'h',
    '#105': 'i',
    '#106': 'j',
    '#107': 'k',
    '#108': 'l',
    '#109': 'm',
    '#110': 'n',
    '#111': 'o',
    '#112': 'p',
    '#113': 'q',
    '#114': 'r',
    '#115': 's',
    '#116': 't',
    '#117': 'u',
    '#118': 'v',
    '#119': 'w',
    '#120': 'x',
    '#121': 'y',
    '#122': 'z',
    '#123': '{',
    '#124': '|',
    '#125': '}',
    '#126': '~',
    '#160': ' ',
    '#161': '¡',
    '#162': '¢',
    '#163': '£',
    '#164': '¤',
    '#165': '¥',
    '#166': '¦',
    '#167': '§',
    '#168': '¨',
    '#169': '©',
    '#170': 'ª',
    '#171': '«',
    '#172': '¬',
    '#174': '®',
    '#175': '¯',
    '#176': '°',
    '#177': '±',
    '#178': '²',
    '#179': '³',
    '#180': '´',
    '#181': 'µ',
    '#182': '¶',
    '#183': '·',
    '#184': '¸',
    '#185': '¹',
    '#186': 'º',
    '#187': '»',
    '#188': '¼',
    '#189': '½',
    '#19': 'Å',
    '#190': '¾',
    '#191': '¿',
    '#192': 'À',
    '#193': 'Á',
    '#194': 'Â',
    '#195': 'Ã',
    '#196': 'Ä',
    '#198': 'Æ',
    '#199': 'Ç',
    '#200': 'È',
    '#201': 'É',
    '#202': 'Ê',
    '#203': 'Ë',
    '#204': 'Ì',
    '#205': 'Í',
    '#206': 'Î',
    '#207': 'Ï',
    '#208': 'Ð',
    '#209': 'Ñ',
    '#210': 'Ò',
    '#211': 'Ó',
    '#212': 'Ô',
    '#213': 'Õ',
    '#214': 'Ö',
    '#215': '×',
    '#216': 'Ø',
    '#217': 'Ù',
    '#218': 'Ú',
    '#219': 'Û',
    '#220': 'Ü',
    '#221': 'Ý',
    '#222': 'Þ',
    '#223': 'ß',
    '#224': 'à',
    '#225': 'á',
    '#226': 'â',
    '#227': 'ã',
    '#228': 'ä',
    '#229': 'å',
    '#23': 'í',
    '#230': 'æ',
    '#231': 'ç',
    '#232': 'è',
    '#233': 'é',
    '#234': 'ê',
    '#235': 'ë',
    '#236': 'ì',
    '#238': 'î',
    '#239': 'ï',
    '#240': 'ð',
    '#241': 'ñ',
    '#242': 'ò',
    '#243': 'ó',
    '#244': 'ô',
    '#245': 'õ',
    '#246': 'ö',
    '#247': '÷',
    '#248': 'ø',
    '#249': 'ù',
    '#250': 'ú',
    '#251': 'û',
    '#252': 'ü',
    '#253': 'ý',
    '#254': 'þ',
    '#255': 'ÿ',
    '#256': 'Ā',
    '#257': 'ā',
    '#258': 'Ă',
    '#259': 'ă',
    '#260': 'Ą',
    '#261': 'ą',
    '#262': 'Ć',
    '#263': 'ć',
    '#264': 'Ĉ',
    '#265': 'ĉ',
    '#266': 'Ċ',
    '#267': 'ċ',
    '#268': 'Č',
    '#269': 'č',
    '#27': 'ĕ',
    '#270': 'Ď',
    '#271': 'ď',
    '#272': 'Đ',
    '#273': 'đ',
    '#274': 'Ē',
    '#275': 'ē',
    '#276': 'Ĕ',
    '#278': 'Ė',
    '#279': 'ė',
    '#280': 'Ę',
    '#281': 'ę',
    '#282': 'Ě',
    '#283': 'ě',
    '#284': 'Ĝ',
    '#285': 'ĝ',
    '#286': 'Ğ',
    '#287': 'ğ',
    '#288': 'Ġ',
    '#289': 'ġ',
    '#290': 'Ģ',
    '#291': 'ģ',
    '#292': 'Ĥ',
    '#293': 'ĥ',
    '#294': 'Ħ',
    '#295': 'ħ',
    '#296': 'Ĩ',
    '#297': 'ĩ',
    '#298': 'Ī',
    '#299': 'ī',
    '#300': 'Ĭ',
    '#301': 'ĭ',
    '#302': 'Į',
    '#303': 'į',
    '#304': 'İ',
    '#305': 'ı',
    '#306': 'Ĳ',
    '#307': 'ĳ',
    '#308': 'Ĵ',
    '#309': 'ĵ',
    '#31': 'Ľ',
    '#310': 'Ķ',
    '#311': 'ķ',
    '#312': 'ĸ',
    '#313': 'Ĺ',
    '#314': 'ĺ',
    '#315': 'Ļ',
    '#316': 'ļ',
    '#318': 'ľ',
    '#319': 'Ŀ',
    '#32': ' ',
    '#320': 'ŀ',
    '#321': 'Ł',
    '#322': 'ł',
    '#323': 'Ń',
    '#324': 'ń',
    '#325': 'Ņ',
    '#326': 'ņ',
    '#327': 'Ň',
    '#328': 'ň',
    '#329': 'ŉ',
    '#33': '!',
    '#330': 'Ŋ',
    '#331': 'ŋ',
    '#332': 'Ō',
    '#333': 'ō',
    '#334': 'Ŏ',
    '#335': 'ŏ',
    '#336': 'Ő',
    '#337': 'ő',
    '#338': 'Œ',
    '#339': 'œ',
    '#34': '"',
    '#340': 'Ŕ',
    '#340': 'Ŕ',
    '#341': 'ŕ',
    '#341': 'ŕ',
    '#342': 'Ŗ',
    '#342': 'Ŗ',
    '#343': 'ŗ',
    '#343': 'ŗ',
    '#344': 'Ř',
    '#344': 'Ř',
    '#345': 'ř',
    '#345': 'ř',
    '#346': 'Ś',
    '#346': 'Ś',
    '#347': 'ś',
    '#347': 'ś',
    '#348': 'Ŝ',
    '#348': 'Ŝ',
    '#349': 'ŝ',
    '#349': 'ŝ',
    '#35': '#',
    '#35': 'ť',
    '#350': 'Ş',
    '#350': 'Ş',
    '#351': 'ş',
    '#351': 'ş',
    '#352': 'Š',
    '#352': 'Š',
    '#353': 'š',
    '#353': 'š',
    '#354': 'Ţ',
    '#354': 'Ţ',
    '#355': 'ţ',
    '#355': 'ţ',
    '#356': 'Ť',
    '#356': 'Ť',
    '#358': 'Ŧ',
    '#358': 'Ŧ',
    '#359': 'ŧ',
    '#359': 'ŧ',
    '#36': '$',
    '#360': 'Ũ',
    '#360': 'Ũ',
    '#361': 'ũ',
    '#361': 'ũ',
    '#362': 'Ū',
    '#362': 'Ū',
    '#363': 'ū',
    '#363': 'ū',
    '#364': 'Ŭ',
    '#364': 'Ŭ',
    '#365': 'ŭ',
    '#365': 'ŭ',
    '#366': 'Ů',
    '#366': 'Ů',
    '#367': 'ů',
    '#367': 'ů',
    '#368': 'Ű',
    '#368': 'Ű',
    '#369': 'ű',
    '#369': 'ű',
    '#37': '%',
    '#37': 'Ź',
    '#370': 'Ų',
    '#370': 'Ų',
    '#371': 'ų',
    '#371': 'ų',
    '#372': 'Ŵ',
    '#372': 'Ŵ',
    '#373': 'ŵ',
    '#373': 'ŵ',
    '#374': 'Ŷ',
    '#374': 'Ŷ',
    '#375': 'ŷ',
    '#375': 'ŷ',
    '#376': 'Ÿ',
    '#376': 'Ÿ',
    '#377': 'Ź',
    '#378': 'ź',
    '#378': 'ź',
    '#379': 'Ż',
    '#379': 'Ż',
    '#38': '&',
    '#380': 'ż',
    '#380': 'ż',
    '#381': 'Ž',
    '#381': 'Ž',
    '#382': 'ž',
    '#382': 'ž',
    '#383': 'ſ',
    '#383': 'ſ',
    '#39': '\'',
    '#40': '(',
    '#41': ')',
    '#42': '*',
    '#43': '+',
    '#44': ',',
    '#45': '-',
    '#46': '.',
    '#47': '/',
    '#48': '0',
    '#49': '1',
    '#50': '2',
    '#51': '3',
    '#52': '4',
    '#53': '5',
    '#54': '6',
    '#55': '7',
    '#56': '8',
    '#57': '9',
    '#577': 'ť',
    '#58': ':',
    '#59': ';',
    '#60': '<',
    '#61': '=',
    '#62': '>',
    '#63': '?',
    '#64': '@',
    '#65': 'A',
    '#66': 'B',
    '#67': 'C',
    '#68': 'D',
    '#69': 'E',
    '#70': 'F',
    '#71': 'G',
    '#72': 'H',
    '#73': 'I',
    '#74': 'J',
    '#75': 'K',
    '#76': 'L',
    '#77': 'M',
    '#78': 'N',
    '#79': 'O',
    '#80': 'P',
    '#81': 'Q',
    '#82': 'R',
    '#83': 'S',
    '#84': 'T',
    '#8482': '™',
    '#85': 'U',
    '#86': 'V',
    '#87': 'W',
    '#88': 'X',
    '#89': 'Y',
    '#90': 'Z',
    '#91': '[',
    '#92': '\\',
    '#93': ']',
    '#94': '^',
    '#95': '_',
    '#96': '`',
    '#97': 'a',
    '#98': 'b',
    '#99': 'c',
    '&#173;': '',
    'AElig': 'Æ',
    'Aacute': 'Á',
    'Acirc': 'Â',
    'Agrave': 'À',
    'Aring': 'Å',
    'Atilde': 'Ã',
    'Auml': 'Ä',
    'Ccedil': 'Ç',
    'ETH': 'Ð',
    'Eacute': 'É',
    'Ecirc': 'Ê',
    'Egrave': 'È',
    'Euml': 'Ë',
    'Iacute': 'Í',
    'Icirc': 'Î',
    'Igrave': 'Ì',
    'Iuml': 'Ï',
    'Ntilde': 'Ñ',
    'Oacute': 'Ó',
    'Ocirc': 'Ô',
    'Ograve': 'Ò',
    'Oslash': 'Ø',
    'Otilde': 'Õ',
    'Ouml': 'Ö',
    'THORN': 'Þ',
    'Uacute': 'Ú',
    'Ucirc': 'Û',
    'Ugrave': 'Ù',
    'Uuml': 'Ü',
    'Yacute': 'Ý',
    'aacute': 'á',
    'acirc': 'â',
    'acute': '´',
    'aelig': 'æ',
    'agrave': 'à',
    'amp': '&',
    'aring': 'å',
    'atilde': 'ã',
    'auml': 'ä',
    'brvbar': '¦',
    'ccedil': 'ç',
    'cedil': '¸',
    'cent': '¢',
    'copy': '©',
    'curren': '¤',
    'deg': '°',
    'divide': '÷',
    'eacute': 'é',
    'ecirc': 'ê',
    'egrave': 'è',
    'eth': 'ð',
    'euml': 'ë',
    'euro': '€',
    'frac12': '½',
    'frac14': '¼',
    'frac34': '¾',
    'gt': '>',
    'iacute': 'í',
    'icirc': 'î',
    'iexcl': '¡',
    'igrave': 'ì',
    'iquest': '¿',
    'iuml': 'ï',
    'lt': '<',
    'macr': '¯',
    'micro': 'µ',
    'middot': '·',
    'nbsp': ' ',
    'nbsp': '',
    'not': '¬',
    'ntilde': 'ñ',
    'oacute': 'ó',
    'ocirc': 'ô',
    'ograve': 'ò',
    'ordf': 'ª',
    'ordm': 'º',
    'oslash': 'ø',
    'otilde': 'õ',
    'ouml': 'ö',
    'para': '¶',
    'plusmn': '±',
    'pound': '£',
    'quot': '"',
    'raquo': '»',
    'reg': '®',
    'sect': '§',
    'shy': '',
    'sup1': '¹',
    'sup2': '²',
    'sup3': '³',
    'szlig': 'ß',
    'thorn': 'þ',
    'times': '×',
    'uacute': 'ú',
    'ucirc': 'û',
    'ugrave': 'ù',
    'uml': '¨',
    'uuml': 'ü',
    'yacute': 'ý',
    'yen': '¥',
  };
  var escapeMap = {};
  for ( var key in unescapeMap ) {
    if ( unescapeMap.hasOwnProperty(key) ) escapeMap[unescapeMap[key]] = key;
  }

  // FUTURE: Lazily instantiate RegExp to save memory.
  var unescapeKeys = Object.keys(unescapeMap).map(function(key) {
    return `&${key};`;
  });
  var escapeSequenceRegExp = RegExp(`(?=(${unescapeKeys.join('|')}))\\1`, 'g');
  var escapeKeys = Object.keys(escapeMap).map(function(escapeChar) {
    return `[${escapeChar}]`;
  });
  var escapableCharRegExp = RegExp(`(?=(${escapeKeys.join('|')}))\\1`, 'g');

  foam.LIB({
    name: 'foam.parsers.html',

    methods: [
      function getHtmlEscapeChar(id) {
        if ( ! unescapeMap.hasOwnProperty(id) ) return '';
        return unescapeMap[id];
      },
      function getHtmlEscapeSequence(c) {
        if ( ! escapeMap.hasOwnProperty(c) ) return '';
        return escapeMap[c];
      },
      function isSelfClosing(nodeName) {
        return selfClosingNodeNames[nodeName];
      },
      function unescapeString(str) {
        if ( ! foam.String.isInstance(str) ) return '';

        return str.replace(escapeSequenceRegExp, function(m) {
          // m is in the form of &id; We drop first and last character.
          var id = m.slice(1, -1);
          return unescapeMap[id];
        });
      },
      function escapeString(str) {
        if ( ! foam.String.isInstance(str) ) return '';

        return str.replace(escapableCharRegExp, function(id) {
          return `&${escapeMap[id]};`;
        });
      }
    ]
  });
})();
/**
 * @license
 * Copyright 2017 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

foam.CLASS({
  package: 'foam.parsers.html',
  name: 'Attribute',

  properties: [
    {
      class: 'String',
      name: 'name'
    },
    {
      class: 'String',
      name: 'value'
    }
  ]
});
/**
 * @license
 * Copyright 2017 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

foam.ENUM({
  package: 'foam.parsers.html',
  name: 'TagType',

  values: [
    { name: 'OPEN',       label: 'Open' },
    { name: 'CLOSE',      label: 'Close' },
    { name: 'OPEN_CLOSE', label: 'Open & Close' }
  ]
});
/**
 * @license
 * Copyright 2017 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

foam.CLASS({
  package: 'foam.parsers.html',
  name: 'Tag',

  properties: [
    {
      class: 'Enum',
      of: 'foam.parsers.html.TagType',
      name: 'type',
      factory: function() { return foam.parser.html.TagType.OPEN; }
    },
    {
      class: 'String',
      name: 'nodeName',
      value: 'div'
    },
    {
      class: 'FObjectArray',
      of: 'foam.parsers.html.Attribute',
      name: 'attributes',
    }
  ]
});
/**
 * @license
 * Copyright 2017 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

foam.CLASS({
  package: 'foam.parsers.html',
  name: 'HTMLLexer',

  documentation: `Parse an HTML string into a flat sequence of tags and
      strings.`,

  requires: [
    'foam.parse.ImperativeGrammar',
    'foam.parse.Parsers',
    'foam.parse.StringPStream',
    'foam.parsers.html.Attribute',
    'foam.parsers.html.Tag',
    'foam.parsers.html.TagType'
  ],

  axioms: [
    foam.pattern.Singleton.create()
  ],

  properties: [
    {
      name: 'lib',
      factory: function() { return foam.parsers.html; }
    },
    {
      name: 'symbolsFactory',
      value: function(
          seq1, sym, seq, repeat, alt, optional, str, plus, notChars, repeat0,
          not, anyChar, range, literalIC) {

        return {
          START: seq1(1, optional(sym('header')), sym('html')),

          html: repeat(sym('htmlPart')),

          htmlPart: alt(
              sym('cdata'),
              sym('comment'),
              sym('closeTag'),
              sym('openTag'),
              sym('text')),

          openTag: seq(
              '<',
              sym('tagName'),
              sym('whitespace'),
              sym('attributes'),
              sym('whitespace'),
              optional('/'),
              '>'),

          closeTag: seq1(1,
                       '</',
                       sym('tagName'),
                       sym('whitespace'),
                       '>'),

          header: seq(
            sym('whitespace'),
            optional(sym('langTag')),
            sym('whitespace'),
            optional(sym('doctype')),
            sym('whitespace')),

          langTag: seq('<?', repeat0(notChars('?')), '?>'),

          doctype: seq('<!', literalIC('DOCTYPE'), sym('whitespace'),
                       repeat0(sym('doctypePart')), '>'),

          doctypePart: alt(plus(notChars('[>', anyChar())),
                           seq('[', repeat0(notChars(']', anyChar())), ']')),

          cdata: seq1(1,
                      '<![CDATA[', str(repeat(not(']]>', anyChar()))), ']]>'),

          comment: seq('<!--', repeat0(not('-->', anyChar())), '-->'),

          attributes: repeat(sym('attribute'), sym('whitespace')),

          label: str(plus(notChars(' =/\t\r\n<>'))),

          tagName: sym('label'),

          text: str(plus(not(alt(sym('closeTag'), sym('openTag')),
                  anyChar()))),

          attribute: seq(sym('label'), optional(
              seq1(3, sym('whitespace'), '=', sym('whitespace'),
                   sym('value')))),

          value: str(alt(
              plus(notChars('\'" \t\r\n<>')),
              seq1(1, '"', repeat(notChars('"', anyChar())), '"'),
              seq1(1, "'", repeat(notChars("'", anyChar())), "'"))),

          whitespace: repeat0(alt(' ', '\t', '\r', '\n'))
        };
      }
    },
    {
      name: 'symbols',
      factory: function() {
        return foam.Function.withArgs(
          this.symbolsFactory,
          this.Parsers.create(),
          this
        );
      }
    },
    {
      name: 'actions',
      factory: function() {
        var self  = this;
        var lib   = self.lib;
        var Tag   = self.Tag;
        var Attribute = self.Attribute;
        var OPEN  = self.TagType.OPEN;
        var CLOSE = self.TagType.CLOSE;
        var OPEN_CLOSE = self.TagType.OPEN_CLOSE;

        return {
          openTag: function(v) {
            return Tag.create({
              type: v[5] || lib.isSelfClosing(v[1]) ? OPEN_CLOSE : OPEN,
              nodeName: v[1],
              attributes: v[3],
            });
          },

          closeTag: function(v) {
            return Tag.create({ type: CLOSE, nodeName: v });
          },

          // TODO(markdittmer): Do something with these values.
          header: function(v) { return null; },
          langTag: function(v) { return null; },
          doctype: function(v) { return null; },
          doctypePart: function(v) { return null; },
          cdata: function(v) { return null; },
          comment: function(v) { return null; },
          attribute: function(v) {
            return Attribute.create({ name: v[0], value: v[1] || null });
          },
        };
      }
    },
    {
      name: 'grammar',
      factory: function() {
        var grammar = this.ImperativeGrammar.create({symbols: this.symbols});
        grammar.addActions(this.actions);
        return grammar;
      }
    },
    {
      name: 'ps',
      factory: function() {
        return this.StringPStream.create();
      }
    }
  ],

  methods: [
    function parseString(str, opt_name) {
      opt_name = opt_name || 'START';

      this.ps.setString(str);
      var start = this.grammar.getSymbol(opt_name);
      foam.assert(start, 'No symbol found for', opt_name);

      return start.parse(this.ps, this.grammar);
    }
  ]
});
/**
 * @license
 * Copyright 2017 The FOAM Authors. All Rights Reserved.
 * http://www.apache.org/licenses/LICENSE-2.0
 */

foam.CLASS({
  package: 'foam.dao.history',
  name: 'PropertyUpdate',
  documentation: `Model containing the name of the property
    being updated, the old value, and the new value`,
  properties: [
    {
      class: 'String',
      name: 'name'
    },
    {
      class: 'Object',
      name: 'oldValue'
    },
    {
      class: 'Object',
      name: 'newValue'
    }
  ]
});
/**
 * @license
 * Copyright 2017 The FOAM Authors. All Rights Reserved.
 * http://www.apache.org/licenses/LICENSE-2.0
 */

foam.CLASS({
  package: 'foam.dao.history',
  name: 'HistoryRecord',

  documentation: 'Contains an array of property updates',
  ids: [ 'objectId', 'seqNo' ],
  
  properties: [
    {
      class: 'Long',
      name: 'seqNo'
    },
    {
      class: 'Object',
      name: 'objectId'
    },
    {
      class: 'String',
      name: 'user'
    },
    {
      class: 'DateTime',
      name: 'timestamp'
    },
    {
      class: 'FObjectArray',
      of: 'foam.dao.history.PropertyUpdate',
      name: 'updates'
    }
  ]
});
/**
 * @license
 * Copyright 2017 The FOAM Authors. All Rights Reserved.
 * http://www.apache.org/licenses/LICENSE-2.0
 */

foam.INTERFACE({
  package: 'foam.mop',
  name: 'MOP',

  documentation: 'MOP Interface',

  methods: [
    {
      name: 'get',
      returns: 'Promise',
      args: [ 'x' ]
    },
    {
      name: 'setProperty',
      returns: 'Promise',
      args: [ 'x', 'name', 'value' ]
    },
    {
      name: 'setProperties',
      returns: 'Promise',
      args: [ 'x', 'values' ]
    }
  ]
});
/**
 * @license
 * Copyright 2017 The FOAM Authors. All Rights Reserved.
 * http://www.apache.org/licenses/LICENSE-2.0
 */

foam.CLASS({
  package: 'foam.dao.pg',
  name: 'ConnectionPool',

  documentation: 'Represents a database connection pool',

  implements: [ 'foam.nanos.NanoService' ],

  javaImports: [ 'org.apache.commons.dbcp2.BasicDataSource' ],

  properties: [
    {
      class: 'Object',
      name: 'pool',
      javaType: 'BasicDataSource',
      documentation: 'Connection pool',
    },
    {
      class: 'Int',
      name: 'poolSize',
      value: 20,
      documentation: 'Connection pool size'
    },
    {
      class: 'String',
      name: 'driver',
      documentation: 'Database driver'
    },
    {
      class: 'String',
      name: 'prefix',
      documentation: 'Database connection string prefix. i.e. jdbc:postgresq://'
    },
    {
      class: 'String',
      name: 'hostname',
      documentation: 'Database hostname'
    },
    {
      class: 'String',
      name: 'port',
      documentation: 'Database port'
    },
    {
      class: 'String',
      name: 'database',
      documentation: 'Database name'
    },
    {
      class: 'String',
      name: 'username',
      documentation: 'Database username for authentication'
    },
    {
      class: 'String',
      name: 'password',
      documentation: 'Database password for authentication'
    },
    {
      class: 'String',
      name: 'connectionString',
      transient: true,
      javaFactory: `return getPrefix() +
        getHostname() + ":" +
        getPort() + "/" +
        getDatabase();`
    }
  ],

  methods: [
    {
      name: 'start',
      javaReturns: 'void',
      javaCode: `try {
  BasicDataSource pool = new BasicDataSource();
  pool.setUsername(getUsername());
  pool.setDriverClassName(getDriver());
  pool.setUrl(getConnectionString());
  pool.setInitialSize(getPoolSize());
  setPool(pool);
} catch (Exception e) {
  e.printStackTrace();
}`
    },
    {
      name: 'getConnection',
      javaReturns: 'java.sql.Connection',
      javaThrows: ['java.sql.SQLException'],
      javaCode: 'return getPool().getConnection();'
    }
  ]
});/**
 * @license
 * Copyright 2017 The FOAM Authors. All Rights Reserved.
 * http://www.apache.org/licenses/LICENSE-2.0
 */

foam.ENUM({
  package: 'foam.lib.json',
  name: 'OutputterMode',

  documentation: 'Defines the mode for JSON Outputter',

  values: [
    {
      name: 'NETWORK',
      label: 'Network'
    },
    {
      name: 'STORAGE',
      label: 'Storage'
    },
    {
      name: 'FULL',
      label: 'Full'
    }
  ]
});/**
 * @license
 * Copyright 2017 The FOAM Authors. All Rights Reserved.
 * http://www.apache.org/licenses/LICENSE-2.0
 */

foam.INTERFACE({
  package: 'foam.lib.parse',
  name: 'Parser',

  documentation: 'Parser interface',

  methods: [
    {
      name: 'parse',
      javaReturns: 'foam.lib.parse.PStream',
      args: [
        {
          name: 'ps',
          javaType: 'foam.lib.parse.PStream'
        },
        {
          name: 'x',
          javaType: 'foam.lib.parse.ParserContext'
        }
      ]
    }
  ]
});/**
 * @license
 * Copyright 2017 The FOAM Authors. All Rights Reserved.
 * http://www.apache.org/licenses/LICENSE-2.0
 */

foam.INTERFACE({
  package: 'foam.lib.parse',
  name: 'PStream',

  documentation: 'PStream interface',

  methods: [
    {
      name: 'head',
      javaReturns: 'char',
    },
    {
      name: 'valid',
      javaReturns: 'boolean'
    },
    {
      name: 'tail',
      javaReturns: 'foam.lib.parse.PStream'
    },
    {
      name: 'value',
      javaReturns: 'Object'
    },
    {
      name: 'setValue',
      javaReturns: 'foam.lib.parse.PStream',
      args: [
        {
          name: 'value',
          javaType: 'Object'
        }
      ]
    },
    {
      name: 'substring',
      javaReturns: 'String',
      args: [
        {
          name: 'end',
          javaType: 'foam.lib.parse.PStream'
        }
      ]
    },
    {
      name: 'apply',
      javaReturns: 'foam.lib.parse.PStream',
      args: [
        {
          name: 'ps',
          javaType: 'foam.lib.parse.Parser'
        },
        {
          name: 'x',
          javaType: 'foam.lib.parse.ParserContext'
        }
      ]
    }
  ]
});/**
 * @license
 * Copyright 2018 The FOAM Authors. All Rights Reserved.
 * http://www.apache.org/licenses/LICENSE-2.0
 */

foam.INTERFACE({
  package: 'foam.crypto.hash',
  name: 'Hasher',

  documentation: 'Hasher interface',

  methods: [
    {
      name: 'updateDigest',
      args: [
        {
          name: 'obj',
          javaType: 'foam.core.FObject'
        },
        {
          name: 'md',
          javaType: 'java.security.MessageDigest'
        }
      ]
    }
  ]
});/**
 * @license
 * Copyright 2018 The FOAM Authors. All Rights Reserved.
 * http://www.apache.org/licenses/LICENSE-2.0
 */

foam.INTERFACE({
  package: 'foam.crypto.hash',
  name: 'Hashable',

  documentation: 'Hashable interface',

  methods: [
    {
      name: 'hash',
      javaReturns: 'byte[]',
      args: [
        {
          name: 'algorithm',
          javaType: 'String',
          documentation: 'Hashing algorithm to use'
        },
        {
          name: 'hash',
          javaType: 'byte[]',
          documentation: 'Previous hash (used for chaining)'
        }
      ]
    }
  ]
});/**
 * @license
 * Copyright 2018 The FOAM Authors. All Rights Reserved.
 * http://www.apache.org/licenses/LICENSE-2.0
 */

foam.INTERFACE({
  package: 'foam.crypto.sign',
  name: 'Signer',

  documentation: 'Signer interface',

  methods: [
    {
      name: 'updateSignature',
      javaThrows: [
        'java.security.SignatureException'
      ],
      args: [
        {
          name: 'obj',
          javaType: 'foam.core.FObject'
        },
        {
          name: 'sig',
          javaType: 'java.security.Signature'
        }
      ]
    }
  ]
});
/**
 * @license
 * Copyright 2018 The FOAM Authors. All Rights Reserved.
 * http://www.apache.org/licenses/LICENSE-2.0
 */

foam.INTERFACE({
  package: 'foam.crypto.sign',
  name: 'Signable',

  documentation: 'Signer interface',

  methods: [
    {
      name: 'sign',
      javaReturns: 'byte[]',
      args: [
        {
          name: 'algorithm',
          javaType: 'String',
          documentation: 'Signing algorithm'
        },
        {
          name: 'key',
          javaType: 'java.security.PrivateKey',
          documentation: 'Private key to use for signing'
        }
      ]
    },
    {
      name: 'verify',
      javaReturns: 'boolean',
      args: [
        {
          name: 'signature',
          javaType: 'byte[]',
          documentation: 'Signature to verify'
        },
        {
          name: 'algorithm',
          javaType: 'String',
          documentation: 'Signing algorithm'
        },
        {
          name: 'key',
          javaType: 'java.security.PublicKey',
          documentation: 'Public key to use for verifying'
        }
      ]
    }
  ]
});
/**
 * @license
 * Copyright 2018 The FOAM Authors. All Rights Reserved.
 * http://www.apache.org/licenses/LICENSE-2.0
 */

foam.CLASS({
  package: 'foam.crypto.sign',
  name: 'SignedFObject',

  documentation: 'Represents an FObject with it\'s signature',

  properties: [
    {
      class: 'FObjectProperty',
      name: 'data',
      documentation: 'Original object'
    },
    {
      class: 'String',
      name: 'signature',
      documentation: 'Signature of object'
    }
  ]
});

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(5).Buffer))

/***/ }),

/***/ 878:
/***/ (function(module, exports) {

/* (ignored) */

/***/ }),

/***/ 879:
/***/ (function(module, exports) {

/* (ignored) */

/***/ }),

/***/ 880:
/***/ (function(module, exports) {

/* (ignored) */

/***/ }),

/***/ 881:
/***/ (function(module, exports) {

/* (ignored) */

/***/ }),

/***/ 882:
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(395);


/***/ })

},[882]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi8ubG9jYWwvZm9hbS1iaW4uanMiLCJ3ZWJwYWNrOi8vL2J1ZmZlciAoaWdub3JlZCkiLCJ3ZWJwYWNrOi8vL2NyeXB0byAoaWdub3JlZCkiLCJ3ZWJwYWNrOi8vL3V0aWwgKGlnbm9yZWQpIiwid2VicGFjazovLy91dGlsIChpZ25vcmVkKT83MDMzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsZUFBZTtBQUNwQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEscUJBQXFCLGFBQWE7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw2Q0FBNkMsZUFBZSxFQUFFO0FBQzlEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztB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Q0EsNENBQTRDLFlBQVk7QUFDeEQ7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDJCQUEyQixnQkFBZ0I7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxvREFBb0QsV0FBVztBQUMvRDtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQSxpQ0FBaUMsZ0JBQWdCLEVBQUU7QUFDbkQ7QUFDQSxlQUFlO0FBQ2YsYUFBYTtBQUNiO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWE7QUFDYjtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsTUFBTTtBQUM3Qyx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLDZCQUE2QixFQUFFO0FBQ3BFO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSx1REFBdUQscUJBQXFCLEVBQUU7QUFDOUU7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7O0FBR0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixlQUFlO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7O0FBRVY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwREFBMEQ7QUFDMUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLGdDQUFnQyxFQUFFO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULGlDQUFpQyw2QkFBNkI7O0FBRTlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLENBQUM7OztBQUdEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLGdDQUFnQztBQUN4RTtBQUNBO0FBQ0EsQ0FBQzs7O0FBR0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsNENBQTRDLFlBQVksRUFBRTtBQUMxRDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHlCQUF5QixlQUFlO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsZUFBZTtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxpQ0FBaUMsMENBQTBDLEVBQUU7QUFDN0U7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7O0FBR0Q7OztBQUdBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQix5QkFBeUIsRUFBRTtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMLHVCQUF1QixtRUFBbUUsRUFBRTtBQUM1RjtBQUNBLENBQUM7O0FBRUQ7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7QUFHRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsS0FBSyw2QkFBNkI7QUFDbEM7QUFDQTtBQUNBLGtCQUFrQixXQUFXO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx5QkFBeUIsZUFBZTtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7QUFHRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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Q0FBQzs7O0FBR0Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7OztBQUdEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDOzs7QUFHRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQzs7O0FBR0Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7OztBQUdEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7O0FBR0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7QUFHRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7OztBQUdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7QUFHRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsV0FBVztBQUM3QjtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsMEJBQTBCO0FBQzdDO0FBQ0E7QUFDQSxDQUFDOzs7QUFHRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7OztBQUdEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0Esa0JBQWtCLFdBQVc7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHlCQUF5QixlQUFlO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHlCQUF5QixlQUFlO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7OztBQUdEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLGlDQUFpQyxFQUFFO0FBQ25FOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxDQUFDOzs7QUFHRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7QUFHRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7QUFHRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7QUFHRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7O0FBR0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7OztBQUdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7QUFHRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7OztBQUdEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw2QkFBNkIsVUFBVSxFQUFFO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLG1CQUFtQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7O0FBR0Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7OztBQUdEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxvQ0FBb0M7QUFDcEUsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsQ0FBQzs7O0FBR0Q7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLEtBQUssaUNBQWlDO0FBQ3RDLEtBQUs7QUFDTDtBQUNBLENBQUM7OztBQUdEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7QUFHRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMscUNBQXFDO0FBQzlDLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsVUFBVTtBQUM1QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FB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Q0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7OztBQUdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxRQUFRO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLOztBQUVM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Q0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwyREFBMkQsd0NBQXdDO0FBQ25HO0FBQ0E7O0FBRUE7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLFdBQVc7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsMEJBQTBCO0FBQ3BEO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0EsOENBQThDLHNCQUFzQjtBQUNwRSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7OztBQUdEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx5QkFBeUIsRUFBRTtBQUMzQixxQkFBcUIsRUFBRTs7QUFFdkI7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7O0FBR0Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FB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TyxhQUFhLHNDQUFzQztBQUNoRyxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBOztBQUVBLHVCQUF1QixxQkFBcUI7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLCtCQUErQixFQUFFO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7O0FBR0Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7QUFHRDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7O0FBR0Q7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSw0QkFBNEI7QUFDNUI7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsNkJBQTZCO0FBQ3hELEtBQUs7QUFDTDtBQUNBO0FBQ0EsMkJBQTJCLDRCQUE0QjtBQUN2RDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsMEJBQTBCLEVBQUU7QUFDbEQ7QUFDQSxPQUFPO0FBQ1AsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE9BQU87QUFDUCxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE9BQU87QUFDUCxLQUFLOztBQUVMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7O0FBR0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7OztBQUdBO0FBQ0E7QUFDQSxHQUFHLGlCQUFpQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHlCQUF5QixxQkFBcUI7QUFDOUM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7QUFHRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7O0FBR0Q7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixXQUFXO0FBQ3RDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVzs7QUFFWDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0Esa0JBQWtCLE1BQU07QUFDeEI7QUFDQTtBQUNBOztBQUVBOztBQUVBLGtCQUFrQjs7QUFFbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsU0FBUztBQUMxQyxnRUFBZ0UsOEJBQThCO0FBQzlGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxzQkFBc0IsZ0JBQWdCO0FBQ3RDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7O0FBR0Q7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0Msc0JBQXNCO0FBQ3JFO0FBQ0E7O0FBRUEsaUJBQWlCO0FBQ2pCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsc0NBQXNDO0FBQ3RDO0FBQ0EsS0FBSztBQUNMO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0RBQWtELFVBQVU7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsbUJBQW1CLEVBQUU7QUFDMUQ7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFD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O0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixzQkFBc0I7QUFDbkQsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLGFBQWE7QUFDMUMsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBLHVCQUF1Qix1QkFBdUI7QUFD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O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUEsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5Qix3QkFBd0I7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7OztBQUdEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsc0JBQXNCO0FBQ25EO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHVCQUF1Qix1QkFBdUI7QUFDOUM7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztB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QUFDQSxvQkFBb0I7QUFDcEIsV0FBVzs7QUFFWCxvQ0FBb0MsWUFBWTtBQUNoRCxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSwrQkFBK0IsOEJBQThCLEVBQUU7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwwQkFBMEI7O0FBRTFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7OztBQUdEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsZUFBZTtBQUN4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QUF5QixvQkFBb0I7QUFDN0M7QUFDQSxDQUFDOzs7QUFHRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixnQkFBZ0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7OztBQUdEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGdCQUFnQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7O0FBR0Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7O0FBR0Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7O0FBR0Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7OztBQUdEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7O0FBR0Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7QUFHRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7OztBQUdEO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTCx5QkFBeUIsbUNBQW1DO0FBQzVEO0FBQ0EsQ0FBQzs7O0FBR0Q7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7OztBQUdEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7OztBQUdEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIscUJBQXFCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQSx1QkFBdUIsMEJBQTBCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsaUJBQWlCLEVBQUU7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsdUJBQXVCLDBCQUEwQjtBQUNqRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLENBQUM7OztBQUdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLHdCQUF3QjtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7OztBQUdEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixlQUFlO0FBQzFDO0FBQ0E7QUFDQTtBQUNBLFNBQVM7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Q1QsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7OztBQUdEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxtQ0FBbUM7QUFDckUsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxjQUFjO0FBQ2pELEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxjQUFjO0FBQ2pELEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7QUFHRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsc0JBQXNCO0FBQ2hFOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLHlCQUF5QixhQUFhLEVBQUU7O0FBRXhDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7QUFHRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxvQkFBb0I7QUFDOUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsdUJBQXVCLGtCQUFrQjtBQUN6QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7O0FBR0Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxrRUFBa0U7QUFDdkc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsRUFBRTtBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0EsZUFBZTtBQUNmO0FBQ0EsT0FBTztBQUNQO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxD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QTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLDZCQUE2QjtBQUM3QixlQUFlOztBQUVmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLLDREQUE0RDtBQUNqRSxLQUFLLDREQUE0RDtBQUNqRSxLQUFLLDREQUE0RDtBQUNqRSxLQUFLLDREQUE0RDtBQUNqRSxLQUFLO0FBQ0w7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixpREFBaUQ7QUFDNUUsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLGdEQUFnRDtBQUMzRSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLGdEQUFnRDtBQUMzRSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLGdEQUFnRDtBQUMzRSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLGlEQUFpRDtBQUM1RSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsZ0NBQWdDO0FBQzNEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSwyQkFBMkIsV0FBVztBQUN0QyxLQUFLO0FBQ0w7QUFDQTtBQUNBLDJCQUEyQixXQUFXO0FBQ3RDLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsdUNBQXVDLHNCQUFzQixFQUFFO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHNDQUFzQyxxQkFBcUIsRUFBRTtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLDhCQUE4QixzQkFBc0I7QUFDcEQsMkJBQTJCLFdBQVc7QUFDdEMsS0FBSztBQUNMO0FBQ0E7QUFDQSw4QkFBOEIsNEJBQTRCO0FBQzFEO0FBQ0EsMkJBQTJCLFdBQVc7QUFDdEMsS0FBSztBQUNMO0FBQ0E7QUFDQSw4QkFBOEIsNEJBQTRCO0FBQzFEO0FBQ0EsMkJBQTJCLFdBQVc7QUFDdEMsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCx3QkFBd0IsbUJBQW1CLEVBQUU7QUFDN0M7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLHdCQUF3QixtQkFBbUIsRUFBRTtBQUM3Qyw0QkFBNEIsMEJBQTBCLEVBQUU7QUFDeEQ7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixxQkFBcUI7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDhCQUE4QixxQkFBcUIsRUFBRTtBQUNyRDtBQUNBO0FBQ0EsS0FBSztBQUNMLG1DQUFtQyw4QkFBOEI7QUFDakU7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLDZCQUE2QixTQUFTLDBCQUEwQixFQUFFO0FBQ2xFO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7OztBQUdEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7OztBQUdEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLFdBQVc7QUFDdEMsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsdUJBQXVCLHdCQUF3QjtBQUMvQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBLHVCQUF1QixxQkFBcUI7QUFDNUM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLHVCQUF1QixxQkFBcUI7QUFDNUM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7OztBQUdEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFFO0FBQ0g7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsRUFBRTtBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDRFQUE0RTs7QUFFNUU7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsMkNBQTJDLDBCQUEwQjs7QUFFckUseUZBQXlGLHNCQUFzQixHQUFHLGdCQUFnQjtBQUNsSTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxjQUFjO0FBQzNELEtBQUs7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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLFVBQVU7QUFDaEQ7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7QUFHRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLG9DQUFvQztBQUMvRDtBQUNBO0FBQ0EsQ0FBQzs7O0FBR0Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBLENBQUM7OztBQUdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7O0FBR0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxLQUFLO0FBQ0w7QUFDQSxDQUFDOzs7QUFHRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUwsb0JBQW9CLG1CQUFtQixFQUFFOztBQUV6QyxxQkFBcUI7O0FBRXJCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7QUFHRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7OztBQUdEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7O0FBR0Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLHVDQUF1Qyx5QkFBeUI7QUFDaEUsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLHVDQUF1Qyw0QkFBNEI7QUFDbkU7QUFDQTtBQUNBLENBQUM7OztBQUdEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLE9BQU87QUFDUCw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7O0FBR0Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FB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RDtBQUN6RDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1Asc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFD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QTtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7QUFHRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7OztBQUdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsQ0FBQzs7O0FBR0Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7QUFHRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7OztBQUdEO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLENBQUM7OztBQUdEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLHNCQUFzQjtBQUNqRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLGFBQWEsRUFBRTtBQUMvQztBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxlQUFlO0FBQ3BELE9BQU87QUFDUCwwRUFBMEU7QUFDMUUsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1AsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUCw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNB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QUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxxQkFBcUI7O0FBRXJCO0FBQ0EsdUJBQXVCOztBQUV2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0EsQ0FBQzs7O0FBR0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7QUFHRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7OztBQUdEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsb0NBQW9DO0FBQ2pFO0FBQ0EsT0FBTztBQUNQLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsb0NBQW9DO0FBQy9EO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsb0NBQW9DO0FBQ2pFO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsQ0FBQzs7O0FBR0Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7QUFHRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCw2QkFBNkI7QUFDN0I7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7O0FBR0Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYyx1Q0FBdUM7QUFDckQsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDRDQUE0QyxxQkFBcUI7QUFDakU7O0FBRUE7QUFDQTtBQUNBLFdBQVc7O0FBRVg7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLEVBQUU7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGVBQWU7QUFDdkM7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLHdCQUF3QixlQUFlO0FBQ3ZDO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSx3QkFBd0IsaUJBQWlCO0FBQ3pDO0FBQ0EsS0FBSztBQUNMLHlCQUF5QixrQkFBa0I7QUFDM0M7QUFDQSxDQUFDOzs7QUFHRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLENBQUM7OztBQUdEO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7OztBQUdEO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyx3QkFBd0I7QUFDeEQsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQSxxRkFBcUYsY0FBYztBQUNuRywyRkFBMkYsUUFBUTtBQUNuRyxxRkFBcUYsV0FBVztBQUNoRyxxRkFBcUYsV0FBVztBQUNoRyxxRkFBcUYsV0FBVztBQUNoRyxxRkFBcUYsV0FBVztBQUNoRztBQUNBO0FBQ0E7QUFDQTtBQUNBLHVGQUF1RixXQUFXO0FBQ2xHO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7O0FBR0Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOzs7QUFHRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7O0FBR0Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlGQUF5RixRQUFRO0FBQ2pHO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7O0FBR0Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2REFBNkQsV0FBVztBQUN4RSx5RkFBeUYsUUFBUTtBQUNqRyx3RUFBd0UsV0FBVztBQUNuRixtRUFBbUUsV0FBVztBQUM5RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7OztBQUdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLEVBQUU7QUFDMUI7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSx3QkFBd0IsY0FBYztBQUN0QztBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLHdCQUF3QixjQUFjO0FBQ3RDO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTCx5QkFBeUIsdUJBQXVCO0FBQ2hEO0FBQ0EsQ0FBQzs7O0FBR0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLDRCQUE0QixhQUFhO0FBQ3pDO0FBQ0EsQ0FBQzs7O0FBR0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsYUFBYSxFQUFFO0FBQ3ZDO0FBQ0EsS0FBSztBQUNMO0FBQ0EsQ0FBQzs7O0FBR0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBLGtCQUFrQixjQUFjO0FBQ2hDO0FBQ0EsQ0FBQzs7O0FBR0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7O0FBR0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7O0FBR0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLHVCQUF1QjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0Esc0JBQXNCLHFCQUFxQjtBQUMzQyw0QkFBNEIsaUJBQWlCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7O0FBR0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5Qix1QkFBdUI7QUFDaEQ7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSx1QkFBdUIsdUJBQXVCO0FBQzlDO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLDJCQUEyQix1QkFBdUI7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLHlDQUF5QyxnQkFBZ0I7QUFDekQsS0FBSzs7QUFFTCw0QkFBNEIsRUFBRTs7QUFFOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLG9CQUFvQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7QUFHRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5Qix1QkFBdUI7QUFDaEQ7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLDZCQUE2QjtBQUM3QjtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsc0JBQXNCLHNCQUFzQjtBQUM1QztBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSwyQkFBMkIsdUJBQXVCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSx5Q0FBeUMsZ0JBQWdCO0FBQ3pELEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLE9BQU87QUFDN0I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLGlCQUFpQjtBQUN4QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCLHVCQUF1QixpQkFBaUI7QUFDeEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsUUFBUTtBQUN6QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLG9CQUFvQjtBQUN6QztBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLGdCQUFnQixPQUFPO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaURBQWlELFFBQVE7QUFDekQ7QUFDQTtBQUNBOztBQUVBO0FBQ0EsOEJBQThCLG1CQUFtQjtBQUNqRDtBQUNBO0FBQ0EsK0JBQStCLHFCQUFxQjtBQUNwRCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7OztBQUdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0Esd0RBQXdEO0FBQ3hEO0FBQ0E7QUFDQSxDQUFDOzs7QUFHRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxDQUFDOzs7QUFHRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7QUFHRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7QUFHRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7QUFHRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLHVCQUF1QjtBQUNqRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7O0FBR0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLHVCQUF1QixpQkFBaUI7QUFDeEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLGlCQUFpQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7O0FBR0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixpQkFBaUI7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7OztBQUdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsbUJBQW1CLEVBQUU7QUFDN0M7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUwseUJBQXlCLG1DQUFtQyxFQUFFOztBQUU5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQixtQkFBbUIsRUFBRTs7QUFFdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMLHlCQUF5QixtQ0FBbUM7QUFDNUQ7QUFDQSxDQUFDOzs7QUFHRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxtQkFBbUIsbUJBQW1CLEVBQUU7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7QUFHRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7O0FBR0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7QUFHRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7OztBQUdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7O0FBR0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7QUFHRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7QUFHRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7OztBQUdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxxQkFBcUIsMkJBQTJCLEVBQUU7O0FBRWxEO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQSxDQUFDOzs7QUFHRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxzQkFBc0Isa0JBQWtCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLENBQUM7OztBQUdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FB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O0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSwrQkFBK0IsZ0JBQWdCO0FBQy9DO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsZ0NBQWdDLGVBQWU7QUFDL0M7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQSx1Q0FBdUM7O0FBRXZDO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOzs7QUFHTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOzs7QUFHTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7OztBQUdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixrQkFBa0I7QUFDOUMsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixrQkFBa0I7QUFDOUMsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixVQUFVO0FBQ3RDLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsVUFBVTtBQUN0QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUwsOEJBQThCLGFBQWEsRUFBRTtBQUM3Qyw4QkFBOEIsYUFBYSxFQUFFO0FBQzdDLDhCQUE4QixhQUFhLEVBQUU7QUFDN0MsOEJBQThCLGFBQWEsRUFBRTtBQUM3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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0NBQWtDLG1CQUFtQixNQUFNO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxtQkFBbUIsTUFBTTtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLHNDQUFzQyxxRUFBcUU7QUFDM0csU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVB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Q0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLGNBQWM7QUFDNUMsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxrQkFBa0I7QUFDcEQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLGFBQWEsRUFBRTtBQUMxQyxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0ZBQXdGO0FBQ3hGO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsMkZBQTJGO0FBQzNGO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsOEZBQThGO0FBQzlGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLCtCQUErQixzQkFBc0I7QUFDckQ7O0FBRUE7QUFDQSw0QkFBNEIsNkNBQTZDLEVBQUU7QUFDM0UsMkJBQTJCLDRDQUE0QztBQUN2RTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQSxxQkFBcUIsdUNBQXVDLEVBQUU7QUFDOUQsd0JBQXdCLDBDQUEwQyxFQUFFO0FBQ3BFLHNCQUFzQix3Q0FBd0MsRUFBRTtBQUNoRSx3QkFBd0IsMENBQTBDLEVBQUU7QUFDcEUsMkJBQTJCLDZDQUE2QyxFQUFFOztBQUUxRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsOENBQThDOztBQUUvRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUlBQXVJO0FBQ3ZJLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU8sT0FBTztBQUNkO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVzs7QUFFWDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLHlCQUF5QjtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7QUFHRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztB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QTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpQkFBaUIsOENBQThDOztBQUUvRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDRDQUE0QztBQUM1QztBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsdUJBQXVCO0FBQ2pELEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsT0FBTyw2REFBNkQ7O0FBRXBFO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNB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QUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxXQUFXO0FBQzVEO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsd0JBQXdCO0FBQ3pEO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixtQkFBbUI7QUFDOUM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJGQUEyRjtBQUMzRixLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0M7QUFDL0M7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixrQkFBa0I7QUFDOUM7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixtQkFBbUI7QUFDOUMsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtB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QUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxrREFBa0Q7QUFDakU7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLDZCQUE2QjtBQUM3QixLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFD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Q0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7OztBQUdEO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxDQUFDOzs7QUFHRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsaUJBQWlCO0FBQzlEO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7OztBQUdEO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7QUFHRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7O0FBR0Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxDQUFDOzs7QUFHRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxDQUFDOzs7QUFHRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLHdFQUF3RTtBQUN4RTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxDQUFDOzs7QUFHRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDLGVBQWUsaUNBQWlDO0FBQ2hEO0FBQ0EsQ0FBQzs7O0FBR0Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7QUFHRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsQ0FBQzs7O0FBR0Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHdCQUF3QixvQkFBb0I7QUFDNUMsU0FBUztBQUNULE9BQU87QUFDUCxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhO0FBQ2IsV0FBVztBQUNYLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCxhQUFhO0FBQy9ELGFBQWE7QUFDYixXQUFXO0FBQ1gsU0FBUztBQUNULE9BQU87QUFDUCxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLFNBQVM7QUFDcEQsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0EsQ0FBQzs7O0FBR0Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQLHdDQUF3Qyx3QkFBd0I7QUFDaEUsT0FBTztBQUNQLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQSxDQUFDOzs7QUFHRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQSxDQUFDOzs7QUFHRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQsU0FBUztBQUNsRSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxtREFBbUQsdUJBQXVCO0FBQzFFO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHlCQUF5QixrQkFBa0I7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUCxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxpQkFBaUI7QUFDakUsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLDBCQUEwQjtBQUNyRCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLHFCQUFxQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixXQUFXO0FBQ1g7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsdUJBQXVCLHFCQUFxQjtBQUM1QztBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0EsMENBQTBDLHdCQUF3QjtBQUNsRTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw2Q0FBNkMsNENBQTRDLEVBQUU7QUFDM0Y7O0FBRUE7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNkNBQTZDLDRDQUE0QyxFQUFFO0FBQzNGOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQSxpQ0FBaUMsaUJBQWlCLEVBQUU7O0FBRXBEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7OztBQUdEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLENBQUM7OztBQUdEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1EO0FBQ25ELEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQ7QUFDbkQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPOztBQUVQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsT0FBTztBQUNQLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3RUFBd0U7QUFDeEU7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLCtDQUErQyxhQUFhO0FBQzVELE9BQU87QUFDUCw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsNENBQTRDLGdDQUFnQztBQUM1RTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE9BQU87QUFDUDtBQUNBLDZCQUE2QjtBQUM3Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE9BQU87QUFDUDtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxhQUFhO0FBQ3JELE9BQU87QUFDUDtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxTQUFTO0FBQ1Qsd0JBQXdCLGVBQWU7QUFDdkMsS0FBSztBQUNMO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsQ0FBQztBQUNEO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRCxhQUFhO0FBQ3hFLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsU0FBUztBQUNULFNBQVM7QUFDVDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQiwwQkFBMEI7QUFDaEQ7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsb0NBQW9DO0FBQy9ELEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0Isc0JBQXNCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esc0JBQXNCLDBCQUEwQjtBQUNoRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLHNCQUFzQixzQkFBc0I7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUCxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtDQUFrQyxtQkFBbUI7QUFDckQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUCxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEtBQUs7QUFDTDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlFQUFpRTtBQUNqRSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxpQkFBaUIsRUFBRTtBQUNuRCw0QkFBNEI7QUFDNUIsS0FBSztBQUNMO0FBQ0E7QUFDQSxnQ0FBZ0MsaUJBQWlCLEVBQUU7QUFDbkQsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLG1CQUFtQixFQUFFO0FBQ2hELDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLHFDQUFxQyxpQkFBaUIsRUFBRTs7QUFFeEQsNkJBQTZCLG1CQUFtQjtBQUNoRDs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsV0FBVztBQUNYOztBQUVBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1Asc0RBQXNEO0FBQ3REO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLHdCQUF3QjtBQUN2RCxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULG1DQUFtQyxtQ0FBbUM7QUFDdEU7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMkJBQTJCLDhCQUE4QixFQUFFO0FBQzNELDhCQUE4Qiw4QkFBOEIsRUFBRTtBQUM5RCw0QkFBNEIsOEJBQThCLEVBQUU7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLDBCQUEwQjtBQUN0RTtBQUNBLHNDQUFzQyx5QkFBeUIsRUFBRTtBQUNqRTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLDZCQUE2QjtBQUM3QixxR0FBcUc7O0FBRXJHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLG1DQUFtQyxpQkFBaUIsRUFBRTs7QUFFdEQsMkJBQTJCLG1CQUFtQjtBQUM5Qzs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsaURBQWlELGtCQUFrQjtBQUNuRSxXQUFXOztBQUVYO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0QsYUFBYTtBQUNuRSxlQUFlO0FBQ2YsYUFBYTtBQUNiO0FBQ0E7QUFDQSxxREFBcUQsa0NBQWtDO0FBQ3ZGLGVBQWU7QUFDZixhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0Esa0RBQWtELFVBQVU7QUFDNUQsV0FBVztBQUNYO0FBQ0EsT0FBTztBQUNQLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxxRUFBcUU7QUFDckUsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1AsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLFlBQVk7QUFDM0QsYUFBYTtBQUNiLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULDZEQUE2RCxnQkFBZ0I7QUFDN0U7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsNkRBQTZELFlBQVk7QUFDekU7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7O0FBRVg7O0FBRUEsOENBQThDLGFBQWE7QUFDM0QsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5Qix1QkFBdUI7QUFDaEQ7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxXQUFXO0FBQzdDLE9BQU87QUFDUDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsb0JBQW9CO0FBQzNEO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsZ0JBQWdCO0FBQ2pFLE9BQU87QUFDUCw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxnQkFBZ0I7QUFDaEU7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVCw2REFBNkQsd0NBQXdDLGNBQWMsR0FBRztBQUN0SCxTQUFTO0FBQ1QsT0FBTztBQUNQLDZCQUE2QjtBQUM3QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxzREFBc0Q7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSx1REFBdUQscUJBQXFCO0FBQzVFLGFBQWE7O0FBRWIsdUNBQXVDLHNCQUFzQjtBQUM3RDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLGlEQUFpRCxhQUFhO0FBQzlEOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxzQ0FBc0MsU0FBUyx1Q0FBdUM7QUFDbEc7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7O0FBR0Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLDBCQUEwQjtBQUNyRCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsMEJBQTBCO0FBQ3JELEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixpQkFBaUIsVUFBVSxFQUFFLEVBQUU7QUFDMUQ7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsMkJBQTJCLEVBQUU7QUFDeEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsZUFBZTtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxxQkFBcUI7QUFDckIsT0FBTztBQUNQO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLGtDQUFrQztBQUM3RCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnREFBZ0Q7QUFDaEQ7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLDRCQUE0QjtBQUN2RCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUztB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QUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0VBQWtFLFlBQVk7QUFDOUUsMENBQTBDLFlBQVk7QUFDdEQsMENBQTBDLDJCQUEyQixFQUFFO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmLFNBQVM7QUFDVDtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7OztBQUdEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCx3QkFBd0I7O0FBRTNFLGlFQUFpRSxVQUFVO0FBQzNFO0FBQ0E7QUFDQTtBQUNBLENBQUM7OztBQUdEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwy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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxnQkFBZ0I7QUFDbEQsS0FBSztBQUNMO0FBQ0E7QUFDQSwyQkFBMkIsNEJBQTRCO0FBQ3ZELEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLHNCQUFzQjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLHNCQUFzQjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFD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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixnQkFBZ0I7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLHFFQUFxRSxFQUFFO0FBQ3JHO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxnQ0FBZ0MsMEJBQTBCO0FBQzFEO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsNENBQTRDLEVBQUU7QUFDOUUsb0NBQW9DO0FBQ3BDLDZDQUE2QyxtQkFBbUI7QUFDaEU7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw2REFBNkQsV0FBVztBQUN4RTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpREFBaUQsVUFBVTtBQUMzRCxhQUFhO0FBQ2IsT0FBTztBQUNQLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsa0JBQWtCO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEscUJBQXFCLGNBQWMsMkJBQTJCLEVBQUU7O0FBRWhFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsWUFBWTtBQUN0RCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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LFdBQVc7QUFDWDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsaUNBQWlDO0FB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QUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEdBQUcsUUFBUTtBQUN0QjtBQUNBO0FBQ0Esd0NBQXdDLHVCQUF1QjtBQUMvRDtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1AsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixXQUFXLEVBQUU7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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OztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVCxPQUFPO0FBQ1AsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7O0FBR0Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVCxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQkFBa0Isa0NBQWtDOztBQUVwRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0EseUJBQXlCLFdBQVc7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsMEVBQTBFO0FBQ3hGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0EsMkJBQTJCOztBQUUzQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixhQUFhO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7QUFHRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7OztBQUdEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLFlBQVk7QUFDcEM7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7O0FBR0Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7QUFHRDtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7O0FBR0Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsOENBQThDO0FBQ2hFLGdFQUFnRSxFQUFFO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7O0FBR0Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7QUFHRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7OztBQUdEO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsU0FBUyxzQkFBc0IsVUFBVSxFQUFFO0FBQzNDO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQSxnQ0FBZ0MsMkNBQTJDLEVBQUU7QUFDN0U7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLGdCQUFnQjtBQUNuRDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxnQkFBZ0I7QUFDbkQ7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsZ0JBQWdCO0FBQ25EO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSw2Q0FBNkMsZ0NBQWdDLEVBQUU7QUFDL0UsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsOEJBQThCLGdEQUFnRDtBQUM5RSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLHlCQUF5QjtBQUN6RCxtQkFBbUI7QUFDbkIsMkNBQTJDLHFCQUFxQixFQUFFO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZixXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QywyQkFBMkIsRUFBRTtBQUMzRSxvREFBb0QsaUNBQWlDLHFDQUFxQyxFQUFFLEVBQUUsRUFBRTtBQUNoSTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CLGVBQWU7QUFDZixXQUFXO0FBQ1g7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1osVUFBVSxPQUFPOztBQUVqQjs7QUFFQSx1QkFBdUIsMkJBQTJCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTs7QUFFZix1QkFBdUIsMEJBQTBCO0FBQ2pEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0JBQWtCLFdBQVc7O0FBRTdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Es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UztBQUNULE9BQU87QUFDUDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsZUFBZTtBQUNmO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLCtCQUErQixXQUFXO0FBQzFDLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsUUFBUTtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsY0FBYztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsMEJBQTBCLG1CQUFtQjtBQUM3QztBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxrQkFBa0I7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVM7O0FBRVQ7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGtCQUFrQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixXQUFXO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixZQUFZO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztB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O0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLHVCQUF1QixFQUFFO0FBQ3hFO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EseUJBQXlCLG1CQUFtQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsZ0JBQWdCLEVBQUU7QUFDbEQ7QUFDQSxzQkFBc0IsMkNBQTJDO0FBQ2pFO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxZQUFZO0FBQzFCLGVBQWUsWUFBWTtBQUMzQixlQUFlLFlBQVk7QUFDM0IsZ0JBQWdCLFlBQVk7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLGFBQWE7QUFDcEM7QUFDQTs7QUFFQSw4QkFBOEIsZ0JBQWdCO0FBQzlDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0QsWUFBWTtBQUNoRTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsZUFBZTtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxpQ0FBaUMsbUJBQW1CLEVBQUU7QUFDdEQ7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLGlCQUFpQjtBQUM1QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyx3QkFBd0I7QUFDNUQ7O0FBRUEsd0JBQXdCLG1CQUFtQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGtCQUFrQixrQkFBa0IsRUFBRTs7QUFFdEM7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxzQ0FBc0Msc0JBQXNCO0FBQzVELEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsZ0NBQWdDO0FBQzVELEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLGdDQUFnQyxtQkFBbUI7QUFDbkQ7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsZ0JBQWdCO0FBQ3BELE9BQU87QUFDUCxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLHdCQUF3QjtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsc0JBQXNCO0FBQ2xFLDRDQUE0Qzs7QUFFNUM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsV0FBVztBQUN0QyxLQUFLO0FBQ0w7QUFDQTtBQUNBLDJCQUEyQixXQUFXO0FBQ3RDLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCwyQkFBMkIsRUFBRTtBQUMvRSxPQUFPO0FBQ1AsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQSxzREFBc0QsY0FBYyxFQUFFO0FBQ3RFO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxjQUFjO0FBQ3REO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQiwyQkFBMkI7QUFDdEQsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZCxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLDhDQUE4Qzs7QUFFM0U7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLFdBQVc7QUFDdEMsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLOztBQUVMO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxnQkFBZ0IsRUFBRTtBQUNsRCx3QkFBd0IsWUFBWTtBQUNwQyxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLHdCQUF3QixFQUFFO0FBQ2pFLHdCQUF3QixZQUFZO0FBQ3BDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsNEJBQTRCO0FBQ3ZELEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsZ0JBQWdCO0FBQzNEOztBQUVBO0FBQ0EsNERBQTRELGdCQUFnQjtBQUM1RTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFD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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLEtBQUssNkJBQTZCO0FBQ2xDLEtBQUssNkJBQTZCO0FBQ2xDLEtBQUssNkJBQTZCO0FBQ2xDLEtBQUssNkJBQTZCO0FBQ2xDLEtBQUssNkJBQTZCO0FBQ2xDLEtBQUssNkJBQTZCO0FBQ2xDLEtBQUssNkJBQTZCO0FBQ2xDLEtBQUssNkJBQTZCO0FBQ2xDLEtBQUssNkJBQTZCO0FBQ2xDO0FBQ0E7QUFDQSwyQkFBMkIsMkJBQTJCLEVBQUU7QUFDeEQ7QUFDQSwyQkFBMkIsVUFBVTtBQUNyQztBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQkFBaUIsWUFBWTtBQUM3QixpQkFBaUIsWUFBWTtBQUM3QixpQkFBaUIsWUFBWTtBQUM3QixLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7O0FBR0Q7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsS0FBSyw2QkFBNkI7QUFDbEMsS0FBSyw2QkFBNkI7QUFDbEMsS0FBSyw2QkFBNkI7QUFDbEMsS0FBSyw2QkFBNkI7O0FBRWxDLEtBQUssNkJBQTZCO0FBQ2xDLEtBQUssNkJBQTZCO0FBQ2xDLEtBQUssNkJBQTZCO0FBQ2xDLEtBQUssNkJBQTZCOztBQUVsQyxLQUFLLDZCQUE2QjtBQUNsQyxLQUFLLDZCQUE2QjtBQUNsQyxLQUFLLDZCQUE2QjtBQUNsQyxLQUFLLDZCQUE2Qjs7QUFFbEMsS0FBSyw2QkFBNkI7QUFDbEMsS0FBSyw2QkFBNkI7QUFDbEMsS0FBSyw2QkFBNkI7QUFDbEMsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQSxpQkFBaUIsWUFBWSxZQUFZO0FBQ3pDLGlCQUFpQixZQUFZLFlBQVk7QUFDekMsaUJBQWlCLFlBQVksWUFBWTtBQUN6QyxpQkFBaUIsWUFBWSxZQUFZO0FBQ3pDLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxL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M0M7QUFDQSxDQUFDOzs7QUFHRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSyw0QkFBNEI7QUFDakMsS0FBSyw0QkFBNEI7QUFDakMsS0FBSyw0QkFBNEI7QUFDakMsS0FBSyxrQ0FBa0M7QUFDdkMsS0FBSyxrQ0FBa0M7QUFDdkMsS0FBSyxrQ0FBa0M7QUFDdkMsS0FBSywyQ0FBMkM7QUFDaEQsS0FBSywyQ0FBMkM7QUFDaEQsS0FBSywyQ0FBMkM7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7OztBQUdEO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7QUFHRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixlQUFlLEVBQUU7QUFDM0MsMkJBQTJCLFlBQVk7QUFDdkMsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixlQUFlLEVBQUU7QUFDM0MsMkJBQTJCLFlBQVk7QUFDdkMsS0FBSztBQUNMLEtBQUssZ0NBQWdDO0FBQ3JDLEtBQUssZ0NBQWdDO0FBQ3JDLEtBQUssK0NBQStDO0FBQ3BELEtBQUssdURBQXVEO0FBQzVELEtBQUssMklBQTJJO0FBQ2hKOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7OztBQUdEO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLGdCQUFnQjtBQUNwRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7OztBQUdEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx1QkFBdUIsc0JBQXNCO0FBQzdDOztBQUVBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQLEtBQUs7O0FBRUw7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLGFBQWE7QUFDYixLQUFLO0FBQ0w7QUFDQTtBQUNBLGFBQWEsd0NBQXdDO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsc0JBQXNCLEVBQUU7QUFDcEUsd0JBQXdCO0FBQ3hCLEtBQUs7QUFDTDtBQUNBO0FBQ0Esc0NBQXNDLHFCQUFxQixFQUFFO0FBQzdELDBDQUEwQyxvQkFBb0IsRUFBRTtBQUNoRTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLHdCQUF3QjtBQUN4QixLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLG1CQUFtQixFQUFFO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSw0Q0FBNEMsc0JBQXNCLEVBQUU7QUFDcEUsc0NBQXNDLHFCQUFxQixFQUFFO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxxQkFBcUI7QUFDL0QsS0FBSztBQUNMO0FBQ0E7QUFDQSxrQ0FBa0Msa0JBQWtCO0FBQ3BELEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixpQ0FBaUM7QUFDaEUsK0JBQStCLHlDQUF5QztBQUN4RTtBQUNBLHVCQUF1Qiw0QkFBNEI7QUFDbkQsaURBQWlELG9DQUFvQyxFQUFFO0FBQ3ZGO0FBQ0EsMkJBQTJCLDJCQUEyQjtBQUN0RDtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsOEJBQThCO0FBQ25FO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsb0NBQW9DLEVBQUU7QUFDakY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsYUFBYSw4QkFBOEI7QUFDM0M7QUFDQSwrQ0FBK0M7QUFDL0M7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRCxpREFBaUQsRUFBRTtBQUM3RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtB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d0M7QUFDdEQ7QUFDQSwyREFBMkQsY0FBYztBQUN6RTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXOztBQUVYO0FBQ0EsaUNBQWlDLG9DQUFvQztBQUNyRTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVzs7QUFFWDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRCxpQ0FBaUM7O0FBRTVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7O0FBRVg7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELHVDQUF1QyxFQUFFLGtCQUFrQixFQUFFO0FBQ2pIO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCx1Q0FBdUMsRUFBRSxrQkFBa0IsRUFBRTtBQUM5RztBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLFdBQVc7QUFDdEMsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLDZDQUE2QztBQUN2RTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaURBQWlEOztBQUVqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLGdDQUFnQyxVQUFVO0FBQzFDO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0EsQ0FBQzs7O0FBR0Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsaUJBQWlCO0FBQ25DO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxZQUFZO0FBQ1o7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsa0NBQWtDO0FBQzdEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EscUJBQXFCO0FBQ3JCOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEIsNENBQTRDLGFBQWE7QUFDekQsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtB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YztBQUMzRTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7O0FBRUEsbUVBQW1FLHVCQUF1Qjs7QUFFMUY7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtEQUFrRCxxQkFBcUI7QUFDdkU7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUEsc0JBQXNCLHNCQUFzQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxzQkFBc0Isb0JBQW9CO0FBQzFDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0Isc0JBQXNCO0FBQzVDO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLHNCQUFzQixzQkFBc0I7QUFDNUM7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFF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cURBQXFELHNCQUFzQjtBQUMzRTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsQ0FBQztBQUNELEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRDtBQUNsRDtBQUNBO0FBQ0EsQ0FBQyxFQUFFO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFFO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLEVBQUU7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsRUFBRTtBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsRUFBRTtBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsRUFBRTtBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7Ozs7Ozs7OztBQ3Q4bkRELGU7Ozs7Ozs7QUNBQSxlOzs7Ozs7O0FDQUEsZTs7Ozs7OztBQ0FBLGUiLCJmaWxlIjoiZm9hbS5idW5kbGUuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG4vLyBQb2x5ZmlsbFxuXG4vLyBSZXF1aXJlZCBvbiBJRSAxMSwgQW5kcm9pZCBCcm93c2VyIGJlZm9yZSA1LjEuXG5pZiAoICEgTWF0aC50cnVuYyApIHtcbiAgTWF0aC50cnVuYyA9IGZ1bmN0aW9uIHRydW5jKHYpIHtcbiAgICByZXR1cm4gdiA+IDAgPyBNYXRoLmZsb29yKHYpIDogTWF0aC5jZWlsKHYpO1xuICB9O1xufVxuXG4vLyBSZXF1aXJlZCBvbiBJRSAxMSwgQW5kcm9pZCBCcm93c2VyIChhdCBsZWFzdCB0byA1LjEpLlxuaWYgKCAhIEFycmF5LmZyb20gKSB7XG4gIC8qKiBUdXJuIGFycmF5LWxpa2Ugb2JqZWN0cyBpbnRvIHJlYWwgYXJyYXlzLiAqKi9cbiAgQXJyYXkuZnJvbSA9IGZ1bmN0aW9uKGEpIHtcbiAgICB2YXIgYiA9IG5ldyBBcnJheShhLmxlbmd0aCk7XG4gICAgZm9yICggdmFyIGkgPSAwIDsgaSA8IGEubGVuZ3RoIDsgaSsrICkgYltpXSA9IGFbaV07XG4gICAgcmV0dXJuIGI7XG4gIH1cbn1cblxuLy8gUmVxdWlyZWQgb24gSUUgMTEsIEFuZHJvaWQgQnJvd3NlciAoYXQgbGVhc3QgdG8gNS4xKS5cbmlmICggISBBcnJheS5wcm90b3R5cGUuZmluZCApIHtcbiAgQXJyYXkucHJvdG90eXBlLmZpbmQgPSBmdW5jdGlvbihwcmVkaWNhdGUpIHtcbiAgICBpZiAoIHRoaXMgPT09IG51bGwgKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcnJheS5wcm90b3R5cGUuZmluZCBjYWxsZWQgb24gbnVsbCBvciB1bmRlZmluZWQnKTtcbiAgICB9XG4gICAgaWYgKCB0eXBlb2YgcHJlZGljYXRlICE9PSAnZnVuY3Rpb24nICkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigncHJlZGljYXRlIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuICAgIH1cbiAgICB2YXIgbGlzdCAgICA9IE9iamVjdCh0aGlzKTtcbiAgICB2YXIgbGVuZ3RoICA9IGxpc3QubGVuZ3RoID4+PiAwO1xuICAgIHZhciB0aGlzQXJnID0gYXJndW1lbnRzWzFdO1xuICAgIHZhciB2YWx1ZTtcblxuICAgIGZvciAoIHZhciBpID0gMCA7IGkgPCBsZW5ndGggOyBpKysgKSB7XG4gICAgICB2YWx1ZSA9IGxpc3RbaV07XG4gICAgICBpZiAoIHByZWRpY2F0ZS5jYWxsKHRoaXNBcmcsIHZhbHVlLCBpLCBsaXN0KSApIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfTtcbn1cblxuLy8gUmVxdWlyZWQgb24gSUUgMTEsIEFuZHJvaWQgQnJvd3NlciAoYXQgbGVhc3QgdG8gNS4xKS5cbmlmICggISBTdHJpbmcucHJvdG90eXBlLmVuZHNXaXRoICkge1xuICAvLyBPZmZpY2lhbCBwb2x5ZmlsbFxuICBTdHJpbmcucHJvdG90eXBlLmVuZHNXaXRoID0gZnVuY3Rpb24oc2VhcmNoU3RyaW5nLCBwb3NpdGlvbikge1xuICAgICAgdmFyIHN1YmplY3RTdHJpbmcgPSB0aGlzLnRvU3RyaW5nKCk7XG4gICAgICBpZiAoIHR5cGVvZiBwb3NpdGlvbiAhPT0gJ251bWJlcicgfHxcbiAgICAgICAgICAhIGlzRmluaXRlKHBvc2l0aW9uKSB8fFxuICAgICAgICAgIE1hdGguZmxvb3IocG9zaXRpb24pICE9PSBwb3NpdGlvbiB8fFxuICAgICAgICAgIHBvc2l0aW9uID4gc3ViamVjdFN0cmluZy5sZW5ndGggKSB7XG4gICAgICAgIHBvc2l0aW9uID0gc3ViamVjdFN0cmluZy5sZW5ndGg7XG4gICAgICB9XG4gICAgICBwb3NpdGlvbiAtPSBzZWFyY2hTdHJpbmcubGVuZ3RoO1xuICAgICAgdmFyIGxhc3RJbmRleCA9IHN1YmplY3RTdHJpbmcuaW5kZXhPZihzZWFyY2hTdHJpbmcsIHBvc2l0aW9uKTtcbiAgICAgIHJldHVybiBsYXN0SW5kZXggIT09IC0xICYmIGxhc3RJbmRleCA9PT0gcG9zaXRpb247XG4gIH07XG59XG5cbi8vIFJlcXVpcmVkIG9uIElFIDExLCBBbmRyb2lkIEJyb3dzZXIgKGF0IGxlYXN0IHRvIDUuMSkuXG5pZiAoICEgU3RyaW5nLnByb3RvdHlwZS5zdGFydHNXaXRoICkge1xuICBTdHJpbmcucHJvdG90eXBlLnN0YXJ0c1dpdGggPSBmdW5jdGlvbihzdHIsIHBvcykge1xuICAgIHJldHVybiB0aGlzLmluZGV4T2Yoc3RyKSA9PT0gMDtcbiAgfTtcbn1cblxuLy8gUmVxdWlyZWQgZm9yIElFIDExLlxuaWYgKCAhIE51bWJlci5pc0ludGVnZXIgKSB7XG4gIE51bWJlci5pc0ludGVnZXIgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInICYmXG4gICAgICAgIGlzRmluaXRlKHZhbHVlKSAmJlxuICAgICAgICBNYXRoLmZsb29yKHZhbHVlKSA9PT0gdmFsdWU7XG4gIH1cbn1cblxuaWYgKCAhIE9iamVjdC52YWx1ZXMgKSB7XG4gIE9iamVjdC52YWx1ZXMgPSBmdW5jdGlvbihvYmopIHtcbiAgICByZXR1cm4gT2JqZWN0LmtleXMob2JqKS5tYXAoZnVuY3Rpb24oaykgeyByZXR1cm4gb2JqW2tdOyB9KTtcbiAgfTtcbn1cblxuLy8gUmVxdWlyZWQgZm9yIElFIDExLlxuaWYoICEgT2JqZWN0LmlzICkge1xuICAvLyBGcm9tIEVTNiBzcGVjcywgYW5kIGFsc286XG4gIC8vIGh0dHBzOi8vZ2lzdC5naXRodWIuY29tL21hdHRoZXdwLzIwMzY0MjhcbiAgT2JqZWN0LmlzID0gZnVuY3Rpb24oeCwgeSkge1xuICAgIGlmICh4ID09PSB5KSB7XG4gICAgICAvLyAwID09PSAtMCwgYnV0IHRoZXkgYXJlIG5vdCBpZGVudGljYWxcbiAgICAgIHJldHVybiB4ICE9PSAwIHx8IDEgLyB4ID09PSAxIC8geTtcbiAgICB9XG5cbiAgICAvLyBOYU4gIT09IE5hTiwgYnV0IHRoZXkgYXJlIGlkZW50aWNhbC5cbiAgICAvLyBOYU5zIGFyZSB0aGUgb25seSBub24tcmVmbGV4aXZlIHZhbHVlLCBpLmUuLCBpZiB4ICE9PSB4LFxuICAgIC8vIHRoZW4geCBpcyBhIE5hTi5cbiAgICAvLyBpc05hTiBpcyBicm9rZW46IGl0IGNvbnZlcnRzIGl0cyBhcmd1bWVudCB0byBudW1iZXIsIHNvXG4gICAgLy8gaXNOYU4oXCJmb29cIikgPT4gdHJ1ZVxuICAgIHJldHVybiB4ICE9PSB4ICYmIHkgIT09IHk7XG4gIH07XG59XG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG4vKipcbiAqIFRvcC1MZXZlbCBvZiBmb2FtIHBhY2thZ2VcbiAqL1xuZm9hbSA9IHtcbiAgaXNTZXJ2ZXI6IHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnLFxuICBjb3JlOiAgICAge30sXG4gIG5leHQkVUlEOiAoZnVuY3Rpb24oKSB7XG4gICAgLyogUmV0dXJuIGEgdW5pcXVlIGlkLiAqL1xuICAgIHZhciBpZCA9IDE7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIG5leHQkVUlEKCkgeyByZXR1cm4gaWQrKzsgfTtcbiAgfSkoKVxufTtcblxuXG4vKiogU2V0dXAgbm9kZWpzLWxpa2UgJ2dsb2JhbCcgb24gd2ViICovXG5pZiAoICEgZm9hbS5pc1NlcnZlciApIGdsb2JhbCA9IHdpbmRvdztcblxuZ2xvYmFsLlNVUFBSRVNTRURfV0FSTklOR1MgPSBnbG9iYWwuU1VQUFJFU1NFRF9XQVJOSU5HUyB8fCB7fTtcbmdsb2JhbC5zdXBwcmVzc1dhcm5pbmdzID0gZnVuY3Rpb24gKGEpIHtcblxuICBhLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG4gICAgU1VQUFJFU1NFRF9XQVJOSU5HU1trZXldID0gdHJ1ZTtcbiAgfSlcbn1cblxuc3VwcHJlc3NXYXJuaW5ncyhbIGBTa2lwcGluZyBjb25zdGFudCBQQVJTRV9KU09OIHdpdGggdW5rbm93biB0eXBlLmAsXG4gIGBQcm9wZXJ0eSBmb2FtLmNvcmUuRk9iamVjdFByb3BlcnR5Lm9mIFwidmFsdWVcIiBoaWRkZW4gYnkgXCJnZXR0ZXJcImAsXG4gIGBVbmtub3duIHByb3BlcnR5IGZvYW0ubmFub3MubWVudS5EQU9NZW51LlhYWHN1bW1hcnlWaWV3OiBbb2JqZWN0IE9iamVjdF1gLFxuICBgSW1wb3J0IFwic2NyaXB0REFPXCIgYWxyZWFkeSBleGlzdHMgaW4gYW5jZXN0b3IgY2xhc3Mgb2YgZm9hbS5uYW5vcy50ZXN0LlRlc3QuYCxcbiAgYFVua25vd24gcHJvcGVydHkgZm9hbS5jb3JlLk1vZGVsLmphdmFUeXBlOiBmb2FtLmNvcmUuUHJvcGVydHlJbmZvYCxcbiAgYFByb3BlcnR5IGZvYW0uZGFvLmluZGV4LkluZGV4Lm5vZGVDbGFzcyBcImZhY3RvcnlcIiBoaWRkZW4gYnkgXCJnZXR0ZXJcImBcbl0pO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoXG4gIE9iamVjdC5wcm90b3R5cGUsXG4gICckVUlEJyxcbiAge1xuICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICBpZiAoICEgT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwodGhpcywgJyRVSURfXycpICYmXG4gICAgICAgICAgICEgT2JqZWN0LmlzRnJvemVuKHRoaXMpICkge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoXG4gICAgICAgICAgICB0aGlzLFxuICAgICAgICAgICAgJyRVSURfXycsXG4gICAgICAgICAgICB7dmFsdWU6IGZvYW0ubmV4dCRVSUQoKSwgZW51bWVyYWJsZTogZmFsc2V9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLiRVSURfXztcbiAgICB9LFxuICAgIGVudW1lcmFibGU6IGZhbHNlXG4gIH1cbik7XG5cblxuLyoqXG4gKiBEZWZpbmUgYW4gYXNzZXJ0aW9uIGZ1bmN0aW9uIHRoYXQgaXMgc2lnbmlmaWNhbnRseSBmYXN0ZXIgYW5kIG1vcmVcbiAqIGNvbXBhdGlibGUgdGhhbiBjb25zb2xlLmFzc2VydC4gIEFsc28gYWxsb3dzIHVzIHRvIHR1cm4gb2ZmIGFzc2VydGlvbnNcbiAqIGluIGEgcHJvZHVjdGlvbiBzY2VuYXJpby5cbiAqXG4gKiBVc2FnZSBvZiBjb25zb2xlLmFzc2VydCBkaXJlY3RseSBpcyBzbG93LCBhbmQgbm90IGFsbCBwbGF0Zm9ybXMgYWdyZWVcbiAqIG9uIHdoYXQgdG8gZG8gd2l0aCBleHRyYSBhcmd1bWVudHMsIHNvbWUgaWdub3JlIHRoZW0sIHNvbWUgam9pbiB0aGVtXG4gKiB0byB0aGUgbWVzc2FnZS5cbiAqL1xuZm9hbS5hc3NlcnQgPSBmdW5jdGlvbiBhc3NlcnQoY29uZCkge1xuICBpZiAoICEgY29uZCApIHtcbi8vICAgIHRocm93IG5ldyBFcnJvcihBcnJheS5mcm9tKGFyZ3VtZW50cykuc2xpY2UoMSkuam9pbignICcpKTtcbiAgICBjb25zb2xlLmFzc2VydChmYWxzZSwgQXJyYXkuZnJvbShhcmd1bWVudHMpLnNsaWNlKDEpLmpvaW4oJyAnKSk7XG5cbiAgfVxuXG4gIHJldHVybiBjb25kO1xufTtcblxuXG4vKipcbiAqIENyZWF0ZXMgYSBzbWFsbCBsaWJyYXJ5IGluIHRoZSBmb2FtIHBhY2thZ2UuIEEgTElCIGlzIGEgY29sbGVjdGlvbiBvZlxuICogY29uc3RhbnRzIGFuZCBzdGF0aWMgbWV0aG9kcy5cbiAqIDxwcmU+XG5mb2FtLkxJQih7XG4gIG5hbWU6ICduZXR3b3JrJyxcbiAgY29uc3RhbnRzOiB7XG4gICAgUE9SVDogNDAwMFxuICB9LFxuICBtZXRob2RzOiBbIGZ1bmN0aW9uIHNlbmRQYWNrZXQoKSB7IC4uLiB9ICBdXG59KTtcbjwvcHJlPlxuUHJvZHVjZXMgPGNvZGU+Zm9hbS5uZXR3b3JrPC9jb2RlPjpcbjxwcmU+XG5jb25zb2xlLmxvZyhmb2FtLm5ldHdvcmsuUE9SVCk7IC8vIG91dHB1dHMgNDAwMFxuZm9hbS5uZXR3b3JrLnNlbmRQYWNrZXQoKTtcbjwvcHJlPlxuICogQG1ldGhvZCBMSUJcbiAqIEBtZW1iZXJvZiBtb2R1bGU6Zm9hbVxuICovXG5mb2FtLkxJQiA9IGZ1bmN0aW9uIExJQihtb2RlbCkge1xuICB2YXIgcm9vdCA9IGdsb2JhbDtcbiAgdmFyIHBhdGggPSBtb2RlbC5uYW1lLnNwbGl0KCcuJyk7XG4gIHZhciBpO1xuXG4gIGZvciAoIGkgPSAwIDsgaSA8IHBhdGgubGVuZ3RoIDsgaSsrICkge1xuICAgIHJvb3QgPSByb290W3BhdGhbaV1dIHx8ICggcm9vdFtwYXRoW2ldXSA9IHt9ICk7XG4gIH1cblxuICAvLyBEdXJpbmcgYm9vdCwga2VlcCBhIGxpc3Qgb2YgY3JlYXRlZCBMSUJzXG4gIGlmICggZ2xvYmFsLmZvYW0uX19MSUJTX18gKSBnbG9iYWwuZm9hbS5fX0xJQlNfX1ttb2RlbC5uYW1lXSA9IHJvb3Q7XG5cbiAgaWYgKCBtb2RlbC5jb25zdGFudHMgKSB7XG4gICAgZm9hbS5hc3NlcnQoXG4gICAgICB0eXBlb2YgbW9kZWwuY29uc3RhbnRzID09PSAnb2JqZWN0JyxcbiAgICAgICdDb25zdGFudHMgbXVzdCBiZSBhIG1hcC4nKTtcblxuICAgIGZvciAoIHZhciBrZXkgaW4gbW9kZWwuY29uc3RhbnRzICkgcm9vdFtrZXldID0gbW9kZWwuY29uc3RhbnRzW2tleV07XG4gIH1cblxuICBpZiAoIG1vZGVsLm1ldGhvZHMgKSB7XG4gICAgZm9hbS5hc3NlcnQoQXJyYXkuaXNBcnJheShtb2RlbC5tZXRob2RzKSwgJ01ldGhvZHMgbXVzdCBiZSBhbiBhcnJheS4nKTtcblxuICAgIGZvciAoIGkgPSAwIDsgaSA8IG1vZGVsLm1ldGhvZHMubGVuZ3RoIDsgaSsrICkge1xuICAgICAgdmFyIG0gPSBtb2RlbC5tZXRob2RzW2ldO1xuXG4gICAgICBmb2FtLmFzc2VydChcbiAgICAgICAgdHlwZW9mIG0gPT09ICdvYmplY3QnIHx8IHR5cGVvZiBtID09PSAnZnVuY3Rpb24nLFxuICAgICAgICAnTWV0aG9kcyBtdXN0IGJlIGEgbWFwIG9mIGEgZnVuY3Rpb24nKTtcblxuICAgICAgZm9hbS5hc3NlcnQoXG4gICAgICAgICB0eXBlb2YgbSAhPT0gJ29iamVjdCcgfHwgdHlwZW9mIG0uY29kZSA9PT0gJ2Z1bmN0aW9uJyxcbiAgICAgICAgJ01ldGhvZHMgbXVzdCBoYXZlIGEgY29kZSBrZXkgd2hpY2ggaXMgYSBmdW5jdGlvbicpO1xuXG4gICAgICB2YXIgbmFtZSA9IG0ubmFtZSB8fCBmb2FtLkZ1bmN0aW9uLmdldE5hbWUobSk7XG4gICAgICBmb2FtLmFzc2VydChuYW1lLCAnTWV0aG9kcyBtdXN0IGJlIG5hbWVkIHdpdGggYSBub24tZW1wdHkgc3RyaW5nJyk7XG5cbiAgICAgIHJvb3RbbmFtZV0gPSBtLmNvZGUgfHwgbTtcbiAgICB9XG4gIH1cbn07XG5nbG9iYWwuZm9hbS5fX0xJQlNfXyA9IHt9O1xuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTYgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgJ0xpY2Vuc2UnKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiAnQVMgSVMnIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG4vLyBUaGlzIG11c3QgYmUgZGVjbGFyZWQgYXMgdGhlIGZpcnN0IGZvYW0uTElCKCkgdXNpbmcgeyBuYW1lOiAuLi4sIGNvZGU6IC4uLiB9XG4vLyBtZXRob2Qgc3ludGF4IGJlY2F1c2UgZm9hbS5MSUIoKSBtYXkgaW52b2tlIGZvYW0uRnVuY3Rpb24uZ2V0TmFtZSgpIG9uXG4vLyBtZXRob2RzIGRlY2xhcmVkIHVzaW5nIGZ1bmN0aW9uIG1ldGhvZE5hbWUoLi4uKSB7IC4uLiB9LlxuZm9hbS5MSUIoe1xuICBuYW1lOiAnZm9hbS5GdW5jdGlvbicsXG5cbiAgbWV0aG9kczogW1xuICAgIHtcbiAgICAgIG5hbWU6ICdnZXROYW1lJyxcbiAgICAgIGNvZGU6IChmdW5jdGlvbiBuYW1lZCgpIHt9KS5uYW1lID09PSAnbmFtZWQnID9cbiAgICAgICAgICBmdW5jdGlvbihtZXRob2QpIHsgcmV0dXJuIG1ldGhvZC5uYW1lOyB9IDpcbiAgICAgICAgICBmdW5jdGlvbihtZXRob2QpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgbWV0aG9kICE9PSAnZnVuY3Rpb24nKSByZXR1cm4gbWV0aG9kLm5hbWU7XG5cbiAgICAgICAgICAgIC8vIElFMTEgZG9lcyBub3Qgc3VwcG9ydCBuYW1lZCBmdW5jdGlvbnMuIEV4dHJhY3QgbmFtZSB3aXRoXG4gICAgICAgICAgICAvLyBmLnRvU3RyaW5nKCkuXG4gICAgICAgICAgICB2YXIgbWF0Y2ggPSBtZXRob2QudG9TdHJpbmcoKS5cbiAgICAgICAgICAgICAgICBtYXRjaCgvXmZ1bmN0aW9uXFxzKyhbQS1aYS16XyRdWzAtOUEtWmEtel8kXSopXFxzKlxcKC8pO1xuICAgICAgICAgICAgZm9hbS5hc3NlcnQobWF0Y2gsICdVbmFibGUgdG8gZGVkdWNlIG1ldGhvZCBuYW1lIGZyb20gZnVuY3Rpb24nKTtcbiAgICAgICAgICAgIHJldHVybiBtYXRjaFsxXTtcbiAgICAgICAgICB9XG4gICAgfVxuICBdXG59KTtcblxuLyoqXG4gIFJhdGhlciB0aGFuIGV4dGVuZGluZyBidWlsdC1pbiBwcm90b3R5cGVzLCB3ZSBjcmVhdGUgZmx5d2VpZ2h0IHZlcnNpb25zLlxuXG4gIFRoaXMgaGFzIGEgbnVtYmVyIG9mIGFkdmFudGFnZXM6XG4gIDEuIEl0IGF2b2lkcyBjb25mbGljdHMgd2l0aCBvdGhlciBsaWJyYXJpZXMgd2hpY2ggbWlnaHQgYWxzbyBleHRlbmQgYnVpbHQtaW5cbiAgICAgdHlwZXMgd2l0aCBtZXRob2RzIHdpdGggdGhlIHNhbWUgbmFtZXMgYnV0IGRpZmZlcmVudCBzZW1hbnRpY3MuXG4gIDIuIEl0IGlzID4xMFggZmFzdGVyIChpbiBWOCkgdG8gY2FsbCBhIGZseXdlaWdodCBtZXRob2QgdGhhbiBhIE1ldGhvZCBhZGRlZFxuICAgICB0byB0aGUgcHJvdG90eXBlcyBvZiBTdHJpbmcgb3IgTnVtYmVyLiBUaGlzIGlzIGJlY2F1c2UgY2FsbGluZyBhbiBhZGRlZFxuICAgICBtZXRob2Qgb24gdGhvc2UgdHlwZXMgcHJvbW90ZXMgdGhlIG9iamVjdCBmcm9tIGEgcHJpbWl0aXZlIHN0cmluZyBvciBudW1iZXJcbiAgICAgdG8gYSBTdHJpbmcgb3IgTnVtYmVyIG9iamVjdC4gIENyZWF0aW5nIHRoZSBvYmplY3QgdGFrZXMgdGltZSBhbmQgY3JlYXRlcyBhXG4gICAgIG5ldyBvYmplY3QgdGhhdCB3aWxsIG5lZWQgdG8gYmUgR0MnZWQuXG4gIDMuIEl0IGxldHMgdXMgZWZmZWN0aXZlbHkgYWRkIG1ldGhvZHMgdG8gYnVpbHQtaW4gc3BlY2lhbCB2YWx1ZXMgbGlrZVxuICAgICB0cnVlLCBmYWxzZSwgbnVsbCwgYW5kIHVuZGVmaW5lZC4gVGhpcyBhdm9pZHMgdGhlIG5lZWQgZm9yIG51bGwtcG9pbnRlclxuICAgICBjaGVja3MuXG4gIDQuIEl0IGF2b2lkcyB0aGUgcHJvbGlmZXJhdGlvbiBvZiBsYXJnZSA9PT0vdHlwZW9mL2lzSW5zdGFuY2UvaW5zdGFuY2VvZiBibG9ja3NcbiAgICAgdGhyb3VnaG91dCB0aGUgcmVzdCBvZiB0aGUgY29kZS5cbiAgNS4gSXQgcHJvdmlkZXMgYSBjb25zaXN0ZW50IG1ldGhvZCBmb3IgY2hlY2tpbmcgYW4gb2JqZWN0J3MgdHlwZSwgc2luY2UgZWFjaFxuICAgICB0eXBlIGZseXdlaWdodCBoYXMgYW4gLmlzSW5zdGFuY2UoKSBtZXRob2Qgd2hpY2ggYWJzdHJhY3RzIHRoZSB1bmRlcmx5aW5nIGRldGVjdGlvblxuICAgICBtZWNoYW5pc20uXG4gIDYuIEl0IG1ha2VzIHRoZSBmdXR1cmUgaW1wbGVtZW50YXRpb24gb2YgbXVsdGktbWV0aG9kcyBtdWNoIGVhc2llci5cbiovXG5cbi8qKlxuICogRWFjaCBvZiB0aGVzZSBmbHl3ZWlnaHQgdHlwZXMgZm9sbG93cyBhIHN0YW5kYXJkIGludGVyZmFjZS5cbiAqXG4gKiA8cHJlPlxuICogaW50ZXJmYWNlIFR5cGUge1xuICogICAvLyBSZXR1cm5zIHRydWUgaWYgdGhlIGdpdmVuIG9iamVjdCBpcyBvZiB0aGlzIHR5cGUuXG4gKiAgIC8vIGV4YW1wbGU6IGZvYW0uU3RyaW5nLmlzSW5zdGFuY2UoJ2hlbGxvJykgLT4gdHJ1ZVxuICogICBpc0luc3RhbmNlKG8pIC0+IEJvb2xlYW5cbiAqXG4gKiAgIC8vIFJldHVybnMgYSBkZWVwIGNsb25lIG9mIG8sIGlmIHRoZSB0eXBlIHN1cHBvcnRzIGl0LlxuICogICBjbG9uZShvKTtcbiAqXG4gKiAgIC8vIFJldHVybnMgdHJ1ZSBpZiBhIGFuZCBiIGFyZSBlcXVpdmFsZW50LlxuICogICBlcXVhbHMoYSwgYikgLT4gQm9vbGVhblxuICpcbiAqICAgLy8gUmV0dXJucyAtMSwgMCBvciAxIGFzIGEgY29tcGFyc2lvbiBvZiB0aGUgdHdvIHR5cGVzLlxuICogICAvLyAtMSBtZWFucyB0aGF0ICdhJyBpcyBjb25zaWRlcmVkIHNtYWxsZXIgdGhhdCAnYidcbiAqICAgLy8gMCBtZWFucyB0aGF0IGFuZCAnYScgYW5kICdiJyBhcmUgY29uc2lkZXJlZCBlcXVpdmFsZW50XG4gKiAgIC8vIDEgbWVhbnMgdGhhdCAnYScgaXMgY29uc2lkZXJlZCBsYXJnZXIgdGhhbiAnYidcbiAqICAgY29tcGFyZShhLCBiKSAtPiBJbnRcbiAqXG4gKiAgIC8vIFJldHVybnMgYSBoYXNoIG9mICdhJyB1c2VmdWwgZm9yIGhhc2ggdGFibGVzXG4gKiAgIGhhc2hDb2RlKGEpIC0+IEludFxuICpcbiAqICAgLy8gUmV0dXJucyB0cnVlIGlmIHRoZSB0d28gdmFsdWVzIGFyZSB0aGUgc2FtZSBpbnN0YW5jZVxuICogICAvLyBvciB0aGUgc2FtZSB2YWx1ZSBmb3IgcHJpbWl0aXZlIHR5cGVzLlxuICogICBpcyhhLCBiKSAtPiBCb29sZWFuXG4gKiB9XG4gKi9cblxuZm9hbS5MSUIoe1xuICBuYW1lOiAnZm9hbS5VbmRlZmluZWQnLFxuICBtZXRob2RzOiBbXG4gICAgZnVuY3Rpb24gaXNJbnN0YW5jZShvKSB7IHJldHVybiBvID09PSB1bmRlZmluZWQ7IH0sXG4gICAgZnVuY3Rpb24gaXMoYSwgYikgeyByZXR1cm4gYiA9PT0gdW5kZWZpbmVkOyB9LFxuICAgIGZ1bmN0aW9uIGNsb25lKG8pIHsgcmV0dXJuIG87IH0sXG4gICAgZnVuY3Rpb24gZXF1YWxzKF8sIGIpIHsgcmV0dXJuIGIgPT09IHVuZGVmaW5lZDsgfSxcbiAgICBmdW5jdGlvbiBjb21wYXJlKF8sIGIpIHsgcmV0dXJuIGIgPT09IHVuZGVmaW5lZCA/IDAgOiAxOyB9LFxuICAgIGZ1bmN0aW9uIGhhc2hDb2RlKCkgeyByZXR1cm4gLTI7IH1cbiAgXVxufSk7XG5cblxuZm9hbS5MSUIoe1xuICBuYW1lOiAnZm9hbS5OdWxsJyxcbiAgbWV0aG9kczogW1xuICAgIGZ1bmN0aW9uIGlzSW5zdGFuY2UobykgeyByZXR1cm4gbyA9PT0gbnVsbDsgfSxcbiAgICBmdW5jdGlvbiBpcyhhLCBiKSB7IHJldHVybiBiID09PSBudWxsOyB9LFxuICAgIGZ1bmN0aW9uIGNsb25lKG8pIHsgcmV0dXJuIG87IH0sXG4gICAgZnVuY3Rpb24gZXF1YWxzKF8sIGIpIHsgcmV0dXJuIGIgPT09IG51bGw7IH0sXG4gICAgZnVuY3Rpb24gY29tcGFyZShfLCBiKSB7IHJldHVybiBiID09PSBudWxsID8gMCA6IDE7IH0sXG4gICAgZnVuY3Rpb24gaGFzaENvZGUoKSB7IHJldHVybiAtMzsgfVxuICBdXG59KTtcblxuXG5mb2FtLkxJQih7XG4gIG5hbWU6ICdmb2FtLkJvb2xlYW4nLFxuICBtZXRob2RzOiBbXG4gICAgZnVuY3Rpb24gaXNJbnN0YW5jZShvKSB7IHJldHVybiB0eXBlb2YgbyA9PT0gJ2Jvb2xlYW4nOyB9LFxuICAgIGZ1bmN0aW9uIGlzKGEsIGIpIHsgcmV0dXJuIGEgPT09IGI7IH0sXG4gICAgZnVuY3Rpb24gY2xvbmUobykgeyByZXR1cm4gbzsgfSxcbiAgICBmdW5jdGlvbiBlcXVhbHMoYSwgYikgeyByZXR1cm4gYSA9PT0gYjsgfSxcbiAgICBmdW5jdGlvbiBjb21wYXJlKGEsIGIpIHtcbiAgICAgIGlmICggISBmb2FtLkJvb2xlYW4uaXNJbnN0YW5jZShiKSApIHJldHVybiAxO1xuICAgICAgcmV0dXJuIGEgPyAoYiA/IDAgOiAxKSA6IChiID8gLTEgOiAwKTtcbiAgICB9LFxuICAgIGZ1bmN0aW9uIGhhc2hDb2RlKG8pIHsgcmV0dXJuIG8gPyAxIDogLTE7IH1cbiAgXVxufSk7XG5cblxuZm9hbS5MSUIoe1xuICBuYW1lOiAnZm9hbS5GdW5jdGlvbicsXG4gIG1ldGhvZHM6IFtcbiAgICBmdW5jdGlvbiBpc0luc3RhbmNlKG8pIHsgcmV0dXJuIHR5cGVvZiBvID09PSAnZnVuY3Rpb24nOyB9LFxuICAgIGZ1bmN0aW9uIGlzKGEsIGIpIHsgcmV0dXJuIGEgPT09IGIgfSxcbiAgICBmdW5jdGlvbiBjbG9uZShvKSB7IHJldHVybiBvOyB9LFxuICAgIGZ1bmN0aW9uIGVxdWFscyhhLCBiKSB7IHJldHVybiBiID8gYS50b1N0cmluZygpID09PSBiLnRvU3RyaW5nKCkgOiBmYWxzZTsgfSxcbiAgICBmdW5jdGlvbiBjb21wYXJlKGEsIGIpIHtcbiAgICAgIGlmICggISBmb2FtLkZ1bmN0aW9uLmlzSW5zdGFuY2UoYikgKSByZXR1cm4gMTtcbiAgICAgIHJldHVybiBiID8gZm9hbS5TdHJpbmcuY29tcGFyZShhLnRvU3RyaW5nKCksIGIudG9TdHJpbmcoKSkgOiAgMTtcbiAgICB9LFxuICAgIGZ1bmN0aW9uIGhhc2hDb2RlKG8pIHsgcmV0dXJuIGZvYW0uU3RyaW5nLmhhc2hDb2RlKG8udG9TdHJpbmcoKSk7IH0sXG5cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIGZ1bmN0aW9uIGJpbmQoZiwgdGhhdCwgYTEsIGEyLCBhMywgYTQpIHtcbiAgICAgIC8qKlxuICAgICAgICogRmFzdGVyIHRoYW4gRnVuY3Rpb24ucHJvdG90eXBlLmJpbmRcbiAgICAgICAqL1xuICAgICAgc3dpdGNoICggYXJndW1lbnRzLmxlbmd0aCApIHtcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ05vIGFyZ3VtZW50cyBnaXZlbiB0byBiaW5kIHRvLicpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDI6IHJldHVybiBmdW5jdGlvbigpIHsgcmV0dXJuIGYuYXBwbHkodGhhdCwgYXJndW1lbnRzKTsgfTtcbiAgICAgICAgY2FzZSAzOiByZXR1cm4gZnVuY3Rpb24oYjEsIGIyLCBiMywgYjQpIHtcbiAgICAgICAgICBzd2l0Y2ggKCBhcmd1bWVudHMubGVuZ3RoICkge1xuICAgICAgICAgICAgY2FzZSAwOiByZXR1cm4gZi5jYWxsKHRoYXQsIGExKTtcbiAgICAgICAgICAgIGNhc2UgMTogcmV0dXJuIGYuY2FsbCh0aGF0LCBhMSwgYjEpO1xuICAgICAgICAgICAgY2FzZSAyOiByZXR1cm4gZi5jYWxsKHRoYXQsIGExLCBiMSwgYjIpO1xuICAgICAgICAgICAgY2FzZSAzOiByZXR1cm4gZi5jYWxsKHRoYXQsIGExLCBiMSwgYjIsIGIzKTtcbiAgICAgICAgICAgIGNhc2UgNDogcmV0dXJuIGYuY2FsbCh0aGF0LCBhMSwgYjEsIGIyLCBiMywgYjQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgY2FzZSA0OiByZXR1cm4gZnVuY3Rpb24oYjEsIGIyLCBiMywgYjQpIHtcbiAgICAgICAgICBzd2l0Y2ggKCBhcmd1bWVudHMubGVuZ3RoICkge1xuICAgICAgICAgICAgY2FzZSAwOiByZXR1cm4gZi5jYWxsKHRoYXQsIGExLCBhMik7XG4gICAgICAgICAgICBjYXNlIDE6IHJldHVybiBmLmNhbGwodGhhdCwgYTEsIGEyLCBiMSk7XG4gICAgICAgICAgICBjYXNlIDI6IHJldHVybiBmLmNhbGwodGhhdCwgYTEsIGEyLCBiMSwgYjIpO1xuICAgICAgICAgICAgY2FzZSAzOiByZXR1cm4gZi5jYWxsKHRoYXQsIGExLCBhMiwgYjEsIGIyLCBiMyk7XG4gICAgICAgICAgICBjYXNlIDQ6IHJldHVybiBmLmNhbGwodGhhdCwgYTEsIGEyLCBiMSwgYjIsIGIzLCBiNCk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBjYXNlIDU6IHJldHVybiBmdW5jdGlvbihiMSwgYjIsIGIzLCBiNCkge1xuICAgICAgICAgIHN3aXRjaCAoIGFyZ3VtZW50cy5sZW5ndGggKSB7XG4gICAgICAgICAgICBjYXNlIDA6IHJldHVybiBmLmNhbGwodGhhdCwgYTEsIGEyLCBhMyk7XG4gICAgICAgICAgICBjYXNlIDE6IHJldHVybiBmLmNhbGwodGhhdCwgYTEsIGEyLCBhMywgYjEpO1xuICAgICAgICAgICAgY2FzZSAyOiByZXR1cm4gZi5jYWxsKHRoYXQsIGExLCBhMiwgYTMsIGIxLCBiMik7XG4gICAgICAgICAgICBjYXNlIDM6IHJldHVybiBmLmNhbGwodGhhdCwgYTEsIGEyLCBhMywgYjEsIGIyLCBiMyk7XG4gICAgICAgICAgICBjYXNlIDQ6IHJldHVybiBmLmNhbGwodGhhdCwgYTEsIGEyLCBhMywgYjEsIGIyLCBiMywgYjQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgY2FzZSA2OiByZXR1cm4gZnVuY3Rpb24oYjEsIGIyLCBiMywgYjQpIHtcbiAgICAgICAgICBzd2l0Y2ggKCBhcmd1bWVudHMubGVuZ3RoICkge1xuICAgICAgICAgICAgY2FzZSAwOiByZXR1cm4gZi5jYWxsKHRoYXQsIGExLCBhMiwgYTMsIGE0KTtcbiAgICAgICAgICAgIGNhc2UgMTogcmV0dXJuIGYuY2FsbCh0aGF0LCBhMSwgYTIsIGEzLCBhNCwgYjEpO1xuICAgICAgICAgICAgY2FzZSAyOiByZXR1cm4gZi5jYWxsKHRoYXQsIGExLCBhMiwgYTMsIGE0LCBiMSwgYjIpO1xuICAgICAgICAgICAgY2FzZSAzOiByZXR1cm4gZi5jYWxsKHRoYXQsIGExLCBhMiwgYTMsIGE0LCBiMSwgYjIsIGIzKTtcbiAgICAgICAgICAgIGNhc2UgNDogcmV0dXJuIGYuY2FsbCh0aGF0LCBhMSwgYTIsIGEzLCBhNCwgYjEsIGIyLCBiMywgYjQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgY29uc29sZS5lcnJvcignQXR0ZW1wdCB0byBmb2FtLkZ1bmN0aW9uLmJpbmQgbW9yZSB0aGFuIDQgYXJndW1lbnRzLicpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBEZWNvcmF0ZXMgdGhlIGZ1bmN0aW9uICdmJyB0byBjYWNoZSB0aGUgcmV0dXJuIHZhbHVlIG9mICdmJyB3aGVuXG4gICAgICogY2FsbGVkIGluIHRoZSBmdXR1cmUuIEFsc28ga25vd24gYXMgYSAndGh1bmsnLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1lbW9pemUwKC8qIEZ1bmN0aW9uICovIGYpIHtcbiAgICAgIHZhciBzZXQgPSBmYWxzZSwgY2FjaGU7XG4gICAgICB2YXIgcmV0ID0gZm9hbS5GdW5jdGlvbi5zZXROYW1lKFxuICAgICAgICAgIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgaWYgKCAhIHNldCApIHtcbiAgICAgICAgICAgICAgc2V0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgY2FjaGUgPSBmKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gY2FjaGU7XG4gICAgICAgICAgfSxcbiAgICAgICAgICAnbWVtb2l6ZTAoJyArIGYubmFtZSArICcpJyk7XG4gICAgICByZXQudG9TdHJpbmcgPSBmdW5jdGlvbigpIHsgcmV0dXJuIGYudG9TdHJpbmcoKTsgfTtcbiAgICAgIHJldHVybiByZXQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIERlY29yYXRlcyB0aGUgZnVuY3Rpb24gJ2YnIHRvIGNhY2hlIHRoZSByZXR1cm4gdmFsdWUgb2YgJ2YnIHdoZW4gY2FsbGVkXG4gICAgICogd2l0aCBhIHBhcnRpY3VsYXIgdmFsdWUgZm9yIGl0cyBmaXJzdCBhcmd1bWVudC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtZW1vaXplMSgvKiBGdW5jdGlvbiAqLyBmKSB7XG4gICAgICB2YXIgY2FjaGUgPSB7fSwgbnVsbENhY2hlLCB1bmRlZmluZWRDYWNoZTtcbiAgICAgIHZhciByZXQgPSBmb2FtLkZ1bmN0aW9uLnNldE5hbWUoXG4gICAgICAgICAgZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgICAgICBmb2FtLmFzc2VydChcbiAgICAgICAgICAgICAgICBhcmd1bWVudHMubGVuZ3RoID09PSAxLFxuICAgICAgICAgICAgICAgICdNZW1vaXplMVxcJ2VkIGZ1bmN0aW9ucyBtdXN0IHRha2UgZXhhY3RseSBvbmUgYXJndW1lbnQuJyk7XG5cbiAgICAgICAgICAgIHZhciBtS2V5ID1cbiAgICAgICAgICAgICAgICBrZXkgPT09IG51bGwgICAgICA/ICdfX19udWxsX19fJyAgICAgIDpcbiAgICAgICAgICAgICAgICBrZXkgPT09IHVuZGVmaW5lZCA/ICdfX191bmRlZmluZWRfX18nIDpcbiAgICAgICAgICAgICAgICBrZXkgO1xuXG4gICAgICAgICAgICBpZiAoICEgY2FjaGUuaGFzT3duUHJvcGVydHkobUtleSkgKSBjYWNoZVttS2V5XSA9IGYuY2FsbCh0aGlzLCBrZXkpO1xuXG4gICAgICAgICAgICByZXR1cm4gY2FjaGVbbUtleV07XG4gICAgICAgICAgfSxcbiAgICAgICAgICAnbWVtb2l6ZTEoJyArIGYubmFtZSArICcpJyk7XG4gICAgICAgIHJldC50b1N0cmluZyA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gZi50b1N0cmluZygpOyB9O1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZXQgYSBmdW5jdGlvbidzIG5hbWUgZm9yIGltcHJvdmVkIGRlYnVnZ2luZyBhbmQgcHJvZmlsaW5nXG4gICAgICpcbiAgICAgKiBSZXR1cm5zIHRoZSBnaXZlbiBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzZXROYW1lKGYsIG5hbWUpIHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShmLCAnbmFtZScsIHsgdmFsdWU6IG5hbWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9KTtcbiAgICAgIHJldHVybiBmO1xuICAgIH0sXG5cbiAgICAvKiogQ29udmVuaWVuY2UgbWV0aG9kIHRvIGFwcGVuZCAnYXJndW1lbnRzJyBvbnRvIGEgcmVhbCBhcnJheSAqKi9cbiAgICBmdW5jdGlvbiBhcHBlbmRBcmd1bWVudHMoYSwgYXJncywgc3RhcnQpIHtcbiAgICAgIHN0YXJ0ID0gc3RhcnQgfHwgMDtcbiAgICAgIGZvciAoIHZhciBpID0gc3RhcnQgOyBpIDwgYXJncy5sZW5ndGggOyBpKysgKSBhLnB1c2goYXJnc1tpXSk7XG4gICAgICByZXR1cm4gYTtcbiAgICB9LFxuXG4gICAgLyoqIEZpbmRzIHRoZSBmdW5jdGlvbiguLi4pIGRlY2xhcmF0aW9uIGFyZ3VtZW50cyBwYXJ0LiBTdHJpcHMgbmV3bGluZXMuICovXG4gICAgZnVuY3Rpb24gYXJnc1N0cihmKSB7XG4gICAgICB2YXIgc3RyID0gZi5cbiAgICAgICAgICB0b1N0cmluZygpLlxuICAgICAgICAgIHJlcGxhY2UoLyhcXHJcXG58XFxufFxccikvZ20sJycpO1xuICAgICAgdmFyIGlzQXJyb3dGdW5jdGlvbiA9ICEvKGFzeW5jICk/ZnVuY3Rpb24vLnRlc3Qoc3RyKTtcblxuICAgICAgdmFyIG1hdGNoID0gaXNBcnJvd0Z1bmN0aW9uID9cbiAgICAgICAgICAvLyAoLi4uYXJncy4uLikgPT4gLi4uXG4gICAgICAgICAgLy8gb3JcbiAgICAgICAgICAvLyBhcmcgPT4gLi4uXG4gICAgICAgICAgbWF0Y2ggPSBzdHIubWF0Y2goL14oXFwoKFteKV0qKVxcKVtePV0qfChbXj1dKykpPT4vKSA6XG4gICAgICAgICAgLy8gZnVuY3Rpb24gKC4uLmFyZ3MuLi4pIHsgLi4uYm9keS4uLiB9XG4gICAgICAgICAgbWF0Y2ggPSBzdHIubWF0Y2goL14oYXN5bmMgKT9mdW5jdGlvbihcXHMrW18kXFx3XSt8XFxzKilcXCgoLio/KVxcKS8pO1xuXG4gICAgICBpZiAoICEgbWF0Y2ggKSB7XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJmb2FtLkZ1bmN0aW9uLmFyZ3NTdHIgY291bGQgbm90IHBhcnNlIGlucHV0IGZ1bmN0aW9uOlxcblwiICsgKCBmID8gZi50b1N0cmluZygpIDogJ3VuZGVmaW5lZCcgKSApO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gaXNBcnJvd0Z1bmN0aW9uID8gKG1hdGNoWzJdIHx8IG1hdGNoWzFdIHx8ICcnKSA6IChtYXRjaFszXSB8fCAnJyk7XG4gICAgfSxcblxuICAgIGZ1bmN0aW9uIGFyZ05hbWVzKGYpIHtcbiAgICAgIC8qKlxuICAgICAgICogUmV0dXJuIGEgZnVuY3Rpb24ncyBhcmd1bWVudHMgYXMgYW4gYXJyYXkuXG4gICAgICAgKiBFeC4gYXJnTmFtZXMoZnVuY3Rpb24oYSxiKSB7Li4ufSkgPT09IFsnYScsICdiJ11cbiAgICAgICAqKi9cbiAgICAgIHZhciBhcmdzID0gZm9hbS5GdW5jdGlvbi5hcmdzU3RyKGYpO1xuICAgICAgYXJncyArPSAnLCc7XG5cbiAgICAgIHZhciByZXQgPSBbXTtcbiAgICAgIC8vIFsgd3MgLyogYW55dGhpbmcgKi8gXSB3cyBbLi4uXWFyZ19uYW1lIHdzIFsgLyogYW55dGhpbmcgKi8gXSxcbiAgICAgIHZhciBhcmdNYXRjaGVyID0gLyhcXHMqXFwvXFwqLio/XFwqXFwvKT9cXHMqKCg/OlxcLlxcLlxcLik/W1xcd18kXSspXFxzKihcXC9cXCouKj9cXCpcXC8pP1xccypcXCwrL2c7XG4gICAgICB2YXIgdHlwZU1hdGNoO1xuICAgICAgd2hpbGUgKCAoIHR5cGVNYXRjaCA9IGFyZ01hdGNoZXIuZXhlYyhhcmdzKSApICE9PSBudWxsICkge1xuICAgICAgICByZXQucHVzaCh0eXBlTWF0Y2hbMl0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJldDtcbiAgICB9LFxuXG4gICAgLyoqIEZpbmRzIHRoZSBmdW5jdGlvbiguLi4pIGRlY2xhcmF0aW9uIGFuZCBmaW5kcyB0aGUgZmlyc3QgYmxvY2sgY29tbWVudFxuICAgICAgaW4gdGhlIGZ1bmN0aW9uIGJvZHkuICovXG4gICAgZnVuY3Rpb24gZnVuY3Rpb25Db21tZW50KGYpIHtcbiAgICAgIHZhciBtYXRjaCA9IGYuXG4gICAgICAgICAgdG9TdHJpbmcoKS5cbiAgICAgICAgICByZXBsYWNlKC9cXG4vZywgJ18jXyVfJV8nKS4gLy8gZmFrZSBuZXdsaW5lc1xuICAgICAgICAgIG1hdGNoKC9eZnVuY3Rpb24oXFxzK1tfJFxcd10rfFxccyopXFwoLio/XFwpKD86XFxfXFwjXFxfXFwlXFxfXFwlXFxffFxccykqXFx7KD86XFxfXFwjXFxfXFwlXFxfXFwlXFxffFxccykqXFwvXFwqXFwqP1xccyooLio/KVxcKj9cXCpcXC8uKlxcfS8pO1xuICAgICAgaWYgKCAhIG1hdGNoICkge1xuICAgICAgICByZXR1cm4gJyc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gbWF0Y2hbMl0gJiYgbWF0Y2hbMl0ucmVwbGFjZSgvXyNfJV8lXy9nLCAnXFxuJykgfHwgJyc7XG4gICAgICB9XG4gICAgfSxcblxuICAgIGZ1bmN0aW9uIGJyZWFrZG93bihmKSB7XG4gICAgICB2YXIgaWRlbnQgPSBcIihbXixcXFxcc1xcXFwpXSspXCI7XG4gICAgICB2YXIgd3MgPSBcIlxcXFxzKlwiO1xuICAgICAgdmFyIGNvbW1lbnQgPSBcIig/OlxcXFwvXFxcXCooPzoufFxcXFxzKSo/XFxcXCpcXFxcLyk/XCI7XG4gICAgICB2YXIgc2tpcCA9IFwiKD86XCIgKyB3cyArIGNvbW1lbnQgKyB3cyArIFwiKSpcIjtcbiAgICAgIHZhciBoZWFkZXIgPSBcIig/OmZ1bmN0aW9uXCIgKyBza2lwICsgaWRlbnQgKyBcIj9cXFxcKHxcXFxcKClcIiArIHNraXA7XG4gICAgICB2YXIgYXJnID0gXCIoPzpcIiArIGlkZW50ICsgc2tpcCArIFwiKVwiO1xuICAgICAgdmFyIG5leHRBcmcgPSBcIig/OixcIiArIHNraXAgKyBhcmcgKyBcIilcIjtcbiAgICAgIHZhciBhcmdFbmQgPSBcIlxcXFwpXCI7XG4gICAgICB2YXIgaGVhZGVyVG9Cb2R5ID0gc2tpcCArIFwiKD86XFxcXD1cXFxcPik/XCIgKyBza2lwO1xuICAgICAgdmFyIGJvZHkgPSBcIlxcXFx7KCg/Oi58XFxcXHMpKilcXFxcfVwiO1xuXG4gICAgICB2YXIgYnJlYWtkb3duID0ge1xuICAgICAgICBuYW1lOiAnJyxcbiAgICAgICAgYXJnczogW10sXG4gICAgICAgIGJvZHk6ICcnXG4gICAgICB9O1xuXG4gICAgICB2YXIgc291cmNlID0gZi50b1N0cmluZygpO1xuXG4gICAgICB2YXIgbGFzdEluZGV4ID0gMDtcbiAgICAgIHZhciBjdXJyZW50UmVnZXg7XG5cbiAgICAgIGZ1bmN0aW9uIGFnYWluKCkge1xuICAgICAgICB2YXIgbWF0Y2ggPSBjdXJyZW50UmVnZXguZXhlYyhzb3VyY2UpO1xuICAgICAgICBpZiAoIG1hdGNoICkgbGFzdEluZGV4ID0gY3VycmVudFJlZ2V4Lmxhc3RJbmRleDtcbiAgICAgICAgcmV0dXJuIG1hdGNoO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBuZXh0KGUpIHtcbiAgICAgICAgcHJlcChlKTtcbiAgICAgICAgcmV0dXJuIGFnYWluKCk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIHByZXAoZSkge1xuICAgICAgICBjdXJyZW50UmVnZXggPSBuZXcgUmVnRXhwKGUsIFwibXlcIik7XG4gICAgICAgIGN1cnJlbnRSZWdleC5sYXN0SW5kZXggPSBsYXN0SW5kZXg7XG4gICAgICB9XG5cbiAgICAgIHZhciBtYXRjaCA9IG5leHQoaGVhZGVyKTtcbiAgICAgIGlmICggISBtYXRjaCApIHJldHVybiBudWxsO1xuXG4gICAgICBpZiAoIG1hdGNoWzFdICkgYnJlYWtkb3duLm5hbWUgPSBtYXRjaFsxXTtcblxuICAgICAgbWF0Y2ggPSBuZXh0KGFyZyk7XG5cbiAgICAgIGlmICggbWF0Y2ggKSB7XG4gICAgICAgIGJyZWFrZG93bi5hcmdzLnB1c2gobWF0Y2hbMV0pO1xuICAgICAgICBwcmVwKG5leHRBcmcpO1xuICAgICAgICB3aGlsZSAoIG1hdGNoID0gYWdhaW4oKSApIHtcbiAgICAgICAgICBicmVha2Rvd24uYXJncy5wdXNoKG1hdGNoWzFdKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBtYXRjaCA9IG5leHQoYXJnRW5kKTtcbiAgICAgIGlmICggISBtYXRjaCApIHJldHVybiBudWxsO1xuXG4gICAgICBpZiAoICEgbmV4dChoZWFkZXJUb0JvZHkpICkgcmV0dXJuIG51bGw7XG5cbiAgICAgIG1hdGNoID0gbmV4dChib2R5KTtcbiAgICAgIGlmICggISBtYXRjaCApIHJldHVybiBudWxsO1xuICAgICAgYnJlYWtkb3duLmJvZHkgPSBtYXRjaFsxXTtcblxuICAgICAgcmV0dXJuIGJyZWFrZG93bjtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2FsbHMgZm4sIGFuZCBwcm92aWRlcyB0aGUgYXJndW1lbnRzIHRvIGZuIGJ5IGxvb2tpbmdcbiAgICAgKiB1cCB0aGVpciBuYW1lcyBvbiBzb3VyY2UuIFRoZSAndGhpcycgY29udGV4dCBpcyBlaXRoZXJcbiAgICAgKiBzb3VyY2UsIG9yIG9wdF9zZWxmIGlmIHByb3ZpZGVkLlxuICAgICAqXG4gICAgICogSWYgdGhlIGFyZ3VtZW50IG1hcHMgdG8gYSBmdW5jdGlvbiBvbiBzb3VyY2UsIGl0IGlzIGJvdW5kIHRvIHNvdXJjZS5cbiAgICAgKlxuICAgICAqIEV4LlxuICAgICAqIHZhciBhID0ge1xuICAgICAqICAgbmFtZTogJ2FkYW0nLFxuICAgICAqICAgaGVsbG86IGZ1bmN0aW9uKCkge1xuICAgICAqICAgICBjb25zb2xlLmJsb2coJ0hlbGxvICcgKyB0aGlzLm5hbWUpO1xuICAgICAqICAgfVxuICAgICAqIH07XG4gICAgICogZnVuY3Rpb24gZm9vKG5hbWUsIGhlbGxvKSB7XG4gICAgICogICBjb25zb2xlLmxvZygnTmFtZSBpcyAnICsgbmFtZSk7XG4gICAgICogICBoZWxsbygpO1xuICAgICAqIH1cbiAgICAgKiBmb2FtLkZ1bmN0aW9uLndpdGhBcmdzKGZvbywgYSk7XG4gICAgICpcbiAgICAgKiBPdXRwdXRzOlxuICAgICAqIE5hbWUgaXMgYWRhbVxuICAgICAqIEhlbGxvIGFkYW1cbiAgICAgKlxuICAgICAqKi9cbiAgICBmdW5jdGlvbiB3aXRoQXJncyhmbiwgc291cmNlLCBvcHRfc2VsZikge1xuICAgICAgdmFyIGFyZ05hbWVzID0gZm9hbS5GdW5jdGlvbi5hcmdOYW1lcyhmbik7XG4gICAgICB2YXIgYXJncyA9IFtdO1xuICAgICAgZm9yICggdmFyIGkgPSAwIDsgaSA8IGFyZ05hbWVzLmxlbmd0aCA7IGkrKyApIHtcbiAgICAgICAgdmFyIGEgPSBzb3VyY2VbYXJnTmFtZXNbaV1dO1xuICAgICAgICBpZiAoIHR5cGVvZiBhID09PSAnZnVuY3Rpb24nICkgYSA9IGEuYmluZChzb3VyY2UpO1xuICAgICAgICBhcmdzLnB1c2goYSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZm4uYXBwbHkob3B0X3NlbGYgfHwgc291cmNlLCBhcmdzKTtcbiAgICB9LFxuXG4gICAgZnVuY3Rpb24gY2xvc3VyZShmbikge1xuICAgICAgLyoqXG4gICAgICAgICBDcmVhdGUgYSBjbG9zdXJlIHdoaWNoIHN0aWxsIHNlcmlhbGl6ZXMgdG8gaXRzIGRlZmluaXRpb24uXG5cbiAgICAgICAgIHZhciBmID0gZm9hbS5GdW5jdGlvbi5jbG9zdXJlKGZ1bmN0aW9uKCkgeyB2YXIgaSA9IDA7IHJldHVybiBmdW5jdGlvbigpIHsgcmV0dXJuIGkrKzsgfSB9KTtcbiAgICAgICAgIGYoKTsgLT4gMFxuICAgICAgICAgZigpOyAtPiAxXG4gICAgICAgICBmLnRvU3RyaW5nKCk7IC0+IFwiZm9hbS5GdW5jdGlvbi5jbG9zdXJlKGZ1bmN0aW9uICgpIHsgdmFyIGkgPSAwOyByZXR1cm4gZnVuY3Rpb24oKSB7IHJldHVybiBpKys7IH0gfSlcIlxuICAgICAgKi9cbiAgICAgIHZhciByZXQgPSBmbigpO1xuXG4gICAgICByZXQudG9TdHJpbmcgPSBmdW5jdGlvbigpIHsgcmV0dXJuICdmb2FtLkZ1bmN0aW9uLmNsb3N1cmUoJyArIGZuLnRvU3RyaW5nKCkgKyAnKSc7IH07XG5cbiAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuICBdXG59KTtcblxuXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuKGZ1bmN0aW9uKCkge1xuICAvLyBEaXNhYmxlIHNldE5hbWUgaWYgbm90IHN1cHBvcnRlZCBvbiB0aGlzIHBsYXRmb3JtLlxuICB0cnkge1xuICAgIGZvYW0uRnVuY3Rpb24uc2V0TmFtZShmdW5jdGlvbigpIHt9LCAnJyk7XG4gIH0gY2F0Y2ggKHgpIHtcbiAgICBjb25zb2xlLndhcm4oJ2ZvYW0uRnVuY3Rpb24uc2V0TmFtZSBpcyBub3Qgc3VwcG9ydGVkIG9uIHlvdXIgcGxhdGZvcm0uICcgK1xuICAgICAgICAgICAgICAgICAnU3RhY2sgdHJhY2VzIHdpbGwgYmUgaGFyZGVyIHRvIGRlY2lwaGVyLCBidXQgbm8gJyArXG4gICAgICAgICAgICAgICAgICdmdW5jdGlvbmFsaXR5IHdpbGwgYmUgbG9zdCcpO1xuICAgIGZvYW0uTElCKHtcbiAgICAgIG5hbWU6ICdmb2FtLkZ1bmN0aW9uJyxcbiAgICAgIG1ldGhvZHM6IFtcbiAgICAgICAgZnVuY3Rpb24gc2V0TmFtZShmKSB7IHJldHVybiBmOyB9XG4gICAgICBdXG4gICAgfSk7XG4gIH1cbn0pKCk7XG5cblxuZm9hbS5MSUIoe1xuICBuYW1lOiAnZm9hbS5OdW1iZXInLFxuICBtZXRob2RzOiBbXG4gICAgZnVuY3Rpb24gaXNJbnN0YW5jZShvKSB7IHJldHVybiB0eXBlb2YgbyA9PT0gJ251bWJlcic7IH0sXG4gICAgZnVuY3Rpb24gaXMoYSwgYikgeyByZXR1cm4gZm9hbS5OdW1iZXIuY29tcGFyZShhLCBiKSA9PSAwOyB9LFxuICAgIGZ1bmN0aW9uIGNsb25lKG8pIHsgcmV0dXJuIG87IH0sXG4gICAgZnVuY3Rpb24gZXF1YWxzKGEsIGIpIHsgcmV0dXJuIGZvYW0uTnVtYmVyLmNvbXBhcmUoYSwgYikgPT0gMDsgfSxcbiAgICBmdW5jdGlvbiBjb21wYXJlKGEsIGIpIHtcbiAgICAgIGlmICggISBmb2FtLk51bWJlci5pc0luc3RhbmNlKGIpIHx8ICggaXNOYU4oYSkgJiYgISBpc05hTihiKSkgKSByZXR1cm4gMTtcbiAgICAgIGlmICggISBpc05hTihhKSAmJiBpc05hTihiKSApIHJldHVybiAtMTtcbiAgICAgIHJldHVybiBhIDwgYiA/IC0xIDogYSA+IGIgPyAxIDogMDtcbiAgICB9LFxuICAgIChmdW5jdGlvbigpIHtcbiAgICAgIHZhciBidWZGb3JIYXNoID0gbmV3IEFycmF5QnVmZmVyKDgpO1xuICAgICAgdmFyIGZsb2F0QXJyYXlGb3JIYXNoID0gbmV3IEZsb2F0NjRBcnJheShidWZGb3JIYXNoKTtcbiAgICAgIHZhciBpbnRBcnJheUZvckhhc2ggPSBuZXcgSW50MzJBcnJheShidWZGb3JIYXNoKTtcblxuICAgICAgcmV0dXJuIGZ1bmN0aW9uIGhhc2hDb2RlKG4pIHtcbiAgICAgICAgaWYgKE51bWJlci5pc0ludGVnZXIobikpIHJldHVybiBuICYgbjsgLy8gVHJ1bmNhdGUgdG8gMzIgYml0cy5cblxuICAgICAgICBmbG9hdEFycmF5Rm9ySGFzaFswXSA9IG47XG4gICAgICAgIHZhciBoYXNoID0gKChpbnRBcnJheUZvckhhc2hbMF0gPDwgNSkgLSBpbnRBcnJheUZvckhhc2hbMF0pICtcbiAgICAgICAgICAgIGludEFycmF5Rm9ySGFzaFsxXTtcbiAgICAgICAgcmV0dXJuIGhhc2ggJiBoYXNoOyAvLyBUcnVuY2F0ZSB0byAzMiBiaXRzLlxuICAgICAgfTtcbiAgICB9KSgpXG4gIF1cbn0pO1xuXG5cbmZvYW0uTElCKHtcbiAgbmFtZTogJ2ZvYW0uU3RyaW5nJyxcbiAgbWV0aG9kczogW1xuICAgIGZ1bmN0aW9uIGlzSW5zdGFuY2UobykgeyByZXR1cm4gdHlwZW9mIG8gPT09ICdzdHJpbmcnOyB9LFxuICAgIGZ1bmN0aW9uIGlzKGEsIGIpIHsgcmV0dXJuIGEgPT09IGI7IH0sXG4gICAgZnVuY3Rpb24gY2xvbmUobykgeyByZXR1cm4gbzsgfSxcbiAgICBmdW5jdGlvbiBlcXVhbHMoYSwgYikgeyByZXR1cm4gYSA9PT0gYjsgfSxcbiAgICBmdW5jdGlvbiBjb21wYXJlKGEsIGIpIHtcbiAgICAgIGlmICggISBmb2FtLlN0cmluZy5pc0luc3RhbmNlKGIpICkgcmV0dXJuIDE7XG4gICAgICByZXR1cm4gYiAhPSBudWxsID8gYS5sb2NhbGVDb21wYXJlKGIpIDogMSA7XG4gICAgfSxcbiAgICBmdW5jdGlvbiBoYXNoQ29kZShzKSB7XG4gICAgICB2YXIgaGFzaCA9IC00O1xuXG4gICAgICBmb3IgKCB2YXIgaSA9IDAgOyBpIDwgcy5sZW5ndGggOyBpKysgKSB7XG4gICAgICAgIHZhciBjb2RlID0gcy5jaGFyQ29kZUF0KGkpO1xuICAgICAgICBoYXNoID0gKChoYXNoIDw8IDUpIC0gaGFzaCkgKyBjb2RlO1xuICAgICAgICBoYXNoICY9IGhhc2g7IC8vIFRydW5jYXRlIHRvIDMyIGJpdHMuXG4gICAgICB9XG5cbiAgICAgIHJldHVybiBoYXNoO1xuICAgIH0sXG4gICAge1xuICAgICAgbmFtZTogJ2NvbnN0YW50aXplJyxcbiAgICAgIGNvZGU6IGZvYW0uRnVuY3Rpb24ubWVtb2l6ZTEoZnVuY3Rpb24oLyogU3RyaW5nICovIHN0cikge1xuICAgICAgICAvLyBzd2l0Y2hlcyBmcm9tIGZyb20gY2FtZWxDYXNlIHRvIENBTUVMX0NBU0VcbiAgICAgICAgcmV0dXJuIHN0ci5yZXBsYWNlKC8oW2Etel0pKFteMC05YS16X10pL2csICckMV8kMicpLnRvVXBwZXJDYXNlKCk7XG4gICAgICB9KVxuICAgIH0sXG4gICAge1xuICAgICAgbmFtZTogJ2xhYmVsaXplJyxcbiAgICAgIGNvZGU6IGZvYW0uRnVuY3Rpb24ubWVtb2l6ZTEoZnVuY3Rpb24oLyogU3RyaW5nPSAqLyBzdHIpIHtcbiAgICAgICAgaWYgKCBzdHIgPT09ICcnIHx8IHN0ciA9PT0gbnVsbCB8fCBmb2FtLlVuZGVmaW5lZC5pc0luc3RhbmNlKHN0cikgKSByZXR1cm4gJyc7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuY2FwaXRhbGl6ZShzdHIucmVwbGFjZSgvW2Etel1bQS1aXS9nLCBmdW5jdGlvbihhKSB7XG4gICAgICAgICAgcmV0dXJuIGEuY2hhckF0KDApICsgJyAnICsgYS5jaGFyQXQoMSk7XG4gICAgICAgIH0pKTtcbiAgICAgIH0pXG4gICAgfSxcbiAgICB7XG4gICAgICBuYW1lOiAnY2FwaXRhbGl6ZScsXG4gICAgICBjb2RlOiBmb2FtLkZ1bmN0aW9uLm1lbW9pemUxKGZ1bmN0aW9uKHN0cikge1xuICAgICAgICBmb2FtLmFzc2VydCh0eXBlb2Ygc3RyID09PSAnc3RyaW5nJyxcbiAgICAgICAgICAgICdDYW5ub3QgY2FwaXRhbGl6ZSBub24tc3RyaW5nIHZhbHVlcy4nKTtcbiAgICAgICAgLy8gc3dpdGNoRnJvbVByb3BlcnlOYW1lIHRvIC8vU3dpdGNoRnJvbVByb3BlcnR5TmFtZVxuICAgICAgICByZXR1cm4gc3RyWzBdLnRvVXBwZXJDYXNlKCkgKyBzdHIuc3Vic3RyaW5nKDEpO1xuICAgICAgfSlcbiAgICB9LFxuICAgIHtcbiAgICAgIC8qKlxuICAgICAgICogVGFrZXMgYSBrZXkgYW5kIGNyZWF0ZXMgYSBzbG90IG5hbWUgZm9yIGl0LiAgR2VuZXJhbGx5IGtleSAtPiBrZXkgKyAnJCcuXG4gICAgICAgKlxuICAgICAgICogRm9yIGV4YW1wbGUsIGlmIGFuIG9iamVjdCBoYXMgYSBwcm9wZXJ0eSBjYWxsZWQgbXlQcm9wZXJ0eSwgdGhlIHNsb3RcbiAgICAgICAqIG5hbWUgZm9yIHRoYXQgd2lsbCBiZSBteVByb3BlcnR5JC5cbiAgICAgICAqL1xuICAgICAgbmFtZTogJ3RvU2xvdE5hbWUnLFxuICAgICAgY29kZTogZm9hbS5GdW5jdGlvbi5tZW1vaXplMShmdW5jdGlvbiB0b1Nsb3ROYW1lKGtleSkge1xuICAgICAgICBmb2FtLmFzc2VydChcbiAgICAgICAgICAgIHR5cGVvZiBrZXkgPT09ICdzdHJpbmcnLFxuICAgICAgICAgICAgJ0Nhbm5vdCB0b1Nsb3ROYW1lIG5vbi1zdHJpbmcgdmFsdWVzLiAgQXR0ZW1wdGVkOiAnLCBrZXkpO1xuXG4gICAgICAgIHJldHVybiBrZXkgKyAnJCc7XG4gICAgICB9KVxuICAgIH0sXG4gICAge1xuICAgICAgbmFtZTogJ3RvVXBwZXJDYXNlJyxcbiAgICAgIGNvZGU6IGZvYW0uRnVuY3Rpb24ubWVtb2l6ZTEoZnVuY3Rpb24oc3RyKSB7XG4gICAgICAgIGZvYW0uYXNzZXJ0KFxuICAgICAgICAgICAgdHlwZW9mIHN0ciA9PT0gJ3N0cmluZycsXG4gICAgICAgICAgICAnQ2Fubm90IHRvVXBwZXJDYXNlIG5vbi1zdHJpbmcgdmFsdWVzLicpO1xuXG4gICAgICAgIHJldHVybiBzdHIudG9VcHBlckNhc2UoKTtcbiAgICAgIH0pXG4gICAgfSxcbiAgICB7XG4gICAgICBuYW1lOiAnY3NzQ2xhc3NpemUnLFxuICAgICAgY29kZTogZm9hbS5GdW5jdGlvbi5tZW1vaXplMShmdW5jdGlvbihzdHIpIHtcbiAgICAgICAgZm9hbS5hc3NlcnQodHlwZW9mIHN0ciA9PT0gJ3N0cmluZycsXG4gICAgICAgICAgICAnQ2Fubm90IGNzc0NsYXNzaXplIG5vbi1zdHJpbmcgdmFsdWVzLicpO1xuICAgICAgICAvLyBUdXJucyBmb2FtLnUyLkZvbyBpbnRvIGZvYW0tdTItRm9vXG4gICAgICAgIHJldHVybiBzdHIucmVwbGFjZSgvXFwuL2csICctJyk7XG4gICAgICB9KVxuICAgIH0sXG4gICAgZnVuY3Rpb24gcGFkKG9iaiwgc2l6ZSkge1xuICAgICAgLy8gUmlnaHQgcGFkcyB0byBzaXplIGlmIHNpemUgPiAwLCBMZWZ0IHBhZHMgdG8gLXNpemUgaWYgc2l6ZSA8IDBcbiAgICAgIHJldHVybiBzaXplIDwgMCA/XG4gICAgICAgIChuZXcgQXJyYXkoLXNpemUpLmpvaW4oJyAnKSArIG9iaikuc2xpY2Uoc2l6ZSkgICAgICAgOlxuICAgICAgICAob2JqICsgbmV3IEFycmF5KHNpemUpLmpvaW4oJyAnKSkuc3Vic3RyaW5nKDAsIHNpemUpIDtcbiAgICB9LFxuICAgIGZ1bmN0aW9uIG11bHRpbGluZShmKSB7XG4gICAgICAvLyBGdW5jdGlvbiBmb3IgcmV0dXJuaW5nIG11bHRpLWxpbmUgc3RyaW5ncyBmcm9tIGNvbW1lbnRlZCBmdW5jdGlvbnMuXG4gICAgICAvLyBFeC4gdmFyIHN0ciA9IG11bHRpbGluZShmdW5jdGlvbigpIHsgLyogbXVsdGktbGluZSBzdHJpbmcgaGVyZSAqLyB9KTtcbiAgICAgIGlmICggdHlwZW9mIGYgPT09ICdzdHJpbmcnICkgcmV0dXJuIGY7XG4gICAgICB2YXIgcyAgICAgPSBmLnRvU3RyaW5nKCk7XG4gICAgICB2YXIgc3RhcnQgPSBzLmluZGV4T2YoJy8qJyk7XG4gICAgICB2YXIgZW5kICAgPSBzLmxhc3RJbmRleE9mKCcqLycpO1xuICAgICAgcmV0dXJuICggc3RhcnQgPj0gMCAmJiBlbmQgPj0gMCApID8gcy5zdWJzdHJpbmcoc3RhcnQgKyAyLCBlbmQpIDogJyc7XG4gICAgfSxcbiAgICBmdW5jdGlvbiBzdGFydHNXaXRoSUMoYSwgYikge1xuICAgICAgZm9hbS5hc3NlcnQodHlwZW9mIGEgPT09ICdzdHJpbmcnICYmIHR5cGVvZiBiID09PSAnc3RyaW5nJyxcbiAgICAgICAgICAnQ2Fubm90IHN0YXJ0c1dpdGhJQyBub24tc3RyaW5nIHZhbHVlcy4nKTtcblxuICAgICAgcmV0dXJuIGEudG9VcHBlckNhc2UoKS5zdGFydHNXaXRoKGIudG9VcHBlckNhc2UoKSk7XG4gICAgfSxcbiAgICAoZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgbWFwID0ge307XG5cbiAgICAgIHJldHVybiBmdW5jdGlvbiBpbnRlcm4odmFsKSB7XG4gICAgICAgIC8qKiBDb252ZXJ0IGEgc3RyaW5nIHRvIGFuIGludGVybmFsIGNhbm9uaWNhbCBjb3B5LiAqKi9cbiAgICAgICAgcmV0dXJuIG1hcFt2YWxdIHx8IChtYXBbdmFsXSA9IHZhbC50b1N0cmluZygpKTtcbiAgICAgIH07XG4gICAgfSkoKSxcbiAgXVxufSk7XG5cblxuZm9hbS5MSUIoe1xuICBuYW1lOiAnZm9hbS5BcnJheScsXG4gIG1ldGhvZHM6IFtcbiAgICBmdW5jdGlvbiBpc0luc3RhbmNlKG8pIHsgcmV0dXJuIEFycmF5LmlzQXJyYXkobyk7IH0sXG4gICAgZnVuY3Rpb24gaXMoYSwgYikgeyByZXR1cm4gYSA9PT0gYjsgfSxcbiAgICBmdW5jdGlvbiBjbG9uZShvKSB7XG4gICAgICAvKiogUmV0dXJucyBhIGRlZXAgY29weSBvZiB0aGlzIGFycmF5IGFuZCBpdHMgY29udGVudHMuICovXG4gICAgICB2YXIgcmV0ID0gbmV3IEFycmF5KG8ubGVuZ3RoKTtcbiAgICAgIGZvciAoIHZhciBpID0gMCA7IGkgPCBvLmxlbmd0aCA7IGkrKyApIHtcbiAgICAgICAgcmV0W2ldID0gZm9hbS51dGlsLmNsb25lKG9baV0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJldDtcbiAgICB9LFxuICAgIGZ1bmN0aW9uIGRpZmYoYSwgYikge1xuICAgICAgLyoqIEZpbmRzIGVsZW1lbnRzIGFkZGVkIChmb3VuZCBpbiBvdGhlciwgbm90IGluIHRoaXMpIGFuZCByZW1vdmVkXG4gICAgICAgICAgKGZvdW5kIGluIHRoaXMsIG5vdCBpbiBvdGhlcikuIFJlcGVhdGVkIHZhbHVlcyBhcmUgdHJlYXRlZFxuICAgICAgICAgIGFzIHNlcGFyYXRlIGVsZW1lbnRzLCBidXQgb3JkZXJpbmcgY2hhbmdlcyBhcmUgaWdub3JlZC4gKi9cbiAgICAgIHZhciBhZGRlZCA9IGIuc2xpY2UoMCk7XG4gICAgICB2YXIgcmVtb3ZlZCA9IFtdO1xuICAgICAgZm9yICggdmFyIGkgPSAwIDsgaSA8IGEubGVuZ3RoIDsgaSsrICkge1xuICAgICAgICBmb3IgKCB2YXIgaiA9IDAgOyBqIDwgYWRkZWQubGVuZ3RoIDsgaisrICkge1xuICAgICAgICAgIGlmICggZm9hbS51dGlsLmVxdWFscyhhW2ldLCBhZGRlZFtqXSkgKSB7XG4gICAgICAgICAgICBhZGRlZC5zcGxpY2UoaiwgMSk7XG4gICAgICAgICAgICBqLS07XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCBqID09PSBhZGRlZC5sZW5ndGggKSByZW1vdmVkLnB1c2goYVtpXSk7XG4gICAgICB9XG4gICAgICByZXR1cm4geyBhZGRlZDogYWRkZWQsIHJlbW92ZWQ6IHJlbW92ZWQgfTtcbiAgICB9LFxuICAgIGZ1bmN0aW9uIGVxdWFscyhhLCBiKSB7XG4gICAgICBpZiAoICEgYiB8fCAhIEFycmF5LmlzQXJyYXkoYikgfHwgYS5sZW5ndGggIT09IGIubGVuZ3RoICkgcmV0dXJuIGZhbHNlO1xuICAgICAgZm9yICggdmFyIGkgPSAwIDsgaSA8IGEubGVuZ3RoIDsgaSsrICkge1xuICAgICAgICBpZiAoICEgZm9hbS51dGlsLmVxdWFscyhhW2ldLCBiW2ldKSApIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0sXG4gICAgZnVuY3Rpb24gY29tcGFyZShhLCBiKSB7XG4gICAgICBpZiAoICEgYiB8fCAhIEFycmF5LmlzQXJyYXkoYikgKSByZXR1cm4gMTtcbiAgICAgIHZhciBsID0gTWF0aC5taW4oYS5sZW5ndGgsIGIubGVuZ3RoKTtcbiAgICAgIGZvciAoIHZhciBpID0gMCA7IGkgPCBsIDsgaSsrICkge1xuICAgICAgICB2YXIgYyA9IGZvYW0udXRpbC5jb21wYXJlKGFbaV0sIGJbaV0pO1xuICAgICAgICBpZiAoIGMgKSByZXR1cm4gYztcbiAgICAgIH1cbiAgICAgIHJldHVybiBhLmxlbmd0aCA9PT0gYi5sZW5ndGggPyAwIDogYS5sZW5ndGggPCBiLmxlbmd0aCA/IC0xIDogMTtcbiAgICB9LFxuICAgIGZ1bmN0aW9uIGhhc2hDb2RlKGEpIHtcbiAgICAgIHZhciBoYXNoID0gLTU7XG5cbiAgICAgIGZvciAoIHZhciBpID0gMCA7IGkgPCBhLmxlbmd0aCA7IGkrKyApIHtcbiAgICAgICAgaGFzaCA9ICgoaGFzaCA8PCA1KSAtIGhhc2gpICsgZm9hbS51dGlsLmhhc2hDb2RlKGFbaV0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gaGFzaDtcbiAgICB9LFxuICAgIGZ1bmN0aW9uIHJlbW92ZShhLCBvKSB7XG4gICAgICBmb3IgKCB2YXIgaSA9IDAgOyBpIDwgYS5sZW5ndGggOyBpKysgKSB7XG4gICAgICAgIGlmICggbyA9PT0gYVtpXSApIHtcbiAgICAgICAgICBhLnNwbGljZShpLCAxKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgXVxufSk7XG5cblxuZm9hbS5MSUIoe1xuICBuYW1lOiAnZm9hbS5EYXRlJyxcbiAgbWV0aG9kczogW1xuICAgIGZ1bmN0aW9uIGlzSW5zdGFuY2UobykgeyByZXR1cm4gbyBpbnN0YW5jZW9mIERhdGU7IH0sXG4gICAgZnVuY3Rpb24gaXMoYSwgYikgeyByZXR1cm4gYSA9PT0gYjsgfSxcbiAgICBmdW5jdGlvbiBjbG9uZShvKSB7IHJldHVybiBuZXcgRGF0ZShvKTsgfSxcbiAgICBmdW5jdGlvbiBnZXRUaW1lKGQpIHsgcmV0dXJuICEgZCA/IDAgOiBkLmdldFRpbWUgPyBkLmdldFRpbWUoKSA6IGQgOyB9LFxuICAgIGZ1bmN0aW9uIGVxdWFscyhhLCBiKSB7IHJldHVybiB0aGlzLmdldFRpbWUoYSkgPT09IHRoaXMuZ2V0VGltZShiKTsgfSxcbiAgICBmdW5jdGlvbiBjb21wYXJlKGEsIGIpIHtcbiAgICAgIGlmICggISBmb2FtLkRhdGUuaXNJbnN0YW5jZShiKSApIHJldHVybiAxO1xuICAgICAgcmV0dXJuIGZvYW0uTnVtYmVyLmNvbXBhcmUodGhpcy5nZXRUaW1lKGEpLCB0aGlzLmdldFRpbWUoYikpO1xuICAgIH0sXG4gICAgLy8gSGFzaCBuICYgbjogVHJ1bmNhdGUgdG8gMzIgYml0cy5cbiAgICBmdW5jdGlvbiBoYXNoQ29kZShkKSB7IHZhciBuID0gZC5nZXRUaW1lKCk7IHJldHVybiBuICYgbjsgfSxcbiAgICBmdW5jdGlvbiByZWxhdGl2ZURhdGVTdHJpbmcoZGF0ZSkge1xuICAgICAgLy8gRlVUVVJFOiBtYWtlIHRoaXMgdHJhbnNsYXRhYmxlIGZvciBpMThuLCBpbmNsdWRpbmcgcGx1cmFsc1xuICAgICAgLy8gICBcImhvdXJzXCIgdnMuIFwiaG91clwiXG4gICAgICB2YXIgc2Vjb25kcyA9IE1hdGgudHJ1bmMoICggRGF0ZS5ub3coKSAtIGRhdGUuZ2V0VGltZSgpICkgLyAxMDAwICk7XG5cbiAgICAgIGlmICggc2Vjb25kcyA+PSAwICYmIHNlY29uZHMgPCA2MCApIHJldHVybiAnbW9tZW50cyBhZ28nO1xuICAgICAgaWYgKCBzZWNvbmRzIDwgMCAgJiYgc2Vjb25kcyA+IC02MCApIHJldHVybiAnaW4gbW9tZW50cyc7XG5cbiAgICAgIHZhciBtaW51dGVzID0gTWF0aC50cnVuYygoc2Vjb25kcykgLyA2MCk7XG5cbiAgICAgIGlmICggbWludXRlcyA9PT0gMSApIHJldHVybiAnMSBtaW51dGUgYWdvJztcbiAgICAgIGlmICggbWludXRlcyA9PT0gLTEgKSByZXR1cm4gJ2luIDEgbWludXRlJztcblxuICAgICAgaWYgKCBtaW51dGVzID49IDAgJiYgbWludXRlcyA8IDYwICkgcmV0dXJuIG1pbnV0ZXMgKyAnIG1pbnV0ZXMgYWdvJztcbiAgICAgIGlmICggbWludXRlcyA8IDAgICYmIG1pbnV0ZXMgPiAtNjAgKSByZXR1cm4gJ2luICcgKyAtbWludXRlcyArICcgbWludXRlcyc7XG5cbiAgICAgIHZhciBob3VycyA9IE1hdGgudHJ1bmMobWludXRlcyAvIDYwKTtcbiAgICAgIGlmICggaG91cnMgPT09IDEgKSByZXR1cm4gJzEgaG91ciBhZ28nO1xuICAgICAgaWYgKCBob3VycyA9PT0gLTEgKSByZXR1cm4gJ2luIDEgaG91cic7XG5cbiAgICAgIGlmICggaG91cnMgPj0gMCAmJiBob3VycyA8IDI0ICkgcmV0dXJuIGhvdXJzICsgJyBob3VycyBhZ28nO1xuICAgICAgaWYgKCBob3VycyA8ICAwICYmIGhvdXJzID4gLTI0ICkgcmV0dXJuICdpbiAnICsgLWhvdXJzICsgJyBob3Vycyc7XG5cbiAgICAgIHZhciBkYXlzID0gTWF0aC50cnVuYyhob3VycyAvIDI0KTtcbiAgICAgIGlmICggZGF5cyA9PT0gMSApIHJldHVybiAnMSBkYXkgYWdvJztcbiAgICAgIGlmICggZGF5cyA9PT0gLTEgKSByZXR1cm4gJ2luIDEgZGF5JztcblxuICAgICAgaWYgKCBkYXlzID49IDAgJiYgZGF5cyA8IDcgKSByZXR1cm4gZGF5cyArICcgZGF5cyBhZ28nO1xuICAgICAgaWYgKCBkYXlzIDwgIDAgJiYgZGF5cyA+IC03ICkgcmV0dXJuICdpbiAnICsgLWRheXMgKyAnIGRheXMnO1xuXG4gICAgICBpZiAoIGRheXMgPj0gMCAmJiBkYXlzIDwgMzY1IHx8IGRheXMgPCAwICYmIGRheXMgPiAtMzY1ICkge1xuICAgICAgICB2YXIgeWVhciA9IDE5MDAgKyBkYXRlLmdldFllYXIoKTtcbiAgICAgICAgdmFyIG5veWVhciA9IGRhdGUudG9EYXRlU3RyaW5nKCkucmVwbGFjZSgnICcgKyB5ZWFyLCAnJyk7XG4gICAgICAgIHJldHVybiBub3llYXIuc3Vic3RyaW5nKDQpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZGF0ZS50b0RhdGVTdHJpbmcoKS5zdWJzdHJpbmcoNCk7XG4gICAgfVxuICBdXG59KTtcblxuXG4vLyBBbiBGT2JqZWN0IGlzIGEgRk9BTS1PYmplY3QsIHRoZSByb290IGNsYXNzIGZvciBhbGwgbW9kZWxlZCBjbGFzc2VzLlxuZm9hbS5MSUIoe1xuICBuYW1lOiAnZm9hbS5jb3JlLkZPYmplY3QnLFxuICBtZXRob2RzOiBbXG4gICAgLy8gQ2FuJ3QgYmUgYW4gRk9iamVjdCB5ZXQgYmVjYXVzZSB3ZSBoYXZlbid0IGJ1aWx0IHRoZSBjbGFzcyBzeXN0ZW0geWV0XG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICBmdW5jdGlvbiBpc0luc3RhbmNlKG8pIHsgcmV0dXJuIGZhbHNlOyB9LFxuICAgIGZ1bmN0aW9uIGNsb25lKG8pICAgICAgeyByZXR1cm4gbyA/IG8uY2xvbmUoKSA6IHRoaXM7IH0sXG4gICAgZnVuY3Rpb24gaXMoYSwgYikgICAgICB7IHJldHVybiBhID09PSBiOyB9LFxuICAgIGZ1bmN0aW9uIGRpZmYoYSwgYikgICAgeyByZXR1cm4gYS5kaWZmKGIpOyB9LFxuICAgIGZ1bmN0aW9uIGVxdWFscyhhLCBiKSAgeyByZXR1cm4gYS5lcXVhbHMoYik7IH0sXG4gICAgZnVuY3Rpb24gY29tcGFyZShhLCBiKSB7XG4gICAgICBpZiAoICEgZm9hbS5jb3JlLkZPYmplY3QuaXNJbnN0YW5jZShiKSApIHJldHVybiAxO1xuICAgICAgcmV0dXJuIGEuY29tcGFyZVRvKGIpO1xuICAgIH0sXG4gICAgZnVuY3Rpb24gaGFzaENvZGUobykgICB7IHJldHVybiBvLmhhc2hDb2RlKCk7IH1cbiAgXVxufSk7XG5cblxuLy8gQU4gT2JqZWN0IGlzIGEgSmF2YXNjcmlwdCBPYmplY3Qgd2hpY2ggaXMgbmVpdGhlciBhbiBGT2JqZWN0IG5vciBhbiBBcnJheS5cbmZvYW0uTElCKHtcbiAgbmFtZTogJ2ZvYW0uT2JqZWN0JyxcbiAgbWV0aG9kczogW1xuICAgIGZ1bmN0aW9uIGZvckVhY2gob2JqLCBmKSB7XG4gICAgICBmb3IgKCB2YXIga2V5IGluIG9iaiApIHtcbiAgICAgICAgaWYgKCBvYmouaGFzT3duUHJvcGVydHkoa2V5KSApIGYob2JqW2tleV0sIGtleSk7XG4gICAgICB9XG4gICAgfSxcbiAgICBmdW5jdGlvbiBpcyhhLCBiKSB7IHJldHVybiBhID09PSBiOyB9LFxuICAgIGZ1bmN0aW9uIGlzSW5zdGFuY2Uobykge1xuICAgICAgcmV0dXJuIHR5cGVvZiBvID09PSAnb2JqZWN0JyAmJiAhIEFycmF5LmlzQXJyYXkobykgJiZcbiAgICAgICAgICAhIGZvYW0uY29yZS5GT2JqZWN0LmlzSW5zdGFuY2Uobyk7XG4gICAgfSxcbiAgICBmdW5jdGlvbiBjbG9uZShvKSB7IHJldHVybiBvOyB9LFxuICAgIGZ1bmN0aW9uIGVxdWFscyhhLCBiKSB7IHJldHVybiBhID09PSBiOyB9LFxuICAgIGZ1bmN0aW9uIGNvbXBhcmUoYSwgYikge1xuICAgICAgaWYgKCAhIGZvYW0uT2JqZWN0LmlzSW5zdGFuY2UoYikgKSByZXR1cm4gMTtcbiAgICAgIHJldHVybiBmb2FtLk51bWJlci5jb21wYXJlKGEuJFVJRCwgYiA/IGIuJFVJRCA6IC0xKTtcbiAgICB9LFxuICAgIGZ1bmN0aW9uIGhhc2hDb2RlKG8pIHtcbiAgICAgIHZhciBoYXNoID0gMTk7XG4gICAgICBmb3IgKCB2YXIga2V5IGluIG8gKSB7XG4gICAgICAgIGlmICggISBvLmhhc093blByb3BlcnR5KGtleSkgKSBjb250aW51ZTtcbiAgICAgICAgaGFzaCA9ICgoaGFzaCA8PCA1KSAtIGhhc2gpICsgZm9hbS51dGlsLmhhc2hDb2RlKG9ba2V5XSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gaGFzaDtcbiAgICB9LFxuICAgIGZ1bmN0aW9uIGZyZWV6ZShvKSB7XG4gICAgICAvLyBGb3JjZSAkVUlEIGNyZWF0aW9uIGJlZm9yZSBmcmVlemluZyBiZWNhdXNlIGl0IGNhbid0XG4gICAgICAvLyBiZSBhZGRlZCB0byB0aGUgb2JqZWN0IGFmdGVyIGl0J3MgZnJvemVuLlxuICAgICAgby4kVUlEX18gPSBmb2FtLm5leHQkVUlEKCk7XG4gICAgICBPYmplY3QuZnJlZXplKG8pO1xuICAgIH1cbiAgXVxufSk7XG5cblxuLyoqXG4gIFJldHVybiB0aGUgZmx5d2VpZ2h0ICd0eXBlIG9iamVjdCcgZm9yIHRoZSBwcm92aWRlZCBvYmplY3QuXG4gIEFueSB2YWx1ZSBpcyBhIHZhbGlkIGFyZ3VtZW50LCBpbmNsdWRpbmcgbnVsbCBhbmQgdW5kZWZpbmVkLlxuKi9cbmZvYW0udHlwZU9mID0gKGZ1bmN0aW9uKCkge1xuICB2YXIgdE51bWJlciAgICA9IGZvYW0uTnVtYmVyO1xuICB2YXIgdFN0cmluZyAgICA9IGZvYW0uU3RyaW5nO1xuICB2YXIgdFVuZGVmaW5lZCA9IGZvYW0uVW5kZWZpbmVkO1xuICB2YXIgdE51bGwgICAgICA9IGZvYW0uTnVsbDtcbiAgdmFyIHRCb29sZWFuICAgPSBmb2FtLkJvb2xlYW47XG4gIHZhciB0QXJyYXkgICAgID0gZm9hbS5BcnJheTtcbiAgdmFyIHREYXRlICAgICAgPSBmb2FtLkRhdGU7XG4gIHZhciB0Rk9iamVjdCAgID0gZm9hbS5jb3JlLkZPYmplY3Q7XG4gIHZhciB0RnVuY3Rpb24gID0gZm9hbS5GdW5jdGlvbjtcbiAgdmFyIHRPYmplY3QgICAgPSBmb2FtLk9iamVjdDtcblxuICByZXR1cm4gZnVuY3Rpb24gdHlwZU9mKG8pIHtcbiAgICBpZiAoIHROdW1iZXIuaXNJbnN0YW5jZShvKSApICAgIHJldHVybiB0TnVtYmVyO1xuICAgIGlmICggdFN0cmluZy5pc0luc3RhbmNlKG8pICkgICAgcmV0dXJuIHRTdHJpbmc7XG4gICAgaWYgKCB0VW5kZWZpbmVkLmlzSW5zdGFuY2UobykgKSByZXR1cm4gdFVuZGVmaW5lZDtcbiAgICBpZiAoIHROdWxsLmlzSW5zdGFuY2UobykgKSAgICAgIHJldHVybiB0TnVsbDtcbiAgICBpZiAoIHRCb29sZWFuLmlzSW5zdGFuY2UobykgKSAgIHJldHVybiB0Qm9vbGVhbjtcbiAgICBpZiAoIHRBcnJheS5pc0luc3RhbmNlKG8pICkgICAgIHJldHVybiB0QXJyYXk7XG4gICAgaWYgKCB0RGF0ZS5pc0luc3RhbmNlKG8pICkgICAgICByZXR1cm4gdERhdGU7XG4gICAgaWYgKCB0RnVuY3Rpb24uaXNJbnN0YW5jZShvKSApICByZXR1cm4gdEZ1bmN0aW9uO1xuICAgIGlmICggdEZPYmplY3QuaXNJbnN0YW5jZShvKSApICAgcmV0dXJuIHRGT2JqZWN0O1xuICAgIHJldHVybiB0T2JqZWN0O1xuICB9O1xufSkoKTtcblxuLyoqXG4gIERlZmluaW5nIGFuIG9yZGluYWwgcHJvcGVydHkgdG8gZXN0YWJsaXNoIGEgcHJlY2VkZW5jZVxuICBpbiB3aGljaCBpdGVtcyBzaG91bGQgYmUgY29tcGFyZWQgaW4uIEl0ZW1zIGFyZSBhcnJhbmdlZFxuICBieSBjb21wbGV4aXR5IG9mIHRoZSB0eXBlLlxuKi9cblxuZm9hbS5jb3JlLkZPYmplY3Qub3JkaW5hbCA9IDA7XG5mb2FtLkRhdGUub3JkaW5hbCA9IDE7XG5mb2FtLk9iamVjdC5vcmRpbmFsID0gMjtcbmZvYW0uRnVuY3Rpb24ub3JkaW5hbCA9IDM7XG5mb2FtLkFycmF5Lm9yZGluYWwgPSA0O1xuZm9hbS5TdHJpbmcub3JkaW5hbCA9IDU7XG5mb2FtLk51bWJlci5vcmRpbmFsID0gNjtcbmZvYW0uQm9vbGVhbi5vcmRpbmFsID0gNztcbmZvYW0uTnVsbC5vcmRpbmFsID0gODtcbmZvYW0uVW5kZWZpbmVkLm9yZGluYWwgPSA5O1xuXG5mb2FtLkxJQih7XG4gIG5hbWU6ICdmb2FtJyxcblxuICBtZXRob2RzOiBbXG4gICAgZnVuY3Rpb24gbW1ldGhvZChtYXAsIG9wdF9kZWZhdWx0TWV0aG9kKSB7XG4gICAgICB2YXIgdWlkID0gJ19fbW1ldGhvZF9fJyArIGZvYW0ubmV4dCRVSUQoKSArICdfXyc7XG5cbiAgICAgIHZhciBmaXJzdCA9IHRydWU7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oYXJnMSkge1xuICAgICAgICBpZiAoIGZpcnN0ICkge1xuICAgICAgICAgIGZvciAoIHZhciBrZXkgaW4gbWFwICkge1xuICAgICAgICAgICAgdmFyIHR5cGUgPSBrZXkgPT09ICdGT2JqZWN0JyA/XG4gICAgICAgICAgICAgICAgZm9hbS5jb3JlLkZPYmplY3QgOlxuICAgICAgICAgICAgICAgIGZvYW1ba2V5XSB8fCBmb2FtLmxvb2t1cChrZXkpO1xuXG4gICAgICAgICAgICB0eXBlW3VpZF0gPSBtYXBba2V5XTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZmlyc3QgPSBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB0eXBlID0gYXJnMSAmJiBhcmcxLmNsc18gJiYgYXJnMS5jbHNfW3VpZF0gP1xuICAgICAgICAgICAgYXJnMS5jbHNfIDpcbiAgICAgICAgICAgIGZvYW0udHlwZU9mKGFyZzEpIDtcblxuICAgICAgICBpZiAoICEgb3B0X2RlZmF1bHRNZXRob2QgKSB7XG4gICAgICAgICAgZm9hbS5hc3NlcnQodHlwZSwgJ1Vua25vd24gdHlwZTogJywgYXJnMSxcbiAgICAgICAgICAgICAgJ2FuZCBubyBkZWZhdWx0IG1ldGhvZCBwcm92aWRlZCcpO1xuICAgICAgICAgIGZvYW0uYXNzZXJ0KFxuICAgICAgICAgICAgICB0eXBlW3VpZF0sXG4gICAgICAgICAgICAgICdNaXNzaW5nIG11bHRpLW1ldGhvZCBmb3IgdHlwZSAnLCBhcmcxLCAnIG1hcDogJywgbWFwLFxuICAgICAgICAgICAgICAnYW5kIG5vIGRlYWZ1bHQgbWV0aG9kIHByb3ZpZGVkJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICggdHlwZVt1aWRdIHx8IG9wdF9kZWZhdWx0TWV0aG9kICkuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH07XG4gICAgfVxuICBdXG59KTtcblxuXG4oZnVuY3Rpb24oKSB7XG4gIHZhciB0eXBlT2YgPSBmb2FtLnR5cGVPZjtcblxuICBmb2FtLkxJQih7XG4gICAgbmFtZTogJ2ZvYW0udXRpbCcsXG5cbiAgICBtZXRob2RzOiBbXG4gICAgICBmdW5jdGlvbiBjbG9uZShvKSAgICAgIHsgcmV0dXJuIHR5cGVPZihvKS5jbG9uZShvKTsgfSxcbiAgICAgIGZ1bmN0aW9uIGVxdWFscyhhLCBiKSAgeyByZXR1cm4gdHlwZU9mKGEpLmVxdWFscyhhLCBiKTsgfSxcbiAgICAgIGZ1bmN0aW9uIGlzKGEsIGIpIHtcbiAgICAgICAgdmFyIGFUeXBlID0gdHlwZU9mKGEpO1xuICAgICAgICB2YXIgYlR5cGUgPSB0eXBlT2YoYik7XG4gICAgICAgIHJldHVybiBhVHlwZSA9PT0gYlR5cGUgJiYgYVR5cGUuaXMoYSwgYik7XG4gICAgICB9LFxuICAgICAgZnVuY3Rpb24gY29tcGFyZShhLCBiKSB7XG4gICAgICAgIC8vIFRvIGVuc3VyZSB0aGF0IHN5bW1ldHJ5IGlzIHByZXNlbnQgd2hlbiBjb21wYXJpbmcsXG4gICAgICAgIC8vIHdlIHdpbGwgYWx3YXlzIHVzZSB0aGUgY29tcGFyYXRvciBvZiBoaWdoZXIgcHJlY2VkZW5jZS5cbiAgICAgICAgdmFyIGFUeXBlID0gdHlwZU9mKGEpO1xuICAgICAgICB2YXIgYlR5cGUgPSB0eXBlT2YoYik7XG4gICAgICAgIHJldHVybiBhVHlwZS5vcmRpbmFsID4gYlR5cGUub3JkaW5hbCA/IDEgOlxuICAgICAgICAgICAgYVR5cGUub3JkaW5hbCA8IGJUeXBlLm9yZGluYWwgPyAtMSA6IGFUeXBlLmNvbXBhcmUoYSwgYik7XG4gICAgICB9LFxuICAgICAgZnVuY3Rpb24gaGFzaENvZGUobykgICB7IHJldHVybiB0eXBlT2YobykuaGFzaENvZGUobyk7IH0sXG4gICAgICBmdW5jdGlvbiBkaWZmKGEsIGIpICAgIHtcbiAgICAgICAgdmFyIHQgPSB0eXBlT2YoYSk7XG4gICAgICAgIHJldHVybiB0LmRpZmYgPyB0LmRpZmYoYSwgYikgOiB1bmRlZmluZWQ7XG4gICAgICB9LFxuICAgICAgZnVuY3Rpb24gZmxhZ0ZpbHRlcihmbGFncykge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24oYSkge1xuICAgICAgICAgIGlmICggISBmbGFncyApIHJldHVybiB0cnVlO1xuICAgICAgICAgIGlmICggISBhLmZsYWdzICkgcmV0dXJuIHRydWU7XG4gICAgICAgICAgZm9yICggdmFyIGkgPSAwLCBmOyBmID0gZmxhZ3NbaV07IGkrKyApIHtcbiAgICAgICAgICAgIGlmICggYS5mbGFncy5pbmRleE9mKGYpICE9IC0xICkgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICBdXG4gIH0pO1xufSkoKTtcblxuXG5mb2FtLkxJQih7XG4gIG5hbWU6ICdmb2FtLnBhY2thZ2UnLFxuICBtZXRob2RzOiBbXG4gICAgLyoqXG4gICAgICogUmVnaXN0ZXJzIHRoZSBnaXZlbiBjbGFzcyBpbiB0aGUgZ2xvYmFsIG5hbWVzcGFjZS5cbiAgICAgKiBJZiB0aGUgZ2l2ZW4gY2xhc3MgaGFzIGFuIGlkIG9mICdzb21lLnBhY2thZ2UuTXlDbGFzcydcbiAgICAgKiB0aGVuIHRoZSBjbGFzcyBvYmplY3Qgd2lsbCBiZSBtYWRlIGF2YWlsYWJsZSBnbG9iYWxseSBhdFxuICAgICAqIGdsb2JhbC5zb21lLnBhY2thZ2UuTXlDbGFzcy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiByZWdpc3RlckNsYXNzKGNscykge1xuICAgICAgZm9hbS5hc3NlcnQodHlwZW9mIGNscyA9PT0gJ29iamVjdCcsXG4gICAgICAgICAgJ2NscyBtdXN0IGJlIGFuIG9iamVjdCcpO1xuICAgICAgZm9hbS5hc3NlcnQodHlwZW9mIGNscy5uYW1lID09PSAnc3RyaW5nJyAmJiBjbHMubmFtZSAhPT0gJycsXG4gICAgICAgICAgJ2NscyBtdXN0IGhhdmUgYSBub24tZW1wdHkgc3RyaW5nIG5hbWUnKTtcblxuICAgICAgdmFyIHBrZyA9IGZvYW0ucGFja2FnZS5lbnN1cmVQYWNrYWdlKGdsb2JhbCwgY2xzLnBhY2thZ2UpO1xuICAgICAgcGtnW2Nscy5uYW1lXSA9IGNscztcblxuICAgICAgZm9hbS5wYWNrYWdlLnRyaWdnZXJDbGFzc18oY2xzKTtcbiAgICB9LFxuXG4gICAgZnVuY3Rpb24gd2FpdEZvckNsYXNzKGNscykge1xuICAgICAgaWYgKCBmb2FtLmxvb2t1cChjbHMsIHRydWUpICkgcmV0dXJuIFByb21pc2UucmVzb2x2ZShmb2FtLmxvb2t1cChjbHMpKTtcblxuICAgICAgZm9hbS5wYWNrYWdlLl9fcGVuZGluZyA9IGZvYW0ucGFja2FnZS5fX3BlbmRpbmcgfHwge307XG4gICAgICBmb2FtLnBhY2thZ2UuX19wZW5kaW5nW2Nsc10gPSBmb2FtLnBhY2thZ2UuX19wZW5kaW5nW2Nsc10gfHwgW107XG5cbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgZm9hbS5wYWNrYWdlLl9fcGVuZGluZ1tjbHNdLnB1c2gocmVzb2x2ZSk7XG4gICAgICB9KTtcbiAgICB9LFxuXG4gICAgZnVuY3Rpb24gdHJpZ2dlckNsYXNzXyhjbHMpIHtcbiAgICAgIGlmICggISBmb2FtLnBhY2thZ2UuX19wZW5kaW5nIHx8ICEgZm9hbS5wYWNrYWdlLl9fcGVuZGluZ1tjbHMuaWRdICkgcmV0dXJuO1xuXG4gICAgICB2YXIgcGVuZGluZyA9IGZvYW0ucGFja2FnZS5fX3BlbmRpbmdbY2xzLmlkXTtcblxuICAgICAgZm9hbS5wYWNrYWdlLl9fcGVuZGluZ1tjbHMuaWRdID0gdW5kZWZpbmVkO1xuXG4gICAgICBmb3IgKCB2YXIgaSA9IDAgOyBpIDwgcGVuZGluZy5sZW5ndGggOyBpKysgKSB7XG4gICAgICAgIHBlbmRpbmdbaV0oY2xzKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVnaXN0ZXIgYSBjbGFzcyBsYXppbHkgaW4gdGhlIGdsb2JhbCBuYW1lc3BhY2UuXG4gICAgICogVGhlIGNsYXNzIGlzIG5vdCBjcmVhdGVkIHVudGlsIGFjY2Vzc2VkIHRoZSBmaXJzdCB0aW1lLlxuICAgICAqIFRoZSBwcm92aWRlZCBmYWN0b3J5IGZ1bmN0aW9uIGNyZWF0ZXMgdGhlIGNsYXNzLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHJlZ2lzdGVyQ2xhc3NGYWN0b3J5KG0sIHRodW5rKSB7XG4gICAgICB2YXIgcGtnID0gZm9hbS5wYWNrYWdlLmVuc3VyZVBhY2thZ2UoZ2xvYmFsLCBtLnBhY2thZ2UpO1xuICAgICAgdmFyIHRtcDtcblxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFxuICAgICAgICBwa2csXG4gICAgICAgIG0ubmFtZSwge1xuICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgaWYgKCB0bXAgKSByZXR1cm4gdG1wO1xuXG4gICAgICAgICAgICB0bXAgPSB0aHVuaygpO1xuXG4gICAgICAgICAgICBmb2FtLnBhY2thZ2UudHJpZ2dlckNsYXNzXyh0bXApO1xuXG4gICAgICAgICAgICByZXR1cm4gdG1wO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogV2FsayBhIGRvdCBzZXBhcmF0ZWQgcGF0aCBzdGFydGluZyBhdCByb290LCBjcmVhdGluZyBlbXB0eVxuICAgICAqIG9iamVjdHMgaWYgbmVjZXNzYXJ5LlxuICAgICAqXG4gICAgICogZW5zdXJlUGFja2FnZShnbG9iYWwsICdzb21lLmRvdC5zZXBhcmF0ZWQucGF0aCcpO1xuICAgICAqIHdpbGwgZW5zdXJlIHRoYXQgZ2xvYmFsLnNvbWUuZG90LnNlcGFyYXRlZC5wYXRoIGV4aXN0cyB3aXRoXG4gICAgICogZWFjaCBwYXJ0IGJlaW5nIGEgSlMgb2JqZWN0LlxuICAgICAqXG4gICAgICogUmV0dXJucyByb290IGlmIHBhdGggaXMgbnVsbCBvciB1bmRlZmluZWQuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZW5zdXJlUGFja2FnZShyb290LCBwYXRoKSB7XG4gICAgICBpZiAoIHBhdGggPT09IG51bGwgfHxcbiAgICAgICAgICAgcGF0aCA9PT0gdW5kZWZpbmVkIHx8XG4gICAgICAgICAgIHBhdGggPT09ICcnICkge1xuICAgICAgICByZXR1cm4gcm9vdDtcbiAgICAgIH1cblxuICAgICAgZm9hbS5hc3NlcnQodHlwZW9mIHBhdGggPT09ICdzdHJpbmcnLFxuICAgICAgICAgICdDYW5ub3QgbWFrZSBhIHBhY2thZ2UgcGF0aCBvZiBhIG5vbi1zdHJpbmcnKTtcblxuICAgICAgcGF0aCA9IHBhdGguc3BsaXQoJy4nKTtcbiAgICAgIHZhciBub2RlID0gcm9vdDtcblxuICAgICAgZm9yICggdmFyIGkgPSAwIDsgaSA8IHBhdGgubGVuZ3RoIDsgaSsrICkge1xuICAgICAgICBub2RlID0gbm9kZVtwYXRoW2ldXSB8fCAoIG5vZGVbcGF0aFtpXV0gPSB7fSApO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbm9kZTtcbiAgICB9XG4gIF1cbn0pO1xuXG5cbmZvYW0uTElCKHtcbiAgbmFtZTogJ2ZvYW0udXVpZCcsXG4gIG1ldGhvZHM6IFtcbiAgICBmdW5jdGlvbiByYW5kb21HVUlEKCkge1xuICAgICAgcmV0dXJuICd4eHh4eHh4eC14eHh4LTR4eHgteXh4eC14eHh4eHh4eHh4eHgnLnJlcGxhY2UoL1t4eV0vZywgZnVuY3Rpb24oYykge1xuICAgICAgICB2YXIgciA9IE1hdGgucmFuZG9tKCkgKiAxNiB8IDA7XG4gICAgICAgIHZhciB2ID0gYyA9PT0gJ3gnID8gciA6ICggciAmIDB4MyB8IDB4OCApO1xuICAgICAgICByZXR1cm4gdi50b1N0cmluZygxNik7XG4gICAgICB9KTtcbiAgICB9XG4gIF1cbn0pO1xuXG5cbmZvYW0uTElCKHtcbiAgbmFtZTogJ2ZvYW0uY29tcGFyZScsXG4gIG1ldGhvZHM6IFtcbiAgICBmdW5jdGlvbiB0b0NvbXBhcmUoYykge1xuICAgICAgcmV0dXJuIGZvYW0uQXJyYXkuaXNJbnN0YW5jZShjKSAgICA/IGZvYW0uY29tcGFyZS5jb21wb3VuZChjKSA6XG4gICAgICAgICAgICAgZm9hbS5GdW5jdGlvbi5pc0luc3RhbmNlKGMpID8geyBjb21wYXJlOiBjfSA6XG4gICAgICAgICAgICAgYyA7XG4gICAgfSxcblxuICAgIC8vIEdldHMgcmVwbGFjZWQgaW4gbWxhbmcuanNcbiAgICBmdW5jdGlvbiBjb21wb3VuZChhcmdzKSB7XG4gICAgICAvKiBDcmVhdGUgYSBjb21wb3VuZCBjb21wYXJhdG9yIGZyb20gYW4gYXJyYXkgb2YgY29tcGFyYXRvcnMuICovXG4gICAgICB2YXIgY3MgPSBhcmdzLm1hcChmb2FtLmNvbXBhcmUudG9Db21wYXJlKTtcbiAgICAgIGlmICggY3MubGVuZ2ggPT09IDEgKSByZXR1cm4gY3NbMF07XG5cbiAgICAgIHZhciBmID0ge1xuICAgICAgICBjb21wYXJlOiBmdW5jdGlvbihvMSwgbzIpIHtcbiAgICAgICAgICBmb3IgKCB2YXIgaSA9IDAgOyBpIDwgY3MubGVuZ3RoIDsgaSsrICkge1xuICAgICAgICAgICAgdmFyIHIgPSBjc1tpXS5jb21wYXJlKG8xLCBvMik7XG4gICAgICAgICAgICBpZiAoIHIgIT0gMCApIHJldHVybiByO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgcmV0dXJuIGY7XG4gICAgfVxuICBdXG59KTtcbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbi8qKlxuICogRXZlbnQgbGlzdGVuZXIgdXRpbGl0aWVzLlxuICovXG5mb2FtLkxJQih7XG4gIG5hbWU6ICdmb2FtLmV2ZW50cycsXG5cbiAgbWV0aG9kczogW1xuICAgIGZ1bmN0aW9uIG9uZVRpbWUobGlzdGVuZXIpIHtcbiAgICAgIC8qKiBDcmVhdGUgYSBcIm9uZS10aW1lXCIgbGlzdGVuZXIgd2hpY2ggdW5zdWJzY3JpYmVzIGl0c2VsZiB3aGVuIGNhbGxlZC4gKiovXG4gICAgICByZXR1cm4gZnVuY3Rpb24oc3Vic2NyaXB0aW9uKSB7XG4gICAgICAgIHN1YnNjcmlwdGlvbi5kZXRhY2goKTtcbiAgICAgICAgbGlzdGVuZXIuYXBwbHkodGhpcywgQXJyYXkuZnJvbShhcmd1bWVudHMpKTtcbiAgICAgIH07XG4gICAgfSxcblxuICAgIGZ1bmN0aW9uIGNvbnNvbGVMb2cobGlzdGVuZXIpIHtcbiAgICAgIC8qKiBMb2cgYWxsIGxpc3RlbmVyIGludm9jYXRpb25zIHRvIGNvbnNvbGUuICoqL1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgYXJncyA9IEFycmF5LmZyb20oYXJndW1lbnRzKTtcbiAgICAgICAgY29uc29sZS5sb2coYXJncyk7XG4gICAgICAgIGxpc3RlbmVyICYmIGxpc3RlbmVyLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgICAgfTtcbiAgICB9XG4gIF1cbn0pO1xuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTYgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuLyoqXG4gKiBDb250ZXh0IFN1cHBvcnRcbiAqXG4gKiBDb250ZXh0cywgYWxzbyBrbm93biBhcyBmcmFtZXMsIHNjb3BlcyBvciBlbnZpcm9ubWVudHMsIGFyZSB1c2VkIHRvIHN0b3JlXG4gKiBuYW1lZCByZXNvdXJjZXMuIFRoZXkgcHJvdmlkZSBhbiBvYmplY3Qtb3JpZW50ZWQgcmVwbGFjZW1lbnQgZm9yIGdsb2JhbFxuICogdmFyaWFibGVzLiBDb250ZXh0cyBhcmUgaW1tdXRhYmxlLiBOZXcgYmluZGluZ3MgYXJlIGFkZGVkIGJ5IGNyZWF0aW5nXG4gKiBcInN1Yi1jb250ZXh0c1wiIHdpdGggbmV3IGJpbmRpbmdzLCBmcm9tIGFuIGV4aXN0aW5nIHBhcmVudCBjb250ZXh0LlxuICogU3ViLWNvbnRleHRzIGluaGVyaXQgYmluZGluZ3MgZnJvbSB0aGVpciBwYXJlbnQuXG4gKlxuICogQ29udGV4dHMgcHJvdmlkZSBhIGZvcm0gb2YgaW52ZXJzaW9uLW9mLWNvbnRyb2wgb3IgZGVwZW5kZW5kZW5jeS1pbmplY3Rpb24uXG4gKiBOb3JtYWxseSwgY29udGV4dHMgYXJlIG5vdCBleHBsaWNpdGx5IHVzZWQgYmVjYXVzZSBGT0FNJ3MgaW1wb3J0cy9leHBvcnRzXG4gKiBtZWNoYW5pc20gcHJvdmlkZXMgYSBoaWdoLWxldmVsIGRlY2xhcmF0aXZlIG1ldGhvZCBvZiBkZXBlbmRlbmN5IG1hbmFnZW1lbnRcbiAqIHdoaWNoIGhpZGVzIHRoZWlyIHVzZS5cbiAqXG4gKiBmb2FtLl9fY29udGV4dF9fIHJlZmVyZW5jZXMgdGhlIHJvb3QgY29udGV4dCwgd2hpY2ggaXMgdGhlIGFuY2VzdG9yIG9mIGFsbCBvdGhlclxuICogY29udGV4dHMuXG4gKi9cblxuKGZ1bmN0aW9uKCkge1xuICB2YXIgX19jb250ZXh0X18gPSB7XG4gICAgLyoqXG4gICAgICogTG9va3VwIGEgY2xhc3MgaW4gdGhlIGNvbnRleHQuICBUaHJvd3MgYW4gZXhjZXB0aW9uIGlmIHRoZSB2YWx1ZVxuICAgICAqIGNvdWxkbid0IGJlIGZvdW5kLCB1bmxlc3Mgb3B0X3N1cHByZXNzIGlzIHRydWUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gaWQgVGhlIGlkIG9mIHRoZSBjbGFzcyB0byBsb29rdXAuXG4gICAgICogQHBhcmFtIG9wdF9zdXBwcmVzcyBTdXBwcmVzcyB0aHJvd2luZyBhbiBlcnJvci5cbiAgICAgKiovXG4gICAgbG9va3VwOiBmdW5jdGlvbihpZCwgb3B0X3N1cHByZXNzKSB7XG4gICAgICB2YXIgcmV0ID0gdHlwZW9mIGlkID09PSAnc3RyaW5nJyAmJiB0aGlzLl9fY2FjaGVfX1tpZF07XG5cbiAgICAgIGlmICggISBvcHRfc3VwcHJlc3MgKSB7XG4gICAgICAgIGZvYW0uYXNzZXJ0KFxuICAgICAgICAgICAgcmV0LFxuICAgICAgICAgICAgJ0NvdWxkIG5vdCBmaW5kIGFueSByZWdpc3RlcmVkIGNsYXNzIGZvciAnICsgaWQpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZm9hbS5GdW5jdGlvbi5pc0luc3RhbmNlKHJldCkgPyByZXQoKSA6IHJldDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVnaXN0ZXIgYSBjbGFzcyBpbnRvIHRoZSBnaXZlbiBjb250ZXh0LiAgQWZ0ZXIgcmVnaXN0cmF0aW9uXG4gICAgICogdGhlIGNsYXNzIGNhbiBiZSBmb3VuZCBhZ2FpbiBieSBjYWxsaW5nIGZvYW0ubG9va3VwKCdjb20uZm9vLlNvbWVDbGFzcycpO1xuICAgICAqXG4gICAgICogQHBhcmFtIGNscyAgICBUaGUgY2xhc3MgdG8gcmVnaXN0ZXIuXG4gICAgICogQHBhcmFtIG9wdF9pZCBPcHRpb25hbCBpZCB1bmRlciB3aGljaCB0byByZWdpc3RlciBjbGFzcy5cbiAgICAgKi9cbiAgICByZWdpc3RlcjogZnVuY3Rpb24oY2xzLCBvcHRfaWQpIHtcbiAgICAgIGZvYW0uYXNzZXJ0KFxuICAgICAgICB0eXBlb2YgY2xzID09PSAnb2JqZWN0JyxcbiAgICAgICAgJ0Nhbm5vdCByZWdpc3RlciBub24tb2JqZWN0cyBpbnRvIGEgY29udGV4dC4nKTtcblxuICAgICAgaWYgKCBvcHRfaWQgKSB7XG4gICAgICAgIHRoaXMucmVnaXN0ZXJJbkNhY2hlXyhjbHMsIHRoaXMuX19jYWNoZV9fLCBvcHRfaWQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZm9hbS5hc3NlcnQoXG4gICAgICAgICAgICB0eXBlb2YgY2xzLmlkID09PSAnc3RyaW5nJyxcbiAgICAgICAgICAgICdNdXN0IGhhdmUgYW4gLmlkIHByb3BlcnR5IHRvIGJlIHJlZ2lzdGVyZWQgaW4gYSBjb250ZXh0LicpO1xuXG4gICAgICAgIHRoaXMucmVnaXN0ZXJJbkNhY2hlXyhjbHMsIHRoaXMuX19jYWNoZV9fLCBjbHMuaWQpO1xuXG4gICAgICAgIGlmICggY2xzLnBhY2thZ2UgPT09ICdmb2FtLmNvcmUnICkge1xuICAgICAgICAgIHRoaXMucmVnaXN0ZXJJbkNhY2hlXyhjbHMsIHRoaXMuX19jYWNoZV9fLCBjbHMubmFtZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVnaXN0ZXIgYSBjbGFzcyBmYWN0b3J5IGludG8gdGhlIGdpdmVuIGNvbnRleHQuXG4gICAgICogV2hlbiB0aGUgY2xhc3MgaXMgZmlyc3QgYWNjZXNzZWQgdGhlIGZhY3RvcnkgaXMgdXNlZFxuICAgICAqIHRvIGNyZWF0ZSB0aGUgdmFsdWUgd2hpY2ggaXMgdXNlZC5cbiAgICAgKi9cbiAgICByZWdpc3RlckZhY3Rvcnk6IGZ1bmN0aW9uKG0sIGZhY3RvcnkpIHtcbiAgICAgIGZvYW0uYXNzZXJ0KFxuICAgICAgICB0eXBlb2YgbS5pZCA9PT0gJ3N0cmluZycsXG4gICAgICAgICdNdXN0IGhhdmUgYW4gLmlkIHByb3BlcnR5IHRvIGJlIHJlZ2lzdGVyZWQgaW4gYSBjb250ZXh0LicpO1xuXG4gICAgICB0aGlzLnJlZ2lzdGVySW5DYWNoZV8oZmFjdG9yeSwgdGhpcy5fX2NhY2hlX18sIG0uaWQpO1xuXG4gICAgICBpZiAoIG0ucGFja2FnZSA9PT0gJ2ZvYW0uY29yZScgKSB7XG4gICAgICAgIHRoaXMucmVnaXN0ZXJJbkNhY2hlXyhmYWN0b3J5LCB0aGlzLl9fY2FjaGVfXywgbS5uYW1lKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0cnVlIGlmIHRoZSBtb2RlbCBJRCBoYXMgYmVlbiByZWdpc3RlcmVkLiBGYWxzZSBvdGhlcndpc2UuXG4gICAgICovXG4gICAgaXNSZWdpc3RlcmVkOiBmdW5jdGlvbihtb2RlbElkKSB7XG4gICAgICByZXR1cm4gISEgdGhpcy5fX2NhY2hlX19bbW9kZWxJZF07XG4gICAgfSxcblxuICAgIC8qKiBJbnRlcm5hbCBtZXRob2QgdG8gcmVnaXN0ZXIgYSBjb250ZXh0IGJpbmRpbmcgaW4gYW4gaW50ZXJuYWwgY2FjaGUgKi9cbiAgICByZWdpc3RlckluQ2FjaGVfOiBmdW5jdGlvbiByZWdpc3RlckluQ2FjaGVfKGNscywgY2FjaGUsIG5hbWUpIHtcbiAgICAgIHZhciBoYXNPbGQgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoY2FjaGUsIG5hbWUpO1xuICAgICAgdmFyIG9sZCA9IGNhY2hlW25hbWVdO1xuXG4gICAgICAvLyBPa2F5IHRvIHJlcGxhY2UgYSBmdW5jdGlvbiB3aXRoIGFuIGFjdHVhbCBjbGFzcy5cbiAgICAgIC8vIFRoaXMgaGFwcGVucyBhZnRlciBhIGxhenkgY2xhc3MgaXMgaW5pdGlhbGl6ZWQuXG4gICAgICBmb2FtLmFzc2VydChcbiAgICAgICAgICAhIGhhc09sZCB8fFxuICAgICAgICAgICAgICAoZm9hbS5GdW5jdGlvbi5pc0luc3RhbmNlKG9sZCkgJiYgISBmb2FtLkZ1bmN0aW9uLmlzSW5zdGFuY2UoY2xzKSksXG4gICAgICAgICAgbmFtZSArICcgaXMgYWxyZWFkeSByZWdpc3RlcmVkIGluIHRoaXMgY29udGV4dC4nKTtcblxuICAgICAgY2FjaGVbbmFtZV0gPSBjbHM7XG4gICAgfSxcblxuICAgIC8qKiBJbnRlcm5hbCBtZXRob2QgdG8gY3JlYXRlIGEgc2xvdCBuYW1lIGZvciBhIHNwZWNpZmllZCBrZXkuICovXG4gICAgdG9TbG90TmFtZV86IGZvYW0uRnVuY3Rpb24ubWVtb2l6ZTEoZnVuY3Rpb24gdG9TbG90TmFtZV8oa2V5KSB7XG4gICAgICByZXR1cm4ga2V5ICsgJyQnO1xuICAgIH0pLFxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIHN1YiBjb250ZXh0IG9mIHRoZSBjb250ZXh0IHRoYXQgdGhpcyBpcyBjYWxsZWQgdXBvbi5cbiAgICAgKiBAcGFyYW0gb3B0X2FyZ3MgQSBtYXAgb2YgYmluZGluZ3MgdG8gc2V0IHVwIGluIHRoZSBzdWIgY29udGV4dC5cbiAgICAgKiAgICAgQ3VycmVudGx5IHVudXNlZC5cbiAgICAgKi9cbiAgICBjcmVhdGVTdWJDb250ZXh0OiBmdW5jdGlvbiBjcmVhdGVTdWJDb250ZXh0KG9wdF9hcmdzLCBvcHRfbmFtZSkge1xuICAgICAgaWYgKCAhIG9wdF9hcmdzICkgcmV0dXJuIHRoaXM7XG5cbiAgICAgIGZvYW0uYXNzZXJ0KFxuICAgICAgICAgIG9wdF9uYW1lID09PSB1bmRlZmluZWQgfHwgdHlwZW9mIG9wdF9uYW1lID09PSAnc3RyaW5nJyxcbiAgICAgICAgICAnb3B0X25hbWUgbXVzdCBiZSBsZWZ0IHVuZGVmaW5lZCBvciBiZSBhIHN0cmluZy4nKTtcblxuICAgICAgdmFyIHN1YiA9IE9iamVjdC5jcmVhdGUodGhpcyk7XG5cbiAgICAgIGlmICggb3B0X25hbWUgKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShzdWIsICdOQU1FJywge1xuICAgICAgICAgIHZhbHVlOiBvcHRfbmFtZSxcbiAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZVxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgZm9yICggdmFyIGtleSBpbiBvcHRfYXJncyApIHtcbiAgICAgICAgaWYgKCBvcHRfYXJncy5oYXNPd25Qcm9wZXJ0eShrZXkpICkge1xuICAgICAgICAgIHZhciB2ID0gb3B0X2FyZ3Nba2V5XTtcblxuICAgICAgICAgIGlmICggISBmb2FtLmNvcmUuU2xvdC5pc0luc3RhbmNlKHYpICkge1xuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHN1YiwgdGhpcy50b1Nsb3ROYW1lXyhrZXkpLCB7XG4gICAgICAgICAgICAgIHZhbHVlOiBmb2FtLmNvcmUuQ29uc3RhbnRTbG90LmNyZWF0ZSh7IHZhbHVlOiB2IH0pLFxuICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHN1Yiwga2V5LCB7XG4gICAgICAgICAgICAgIHZhbHVlOiB2LFxuICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHN1YiwgdGhpcy50b1Nsb3ROYW1lXyhrZXkpLCB7XG4gICAgICAgICAgICAgIHZhbHVlOiB2LFxuICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgKGZ1bmN0aW9uKHYpIHtcbiAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHN1Yiwga2V5LCB7XG4gICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIHYuZ2V0KCk7IH0sXG4gICAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pKHYpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoc3ViLCAnX19jYWNoZV9fJywge1xuICAgICAgICB2YWx1ZTogT2JqZWN0LmNyZWF0ZSh0aGlzLl9fY2FjaGVfXyksXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlXG4gICAgICB9KTtcblxuICAgICAgZm9hbS5PYmplY3QuZnJlZXplKHN1Yik7XG5cbiAgICAgIHJldHVybiBzdWI7XG4gICAgfVxuICB9O1xuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfX2NvbnRleHRfXywgJ19fY2FjaGVfXycsIHtcbiAgICB2YWx1ZToge30sXG4gICAgZW51bWVyYWJsZTogZmFsc2VcbiAgfSk7XG5cbiAgLy8gQ3JlYXRlIHNob3J0LWN1dHMgZm9yIGZvYW0uX19jb250ZXh0X18uW2NyZWF0ZVN1YkNvbnRleHQsIHJlZ2lzdGVyLCBsb29rdXBdXG4gIC8vIGluIGZvYW0uXG4gIGZvYW0ubG9va3VwID0gZnVuY3Rpb24oaWQsIG9wdF9zdXBwcmVzcykge1xuICAgIHJldHVybiBmb2FtLl9fY29udGV4dF9fLmxvb2t1cChpZCwgb3B0X3N1cHByZXNzKTtcbiAgfTtcbiAgZm9hbS5yZWdpc3RlciA9IGZ1bmN0aW9uKGNscywgb3B0X2lkKSB7XG4gICAgZm9hbS5fX2NvbnRleHRfXy5yZWdpc3RlcihjbHMsIG9wdF9pZCk7XG4gIH07XG4gIGZvYW0uY3JlYXRlU3ViQ29udGV4dCA9IGZ1bmN0aW9uKG9wdF9hcmdzLCBvcHRfbmFtZSkge1xuICAgIHJldHVybiBmb2FtLl9fY29udGV4dF9fLmNyZWF0ZVN1YkNvbnRleHQob3B0X2FyZ3MsIG9wdF9uYW1lKTtcbiAgfTtcblxuICBmb2FtLl9fY29udGV4dF9fID0gX19jb250ZXh0X187XG59KSgpO1xuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTYgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuLyoqXG4gRk9BTSBCb290c3RyYXBcbjxwPlxuIEZPQU0gdXNlcyBNb2RlbHMgdG8gc3BlY2lmeSBjbGFzcyBkZWZpbml0aW9ucy5cbiBUaGUgRk9BTSBNb2RlbCBjbGFzcyBpcyBpdHNlbGYgc3BlY2lmaWVkIHdpdGggYSBGT0FNIG1vZGVsLCBtZWFuaW5nXG4gdGhhdCBNb2RlbCBpcyBkZWZpbmVkIGluIHRoZSBzYW1lIGxhbmd1YWdlIHdoaWNoIGl0IGRlZmluZXMuXG4gVGhpcyBzZWxmLW1vZGVsaW5nIHN5c3RlbSByZXF1aXJlcyBzb21lIGNhcmUgdG8gYm9vdHN0cmFwLCBidXQgcmVzdWx0c1xuIGluIGEgdmVyeSBjb21wYWN0LCB1bmlmb3JtLCBhbmQgcG93ZXJmdWwgc3lzdGVtLlxuPHByZT5cblxuIEZPYmplY3QgLT4gRk9iamVjdCBDbGFzcyAgICAgICAgICAgICAgICAgICAgIFByb3RvdHlwZVxuICAgIF4gICAgICAgICAgICAgICAgICAgICAgICArLS5wcm90b3R5cGUtLS0tLS0tLS1eXG4gICAgfCAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgICAgICAgICAgICAgICAgIHxcbiAgTW9kZWwgIC0+IGJ1aWxkQ2xhc3MoKSAgLT4gQ2xhc3MgLT4gY3JlYXRlKCkgLT4gaW5zdGFuY2VcbjwvcHJlPlxuICBGT2JqZWN0IGlzIHRoZSByb290IG1vZGVsL2NsYXNzIG9mIGFsbCBvdGhlciBjbGFzc2VzLCBpbmNsdWRpbmcgTW9kZWwuXG4gIEFic3RyYWN0IENsYXNzIGlzIHRoZSBwcm90b3R5cGUgb2YgRk9iamVjdCdzIENsYXNzLCB3aGljaCBtYWtlcyBpdCB0aGUgcm9vdCBvZiBhbGwgQ2xhc3Nlcy5cbiAgRnJvbSBhIE1vZGVsIHdlIGNhbGwgYnVpbGRDbGFzcygpIHRvIGNyZWF0ZSBhIENsYXNzIChvciB0aGUgcHJldmlvdXNseSBjcmVhdGVkIENsYXNzKSBvYmplY3QuXG4gIEZyb20gdGhlIENsYXNzIHdlIGNhbGwgY3JlYXRlKCkgdG8gY3JlYXRlIG5ldyBpbnN0YW5jZXMgb2YgdGhhdCBjbGFzcy5cbiAgTmV3IGluc3RhbmNlcyBleHRlbmQgdGhlIGNsYXNzZXMgcHJvdG90eXBlIG9iamVjdCwgd2hpY2ggaXMgc3RvcmVkIG9uIHRoZSBjbGFzcyBhcyAucHJvdG90eXBlLlxuPHByZT5cbiAgaW5zdGFuY2UgLS0tPiAuY2xzXyAgIC0+IE9iamVjdCdzIENsYXNzXG4gICAgICAgfFxuICAgICAgICstLS0tLS0+IC5tb2RlbF8gLT4gT2JqZWN0J3MgTW9kZWxcbjwvcHJlPlxuICBBbGwgZGVzY2VuZGVudHMgb2YgRk9iamVjdCBoYXZlIHJlZmVyZW5jZXMgdG8gYm90aCB0aGVpciBNb2RlbCBhbmQgQ2xhc3MuXG4gICAgLSBvYmouY2xzXyByZWZlcnMgdG8gYW4gT2JqZWN0J3MgQ2xhc3NcbiAgICAtIG9iai5tb2RlbF8gcmVmZXJzIHRvIGFuIE9iamVjdCdzIE1vZGVsXG5cbjxwPiAgQ2xhc3NlcyBhbHNvIHJlZmVyIHRvIHRoZWlyIE1vZGVsIHdpdGggLm1vZGVsXy5cblxuPHA+ICBNb2RlbCBpcyBpdHMgb3duIGRlZmluaXRpb246XG48cHJlPlxuICAgIE1vZGVsLmJ1aWxkQ2xhc3MoKS5jcmVhdGUoTW9kZWwpID09IE1vZGVsXG4gICAgTW9kZWwubW9kZWxfID09PSBNb2RlbFxuPC9wcmU+XG4gIE1vZGVscyBhcmUgZGVmaW5lZCBhcyBhIGNvbGxlY3Rpb24gb2YgQXhpb21zLlxuICBJdCBpcyB0aGUgcmVzcG9uc2liaWxpdHkgb2YgQXhpb21zIHRvIGluc3RhbGwgaXRzZWxmIG9udG8gYSBNb2RlbCdzIENsYXNzIGFuZC9vciBQcm90b3R5cGUuXG5cbjxwPlxuICBBeGlvbXMgYXJlIGRlZmluZWQgd2l0aCB0aGUgZm9sbG93aW5nIHBzZWRvLWludGVyZmFjZTpcbjxwcmU+XG4gICAgcHVibGljIGludGVyZmFjZSBBeGlvbSB7XG4gICAgICBvcHRpb25hbCBpbnN0YWxsSW5DbGFzcyhjbHMpXG4gICAgICBvcHRpb25hbCBpbnN0YWxsSW5Qcm90byhwcm90bylcbiAgICB9XG48L3ByZT5cbiAgRXguIG9mIGEgTW9kZWwgd2l0aCBvbmUgQXhpb206XG48cHJlPlxuICBmb2FtLkNMQVNTKHtcbiAgICBuYW1lOiAnU2FtcGxlJyxcblxuICAgIGF4aW9tczogW1xuICAgICAge1xuICAgICAgICBuYW1lOiAnYXhpb20xJyxcbiAgICAgICAgaW5zdGFsbEluQ2xhc3M6IGZ1bmN0aW9uKGNscykgeyAuLi4gfSxcbiAgICAgICAgaW5zdGFsbEluUHJvdG86IGZ1bmN0aW9uKHByb3RvKSB7IC4uLiB9XG4gICAgICB9XG4gICAgXVxuICB9KTtcbjwvcHJlPlxuICBBeGlvbXMgY2FuIGJlIGFkZGVkIGVpdGhlciBkdXJpbmcgdGhlIGluaXRpYWwgY3JlYXRpb24gb2YgYSBjbGFzcyBhbmQgcHJvdG90eXBlLFxuICBvciBhbnl0aW1lIGFmdGVyLiAgVGhpcyBhbGxvd3MgY2xhc3NlcyB0byBiZSBleHRlbmRlZCB3aXRoIG5ldyBmdW5jdGlvbmFsaXR5LFxuICBhbmQgdGhpcyBpcyB2ZXJ5IGltcG9ydGFudCB0byB0aGUgYm9vdHN0cmFwIHByb2Nlc3MgYmVjYXVzZSBpdCBhbGxvd3MgdXMgdG9cbiAgc3RhcnQgb3V0IHdpdGggdmVyeSBzaW1wbGUgZGVmaW5pdGlvbnMgb2YgTW9kZWwgYW5kIEZPYmplY3QsIGFuZCB0aGVuIGJ1aWxkXG4gIHRoZW0gdXAgdW50aWwgdGhleSdyZSBmdWxseSBib290c3RyYXBwZWQuXG48cD5cbiAgSG93ZXZlciwgcmF3IGF4aW9tcyBhcmUgcmFyZWx5IHVzZWQgZGlyZWN0bHkuIEluc3RlYWQgd2UgbW9kZWwgaGlnaGVyLWxldmVsXG4gIGF4aW9tIHR5cGVzLCBpbmNsdWRpbmc6XG48dWw+XG4gIDxsaT5SZXF1aXJlcyAgIC0gUmVxdWlyZSBvdGhlciBjbGFzc2VzXG4gIDxsaT5JbXBvcnRzICAgIC0gQ29udGV4dCBpbXBvcnRzXG4gIDxsaT5FeHBvcnRzICAgIC0gQ29udGV4dCBleHBvcnRzXG4gIDxsaT5JbXBsZW1lbnRzIC0gRGVjbGFyZSBpbnRlcmZhY2VzIGltcGxlbWVudGVkIC8gbWl4LWlucyBtaXhlZC1pblxuICA8bGk+Q29uc3RhbnRzICAtIEFkZCBjb25zdGFudHMgdG8gdGhlIHByb3RvdHlwZSBhbmQgY2xhc3NcbiAgPGxpPlByb3BlcnRpZXMgLSBIaWdoLWxldmVsIGluc3RhbmNlIHZhcmlhYmxlIGRlZmluaXRpb25zXG4gIDxsaT5NZXRob2RzICAgIC0gUHJvdG90eXBlIG1ldGhvZHNcbiAgPGxpPlRvcGljcyAgICAgLSBQdWJsaXNoL3N1YiB0b3BpY3NcbiAgPGxpPkxpc3RlbmVycyAgLSBMaWtlIG1ldGhvZHMsIGJ1dCB3aXRoIGV4dHJhIGZlYXR1cmVzIGZvciB1c2UgYXMgY2FsbGJhY2tzXG48L3VsPlxuXG4qL1xuXG5cbi8qKlxuIEJvb3RzdHJhcCBzdXBwb3J0LlxuXG4gSXMgZGlzY2FyZGVkIGFmdGVyIHVzZS5cbiovXG5mb2FtLkxJQih7XG4gIG5hbWU6ICdmb2FtLmJvb3QnLFxuXG4gIGNvbnN0YW50czoge1xuICAgIHN0YXJ0VGltZTogRGF0ZS5ub3coKSxcbiAgfSxcblxuICBtZXRob2RzOiBbXG4gICAgLyoqXG4gICAgICBDcmVhdGUgb3IgVXBkYXRlIGEgUHJvdG90eXBlIGZyb20gYSBNb2RlbCBkZWZpbml0aW9uLlxuXG4gICAgICBUaGlzIHdpbGwgYmUgYWRkZWQgYXMgYSBtZXRob2Qgb24gdGhlIE1vZGVsIGNsYXNzXG4gICAgICB3aGVuIGl0IGlzIGV2ZW50dWFsbHkgYnVpbHQuXG5cbiAgICAgIChNb2RlbCBpcyAndGhpcycpLlxuICAgICovXG4gICAgZnVuY3Rpb24gYnVpbGRDbGFzcygpIHtcbiAgICAgIHZhciBjb250ZXh0ID0gdGhpcy5fX2NvbnRleHRfXyB8fCBmb2FtLl9fY29udGV4dF9fO1xuICAgICAgdmFyIGNscztcblxuICAgICAgaWYgKCB0aGlzLnJlZmluZXMgKSB7XG4gICAgICAgIGNscyA9IGNvbnRleHQubG9va3VwKHRoaXMucmVmaW5lcyk7XG4gICAgICAgIGZvYW0uYXNzZXJ0KGNscywgJ1Vua25vd24gcmVmaW5lbWVudCBjbGFzczogJyArIHRoaXMucmVmaW5lcyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmb2FtLmFzc2VydCh0aGlzLmlkLCAnTWlzc2luZyBpZCBuYW1lLicsIHRoaXMubmFtZSk7XG4gICAgICAgIGZvYW0uYXNzZXJ0KHRoaXMubmFtZSwgJ01pc3NpbmcgY2xhc3MgbmFtZS4nKTtcblxuICAgICAgICB2YXIgcGFyZW50ID0gdGhpcy5leHRlbmRzICAgICAgP1xuICAgICAgICAgIGNvbnRleHQubG9va3VwKHRoaXMuZXh0ZW5kcykgOlxuICAgICAgICAgIGZvYW0uY29yZS5GT2JqZWN0ICAgICAgICAgICAgO1xuXG4gICAgICAgIGNscyAgICAgICAgICAgICAgICAgID0gcGFyZW50LmNyZWF0ZVN1YkNsYXNzXygpO1xuICAgICAgICBjbHMucHJvdG90eXBlLmNsc18gICA9IGNscztcbiAgICAgICAgY2xzLnByb3RvdHlwZS5tb2RlbF8gPSB0aGlzO1xuICAgICAgICBjbHMuY291bnRfICAgICAgICAgICA9IDA7ICAgICAgICAgICAgLy8gTnVtYmVyIG9mIGluc3RhbmNlcyBjcmVhdGVkXG4gICAgICAgIGNscy5pZCAgICAgICAgICAgICAgID0gdGhpcy5pZDtcbiAgICAgICAgY2xzLnBhY2thZ2UgICAgICAgICAgPSB0aGlzLnBhY2thZ2U7XG4gICAgICAgIGNscy5uYW1lICAgICAgICAgICAgID0gdGhpcy5uYW1lO1xuICAgICAgICBjbHMubW9kZWxfICAgICAgICAgICA9IHRoaXM7XG5cbiAgICAgICAgLy8gSW5zdGFsbCBhbiBGT2JqZWN0IG9uIHRoZSBjbGFzcyB0aGF0IHdlIGNhbiB1c2UgYXMgYSBwdWIvc3ViIGh1Yi5cbiAgICAgICAgLy8gV2UgaGF2ZSB0byBkbyB0aGlzIGJlY2F1c2UgY2xhc3NlcyBhcmVuJ3QgRk9iamVjdHMuXG4gICAgICAgIC8vIFRoaXMgaXMgdXNlZCB0byBwdWJsaXNoICdpbnN0YWxsQXhpb20nIGV2ZW50cyB0bywgc28gdGhhdCBkZXNjZW5kZW50c1xuICAgICAgICAvLyBwcm9wZXJ0aWVzIGtub3cgd2hlbiB0aGV5IG5lZWQgdG8gYmUgcmUtaW5zdGFsbGVkLlxuICAgICAgICBpZiAoIGNscyAhPT0gZm9hbS5jb3JlLkZPYmplY3QgKSB7XG4gICAgICAgICAgY2xzLnB1YnN1Yl8gPSBmb2FtLmNvcmUuRk9iamVjdC5jcmVhdGUoKTtcblxuICAgICAgICAgIC8vIFJlbGF5ICdpbnN0YWxsQXhpb20nIGV2ZW50cyBmcm9tIHBhcmVudCBjbGFzcy5cbiAgICAgICAgICBwYXJlbnQucHVic3ViXyAmJiBwYXJlbnQucHVic3ViXy5zdWIoXG4gICAgICAgICAgICAnaW5zdGFsbEF4aW9tJyxcbiAgICAgICAgICAgIGZ1bmN0aW9uKF8sIGExLCBhMiwgYTMpIHsgY2xzLnB1YnN1Yl8ucHViKGExLCBhMiwgYTMpOyB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBjbHMuaW5zdGFsbE1vZGVsKHRoaXMpO1xuXG4gICAgICByZXR1cm4gY2xzO1xuICAgIH0sXG5cbiAgICBmdW5jdGlvbiBzdGFydCgpIHtcbiAgICAgIC8qIFN0YXJ0IHRoZSBib290c3RyYXAgcHJvY2Vzcy4gKi9cblxuICAgICAgdmFyIGJ1aWxkQ2xhc3MgPSB0aGlzLmJ1aWxkQ2xhc3M7XG5cbiAgICAgIC8vIFdpbGwgYmUgcmVwbGFjZWQgaW4gcGhhc2UyLlxuICAgICAgZm9hbS5DTEFTUyA9IGZ1bmN0aW9uKG0pIHtcbiAgICAgICAgbS5pZCA9IG0ucGFja2FnZSArICcuJyArIG0ubmFtZTtcbiAgICAgICAgdmFyIGNscyA9IGJ1aWxkQ2xhc3MuY2FsbChtKTtcblxuICAgICAgICBmb2FtLmFzc2VydChcbiAgICAgICAgICAhIG0ucmVmaW5lcyxcbiAgICAgICAgICAnUmVmaW5lcyBpcyBub3Qgc3VwcG9ydGVkIGluIGVhcmx5IGJvb3RzdHJhcCcpO1xuXG4gICAgICAgIGZvYW0ucmVnaXN0ZXIoY2xzKTtcblxuICAgICAgICAvLyBSZWdpc3RlciB0aGUgY2xhc3MgaW4gdGhlIGdsb2JhbCBwYWNrYWdlIHBhdGguXG4gICAgICAgIGZvYW0ucGFja2FnZS5yZWdpc3RlckNsYXNzKGNscyk7XG5cbiAgICAgICAgcmV0dXJuIGNscztcbiAgICAgIH07XG4gICAgfSxcblxuICAgIC8qKiBTdGFydCBzZWNvbmQgcGhhc2Ugb2YgYm9vdHN0cmFwIHByb2Nlc3MuICovXG4gICAgZnVuY3Rpb24gcGhhc2UyKCkge1xuICAgICAgLy8gVXBncmFkZSB0byBmaW5hbCBDTEFTUygpIGRlZmluaXRpb24uXG4gICAgICAvKiBDcmVhdGVzIGEgRm9hbSBjbGFzcyBmcm9tIGEgcGxhaW4tb2xkLW9iamVjdCBkZWZpbml0aW9uOlxuICAgICAgICAgICgxKSBEZXRlcm1pbmUgdGhlIGNsYXNzIG9mIG1vZGVsIGZvciB0aGUgbmV3IGNsYXNzJ3MgbW9kZWw7XG4gICAgICAgICAgKDIpIENvbnN0cnVjdCBhbmQgdmFsaWRhdGUgdGhlIG5ldyBjbGFzcydzIG1vZGVsO1xuICAgICAgICAgICgzKSBDb25zdHJ1Y3QgYW5kIHZhbGlkYXRlIHRoZSBuZXcgY2xhc3MuXG4gICAgICAgICAgQG1ldGhvZCBDTEFTU1xuICAgICAgICAgIEBtZW1iZXJvZiBtb2R1bGU6Zm9hbSAqL1xuICAgICAgZm9hbS5DTEFTUyA9IGZ1bmN0aW9uKG0sIHNraXBSZWdpc3RyYXRpb24pIHtcbiAgICAgICAgdmFyIGNscyAgID0gbS5jbGFzcyA/IGZvYW0ubG9va3VwKG0uY2xhc3MpIDogZm9hbS5jb3JlLk1vZGVsO1xuICAgICAgICB2YXIgbW9kZWwgPSBjbHMuY3JlYXRlKG0pO1xuICAgICAgICBtb2RlbC52YWxpZGF0ZSgpO1xuICAgICAgICAvLyBjbHMgd2FzOiBjbGFzcy1mb3ItbW9kZWwtY29uc3RydWN0aW9uO1xuICAgICAgICAvLyBjbHMgaXM6IGNsYXNzLWNvbnN0cnVjdGVkLWZyb20tbW9kZWwuXG4gICAgICAgIGNscyA9IG1vZGVsLmJ1aWxkQ2xhc3MoKTtcbiAgICAgICAgY2xzLnZhbGlkYXRlKCk7XG5cbiAgICAgICAgaWYgKCBza2lwUmVnaXN0cmF0aW9uICkgcmV0dXJuIGNscztcblxuICAgICAgICBpZiAoICEgbS5yZWZpbmVzICkge1xuICAgICAgICAgIC8vIFJlZ2lzdGVyIGNsYXNzIGluIGdsb2JhbCBjb250ZXh0LlxuICAgICAgICAgIGZvYW0ucmVnaXN0ZXIoY2xzKTtcblxuICAgICAgICAgIC8vIFJlZ2lzdGVyIHRoZSBjbGFzcyBpbiB0aGUgZ2xvYmFsIHBhY2thZ2UgcGF0aC5cbiAgICAgICAgICBmb2FtLnBhY2thZ2UucmVnaXN0ZXJDbGFzcyhjbHMpO1xuICAgICAgICB9IGVsc2UgaWYgKCBtLm5hbWUgKSB7XG4gICAgICAgICAgLy8gUmVnaXN0ZXIgcmVmaW5lbWVudCBpZCBpbiBnbG9iYWwgY29udGV4dC5cbiAgICAgICAgICBmb2FtLnJlZ2lzdGVyKGNscywgKCBtLnBhY2thZ2UgfHwgJ2ZvYW0uY29yZScgKSArICcuJyArIG0ubmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVE9ETyhtYXJrZGl0dG1lcik6IElkZW50aWZ5IGFuZCBuYW1lIGFub255bW91cyByZWZpbmVtZW50cyB3aXRoOlxuICAgICAgICAvLyBlbHNlIHtcbiAgICAgICAgLy8gICBjb25zb2xlLndhcm4oJ1JlZmluZW1lbnQgd2l0aG91dCB1bmlxdWUgaWQnLCBjbHMpO1xuICAgICAgICAvLyAgIGRlYnVnZ2VyO1xuICAgICAgICAvLyB9XG5cbiAgICAgICAgcmV0dXJuIGNscztcbiAgICAgIH07XG5cbiAgICAgIC8vIFVwZ3JhZGUgZXhpc3RpbmcgY2xhc3NlcyB0byByZWFsIGNsYXNzZXMuXG4gICAgICBmb3IgKCB2YXIga2V5IGluIGZvYW0uY29yZSApIHtcbiAgICAgICAgdmFyIG0gPSBmb2FtLmxvb2t1cChrZXkpLm1vZGVsXztcblxuICAgICAgICAvLyBjbGFzc01vZGVsLmJ1aWxkQ2xhc3MoKSBleHBlY3RzICdyZWZpbmVzJyBpZiB3ZSBhcmUgdXBncmFkaW5nIGFuXG4gICAgICAgIC8vIGV4aXN0aW5nIGNsYXNzLlxuICAgICAgICBtLnJlZmluZXMgPSBtLmlkO1xuXG4gICAgICAgIGZvYW0uQ0xBU1MobSwgdHJ1ZSk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIGZ1bmN0aW9uIHBoYXNlMygpIHtcbiAgICAgIC8vIFN1YnN0aXR1dGUgZm9hbS5jb3JlLmluc3RhbGxNb2RlbCgpIHdpdGggc2ltcGxlciBheGlvbS1vbmx5IHZlcnNpb24uXG4gICAgICBmb2FtLmNvcmUuRk9iamVjdC5pbnN0YWxsTW9kZWwgPSBmdW5jdGlvbiBpbnN0YWxsTW9kZWwobSkge1xuICAgICAgICBpZiAoIG0uc291cmNlICkgbS5heGlvbXNfLmZvckVhY2goZnVuY3Rpb24oYSkgeyBhLnNvdXJjZSA9IG0uc291cmNlOyB9KTtcbiAgICAgICAgdGhpcy5pbnN0YWxsQXhpb21zKG0uYXhpb21zXyk7XG4gICAgICB9O1xuICAgIH0sXG5cbiAgICAvKiogRmluaXNoIHRoZSBib290c3RyYXAgcHJvY2VzcywgZGVsZXRpbmcgZm9hbS5ib290IHdoZW4gZG9uZS4gKi9cbiAgICBmdW5jdGlvbiBlbmQoKSB7XG4gICAgICB2YXIgTW9kZWwgPSBmb2FtLmNvcmUuTW9kZWw7XG5cbiAgICAgIC8vIFVwZGF0ZSBwc2Vkby1Nb2RlbHMgdG8gcmVhbCBNb2RlbHNcbiAgICAgIGZvciAoIHZhciBrZXkgaW4gZm9hbS5jb3JlICkge1xuICAgICAgICB2YXIgYyA9IGZvYW0uY29yZVtrZXldO1xuICAgICAgICBjLnByb3RvdHlwZS5tb2RlbF8gPSBjLm1vZGVsXyA9IE1vZGVsLmNyZWF0ZShjLm1vZGVsXyk7XG4gICAgICB9XG5cbiAgICAgIGRlbGV0ZSBmb2FtLmJvb3Q7XG5cbiAgICAgIGNvbnNvbGUubG9nKCdjb3JlIGJvb3QgdGltZTogJywgRGF0ZS5ub3coKSAtIHRoaXMuc3RhcnRUaW1lKTtcbiAgICB9XG4gIF1cbn0pO1xuXG5cbmZvYW0uYm9vdC5zdGFydCgpO1xuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTYgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuLypcbiAgRk9iamVjdCBpcyB0aGUgcm9vdCBvZiBGT0FNJ3MgY2xhc3MgaGllcmFyY2h5LlxuXG4gIFdlIGRlZmluZSBGT2JqZWN0IHR3aWNlLCBmaXJzdCBhcyBhIExJQiB0byBpbnN0YWxsIGFsbCBvZlxuICB0aGUgc3RhdGljL2NsYXNzIG1ldGhvZHMgaW4gdGhlIHRvcC1sZXZlbCBGT2JqZWN0IGNsYXNzLFxuICB0aGVuIHdpdGggYSBDTEFTUyBiZWxvdyB0byBkZWZpbmUgbWV0aG9kcyBvbiB0aGUgRk9iamVjdFxuICBwcm90b3R5cGUuXG5cbiAgRm9yIGRldGFpbHMgb24gaG93IEZPYmplY3QgZml0cyBpbiB0byB0aGUgRk9BTSBjbGFzcyBzeXN0ZW0sXG4gIHNlZSB0aGUgZG9jdW1lbnRhdGlvbiBpbiB0aGUgdG9wIG9mIEJvb3QuanNcbiAqL1xuZm9hbS5MSUIoe1xuICBuYW1lOiAnZm9hbS5jb3JlLkZPYmplY3QnLFxuXG4gIGNvbnN0YW50czoge1xuICAgIC8vIEVhY2ggY2xhc3MgaGFzIGEgcHJvdG90eXBlIG9iamVjdCB3aGljaCBpcyB0aGUgcHJvdG90eXBlIG9mIGFsbFxuICAgIC8vIGluc3RhbmNlcyBvZiB0aGUgY2xhc3MuIEEgY2xhc3NlcyBwcm90b3R5cGUgZXh0ZW5kcyBpdHMgcGFyZW50XG4gICAgLy8gY2xhc3NlcyBwcm90b3R5cGUuXG4gICAgcHJvdG90eXBlOiB7fSxcblxuICAgIC8vIEVhY2ggY2xhc3MgaGFzIGEgbWFwIG9mIEF4aW9tcyBhZGRlZCB0byB0aGUgY2xhc3MuXG4gICAgLy8gTWFwIGtleXMgYXJlIHRoZSBuYW1lIG9mIHRoZSBheGlvbS5cbiAgICAvLyBUaGUgY2xhc3NlcyBheGlvbU1hcF8ncyBleHRlbmRzIGl0cyBwYXJlbnQncyBheGlvbU1hcF8uXG4gICAgYXhpb21NYXBfOiB7fSxcblxuICAgIC8vIEVhY2ggY2xhc3MgaGFzIGEgbWFwIG9mIFwicHJpdmF0ZVwiIHZhcmlhYmxlcyBmb3IgdXNlIGJ5XG4gICAgLy8gYXhpb21zLiBTdG9yaW5nIGludGVybmFsIGRhdGEgaW4gcHJpdmF0ZV8gaW5zdGVhZCBvZiBvbiB0aGVcbiAgICAvLyBjbGFzcyBkaXJlY3RseSBhdm9pZHMgbmFtZSBjb25mbGljdHMgd2l0aCBwdWJsaWMgZmVhdHVyZXMgb2ZcbiAgICAvLyB0aGUgY2xhc3MuXG4gICAgcHJpdmF0ZV86ICB7IGF4aW9tQ2FjaGU6IHt9IH1cbiAgfSxcblxuICBtZXRob2RzOiBbXG4gICAgZnVuY3Rpb24gY3JlYXRlKGFyZ3MsIG9wdF9wYXJlbnQpIHtcbiAgICAgIC8qKlxuICAgICAgICogQ3JlYXRlIGEgbmV3IGluc3RhbmNlIG9mIHRoaXMgY2xhc3MuXG4gICAgICAgKiBDb25maWd1cmVkIGZyb20gdmFsdWVzIHRha2VuIGZyb20gJ2FyZ3MnLCBpZiBzdXBwbGlmZWQuXG4gICAgICAgKi9cblxuICAgICAgdmFyIG9iaiA9IE9iamVjdC5jcmVhdGUodGhpcy5wcm90b3R5cGUpO1xuXG4gICAgICAvLyBJbmNyZW1lbnQgbnVtYmVyIG9mIG9iamVjdHMgY3JlYXRlZCBvZiB0aGlzIGNsYXNzLlxuICAgICAgdGhpcy5jb3VudF8rKztcblxuICAgICAgLy8gUHJvcGVydGllcyBoYXZlIHRoZWlyIHZhbHVlcyBzdG9yZWQgaW4gaW5zdGFuY2VfIGluc3RlYWRcbiAgICAgIC8vIG9mIG9uIHRoZSBvYmplY3QgZGlyZWN0bHkuIFRoaXMgbGV0cyB1cyBkZWZpbmVQcm9wZXJ0eSBvblxuICAgICAgLy8gdGhlIG9iamVjdCBpdHNlbGYgc28gdGhhdCB3ZSBjYW4gYWRkIGV4dHJhIGJlaGF2aW91clxuICAgICAgLy8gdG8gcHJvcGVydGllcyAodGhpbmdzIGxpa2UgcHJlU2V0LCBwb3N0U2V0LCBmaXJpbmcgcHJvcGVydHktXG4gICAgICAvLyBjaGFuZ2UgZXZlbnRzLCBldGMuKS5cbiAgICAgIG9iai5pbnN0YW5jZV8gPSB7fTtcblxuICAgICAgLy8gaW5pdEFyZ3MoKSBpcyB0aGUgc3RhbmRhcmQgYXJndW1lbnQgZXh0cmFjdGlvbiBtZXRob2QuXG4gICAgICBvYmouaW5pdEFyZ3MoYXJncywgb3B0X3BhcmVudCk7XG5cbiAgICAgIHZhciBheGlvbXMgPSB0aGlzLmdldEluaXRBZ2VudHMoKTtcbiAgICAgIGZvciAoIHZhciBpID0gMCA7IGkgPCBheGlvbXMubGVuZ3RoIDsgaSsrICkge1xuICAgICAgICBheGlvbXNbaV0uaW5pdE9iamVjdChvYmopO1xuICAgICAgfVxuXG4gICAgICAvLyBpbml0KCkgaXMgY2FsbGVkIHdoZW4gb2JqZWN0IGlzIGNyZWF0ZWQuXG4gICAgICAvLyBUaGlzIGlzIHdoZXJlIGNsYXNzLXNwZWNpZmljIGluaXRpYWxpemF0aW9uIGNvZGUgc2hvdWxkXG4gICAgICAvLyBiZSBwdXQgKG5vdCBpbiBpbml0QXJncykuXG4gICAgICBvYmouaW5pdCgpO1xuXG4gICAgICByZXR1cm4gb2JqO1xuICAgIH0sXG5cbiAgICBmdW5jdGlvbiBjcmVhdGVTdWJDbGFzc18oKSB7XG4gICAgICAvKipcbiAgICAgICAqIFVzZWQgdG8gY3JlYXRlIGEgc3ViLWNsYXNzIG9mIHRoaXMgY2xhc3MuICBTZXRzIHVwIHRoZSBhcHByb3ByaWF0ZVxuICAgICAgICogcHJvdG90eXBlIGNoYWlucyBmb3IgdGhlIGNsYXNzLCBjbGFzcy5wcm90b3R5cGUgYW5kIGF4aW9tTWFwX1xuICAgICAgICpcbiAgICAgICAqIFRoZSB2ZXJ5IGZpcnN0IFwic3ViQ2xhc3NcIiB0aGF0IHdlIGNyZWF0ZSB3aWxsIGJlIEZPYmplY3QgaXRzZWxmLCB3aGVuXG4gICAgICAgKiB3ZSBkZWZpbmUgdGhlIEZPYmplY3QgY2xhc3MgcmF0aGVyIHRoYW4gdGhlIEZPYmplY3QgbGliIHRoYXQgd2UgYXJlXG4gICAgICAgKiBjdXJyZW50bHkgZGVmaW5pbmcuXG4gICAgICAgKlxuICAgICAgICogU28gaW5zdGVhZCBvZiBhY3R1YWxseSBjcmVhdGluZyBhIHN1YkNsYXNzLCB3ZSB3aWxsIGp1c3QgcmV0dXJuIFwidGhpc1wiXG4gICAgICAgKiBhbmQgcmVwbGFjZSBjcmVhdGVTdWJDbGFzcygpIG9uIEZPYmplY3QgdG8gYWN0dWFsbHkgY3JlYXRlIHJlYWxcbiAgICAgICAqIHN1Yi1jbGFzc2VzIGZvciBhbGwgc3Vic2VxdWVudCB1c2VzIG9mIEZPYmplY3QuY3JlYXRlU3ViQ2xhc3MoKVxuICAgICAgICovXG4gICAgICBmb2FtLmNvcmUuRk9iamVjdC5jcmVhdGVTdWJDbGFzc18gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGNscyA9IE9iamVjdC5jcmVhdGUodGhpcyk7XG5cbiAgICAgICAgY2xzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUodGhpcy5wcm90b3R5cGUpO1xuICAgICAgICBjbHMuYXhpb21NYXBfID0gT2JqZWN0LmNyZWF0ZSh0aGlzLmF4aW9tTWFwXyk7XG4gICAgICAgIGNscy5wcml2YXRlXyAgPSB7IGF4aW9tQ2FjaGU6IHt9IH07XG5cbiAgICAgICAgcmV0dXJuIGNscztcbiAgICAgIH07XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBmdW5jdGlvbiBnZXRTdXBlckNsYXNzKCkge1xuICAgICAgcmV0dXJuIHRoaXMubW9kZWxfLl9fY29udGV4dF9fLmxvb2t1cCh0aGlzLm1vZGVsXy5leHRlbmRzKTtcbiAgICB9LFxuXG4gICAgZnVuY3Rpb24gaW5zdGFsbEF4aW9tcyhheHMpIHtcbiAgICAgIGlmICggISBheHMgfHwgISBheHMubGVuZ3RoICkgcmV0dXJuO1xuXG4gICAgICAvKipcbiAgICAgICAqIEluc3RhbGwgQXhpb21zIGludG8gdGhlIGNsYXNzIGFuZCBwcm90b3R5cGUuXG4gICAgICAgKiBJbnZhbGlkYXRlIHRoZSBheGlvbS1jYWNoZSwgdXNlZCBieSBnZXRBeGlvbXNCeU5hbWUoKS5cbiAgICAgICAqXG4gICAgICAgKiBGVVRVUkU6IFdhaXQgZm9yIGZpcnN0IG9iamVjdCB0byBiZSBjcmVhdGVkIGJlZm9yZSBjcmVhdGluZyBwcm90b3R5cGUuXG4gICAgICAgKiBDdXJyZW50bHkgaXQgaW5zdGFsbHMgYXhpb21zIGludG8gdGhlIHByb3RveXBlIGltbWVkaWF0ZWx5LCBidXQgaW4gc2hvdWxkXG4gICAgICAgKiB3YWl0IHVudGlsIHRoZSBmaXJzdCBvYmplY3QgaXMgY3JlYXRlZC4gVGhpcyB3aWxsIHByb3ZpZGVcbiAgICAgICAqIGJldHRlciBzdGFydHVwIHBlcmZvcm1hbmNlLlxuICAgICAgICovXG4gICAgICB0aGlzLnByaXZhdGVfLmF4aW9tQ2FjaGUgPSB7fTtcblxuICAgICAgLy8gV2UgaW5zdGFsbCBpbiB0d28gcGFzc2VzIHRvIGF2b2lkIG9yZGVyaW5nIGlzc3VlcyBmcm9tIEF4aW9tcyB3aGljaFxuICAgICAgLy8gbmVlZCB0byBhY2Nlc3Mgb3RoZXIgYXhpb21zLCBsaWtlIGlkczogYW5kIGV4cG9ydHM6LlxuXG4gICAgICB2YXIgZXhpc3RpbmcgPSBuZXcgQXJyYXkoYXhzLmxlbmd0aCk7XG5cbiAgICAgIGZvciAoIHZhciBpID0gMCA7IGkgPCBheHMubGVuZ3RoIDsgaSsrICkge1xuICAgICAgLy8gQ29udmVydCBKU09OIGF4aW9tcyB0byByZWFsIGluc3RhbmNlcyBhcyBsYXRlIGFzIHBvc3NpYmxlXG4gICAgICAgIGlmICggZm9hbS5TdHJpbmcuaXNJbnN0YW5jZShheHNbaV0uY2xhc3MpICkge1xuICAgICAgICAgIHZhciBheHNDbHMgPSBmb2FtLmxvb2t1cChheHNbaV0uY2xhc3MsIHRydWUpO1xuICAgICAgICAgIGlmICggYXhzQ2xzICkgYXhzW2ldID0gYXhzQ2xzLmNyZWF0ZShheHNbaV0pO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGEgPSBheHNbaV07XG5cbiAgICAgICAgLy8gU3RvcmUgdGhlIGRlc3RpbmF0aW9uIGNsYXNzIGluIHRoZSBBeGlvbS4gVXNlZCBieSBkZXNjcmliZSgpLlxuICAgICAgICAvLyBTdG9yZSBzb3VyY2UgY2xhc3Mgb24gYSBjbG9uZSBvZiAnYScgc28gdGhhdCB0aGUgQXhpb20gY2FuIGJlXG4gICAgICAgIC8vIHJldXNlZCB3aXRob3V0IGNvcnJ1cHRpbmcgdGhlIHNvdXJjZUNsc18uXG4gICAgICAgIGEuc291cmNlQ2xzXyA9IHRoaXM7XG5cbiAgICAgICAgaWYgKCBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodGhpcy5heGlvbU1hcF8sIGEubmFtZSkgKSB7XG4gICAgICAgICAgZXhpc3RpbmdbaV0gPSB0aGlzLmF4aW9tTWFwX1thLm5hbWVdO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5heGlvbU1hcF9bYS5uYW1lXSA9IGE7XG4gICAgICB9XG5cbiAgICAgIGZvciAoIHZhciBpID0gMCA7IGkgPCBheHMubGVuZ3RoIDsgaSsrICkge1xuICAgICAgICB2YXIgYSA9IGF4c1tpXTtcblxuICAgICAgICB2YXIgc3VwZXJBeGlvbSA9IHRoaXMuZ2V0U3VwZXJBeGlvbUJ5TmFtZShhLm5hbWUpO1xuXG4gICAgICAgIGEuaW5zdGFsbEluQ2xhc3MgJiYgYS5pbnN0YWxsSW5DbGFzcyh0aGlzLCAgICAgICAgICAgc3VwZXJBeGlvbSwgZXhpc3RpbmdbaV0pO1xuICAgICAgICBhLmluc3RhbGxJblByb3RvICYmIGEuaW5zdGFsbEluUHJvdG8odGhpcy5wcm90b3R5cGUsIHN1cGVyQXhpb20sIGV4aXN0aW5nW2ldKTtcblxuICAgICAgICBpZiAoIGEubmFtZSApIHtcbiAgICAgICAgICB0aGlzLnB1YnN1Yl8gJiYgdGhpcy5wdWJzdWJfLnB1YignaW5zdGFsbEF4aW9tJywgYS5uYW1lLCBhKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBmdW5jdGlvbiBpbnN0YWxsQXhpb20oYSkge1xuICAgICAgdGhpcy5pbnN0YWxsQXhpb21zKFthXSk7XG4gICAgfSxcblxuICAgIGZ1bmN0aW9uIGluc3RhbGxDb25zdGFudChrZXksIHZhbHVlKSB7XG4gICAgICB2YXIgY05hbWUgPSBmb2FtLlN0cmluZy5jb25zdGFudGl6ZShrZXkpO1xuICAgICAgdmFyIHByZXYgID0gdGhpc1tjTmFtZV07XG5cbiAgICAgIC8vIERldGVjdCBjb25zdGFudCBuYW1lIGNvbGxpc2lvbnNcbiAgICAgIGlmICggcHJldiAmJiBwcmV2Lm5hbWUgIT09IGtleSApIHtcbiAgICAgICAgdGhyb3cgJ0NsYXNzIGNvbnN0YW50IGNvbmZsaWN0OiAnICtcbiAgICAgICAgICB0aGlzLmlkICsgJy4nICsgY05hbWUgKyAnIGZyb206ICcgKyBrZXkgKyAnIGFuZCAnICsgcHJldi5uYW1lO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnByb3RvdHlwZVtjTmFtZV0gPSB0aGlzW2NOYW1lXSA9IHZhbHVlO1xuICAgIH0sXG5cbiAgICBmdW5jdGlvbiBpc0luc3RhbmNlKG8pIHtcbiAgICAgIC8qKlxuICAgICAgICogRGV0ZXJtaW5lIGlmIGFuIG9iamVjdCBpcyBhbiBpbnN0YW5jZSBvZiB0aGlzIGNsYXNzXG4gICAgICAgKiBvciBvbmUgb2YgaXRzIHN1Yi1jbGFzc2VzLlxuICAgICAgICovXG5cbiAgICAgIHJldHVybiAhISAoIG8gJiYgby5jbHNfICYmIHRoaXMuaXNTdWJDbGFzcyhvLmNsc18pICk7XG4gICAgfSxcblxuICAgIGZ1bmN0aW9uIGlzU3ViQ2xhc3MoYykge1xuICAgICAgLyoqXG4gICAgICAgKiBEZXRlcm1pbmUgaWYgYSBjbGFzcyBpcyBlaXRoZXIgdGhpcyBjbGFzcywgYSBzdWItY2xhc3MsIG9yXG4gICAgICAgKiBpZiBpdCBpbXBsZW1lbnRzIHRoaXMgY2xhc3MgKGRpcmVjdGx5IG9yIGluZGlyZWN0bHkpLlxuICAgICAgICovXG5cbiAgICAgIGlmICggISBjIHx8ICEgYy5pZCApIHJldHVybiBmYWxzZTtcblxuICAgICAgLy8gT3B0aW1pemUgbW9zdCBjb21tb24gY2FzZSBhbmQgYXZvaWQgY3JlYXRpbmcgY2FjaGVcbiAgICAgIGlmICggdGhpcyA9PT0gZm9hbS5jb3JlLkZPYmplY3QgKSByZXR1cm4gdHJ1ZTtcblxuICAgICAgdmFyIGNhY2hlID0gdGhpcy5wcml2YXRlXy5pc1N1YkNsYXNzQ2FjaGUgfHxcbiAgICAgICAgKCB0aGlzLnByaXZhdGVfLmlzU3ViQ2xhc3NDYWNoZSA9IHt9ICk7XG5cbiAgICAgIGlmICggY2FjaGVbYy5pZF0gPT09IHVuZGVmaW5lZCApIHtcbiAgICAgICAgY2FjaGVbYy5pZF0gPSAoIGMgPT09IHRoaXMucHJvdG90eXBlLmNsc18gKSB8fFxuICAgICAgICAgICggYy5nZXRBeGlvbUJ5TmFtZSAmJiAhISBjLmdldEF4aW9tQnlOYW1lKCdpbXBsZW1lbnRzXycgKyB0aGlzLmlkKSApIHx8XG4gICAgICAgICAgdGhpcy5pc1N1YkNsYXNzKGMuX19wcm90b19fKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGNhY2hlW2MuaWRdO1xuICAgIH0sXG5cbiAgICBmdW5jdGlvbiBnZXRBeGlvbUJ5TmFtZShuYW1lKSB7XG4gICAgICAvKipcbiAgICAgICAqIEZpbmQgYW4gYXhpb20gYnkgdGhlIHNwZWNpZmllZCBuYW1lIGZyb20gZWl0aGVyIHRoaXMgY2xhc3Mgb3IgYW5cbiAgICAgICAqIGFuY2VzdG9yLlxuICAgICAgICovXG4gICAgICByZXR1cm4gdGhpcy5heGlvbU1hcF9bbmFtZV07XG4gICAgfSxcblxuICAgIGZ1bmN0aW9uIGdldEF4aW9tc0J5Q2xhc3MoY2xzKSB7XG4gICAgICAvKipcbiAgICAgICAqIFJldHVybnMgYWxsIGF4aW9tcyBkZWZpbmVkIG9uIHRoaXMgY2xhc3Mgb3IgaXRzIHBhcmVudCBjbGFzc2VzXG4gICAgICAgKiB0aGF0IGFyZSBpbnN0YW5jZXMgb2YgdGhlIHNwZWNpZmllZCBjbGFzcy5cbiAgICAgICAqL1xuICAgICAgLy8gRlVUVVJFOiBBZGQgZWZmaWNpZW50IHN1cHBvcnQgZm9yOlxuICAgICAgLy8gICAgLndoZXJlKCkgLm9yZGVyQnkoKSAuZ3JvdXBCeSgpXG4gICAgICB2YXIgYXMgPSB0aGlzLnByaXZhdGVfLmF4aW9tQ2FjaGVbY2xzLmlkXTtcbiAgICAgIGlmICggISBhcyApIHtcbiAgICAgICAgYXMgPSBbXTtcbiAgICAgICAgZm9yICggdmFyIGtleSBpbiB0aGlzLmF4aW9tTWFwXyApIHtcbiAgICAgICAgICB2YXIgYSA9IHRoaXMuYXhpb21NYXBfW2tleV07XG4gICAgICAgICAgaWYgKCBjbHMuaXNJbnN0YW5jZShhKSApIGFzLnB1c2goYSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wcml2YXRlXy5heGlvbUNhY2hlW2Nscy5pZF0gPSBhcztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGFzO1xuICAgIH0sXG5cbiAgICBmdW5jdGlvbiBnZXRTdXBlckF4aW9tQnlOYW1lKG5hbWUpIHtcbiAgICAgIC8qKlxuICAgICAgICogRmluZCBhbiBheGlvbSBieSB0aGUgc3BlY2lmaWVkIG5hbWUgZnJvbSBhbiBhbmNlc3Rvci5cbiAgICAgICAqL1xuICAgICAgcmV0dXJuIHRoaXMuYXhpb21NYXBfLl9fcHJvdG9fX1tuYW1lXTtcbiAgICB9LFxuXG4gICAgZnVuY3Rpb24gaGFzT3duQXhpb20obmFtZSkge1xuICAgICAgLyoqXG4gICAgICAgKiBSZXR1cm4gdHJ1ZSBpZiBhbiBheGlvbSBuYW1lZCBcIm5hbWVcIiBpcyBkZWZpbmVkIG9uIHRoaXMgY2xhc3NcbiAgICAgICAqIGRpcmVjdGx5LCByZWdhcmRsZXNzIG9mIHdoYXQgcGFyZW50IGNsYXNzZXMgZGVmaW5lLlxuICAgICAgICovXG4gICAgICByZXR1cm4gT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwodGhpcy5heGlvbU1hcF8sIG5hbWUpO1xuICAgIH0sXG5cbiAgICBmdW5jdGlvbiBnZXRPd25BeGlvbXNCeUNsYXNzKGNscykge1xuICAgICAgLyoqXG4gICAgICAgKiBSZXR1cm5zIGFsbCBheGlvbXMgZGVmaW5lZCBvbiB0aGlzIGNsYXNzIHRoYXQgYXJlIGluc3RhbmNlcyBvZiB0aGVcbiAgICAgICAqIHNwZWNpZmllZCBjbGFzcy5cbiAgICAgICAqL1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0QXhpb21zQnlDbGFzcyhjbHMpLmZpbHRlcihmdW5jdGlvbihhKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmhhc093bkF4aW9tKGEubmFtZSk7XG4gICAgICB9LmJpbmQodGhpcykpO1xuICAgIH0sXG5cbiAgICBmdW5jdGlvbiBnZXRPd25BeGlvbXMoKSB7XG4gICAgICAvKiogUmV0dXJucyBhbGwgYXhpb21zIGRlZmluZWQgb24gdGhpcyBjbGFzcy4gKi9cbiAgICAgIHJldHVybiB0aGlzLmdldEF4aW9tcygpLmZpbHRlcihmdW5jdGlvbihhKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmhhc093bkF4aW9tKGEubmFtZSk7XG4gICAgICB9LmJpbmQodGhpcykpO1xuICAgIH0sXG5cbiAgICBmdW5jdGlvbiBnZXRBeGlvbXMoKSB7XG4gICAgICAvKiogUmV0dXJucyBhbGwgYXhpb21zIGRlZmluZWQgb24gdGhpcyBjbGFzcyBvciBpdHMgcGFyZW50IGNsYXNzZXMuICovXG5cbiAgICAgIC8vIFRoZSBmdWxsIGF4aW9tIGxpc3QgaXMgc3RvcmVkIGluIHRoZSByZWd1bGFyIGNhY2hlIHdpdGggJycgYXMgYSBrZXkuXG4gICAgICB2YXIgYXMgPSB0aGlzLnByaXZhdGVfLmF4aW9tQ2FjaGVbJyddO1xuICAgICAgaWYgKCAhIGFzICkge1xuICAgICAgICBhcyA9IFtdO1xuICAgICAgICBmb3IgKCB2YXIga2V5IGluIHRoaXMuYXhpb21NYXBfICkgYXMucHVzaCh0aGlzLmF4aW9tTWFwX1trZXldKTtcbiAgICAgICAgdGhpcy5wcml2YXRlXy5heGlvbUNhY2hlWycnXSA9IGFzO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGFzO1xuICAgIH0sXG5cbiAgICBmdW5jdGlvbiBnZXRJbml0QWdlbnRzKCkge1xuICAgICAgaWYgKCAhIHRoaXMucHJpdmF0ZV8uaW5pdEFnZW50c0NhY2hlICkge1xuICAgICAgICB0aGlzLnByaXZhdGVfLmluaXRBZ2VudHNDYWNoZSA9IFtdO1xuICAgICAgICBmb3IgKCB2YXIga2V5IGluIHRoaXMuYXhpb21NYXBfICkge1xuICAgICAgICAgIHZhciBheGlvbSA9IHRoaXMuYXhpb21NYXBfW2tleV07XG4gICAgICAgICAgaWYgKGF4aW9tLmluaXRPYmplY3QpIHRoaXMucHJpdmF0ZV8uaW5pdEFnZW50c0NhY2hlLnB1c2goYXhpb20pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5wcml2YXRlXy5pbml0QWdlbnRzQ2FjaGU7XG4gICAgfSxcblxuICAgIC8vIE5PUCwgaXMgcmVwbGFjZWQgaWYgZGVidWcuanMgaXMgbG9hZGVkXG4gICAgZnVuY3Rpb24gdmFsaWRhdGUoKSB7IH0sXG5cbiAgICBmdW5jdGlvbiB0b1N0cmluZygpIHsgcmV0dXJuIHRoaXMubmFtZSArICdDbGFzcyc7IH0sXG5cbiAgICBmdW5jdGlvbiBpbnN0YWxsTW9kZWwobSkge1xuICAgICAgLyoqXG4gICAgICAgKiBUZW1wb3JhcnkgQm9vdHN0cmFwIEltcGxlbWVudGF0aW9uXG4gICAgICAgKlxuICAgICAgICogVGhpcyBpcyBhIHRlbXBvcmFyeSB2ZXJzaW9uIG9mIGluc3RhbGxNb2RlbC5cbiAgICAgICAqIFdoZW4gdGhlIGJvb3RzdHJhcCBpcyBmaW5pc2hlZCwgaXQgd2lsbCBiZSByZXBsYWNlZCBieSBhXG4gICAgICAgKiB2ZXJzaW9uIHRoYXQgb25seSBrbm93cyBob3cgdG8gaW5zdGFsbCBheGlvbXMgaW4gQm9vdC5qcyBwaGFzZTMoKS5cbiAgICAgICAqXG4gICAgICAgKiBJdCBpcyBlYXNpZXIgdG8gc3RhcnQgd2l0aCBoYXJkLWNvZGVkIG1ldGhvZCBhbmQgcHJvcGVydHlcbiAgICAgICAqIHN1cHBvcnQgYmVjYXVzZSBBeGlvbXMgbmVlZCBtZXRob2RzIHRvIGluc3RhbGwgdGhlbXNlbHZlc1xuICAgICAgICogYW5kIFByb3BlcnR5IEF4aW9tcyB0aGVtc2VsdmVzIGhhdmUgcHJvcGVydGllcy5cbiAgICAgICAqXG4gICAgICAgKiBIb3dldmVyLCBvbmNlIHdlJ3ZlIGJvb3RzdHJhcHBlZCBwcm9wZXIgUHJvcGVydHkgYW5kIE1ldGhvZFxuICAgICAgICogQXhpb21zLCB3ZSBjYW4gcmVtb3ZlIHRoaXMgc3VwcG9ydCBhbmQganVzdCBpbnN0YWxsIEF4aW9tcy5cbiAgICAgICAqL1xuXG5cbiAgICAgIC8qXG4gICAgICAgIE1ldGhvZHMgY2FuIGJlIGRlZmluZWQgdXNpbmcgdHdvIGZvcm1hdHMuXG4gICAgICAgIDEuIFNob3J0LWZvcm0gZnVuY3Rpb24gbGl0ZXJhbDpcbiAgICAgICAgICAgICBmdW5jdGlvbiBmb28oKSB7XG4gICAgICAgICAgICAgICBjb25zb2xlLmxvZygnYmFyJyk7XG4gICAgICAgICAgICAgfVxuXG4gICAgICAgIDMuIExvbmctZm9ybSBKU09OOlxuICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgIG5hbWU6ICdmb28nLFxuICAgICAgICAgICAgICAgY29kZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdiYXInKTtcbiAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICB9XG4gICAgICAgICAgIFRoZSBsb25nLWZvcm0gd2lsbCBzdXBwb3J0IG1hbnkgb3B0aW9ucyAobWFueSBvZiB3aGljaCBhcmUgZGVmaW5lZFxuICAgICAgICAgICBpbiBNZXRob2QuanMpLCBidXQgb25seSAnbmFtZScgYW5kICdjb2RlJyBhcmUgbWFuZGF0b3J5LlxuICAgICAgICovXG5cbiAgICAgIGlmICggbS5tZXRob2RzICkge1xuICAgICAgICBmb3IgKCB2YXIgaSA9IDAgOyBpIDwgbS5tZXRob2RzLmxlbmd0aCA7IGkrKyApIHtcbiAgICAgICAgICB2YXIgYSA9IG0ubWV0aG9kc1tpXTtcblxuICAgICAgICAgIGlmICggZm9hbS5GdW5jdGlvbi5pc0luc3RhbmNlKGEpICkge1xuICAgICAgICAgICAgdmFyIG5hbWUgPSBmb2FtLkZ1bmN0aW9uLmdldE5hbWUoYSk7XG4gICAgICAgICAgICBtLm1ldGhvZHNbaV0gPSBhID0geyBuYW1lOiBuYW1lLCBjb2RlOiBhIH07XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICggZm9hbS5jb3JlLk1ldGhvZCApIHtcbiAgICAgICAgICAgIGZvYW0uYXNzZXJ0KGEuY2xzXyAhPT0gZm9hbS5jb3JlLk1ldGhvZCxcbiAgICAgICAgICAgICAgJ01ldGhvZCcsIGEubmFtZSwgJ29uJywgbS5uYW1lLFxuICAgICAgICAgICAgICAnaGFzIGFscmVhZHkgYmVlbiB1cGdyYWRlZCB0byBhIE1ldGhvZCcpO1xuXG4gICAgICAgICAgICBhID0gZm9hbS5jb3JlLk1ldGhvZC5jcmVhdGUoYSk7XG4gICAgICAgICAgICB0aGlzLmluc3RhbGxBeGlvbShhKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5wcm90b3R5cGVbYS5uYW1lXSA9IGEuY29kZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLypcbiAgICAgICAgUHJvcGVydGllcyBjYW4gYmUgZGVmaW5lZCB1c2luZyB0aHJlZSBmb3JtYXRzOlxuICAgICAgICAxLiBTaG9ydC1mb3JtIFN0cmluZzogICdmaXJzdE5hbWUnIG9yICdzZXgnXG5cbiAgICAgICAgMi4gTWVkaXVtLWZvcm0gQXJyYXk6ICBbICdmaXJzdE5hbWUnLCAnSm9obicgXSBvciBbICdzZXgnLCAnTWFsZScgXVxuICAgICAgICAgICBUaGUgZmlyc3QgZWxlbWVudCBvZiB0aGUgYXJyYXkgaXMgdGhlIG5hbWUgYW5kIHRoZSBzZWNvbmQgaXMgdGhlXG4gICAgICAgICAgIGRlZmF1bHQgdmFsdWUuXG5cbiAgICAgICAgMy4gTG9uZy1mb3JtIEpTT046ICAgICB7IGNsYXNzOiAnU3RyaW5nJywgbmFtZTogJ3NleCcsIHZhbHVlOiAnTWFsZScgfVxuICAgICAgICAgICBUaGUgbG9uZy1mb3JtIHdpbGwgc3VwcG9ydCBtYW55IG9wdGlvbnMgKG1hbnkgb2Ygd2hpY2ggYXJlIGRlZmluZWRcbiAgICAgICAgICAgaW4gUHJvcGVydHkuanMpLCBidXQgb25seSAnbmFtZScgaXMgbWFuZGF0b3J5LlxuICAgICAgICovXG4gICAgICBpZiAoIGZvYW0uY29yZS5Qcm9wZXJ0eSAmJiBtLnByb3BlcnRpZXMgKSB7XG4gICAgICAgIGZvciAoIHZhciBpID0gMCA7IGkgPCBtLnByb3BlcnRpZXMubGVuZ3RoIDsgaSsrICkge1xuICAgICAgICAgIHZhciBhID0gbS5wcm9wZXJ0aWVzW2ldO1xuXG4gICAgICAgICAgaWYgKCBBcnJheS5pc0FycmF5KGEpICkge1xuICAgICAgICAgICAgbS5wcm9wZXJ0aWVzW2ldID0gYSA9IHsgbmFtZTogYVswXSwgdmFsdWU6IGFbMV0gfTtcbiAgICAgICAgICB9IGVsc2UgaWYgKCBmb2FtLlN0cmluZy5pc0luc3RhbmNlKGEpICkge1xuICAgICAgICAgICAgbS5wcm9wZXJ0aWVzW2ldID0gYSA9IHsgbmFtZTogYSB9O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciB0eXBlID0gZm9hbS5sb29rdXAoYS5jbGFzcywgdHJ1ZSkgfHwgZm9hbS5jb3JlLlByb3BlcnR5O1xuICAgICAgICAgIGZvYW0uYXNzZXJ0KFxuICAgICAgICAgICAgdHlwZSAhPT0gYS5jbHNfLFxuICAgICAgICAgICAgJ1Byb3BlcnR5JywgYS5uYW1lLCAnb24nLCBtLm5hbWUsXG4gICAgICAgICAgICAnaGFzIGFscmVhZHkgYmVlbiB1cGdyYWRlZCB0byBhIFByb3BlcnR5LicpO1xuXG4gICAgICAgICAgYSA9IHR5cGUuY3JlYXRlKGEpO1xuXG4gICAgICAgICAgdGhpcy5pbnN0YWxsQXhpb20oYSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIF1cbn0pO1xuXG4vKipcbiAqIFRoZSBpbXBsaWNpdCBiYXNlIGNsYXNzIGZvciB0aGUgRk9BTSBjbGFzcyBoaWVyYXJjaHkuIElmIHlvdSBkbyBub3RcbiAqIGV4cGxpY2l0bHkgZXh0ZW5kIGFub3RoZXIgY2xhc3MsIEZPYmplY3QgaXMgdXNlZC5cbiAqL1xuZm9hbS5DTEFTUyh7XG4gIHBhY2thZ2U6ICdmb2FtLmNvcmUnLFxuICBuYW1lOiAnRk9iamVjdCcsXG5cbiAgLy8gRWZmZWN0aXZlbHkgaW1wb3J0cyB0aGUgZm9sbG93aW5nIG1ldGhvZHMsIGJ1dCBpbXBvcnRzOiBpc24ndCBhdmFpbGFibGVcbiAgLy8geWV0LCBzbyB3ZSBhZGQgd2l0aCAnbWV0aG9kczonLlxuICAvL1xuICAvLyBpbXBvcnRzOiBbICdlcnJvcicsICdsb2cnLCAnd2FybicgXSxcblxuICBtZXRob2RzOiBbXG4gICAgZnVuY3Rpb24gaW5pdCgpIHtcbiAgICAgIC8qKlxuICAgICAgICogVGVtcGxhdGUgaW5pdCgpIG1ldGhvZCwgYmFzaWMgRk9iamVjdCB0aGlzIGlzIGEgbm8tb3AsIGJ1dCBjbGFzc2VzXG4gICAgICAgKiBjYW4gb3ZlcnJpZGUgdGhpcyB0byBkbyB0aGVpciBvd24gcGVyLWluc3RhbmNlIGluaXRpYWxpemF0aW9uXG4gICAgICAgKi9cbiAgICB9LFxuXG4gICAgZnVuY3Rpb24gaW5pdEFyZ3MoYXJncykge1xuICAgICAgLyoqXG4gICAgICAgKiBUaGlzIGlzIGEgdGVtcG9yYXJ5IHZlcnNpb24gb2YgaW5pdEFyZ3MuXG4gICAgICAgKiBXaGVuIHRoZSBib290c3RyYXAgaXMgZmluaXNoZWQsIGl0IHdpbGwgYmUgcmVwbGFjZWQgYnkgYSB2ZXJzaW9uXG4gICAgICAgKiB0aGF0IGtub3dzIGFib3V0IGEgY2xhc3NlcyBQcm9wZXJ0aWVzLCBzbyBpdCBjYW4gZG8gYSBiZXR0ZXIgam9iLlxuICAgICAgICovXG5cbiAgICAgIGlmICggISBhcmdzICkgcmV0dXJuO1xuXG4gICAgICBmb3IgKCB2YXIga2V5IGluIGFyZ3MgKSB0aGlzW2tleV0gPSBhcmdzW2tleV07XG4gICAgfSxcblxuICAgIGZ1bmN0aW9uIGhhc093blByb3BlcnR5KG5hbWUpIHtcbiAgICAgIC8qKlxuICAgICAgICogUmV0dXJucyB0cnVlIGlmIHRoaXMgb2JqZWN0IGlzIHN0b3JpbmcgYSB2YWx1ZSBmb3IgYSBwcm9wZXJ0eVxuICAgICAgICogbmFtZWQgYnkgdGhlICduYW1lJyBwYXJhbWV0ZXIuXG4gICAgICAgKi9cblxuICAgICAgcmV0dXJuICEgZm9hbS5VbmRlZmluZWQuaXNJbnN0YW5jZSh0aGlzLmluc3RhbmNlX1tuYW1lXSk7XG4gICAgfSxcblxuICAgIGZ1bmN0aW9uIGhhc0RlZmF1bHRWYWx1ZShuYW1lKSB7XG4gICAgICBpZiAoICEgdGhpcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSApIHJldHVybiB0cnVlO1xuXG4gICAgICB2YXIgYXhpb20gPSB0aGlzLmNsc18uZ2V0QXhpb21CeU5hbWUobmFtZSk7XG4gICAgICByZXR1cm4gYXhpb20uaXNEZWZhdWx0VmFsdWUodGhpc1tuYW1lXSk7XG4gICAgfSxcblxuICAgIGZ1bmN0aW9uIGNsZWFyUHJvcGVydHkobmFtZSkge1xuICAgICAgLyoqXG4gICAgICAgKiBVbmRlZmluZSBhIFByb3BlcnR5J3MgdmFsdWUuXG4gICAgICAgKiBUaGUgdmFsdWUgd2lsbCByZXZlcnQgdG8gZWl0aGVyIHRoZSBQcm9wZXJ0eSdzICd2YWx1ZScgb3JcbiAgICAgICAqICdleHByZXNzaW9uJyB2YWx1ZSwgaWYgdGhleSdyZSBkZWZpbmVkIG9yIHVuZGVmaW5lZCBpZiB0aGV5IGFyZW4ndC5cbiAgICAgICAqIEEgcHJvcGVydHlDaGFuZ2UgZXZlbnQgd2lsbCBiZSBmaXJlZCwgZXZlbiBpZiB0aGUgdmFsdWUgZG9lc24ndCBjaGFuZ2UuXG4gICAgICAgKi9cblxuICAgICAgdmFyIHByb3AgPSB0aGlzLmNsc18uZ2V0QXhpb21CeU5hbWUobmFtZSk7XG4gICAgICBmb2FtLmFzc2VydChwcm9wICYmIGZvYW0uY29yZS5Qcm9wZXJ0eS5pc0luc3RhbmNlKHByb3ApLFxuICAgICAgICAgICAgICAgICAgICAnQXR0ZW1wdGVkIHRvIGNsZWFyIG5vbi1wcm9wZXJ0eScsIG5hbWUpO1xuXG4gICAgICBpZiAoIHRoaXMuaGFzT3duUHJvcGVydHkobmFtZSkgKSB7XG4gICAgICAgIHZhciBvbGRWYWx1ZSA9IHRoaXNbbmFtZV07XG4gICAgICAgIHRoaXMuaW5zdGFuY2VfW25hbWVdID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLmNsZWFyUHJpdmF0ZV8obmFtZSk7XG5cbiAgICAgICAgLy8gQXZvaWQgY3JlYXRpbmcgc2xvdCBhbmQgcHVibGlzaGluZyBldmVudCBpZiBub2JvZHkgaXMgbGlzdGVuaW5nLlxuICAgICAgICBpZiAoIHRoaXMuaGFzTGlzdGVuZXJzKCdwcm9wZXJ0eUNoYW5nZScsIG5hbWUpICkge1xuICAgICAgICAgIHRoaXMucHViKCdwcm9wZXJ0eUNoYW5nZScsIG5hbWUsIHRoaXMuc2xvdChuYW1lKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgZnVuY3Rpb24gc2V0UHJpdmF0ZV8obmFtZSwgdmFsdWUpIHtcbiAgICAgIC8qKlxuICAgICAgICogUHJpdmF0ZSBzdXBwb3J0IGlzIHVzZWQgdG8gc3RvcmUgcGVyLW9iamVjdCB2YWx1ZXMgdGhhdCBhcmUgbm90XG4gICAgICAgKiBpbnN0YW5jZSB2YXJpYWJsZXMuICBUaGluZ3MgbGlrZSBsaXN0ZW5lcnMgYW5kIHRvcGljcy5cbiAgICAgICAqL1xuICAgICAgKCB0aGlzLnByaXZhdGVfIHx8ICggdGhpcy5wcml2YXRlXyA9IHt9ICkgKVtuYW1lXSA9IHZhbHVlO1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH0sXG5cbiAgICBmdW5jdGlvbiBnZXRQcml2YXRlXyhuYW1lKSB7XG4gICAgICByZXR1cm4gdGhpcy5wcml2YXRlXyAmJiB0aGlzLnByaXZhdGVfW25hbWVdO1xuICAgIH0sXG5cbiAgICBmdW5jdGlvbiBoYXNPd25Qcml2YXRlXyhuYW1lKSB7XG4gICAgICByZXR1cm4gdGhpcy5wcml2YXRlXyAmJiAhIGZvYW0uVW5kZWZpbmVkLmlzSW5zdGFuY2UodGhpcy5wcml2YXRlX1tuYW1lXSk7XG4gICAgfSxcblxuICAgIGZ1bmN0aW9uIGNsZWFyUHJpdmF0ZV8obmFtZSkge1xuICAgICAgaWYgKCB0aGlzLnByaXZhdGVfICkgdGhpcy5wcml2YXRlX1tuYW1lXSA9IHVuZGVmaW5lZDtcbiAgICB9LFxuXG4gICAgZnVuY3Rpb24gdmFsaWRhdGUoKSB7XG4gICAgICB2YXIgYXMgPSB0aGlzLmNsc18uZ2V0QXhpb21zKCk7XG4gICAgICBmb3IgKCB2YXIgaSA9IDAgOyBpIDwgYXMubGVuZ3RoIDsgaSsrICkge1xuICAgICAgICB2YXIgYSA9IGFzW2ldO1xuICAgICAgICBhLnZhbGlkYXRlSW5zdGFuY2UgJiYgYS52YWxpZGF0ZUluc3RhbmNlKHRoaXMpO1xuICAgICAgfVxuICAgIH0sXG5cblxuICAgIC8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAgICAgKiBDb25zb2xlXG4gICAgICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuICAgIC8vIEltcG9ydHMgYXJlbid0IGltcGxlbWVudGVkIHlldCwgc28gbWltaWM6XG4gICAgLy8gICBpbXBvcnRzOiBbICdsb29rdXAnLCAnYXNzZXJ0JywgJ2Vycm9yJywgJ2xvZycsICd3YXJuJyBdLFxuXG5cbiAgICAvLyBCb290c3RyYXAgZm9ybSByZXBsYWNlZCBhZnRlciB0aGlzLl9fY29udGV4dF9fIGlzIGFkZGVkLlxuICAgIGZ1bmN0aW9uIGxvb2t1cCgpIHsgcmV0dXJuIGZvYW0ubG9va3VwLmFwcGx5KGZvYW0sIGFyZ3VtZW50cyk7IH0sXG5cbiAgICBmdW5jdGlvbiBlcnJvcigpIHsgdGhpcy5fX2NvbnRleHRfXy5lcnJvci5hcHBseShudWxsLCBhcmd1bWVudHMpOyB9LFxuXG4gICAgZnVuY3Rpb24gbG9nKCkgeyB0aGlzLl9fY29udGV4dF9fLmxvZy5hcHBseShudWxsLCBhcmd1bWVudHMpOyB9LFxuXG4gICAgZnVuY3Rpb24gd2FybigpIHsgdGhpcy5fX2NvbnRleHRfXy53YXJuLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7IH0sXG5cblxuICAgIC8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAgICAgKiBQdWJsaXNoIGFuZCBTdWJzY3JpYmVcbiAgICAgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4gICAgZnVuY3Rpb24gY3JlYXRlTGlzdGVuZXJMaXN0XygpIHtcbiAgICAgIC8qKlxuICAgICAgICogVGhpcyBzdHJ1Y3R1cmUgcmVwcmVzZW50cyB0aGUgaGVhZCBvZiBhIGRvdWJseS1saW5rZWQgbGlzdCBvZlxuICAgICAgICogbGlzdGVuZXJzLiBJdCBjb250YWlucyAnbmV4dCcsIGEgcG9pbnRlciB0byB0aGUgZmlyc3QgbGlzdGVuZXIsXG4gICAgICAgKiBhbmQgJ2NoaWxkcmVuJywgYSBtYXAgb2Ygc3ViLXRvcGljIGNoYWlucy5cbiAgICAgICAqXG4gICAgICAgKiBOb2RlcyBpbiB0aGUgbGlzdCBjb250YWluICduZXh0JyBhbmQgJ3ByZXYnIGxpbmtzLCB3aGljaCBsZXRzXG4gICAgICAgKiByZW1vdmluZyBzdWJzY3JpcHRpb25zIGJlIGRvbmUgcXVpY2tseSBieSBjb25uZWN0aW5nIG5leHQgdG8gcHJldlxuICAgICAgICogYW5kIHByZXYgdG8gbmV4dC5cbiAgICAgICAqXG4gICAgICAgKiBOb3RlIHRoYXQgYm90aCB0aGUgaGVhZCBzdHJ1Y3R1cmUgYW5kIHRoZSBub2RlcyB0aGVtc2VsdmVzIGhhdmUgYVxuICAgICAgICogJ25leHQnIHByb3BlcnR5LiBUaGlzIHNpbXBsaWZpZXMgdGhlIGNvZGUgYmVjYXVzZSB0aGVyZSBpcyBub1xuICAgICAgICogc3BlY2lhbCBjYXNlIGZvciBoYW5kbGluZyB3aGVuIHRoZSBsaXN0IGlzIGVtcHR5LlxuICAgICAgICpcbiAgICAgICAqIExpc3RlbmVyIExpc3QgU3RydWN0dXJlXG4gICAgICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICogbmV4dCAgICAgLT4ge1xuICAgICAgICogICBwcmV2OiA8LSxcbiAgICAgICAqICAgc3ViOiB7c3JjOiA8c291cmNlIG9iamVjdD4sIGRldGFjaDogPGRlc3RydWN0b3IgZnVuY3Rpb24+IH0sXG4gICAgICAgKiAgIGw6IDxsaXN0ZW5lcj4sXG4gICAgICAgKiAgIG5leHQ6IC0+IDxzYW1lIHN0cnVjdHVyZT4sXG4gICAgICAgKiAgIGNoaWxkcmVuIC0+IHtcbiAgICAgICAqICAgICBzdWJUb3BpYzE6IDxzYW1lIHN0cnVjdHVyZT4sXG4gICAgICAgKiAgICAgLi4uXG4gICAgICAgKiAgICAgc3ViVG9waWNuOiA8c2FtZSBzdHJ1Y3R1cmU+XG4gICAgICAgKiAgIH1cbiAgICAgICAqIH1cbiAgICAgICAqXG4gICAgICAgKiBUT0RPOiBNb3ZlIHRoaXMgc3RydWN0dXJlIHRvIGEgZm9hbS5MSUIsIGFuZCBhZGQgYSBiZW5jaG1hcmtcbiAgICAgICAqIHRvIHNob3cgd2h5IHdlIGFyZSB1c2luZyBwbGFpbiBqYXZhc2NyaXB0IG9iamVjdHMgcmF0aGVyIHRoYW5cbiAgICAgICAqIG1vZGVsZWQgb2JqZWN0cyBmb3IgdGhpcyBzdHJ1Y3R1cmUuXG4gICAgKi9cbiAgICAgIHJldHVybiB7IG5leHQ6IG51bGwgfTtcbiAgICB9LFxuXG4gICAgZnVuY3Rpb24gbGlzdGVuZXJzXygpIHtcbiAgICAgIC8qKlxuICAgICAgICogUmV0dXJuIHRoZSB0b3AtbGV2ZWwgbGlzdGVuZXIgbGlzdCwgY3JlYXRpbmcgaWYgbmVjZXNzYXJ5LlxuICAgICAgICovXG4gICAgICByZXR1cm4gdGhpcy5nZXRQcml2YXRlXygnbGlzdGVuZXJzJykgfHxcbiAgICAgICAgdGhpcy5zZXRQcml2YXRlXygnbGlzdGVuZXJzJywgdGhpcy5jcmVhdGVMaXN0ZW5lckxpc3RfKCkpO1xuICAgIH0sXG5cbiAgICBmdW5jdGlvbiBub3RpZnlfKGxpc3RlbmVycywgYSkge1xuICAgICAgLyoqXG4gICAgICAgKiBOb3RpZnkgYWxsIG9mIHRoZSBsaXN0ZW5lcnMgaW4gYSBsaXN0ZW5lciBsaXN0LlxuICAgICAgICogUGFzcyAnYScgYXJndW1lbnRzIHRvIGxpc3RlbmVycy5cbiAgICAgICAqIFJldHVybnMgdGhlIG51bWJlciBvZiBsaXN0ZW5lcnMgbm90aWZpZWQuXG4gICAgICAgKi9cbiAgICAgIHZhciBjb3VudCA9IDA7XG4gICAgICB3aGlsZSAoIGxpc3RlbmVycyApIHtcbiAgICAgICAgdmFyIGwgPSBsaXN0ZW5lcnMubDtcbiAgICAgICAgdmFyIHMgPSBsaXN0ZW5lcnMuc3ViO1xuXG4gICAgICAgIC8vIFVwZGF0ZSAnbGlzdGVuZXJzJyBiZWZvcmUgbm90aWZ5aW5nIGJlY2F1c2UgdGhlIGxpc3RlbmVyXG4gICAgICAgIC8vIG1heSBzZXQgbmV4dCB0byBudWxsLlxuICAgICAgICBsaXN0ZW5lcnMgPSBsaXN0ZW5lcnMubmV4dDtcblxuICAgICAgICAvLyBMaWtlIGwuYXBwbHkobCwgW3NdLmNvbmNhdChBcnJheS5mcm9tKGEpKSksIGJ1dCBmYXN0ZXIuXG4gICAgICAgIC8vIEZVVFVSRTogYWRkIGJlbmNobWFyayB0byBqdXN0aWZ5XG4gICAgICAgIC8vID8/Pzogb3B0aW9uYWwgZXhjZXB0aW9uIHRyYXBwaW5nLCBiZW5jaG1hcmtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBzd2l0Y2ggKCBhLmxlbmd0aCApIHtcbiAgICAgICAgICAgIGNhc2UgMDogbChzKTsgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDE6IGwocywgYVswXSk7IGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAyOiBsKHMsIGFbMF0sIGFbMV0pOyBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMzogbChzLCBhWzBdLCBhWzFdLCBhWzJdKTsgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDQ6IGwocywgYVswXSwgYVsxXSwgYVsyXSwgYVszXSk7IGJyZWFrO1xuICAgICAgICAgICAgY2FzZSA1OiBsKHMsIGFbMF0sIGFbMV0sIGFbMl0sIGFbM10sIGFbNF0pOyBicmVhaztcbiAgICAgICAgICAgIGNhc2UgNjogbChzLCBhWzBdLCBhWzFdLCBhWzJdLCBhWzNdLCBhWzRdLCBhWzVdKTsgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDc6IGwocywgYVswXSwgYVsxXSwgYVsyXSwgYVszXSwgYVs0XSwgYVs1XSwgYVs2XSk7IGJyZWFrO1xuICAgICAgICAgICAgY2FzZSA4OiBsKHMsIGFbMF0sIGFbMV0sIGFbMl0sIGFbM10sIGFbNF0sIGFbNV0sIGFbNl0sIGFbN10pOyBicmVhaztcbiAgICAgICAgICAgIGNhc2UgOTogbChzLCBhWzBdLCBhWzFdLCBhWzJdLCBhWzNdLCBhWzRdLCBhWzVdLCBhWzZdLCBhWzddLCBhWzhdKTsgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OiBsLmFwcGx5KGwsIFtzXS5jb25jYXQoQXJyYXkuZnJvbShhKSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoeCkge31cbiAgICAgICAgY291bnQrKztcbiAgICAgIH1cbiAgICAgIHJldHVybiBjb3VudDtcbiAgICB9LFxuXG4gICAgZnVuY3Rpb24gaGFzTGlzdGVuZXJzKC8qIGFyZ3MgKi8pIHtcbiAgICAgIC8qKlxuICAgICAgICogUmV0dXJuIHRydWUgaWZmIHRoZXJlIGFyZSBsaXN0ZW5lcnMgZm9yIHRoZSBzdXBwbGllZCBtZXNzYWdlLlxuICAgICAgICovXG5cbiAgICAgIHZhciBsaXN0ZW5lcnMgPSB0aGlzLmdldFByaXZhdGVfKCdsaXN0ZW5lcnMnKTtcblxuICAgICAgZm9yICggdmFyIGkgPSAwIDsgbGlzdGVuZXJzIDsgaSsrICkge1xuICAgICAgICBpZiAoIGxpc3RlbmVycy5uZXh0ICAgICAgICApIHJldHVybiB0cnVlO1xuICAgICAgICBpZiAoIGkgPT0gYXJndW1lbnRzLmxlbmd0aCApIHJldHVybiBmYWxzZTtcbiAgICAgICAgbGlzdGVuZXJzID0gbGlzdGVuZXJzLmNoaWxkcmVuICYmIGxpc3RlbmVycy5jaGlsZHJlblthcmd1bWVudHNbaV1dO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSxcblxuICAgIGZ1bmN0aW9uIHB1YihhMSwgYTIsIGEzLCBhNCwgYTUsIGE2LCBhNywgYTgpIHtcbiAgICAgIC8qKlxuICAgICAgICogUHVibGlzaCBhIG1lc3NhZ2UgdG8gYWxsIG1hdGNoaW5nIHN1YigpJ2VkIGxpc3RlbmVycy5cbiAgICAgICAqXG4gICAgICAgKiBBbGwgc3ViKCknZWQgbGlzdGVuZXJzIHdob3NlIHNwZWNpZmllZCBwYXR0ZXJuIG1hdGNoIHRoZVxuICAgICAgICogcHViKCknZWQgYXJndW1lbnRzIHdpbGwgYmUgbm90aWZpZWQuXG4gICAgICAgKiBFeC5cbiAgICAgICAqIDxwcmU+XG4gICAgICAgKiAgIHZhciBvYmogID0gZm9hbS5jb3JlLkZPYmplY3QuY3JlYXRlKCk7XG4gICAgICAgKiAgIHZhciBzdWIxID0gb2JqLnN1YiggICAgICAgICAgICAgICBmdW5jdGlvbihhLGIsYykgeyBjb25zb2xlLmxvZyhhLGIsYyk7IH0pO1xuICAgICAgICogICB2YXIgc3ViMiA9IG9iai5zdWIoJ2FsYXJtJywgICAgICAgZnVuY3Rpb24oYSxiLGMpIHsgY29uc29sZS5sb2coYSxiLGMpOyB9KTtcbiAgICAgICAqICAgdmFyIHN1YjMgPSBvYmouc3ViKCdhbGFybScsICdvbicsIGZ1bmN0aW9uKGEsYixjKSB7IGNvbnNvbGUubG9nKGEsYixjKTsgfSk7XG4gICAgICAgKlxuICAgICAgICogICBvYmoucHViKCdhbGFybScsICdvbicpOyAgLy8gbm90aWZpZXMgc3ViMSwgc3ViMiBhbmQgc3ViM1xuICAgICAgICogICBvYmoucHViKCdhbGFybScsICdvZmYnKTsgLy8gbm90aWZpZXMgc3ViMSBhbmQgc3ViMlxuICAgICAgICogICBvYmoucHViKCk7ICAgICAgICAgICAgICAgLy8gb25seSBub3RpZmllcyBzdWIxXG4gICAgICAgKiAgIG9iai5wdWIoJ2Zvb2JhcicpOyAgICAgICAvLyBvbmx5IG5vdGlmaWVzIHN1YjFcbiAgICAgICAqIDwvcHJlPlxuICAgICAgICpcbiAgICAgICAqIE5vdGUgaG93IEZPYmplY3RzIGNhbiBiZSB1c2VkIGFzIGdlbmVyaWMgcHViL3N1YnMuXG4gICAgICAgKlxuICAgICAgICogUmV0dXJucyB0aGUgbnVtYmVyIG9mIGxpc3RlbmVycyBub3RpZmllZC5cbiAgICAgICAqL1xuXG4gICAgICAvLyBUaGlzIG1ldGhvZCBwcmV2ZW50cyB0aGlzIGZ1bmN0aW9uIG5vdCBiZWluZyBKSVQtZWQgYmVjYXVzZVxuICAgICAgLy8gb2YgdGhlIHVzZSBvZiAnYXJndW1lbnRzJy4gRG9lc24ndCBnZW5lcmF0ZSBhbnkgZ2FyYmFnZSAoW10nc1xuICAgICAgLy8gZG9uJ3QgYXBwZWFyIHRvIGJlIGdhcmJhZ2UgaW4gVjgpLlxuICAgICAgLy8gRlVUVVJFOiBiZW5jaG1hcmtcbiAgICAgIHN3aXRjaCAoIGFyZ3VtZW50cy5sZW5ndGggKSB7XG4gICAgICAgIGNhc2UgMDogIHJldHVybiB0aGlzLnB1Yl8oW10pO1xuICAgICAgICBjYXNlIDE6ICByZXR1cm4gdGhpcy5wdWJfKFsgYTEgXSk7XG4gICAgICAgIGNhc2UgMjogIHJldHVybiB0aGlzLnB1Yl8oWyBhMSwgYTIgXSk7XG4gICAgICAgIGNhc2UgMzogIHJldHVybiB0aGlzLnB1Yl8oWyBhMSwgYTIsIGEzIF0pO1xuICAgICAgICBjYXNlIDQ6ICByZXR1cm4gdGhpcy5wdWJfKFsgYTEsIGEyLCBhMywgYTQgXSk7XG4gICAgICAgIGNhc2UgNTogIHJldHVybiB0aGlzLnB1Yl8oWyBhMSwgYTIsIGEzLCBhNCwgYTUgXSk7XG4gICAgICAgIGNhc2UgNjogIHJldHVybiB0aGlzLnB1Yl8oWyBhMSwgYTIsIGEzLCBhNCwgYTUsIGE2IF0pO1xuICAgICAgICBjYXNlIDc6ICByZXR1cm4gdGhpcy5wdWJfKFsgYTEsIGEyLCBhMywgYTQsIGE1LCBhNiwgYTcgXSk7XG4gICAgICAgIGNhc2UgODogIHJldHVybiB0aGlzLnB1Yl8oWyBhMSwgYTIsIGEzLCBhNCwgYTUsIGE2LCBhNywgYTggXSk7XG4gICAgICAgIGRlZmF1bHQ6IHJldHVybiB0aGlzLnB1Yl8oYXJndW1lbnRzKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgZnVuY3Rpb24gcHViXyhhcmdzKSB7XG4gICAgICAvKiogSW50ZXJuYWwgcHVibGlzaCBtZXRob2QsIGNhbGxlZCBieSBwdWIoKS4gKi9cblxuICAgICAgLy8gTm8gbGlzdGVuZXJzLCBzbyByZXR1cm4uXG4gICAgICBpZiAoICEgdGhpcy5oYXNPd25Qcml2YXRlXygnbGlzdGVuZXJzJykgKSByZXR1cm4gMDtcblxuICAgICAgdmFyIGxpc3RlbmVycyA9IHRoaXMubGlzdGVuZXJzXygpO1xuXG4gICAgICAvLyBOb3RpZnkgYWxsIGdsb2JhbCBsaXN0ZW5lcnMuXG4gICAgICB2YXIgY291bnQgPSB0aGlzLm5vdGlmeV8obGlzdGVuZXJzLm5leHQsIGFyZ3MpO1xuXG4gICAgICAvLyBXYWxrIHRoZSBhcmd1bWVudHMsIG5vdGlmeWluZyBtb3JlIHNwZWNpZmljIGxpc3RlbmVycy5cbiAgICAgIGZvciAoIHZhciBpID0gMCA7IGkgPCBhcmdzLmxlbmd0aDsgaSsrICkge1xuICAgICAgICBsaXN0ZW5lcnMgPSBsaXN0ZW5lcnMuY2hpbGRyZW4gJiYgbGlzdGVuZXJzLmNoaWxkcmVuW2FyZ3NbaV1dO1xuICAgICAgICBpZiAoICEgbGlzdGVuZXJzICkgYnJlYWs7XG4gICAgICAgIGNvdW50ICs9IHRoaXMubm90aWZ5XyhsaXN0ZW5lcnMubmV4dCwgYXJncyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBjb3VudDtcbiAgICB9LFxuXG4gICAgZnVuY3Rpb24gc3ViKCkgeyAvKiBhcmdzLi4uLCBsICovXG4gICAgICAvKipcbiAgICAgICAqIFN1YnNjcmliZSB0byBwdWIoKSdlZCBldmVudHMuXG4gICAgICAgKiBhcmdzIC0gemVybyBvciBtb3JlIHZhbHVlcyB3aGljaCBzcGVjaWZ5IHRoZSBwYXR0ZXJuIG9mIHB1YigpJ2VkXG4gICAgICAgKiBldmVudHMgdG8gbWF0Y2guXG4gICAgICAgKiA8cD5Gb3IgZXhhbXBsZTpcbiAgICAgICAqIDxwcmU+XG4gICAgICAgKiAgIHN1YigncHJvcGVydHlDaGFuZ2UnLCBsKSB3aWxsIG1hdGNoOlxuICAgICAgICogICBwdWIoJ3Byb3BlcnR5Q2hhbmdlJywgJ2FnZScsIDE4LCAxOSksIGJ1dCBub3Q6XG4gICAgICAgKiAgIHB1Yignc3RhdGVDaGFuZ2UnLCAnYWN0aXZlJyk7XG4gICAgICAgKiA8L3ByZT5cbiAgICAgICAqIDxwPnN1YihsKSB3aWxsIG1hdGNoIGFsbCBldmVudHMuXG4gICAgICAgKiAgIGwgLSB0aGUgbGlzdGVuZXIgdG8gY2FsbCB3aXRoIG5vdGlmaWNhdGlvbnMuXG4gICAgICAgKiA8cD4gVGhlIGZpcnN0IGFyZ3VtZW50IHN1cHBsaWVkIHRvIHRoZSBsaXN0ZW5lciBpcyB0aGUgXCJzdWJzY3JpcHRpb25cIixcbiAgICAgICAqICAgd2hpY2ggY29udGFpbnMgdGhlIFwic3JjXCIgb2YgdGhlIGV2ZW50IGFuZCBhIGRldGFjaCgpIG1ldGhvZCBmb3JcbiAgICAgICAqICAgY2FuY2VsbGluZyB0aGUgc3Vic2NyaXB0aW9uLlxuICAgICAgICogPHA+UmV0dXJucyBhIFwic3Vic2NyaXRpb25cIiB3aGljaCBjYW4gYmUgY2FuY2VsbGVkIGJ5IGNhbGxpbmdcbiAgICAgICAqICAgaXRzIC5kZXRhY2goKSBtZXRob2QuXG4gICAgICAgKi9cblxuICAgICAgdmFyIGwgPSBhcmd1bWVudHNbYXJndW1lbnRzLmxlbmd0aCAtIDFdO1xuXG4gICAgICBmb2FtLmFzc2VydChmb2FtLkZ1bmN0aW9uLmlzSW5zdGFuY2UobCksXG4gICAgICAgICAgJ0xpc3RlbmVyIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuXG4gICAgICB2YXIgbGlzdGVuZXJzID0gdGhpcy5saXN0ZW5lcnNfKCk7XG5cbiAgICAgIGZvciAoIHZhciBpID0gMCA7IGkgPCBhcmd1bWVudHMubGVuZ3RoIC0gMSA7IGkrKyApIHtcbiAgICAgICAgdmFyIGNoaWxkcmVuID0gbGlzdGVuZXJzLmNoaWxkcmVuIHx8ICggbGlzdGVuZXJzLmNoaWxkcmVuID0ge30gKTtcbiAgICAgICAgbGlzdGVuZXJzID0gY2hpbGRyZW5bYXJndW1lbnRzW2ldXSB8fFxuICAgICAgICAgICAgKCBjaGlsZHJlblthcmd1bWVudHNbaV1dID0gdGhpcy5jcmVhdGVMaXN0ZW5lckxpc3RfKCkgKTtcbiAgICAgIH1cblxuICAgICAgdmFyIG5vZGUgPSB7XG4gICAgICAgIHN1YjogIHsgc3JjOiB0aGlzIH0sXG4gICAgICAgIG5leHQ6IGxpc3RlbmVycy5uZXh0LFxuICAgICAgICBwcmV2OiBsaXN0ZW5lcnMsXG4gICAgICAgIGw6ICAgIGxcbiAgICAgIH07XG4gICAgICBub2RlLnN1Yi5kZXRhY2ggPSBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKCBub2RlLm5leHQgKSBub2RlLm5leHQucHJldiA9IG5vZGUucHJldjtcbiAgICAgICAgaWYgKCBub2RlLnByZXYgKSBub2RlLnByZXYubmV4dCA9IG5vZGUubmV4dDtcblxuICAgICAgICAvLyBEaXNjb25uZWN0IHNvIHRoYXQgY2FsbGluZyBkZXRhY2ggbW9yZSB0aGFuIG9uY2UgaXMgaGFybWxlc3NcbiAgICAgICAgbm9kZS5uZXh0ID0gbm9kZS5wcmV2ID0gbnVsbDtcbiAgICAgIH07XG5cbiAgICAgIGlmICggbGlzdGVuZXJzLm5leHQgKSBsaXN0ZW5lcnMubmV4dC5wcmV2ID0gbm9kZTtcbiAgICAgIGxpc3RlbmVycy5uZXh0ID0gbm9kZTtcblxuICAgICAgcmV0dXJuIG5vZGUuc3ViO1xuICAgIH0sXG5cbiAgICBmdW5jdGlvbiBwdWJQcm9wZXJ0eUNoYW5nZV8ocHJvcCwgb2xkVmFsdWUsIG5ld1ZhbHVlKSB7XG4gICAgICAvKipcbiAgICAgICAqIFB1Ymxpc2ggdG8gdGhpcy5wcm9wZXJ0eUNoYW5nZSB0b3BpYyBpZiBvbGRWYWx1ZSBhbmQgbmV3VmFsdWUgYXJlXG4gICAgICAgKiBkaWZmZXJlbnQuXG4gICAgICAgKi9cbiAgICAgIGlmICggT2JqZWN0LmlzKG9sZFZhbHVlLCBuZXdWYWx1ZSkgKSByZXR1cm47XG4gICAgICBpZiAoICEgdGhpcy5oYXNMaXN0ZW5lcnMoJ3Byb3BlcnR5Q2hhbmdlJywgcHJvcC5uYW1lKSApIHJldHVybjtcblxuICAgICAgdmFyIHNsb3QgPSBwcm9wLnRvU2xvdCh0aGlzKTtcbiAgICAgIHNsb3Quc2V0UHJldihvbGRWYWx1ZSk7XG4gICAgICB0aGlzLnB1YigncHJvcGVydHlDaGFuZ2UnLCBwcm9wLm5hbWUsIHNsb3QpO1xuICAgIH0sXG5cbiAgICBmdW5jdGlvbiBzbG90KG9iaikge1xuICAgICAgLyoqXG4gICAgICAgKiBDcmVhdGVzIGEgU2xvdCBmb3IgYW4gQXhpb20uXG4gICAgICAgKi9cbiAgICAgIGlmICggdHlwZW9mIG9iaiA9PT0gJ2Z1bmN0aW9uJyApIHtcbiAgICAgICAgcmV0dXJuIGZvYW0uY29yZS5FeHByZXNzaW9uU2xvdC5jcmVhdGUoXG4gICAgICAgICAgICBhcmd1bWVudHMubGVuZ3RoID09PSAxID9cbiAgICAgICAgICAgICAgICB7IGNvZGU6IG9iaiwgb2JqOiB0aGlzIH0gOlxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgIGNvZGU6IG9iaixcbiAgICAgICAgICAgICAgICAgIG9iajogdGhpcyxcbiAgICAgICAgICAgICAgICAgIGFyZ3M6IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSlcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgaWYgKCBmb2FtLkFycmF5LmlzSW5zdGFuY2Uob2JqKSApIHtcbiAgICAgICAgcmV0dXJuIGZvYW0uY29yZS5FeHByZXNzaW9uU2xvdC5jcmVhdGUoe1xuICAgICAgICAgIG9iajogdGhpcyxcbiAgICAgICAgICBhcmdzOiBvYmpbMF0ubWFwKHRoaXMuc2xvdC5iaW5kKHRoaXMpKSxcbiAgICAgICAgICBjb2RlOiBvYmpbMV0sXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICB2YXIgbmFtZXMgPSBvYmouc3BsaXQoJyQnKTtcbiAgICAgIHZhciBheGlvbSA9IHRoaXMuY2xzXy5nZXRBeGlvbUJ5TmFtZShuYW1lcy5zaGlmdCgpKTtcblxuICAgICAgZm9hbS5hc3NlcnQoYXhpb20sICdzbG90KCkgY2FsbGVkIHdpdGggdW5rbm93biBheGlvbSBuYW1lOicsIG9iaik7XG4gICAgICBmb2FtLmFzc2VydChheGlvbS50b1Nsb3QsICdDYWxsZWQgc2xvdCgpIG9uIHVuc2xvdHRhYmxlIGF4aW9tOicsIG9iaik7XG5cbiAgICAgIHZhciBzbG90ID0gYXhpb20udG9TbG90KHRoaXMpXG4gICAgICBuYW1lcy5mb3JFYWNoKGZ1bmN0aW9uKG4pIHtcbiAgICAgICAgc2xvdCA9IHNsb3QuZG90KG4pO1xuICAgICAgfSk7XG5cbiAgICAgIHJldHVybiBzbG90O1xuICAgIH0sXG5cblxuICAgIC8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAgICAgKiBEZXN0cnVjdGlvblxuICAgICAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbiAgICBmdW5jdGlvbiBvbkRldGFjaChkKSB7XG4gICAgICAvKipcbiAgICAgICAqIFJlZ2lzdGVyIGEgZnVuY3Rpb24gb3IgYSBkZXRhY2hhYmxlIHRvIGJlIGNhbGxlZCB3aGVuIHRoaXMgb2JqZWN0IGlzXG4gICAgICAgKiBkZXRhY2hlZC5cbiAgICAgICAqXG4gICAgICAgKiBBIGRldGFjaGFibGUgaXMgYW55IG9iamVjdCB3aXRoIGEgZGV0YWNoKCkgbWV0aG9kLlxuICAgICAgICpcbiAgICAgICAqIERvZXMgbm90aGluZyBpcyB0aGUgYXJndW1lbnQgaXMgZmFsc3kuXG4gICAgICAgKlxuICAgICAgICogUmV0dXJucyB0aGUgaW5wdXQgb2JqZWN0LCB3aGljaCBjYW4gYmUgdXNlZnVsIGZvciBjaGFpbmluZy5cbiAgICAgICAqL1xuICAgICAgZm9hbS5hc3NlcnQoISBkIHx8IGZvYW0uRnVuY3Rpb24uaXNJbnN0YW5jZShkLmRldGFjaCkgfHxcbiAgICAgICAgICBmb2FtLkZ1bmN0aW9uLmlzSW5zdGFuY2UoZCksXG4gICAgICAgICAgJ0FyZ3VtZW50IHRvIG9uRGV0YWNoKCkgbXVzdCBiZSBjYWxsYWJsZSBvciBkZXRhY2hhYmxlLicpO1xuICAgICAgaWYgKCBkICkgdGhpcy5zdWIoJ2RldGFjaCcsIGQuZGV0YWNoID8gZC5kZXRhY2guYmluZChkKSA6IGQpO1xuICAgICAgcmV0dXJuIGQ7XG4gICAgfSxcblxuICAgIGZ1bmN0aW9uIGRldGFjaCgpIHtcbiAgICAgIC8qKlxuICAgICAgICogRGV0YWNoIHRoaXMgb2JqZWN0LiBGcmVlIGFueSByZWZlcmVuY2VkIG9iamVjdHMgYW5kIGRlc3RvcnlcbiAgICAgICAqIGFueSByZWdpc3RlcmVkIGRldHJveWFibGVzLlxuICAgICAgICovXG4gICAgICBpZiAoIHRoaXMuaW5zdGFuY2VfLmRldGFjaGluZ18gKSByZXR1cm47XG5cbiAgICAgIC8vIFJlY29yZCB0aGF0IHdlJ3JlIGN1cnJlbnRseSBkZXRhY2hpbmcgdGhpcyBvYmplY3QsXG4gICAgICAvLyB0byBwcmV2ZW50IGluZmluaXRlIHJlY3Vyc2lvbi5cbiAgICAgIHRoaXMuaW5zdGFuY2VfLmRldGFjaGluZ18gPSB0cnVlO1xuICAgICAgdGhpcy5wdWIoJ2RldGFjaCcpO1xuICAgICAgdGhpcy5pbnN0YW5jZV8uZGV0YWNoaW5nXyA9IGZhbHNlO1xuICAgICAgdGhpcy5jbGVhclByaXZhdGVfKCdsaXN0ZW5lcnMnKTtcbiAgICB9LFxuXG5cbiAgICAvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gICAgICogVXRpbGl0eSBNZXRob2RzOiBjbG9uZSwgZXF1YWxzLCBoYXNoQ29kZSwgZXRjLlxuICAgICAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbiAgICBmdW5jdGlvbiBlcXVhbHMob3RoZXIpIHsgcmV0dXJuIHRoaXMuY29tcGFyZVRvKG90aGVyKSA9PT0gMDsgfSxcblxuICAgIGZ1bmN0aW9uIGNvbXBhcmVUbyhvdGhlcikge1xuICAgICAgaWYgKCBvdGhlciA9PT0gdGhpcyApIHJldHVybiAwO1xuICAgICAgaWYgKCAhIG90aGVyICAgICAgICApIHJldHVybiAxO1xuXG4gICAgICBpZiAoIHRoaXMubW9kZWxfICE9PSBvdGhlci5tb2RlbF8gKSB7XG4gICAgICAgIHJldHVybiBvdGhlci5tb2RlbF8gP1xuICAgICAgICAgIGZvYW0udXRpbC5jb21wYXJlKHRoaXMubW9kZWxfLmlkLCBvdGhlci5tb2RlbF8uaWQpIDpcbiAgICAgICAgICAxO1xuICAgICAgfVxuXG4gICAgICAvLyBGVVRVUkU6IGNoZWNrICdpZCcgZmlyc3RcbiAgICAgIC8vIEZVVFVSRTogb3JkZXIgcHJvcGVydGllc1xuICAgICAgdmFyIHBzID0gdGhpcy5jbHNfLmdldEF4aW9tc0J5Q2xhc3MoZm9hbS5jb3JlLlByb3BlcnR5KTtcbiAgICAgIGZvciAoIHZhciBpID0gMCA7IGkgPCBwcy5sZW5ndGggOyBpKysgKSB7XG4gICAgICAgIHZhciByID0gcHNbaV0uY29tcGFyZSh0aGlzLCBvdGhlcik7XG4gICAgICAgIGlmICggciApIHJldHVybiByO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gMDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ29tcGFyZSB0aGlzIG9iamVjdCB0byBhbm90aGVyIG9iamVjdCBvZiB0aGUgc2FtZSB0eXBlLCBhbmQgcHJvZHVjZSBhIHJhd1xuICAgICAqIGphdmFzY3JpcHQgb2JqZWN0IHdoaWNoIHNob3dzIHRoZSBkaWZmZXJlbmNlcyBiZXR3ZWVuIHRoZSB0d28uXG4gICAgICogRXhhbXBsZVxuICAgICAqIDxwcmU+XG4gICAgICogdmFyIG9iajEgPSBBYmMuY3JlYXRlKHsgYTogMSwgYjogWydBJywgJ0InLCAnQyddIH0pO1xuICAgICAqIHZhciBvYmoyID0gQWJjLmNyZWF0ZSh7IGE6IDIsIGI6IFsnQScsICdEJ10gfSk7XG4gICAgICogdmFyIGRpZmYgPSBvYmoxLmRpZmYob2JqMik7XG4gICAgICogPC9wcmU+XG4gICAgICogVGhlIGRpZmYgb2JqZWN0IHdpbGwgbG9vayBsaWtlXG4gICAgICogPHByZT5cbiAgICAgKiB7IGE6IDIsIGI6IHsgYWRkZWQ6IFsnRCddLCByZW1vdmVkOiBbJ0InLCAnQyddIH0gfTtcbiAgICAgKiA8L3ByZT5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBkaWZmKG90aGVyKSB7XG4gICAgICB2YXIgZCA9IHt9O1xuXG4gICAgICBmb2FtLmFzc2VydChvdGhlciwgJ0F0dGVtcHQgdG8gZGlmZiBhZ2FpbnN0IG51bGwuJyk7XG4gICAgICBmb2FtLmFzc2VydChvdGhlci5jbHNfID09PSB0aGlzLmNsc18sICdBdHRlbXB0IHRvIGRpZmYgb2JqZWN0cyB3aXRoIGRpZmZlcmVudCBjbGFzc2VzLicsIHRoaXMsIG90aGVyKTtcblxuICAgICAgdmFyIHBzID0gdGhpcy5jbHNfLmdldEF4aW9tc0J5Q2xhc3MoZm9hbS5jb3JlLlByb3BlcnR5KTtcbiAgICAgIGZvciAoIHZhciBpID0gMCwgcHJvcGVydHkgOyBwcm9wZXJ0eSA9IHBzW2ldIDsgaSsrICkge1xuICAgICAgICAvLyBGVVRVUkU6IG1vdmUgdGhpcyB0byBhIHJlZmluZW1lbnQgaW4gY2FzZSBub3QgbmVlZGVkP1xuICAgICAgICAvLyBGVVRVUkU6IGFkZCBuZXN0ZWQgT2JqZWN0IHN1cHBvcnRcbiAgICAgICAgLy8gRlVUVVJFOiBhZGQgcGF0Y2goKSBtZXRob2Q/XG5cbiAgICAgICAgLy8gUHJvcGVydHkgYWRkcyBpdHMgZGlmZmVyZW5jZShzKSB0byBcImRcIi5cbiAgICAgICAgcHJvcGVydHkuZGlmZlByb3BlcnR5KHRoaXMsIG90aGVyLCBkLCBwcm9wZXJ0eSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBkO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgIENyZWF0ZSBhbiBpbnRlZ2VyIGhhc2ggY29kZSB2YWx1ZSBiYXNlZCBvbiBhbGwgcHJvcGVydGllcyBvZiB0aGlzIG9iamVjdC5cbiAgICAqL1xuICAgIGZ1bmN0aW9uIGhhc2hDb2RlKCkge1xuICAgICAgdmFyIGhhc2ggPSAxNztcblxuICAgICAgdmFyIHBzID0gdGhpcy5jbHNfLmdldEF4aW9tc0J5Q2xhc3MoZm9hbS5jb3JlLlByb3BlcnR5KTtcbiAgICAgIGZvciAoIHZhciBpID0gMCA7IGkgPCBwcy5sZW5ndGggOyBpKysgKSB7XG4gICAgICAgIHZhciBwcm9wID0gdGhpc1twc1tpXS5uYW1lXTtcbiAgICAgICAgaGFzaCA9ICgoaGFzaCA8PCA1KSAtIGhhc2gpICsgZm9hbS51dGlsLmhhc2hDb2RlKHByb3ApO1xuICAgICAgICBoYXNoICY9IGhhc2g7IC8vIGZvcmNlcyAnaGFzaCcgYmFjayB0byBhIDMyLWJpdCBpbnRcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGhhc2g7XG4gICAgfSxcblxuICAgIGZ1bmN0aW9uIGNsb25lKG9wdF9YKSB7XG4gICAgICAvKiogQ3JlYXRlIGEgZGVlcCBjb3B5IG9mIHRoaXMgb2JqZWN0LiAqKi9cbiAgICAgIHZhciBtID0ge307XG4gICAgICBmb3IgKCB2YXIga2V5IGluIHRoaXMuaW5zdGFuY2VfICkge1xuICAgICAgICBpZiAoIHRoaXMuaW5zdGFuY2VfW2tleV0gPT09IHVuZGVmaW5lZCApIGNvbnRpbnVlOyAvLyBTa2lwIHByZXZpb3VzbHkgY2xlYXJlZCBrZXlzLlxuXG4gICAgICAgIHZhciB2YWx1ZSA9IHRoaXNba2V5XTtcbiAgICAgICAgdGhpcy5jbHNfLmdldEF4aW9tQnlOYW1lKGtleSkuY2xvbmVQcm9wZXJ0eSh2YWx1ZSwgbSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5jbHNfLmNyZWF0ZShtLCBvcHRfWCB8fCB0aGlzLl9fY29udGV4dF9fKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICBDb3B5IHByb3BlcnR5IHZhbHVlcyBmcm9tIHRoZSBzdXBwbGllZCBvYmplY3Qgb3IgbWFwLlxuXG4gICAgICBFeC5cbjxwcmU+XG4gIHBlcnNvbi5jb3B5RnJvbSh7Zk5hbWU6ICdKb2huJywgbE5hbWU6ICdTbWl0aCcsIGFnZTogNDJ9KVxuICBvclxuICBwZXJzb24uY29weUZyb20ob3RoZXJQZXJzb24pO1xuPC9wcmU+XG4gICAgIFRoZSBmaXJzdCBleGFtcGxlIGlzIHNob3J0LWZvcm0gZm9yOlxuPHByZT5cbiAgcGVyc29uLmZOYW1lID0gJ0pvaG4nO1xuICBwZXJzb24ubE5hbWUgPSAnU21pdGgnO1xuICBwZXJzb24uYWdlICAgPSA0MjtcbjwvcHJlPlxuICAgICBJZiBhbiBGT2JqZWN0IGlzIHN1cHBsaWVkLCBpdCBkb2Vzbid0IG5lZWQgdG8gYmUgdGhlIHNhbWUgY2xhc3MgYXMgJ3RoaXMnLlxuICAgICBPbmx5IHByb3BlcnRpZXMgdGhhdCB0aGUgdHdvIGNsYXNzZXMgaGF2ZSBpbiBjb21tb24gd2lsbCBiZSBjb3BpZWQuXG4gICAgIE51bGwgb3IgdW5kZWZpbmVkIHZhbHVlcyBhcmUgaWdub3JlZC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjb3B5RnJvbShvLCBvcHRfd2Fybikge1xuICAgICAgaWYgKCAhIG8gKSByZXR1cm4gdGhpcztcblxuICAgICAgLy8gV2hlbiBjb3B5aW5nIGZyb20gYSBwbGFpbiBtYXAsIGp1c3QgZW51bWVyYXRlIHRoZSBrZXlzXG4gICAgICBpZiAoIG8uX19wcm90b19fID09PSBPYmplY3QucHJvdG90eXBlIHx8ICEgby5fX3Byb3RvX18gKSB7XG4gICAgICAgIGZvciAoIHZhciBrZXkgaW4gbyApIHtcbiAgICAgICAgICB2YXIgbmFtZSA9IGtleS5lbmRzV2l0aCgnJCcpID9cbiAgICAgICAgICAgICAga2V5LnN1YnN0cmluZygwLCBrZXkubGVuZ3RoIC0gMSkgOlxuICAgICAgICAgICAgICBrZXkgO1xuXG4gICAgICAgICAgdmFyIGEgPSB0aGlzLmNsc18uZ2V0QXhpb21CeU5hbWUobmFtZSk7XG4gICAgICAgICAgaWYgKCBhICYmIGZvYW0uY29yZS5Qcm9wZXJ0eS5pc0luc3RhbmNlKGEpICkge1xuICAgICAgICAgICAgdGhpc1trZXldID0gb1trZXldO1xuICAgICAgICAgIH0gZWxzZSBpZiAoIG9wdF93YXJuICkge1xuICAgICAgICAgICAgdGhpcy51bmtub3duQXJnKGtleSwgb1trZXldKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG5cbiAgICAgIC8vIFdoZW4gY29weWluZyBmcm9tIGFuIG9iamVjdCBvZiB0aGUgc2FtZSBjbGFzc1xuICAgICAgLy8gV2UgZG9uJ3QgY29weSBkZWZhdWx0IHZhbHVlcyBvciB0aGUgdmFsdWVzIG9mIGV4cHJlc3Npb25zXG4gICAgICAvLyBzbyB0aGF0IHRoZSB1bnNldCBzdGF0ZSBvZiB0aG9zZSBwcm9wZXJ0aWVzIGlzIHByZXNlcnZlZFxuICAgICAgdmFyIHByb3BzID0gdGhpcy5jbHNfLmdldEF4aW9tc0J5Q2xhc3MoZm9hbS5jb3JlLlByb3BlcnR5KTtcblxuICAgICAgaWYgKCBvLmNsc18gJiYgKCBvLmNsc18gPT09IHRoaXMuY2xzXyB8fCBvLmNsc18uaXNTdWJDbGFzcyh0aGlzLmNsc18pICkgKSB7XG4gICAgICAgIGZvciAoIHZhciBpID0gMCA7IGkgPCBwcm9wcy5sZW5ndGggOyBpKysgKSB7XG4gICAgICAgICAgdmFyIG5hbWUgPSBwcm9wc1tpXS5uYW1lO1xuXG4gICAgICAgICAgLy8gT25seSBjb3B5IHZhbHVlcyB0aGF0IGFyZSBzZXQgb3IgaGF2ZSBhIGZhY3RvcnkuXG4gICAgICAgICAgLy8gQW55IGRlZmF1bHQgdmFsdWVzIG9yIGV4cHJlc3Npb25zIHdpbGwgYmUgdGhlIHNhbWVcbiAgICAgICAgICAvLyBmb3IgZWFjaCBvYmplY3Qgc2luY2UgdGhleSBhcmUgb2YgdGhlIGV4YWN0IHNhbWVcbiAgICAgICAgICAvLyB0eXBlLlxuICAgICAgICAgIGlmICggby5oYXNPd25Qcm9wZXJ0eShuYW1lKSB8fCBwcm9wc1tpXS5mYWN0b3J5ICkge1xuICAgICAgICAgICAgdGhpc1tuYW1lXSA9IG9bbmFtZV07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuXG4gICAgICAvLyBJZiB0aGUgc291cmNlIGlzIGFuIEZPYmplY3QsIGNvcHkgYW55IHByb3BlcnRpZXNcbiAgICAgIC8vIHRoYXQgd2UgaGF2ZSBpbiBjb21tb24uXG4gICAgICBpZiAoIGZvYW0uY29yZS5GT2JqZWN0LmlzSW5zdGFuY2UobykgKSB7XG4gICAgICAgIGZvciAoIHZhciBpID0gMCA7IGkgPCBwcm9wcy5sZW5ndGggOyBpKysgKSB7XG4gICAgICAgICAgdmFyIG5hbWUgPSBwcm9wc1tpXS5uYW1lO1xuICAgICAgICAgIHZhciBvdGhlclByb3AgPSBvLmNsc18uZ2V0QXhpb21CeU5hbWUobmFtZSk7XG4gICAgICAgICAgaWYgKCBvdGhlclByb3AgJiYgZm9hbS5jb3JlLlByb3BlcnR5LmlzSW5zdGFuY2Uob3RoZXJQcm9wKSApIHtcbiAgICAgICAgICAgIHRoaXNbbmFtZV0gPSBvW25hbWVdO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cblxuICAgICAgLy8gSWYgdGhlIHNvdXJjZSBpcyBzb21lIHVua25vd24gb2JqZWN0LCB3ZSBkbyBvdXIgYmVzdFxuICAgICAgLy8gdG8gY29weSBhbnkgdmFsdWVzIHRoYXQgYXJlIG5vdCB1bmRlZmluZWQuXG4gICAgICBmb3IgKCB2YXIgaSA9IDAgOyBpIDwgcHJvcHMubGVuZ3RoIDsgaSsrICkge1xuICAgICAgICB2YXIgbmFtZSA9IHByb3BzW2ldLm5hbWU7XG4gICAgICAgIGlmICggdHlwZW9mIG9bbmFtZV0gIT09ICd1bmRlZmluZWQnICkge1xuICAgICAgICAgIHRoaXNbbmFtZV0gPSBvW25hbWVdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgICAvLyBEaXN0aW5ndWlzaCBiZXR3ZWVuIHByb3RvdHlwZXMgYW5kIGluc3RhbmNlcy5cbiAgICAgIHJldHVybiB0aGlzLmNsc18uaWQgKyAoXG4gICAgICAgICAgdGhpcy5jbHNfLnByb3RvdHlwZSA9PT0gdGhpcyA/ICdQcm90bycgOiAnJyk7XG4gICAgfSxcblxuICAgIGZ1bmN0aW9uIGRvdChuYW1lKSB7XG4gICAgICAvLyBCZWhhdmVzIGp1c3QgbGlrZSBTbG90LmRvdCgpLiAgTWFrZXMgaXQgZWFzeSBmb3IgY3JlYXRpbmcgc3ViLXNsb3RzXG4gICAgICAvLyB3aXRob3V0IHdvcnJ5aW5nIGlmIHlvdSdyZSBob2xkaW5nIGFuIEZPYmplY3Qgb3IgYSBzbG90LlxuICAgICAgcmV0dXJuIHRoaXNbbmFtZSArICckJ107XG4gICAgfVxuICBdXG59KTtcbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbi8qKiBDbGFzcy9Qcm90b3R5cGUgZGVzY3JpcHRpb24uICovXG5mb2FtLkNMQVNTKHtcbiAgcGFja2FnZTogJ2ZvYW0uY29yZScsXG4gIG5hbWU6ICdNb2RlbCcsXG5cbiAgZG9jdW1lbnRhdGlvbjogJ0EgQ2xhc3MgTW9kZWwgKGRlc2NyaXB0aW9uKS4nLFxuXG4gIHByb3BlcnRpZXM6IFtcbiAgICB7XG4gICAgICBuYW1lOiAnaWQnLFxuICAgICAgaGlkZGVuOiB0cnVlLFxuICAgICAgdHJhbnNpZW50OiB0cnVlLFxuICAgICAgZ2V0dGVyOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFja2FnZSA/IHRoaXMucGFja2FnZSArICcuJyArIHRoaXMubmFtZSA6IHRoaXMubmFtZTtcbiAgICAgIH1cbiAgICB9LFxuICAgICdwYWNrYWdlJyxcbiAgICAnYWJzdHJhY3QnLFxuICAgICduYW1lJyxcbiAgICB7XG4gICAgICBuYW1lOiAnZmxhZ3MnLFxuICAgICAgZmFjdG9yeTogZnVuY3Rpb24oKSB7IHJldHVybiB7fTsgfVxuICAgIH0sXG4gICAge1xuICAgICAgbmFtZTogJ2xhYmVsJyxcbiAgICAgIGV4cHJlc3Npb246IGZ1bmN0aW9uKG5hbWUpIHsgcmV0dXJuIGZvYW0uU3RyaW5nLmxhYmVsaXplKG5hbWUpOyB9XG4gICAgfSxcbiAgICBbICdleHRlbmRzJywgJ0ZPYmplY3QnIF0sXG4gICAgJ3JlZmluZXMnLFxuICAgIHsgbmFtZTogJ2RvY3VtZW50YXRpb24nLCBhZGFwdDogZnVuY3Rpb24oXywgZCkgeyByZXR1cm4gdHlwZW9mIGQgPT09ICdmdW5jdGlvbicgPyBmb2FtLlN0cmluZy5tdWx0aWxpbmUoZCkudHJpbSgpIDogZDsgfSB9LFxuICAgIHtcbiAgICAgIC8vIExpc3Qgb2YgYWxsIGF4aW9tcywgaW5jbHVkaW5nIG1ldGhvZHMsIHByb3BlcnRpZXMsIGxpc3RlbmVycyxcbiAgICAgIC8vIGV0Yy4gYW5kICdheGlvbXMnLlxuICAgICAgbmFtZTogJ2F4aW9tc18nLFxuICAgICAgdHJhbnNpZW50OiB0cnVlLFxuICAgICAgaGlkZGVuOiB0cnVlLFxuICAgICAgZmFjdG9yeTogZnVuY3Rpb24oKSB7IHJldHVybiBbXTsgfVxuICAgIH0sXG4gICAge1xuICAgICAgLy8gTGlzdCBvZiBleHRyYSBheGlvbXMuIElzIGFkZGVkIHRvIGF4aW9tc18uXG4gICAgICBuYW1lOiAnYXhpb21zJyxcbiAgICAgIGhpZGRlbjogdHJ1ZSxcbiAgICAgIGZhY3Rvcnk6IGZ1bmN0aW9uKCkgeyByZXR1cm4gW107IH0sXG4gICAgICBwb3N0U2V0OiBmdW5jdGlvbihfLCBhKSB7IHRoaXMuYXhpb21zXy5wdXNoLmFwcGx5KHRoaXMuYXhpb21zXywgYSk7IH1cbiAgICB9LFxuICAgIHtcbiAgICAgIC8vIElzIHVwZ3JhZGVkIHRvIGFuIEF4aW9tQXJyYXkgbGF0ZXIuXG4gICAgICBvZjogJ1Byb3BlcnR5JyxcbiAgICAgIG5hbWU6ICdwcm9wZXJ0aWVzJ1xuICAgIH0sXG4gICAge1xuICAgICAgLy8gSXMgdXBncmFkZWQgdG8gYW4gQXhpb21BcnJheSBsYXRlci5cbiAgICAgIG9mOiAnTWV0aG9kJyxcbiAgICAgIG5hbWU6ICdtZXRob2RzJ1xuICAgIH1cbiAgXSxcblxuICBtZXRob2RzOiBbIGZvYW0uYm9vdC5idWlsZENsYXNzIF1cbn0pO1xuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTYgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuLyoqXG4gIEEgUHJvcGVydHkgaXMgYSBoaWdoLWxldmVsIGluc3RhbmNlIHZhcmlhYmxlLlxuXG4gIFByb3BlcnRpZXMgY29udGFpbiBtb3JlIGluZm9ybWF0aW9uIHRoYW4gdHlwaWNhbCB2YXJpYWJsZSBkZWNsYXJhdGlvbnMuXG4gIFN1Y2ggYXM6IGxhYmVsLCBoZWxwIHRleHQsIHByZS9wb3N0LXNldCBjYWxsYmFja3MsIGRlZmF1bHQgdmFsdWUsXG4gIHZhbHVlIGZhY3RvcnksIHVuaXRzLCBldGMuXG5cbiAgV2hlbiBzZXR0aW5nIGEgUHJvcGVyeSdzIHZhbHVlLCB0aGUgY2FsbGJhY2sgb3JkZXIgaXM6XG4gICAgMS4gYWRhcHQoKVxuICAgIDIuIGFzc2VydFZhbHVlKClcbiAgICAzLiBwcmVTZXQoKVxuICAgICAgIHZhbHVlIHVwZGF0ZWRcbiAgICAgICBwcm9wZXJ0eSBjaGFuZ2UgZXZlbnQgZmlyZWRcbiAgICA0LiBwb3N0U2V0KClcblxuICAgVW5sZXNzIHRoZSB1c2VyIGhhcyBwcm92aWRlZCBhIGN1c3RvbWVyICdzZXR0ZXInLCBpbiB3aGljaCBjYXNlIHRoZSBvcmRlciBpc1xuICAgICAxLiBzZXR0ZXIoKVxuXG4gIEEgc3ViLWNsYXNzIG9yIHJlZmluZW1lbnQgY2FuIGluY2x1ZGUgYSBwYXJ0aWFsIFByb3BlcnR5IGRlZmluaXRpb24gd2hpY2hcbiAgd2lsbCBvdmVycmlkZSBvciBhZGQgbWV0YS1pbmZvcm1hdGlvbiB0byB0aGUgUHJvcGVydHkuXG4qKi9cbmZvYW0uQ0xBU1Moe1xuICBwYWNrYWdlOiAnZm9hbS5jb3JlJyxcbiAgbmFtZTogJ1Byb3BlcnR5JyxcbiAgZXh0ZW5kczogJ0ZPYmplY3QnLFxuXG4gIHByb3BlcnRpZXM6IFtcbiAgICB7XG4gICAgICBuYW1lOiAnbmFtZScsXG4gICAgICByZXF1aXJlZDogdHJ1ZVxuICAgIH0sXG4gICAge1xuICAgICAgbmFtZTogJ2xhYmVsJyxcbiAgICAgIC8vIElmIG5vdCBwcm92aWRlZCwgaXQgZGVmYXVsdHMgdG8gdGhlIG5hbWUgXCJsYWJlbGl6ZWRcIi5cbiAgICAgIGV4cHJlc3Npb246IGZ1bmN0aW9uKG5hbWUpIHsgcmV0dXJuIGZvYW0uU3RyaW5nLmxhYmVsaXplKG5hbWUpOyB9XG4gICAgfSxcblxuICAgIC8qIERldmVsb3Blci1sZXZlbCBkb2N1bWVudGF0aW9uLiAqL1xuICAgICdkb2N1bWVudGF0aW9uJyxcblxuICAgIC8qIFVzZXItbGV2ZWwgaGVscC4gQ291bGQvc2hvdWxkIGFwcGVhciBpbiBHVUkncyBhcyBvbmxpbmUgaGVscC4gKi9cbiAgICAnaGVscCcsXG5cbiAgICAvKiBIaWRkZW4gcHJvcGVydGllcyB0byBub3QgYXBwZWFyIGluIEdVSSdzIGJ5IGRlZmF1bHQuICovXG4gICAgeyBjbGFzczogJ0Jvb2xlYW4nLCBuYW1lOiAnaGlkZGVuJyB9LFxuXG4gICAgLyoqXG4gICAgICBUaGUgZGVmYXVsdC12YWx1ZSBvZiB0aGlzIHByb3BlcnR5LlxuICAgICAgQSBwcm9wZXJ0eSB3aGljaCBoYXMgbmV2ZXIgYmVlbiBzZXQgb3IgaGFzIGJlZW4gY2xlYXJlZFxuICAgICAgYnkgc2V0dGluZyBpdCB0byAndW5kZWZpbmVkJyBvciBjbGVhcmVkIHdpdGggY2xlYXJQcm9wZXJ0eSgpXG4gICAgICB3aWxsIGhhdmUgdGhlIGRlZmF1bHQgdmFsdWUuXG4gICAgKi9cbiAgICAndmFsdWUnLFxuXG4gICAgLyoqXG4gICAgICBBIGZhY3RvcnkgaXMgYSBmdW5jdGlvbiB3aGljaCBpbml0aWFsaXplcyB0aGUgcHJvcGVydHkgdmFsdWVcbiAgICAgIHdoZW4gYWNjZXNzZWQgZm9yIHRoZSBmaXJzdCB0aW1lLCBpZiBub3QgYWxyZWFkeSBzZXQuXG4gICAgKi9cbiAgICAnZmFjdG9yeScsXG5cbiAgICAvKipcbiAgICAgIEEgZnVuY3Rpb24gb2YgdGhlIGZvcm06XG4gICAgICAgIE9iamVjdCBmdW5jdGlvbihvbGRWYWx1ZSwgbmV3VmFsdWUpXG4gICAgICBhZGFwdCBpcyBjYWxsZWQgd2hlbnZlciB0aGUgcHJvcGVydHkgaXMgc2V0LiBJdCdzIGludGVuZGVkXG4gICAgICB0byBhZGFwdCB0aGUgdmFsdWUgdG8gdGhlIGFwcHJvcHJpYXRlIHR5cGUgaWYgcmVxdWlyZWQuXG4gICAgICBBZGFwdCBtdXN0IHJldHVybiBhIHZhbHVlLiBJdCBjYW4gcmV0dXJuIG5ld1ZhbHVlIHVuY2hhbmdlZFxuICAgICAgaWYgaXQgd2FzIGFscmVhZHkgdGhlIGFwcHJvcHJpYXRlIHR5cGUuXG4gICAgKi9cbiAgICAnYWRhcHQnLFxuXG4gICAgLyoqXG4gICAgICBBIGZ1bmN0aW9uIG9mIHRoZSBmb3JtOlxuICAgICAgICBPYmplY3QgZnVuY3Rpb24ob2xkVmFsdWUsIG5ld1ZhbHVlKVxuICAgICAgcHJlU2V0IGlzIGNhbGxlZCBiZWZvcmUgdGhlIHByb3BlcnkncyB2YWx1ZSBpcyB1cGRhdGVkLlxuICAgICAgSXQgY2FuIHZldG8gdGhlIHZhbHVlIGNoYW5nZSBieSByZXR1cm5pbmcgYSBkaWZmZXJlbnQgbmV3VmFsdWVcbiAgICAgIChpbmNsdWRpbmcgcmV0dXJuaW5nIG9sZFZhbHVlIHRvIGxlYXZlIHRoZSBwcm9wZXJ0eSB1bmNoYW5nZWQpLlxuICAgICovXG4gICAgJ3ByZVNldCcsXG5cbiAgICAvKipcbiAgICAgIEEgZnVuY3Rpb24gb2YgdGhlIGZvcm06XG4gICAgICAgIHZvaWQgZnVuY3Rpb24ob2xkVmFsdWUsIG5ld1ZhbHVlKSB0aHJvd3MgRXhjZXB0aW9uXG4gICAgICBhc3NlcnRWYWx1ZSBjYW4gdmFsaWRhdGUgbmV3VmFsdWUgYW5kIHRocm93IGFuIGV4Y2VwdGlvbiBpZiBpdCdzIGFuXG4gICAgICBpbnZhbGlkIHZhbHVlLlxuICAgICovXG4gICAgJ2Fzc2VydFZhbHVlJyxcblxuICAgIC8qKlxuICAgICAgQSBmdW5jdGlvbiBvZiB0aGUgZm9ybTpcbiAgICAgICAgdm9pZCBmdW5jdGlvbihvbGRWYWx1ZSwgbmV3VmFsdWUpXG4gICAgICBwb3N0U2V0IGlzIGNhbGxlZCBhZnRlciB0aGUgUHJvcGVydHkncyB2YWx1ZSBoYXMgYmVlbiB1cGRhdGVkLlxuICAgICovXG4gICAgJ3Bvc3RTZXQnLFxuXG4gICAgLyoqXG4gICAgICBBIGR5bmFtaWMgZnVuY3Rpb24gd2hpY2ggZGVmaW5lcyB0aGlzIFByb3BlcnR5J3MgdmFsdWUuXG4gICAgICBTaW1pbGFyIHRvICdmYWN0b3J5JywgZXhjZXB0IHRoYXQgdGhlIGZ1bmN0aW9uIHRha2VzIGFyZ3VtZW50c1xuICAgICAgd2hpY2ggYXJlIG5hbWVkIHRoZSBzYW1lIGFzIG90aGVyIHByb3BlcnRpZXMgb2YgdGhpcyBvYmplY3QuXG4gICAgICBXaGVuZXZlciB0aGUgdmFsdWVzIG9mIGFueSBvZiB0aGUgYXJndW1lbnQgcHJvcGVydGllcyBjaGFuZ2UsXG4gICAgICB0aGUgdmFsdWUgb2YgdGhpcyBQcm9wZXJ0eSBpcyBpbnZhbGlkYXRlZC4gTGlrZSBhIHJlZ3VsYXIgZmFjdG9yeSxcbiAgICAgIGFuIGludmFsaWRhdGVkIHByb3BlcnR5IHdpbGwgYmUgcmVjYWxjdWxhdGVkIGJ5IGNhbGxpbmcgdGhlIHByb3ZpZGVkXG4gICAgICBleHByZXNzaW9uIGZ1bmN0aW9uIHdoZW4gYWNjZXNzZWQuIFRoaXMgbWFrZXMgZXhwcmVzc2lvbnMgdmVyeSBlZmZpY2llbnRcbiAgICAgIGJlY2F1c2UgdGhlIHZhbHVlIGlzIG9ubHkgcmVjb21wdXRlZCB3aGVuIGFjdHVhbGx5IG5lZWRlZC5cbiAgICAqL1xuICAgICdleHByZXNzaW9uJyxcblxuICAgIC8qKlxuICAgICAgQSBnZXR0ZXIgZnVuY3Rpb24gd2hpY2ggY29tcGxldGVseSByZXBsYWNlcyB0aGUgbm9ybWFsXG4gICAgICBQcm9wZXJ0eSBnZXR0ZXIgcHJvY2Vzcy4gV2hlbmV2ZXIgdGhlIHByb3BlcnR5IGlzIGFjY2Vzc2VkLCBnZXR0ZXIgaXNcbiAgICAgIGNhbGxlZCBhbmQgaXRzIHZhbHVlIGlzIHJldHVybmVkLlxuICAgICovXG4gICAgJ2dldHRlcicsXG5cbiAgICAvKipcbiAgICAgIEEgc2V0dGVyIGZ1bmN0aW9uIHdoaWNoIGNvbXBsZXRlbHkgcmVwbGFjZXMgdGhlIG5vcm1hbFxuICAgICAgUHJvcGVydHkgc2V0dGVyIHByb2Nlc3MuIFdoZW5ldmVyIHRoZSBwcm9wZXJ0eSBpcyBzZXQsIHNldHRlciBpc1xuICAgICAgY2FsbGVkLlxuICAgICAgQSBmdW5jdGlvbiBvZiB0aGUgZm9ybTpcbiAgICAgICAgdm9pZCBmdW5jdGlvbihuZXdWYWx1ZSlcbiAgICAqL1xuICAgICdzZXR0ZXInLFxuXG4gICAgWyAnY2xvbmVQcm9wZXJ0eScsIGZ1bmN0aW9uKFxuICAgICAgLyogYW55IC8vIFRoZSB2YWx1ZSB0byBjbG9uZSAqLyAgICAgICAgIHZhbHVlLFxuICAgICAgLyogb2JqZWN0IC8vIEFkZCB2YWx1ZXMgdG8gdGhpcyBtYXAgdG9cbiAgICAgICAgIGhhdmUgdGhlbSBpbnN0YWxsZWQgb24gdGhlIGNsb25lLiAqLyBjbG9uZU1hcFxuICAgICAgKSB7XG4gICAgICAgIC8qKiBPdmVycmlkZSB0byBwcm92aWRlIHNwZWNpYWwgZGVlcCBjbG9uaW5nIGJlaGF2aW9yLiAqL1xuICAgICAgICBjbG9uZU1hcFt0aGlzLm5hbWVdID0gKCB2YWx1ZSAmJiB2YWx1ZS5jbG9uZSApID8gdmFsdWUuY2xvbmUoKSA6XG4gICAgICAgICAgZm9hbS51dGlsLmNsb25lKHZhbHVlKTtcbiAgICAgIH1cbiAgICBdLFxuXG4gICAgLyoqXG4gICAgICBBIGZpbmFsIFByb3BlcnR5IGNhbiBvbmx5IGJlIHNldCBvbmNlLlxuICAgICAgQWZ0ZXIgYmVpbmcgc2V0LCBpdHMgdmFsdWUgaXMgZmluYWwgKHJlYWQtb25seSkuXG4gICAgKi9cbiAgICAnZmluYWwnLFxuXG4gICAgLyoqXG4gICAgICBBIHJlcXVpcmVkIFByb3BlcnR5IGNhbiBub3QgYmUgc2V0IHRvIG51bGwsIHVuZGVmaW5lZCwgMCBvciBcIlwiLlxuICAgICAqL1xuICAgICdyZXF1aXJlZCcsXG5cbiAgICAvKipcbiAgICAgIFdoZW4gc2V0LCBtYXJrcyB0aGUgcHJvcGVydHkgd2l0aCB0aGUgZ2l2ZW4gZmxhZ3MuIFRoaXMgY2FuIGJlIHVzZWQgZm9yXG4gICAgICB0aGluZ3MgbGlrZSBzdHJpcHBpbmcgb3V0IHBsYXRmb3JtIHNwZWNpZmljIHByb3BlcnRpZXMgd2hlbiBzZXJpYWxpemluZy5cbiAgICAgKi9cbiAgICAnZmxhZ3MnLFxuXG4gICAgW1xuICAgICAgLyoqXG4gICAgICAgIENhbGxlZCB0byBjb252ZXJ0IGEgc3RyaW5nIGludG8gYSB2YWx1ZSBzdWl0YWJsZSBmb3IgdGhpcyBwcm9wZXJ0eS5cbiAgICAgICAgRWcuIHRoaXMgbWlnaHQgY29udmVydCBzdHJpbmdzIHRvIG51bWJlcnMsIG9yIHBhcnNlIFJGQyAyODIyIHRpbWVzdGFtcHMuXG4gICAgICAgIEJ5IGRlZmF1bHQgaXQgc2ltcGx5IHJldHVybnMgdGhlIHN0cmluZyB1bmNoYW5nZWQuXG4gICAgICAgKi9cbiAgICAgICdmcm9tU3RyaW5nJyxcbiAgICAgIGZ1bmN0aW9uKHN0cikgeyByZXR1cm4gc3RyOyB9XG4gICAgXSxcblxuICAgIFtcbiAgICAgIC8qKlxuICAgICAgICBDb21wYXJlIHR3byB2YWx1ZXMgdGFrZW4gZnJvbSB0aGlzIHByb3BlcnR5LlxuICAgICAgICA8cD5Vc2VkIGJ5IFByb3BlcnR5LmNvbXBhcmUoKS5cbiAgICAgICAgSXQgaXMgYSBwcm9wZXJ0eSByYXRoZXIgdGhhbiBhIG1ldGhvZCBzbyB0aGF0IGl0IGNhbiBiZSBjb25maWd1cmVkXG4gICAgICAgIHdpdGhvdXQgc3ViY2xhc3NpbmcuXG4gICAgICAqL1xuICAgICAgJ2NvbXBhcmVQcm9wZXJ0eVZhbHVlcycsXG4gICAgICBmdW5jdGlvbihvMSwgbzIpIHsgcmV0dXJuIGZvYW0udXRpbC5jb21wYXJlKG8xLCBvMik7IH1cbiAgICBdLFxuXG4gICAgW1xuICAgICAgJ2lzRGVmYXVsdFZhbHVlJyxcbiAgICAgIGZ1bmN0aW9uKHYpIHsgcmV0dXJuICEgdGhpcy5jb21wYXJlUHJvcGVydHlWYWx1ZXModGhpcy52YWx1ZSwgdik7IH1cbiAgICBdLFxuXG4gICAge1xuICAgICAgLyoqIE1ha2VzIFByb3BlcnRpZXMgdXNlZnVsIGFzIG1hcCBmdW5jdGlvbnMuICovXG4gICAgICBuYW1lOiAnZicsXG4gICAgICB0cmFuc2llbnQ6IHRydWUsXG4gICAgICBmYWN0b3J5OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIG5hbWUgPSB0aGlzLm5hbWU7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiBmKG8pIHsgcmV0dXJuIG9bbmFtZV07IH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAge1xuICAgICAgLyoqIE1ha2VzIFByb3BlcnRpZXMgdXNlZnVsIGFzIGNvbXBhcmF0b3JzLiAqL1xuICAgICAgbmFtZTogJ2NvbXBhcmUnLFxuICAgICAgdHJhbnNpZW50OiB0cnVlLFxuICAgICAgZmFjdG9yeTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBjb21wYXJlUHJvcGVydHlWYWx1ZXMgPSB0aGlzLmNvbXBhcmVQcm9wZXJ0eVZhbHVlcztcbiAgICAgICAgdmFyIGYgPSB0aGlzLmY7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiBjb21wYXJlKG8xLCBvMikge1xuICAgICAgICAgIHJldHVybiBjb21wYXJlUHJvcGVydHlWYWx1ZXMoZihvMSksIGYobzIpKTtcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9LFxuICAgIC8vIEZVVFVSRTogTW92ZSB0byByZWZpbmVtZW50P1xuICAgIHtcbiAgICAgIG5hbWU6ICdkaWZmUHJvcGVydHlWYWx1ZXMnLFxuICAgICAgdHJhbnNpZW50OiB0cnVlLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uKHYxLCB2MiwgZGlmZikge1xuICAgICAgICAvLyBUT0RPOiBpbnN0ZWFkIG9mIGFycmF5IGNoZWNrLCBoYXZlIGRpZmZlcmVudCBpbXBsZW1lbnRhdGlvbiBpbiBBcnJheVByb3BlcnR5XG4gICAgICAgIGlmICggQXJyYXkuaXNBcnJheSh2MSkgKSB7XG4gICAgICAgICAgdmFyIHN1YmRpZmYgPSBmb2FtLkFycmF5LmRpZmYodjEsIHYyKTtcbiAgICAgICAgICBpZiAoIHN1YmRpZmYuYWRkZWQubGVuZ3RoICE9PSAwIHx8IHN1YmRpZmYucmVtb3ZlZC5sZW5ndGggIT09IDAgKSB7XG4gICAgICAgICAgICBkaWZmW3RoaXMubmFtZV0gPSBzdWJkaWZmO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICggISBmb2FtLnV0aWwuZXF1YWxzKHYxLCB2MikgKSB7XG4gICAgICAgICAgLy8gaWYgdGhlIHByaW1hcnkgdmFsdWUgaXMgdW5kZWZpbmVkLCB1c2UgdGhlIGNvbXBhcmVUbyBvZiB0aGUgb3RoZXJcbiAgICAgICAgICBkaWZmW3RoaXMubmFtZV0gPSB2MjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGlmZjtcbiAgICAgIH1cbiAgICB9LFxuICAgIHtcbiAgICAgIG5hbWU6ICdkaWZmUHJvcGVydHknLFxuICAgICAgdHJhbnNpZW50OiB0cnVlLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGRpZmZQcm9wZXJ0eShvMSwgbzIsIGRpZmYsIHByb3ApIHtcbiAgICAgICAgcmV0dXJuIHByb3AuZGlmZlByb3BlcnR5VmFsdWVzKHByb3AuZihvMSksIHByb3AuZihvMiksIGRpZmYpO1xuICAgICAgfVxuICAgIH0sXG4gICAge1xuICAgICAgbmFtZTogJ2ZvckNsYXNzXycsXG4gICAgICB0cmFuc2llbnQ6IHRydWVcbiAgICB9LFxuICBdLFxuXG4gIG1ldGhvZHM6IFtcbiAgICAvKipcbiAgICAgIEhhbmRsZSBvdmVycmlkaW5nIG9mIFByb3BlcnR5IGRlZmluaXRpb24gZnJvbSBwYXJlbnQgY2xhc3MgYnlcbiAgICAgIGNvcHlpbmcgdW5kZWZpbmVkIHZhbHVlcyBmcm9tIHBhcmVudCBQcm9wZXJ0eSwgaWYgaXQgZXhpc3RzLlxuICAgICovXG4gICAgZnVuY3Rpb24gaW5zdGFsbEluQ2xhc3MoYywgc3VwZXJQcm9wLCBleGlzdGluZ1Byb3ApIHtcbiAgICAgIHZhciBwcm9wID0gdGhpcztcblxuICAgICAgaWYgKCBzdXBlclByb3AgJiYgZm9hbS5jb3JlLlByb3BlcnR5LmlzSW5zdGFuY2Uoc3VwZXJQcm9wKSApIHtcbiAgICAgICAgcHJvcCA9IHN1cGVyUHJvcC5jcmVhdGVDaGlsZFByb3BlcnR5Xyhwcm9wKTtcblxuICAgICAgICAvLyBJZiBwcm9wZXJ0aWVzIHdvdWxkIGJlIHNoYWRvd2VkIGJ5IHN1cGVyUHJvcCBwcm9wZXJ0aWVzLCB0aGVuXG4gICAgICAgIC8vIGNsZWFyIHRoZSBzaGFkb3dpbmcgcHJvcGVydHkgc2luY2UgdGhlIG5ldyB2YWx1ZSBzaG91bGRcbiAgICAgICAgLy8gdGFrZSBwcmVjZWRlbmNlIHNpbmNlIGl0IHdhcyBzZXQgbGF0ZXIuXG4gICAgICAgIHZhciBlcyA9IGZvYW0uY29yZS5Qcm9wZXJ0eS5TSEFET1dfTUFQIHx8IHt9O1xuICAgICAgICBmb3IgKCB2YXIga2V5IGluIGVzICkge1xuICAgICAgICAgIHZhciBlID0gZXNba2V5XTtcbiAgICAgICAgICBmb3IgKCB2YXIgaiA9IDAgOyBqIDwgZS5sZW5ndGggOyBqKysgKSB7XG4gICAgICAgICAgICBpZiAoIHRoaXMuaGFzT3duUHJvcGVydHkoZVtqXSkgJiYgc3VwZXJQcm9wW2tleV0gKSB7XG4gICAgICAgICAgICAgIHByb3AuY2xlYXJQcm9wZXJ0eShrZXkpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBjLmF4aW9tTWFwX1twcm9wLm5hbWVdID0gcHJvcDtcbiAgICAgIH1cblxuICAgICAgaWYgKCB0aGlzLmZvckNsYXNzXyAmJiB0aGlzLmZvckNsYXNzXyAhPT0gYy5pZCAmJiBwcm9wID09PSB0aGlzICkge1xuICAgICAgICAvLyBDbG9uZSB0aGlzIHByb3BlcnR5IGlmIGl0J3MgYmVlbiBpbnN0YWxsZWQgYmVmb3JlLlxuICAgICAgICBwcm9wID0gdGhpcy5jbG9uZSgpO1xuICAgICAgICBjLmF4aW9tTWFwX1twcm9wLm5hbWVdID0gcHJvcDtcbiAgICAgIH1cblxuICAgICAgcHJvcC5mb3JDbGFzc18gPSBjLmlkO1xuXG4gICAgICAvLyB2YXIgcmVpbnN0YWxsID0gZm9hbS5ldmVudHMub25lVGltZShmdW5jdGlvbiByZWluc3RhbGwoXyxfLF8sYXhpb20pIHtcbiAgICAgIC8vICAgLy8gV2Ugb25seSBjYXJlIGFib3V0IFByb3BlcnR5IGF4aW9tcy5cblxuICAgICAgLy8gICAvLyBGVVRVUkU6IHdlIHJlYWxseSBvbmx5IGNhcmUgYWJvdXQgdGhvc2UgcHJvcGVydGllcyB0aGF0IGFmZmVjdFxuICAgICAgLy8gICAvLyB0aGUgZGVmaW5pdGlvbiBvZiB0aGUgcHJvcGVydHkgZ2V0dGVyIGFuZCBzZXR0ZXIsIHNvIGFuIGV4dHJhXG4gICAgICAvLyAgIC8vIGNoZWNrIHdvdWxkIGhlbHAgZWxpbWluYXRlIGV4dHJhIHJlaW5zdGFsbHMuXG5cbiAgICAgIC8vICAgLy8gSGFuZGxlIHNwZWNpYWwgY2FzZSBvZiBheGlvbSBiZWluZyBpbnN0YWxsZWQgaW50byBpdHNlbGYuXG4gICAgICAvLyAgIC8vIEZvciBleGFtcGxlIGZvYW0uY29yZS5TdHJpbmcgaGFzIGZvYW0uY29yZS5TdHJpbmcgYXhpb21zIGZvciB0aGluZ3NcbiAgICAgIC8vICAgLy8gbGlrZSBcImxhYmVsXCJcbiAgICAgIC8vICAgLy8gSW4gdGhlIGZ1dHVyZSB0aGlzIHNob3VsZG4ndCBiZSByZXF1aXJlZCBpZiBhIHJlaW5zdGFsbCBpc1xuICAgICAgLy8gICAvLyBvbmx5IHRyaWdnZXJlZCBvbiB0aGlzIHdoaWNoIGFmZmVjdCBnZXR0ZXIvc2V0dGVyLlxuICAgICAgLy8gICBpZiAoIHByb3AuY2xzXyA9PT0gYyApIHtcbiAgICAgIC8vICAgICByZXR1cm47XG4gICAgICAvLyAgIH1cblxuICAgICAgLy8gICBpZiAoIGZvYW0uY29yZS5Qcm9wZXJ0eS5pc0luc3RhbmNlKGF4aW9tKSApIHtcbiAgICAgIC8vICAgICAvLyBjb25zb2xlLmxvZygnKioqKioqKioqKioqKioqKiBVcGRhdGluZyBQcm9wZXJ0eTogJywgYy5uYW1lLCBwcm9wLm5hbWUpO1xuICAgICAgLy8gICAgIGMuaW5zdGFsbEF4aW9tKHByb3ApO1xuICAgICAgLy8gICB9XG4gICAgICAvLyB9KTtcblxuICAgICAgLy8gLy8gSWYgdGhlIHN1cGVyUHJvcCBpcyB1cGRhdGVkLCB0aGVuIHJlaW5zdGFsbCB0aGlzIHByb3BlcnR5XG4gICAgICAvLyBjLl9fcHJvdG9fXy5wdWJzdWJfICYmIGMuX19wcm90b19fLnB1YnN1Yl8uc3ViKFxuICAgICAgLy8gICAnaW5zdGFsbEF4aW9tJyxcbiAgICAgIC8vICAgdGhpcy5uYW1lLFxuICAgICAgLy8gICByZWluc3RhbGxcbiAgICAgIC8vICk7XG5cbiAgICAgIC8vIC8vIElmIHRoZSBjbGFzcyBvZiB0aGlzIFByb3BlcnR5IGNoYW5nZXMsIHRoZW4gYWxzbyByZWluc3RhbGxcbiAgICAgIC8vIGlmIChcbiAgICAgIC8vICAgYy5pZCAhPT0gJ2ZvYW0uY29yZS5Qcm9wZXJ0eScgJiZcbiAgICAgIC8vICAgYy5pZCAhPT0gJ2ZvYW0uY29yZS5Nb2RlbCcgICAgJiZcbiAgICAgIC8vICAgYy5pZCAhPT0gJ2ZvYW0uY29yZS5NZXRob2QnICAgJiZcbiAgICAgIC8vICAgYy5pZCAhPT0gJ2ZvYW0uY29yZS5GT2JqZWN0JyAgJiZcbiAgICAgIC8vICAgdGhpcy5jbHNfLmlkICE9PSAnZm9hbS5jb3JlLkZPYmplY3QnXG4gICAgICAvLyApIHtcbiAgICAgIC8vICAgdGhpcy5jbHNfLnB1YnN1Yl8uc3ViKCdpbnN0YWxsQXhpb20nLCByZWluc3RhbGwpO1xuICAgICAgLy8gfVxuXG4gICAgICBjLmluc3RhbGxDb25zdGFudChwcm9wLm5hbWUsIHByb3ApO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgIEluc3RhbGwgYSBwcm9wZXJ0eSBvbnRvIGEgcHJvdG90eXBlIGZyb20gYSBQcm9wZXJ0eSBkZWZpbml0aW9uLlxuICAgICAgKFByb3BlcnR5IGlzICd0aGlzJykuXG4gICAgKi9cbiAgICBmdW5jdGlvbiBpbnN0YWxsSW5Qcm90byhwcm90bykge1xuICAgICAgLy8gVGFrZSBBeGlvbSBmcm9tIGNsYXNzIHJhdGhlciB0aGFuIHVzaW5nICd0aGlzJyBkaXJlY3RseSxcbiAgICAgIC8vIHNpbmNlIGluc3RhbGxJbkNsYXNzKCkgbWF5IGhhdmUgY3JlYXRlZCBhIG1vZGlmaWVkIHZlcnNpb25cbiAgICAgIC8vIHRvIGluaGVyaXQgUHJvcGVydHkgUHJvcGVydGllcyBmcm9tIGEgc3VwZXItUHJvcGVydHkuXG4gICAgICB2YXIgcHJvcCAgICAgICAgPSBwcm90by5jbHNfLmdldEF4aW9tQnlOYW1lKHRoaXMubmFtZSk7XG4gICAgICB2YXIgbmFtZSAgICAgICAgPSBwcm9wLm5hbWU7XG4gICAgICB2YXIgYWRhcHQgICAgICAgPSBwcm9wLmFkYXB0XG4gICAgICB2YXIgYXNzZXJ0VmFsdWUgPSBwcm9wLmFzc2VydFZhbHVlO1xuICAgICAgdmFyIHByZVNldCAgICAgID0gcHJvcC5wcmVTZXQ7XG4gICAgICB2YXIgcG9zdFNldCAgICAgPSBwcm9wLnBvc3RTZXQ7XG4gICAgICB2YXIgZmFjdG9yeSAgICAgPSBwcm9wLmZhY3Rvcnk7XG4gICAgICB2YXIgZ2V0dGVyICAgICAgPSBwcm9wLmdldHRlcjtcbiAgICAgIHZhciB2YWx1ZSAgICAgICA9IHByb3AudmFsdWU7XG4gICAgICB2YXIgaGFzVmFsdWUgICAgPSB0eXBlb2YgdmFsdWUgIT09ICd1bmRlZmluZWQnO1xuICAgICAgdmFyIHNsb3ROYW1lICAgID0gbmFtZSArICckJztcbiAgICAgIHZhciBpc0ZpbmFsICAgICA9IHByb3AuZmluYWw7XG4gICAgICB2YXIgZUZhY3RvcnkgICAgPSB0aGlzLmV4cHJGYWN0b3J5KHByb3AuZXhwcmVzc2lvbik7XG4gICAgICB2YXIgRklQICAgICAgICAgPSBmYWN0b3J5ICYmICggcHJvcC5uYW1lICsgJ19maXAnICk7IC8vIEZhY3RvcnkgSW4gUHJvZ3Jlc3NcbiAgICAgIHZhciBmaXAgICAgICAgICA9IDA7XG5cbiAgICAgIC8vIEZhY3RvcnkgSW4gUHJvZ3Jlc3MgKEZJUCkgU3VwcG9ydFxuICAgICAgLy8gV2hlbiBhIGZhY3RvcnkgbWV0aG9kIGlzIGluIHByb2dyZXNzLCB0aGUgb2JqZWN0IHNldHMgYSBwcml2YXRlXG4gICAgICAvLyBmbGFnIG5hbWVkIGJ5IHRoZSB2YWx1ZSBpbiBGSVAuXG4gICAgICAvLyBUaGlzIGFsbG93cyBmb3IgdGhlIGRldGVjdGlvbiBhbmQgZWxpbWluYXRpb24gb2ZcbiAgICAgIC8vIGluZmluaXRlIHJlY3Vyc2lvbnMgKGlmIGEgZmFjdG9yeSBhY2Nlc3NlcyBhbm90aGVyIHByb3BlcnR5XG4gICAgICAvLyB3aGljaCBpbiB0dXJuIHRyaWVzIHRvIGFjY2VzcyBpdHMgcHJvcGVyeSkgYW5kIGFsbG93cyBmb3JcbiAgICAgIC8vIHRoZSBwcm9wZXJ0eSBjaGFuZ2UgZXZlbnQgdG8gbm90IGJlIGZpcmVkIHdoZW4gdGhlIHZhbHVlXG4gICAgICAvLyBpcyBmaXJzdCBzZXQgYnkgdGhlIGZhY3RvcnkgKHNpbmNlIHRoZSB2YWx1ZSBkaWRuJ3QgY2hhbmdlLFxuICAgICAgLy8gdGhlIGZhY3RvcnkgaXMgcHJvdmlkaW5nIGl0cyBvcmlnaW5hbCB2YWx1ZSkuXG4gICAgICAvLyBIb3dldmVyLCB0aGlzIGlzIGV4cGVuc2l2ZSwgc28gd2Uga2VlcCBhIGdsb2JhbCAnZmlwJyB2YXJpYWJsZVxuICAgICAgLy8gd2hpY2ggaW5kaWNhdGVzIHRoYXQgdGhlIGZhY3RvcnkgaXMgYWxyZWFkeSBiZWluZyBjYWxsZWQgb24gYW55XG4gICAgICAvLyBvYmplY3QgYW5kIHRoZW4gd2Ugb25seSB0cmFjayBvbiBhIHBlci1pbnN0YW5jZSBiYXNpcyB3aGVuIHRoaXNcbiAgICAgIC8vIGlzIG9uLiBUaGlzIGVsaW1pbmF0ZXMgYWxtb3N0IGFsbCBwZXItaW5zdGFuY2UgRklQIGNoZWNrcy5cblxuICAgICAgLy8gUHJvcGVydHkgU2xvdFxuICAgICAgLy8gVGhpcyBjb3N0cyB1cyBhYm91dCA0JSBvZiBvdXIgYm9vdCB0aW1lLlxuICAgICAgLy8gSWYgbm90IGluIGRlYnVnIG1vZGUgd2Ugc2hvdWxkIHNoYXJlIGltcGxlbWVudGF0aW9ucyBsaWtlIGluIEYxLlxuICAgICAgLy9cbiAgICAgIC8vIERlZmluZSBhIFByb3BlcnR5U2xvdCBhY2Nlc3NvciAoc2VlIFNsb3QuanMpIGZvciB0aGlzIFByb3BlcnR5LlxuICAgICAgLy8gSWYgdGhlIHByb3BlcnR5IGlzIG5hbWVkICduYW1lJyB0aGVuICduYW1lJCcgd2lsbCBhY2Nlc3MgYSBTbG90XG4gICAgICAvLyBmb3IgdGhpcyBQcm9wZXJ0eS4gVGhlIFNsb3QgaXMgY3JlYXRlZCB3aGVuIGZpcnN0IGFjY2Vzc2VkIGFuZCB0aGVuXG4gICAgICAvLyBjYWNoZWQuXG4gICAgICAvLyBJZiB0aGUgU2xvdCBpcyBzZXQgKHRvIGFub3RoZXIgc2xvdCkgdGhlIHR3byBTbG90cyBhcmUgbGluaygpJ2VkXG4gICAgICAvLyB0b2dldGhlciwgbWVhbmluZyB0aGV5IHdpbGwgbm93IGR5bmFtaWNhbGx5IHNoYXJlIHRoZSBzYW1lIHZhbHVlLlxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb3RvLCBzbG90TmFtZSwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uIHByb3BlcnR5U2xvdEdldHRlcigpIHtcbiAgICAgICAgICByZXR1cm4gcHJvcC50b1Nsb3QodGhpcyk7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gcHJvcGVydHlTbG90U2V0dGVyKHNsb3QyKSB7XG4gICAgICAgICAgcHJvcC50b1Nsb3QodGhpcykubGlua0Zyb20oc2xvdDIpO1xuICAgICAgICB9LFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlXG4gICAgICB9KTtcblxuICAgICAgLy8gRGVmaW5lIFByb3BlcnR5IGdldHRlciBhbmQgc2V0dGVyIGJhc2VkIG9uIFByb3BlcnR5IHByb3BlcnRpZXMuXG4gICAgICAvLyBCeSBkZWZhdWx0LCBnZXR0ZXIgYW5kIHNldHRlciBzdG9yZXMgaW5zdGFuY2UgdmFsdWUgZm9yIHByb3BlcnR5XG4gICAgICAvLyBpbiB0aGlzLmluc3RhbmNlX1s8bmFtZSBvZiBwcm9wZXJ0eT5dLFxuICAgICAgLy8gdW5sZXNzIHRoZSB1c2VyIHByb3ZpZGVzIGN1c3RvbSBnZXR0ZXIgYW5kIHNldHRlciBtZXRob2RzLlxuXG4gICAgICAvLyBHZXR0ZXJcbiAgICAgIC8vIENhbGwgJ2dldHRlcicgaWYgcHJvdmlkZWQsIGVsc2UgcmV0dXJuIHZhbHVlIGZyb20gaW5zdGFuY2VfIGlmIHNldC5cbiAgICAgIC8vIElmIG5vdCBzZXQsIHJldHVybiB2YWx1ZSBmcm9tICdmYWN0b3J5JywgJ2V4cHJlc3Npb24nLCBvclxuICAgICAgLy8gKGRlZmF1bHQpICd2YWx1ZScsIGlmIHByb3ZpZGVkLlxuICAgICAgdmFyIGdldCA9XG4gICAgICAgIGdldHRlciA/IGZ1bmN0aW9uKCkgeyByZXR1cm4gZ2V0dGVyLmNhbGwodGhpcywgcHJvcCk7IH0gOlxuICAgICAgICBmYWN0b3J5ID8gZnVuY3Rpb24gZmFjdG9yeUdldHRlcigpIHtcbiAgICAgICAgICB2YXIgdiA9IHRoaXMuaW5zdGFuY2VfW25hbWVdO1xuICAgICAgICAgIGlmICggdiAhPT0gdW5kZWZpbmVkICkgcmV0dXJuIHY7XG4gICAgICAgICAgLy8gSW5kaWNhdGUgdGhlIEZhY3RvcnkgSW4gUHJvZ3Jlc3Mgc3RhdGVcbiAgICAgICAgICBpZiAoIGZpcCA+IDEwICYmIHRoaXMuZ2V0UHJpdmF0ZV8oRklQKSApIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybigncmVlbnRyYW50IGZhY3RvcnkgZm9yIHByb3BlcnR5OicsIG5hbWUpO1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgb2xkRmlwID0gZmlwO1xuICAgICAgICAgIGZpcCsrO1xuICAgICAgICAgIGlmICggb2xkRmlwID09PSAxMCApIHRoaXMuc2V0UHJpdmF0ZV8oRklQLCB0cnVlKTtcbiAgICAgICAgICB2ID0gZmFjdG9yeS5jYWxsKHRoaXMsIHByb3ApO1xuICAgICAgICAgIC8vIENvbnZlcnQgdW5kZWZpbmVkIHRvIG51bGwgYmVjYXVzZSB1bmRlZmluZWQgbWVhbnMgdGhhdCB0aGVcbiAgICAgICAgICAvLyB2YWx1ZSBoYXNuJ3QgYmVlbiBzZXQgYnV0IGl0IGhhcy4gU2V0dGluZyBpdCB0byB1bmRlZmluZWRcbiAgICAgICAgICAvLyB3b3VsZCBwcmV2ZW50IHByb3BlcnR5Q2hhbmdlIGV2ZW50cyBpZiB0aGUgdmFsdWUgd2VyZSBjbGVhcmVkLlxuICAgICAgICAgIHRoaXNbbmFtZV0gPSB2ID09PSB1bmRlZmluZWQgPyBudWxsIDogdjtcbiAgICAgICAgICBpZiAoIG9sZEZpcCA9PT0gMTAgKSB0aGlzLmNsZWFyUHJpdmF0ZV8oRklQKTtcbiAgICAgICAgICBmaXAtLTtcblxuICAgICAgICAgIHJldHVybiB0aGlzLmluc3RhbmNlX1tuYW1lXTtcbiAgICAgICAgfSA6XG4gICAgICAgIGVGYWN0b3J5ID8gZnVuY3Rpb24gZUZhY3RvcnlHZXR0ZXIoKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuaGFzT3duUHJvcGVydHkobmFtZSkgPyB0aGlzLmluc3RhbmNlX1tuYW1lXSAgIDpcbiAgICAgICAgICAgICAgICAgdGhpcy5oYXNPd25Qcml2YXRlXyhuYW1lKSA/IHRoaXMuZ2V0UHJpdmF0ZV8obmFtZSkgOlxuICAgICAgICAgICAgICAgICB0aGlzLnNldFByaXZhdGVfKG5hbWUsIGVGYWN0b3J5LmNhbGwodGhpcykpIDtcbiAgICAgICAgfSA6XG4gICAgICAgIGhhc1ZhbHVlID8gZnVuY3Rpb24gdmFsdWVHZXR0ZXIoKSB7XG4gICAgICAgICAgdmFyIHYgPSB0aGlzLmluc3RhbmNlX1tuYW1lXTtcbiAgICAgICAgICByZXR1cm4gdiAhPT0gdW5kZWZpbmVkID8gdiA6IHZhbHVlIDtcbiAgICAgICAgfSA6XG4gICAgICAgIGZ1bmN0aW9uIHNpbXBsZUdldHRlcigpIHsgcmV0dXJuIHRoaXMuaW5zdGFuY2VfW25hbWVdOyB9O1xuXG4gICAgICB2YXIgc2V0ID0gcHJvcC5zZXR0ZXIgPyBwcm9wLnNldHRlciA6XG4gICAgICAgICEgKCBwb3N0U2V0IHx8IGZhY3RvcnkgfHwgZUZhY3RvcnkgfHwgYWRhcHQgfHwgYXNzZXJ0VmFsdWUgfHwgcHJlU2V0IHx8IGlzRmluYWwgKSA/XG4gICAgICAgIGZ1bmN0aW9uIHNpbXBsZVByb3BTZXR0ZXIobmV3VmFsdWUpIHtcbiAgICAgICAgICBpZiAoIG5ld1ZhbHVlID09PSB1bmRlZmluZWQgKSB7XG4gICAgICAgICAgICB0aGlzLmNsZWFyUHJvcGVydHkobmFtZSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIG9sZFZhbHVlID0gdGhpcy5pbnN0YW5jZV9bbmFtZV0gO1xuICAgICAgICAgIHRoaXMuaW5zdGFuY2VfW25hbWVdID0gbmV3VmFsdWU7XG4gICAgICAgICAgdGhpcy5wdWJQcm9wZXJ0eUNoYW5nZV8ocHJvcCwgb2xkVmFsdWUsIG5ld1ZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICA6IGZhY3RvcnkgJiYgISAoIHBvc3RTZXQgfHwgZUZhY3RvcnkgfHwgYWRhcHQgfHwgYXNzZXJ0VmFsdWUgfHwgcHJlU2V0IHx8IGlzRmluYWwgKSA/XG4gICAgICAgIGZ1bmN0aW9uIGZhY3RvcnlQcm9wU2V0dGVyKG5ld1ZhbHVlKSB7XG4gICAgICAgICAgaWYgKCBuZXdWYWx1ZSA9PT0gdW5kZWZpbmVkICkge1xuICAgICAgICAgICAgdGhpcy5jbGVhclByb3BlcnR5KG5hbWUpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBvbGRWYWx1ZSA9IHRoaXMuaGFzT3duUHJvcGVydHkobmFtZSkgPyB0aGlzW25hbWVdIDogdW5kZWZpbmVkO1xuXG4gICAgICAgICAgdGhpcy5pbnN0YW5jZV9bbmFtZV0gPSBuZXdWYWx1ZTtcblxuICAgICAgICAgIC8vIElmIHRoaXMgaXMgdGhlIHJlc3VsdCBvZiBhIGZhY3Rvcnkgc2V0dGluZyB0aGUgaW5pdGlhbCB2YWx1ZSxcbiAgICAgICAgICAvLyB0aGVuIGRvbid0IGZpcmUgYSBwcm9wZXJ0eSBjaGFuZ2UgZXZlbnQsIHNpbmNlIGl0IGhhc24ndFxuICAgICAgICAgIC8vIHJlYWxseSBjaGFuZ2VkLlxuICAgICAgICAgIGlmICggb2xkVmFsdWUgIT09IHVuZGVmaW5lZCApXG4gICAgICAgICAgICB0aGlzLnB1YlByb3BlcnR5Q2hhbmdlXyhwcm9wLCBvbGRWYWx1ZSwgbmV3VmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIDpcbiAgICAgICAgZnVuY3Rpb24gcHJvcFNldHRlcihuZXdWYWx1ZSkge1xuICAgICAgICAgIC8vID8/PzogU2hvdWxkIGNsZWFyUHJvcGVydHkoKSBjYWxsIHNldCh1bmRlZmluZWQpP1xuICAgICAgICAgIGlmICggbmV3VmFsdWUgPT09IHVuZGVmaW5lZCApIHtcbiAgICAgICAgICAgIHRoaXMuY2xlYXJQcm9wZXJ0eShuYW1lKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBHZXR0aW5nIHRoZSBvbGQgdmFsdWUgYnV0IGF2b2lkIHRyaWdnZXJpbmcgZmFjdG9yeSBvciBleHByZXNzaW9uIGlmXG4gICAgICAgICAgLy8gcHJlc2VudC4gRmFjdG9yaWVzIGFuZCBleHByZXNzaW9ucyAod2hpY2ggYXJlIGFsc28gZmFjdG9yaWVzKSBjYW4gYmVcbiAgICAgICAgICAvLyBleHBlbnNpdmUgdG8gZ2VuZXJhdGUsIGFuZCBpZiB0aGUgdmFsdWUgaGFzIGJlZW4gZXhwbGljaXRseSBzZXQgdG9cbiAgICAgICAgICAvLyBzb21lIHZhbHVlLCB0aGVuIGl0IGlzbid0IHdvcnRoIHRoZSBleHBlbnNlIG9mIGNvbXB1dGluZyB0aGUgb2xkXG4gICAgICAgICAgLy8gc3RhbGUgdmFsdWUuXG4gICAgICAgICAgdmFyIG9sZFZhbHVlID1cbiAgICAgICAgICAgIGZhY3RvcnkgID8gKCB0aGlzLmhhc093blByb3BlcnR5KG5hbWUpID8gdGhpc1tuYW1lXSA6IHVuZGVmaW5lZCApIDpcbiAgICAgICAgICAgIGVGYWN0b3J5ID9cbiAgICAgICAgICAgICAgICAoIHRoaXMuaGFzT3duUHJpdmF0ZV8obmFtZSkgfHwgdGhpcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSA/XG4gICAgICAgICAgICAgICAgICB0aGlzW25hbWVdIDpcbiAgICAgICAgICAgICAgICAgIHVuZGVmaW5lZCApIDpcbiAgICAgICAgICAgIHRoaXNbbmFtZV0gO1xuXG4gICAgICAgICAgaWYgKCBhZGFwdCApIG5ld1ZhbHVlID0gYWRhcHQuY2FsbCh0aGlzLCBvbGRWYWx1ZSwgbmV3VmFsdWUsIHByb3ApO1xuXG4gICAgICAgICAgaWYgKCBhc3NlcnRWYWx1ZSApIGFzc2VydFZhbHVlLmNhbGwodGhpcywgbmV3VmFsdWUsIHByb3ApO1xuXG4gICAgICAgICAgaWYgKCBwcmVTZXQgKSBuZXdWYWx1ZSA9IHByZVNldC5jYWxsKHRoaXMsIG9sZFZhbHVlLCBuZXdWYWx1ZSwgcHJvcCk7XG5cbiAgICAgICAgICAvLyA/Pz86IFNob3VsZCBuZXdWYWx1ZSA9PT0gdW5kZWZpbmVkIGNoZWNrIGdvIGhlcmUgaW5zdGVhZD9cblxuICAgICAgICAgIHRoaXMuaW5zdGFuY2VfW25hbWVdID0gbmV3VmFsdWU7XG5cbiAgICAgICAgICBpZiAoIGlzRmluYWwgKSB7XG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgbmFtZSwge1xuICAgICAgICAgICAgICB2YWx1ZTogbmV3VmFsdWUsXG4gICAgICAgICAgICAgIHdyaXRhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlIC8vID8/PzogaXMgdGhpcyBuZWVkZWQ/XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBJZiB0aGlzIGlzIHRoZSByZXN1bHQgb2YgYSBmYWN0b3J5IHNldHRpbmcgdGhlIGluaXRpYWwgdmFsdWUsXG4gICAgICAgICAgLy8gdGhlbiBkb24ndCBmaXJlIGEgcHJvcGVydHkgY2hhbmdlIGV2ZW50LCBzaW5jZSBpdCBoYXNuJ3RcbiAgICAgICAgICAvLyByZWFsbHkgY2hhbmdlZC5cbiAgICAgICAgICBpZiAoICEgZmFjdG9yeSB8fCBvbGRWYWx1ZSAhPT0gdW5kZWZpbmVkIClcbiAgICAgICAgICAgIHRoaXMucHViUHJvcGVydHlDaGFuZ2VfKHByb3AsIG9sZFZhbHVlLCBuZXdWYWx1ZSk7XG5cbiAgICAgICAgICAvLyBGVVRVUkU6IHB1YiB0byBhIGdsb2JhbCB0b3BpYyB0byBzdXBwb3J0IGR5bmFtaWMoKVxuXG4gICAgICAgICAgaWYgKCBwb3N0U2V0ICkgcG9zdFNldC5jYWxsKHRoaXMsIG9sZFZhbHVlLCBuZXdWYWx1ZSwgcHJvcCk7XG4gICAgICAgIH07XG5cbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm90bywgbmFtZSwge1xuICAgICAgICBnZXQ6IGdldCxcbiAgICAgICAgc2V0OiBzZXQsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8qKiBWYWxpZGF0ZSBhbiBvYmplY3Qgd2hpY2ggaGFzIHRoaXMgUHJvcGVydHkuICovXG4gICAgZnVuY3Rpb24gdmFsaWRhdGVJbnN0YW5jZShvKSB7XG4gICAgICBpZiAoIHRoaXMucmVxdWlyZWQgJiYgISBvW3RoaXMubmFtZV0gKSB7XG4gICAgICAgIHRocm93ICdSZXF1aXJlZCBwcm9wZXJ0eSAnICtcbiAgICAgICAgICAgIG8uY2xzXy5pZCArICcuJyArIHRoaXMubmFtZSArXG4gICAgICAgICAgICAnIG5vdCBkZWZpbmVkLic7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIGZhY3RvcnkgZnVuY3Rpb24gZnJvbSBhbiBleHByZXNzaW9uIGZ1bmN0aW9uLlxuICAgICAqIEZ1bmN0aW9uIGFyZ3VtZW50cyBhcmUgdmFsaWRhdGVkIGluIGRlYnVnLmpzLlxuICAgICAqKi9cbiAgICBmdW5jdGlvbiBleHByRmFjdG9yeShlKSB7XG4gICAgICBpZiAoICEgZSApIHJldHVybiBudWxsO1xuXG4gICAgICB2YXIgYXJnTmFtZXMgPSBmb2FtLkZ1bmN0aW9uLmFyZ05hbWVzKGUpO1xuICAgICAgdmFyIG5hbWUgICAgID0gdGhpcy5uYW1lO1xuXG4gICAgICAvLyBGVVRVUkU6IGRldGVybWluZSBob3cgb2Z0ZW4gdGhlIHZhbHVlIGlzIGJlaW5nIGludmFsaWRhdGVkLFxuICAgICAgLy8gYW5kIGlmIGl0J3MgaGFwcGVuaW5nIG9mdGVuLCB0aGVuIGRvbid0IHVuc3Vic2NyaWJlLlxuICAgICAgcmV0dXJuIGZ1bmN0aW9uIGV4cG9ydGVkRmFjdG9yeSgpIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmdOYW1lcy5sZW5ndGgpO1xuICAgICAgICB2YXIgc3VicyA9IFtdO1xuICAgICAgICB2YXIgbCAgICA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGlmICggISBzZWxmLmhhc093blByb3BlcnR5KG5hbWUpICkge1xuICAgICAgICAgICAgdmFyIG9sZFZhbHVlID0gc2VsZltuYW1lXTtcbiAgICAgICAgICAgIHNlbGYuY2xlYXJQcml2YXRlXyhuYW1lKTtcblxuICAgICAgICAgICAgLy8gQXZvaWQgY3JlYXRpbmcgc2xvdCBhbmQgcHVibGlzaGluZyBldmVudCBpZiBubyBsaXN0ZW5lcnNcbiAgICAgICAgICAgIGlmICggc2VsZi5oYXNMaXN0ZW5lcnMoJ3Byb3BlcnR5Q2hhbmdlJywgbmFtZSkgKSB7XG4gICAgICAgICAgICAgIHNlbGYucHViKCdwcm9wZXJ0eUNoYW5nZScsIG5hbWUsIHNlbGYuc2xvdChuYW1lKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGZvciAoIHZhciBpID0gMCA7IGkgPCBzdWJzLmxlbmd0aCA7IGkrKyApIHN1YnNbaV0uZGV0YWNoKCk7XG4gICAgICAgIH07XG4gICAgICAgIGZvciAoIHZhciBpID0gMCA7IGkgPCBhcmdOYW1lcy5sZW5ndGggOyBpKysgKSB7XG4gICAgICAgICAgdmFyIHNsb3QgPSB0aGlzLnNsb3QoYXJnTmFtZXNbaV0pO1xuICAgICAgICAgIC8vIFRoaXMgY2hlY2sgd2FzIGludHJvZHVjZWQgdG8gaGFuZGxlIG9wdGlvbmFsIGltcG9ydHMgbm90IGhhdmluZyBhXG4gICAgICAgICAgLy8gc2xvdCB3aGVuIHRoZSBpbXBvcnQgaXNuJ3QgZm91bmQgaW4gdGhlIGNvbnRleHQuXG4gICAgICAgICAgaWYgKHNsb3QpIHtcbiAgICAgICAgICAgIHZhciBzID0gc2xvdC5zdWIobCk7XG4gICAgICAgICAgICBzICYmIHN1YnMucHVzaChzKTtcbiAgICAgICAgICAgIGFyZ3NbaV0gPSBzbG90LmdldCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YXIgcmV0ID0gZS5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgICAgaWYgKCByZXQgPT09IHVuZGVmaW5lZCApIHRoaXMud2FybignRXhwcmVzc2lvbiByZXR1cm5lZCB1bmRlZmluZWQ6ICcsIGUpO1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgfTtcbiAgICB9LFxuXG4gICAgLyoqIFJldHVybnMgYSBkZXZlbG9wZXItcmVhZGFibGUgZGVzY3JpcHRpb24gb2YgdGhpcyBQcm9wZXJ0eS4gKiovXG4gICAgZnVuY3Rpb24gdG9TdHJpbmcoKSB7IHJldHVybiB0aGlzLm5hbWU7IH0sXG5cbiAgICAvKiogRmx5d2VpZ2h0IGdldHRlciBmb3IgdGhpcyBQcm9wZXJ0eS4gKiovXG4gICAgZnVuY3Rpb24gZ2V0KG8pIHsgcmV0dXJuIG9bdGhpcy5uYW1lXTsgfSxcblxuICAgIC8qKiBGbHl3ZWlnaHQgc2V0dGVyIGZvciB0aGlzIFByb3BlcnR5LiAqKi9cbiAgICBmdW5jdGlvbiBzZXQobywgdmFsdWUpIHtcbiAgICAgIG9bdGhpcy5uYW1lXSA9IHZhbHVlO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEhhbmRsZXMgcHJvcGVydHkgaW5oZXJpdGFuY2UuICBCdWlsZHMgYSBuZXcgdmVyc2lvbiBvZlxuICAgICAqIHRoaXMgcHJvcGVydHkgdG8gYmUgaW5zdGFsbGVkIG9uIGNsYXNzZXMgdGhhdCBpbmhlcml0IGZyb21cbiAgICAgKiB0aGlzIGJ1dCBkZWZpbmUgdGhlaXIgb3duIHByb3BlcnR5IHdpdGggdGhlIHNhbWUgbmFtZSBhcyB0aGlzLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZUNoaWxkUHJvcGVydHlfKGNoaWxkKSB7XG4gICAgICB2YXIgcHJvcCA9IHRoaXMuY2xvbmUoKTtcblxuICAgICAgaWYgKCBjaGlsZC5jbHNfICE9PSBmb2FtLmNvcmUuUHJvcGVydHkgJiZcbiAgICAgICAgICAgY2hpbGQuY2xzXyAhPT0gdGhpcy5jbHNfIClcbiAgICAgIHtcbiAgICAgICAgaWYgKCB0aGlzLmNsc18gIT09IGZvYW0uY29yZS5Qcm9wZXJ0eSApIHtcbiAgICAgICAgICB0aGlzLndhcm4oJ1Vuc3VwcG9ydGVkIGNoYW5nZSBvZiBwcm9wZXJ0eSB0eXBlIGZyb20nLCB0aGlzLmNsc18uaWQsICd0bycsIGNoaWxkLmNsc18uaWQpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGNoaWxkO1xuICAgICAgfVxuXG4gICAgICBwcm9wLnNvdXJjZUNsc18gPSBjaGlsZC5zb3VyY2VDbHNfO1xuXG4gICAgICBmb3IgKCB2YXIga2V5IGluIGNoaWxkLmluc3RhbmNlXyApIHtcbiAgICAgICAgcHJvcC5pbnN0YW5jZV9ba2V5XSA9IGNoaWxkLmluc3RhbmNlX1trZXldO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcHJvcDtcbiAgICB9LFxuXG4gICAgZnVuY3Rpb24gZXhwb3J0QXMob2JqLCBzb3VyY2VQYXRoKSB7XG4gICAgICAvKiogRXhwb3J0IG9iai5uYW1lJCBpbnN0ZWFkIG9mIGp1c3Qgb2JqLm5hbWUuICovXG5cbiAgICAgIHZhciBzbG90ID0gdGhpcy50b1Nsb3Qob2JqKTtcblxuICAgICAgZm9yICggdmFyIGkgPSAwIDsgc291cmNlUGF0aCAmJiBpIDwgc291cmNlUGF0aC5sZW5ndGggOyBpKysgKSB7XG4gICAgICAgIHNsb3QgPSBzbG90LmRvdChzb3VyY2VQYXRoW2ldKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNsb3Q7XG4gICAgfSxcblxuICAgIGZ1bmN0aW9uIHRvU2xvdChvYmopIHtcbiAgICAgIC8qKiBDcmVhdGUgYSBTbG90IGZvciB0aGlzIFByb3BlcnR5LiAqL1xuICAgICAgdmFyIHNsb3ROYW1lID0gdGhpcy5zbG90TmFtZV8gfHwgKCB0aGlzLnNsb3ROYW1lXyA9IHRoaXMubmFtZSArICckJyApO1xuICAgICAgdmFyIHNsb3QgICAgID0gb2JqLmdldFByaXZhdGVfKHNsb3ROYW1lKTtcblxuICAgICAgaWYgKCAhIHNsb3QgKSB7XG4gICAgICAgIHNsb3QgPSBmb2FtLmNvcmUuaW50ZXJuYWwuUHJvcGVydHlTbG90LmNyZWF0ZSgpO1xuICAgICAgICBzbG90Lm9iaiAgPSBvYmo7XG4gICAgICAgIHNsb3QucHJvcCA9IHRoaXM7XG4gICAgICAgIG9iai5zZXRQcml2YXRlXyhzbG90TmFtZSwgc2xvdCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzbG90O1xuICAgIH1cbiAgXVxufSk7XG5cblxuLyoqXG4gIEEgU2ltcGxlIFByb3BlcnR5IHNraXBzIHRoZSByZWd1bGFyIEZPQU0gUHJvcGVydHkgZ2V0dGVyL3NldHRlci9pbnN0YW5jZV9cbiAgbWVjaGFuaXNtLiBJbiBnZXRzIGluc3RhbGxlZCBvbiB0aGUgQ0xBU1MgYXMgYSBQcm9wZXJ0eSBjb25zdGFudCwgYnV0IGlzbid0XG4gIGFkZGVkIHRvIHRoZSBwcm90b3R5cGUgYXQgYWxsLiBGcm9tIHRoaXMgcG9pbnQgb2YgdmlldywgaXQncyBtb3N0bHkganVzdCBmb3JcbiAgZG9jdW1lbnRhdGlvbi4gU2ltcGxlIFByb3BlcnRpZXMgYXJlIHVzZWQgb25seSBpbiBzcGVjaWFsIGNhc2VzIHRvIG1heGltaXplXG4gIHBlcmZvcm1hbmNlIGFuZC9vciBtaW5pbWl6ZSBtZW1vcnkgdXNlLlxuICBVc2VkIGZvciBNREFPIGluZGljZXMgYW5kIFNsb3RzLlxuXG4gIFVTRSBXSVRIIEVYVFJFTUUgQ0FVVElPTiAoT1IgTk9UIEFUIEFMTCkuXG4qL1xuZm9hbS5DTEFTUyh7XG4gIHBhY2thZ2U6ICdmb2FtLmNvcmUnLFxuICBuYW1lOiAnU2ltcGxlJyxcbiAgZXh0ZW5kczogJ1Byb3BlcnR5JyxcblxuICBtZXRob2RzOiBbXG4gICAgZnVuY3Rpb24gaW5zdGFsbEluUHJvdG8ocHJvdG8pIHt9XG4gIF1cbn0pO1xuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTYgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuLyoqXG48cD5cbiAgTWV0aG9kcyBhcmUgb25seSBpbnN0YWxsZWQgb24gdGhlIHByb3RvdHlwZS5cbiAgSWYgdGhlIG1ldGhvZCBpcyBvdmVycmlkaW5nIGEgbWV0aG9kIGZyb20gYSBwYXJlbnQgY2xhc3MsXG4gIHRoZW4gU1VQRVIgc3VwcG9ydCBpcyBhZGRlZC5cblxuPHA+XG4gIEV4LlxuPHByZT5cbiAgZm9hbS5DTEFTUyh7XG4gICAgbmFtZTogJ1BhcmVudCcsXG4gICAgbWV0aG9kczogW1xuICAgICAgLy8gc2hvcnQtZm9ybVxuICAgICAgZnVuY3Rpb24gc2F5SGVsbG8oKSB7IGNvbnNvbGUubG9nKCdoZWxsbycpOyB9LFxuXG4gICAgICAvLyBsb25nLWZvcm1cbiAgICAgIHtcbiAgICAgICAgbmFtZTogJ3NheUdvb2RieWUnLFxuICAgICAgICBjb2RlOiBmdW5jdGlvbigpIHsgY29uc29sZS5sb2coJ2dvb2RieWUnKTsgfVxuICAgICAgfVxuICAgIF1cbiAgfSk7XG5cbiAgLy8gQ3JlYXRlIGEgc3ViY2xhc3Mgb2YgUGFyZW50IGFuZCBvdmVycmlkZSB0aGUgJ3NheUhlbGxvJyBtZXRob2QuXG4gIC8vIFRoZSBwYXJlbnQgY2xhc3NlcyAnc2F5SGVsbG8nIG1ldGhvbGQgaXMgY2FsbGVkIHdpdGggJ3RoaXMuU1VQRVIoKSdcbiAgZm9hbS5DTEFTUyh7XG4gICAgbmFtZTogJ0NoaWxkJyxcbiAgICBleHRlbmRzOiAnUGFyZW50JyxcbiAgICBtZXRob2RzOiBbXG4gICAgICBmdW5jdGlvbiBzYXlIZWxsbygpIHsgdGhpcy5TVVBFUigpOyBjb25zb2xlLmxvZygnd29ybGQnKTsgfVxuICAgIF1cbiAgfSk7XG5cbiAgQ2hpbGQuY3JlYXRlKCkuc2F5SGVsbG8oKTtcbiAgPj4gaGVsbG9cbiAgPj4gd29ybGRcbjwvcHJlPlxuKi9cbmZvYW0uQ0xBU1Moe1xuICBwYWNrYWdlOiAnZm9hbS5jb3JlJyxcbiAgbmFtZTogJ0Fic3RyYWN0TWV0aG9kJyxcblxuICBwcm9wZXJ0aWVzOiBbXG4gICAgeyBuYW1lOiAnbmFtZScsIHJlcXVpcmVkOiB0cnVlIH0sXG4gICAgeyBuYW1lOiAnY29kZScsIHJlcXVpcmVkOiBmYWxzZSB9LFxuICAgICdkb2N1bWVudGF0aW9uJyxcbiAgICAncmV0dXJucycsXG4gICAge1xuICAgICAgbmFtZTogJ2FyZ3MnLFxuICAgICAgZmFjdG9yeTogZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLmNvZGUgPyBmb2FtLkZ1bmN0aW9uLmFyZ3ModGhpcy5jb2RlKSA6IFtdOyB9XG4gICAgfVxuICBdLFxuXG4gIG1ldGhvZHM6IFtcbiAgICAvKipcbiAgICAgIERlY29yYXRlIGEgbWV0aG9kIHNvIHRoYXQgaXQgY2FuIGNhbGwgdGhlXG4gICAgICBtZXRob2QgaXQgb3ZlcnJpZGVzIHdpdGggdGhpcy5TVVBFUigpLlxuICAgICovXG4gICAgZnVuY3Rpb24gb3ZlcnJpZGVfKHByb3RvLCBtZXRob2QsIHN1cGVyTWV0aG9kKSB7XG4gICAgICBpZiAoICEgbWV0aG9kICkgcmV0dXJuO1xuXG4gICAgICAvLyBOb3QgdXNpbmcgU1VQRVIsIHNvIGp1c3QgcmV0dXJuIG9yaWdpbmFsIG1ldGhvZFxuICAgICAgaWYgKCBtZXRob2QudG9TdHJpbmcoKS5pbmRleE9mKCdTVVBFUicpID09IC0xICkgcmV0dXJuIG1ldGhvZDtcblxuICAgICAgdmFyIHN1cGVyTWV0aG9kXyA9IHByb3RvLmNsc18uZ2V0U3VwZXJBeGlvbUJ5TmFtZSh0aGlzLm5hbWUpO1xuICAgICAgdmFyIHN1cGVyXztcblxuICAgICAgaWYgKCAhIHN1cGVyTWV0aG9kXyApIHtcbiAgICAgICAgdmFyIG5hbWUgPSB0aGlzLm5hbWU7XG5cbiAgICAgICAgLy8gVGhpcyBtZXRob2QgaXRzZWxmIHByb3ZpZGVzIGEgZmFsc2UtcG9zaXN0aXZlIGJlY2F1c2VcbiAgICAgICAgLy8gaXQgcmVmZXJlbmNlcyBTVVBFUigpLCBzbyBpZ25vcmUuXG4gICAgICAgIGlmICggbmFtZSAhPT0gJ292ZXJyaWRlXycgKSB7XG4gICAgICAgICAgc3VwZXJfID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICAgICAgICAgJ0F0dGVtcHRlZCB0byB1c2UgU1VQRVIoKSBpbicsXG4gICAgICAgICAgICAgICAgbmFtZSwgJ29uJywgcHJvdG8uY2xzXy5pZCwgJ2J1dCBubyBwYXJlbnQgbWV0aG9kIGV4aXN0cy4nKTtcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgLy8gR2VuZXJhdGUgd2FybmluZyBub3cuXG4gICAgICAgICAgc3VwZXJfKCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZvYW0uYXNzZXJ0KGZvYW0uY29yZS5BYnN0cmFjdE1ldGhvZC5pc0luc3RhbmNlKHN1cGVyTWV0aG9kXyksXG4gICAgICAgICAgJ0F0dGVtcHQgdG8gb3ZlcnJpZGUgbm9uLW1ldGhvZCcsIHRoaXMubmFtZSwgJ29uJywgcHJvdG8uY2xzXy5pZCk7XG5cbiAgICAgICAgLy8gRmV0Y2ggdGhlIHN1cGVyIG1ldGhvZCBmcm9tIHRoZSBwcm90bywgYXMgdGhlIHN1cGVyIG1ldGhvZCBheGlvbVxuICAgICAgICAvLyBtYXkgaGF2ZSBkZWNvcmF0ZWQgdGhlIGNvZGUgYmVmb3JlIGluc3RhbGxpbmcgaXQuXG4gICAgICAgIHN1cGVyXyA9IHByb3RvLl9fcHJvdG9fX1t0aGlzLm5hbWVdO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBTVVBFUigpIHsgcmV0dXJuIHN1cGVyXy5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9XG5cbiAgICAgIHZhciBmID0gZnVuY3Rpb24gc3VwZXJXcmFwcGVyKCkge1xuICAgICAgICB2YXIgb2xkU3VwZXIgPSB0aGlzLlNVUEVSO1xuICAgICAgICB0aGlzLlNVUEVSID0gU1VQRVI7XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZXR1cm4gbWV0aG9kLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgdGhpcy5TVVBFUiA9IG9sZFN1cGVyO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgIH07XG5cbiAgICAgIGZvYW0uRnVuY3Rpb24uc2V0TmFtZShmLCB0aGlzLm5hbWUpO1xuICAgICAgZi50b1N0cmluZyA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gbWV0aG9kLnRvU3RyaW5nKCk7IH07XG5cbiAgICAgIHJldHVybiBmO1xuICAgIH0sXG5cbiAgICBmdW5jdGlvbiBjcmVhdGVDaGlsZE1ldGhvZF8oY2hpbGQpIHtcbiAgICAgIC8qKlxuICAgICAgICBUZW1wbGF0ZSBtZXRob2QgZm9yIHVzZSBieSBNZXRob2Qgc3ViY2xhc3Nlcy5cbiAgICAgICAgKFVzZWQgYnkgSmF2YVNvdXJjZS4pXG4gICAgICAqL1xuICAgICAgcmV0dXJuIGNoaWxkO1xuICAgIH0sXG5cbiAgICBmdW5jdGlvbiBpbnN0YWxsSW5DbGFzcyhjbHMsIHN1cGVyTWV0aG9kLCBleGlzdGluZ01ldGhvZCkge1xuICAgICAgdmFyIG1ldGhvZCA9IHRoaXM7XG5cbiAgICAgIHZhciBwYXJlbnQgPSBzdXBlck1ldGhvZDtcbiAgICAgIGlmICggcGFyZW50ICYmIGZvYW0uY29yZS5BYnN0cmFjdE1ldGhvZC5pc0luc3RhbmNlKHBhcmVudCkgKSB7XG4gICAgICAgIG1ldGhvZCA9IHBhcmVudC5jcmVhdGVDaGlsZE1ldGhvZF8obWV0aG9kKTtcbiAgICAgIH1cblxuICAgICAgY2xzLmF4aW9tTWFwX1ttZXRob2QubmFtZV0gPSBtZXRob2Q7XG4gICAgfVxuICBdXG59KTtcblxuXG5mb2FtLkNMQVNTKHtcbiAgcGFja2FnZTogJ2ZvYW0uY29yZScsXG4gIG5hbWU6ICdNZXRob2QnLFxuICBleHRlbmRzOiAnZm9hbS5jb3JlLkFic3RyYWN0TWV0aG9kJyxcblxuICBtZXRob2RzOiBbXG4gICAgZnVuY3Rpb24gaW5zdGFsbEluUHJvdG8ocHJvdG8sIHN1cGVyQXhpb20pIHtcbiAgICAgIHByb3RvW3RoaXMubmFtZV0gPSB0aGlzLm92ZXJyaWRlXyhwcm90bywgdGhpcy5jb2RlLCBzdXBlckF4aW9tKTtcbiAgICB9LFxuXG4gICAgZnVuY3Rpb24gZXhwb3J0QXMob2JqKSB7XG4gICAgICB2YXIgbSA9IG9ialt0aGlzLm5hbWVdO1xuICAgICAgLyoqIEJpbmQgdGhlIG1ldGhvZCB0byAndGhpcycgd2hlbiBleHBvcnRlZCBzbyB0aGF0IGl0IHN0aWxsIHdvcmtzLiAqKi9cbiAgICAgIHJldHVybiBmdW5jdGlvbiBleHBvcnRlZE1ldGhvZCgpIHsgcmV0dXJuIG0uYXBwbHkob2JqLCBhcmd1bWVudHMpOyB9O1xuICAgIH1cbiAgXVxufSk7XG5cblxuZm9hbS5ib290LnBoYXNlMigpO1xuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTYgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuZm9hbS5DTEFTUyh7XG4gIHBhY2thZ2U6ICdmb2FtLmNvcmUnLFxuICBuYW1lOiAnQm9vbGVhbicsXG4gIGV4dGVuZHM6ICdQcm9wZXJ0eScsXG5cbiAgZG9jdW1lbnRhdGlvbjogJ0EgUHJvcGVydHkgZm9yIEJvb2xlYW4gdmFsdWVzLicsXG5cbiAgcHJvcGVydGllczogW1xuICAgIFsgJ3ZhbHVlJywgZmFsc2UgXSxcbiAgICBbICdhZGFwdCcsIGZ1bmN0aW9uIGFkYXB0Qm9vbGVhbihfLCB2KSB7IHJldHVybiAhIXY7IH0gXVxuICBdXG59KTtcbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmZvYW0uQ0xBU1Moe1xuICBwYWNrYWdlOiAnZm9hbS5jb3JlJyxcbiAgbmFtZTogJ0F4aW9tQXJyYXknLFxuICBleHRlbmRzOiAnUHJvcGVydHknLFxuXG4gIGRvY3VtZW50YXRpb246ICdBbiBBcnJheSBvZiBBeGlvbXMgKHVzZWQgYnkgTW9kZWwpIHdob3NlIGVsZW1lbnRzIGFyZSBhZGRlZCB0byB0aGlzLmF4aW9tc18uJyxcblxuICBwcm9wZXJ0aWVzOiBbXG4gICAge1xuICAgICAgbmFtZTogJ29mJyxcbiAgICAgIHJlcXVpcmVkOiB0cnVlXG4gICAgfSxcbiAgICB7XG4gICAgICBuYW1lOiAnYWRhcHQnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uKF8sIGEsIHByb3ApIHtcbiAgICAgICAgaWYgKCAhIEFycmF5LmlzQXJyYXkoYSkgKSByZXR1cm4gYTtcblxuICAgICAgICB2YXIgY29weTtcbiAgICAgICAgZm9yICggdmFyIGkgPSAwIDsgaSA8IGEubGVuZ3RoIDsgaSsrICkge1xuICAgICAgICAgIHZhciBiID0gcHJvcC5hZGFwdEFycmF5RWxlbWVudC5jYWxsKHRoaXMsIGFbaV0sIHByb3ApO1xuICAgICAgICAgIGlmICggYiAhPT0gYVtpXSApIHtcbiAgICAgICAgICAgIGlmICggISBjb3B5ICkgY29weSA9IGEuc2xpY2UoKTtcbiAgICAgICAgICAgIGNvcHlbaV0gPSBiO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBjb3B5IHx8IGE7XG4gICAgICB9XG4gICAgfSxcbiAgICB7XG4gICAgICBuYW1lOiAnYXNzZXJ0VmFsdWUnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uKHYsIHByb3ApIHtcbiAgICAgICAgZm9hbS5hc3NlcnQoQXJyYXkuaXNBcnJheSh2KSxcbiAgICAgICAgICAgICdUcmllZCB0byBzZXQnLCBwcm9wLm5hbWUsICd0byBub24gYXJyYXkgdmFsdWUnKTtcblxuICAgICAgICB2YXIgb2YgPSB0aGlzLmxvb2t1cChwcm9wLm9mLCB0cnVlKTtcbiAgICAgICAgZm9hbS5hc3NlcnQoXG4gICAgICAgICAgICBvZixcbiAgICAgICAgICAgICdVbmtub3duIFwib2ZcIiBNb2RlbCBpbiBBeGlvbUFycmF5OiBwcm9wZXJ0eT0nLFxuICAgICAgICAgICAgcHJvcC5uYW1lLFxuICAgICAgICAgICAgJyBvZj0nLFxuICAgICAgICAgICAgcHJvcC5vZik7XG4gICAgICAgIGZvciAoIHZhciBpID0gMCA7IGkgPCB2Lmxlbmd0aCA7IGkrKyApIHtcbiAgICAgICAgICBmb2FtLmFzc2VydChvZi5pc0luc3RhbmNlKHZbaV0pLFxuICAgICAgICAgICAgICAnRWxlbWVudCcsIGksICdvZicsIHByb3AubmFtZSwgJ2lzIG5vdCBhbiBpbnN0YW5jZSBvZicsXG4gICAgICAgICAgICAgIHByb3Aub2YpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICB7XG4gICAgICBuYW1lOiAnYWRhcHRBcnJheUVsZW1lbnQnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uKGEsIHByb3ApIHtcbiAgICAgICAgdmFyIG9mID0gdGhpcy5sb29rdXAocHJvcC5vZik7XG4gICAgICAgIHJldHVybiBvZi5pc0luc3RhbmNlKGEpID8gYSA6IG9mLmNyZWF0ZShhLCB0aGlzKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIFsgJ3Bvc3RTZXQnLCBmdW5jdGlvbihfLCBhKSB7IHRoaXMuYXhpb21zXy5wdXNoLmFwcGx5KHRoaXMuYXhpb21zXywgYSk7IH0gXVxuICBdXG59KTtcbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbi8qKlxuICogTWFwIG9mIFByb3BlcnR5IHByb3BlcnR5IG5hbWVzIHRvIGFycmF5cyBvZiBuYW1lcyBvZiBwcm9wZXJ0aWVzIHRoYXQgdGhleSBzaGFkb3cuXG4gKlxuICogRXguICdzZXR0ZXInIGhhcyBoaWdoZXIgcHJlY2VkZW5jZSB0aGFuICdhZGFwdCcsICdwcmVTZXQnLCBhbmQgJ3Bvc3RTZXQnLCBzbyBpZlxuICogaXQgaXMgc2V0LCB0aGVuIGl0IHNoYWRvd3MgdGhvc2Ugb3RoZXIgcHJvcGVydGllcyBpZiB0aGV5IGFyZSBzZXQsIGNhdXNpbmcgdGhlaXJcbiAqIHZhbHVlcyB0byBiZSBpZ25vcmVkLlxuICpcbiAqIE5vdCBkZWZpbmVkIGFzIGEgY29uc3RhbnQsIGJlY2F1c2UgdGhleSBoYXZlbid0IGJlZW4gZGVmaW5lZCB5ZXQuXG4gKi9cbmZvYW0uY29yZS5Qcm9wZXJ0eS5TSEFET1dfTUFQID0ge1xuICBzZXR0ZXI6ICAgICBbICdhZGFwdCcsICdwcmVTZXQnLCAncG9zdFNldCcgXSxcbiAgZ2V0dGVyOiAgICAgWyAnZmFjdG9yeScsICdleHByZXNzaW9uJywgJ3ZhbHVlJyBdLFxuICBmYWN0b3J5OiAgICBbICdleHByZXNzaW9uJywgJ3ZhbHVlJyBdLFxuICBleHByZXNzaW9uOiBbICd2YWx1ZScgXVxufTtcblxuXG4vKiogQWRkIG5ldyBBeGlvbSB0eXBlcyAoSW1wbGVtZW50cywgQ29uc3RhbnRzLCBUb3BpY3MsIFByb3BlcnRpZXMsIE1ldGhvZHMgYW5kIExpc3RlbmVycykgdG8gTW9kZWwuICovXG5mb2FtLkNMQVNTKHtcbiAgcmVmaW5lczogJ2ZvYW0uY29yZS5Nb2RlbCcsXG5cbiAgcHJvcGVydGllczogW1xuICAgIHtcbiAgICAgIGNsYXNzOiAnQXhpb21BcnJheScsXG4gICAgICBvZjogJ1Byb3BlcnR5JyxcbiAgICAgIG5hbWU6ICdwcm9wZXJ0aWVzJyxcbiAgICAgIGFkYXB0QXJyYXlFbGVtZW50OiBmdW5jdGlvbihvKSB7XG4gICAgICAgIGlmICggdHlwZW9mIG8gPT09ICdzdHJpbmcnICkge1xuICAgICAgICAgIHZhciBwID0gZm9hbS5jb3JlLlByb3BlcnR5LmNyZWF0ZSgpO1xuICAgICAgICAgIHAubmFtZSA9IG87XG4gICAgICAgICAgcmV0dXJuIHA7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIEFycmF5LmlzQXJyYXkobykgKSB7XG4gICAgICAgICAgdmFyIHAgPSBmb2FtLmNvcmUuUHJvcGVydHkuY3JlYXRlKCk7XG4gICAgICAgICAgcC5uYW1lICA9IG9bMF07XG4gICAgICAgICAgcC52YWx1ZSA9IG9bMV07XG4gICAgICAgICAgcmV0dXJuIHA7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIG8uY2xhc3MgKSB7XG4gICAgICAgICAgdmFyIG0gPSB0aGlzLmxvb2t1cChvLmNsYXNzKTtcbiAgICAgICAgICBpZiAoICEgbSApIHRocm93ICdVbmtub3duIGNsYXNzIDogJyArIG8uY2xhc3M7XG4gICAgICAgICAgcmV0dXJuIG0uY3JlYXRlKG8sIHRoaXMpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZvYW0uY29yZS5Qcm9wZXJ0eS5pc0luc3RhbmNlKG8pID8gbyA6IGZvYW0uY29yZS5Qcm9wZXJ0eS5jcmVhdGUobyk7XG4gICAgICB9XG4gICAgfSxcbiAgICB7XG4gICAgICBjbGFzczogJ0F4aW9tQXJyYXknLFxuICAgICAgb2Y6ICdNZXRob2QnLFxuICAgICAgbmFtZTogJ21ldGhvZHMnLFxuICAgICAgYWRhcHRBcnJheUVsZW1lbnQ6IGZ1bmN0aW9uKG8sIHByb3ApIHtcbiAgICAgICAgaWYgKCB0eXBlb2YgbyA9PT0gJ2Z1bmN0aW9uJyApIHtcbiAgICAgICAgICB2YXIgbmFtZSA9IGZvYW0uRnVuY3Rpb24uZ2V0TmFtZShvKTtcbiAgICAgICAgICBmb2FtLmFzc2VydChuYW1lLCAnTWV0aG9kIG11c3QgYmUgbmFtZWQnKTtcbiAgICAgICAgICB2YXIgbSA9IHRoaXMubG9va3VwKHByb3Aub2YpLmNyZWF0ZSgpO1xuICAgICAgICAgIG0ubmFtZSA9IG5hbWU7XG4gICAgICAgICAgbS5jb2RlID0gbztcbiAgICAgICAgICByZXR1cm4gbTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIHRoaXMubG9va3VwKHByb3Aub2YpLmlzSW5zdGFuY2UobykgKSByZXR1cm4gbztcbiAgICAgICAgaWYgKCBvLmNsYXNzICkgcmV0dXJuIHRoaXMubG9va3VwKG8uY2xhc3MpLmNyZWF0ZShvLCB0aGlzKTtcbiAgICAgICAgcmV0dXJuIGZvYW0ubG9va3VwKHByb3Aub2YpLmNyZWF0ZShvKTtcbiAgICAgIH1cbiAgICB9XG4gIF1cbn0pO1xuXG5cbmZvYW0uYm9vdC5waGFzZTMoKTtcblxuXG5mb2FtLkNMQVNTKHtcbiAgcmVmaW5lczogJ2ZvYW0uY29yZS5GT2JqZWN0JyxcblxuICBkb2N1bWVudGF0aW9uOiAnVXBncmFkZSBGT2JqZWN0IHRvIGZ1bGx5IGJvb3RzdHJhcGVkIGZvcm0uJyxcblxuICBheGlvbXM6IFtcbiAgICB7XG4gICAgICBuYW1lOiAnX19jb250ZXh0X18nLFxuICAgICAgaW5zdGFsbEluUHJvdG86IGZ1bmN0aW9uKHApIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHAsICdfX2NvbnRleHRfXycsIHtcbiAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIHggPSB0aGlzLmdldFByaXZhdGVfKCdfX2NvbnRleHRfXycpO1xuICAgICAgICAgICAgaWYgKCAhIHggKSB7XG4gICAgICAgICAgICAgIHZhciBjb250ZXh0UGFyZW50ID0gdGhpcy5nZXRQcml2YXRlXygnY29udGV4dFBhcmVudCcpO1xuICAgICAgICAgICAgICBpZiAoIGNvbnRleHRQYXJlbnQgKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRQcml2YXRlXyhcbiAgICAgICAgICAgICAgICAgICAgJ19fY29udGV4dF9fJyxcbiAgICAgICAgICAgICAgICAgICAgeCA9IGNvbnRleHRQYXJlbnQuX19zdWJDb250ZXh0X18gfHwgY29udGV4dFBhcmVudC5fX2NvbnRleHRfXyk7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRQcml2YXRlXygnY29udGV4dFBhcmVudCcsIHVuZGVmaW5lZCk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gSGFwcGVucyBkdXJpbmcgYm9vdHN0cmFwIHdpdGggUHJvcGVydGllcy5cbiAgICAgICAgICAgICAgICB4ID0gZm9hbS5fX2NvbnRleHRfXztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHg7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBzZXQ6IGZ1bmN0aW9uKHgpIHtcbiAgICAgICAgICAgIGlmICggeCApIHtcbiAgICAgICAgICAgICAgdGhpcy5zZXRQcml2YXRlXyhcbiAgICAgICAgICAgICAgICAgIGZvYW0uY29yZS5GT2JqZWN0LmlzSW5zdGFuY2UoeCkgP1xuICAgICAgICAgICAgICAgICAgICAgICdjb250ZXh0UGFyZW50JyA6XG4gICAgICAgICAgICAgICAgICAgICAgJ19fY29udGV4dF9fJyxcbiAgICAgICAgICAgICAgICAgIHgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gSWYgbm8gZGVsY2FyZWQgZXhwb3J0cywgdGhlbiBzdWItY29udGV4dCBpcyB0aGUgc2FtZSBhcyBjb250ZXh0LlxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoXG4gICAgICAgICAgICBwLFxuICAgICAgICAgICAgJ19fc3ViQ29udGV4dF9fJyxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMuX19jb250ZXh0X187IH0sXG4gICAgICAgICAgICAgIHNldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgICAgICAgICAnQXR0ZW1wdGVkIHRvIHNldCB1bnNldHRhYmxlIF9fc3ViQ29udGV4dF9fIGluICcgK1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNsc18uaWQpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gIF0sXG5cbiAgbWV0aG9kczogW1xuICAgIC8qKlxuICAgICAgQ2FsbGVkIHRvIHByb2Nlc3MgY29uc3RydWN0b3IgYXJndW1lbnRzLlxuICAgICAgUmVwbGFjZXMgc2ltcGxlciB2ZXJzaW9uIGRlZmluZWQgaW4gb3JpZ2luYWwgRk9iamVjdCBkZWZpbml0aW9uLlxuICAgICovXG4gICAgZnVuY3Rpb24gaW5pdEFyZ3MoYXJncywgY3R4KSB7XG4gICAgICBpZiAoIGN0eCAgKSB0aGlzLl9fY29udGV4dF9fID0gY3R4O1xuICAgICAgaWYgKCBhcmdzICkgdGhpcy5jb3B5RnJvbShhcmdzLCB0cnVlKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICBUZW1wbGF0ZSBtZXRob2QgdXNlZCB0byByZXBvcnQgYW4gdW5rbm93biBhcmd1bWVudCBwYXNzZWRcbiAgICAgIHRvIGEgY29uc3RydWN0b3IuIElzIHNldCBpbiBkZWJ1Zy5qcy5cbiAgICAqL1xuICAgIGZ1bmN0aW9uIHVua25vd25Bcmcoa2V5LCB2YWx1ZSkge1xuICAgICAgLy8gTk9QXG4gICAgfSxcblxuICAgIGZ1bmN0aW9uIGxvb2t1cCgpIHsgcmV0dXJuIHRoaXMuX19jb250ZXh0X18ubG9va3VwLmFwcGx5KHRoaXMuX19jb250ZXh0X18sIGFyZ3VtZW50cyk7IH0sXG4gIF1cbn0pO1xuXG5mb2FtLmJvb3QuZW5kKCk7XG5cblxuLyoqXG4gIFJlZmluZSBmb2FtLmNvcmUuUHJvcGVydHkgdG8gYWRkICd0cmFuc2llbnQnIHN1cHBvcnQuXG5cbiAgQSB0cmFuc2llbnQgUHJvcGVydHkgaXMgbm90IGludGVuZGVkIHRvIGJlIHBlcnNpc3RlZFxuICBvciB0cmFuc2ZlcmVkIG92ZXIgdGhlIG5ldHdvcmsuXG5cbiAgRXguIEEgY29tcHV0ZWQgUHJvcGVydHkgY291bGQgYmUgbWFkZSB0cmFuc2llbnQgdG8gYXZvaWRcbiAgd2FzdGluZyBkaXNrIHNwYWNlIG9yIG5ldHdvcmsgYmFuZHdpZHRoLlxuXG4gIEZvciBmaW5lciBjb250cm9sLCB0aGVyZSBhcmUgYWxzbyBzZXBhcmF0ZSBwcm9wZXJ0aWVzIGNhbGxlZFxuICAnbmV0d29ya1RyYW5zaWVudCcgYW5kICdzdG9yYWdlVHJhbnNpZW50Jywgd2hpY2ggZGVmYXVsdCB0b1xuICB0aGUgdmFsdWUgb2YgJ3RyYW5zaWVudCcgaWYgbm90IGV4cGxpY2l0bHkgc2V0LlxuXG4gIEEgbmV0d29ya1RyYW5zaWVudCBmaWVsZCBpcyBub3QgbWFyc2hhbGxlZCBvdmVyIG5ldHdvcmsgY2FsbHMuXG4gIGZvYW0uanNvbi5OZXR3b3JrIGRvZXMgbm90IGVuY29kZSBuZXR3b3JrVHJhbnNpZW50IGZpZWxkcy5cblxuICBBIHN0b3JhZ2VUcmFuc2llbnQgZmllbGQgaXMgbm90IHN0b3JlZCB0byBwZXJzaXN0ZW50IHN0b3JhZ2UuXG4gIGZvYW0uanNvbi5TdG9yYWdlIGRvZXMgbm90IGVuY29kZSBzdG9yYWdlVHJhbnNpZW50IGZpZWxkcy5cbiAqL1xuZm9hbS5DTEFTUyh7XG4gIHJlZmluZXM6ICdmb2FtLmNvcmUuUHJvcGVydHknLFxuXG4gIHByb3BlcnRpZXM6IFtcbiAgICB7XG4gICAgICBjbGFzczogJ0Jvb2xlYW4nLFxuICAgICAgbmFtZTogJ3RyYW5zaWVudCdcbiAgICB9LFxuICAgIHtcbiAgICAgIGNsYXNzOiAnQm9vbGVhbicsXG4gICAgICBuYW1lOiAnbmV0d29ya1RyYW5zaWVudCcsXG4gICAgICBleHByZXNzaW9uOiBmdW5jdGlvbih0cmFuc2llbnQpIHtcbiAgICAgICAgcmV0dXJuIHRyYW5zaWVudDtcbiAgICAgIH1cbiAgICB9LFxuICAgIHtcbiAgICAgIGNsYXNzOiAnQm9vbGVhbicsXG4gICAgICBuYW1lOiAnc3RvcmFnZVRyYW5zaWVudCcsXG4gICAgICBleHByZXNzaW9uOiBmdW5jdGlvbih0cmFuc2llbnQpIHtcbiAgICAgICAgcmV0dXJuIHRyYW5zaWVudDtcbiAgICAgIH1cbiAgICB9XG4gIF1cbn0pO1xuXG5cbi8qKlxuICogUmVwbGFjZSBmb2FtLkNMQVNTKCkgd2l0aCBhIGxhenkgdmVyc2lvbiB3aGljaCBvbmx5XG4gKiBidWlsZCB0aGUgY2xhc3Mgd2hlbiBmaXJzdCBhY2Nlc3NlZC5cbiAqL1xuKGZ1bmN0aW9uKCkge1xuICAvLyBMaXN0IG9mIHVudXNlZCBNb2RlbHMgaW4gdGhlIHN5c3RlbS5cbiAgZm9hbS5VU0VEICAgICAgPSB7fTtcbiAgZm9hbS5VTlVTRUQgICAgPSB7fTtcblxuICB2YXIgQ0xBU1MgPSBmb2FtLkNMQVNTO1xuXG4gIGZvYW0uQ0xBU1MgPSBmdW5jdGlvbihtKSB7XG4gICAgaWYgKCAhIG0uc291cmNlICYmIGdsb2JhbC5kb2N1bWVudCAmJiBnbG9iYWwuZG9jdW1lbnQuY3VycmVudFNjcmlwdCApIHtcbiAgICAgIG0uc291cmNlID0gZ2xvYmFsLmRvY3VtZW50LmN1cnJlbnRTY3JpcHQuc3JjO1xuICAgIH1cblxuICAgIGlmICggbS5yZWZpbmVzICkgcmV0dXJuIENMQVNTKG0pO1xuXG4gICAgbS5pZCA9IG0ucGFja2FnZSA/IG0ucGFja2FnZSArICcuJyArIG0ubmFtZSA6IG0ubmFtZTtcbiAgICBmb2FtLlVOVVNFRFttLmlkXSA9IHRydWU7XG5cbiAgICB2YXIgZiA9IGZvYW0uRnVuY3Rpb24ubWVtb2l6ZTAoZnVuY3Rpb24oKSB7XG4gICAgICBkZWxldGUgZm9hbS5VTlVTRURbbS5pZF07XG4gICAgICB2YXIgYyA9IENMQVNTKG0pO1xuICAgICAgZm9hbS5VU0VEW20uaWRdID0gYztcbiAgICAgIHJldHVybiBjO1xuICAgIH0pO1xuXG4gICAgZm9hbS5fX2NvbnRleHRfXy5yZWdpc3RlckZhY3RvcnkobSwgZik7XG4gICAgZm9hbS5wYWNrYWdlLnJlZ2lzdGVyQ2xhc3NGYWN0b3J5KG0sIGYpO1xuICB9O1xufSkoKTtcbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmZvYW0uQ0xBU1Moe1xuICBwYWNrYWdlOiAnZm9hbS5jb3JlJyxcbiAgbmFtZTogJ0ZPYmplY3RBcnJheScsXG4gIGV4dGVuZHM6ICdQcm9wZXJ0eScsXG5cbiAgZG9jdW1lbnRhdGlvbjogXCJBIFByb3BlcnR5IHdoaWNoIGNvbnRhaW5zIGFuIGFycmF5IG9mICdvZicgRk9iamVjdHMuXCIsXG5cbiAgcHJvcGVydGllczogW1xuICAgIHsgbmFtZTogJ29mJywgcmVxdWlyZWQ6IHRydWUgfSxcbiAgICBbXG4gICAgICAnZmFjdG9yeScsXG4gICAgICBmdW5jdGlvbigpIHsgcmV0dXJuIFtdOyB9XG4gICAgXSxcbiAgICBbICdhZGFwdCcsIGZ1bmN0aW9uKF8sIC8qIGFycmF5PyAqLyBhLCBwcm9wKSB7XG4gICAgICAgIGlmICggISBhICkgcmV0dXJuIFtdO1xuICAgICAgICAvLyBJZiBub3QgYW4gYXJyYXksIGFsbG93IGFzc2VydFZhbHVlIHRvIGFzc2VydCB0aGUgdHlwZS1jaGVjay5cbiAgICAgICAgaWYgKCAhIEFycmF5LmlzQXJyYXkoYSkgKSByZXR1cm4gYTtcblxuICAgICAgICB2YXIgYiA9IG5ldyBBcnJheShhLmxlbmd0aCk7XG4gICAgICAgIGZvciAoIHZhciBpID0gMCA7IGkgPCBhLmxlbmd0aCA7IGkrKyApIHtcbiAgICAgICAgICBiW2ldID0gcHJvcC5hZGFwdEFycmF5RWxlbWVudChhW2ldLCB0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYjtcbiAgICAgIH1cbiAgICBdLFxuICAgIFsgJ2Fzc2VydFZhbHVlJywgZnVuY3Rpb24odiwgcHJvcCkge1xuICAgICAgICBmb2FtLmFzc2VydChBcnJheS5pc0FycmF5KHYpLFxuICAgICAgICAgICAgcHJvcC5uYW1lLCAnQXR0ZW1wdCB0byBzZXQgYXJyYXkgcHJvcGVydHkgdG8gbm9uLWFycmF5IHZhbHVlJywgdik7XG4gICAgICB9XG4gICAgXSxcbiAgICBbICdhZGFwdEFycmF5RWxlbWVudCcsIGZ1bmN0aW9uKG8sIG9iaikge1xuICAgICAgLy8gRlVUVVJFOiByZXBsYWNlICdmb2FtLicgd2l0aCAnKHRoaXMuX19zdWJDb250ZXh0X18gfHwgZm9hbSkuJyA/XG4gICAgICB2YXIgY3R4ID0gb2JqLl9fc3ViQ29udGV4dF9fIHx8IGZvYW07XG4gICAgICB2YXIgb2YgPSBvLmNsYXNzIHx8IHRoaXMub2Y7XG4gICAgICB2YXIgY2xzID0gY3R4Lmxvb2t1cChvZik7XG4gICAgICByZXR1cm4gY2xzLmlzSW5zdGFuY2UobykgPyBvIDogY2xzLmNyZWF0ZShvLCBvYmopO1xuICAgIH1dLFxuICAgIHtcbiAgICAgIG5hbWU6ICdmcm9tSlNPTicsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24odmFsdWUsIGN0eCwgcHJvcCkge1xuICAgICAgICByZXR1cm4gZm9hbS5qc29uLnBhcnNlKHZhbHVlLCBwcm9wLm9mLCBjdHgpO1xuICAgICAgfVxuICAgIH1cbiAgXVxufSk7XG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG4vKipcbiAgQ29uc3RhbnRzIGFyZSBpbnN0YWxsZWQgb24gYm90aCB0aGUgcHJvdG90eXBlIGFuZCBjbGFzcy5cbjxwcmU+XG4gIEV4LlxuICBjb25zdGFudHM6IHtcbiAgICBLRVk6ICdzb21lIHZhbHVlJ1xuICB9XG5cbiAgdGhpcy5jbHNfLktFWSA9PT0gdGhpcy5LRVkgPT09ICdzb21lIHZhbHVlJ1xuPC9wcmU+XG4qL1xuZm9hbS5DTEFTUyh7XG4gIHBhY2thZ2U6ICdmb2FtLmNvcmUnLFxuICBuYW1lOiAnQ29uc3RhbnQnLFxuXG4gIGRvY3VtZW50YXRpb246ICdBbiBBeGlvbSBmb3IgZGVmaW5pbmcgY2xhc3MgY29uc3RhbnRzLicsXG5cbiAgcHJvcGVydGllczogW1xuICAgICduYW1lJyxcbiAgICB7XG4gICAgICBuYW1lOiAndmFsdWUnLFxuICAgICAgZmFjdG9yeTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZhY3RvcnkoKTtcbiAgICAgIH0sXG4gICAgfSxcbiAgICAnZmFjdG9yeScsXG4gICAgJ2RvY3VtZW50YXRpb24nLFxuICBdLFxuXG4gIG1ldGhvZHM6IFtcbiAgICBmdW5jdGlvbiBpbnN0YWxsSW5DbGFzcyhjbHMpIHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShcbiAgICAgICAgY2xzLFxuICAgICAgICBmb2FtLlN0cmluZy5jb25zdGFudGl6ZSh0aGlzLm5hbWUpLFxuICAgICAgICB7XG4gICAgICAgICAgdmFsdWU6IHRoaXMudmFsdWUsXG4gICAgICAgICAgY29uZmlndXJhYmxlOiBmYWxzZVxuICAgICAgICB9KTtcbiAgICB9LFxuICAgIGZ1bmN0aW9uIGluc3RhbGxJblByb3RvKHByb3RvKSB7XG4gICAgICB0aGlzLmluc3RhbGxJbkNsYXNzKHByb3RvKTtcbiAgICB9XG4gIF1cbn0pO1xuXG5cbmZvYW0uQ0xBU1Moe1xuICByZWZpbmVzOiAnZm9hbS5jb3JlLk1vZGVsJyxcbiAgcHJvcGVydGllczogW1xuICAgIHtcbiAgICAgIGNsYXNzOiAnQXhpb21BcnJheScsXG4gICAgICBvZjogJ0NvbnN0YW50JyxcbiAgICAgIG5hbWU6ICdjb25zdGFudHMnLFxuICAgICAgYWRhcHQ6IGZ1bmN0aW9uKF8sIGEsIHByb3ApIHtcbiAgICAgICAgaWYgKCAhIGEgKSByZXR1cm4gW107XG4gICAgICAgIGlmICggISBBcnJheS5pc0FycmF5KGEpICkge1xuICAgICAgICAgIHZhciBjcyA9IFtdO1xuICAgICAgICAgIGZvciAoIHZhciBrZXkgaW4gYSApIHtcbiAgICAgICAgICAgIGNzLnB1c2goZm9hbS5jb3JlLkNvbnN0YW50LmNyZWF0ZSh7bmFtZToga2V5LCB2YWx1ZTogYVtrZXldfSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gY3M7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGIgPSBuZXcgQXJyYXkoYS5sZW5ndGgpO1xuICAgICAgICBmb3IgKCB2YXIgaSA9IDAgOyBpIDwgYS5sZW5ndGggOyBpKysgKSB7XG4gICAgICAgICAgYltpXSA9IHByb3AuYWRhcHRBcnJheUVsZW1lbnQuY2FsbCh0aGlzLCBhW2ldLCBwcm9wKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYjtcbiAgICAgIH1cbiAgICB9XG4gIF1cbn0pO1xuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTYgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuZm9hbS5DTEFTUyh7XG4gIHJlZmluZXM6ICdmb2FtLmNvcmUuUHJvcGVydHknLFxuXG4gIHByb3BlcnRpZXM6IFtcbiAgICB7XG4gICAgICBuYW1lOiAndmFsaWRhdGVPYmonLFxuICAgICAgZXhwcmVzc2lvbjogZnVuY3Rpb24obmFtZSwgbGFiZWwsIHJlcXVpcmVkKSB7XG4gICAgICAgIHJldHVybiAhcmVxdWlyZWQgPyBudWxsIDogW1tuYW1lXSxcbiAgICAgICAgICBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiAhdGhpcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSAmJiAobGFiZWwgKyAnIGlzIHJlcXVpcmVkLicpO1xuICAgICAgICAgIH1dXG4gICAgICB9LFxuICAgIH0sXG4gIF1cbn0pO1xuXG5cbmZvYW0uQ0xBU1Moe1xuICBwYWNrYWdlOiAnZm9hbS5jb3JlLmludGVybmFsJyxcbiAgbmFtZTogJ0Vycm9ycycsXG4vLyAgZXh0ZW5kczogJ2ZvYW0uY29yZS5Qcm9wZXJ0eScsXG5cbiAgZG9jdW1lbnRhdGlvbjogYFxuICAgIEEgcHNlZG8tUHJvcGVydHkgQXhpb20gYWRkZWQgdG8gRk9iamVjdCB3aGljaCBjb250YWlucyBhbiBvYmplY3RcXCdzIHZhbGlkYXRpb24gZXJyb3JzLlxuICAgIEFkZHMgdGhlIGZvbGxvd2luZyBhdHRyaWJ1dGVzIHRvIGFuIE9iamVjdDpcbiAgICA8ZGw+XG4gICAgICA8ZHQ+ZXJyb3JzXzwvZHQ+PGRkPmxpc3Qgb2YgY3VycmVudCBlcnJvcnM8L2RkPlxuICAgICAgPGR0PmVycm9yc18kPC9kdD48ZGQ+U2xvdCByZXByZXNlbnRhdGlvbiBvZiBlcnJvcnNfPC9kZD5cbiAgICAgIDxkdD52YWxpZGF0ZU9iamVjdCgpPC9kdD48ZGQ+Y2FsbHMgdGhlIHZhbGlkYXRlT2JqKCkgbWV0aG9kIG9mIGFsbCBwcm9wZXJ0eSBBeGlvbXMsIGFsbG93aW5nIHRoZW0gdG8gcG9wdWxhdGUgZXJyb3JzXzwvZGQ+XG4gICAgPC9kbD5cbiAgYCxcblxuICBwcm9wZXJ0aWVzOiBbXG4gICAgWyAnbmFtZScsICdlcnJvcnNfJyBdXG4gIF0sXG5cbiAgbWV0aG9kczogW1xuICAgIGZ1bmN0aW9uIGluc3RhbGxJblByb3RvKHByb3RvKSB7XG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvdG8sICdlcnJvcnNfJywge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiBzZWxmLnRvU2xvdCh0aGlzKS5nZXQoKTtcbiAgICAgICAgfSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZVxuICAgICAgfSk7XG5cbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm90bywgJ2Vycm9yc18kJywge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiBzZWxmLnRvU2xvdCh0aGlzKTtcbiAgICAgICAgfSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZVxuICAgICAgfSk7XG4gICAgfSxcblxuICAgIGZ1bmN0aW9uIHRvU2xvdChvYmopIHtcbiAgICAgIHZhciBzbG90TmFtZSA9IHRoaXMuc2xvdE5hbWVfIHx8ICggdGhpcy5zbG90TmFtZV8gPSB0aGlzLm5hbWUgKyAnJCcgKTtcbiAgICAgIHZhciBzbG90ICAgICA9IG9iai5nZXRQcml2YXRlXyhzbG90TmFtZSk7XG5cbiAgICAgIGlmICggISBzbG90ICkge1xuICAgICAgICBzbG90ID0gdGhpcy5jcmVhdGVFcnJvclNsb3RfKG9iailcbiAgICAgICAgb2JqLnNldFByaXZhdGVfKHNsb3ROYW1lLCBzbG90KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNsb3Q7XG4gICAgfSxcblxuICAgIGZ1bmN0aW9uIGNyZWF0ZUVycm9yU2xvdF8ob2JqKSB7XG4gICAgICB2YXIgYXJncyA9IFtdO1xuICAgICAgdmFyIHBzICAgPSBvYmouY2xzXy5nZXRBeGlvbXNCeUNsYXNzKGZvYW0uY29yZS5Qcm9wZXJ0eSkuXG4gICAgICAgIGZpbHRlcihmdW5jdGlvbihhKSB7IHJldHVybiBhLnZhbGlkYXRlT2JqOyB9KTtcblxuICAgICAgZm9yICggdmFyIGkgPSAwIDsgaSA8IHBzLmxlbmd0aCA7IGkrKyApIHtcbiAgICAgICAgdmFyIHAgPSBwc1tpXTtcbiAgICAgICAgYXJncy5wdXNoKG9iai5zbG90KHAudmFsaWRhdGVPYmopKTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gdmFsaWRhdGVPYmplY3QoKSB7XG4gICAgICAgIHZhciByZXQ7XG5cbiAgICAgICAgZm9yICggdmFyIGkgPSAwIDsgaSA8IHBzLmxlbmd0aCA7IGkrKyApIHtcbiAgICAgICAgICB2YXIgcCA9IHBzW2ldO1xuICAgICAgICAgIHZhciBlcnIgPSBhcmdzW2ldLmdldCgpO1xuICAgICAgICAgIGlmICggZXJyICkgKHJldCB8fCAocmV0ID0gW10pKS5wdXNoKFtwLCBlcnJdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBmb2FtLmNvcmUuRXhwcmVzc2lvblNsb3QuY3JlYXRlKHtcbiAgICAgICAgb2JqOiBvYmosXG4gICAgICAgIGNvZGU6IHZhbGlkYXRlT2JqZWN0LFxuICAgICAgICBhcmdzOiBhcmdzfSk7XG4gICAgfVxuICBdXG59KTtcblxuXG5mb2FtLkNMQVNTKHtcbiAgcmVmaW5lczogJ2ZvYW0uY29yZS5GT2JqZWN0JyxcblxuICBheGlvbXM6IFtcbiAgICBmb2FtLmNvcmUuaW50ZXJuYWwuRXJyb3JzLmNyZWF0ZSgpXG4gIF1cbn0pO1xuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuLyoqXG4gIEEgRmFjZXRlZCBBeGlvbSwgd2hlbiBhZGRlZCB0byBhIENsYXNzLCBtYWtlcyBpdCBpbXBsZW1lbnRcbiAgdGhlIEZhY2V0LU1hbmFnZXIgUGF0dGVybiwgbWVhbmluZyB0aGF0IGNhbGxzIHRvIGNyZWF0ZSgpIGNhblxuICBiZSBpbnRlcmNlcHRlZCBhbmQgcmV0dXJuIGEgc3BlY2lhbCBGYWNldCBjbGFzcyBkZXBlbmRpbmcgb24gdGhlXG4gIHZhbHVlIG9mIHRoZSAnb2YnIGNyZWF0ZSBhcmd1bWVudC5cblxuICBFeC46XG4gIGZvYW0uQ0xBU1Moe1xuICAgIG5hbWU6ICdWaWV3JyxcbiAgICBheGlvbXM6IFsgZm9hbS5wYXR0ZXJuLkZhY2V0ZWQuY3JlYXRlKCkgXSxcbiAgICBwcm9wZXJ0aWVzOiBbICdvZicgXSxcbiAgICBtZXRob2RzOiBbIGZ1bmN0aW9uIHZpZXcoKSB7IHJldHVybiAnZGVmYXVsdCcgfSBdXG4gIH0pO1xuXG4gIGZvYW0uQ0xBU1Moe25hbWU6ICdBJ30pO1xuICBmb2FtLkNMQVNTKHtuYW1lOiAnQid9KTtcbiAgZm9hbS5DTEFTUyh7bmFtZTogJ0MnfSk7XG4gIGZvYW0uQ0xBU1Moe25hbWU6ICdCVmlldycsIGV4dGVuZHM6ICdWaWV3JywgbWV0aG9kczogW2Z1bmN0aW9uIHZpZXcoKSB7IHJldHVybiAnQlZpZXcnOyB9XX0pO1xuICBmb2FtLkNMQVNTKHtuYW1lOiAnQ1ZpZXcnLCBleHRlbmRzOiAnVmlldycsIG1ldGhvZHM6IFtmdW5jdGlvbiB2aWV3KCkgeyByZXR1cm4gJ0NWaWV3JzsgfV19KTtcblxuICBjb25zb2xlLmxvZyhWaWV3LmNyZWF0ZSh7b2Y6IEF9KSk7XG4gIGNvbnNvbGUubG9nKFZpZXcuY3JlYXRlKHtvZjogQn0pKTtcbiAgY29uc29sZS5sb2coVmlldy5jcmVhdGUoe29mOiBDfSkpO1xuKi9cbi8vIEZVVFVSRTogYWRkIGNyZWF0ZU9yaWdpbmFsKCkgKG9yIHNpbWlsYXIpIG1ldGhvZC5cbmZvYW0uQ0xBU1Moe1xuICBwYWNrYWdlOiAnZm9hbS5wYXR0ZXJuJyxcbiAgbmFtZTogJ0ZhY2V0ZWQnLFxuXG4gIG1ldGhvZHM6IFtcbiAgICBmdW5jdGlvbiBpbnN0YWxsSW5DbGFzcyhjbHMpIHtcbiAgICAgIHZhciBvbGRDcmVhdGUgPSBjbHMuY3JlYXRlO1xuXG4gICAgICBjbHMuZ2V0RmFjZXRPZiA9IGZ1bmN0aW9uKG9mLCBYKSB7XG4gICAgICAgIGlmICggISBvZiApIHJldHVybiB0aGlzO1xuICAgICAgICBYID0gWCB8fCBmb2FtLl9fY29udGV4dF9fO1xuXG4gICAgICAgIHZhciBuYW1lO1xuICAgICAgICB2YXIgcGtnO1xuICAgICAgICBpZiAoIGZvYW0uU3RyaW5nLmlzSW5zdGFuY2Uob2YpICkge1xuICAgICAgICAgIG5hbWUgPSBvZi5zdWJzdHJpbmcob2YubGFzdEluZGV4T2YoJy4nKSArIDEpO1xuICAgICAgICAgIHBrZyA9IG9mLnN1YnN0cmluZygwLCBvZi5sYXN0SW5kZXhPZignLicpKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5hbWUgPSBvZi5uYW1lO1xuICAgICAgICAgIHBrZyAgPSBvZi5wYWNrYWdlO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGlkID0gKCBwa2cgPyBwa2cgKyAnLicgOiAnJyApICsgbmFtZSArIHRoaXMubmFtZTtcblxuICAgICAgICByZXR1cm4gWC5sb29rdXAoaWQsIHRydWUpIHx8IHRoaXM7XG4gICAgICB9O1xuXG4gICAgICAvLyBpZ25vcmVGYWNldHMgaXMgc2V0IHRvIHRydWUgd2hlbiBjYWxsZWQgdG8gcHJldmVudCBhIHNlY29uZC1sZXZlbFxuICAgICAgLy8gb2YgZmFjZXQgY2hlY2tpbmdcbiAgICAgIGNscy5jcmVhdGUgPSBmdW5jdGlvbihhcmdzLCBYLCBpZ25vcmVGYWNldHMpIHtcbiAgICAgICAgaWYgKCAhIGlnbm9yZUZhY2V0cyApIHtcbiAgICAgICAgICB2YXIgZmFjZXRDbHMgPSB0aGlzLmdldEZhY2V0T2YoYXJncyAmJiBhcmdzLm9mLCBYKTtcblxuICAgICAgICAgIGlmICggZmFjZXRDbHMgIT09IHRoaXMgKSByZXR1cm4gZmFjZXRDbHMuY3JlYXRlKGFyZ3MsIFgsIHRydWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG9sZENyZWF0ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuICAgIH1cbiAgXSxcblxuICBwcm9wZXJ0aWVzOiBbXG4gICAgWyduYW1lJywgJ2ZvYW0ucGF0dGVybi5GYWNldGVkJ11cbiAgXVxufSk7XG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuZm9hbS5DTEFTUyh7XG4gIHBhY2thZ2U6ICdmb2FtLmNvcmUnLFxuICBuYW1lOiAnSW50JyxcbiAgZXh0ZW5kczogJ1Byb3BlcnR5JyxcblxuICBwcm9wZXJ0aWVzOiBbXG4gICAgJ3VuaXRzJyxcbiAgICBbICd2YWx1ZScsIDAgXSxcbiAgICAnbWluJyxcbiAgICAnbWF4JyxcbiAgICBbICdhZGFwdCcsIGZ1bmN0aW9uIGFkYXB0SW50KF8sIHYpIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiB2ID09PSAnbnVtYmVyJyA/IE1hdGgudHJ1bmModikgOlxuICAgICAgICAgIHYgPyBwYXJzZUludCh2KSA6XG4gICAgICAgICAgMCA7XG4gICAgICB9XG4gICAgXSxcbiAgICBbICdmcm9tU3RyaW5nJywgZnVuY3Rpb24gaW50RnJvbVN0cmluZyhzdHIpIHtcbiAgICAgICAgcmV0dXJuIHN0ciA/IHBhcnNlSW50KHN0cikgOiAwO1xuICAgICAgfVxuICAgIF1cbiAgXVxufSk7XG5cblxuZm9hbS5DTEFTUyh7XG4gIHBhY2thZ2U6ICdmb2FtLmNvcmUnLFxuICBuYW1lOiAnU3RyaW5nJyxcbiAgZXh0ZW5kczogJ1Byb3BlcnR5JyxcblxuICBkb2N1bWVudGF0aW9uOiAnU3RyaW5nUHJvcGVydGllcyBjb2VyY2UgdGhlaXIgYXJndW1lbnRzIGludG8gU3RyaW5ncy4nLFxuXG4gIHByb3BlcnRpZXM6IFtcbiAgICB7IGNsYXNzOiAnSW50JywgbmFtZTogJ3dpZHRoJywgdmFsdWU6IDMwIH0sXG4gICAgWyAnYWRhcHQnLCBmdW5jdGlvbihfLCBhKSB7XG4gICAgICAgIHJldHVybiB0eXBlb2YgYSA9PT0gJ2Z1bmN0aW9uJyA/IGZvYW0uU3RyaW5nLm11bHRpbGluZShhKSA6XG4gICAgICAgICAgICAgICB0eXBlb2YgYSA9PT0gJ251bWJlcicgICA/IFN0cmluZyhhKSAgICAgICAgICAgICAgICA6XG4gICAgICAgICAgICAgICBhICYmIGEudG9TdHJpbmcgICAgICAgICA/IGEudG9TdHJpbmcoKSAgICAgICAgICAgICA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICcnICAgICAgICAgICAgICAgICAgICAgICA7XG4gICAgICB9XG4gICAgXSxcbiAgICBbICd2YWx1ZScsICcnIF1cbiAgXVxufSk7XG5cblxuZm9hbS5DTEFTUyh7XG4gIHJlZmluZXM6ICdmb2FtLmNvcmUuTW9kZWwnLFxuXG4gIGRvY3VtZW50YXRpb246ICdVcGdyYWRlIE1vZGUuZG9jdW1lbnRhdGlvbiB0byBhIHByb3BlciBTdHJpbmcgcHJvcGVydHkuJyxcblxuICBwcm9wZXJ0aWVzOiBbXG4gICAgeyBjbGFzczogJ1N0cmluZycsIG5hbWU6ICdkb2N1bWVudGF0aW9uJyB9XG4gIF1cbn0pO1xuXG5cbmZvYW0uQ0xBU1Moe1xuICBwYWNrYWdlOiAnZm9hbS5jb3JlJyxcbiAgbmFtZTogJ0RhdGUnLFxuICBleHRlbmRzOiAnUHJvcGVydHknLFxuXG4gIC8vIGRvY3VtZW50YXRpb246ICdEZXNjcmliZXMgcHJvcGVydGllcyBvZiB0eXBlIERhdGUuJyxcbiAgbGFiZWw6ICdEYXRlJyxcblxuICBwcm9wZXJ0aWVzOiBbXG4gICAge1xuICAgICAgbmFtZTogJ2FkYXB0JyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiAoXywgZCkge1xuICAgICAgICBpZiAoIHR5cGVvZiBkID09PSAnbnVtYmVyJyApIHJldHVybiBuZXcgRGF0ZShkKTtcbiAgICAgICAgaWYgKCB0eXBlb2YgZCA9PT0gJ3N0cmluZycgKSB7XG4gICAgICAgICAgdmFyIHJldCA9IG5ldyBEYXRlKGQpO1xuXG4gICAgICAgICAgaWYgKCBpc05hTihyZXQuZ2V0VGltZSgpKSApIHRocm93ICdJbnZhbGlkIERhdGU6ICcgKyBkO1xuXG4gICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZDtcbiAgICAgIH1cbiAgICB9LFxuICAgIHtcbiAgICAgIG5hbWU6ICdjb21wYXJlUHJvcGVydHlWYWx1ZXMnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uKG8xLCBvMikge1xuICAgICAgICBpZiAoICEgbzEgKSByZXR1cm4gbzIgPyAtMSA6IDA7XG4gICAgICAgIGlmICggISBvMiApIHJldHVybiAxO1xuXG4gICAgICAgIHJldHVybiBmb2FtLkRhdGUuY29tcGFyZShvMSwgbzIpO1xuICAgICAgfVxuICAgIH1cbiAgXVxufSk7XG5cblxuZm9hbS5DTEFTUyh7XG4gIHBhY2thZ2U6ICdmb2FtLmNvcmUnLFxuICBuYW1lOiAnRGF0ZVRpbWUnLFxuICBleHRlbmRzOiAnRGF0ZScsXG5cbiAgZG9jdW1lbnRhdGlvbjogJ0Rlc2NyaWJlcyBwcm9wZXJ0aWVzIG9mIHR5cGUgRGF0ZVRpbWUuJyxcbiAgbGFiZWw6ICdEYXRlIGFuZCB0aW1lJ1xufSk7XG5cbmZvYW0uQ0xBU1Moe1xuICBwYWNrYWdlOiAnZm9hbS5jb3JlJyxcbiAgbmFtZTogJ1RpbWUnLFxuICBleHRlbmRzOiAnU3RyaW5nJyxcblxuICBkb2N1bWVudGF0aW9uOiAnRGVzY3JpYmVzIHByb3BlcnRpZXMgb2YgdHlwZSBUaW1lLicsXG4gIGxhYmVsOiAnVGltZSdcbn0pO1xuXG5cbmZvYW0uQ0xBU1Moe1xuICBwYWNrYWdlOiAnZm9hbS5jb3JlJyxcbiAgbmFtZTogJ0J5dGUnLFxuICBleHRlbmRzOiAnSW50JyxcblxuICBkb2N1bWVudGF0aW9uOiAnRGVzY3JpYmVzIHByb3BlcnRpZXMgb2YgdHlwZSBCeXRlLicsXG4gIGxhYmVsOiAnUm91bmQgYnl0ZSBudW1iZXJzJ1xufSk7XG5cblxuZm9hbS5DTEFTUyh7XG4gIHBhY2thZ2U6ICdmb2FtLmNvcmUnLFxuICBuYW1lOiAnU2hvcnQnLFxuICBleHRlbmRzOiAnSW50JyxcblxuICBkb2N1bWVudGF0aW9uOiAnRGVzY3JpYmVzIHByb3BlcnRpZXMgb2YgdHlwZSBTaG9ydC4nLFxuICBsYWJlbDogJ1JvdW5kIHNob3J0IG51bWJlcnMnXG59KTtcblxuXG5mb2FtLkNMQVNTKHtcbiAgcGFja2FnZTogJ2ZvYW0uY29yZScsXG4gIG5hbWU6ICAnTG9uZycsXG4gIGV4dGVuZHM6ICdJbnQnLFxuXG4gIGRvY3VtZW50YXRpb246ICAnRGVzY3JpYmVzIHByb3BlcnRpZXMgb2YgdHlwZSBMb25nLicsXG4gIGxhYmVsOiAnUm91bmQgbG9uZyBudW1iZXJzJ1xufSk7XG5cblxuZm9hbS5DTEFTUyh7XG4gIHBhY2thZ2U6ICdmb2FtLmNvcmUnLFxuICBuYW1lOiAnRmxvYXQnLFxuICBleHRlbmRzOiAnSW50JyxcblxuICAvLyBkb2N1bWVudGF0aW9uOiAgJ0Rlc2NyaWJlcyBwcm9wZXJ0aWVzIG9mIHR5cGUgRmxvYXQuJyxcbiAgbGFiZWw6ICdEZWNpbWFsIG51bWJlcnMnLFxuXG4gIHByb3BlcnRpZXM6IFtcbiAgICAncHJlY2lzaW9uJyxcbiAgICBbXG4gICAgICAnYWRhcHQnLFxuICAgICAgZnVuY3Rpb24gKF8sIHYpIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiB2ID09PSAnbnVtYmVyJyA/IHYgOiB2ID8gcGFyc2VGbG9hdCh2KSA6IDAuMCA7XG4gICAgICB9XG4gICAgXVxuICBdXG59KTtcblxuXG4vKipcbiBObyBkaWZmZXJlbnQgdGhhbiBGbG9hdCBmb3IgSlMsIGJ1dCB1c2VmdWwgd2hlbiB0YXJnZXRpbmcgd2l0aCBvdGhlciBsYW5ndWFnZXMuXG4gKiovXG5mb2FtLkNMQVNTKHtcbiAgcGFja2FnZTogJ2ZvYW0uY29yZScsXG4gIG5hbWU6ICdEb3VibGUnLFxuICBleHRlbmRzOiAnRmxvYXQnXG59KTtcblxuXG5mb2FtLkNMQVNTKHtcbiAgcGFja2FnZTogJ2ZvYW0uY29yZScsXG4gIG5hbWU6ICdGdW5jdGlvbicsXG4gIGV4dGVuZHM6ICdQcm9wZXJ0eScsXG5cbiAgZG9jdW1lbnRhdGlvbjogJ0Rlc2NyaWJlcyBwcm9wZXJ0aWVzIG9mIHR5cGUgRnVuY3Rpb24uJyxcbiAgbGFiZWw6ICdDb2RlIHRoYXQgY2FuIGJlIHJ1bicsXG5cbiAgcHJvcGVydGllczogW1xuICAgIFtcbiAgICAgICd2YWx1ZScsXG4gICAgICBmdW5jdGlvbigpIHt9XG4gICAgXSxcbiAgICBbXG4gICAgICAnYXNzZXJ0VmFsdWUnLFxuICAgICAgZnVuY3Rpb24odmFsdWUsIHByb3ApIHtcbiAgICAgICAgZm9hbS5hc3NlcnQodHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nLCBwcm9wLm5hbWUsICdDYW5ub3Qgc2V0IHRvIG5vbiBmdW5jdGlvbiB0eXBlLicpO1xuICAgICAgfVxuICAgIF1cbiAgXVxufSk7XG5cblxuZm9hbS5DTEFTUyh7XG4gIHBhY2thZ2U6ICdmb2FtLmNvcmUnLFxuICBuYW1lOiAnT2JqZWN0JyxcbiAgZXh0ZW5kczogJ1Byb3BlcnR5JyxcbiAgZG9jdW1lbnRhdGlvbjogJydcbn0pO1xuXG5cbmZvYW0uQ0xBU1Moe1xuICBwYWNrYWdlOiAnZm9hbS5jb3JlJyxcbiAgbmFtZTogJ0FycmF5JyxcbiAgZXh0ZW5kczogJ1Byb3BlcnR5JyxcblxuICBwcm9wZXJ0aWVzOiBbXG4gICAgW1xuICAgICAgJ2ZhY3RvcnknLFxuICAgICAgZnVuY3Rpb24oKSB7IHJldHVybiBbXTsgfVxuICAgIF0sXG4gICAgW1xuICAgICAgJ2lzRGVmYXVsdFZhbHVlJyxcbiAgICAgIGZ1bmN0aW9uKHYpIHsgcmV0dXJuICEgdiB8fCAhIHYubGVuZ3RoOyB9XG4gICAgXVxuICBdXG59KTtcblxuXG5mb2FtLkNMQVNTKHtcbiAgcGFja2FnZTogJ2ZvYW0uY29yZScsXG4gIG5hbWU6ICdMaXN0JyxcbiAgZXh0ZW5kczogJ2ZvYW0uY29yZS5PYmplY3QnXG59KTtcblxuXG5mb2FtLkNMQVNTKHtcbiAgcGFja2FnZTogJ2ZvYW0uY29yZScsXG4gIG5hbWU6ICdTdHJpbmdBcnJheScsXG4gIGV4dGVuZHM6ICdQcm9wZXJ0eScsXG5cbiAgZG9jdW1lbnRhdGlvbjogJ0FuIGFycmF5IG9mIFN0cmluZyB2YWx1ZXMuJyxcbiAgbGFiZWw6ICdMaXN0IG9mIHRleHQgc3RyaW5ncycsXG5cbiAgcHJvcGVydGllczogW1xuICAgIHtcbiAgICAgIG5hbWU6ICdvZicsXG4gICAgICB2YWx1ZTogJ1N0cmluZycsXG4gICAgICBkb2N1bWVudGF0aW9uOiAnVGhlIEZPQU0gc3ViLXR5cGUgb2YgdGhpcyBwcm9wZXJ0eS4nXG4gICAgfSxcbiAgICBbXG4gICAgICAnZmFjdG9yeScsXG4gICAgICBmdW5jdGlvbigpIHsgcmV0dXJuIFtdOyB9XG4gICAgXSxcbiAgICBbXG4gICAgICAnYWRhcHQnLFxuICAgICAgZnVuY3Rpb24oXywgdiwgcHJvcCkge1xuICAgICAgICBpZiAoICEgQXJyYXkuaXNBcnJheSh2KSApIHJldHVybiB2O1xuXG4gICAgICAgIHZhciBjb3B5O1xuICAgICAgICBmb3IgKCB2YXIgaSA9IDAgOyBpIDwgdi5sZW5ndGggOyBpKysgKSB7XG4gICAgICAgICAgaWYgKCB0eXBlb2YgdltpXSAhPT0gJ3N0cmluZycgKSB7XG4gICAgICAgICAgICBpZiAoICEgY29weSApIGNvcHkgPSB2LnNsaWNlKCk7XG4gICAgICAgICAgICBjb3B5W2ldID0gJycgKyB2W2ldO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBjb3B5IHx8IHY7XG4gICAgICB9XG4gICAgXSxcbiAgICBbXG4gICAgICAnYXNzZXJ0VmFsdWUnLFxuICAgICAgZnVuY3Rpb24odiwgcHJvcCkge1xuICAgICAgICBpZiAoIHYgPT09IG51bGwgKSByZXR1cm47XG5cbiAgICAgICAgZm9hbS5hc3NlcnQoQXJyYXkuaXNBcnJheSh2KSxcbiAgICAgICAgICAgIHByb3AubmFtZSwgJ1RyaWVkIHRvIHNldCBTdHJpbmdBcnJheSB0byBub24tYXJyYXkgdHlwZS4nKTtcbiAgICAgICAgZm9yICggdmFyIGkgPSAwIDsgaSA8IHYubGVuZ3RoIDsgaSsrICkge1xuICAgICAgICAgIGZvYW0uYXNzZXJ0KHR5cGVvZiB2W2ldID09PSAnc3RyaW5nJyxcbiAgICAgICAgICAgICAgcHJvcC5uYW1lLCAnRWxlbWVudCcsIGksICdpcyBub3QgYSBzdHJpbmcnLCB2W2ldKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIF1cbiAgXVxufSk7XG5cblxuZm9hbS5DTEFTUyh7XG4gIHBhY2thZ2U6ICdmb2FtLmNvcmUnLFxuICBuYW1lOiAnQ2xhc3MnLFxuICBleHRlbmRzOiAnUHJvcGVydHknLFxuXG4gIHByb3BlcnRpZXM6IFtcbiAgICBbICdnZXR0ZXInLCBmdW5jdGlvbihwcm9wKSB7XG4gICAgICAgIHZhciBjID0gdGhpcy5pbnN0YW5jZV9bcHJvcC5uYW1lXTtcblxuICAgICAgICAvLyBJbXBsZW1lbnQgdmFsdWUgYW5kIGZhY3Rvcnkgc3VwcG9ydC5cbiAgICAgICAgaWYgKCBmb2FtLlVuZGVmaW5lZC5pc0luc3RhbmNlKGMpICkge1xuICAgICAgICAgIGlmICggISBmb2FtLlVuZGVmaW5lZC5pc0luc3RhbmNlKHByb3AudmFsdWUpICkge1xuICAgICAgICAgICAgYyA9IHByb3AudmFsdWU7XG4gICAgICAgICAgfSBlbHNlIGlmICggcHJvcC5mYWN0b3J5ICkge1xuICAgICAgICAgICAgYyA9IHRoaXMuaW5zdGFuY2VfW3Byb3AubmFtZV0gPSBwcm9wLmZhY3RvcnkuY2FsbCh0aGlzLCBwcm9wKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBVcGdyYWRlIFN0cmluZ3MgdG8gYWN0dWFsIGNsYXNzZXMsIGlmIGF2YWlsYWJsZS5cbiAgICAgICAgaWYgKCBmb2FtLlN0cmluZy5pc0luc3RhbmNlKGMpICkge1xuICAgICAgICAgIGMgPSB0aGlzLmxvb2t1cChjLCB0cnVlKTtcbiAgICAgICAgICBpZiAoIGMgKSB7XG4gICAgICAgICAgICB0aGlzLmluc3RhbmNlX1twcm9wLm5hbWVdID0gYztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcignVW5rbm93biBjbGFzczogJyArIGMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBjO1xuICAgICAgfVxuICAgIF0sXG4gICAgWyd0b0pTT04nLCBmdW5jdGlvbih2YWx1ZSkgeyByZXR1cm4gdmFsdWUgPyB2YWx1ZS5pZCA6IHZhbHVlOyB9IF1cbiAgXSxcblxuICBtZXRob2RzOiBbXG4gICAgZnVuY3Rpb24gaW5zdGFsbEluUHJvdG8ocHJvdG8pIHtcbiAgICAgIHRoaXMuU1VQRVIocHJvdG8pO1xuXG4gICAgICB2YXIgbmFtZSA9IHRoaXMubmFtZTtcblxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb3RvLCBuYW1lICsgJyRjbHMnLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gY2xhc3NHZXR0ZXIoKSB7XG4gICAgICAgICAgY29uc29sZS53YXJuKFwiRGVwcmVjYXRlZCB1c2Ugb2YgJ2Nscy4kY2xzJy4gSnVzdCB1c2UgJ2NscycgaW5zdGVhZC5cIik7XG4gICAgICAgICAgcmV0dXJuIHR5cGVvZiB0aGlzW25hbWVdICE9PSAnc3RyaW5nJyA/IHRoaXNbbmFtZV0gOlxuICAgICAgICAgICAgdGhpcy5fX2NvbnRleHRfXy5sb29rdXAodGhpc1tuYW1lXSwgdHJ1ZSk7XG4gICAgICAgIH0sXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgfSk7XG4gICAgfVxuICBdXG59KTtcblxuXG5mb2FtLkNMQVNTKHtcbiAgcGFja2FnZTogJ2ZvYW0uY29yZScsXG4gIG5hbWU6ICdFTWFpbCcsXG4gIGV4dGVuZHM6ICdTdHJpbmcnLFxuICAvLyBGVVRVUkU6IHZlcmlmeVxuICBsYWJlbDogJ0VtYWlsIGFkZHJlc3MnXG59KTtcblxuXG5mb2FtLkNMQVNTKHtcbiAgcGFja2FnZTogJ2ZvYW0uY29yZScsXG4gIG5hbWU6ICdJbWFnZScsXG4gIGV4dGVuZHM6ICdTdHJpbmcnLFxuICAvLyBGVVRVUkU6IHZlcmlmeVxuICBsYWJlbDogJ0ltYWdlIGRhdGEgb3IgbGluaydcbn0pO1xuXG5cbmZvYW0uQ0xBU1Moe1xuICBwYWNrYWdlOiAnZm9hbS5jb3JlJyxcbiAgbmFtZTogJ1VSTCcsXG4gIGV4dGVuZHM6ICdTdHJpbmcnLFxuICAvLyBGVVRVUkU6IHZlcmlmeVxuICBsYWJlbDogJ1dlYiBsaW5rIChVUkwgb3IgaW50ZXJuZXQgYWRkcmVzcyknXG59KTtcblxuXG5mb2FtLkNMQVNTKHtcbiAgcGFja2FnZTogJ2ZvYW0uY29yZScsXG4gIG5hbWU6ICdDb2xvcicsXG4gIGV4dGVuZHM6ICdTdHJpbmcnLFxuICBsYWJlbDogJ0NvbG9yJ1xufSk7XG5cblxuZm9hbS5DTEFTUyh7XG4gIHBhY2thZ2U6ICdmb2FtLmNvcmUnLFxuICBuYW1lOiAnUGFzc3dvcmQnLFxuICBleHRlbmRzOiAnU3RyaW5nJyxcbiAgbGFiZWw6ICdQYXNzd29yZCB0aGF0IGRpc3BsYXlzIHByb3RlY3RlZCBvciBoaWRkZW4gdGV4dCdcbn0pO1xuXG5cbmZvYW0uQ0xBU1Moe1xuICBwYWNrYWdlOiAnZm9hbS5jb3JlJyxcbiAgbmFtZTogJ1Bob25lTnVtYmVyJyxcbiAgZXh0ZW5kczogJ1N0cmluZycsXG4gIGxhYmVsOiAnUGhvbmUgbnVtYmVyJ1xufSk7XG5cblxuZm9hbS5DTEFTUyh7XG4gIHBhY2thZ2U6ICdmb2FtLmNvcmUnLFxuICBuYW1lOiAnQ3VycmVuY3knLFxuICBleHRlbmRzOiAnTG9uZydcbn0pO1xuXG5cbmZvYW0uQ0xBU1Moe1xuICBwYWNrYWdlOiAnZm9hbS5jb3JlJyxcbiAgbmFtZTogJ01hcCcsXG4gIGV4dGVuZHM6ICdQcm9wZXJ0eScsXG5cbiAgLy8gVE9ETzogUmVtb3ZlIG5lZWQgZm9yIHNvcnRpbmdcbiAgcHJvcGVydGllczogW1xuICAgIFsgJ2ZhY3RvcnknLCBmdW5jdGlvbigpIHsgcmV0dXJuIHt9IH0gXSxcbiAgICBbXG4gICAgICAnY29tcGFyZVByb3BlcnR5VmFsdWVzJyxcbiAgICAgIGZ1bmN0aW9uKG8xLCBvMikge1xuICAgICAgICBpZiAoIGZvYW0udHlwZU9mKG8xKSAhPSBmb2FtLnR5cGVPZihvMikgKSByZXR1cm4gLTE7XG5cbiAgICAgICAgdmFyIGtleXMxID0gT2JqZWN0LmtleXMobzEpLnNvcnQoKTtcbiAgICAgICAgdmFyIGtleXMyID0gT2JqZWN0LmtleXMobzIpLnNvcnQoKTtcbiAgICAgICAgaWYgKCBrZXlzMS5sZW5ndGggPCBrZXlzMi5sZW5ndGggKSByZXR1cm4gLTE7XG4gICAgICAgIGlmICgga2V5czEubGVuZ3RoID4ga2V5czIubGVuZ3RoICkgcmV0dXJuIDE7XG4gICAgICAgIGZvciAoIHZhciBpID0gMCA7IGkgPCBrZXlzMS5sZW5ndGggOyBpKysgKSB7XG4gICAgICAgICAgdmFyIGMgPSBmb2FtLlN0cmluZy5jb21wYXJlKGtleXMxW2ldLCBrZXlzMltpXSk7XG4gICAgICAgICAgaWYgKCBjICE9IDAgKSByZXR1cm4gYztcbiAgICAgICAgICBjID0gZm9hbS51dGlsLmNvbXBhcmUobzFba2V5czFbaV1dLCBvMltrZXlzMltpXV0pO1xuICAgICAgICAgIGlmICggYyAhPSAwICkgcmV0dXJuIGM7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gMDtcbiAgICAgIH1cbiAgICBdLFxuICAgIFtcbiAgICAgICdjbG9uZVByb3BlcnR5JyxcbiAgICAgIGZ1bmN0aW9uKHZhbHVlLCBjbG9uZU1hcCkge1xuICAgICAgICBpZiAoIHZhbHVlICkge1xuICAgICAgICAgIHZhciB0bXAgPSBjbG9uZU1hcFt0aGlzLm5hbWVdID0ge307XG4gICAgICAgICAgZm9yICggdmFyIGtleSBpbiB2YWx1ZSApIHtcbiAgICAgICAgICAgIHRtcFtrZXldID0gdmFsdWVba2V5XTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICBdLFxuICAgIFtcbiAgICAgICdkaWZmUHJvcGVydHlWYWx1ZXMnLFxuICAgICAgZnVuY3Rpb24obzEsIG8yKSB7XG4gICAgICAgIC8vIFRPRE9cbiAgICAgIH1cbiAgICBdLFxuICAgICdvZidcbiAgXVxufSk7XG5cblxuZm9hbS5DTEFTUyh7XG4gIHBhY2thZ2U6ICdmb2FtLmNvcmUnLFxuICBuYW1lOiAnRk9iamVjdFByb3BlcnR5JyxcbiAgZXh0ZW5kczogJ1Byb3BlcnR5JyxcblxuICBwcm9wZXJ0aWVzOiBbXG4gICAge1xuICAgICAgY2xhc3M6ICdDbGFzcycsXG4gICAgICBuYW1lOiAnb2YnLFxuICAgICAgdmFsdWU6ICdmb2FtLmNvcmUuRk9iamVjdCdcbiAgICB9LFxuICAgIHtcbiAgICAgIG5hbWU6ICdmcm9tSlNPTicsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24oanNvbiwgY3R4LCBwcm9wKSB7XG4gICAgICAgIHJldHVybiBmb2FtLmpzb24ucGFyc2UoanNvbiwgcHJvcC5vZiwgY3R4KTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHtcbiAgICAgIG5hbWU6ICdhZGFwdCcsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24oXywgdiwgcHJvcCkge1xuICAgICAgICAvLyBBbGwgRk9iamVjdHMgbWF5IGJlIG51bGwuXG4gICAgICAgIGlmICh2ID09PSBudWxsKSByZXR1cm4gdjtcblxuICAgICAgICB2YXIgb2YgPSBwcm9wLm9mO1xuXG4gICAgICAgIHJldHVybiBvZi5pc0luc3RhbmNlKHYpID9cbiAgICAgICAgICAgIHYgOlxuICAgICAgICAgICAgKCB2LmNsYXNzID9cbiAgICAgICAgICAgICAgICB0aGlzLmxvb2t1cCh2LmNsYXNzKSA6XG4gICAgICAgICAgICAgICAgb2YgKS5jcmVhdGUodiwgdGhpcy5fX3N1YkNvbnRleHRfXyk7XG4gICAgICB9XG4gICAgfVxuICBdXG59KTtcblxuXG5mb2FtLkNMQVNTKHtcbiAgcGFja2FnZTogJ2ZvYW0uY29yZScsXG4gIG5hbWU6ICdSZWZlcmVuY2UnLFxuICBleHRlbmRzOiAnUHJvcGVydHknLFxuXG4gIHByb3BlcnRpZXM6IFtcbiAgICB7XG4gICAgICBjbGFzczogJ0NsYXNzJyxcbiAgICAgIG5hbWU6ICdvZidcbiAgICB9LFxuICAgIHtcbiAgICAgIGNsYXNzOiAnU3RyaW5nJyxcbiAgICAgIG5hbWU6ICd0YXJnZXREQU9LZXknLFxuICAgICAgZXhwcmVzc2lvbjogZnVuY3Rpb24ob2YpIHsgcmV0dXJuIGZvYW0uU3RyaW5nLmRhb2l6ZShvZi5uYW1lKTsgfVxuICAgIH0sXG4gICAge1xuICAgICAgbmFtZTogJ2FkYXB0JyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbihvbGRWYWx1ZSwgbmV3VmFsdWUsIHByb3ApIHtcbiAgICAgICAgcmV0dXJuIHByb3Aub2YuaXNJbnN0YW5jZShuZXdWYWx1ZSkgP1xuICAgICAgICAgIG5ld1ZhbHVlLmlkIDpcbiAgICAgICAgICBuZXdWYWx1ZSA7XG4gICAgICB9XG4gICAgfVxuICBdLFxuXG4gIG1ldGhvZHM6IFtcbiAgICBmdW5jdGlvbiBpbnN0YWxsSW5Qcm90byhwcm90bykge1xuICAgICAgdGhpcy5TVVBFUihwcm90byk7XG4gICAgICB2YXIga2V5ICA9IHRoaXMudGFyZ2V0REFPS2V5O1xuICAgICAgdmFyIG5hbWUgPSB0aGlzLm5hbWU7XG5cbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm90bywgbmFtZSArICckZmluZCcsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiBjbGFzc0dldHRlcigpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5fX2NvbnRleHRfX1trZXldLmZpbmQodGhpc1tuYW1lXSk7XG4gICAgICAgIH0sXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgfSk7XG4gICAgfVxuICBdXG59KTtcblxuXG5mb2FtLkNMQVNTKHtcbiAgcmVmaW5lczogJ2ZvYW0uY29yZS5Nb2RlbCcsXG5cbiAgZG9jdW1lbnRhdGlvbjogJ1VwZGF0ZSBNb2RlbCBQcm9wZXJ0eSB0eXBlcy4nLFxuXG4gIHByb3BlcnRpZXM6IFtcbiAgICB7IGNsYXNzOiAnU3RyaW5nJywgIG5hbWU6ICduYW1lJyB9LFxuICAgIHsgY2xhc3M6ICdCb29sZWFuJywgbmFtZTogJ2Fic3RyYWN0JyB9XG4gIF1cbn0pO1xuXG5cbmZvYW0uQ0xBU1Moe1xuICByZWZpbmVzOiAnUHJvcGVydHknLFxuXG4gIGF4aW9tczogW1xuICAgIGZvYW0ucGF0dGVybi5GYWNldGVkLmNyZWF0ZSgpXG4gIF0sXG5cbiAgcHJvcGVydGllczogW1xuICAgIHtcbiAgICAgIG5hbWU6ICdvZidcbiAgICB9XG4gIF1cbn0pO1xuXG5cbmZvYW0uQ0xBU1Moe1xuICByZWZpbmVzOiAnUHJvcGVydHknLFxuXG4gIHByb3BlcnRpZXM6IFtcbiAgICAvKipcbiAgICAgIEEgc2hvcnQtbmFtZSBpcyBhbiBvcHRpb25hbCBzaG9ydGVyIG5hbWUgZm9yIGEgcHJvcGVydHkuXG4gICAgICBJdCBpcyB1c2VkIGJ5IEpTT04gYW5kIFhNTCBzdXBwb3J0IHdoZW4gJ3VzZVNob3J0TmFtZXMnXG4gICAgICBpcyBlbmFibGVkLiBTaG9ydC1uYW1lcyBlbmFibGUgb3V0cHV0IHRvIGJlIHNtYWxsZXIsXG4gICAgICB3aGljaCBjYW4gc2F2ZSBkaXNrIHNwYWNlIGFuZC9vciBuZXR3b3JrIGJhbmR3aWR0aC5cbiAgICAgIEV4LlxuICAgIDxwcmU+XG4gICAgICBwcm9wZXJ0aWVzOiBbXG4gICAgICAgIHsgbmFtZTogJ2ZpcnN0TmFtZScsIHNob3J0TmFtZTogJ2ZuJyB9LFxuICAgICAgICB7IG5hbWU6ICdsYXN0TmFtZScsICBzaG9ydE5hbWU6ICdsbicgfVxuICAgICAgXVxuICAgIDwvcHJlPlxuICAgICovXG4gICAgeyBjbGFzczogJ1N0cmluZycsIG5hbWU6ICdzaG9ydE5hbWUnIH1cbiAgXVxufSk7XG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5mb2FtLkNMQVNTKHtcbiAgcGFja2FnZTogJ2ZvYW0uY29yZScsXG4gIG5hbWU6ICdUb3BpYycsXG5cbiAgZG9jdW1lbnRhdGlvbjogYFxuICBUb3BpY3MgZGVsY2FyZSB0aGUgdHlwZXMgb2YgZXZlbnRzIHRoYXQgYW4gb2JqZWN0IHB1Ymxpc2hlcy5cbiAgPHByZT5cbiAgICBFeC5cbiAgICBmb2FtLkNMQVNTKHtcbiAgICAgIG5hbWU6ICdBbGFybScsXG4gICAgICB0b3BpY3M6IFsgJ3JpbmcnIF1cbiAgICB9KTtcblxuICAgIHRoZW4gZG9pbmc6XG4gICAgYWxhcm0ucmluZy5wdWIoKTtcbiAgICBhbGFybS5yaW5nLnN1YihsKTtcblxuICAgIGlzIHRoZSBzYW1lIGFzOlxuICAgIGFsYXJtLnB1YigncmluZycpO1xuICAgIGFsYXJtLnN1YigncmluZycsIGwpO1xuICA8L3ByZT5cbiAgYCxcblxuICBwcm9wZXJ0aWVzOiBbXG4gICAgJ25hbWUnLFxuICAgICdkZXNjcmlwdGlvbicsXG4gICAge1xuICAgICAgY2xhc3M6ICdGT2JqZWN0QXJyYXknLFxuICAgICAgb2Y6ICdUb3BpYycsXG4gICAgICBuYW1lOiAndG9waWNzJyxcbiAgICAgIGFkYXB0QXJyYXlFbGVtZW50OiBmdW5jdGlvbihvKSB7XG4gICAgICAgIHJldHVybiB0eXBlb2YgbyA9PT0gJ3N0cmluZycgP1xuICAgICAgICAgIGZvYW0uY29yZS5Ub3BpYy5jcmVhdGUoeyBuYW1lOiBvIH0sIHRoaXMpIDpcbiAgICAgICAgICBmb2FtLmNvcmUuVG9waWMuY3JlYXRlKG8sIHRoaXMpO1xuICAgICAgfVxuICAgIH1cbiAgXSxcblxuICBtZXRob2RzOiBbXG4gICAgZnVuY3Rpb24gaW5zdGFsbEluUHJvdG8ocHJvdG8pIHtcbiAgICAgIHZhciBuYW1lICAgICAgPSB0aGlzLm5hbWU7XG4gICAgICB2YXIgdG9waWMgICAgID0gdGhpcztcbiAgICAgIHZhciBtYWtlVG9waWMgPSB0aGlzLm1ha2VUb3BpYztcblxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb3RvLCBuYW1lLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gdG9waWNHZXR0ZXIoKSB7XG4gICAgICAgICAgaWYgKCAhIHRoaXMuaGFzT3duUHJpdmF0ZV8obmFtZSkgKSB7XG4gICAgICAgICAgICB0aGlzLnNldFByaXZhdGVfKG5hbWUsIG1ha2VUb3BpYyh0b3BpYywgdGhpcykpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiB0aGlzLmdldFByaXZhdGVfKG5hbWUpO1xuICAgICAgICB9LFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlXG4gICAgICB9KTtcbiAgICB9LFxuXG4gICAgZnVuY3Rpb24gbWFrZVRvcGljKHRvcGljLCBwYXJlbnQpIHtcbiAgICAgIHZhciBuYW1lICAgPSB0b3BpYy5uYW1lO1xuICAgICAgdmFyIHRvcGljcyA9IHRvcGljLnRvcGljcyB8fCBbXTtcblxuICAgICAgdmFyIHJldCA9IHtcbiAgICAgICAgcHViOiBmb2FtLkZ1bmN0aW9uLmJpbmQocGFyZW50LnB1YiwgcGFyZW50LCBuYW1lKSxcbiAgICAgICAgc3ViOiBmb2FtLkZ1bmN0aW9uLmJpbmQocGFyZW50LnN1YiwgcGFyZW50LCBuYW1lKSxcbiAgICAgICAgaGFzTGlzdGVuZXJzOiBmb2FtLkZ1bmN0aW9uLmJpbmQocGFyZW50Lmhhc0xpc3RlbmVycywgcGFyZW50LCBuYW1lKSxcbiAgICAgICAgdG9TdHJpbmc6IGZ1bmN0aW9uKCkgeyByZXR1cm4gJ1RvcGljKCcgKyBuYW1lICsgJyknOyB9XG4gICAgICB9O1xuXG4gICAgICBmb3IgKCB2YXIgaSA9IDAgOyBpIDwgdG9waWNzLmxlbmd0aCA7IGkrKyApIHtcbiAgICAgICAgcmV0W3RvcGljc1tpXS5uYW1lXSA9IG1ha2VUb3BpYyh0b3BpY3NbaV0sIHJldCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuICBdXG59KTtcblxuXG5mb2FtLkNMQVNTKHtcbiAgcmVmaW5lczogJ2ZvYW0uY29yZS5Nb2RlbCcsXG4gIHByb3BlcnRpZXM6IFtcbiAgICB7XG4gICAgICBjbGFzczogJ0F4aW9tQXJyYXknLFxuICAgICAgb2Y6ICdUb3BpYycsXG4gICAgICBuYW1lOiAndG9waWNzJyxcbiAgICAgIGFkYXB0QXJyYXlFbGVtZW50OiBmdW5jdGlvbihvKSB7XG4gICAgICAgIHJldHVybiB0eXBlb2YgbyA9PT0gJ3N0cmluZycgICAgICAgID9cbiAgICAgICAgICBmb2FtLmNvcmUuVG9waWMuY3JlYXRlKHtuYW1lOiBvfSkgOlxuICAgICAgICAgIGZvYW0uY29yZS5Ub3BpYy5jcmVhdGUobykgICAgICAgICA7XG4gICAgICB9XG4gICAgfVxuICBdXG59KTtcblxuXG5mb2FtLkNMQVNTKHtcbiAgcmVmaW5lczogJ2ZvYW0uY29yZS5GT2JqZWN0JyxcbiAgdG9waWNzOiBbICdwcm9wZXJ0eUNoYW5nZScgXVxufSk7XG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG4vKipcbiAgQ2xhc3NlcyBjYW4gaGF2ZSBcImlubmVyLWNsYXNzZXNcIiB3aGljaCBhcmUgY2xhc3NlcyB3aGljaCBhcmUgZGVmaW5lZCB3aXRoaW5cbiAgdGhlIHNjb3BlIG9mIGEgY2xhc3MgaXRzZWxmIHJhdGhlciB0aGFuIGJlaW5nIHRvcC1sZXZlbCBjbGFzc2VzIHdoaWNoIHJlc2lkZVxuICBpbiBhIHBhY2thZ2Ugb3IgZ2xvYmFsbHkuIFRoaXMgaGVscHMgdG8gYXZvaWQgcG9sbHV0aW5nIG5hbWVzcGFjZXMgd2l0aCBjbGFzc2VzXG4gIHdoaWNoIGFyZSBvbmx5IHVzZWQgYnkgYSBzaW5nbGUgY2xhc3MuXG5cbjxwcmU+XG4gIEV4LlxuICAvLyBDbGFzc2VzIGNhbiBoYXZlIGlubmVyLUNsYXNzZXMuXG4gIGZvYW0uQ0xBU1Moe1xuICAgIG5hbWU6ICdJbm5lckNsYXNzVGVzdCcsXG4gICAgY2xhc3NlczogW1xuICAgICAgeyBuYW1lOiAnSW5uZXJDbGFzczEnLCBwcm9wZXJ0aWVzOiBbJ2EnLCAnYiddIH0sXG4gICAgICB7IG5hbWU6ICdJbm5lckNsYXNzMicsIHByb3BlcnRpZXM6IFsneCcsICd5J10gfVxuICAgIF0sXG4gICAgbWV0aG9kczogW1xuICAgICAgZnVuY3Rpb24gaW5pdCgpIHtcbiAgICAgICAgdmFyIGljMSA9IHRoaXMuSW5uZXJDbGFzczEuY3JlYXRlKHthOjEsIGI6Mn0pO1xuICAgICAgICB2YXIgaWMyID0gdGhpcy5Jbm5lckNsYXNzMi5jcmVhdGUoe3g6NSwgeToxMH0pO1xuICAgICAgICBsb2coaWMxLmEsIGljMS5iLCBpYzIueCwgaWMyLnkpO1xuICAgICAgfVxuICAgIF1cbiAgfSk7XG4gIElubmVyQ2xhc3NUZXN0LmNyZWF0ZSgpO1xuPC9wcmU+XG4qL1xuZm9hbS5DTEFTUyh7XG4gIHBhY2thZ2U6ICdmb2FtLmNvcmUnLFxuICBuYW1lOiAnSW5uZXJDbGFzcycsXG5cbiAgZG9jdW1lbnRhdGlvbjogJ0F4aW9tIGZvciBkZWZpbmluZyBpbm5lci1jbGFzc2VzLiBBbiBpbm5lci1jbGFzcyBpcyBhIGNsYXNzIGRlZmluZWQgaW4gdGhlIHNjb3BlIG9mIHRoZSBvdXRlci9vd25lciBjbGFzcy4gVGhpcyBhdm9pZHMgcG9sdXRpbmcgdGhlIHBhY2thZ2UgbmFtZXNwYWNlIHdpdGggY2xhc3NlcyB3aGljaCBhcmUgb25seSB1c2VkIGludGVybmFsbHkgYnkgYSBjbGFzcy4nLFxuXG4gIHByb3BlcnRpZXM6IFtcbiAgICB7XG4gICAgICBuYW1lOiAnbmFtZScsXG4gICAgICBnZXR0ZXI6IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcy5tb2RlbC5uYW1lOyB9XG4gICAgfSxcbiAgICB7XG4gICAgICBuYW1lOiAnbW9kZWwnLFxuICAgICAgYWRhcHQ6IGZ1bmN0aW9uKF8sIG0pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubW9kZWxBZGFwdF8obSk7XG4gICAgICB9XG4gICAgfVxuICBdLFxuXG4gIG1ldGhvZHM6IFtcbiAgICBmdW5jdGlvbiBtb2RlbEFkYXB0XyhtKSB7XG4gICAgICByZXR1cm4gZm9hbS5jb3JlLk1vZGVsLmlzSW5zdGFuY2UobSkgPyBtIDpcbiAgICAgICAgICBmb2FtLmNvcmUuRW51bU1vZGVsLmlzSW5zdGFuY2UobSkgPyBtIDpcbiAgICAgICAgICBmb2FtLmNvcmUuSW5uZXJDbGFzcy5pc0luc3RhbmNlKG0pID8gdGhpcy5tb2RlbEFkYXB0XyhtLm1vZGVsKSA6XG4gICAgICAgICAgbS5jbGFzcyA/IHRoaXMubW9kZWxBZGFwdF8oZm9hbS5qc29uLnBhcnNlKG0pKSA6XG4gICAgICAgICAgZm9hbS5jb3JlLk1vZGVsLmNyZWF0ZShtKTtcbiAgICB9LFxuXG4gICAgZnVuY3Rpb24gaW5zdGFsbEluQ2xhc3MoY2xzKSB7XG4gICAgICBjbHNbdGhpcy5tb2RlbC5uYW1lXSA9IHRoaXMubW9kZWwuYnVpbGRDbGFzcygpO1xuICAgIH0sXG5cbiAgICBmdW5jdGlvbiBpbnN0YWxsSW5Qcm90byhwcm90bykge1xuICAgICAgLy8gZ2V0IGNsYXNzIGFscmVhZHkgY3JlYXRlZCBpbiBpbnN0YWxsSW5DbGFzcygpO1xuICAgICAgdmFyIG5hbWUgPSB0aGlzLm1vZGVsLm5hbWU7XG4gICAgICB2YXIgY2xzID0gcHJvdG8uY2xzX1tuYW1lXTtcblxuICAgICAgLy8gQ3JlYXRlIGEgcHJpdmF0ZV8gY2xvbmUgb2YgdGhlIENsYXNzIHdpdGggdGhlIGNyZWF0ZSgpIG1ldGhvZCBkZWNvcmF0ZWRcbiAgICAgIC8vIHRvIHBhc3MgJ3RoaXMnIGFzIHRoZSBjb250ZXh0IGlmIG5vdCBleHBsaWNpdGx5IHByb3ZpZGVkLiAgVGhpcyBlbnN1cmVzXG4gICAgICAvLyB0aGF0IHRoZSBjcmVhdGVkIG9iamVjdCBoYXMgYWNjZXNzIHRvIHRoaXMgb2JqZWN0J3MgZXhwb3J0ZWQgYmluZGluZ3MuXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvdG8sIG5hbWUsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiBpbm5lckNsYXNzR2V0dGVyKCkge1xuICAgICAgICAgIGlmICggISB0aGlzLmhhc093blByaXZhdGVfKG5hbWUpICkge1xuICAgICAgICAgICAgdmFyIHBhcmVudCA9IHRoaXM7XG4gICAgICAgICAgICB2YXIgYyAgICAgID0gT2JqZWN0LmNyZWF0ZShjbHMpO1xuXG4gICAgICAgICAgICBjLmNyZWF0ZSA9IGZ1bmN0aW9uIGlubmVyQ2xhc3NDcmVhdGUoYXJncywgY3R4KSB7XG4gICAgICAgICAgICAgIHJldHVybiBjbHMuY3JlYXRlKGFyZ3MsIGN0eCB8fCBwYXJlbnQpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRoaXMuc2V0UHJpdmF0ZV8obmFtZSwgYyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0UHJpdmF0ZV8obmFtZSk7XG4gICAgICAgIH0sXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2VcbiAgICAgIH0pO1xuICAgIH1cbiAgXVxufSk7XG5cblxuZm9hbS5DTEFTUyh7XG4gIHJlZmluZXM6ICdmb2FtLmNvcmUuTW9kZWwnLFxuICBwcm9wZXJ0aWVzOiBbXG4gICAge1xuICAgICAgY2xhc3M6ICdBeGlvbUFycmF5JyxcbiAgICAgIG9mOiAnSW5uZXJDbGFzcycsXG4gICAgICBuYW1lOiAnY2xhc3NlcycsXG4gICAgICAvLyBBIGN1c3RvbSBhZGFwdEFycmF5RWxlbWVudCBpcyBuZWVkZWQgYmVjYXVzZSB3ZSdyZVxuICAgICAgLy8gcGFzc2luZyB0aGUgbW9kZWwgZGVmaW5pdGlvbiBhcyBtb2RlbDosIHJhdGhlciB0aGFuXG4gICAgICAvLyBhcyBhbGwgb2YgdGhlIGFyZ3VtZW50cyB0byBjcmVhdGUoKS5cbiAgICAgIGFkYXB0QXJyYXlFbGVtZW50OiBmdW5jdGlvbihvKSB7XG4gICAgICAgIHJldHVybiBmb2FtLmNvcmUuSW5uZXJDbGFzcy5pc0luc3RhbmNlKG8pID9cbiAgICAgICAgICBvIDpcbiAgICAgICAgICBmb2FtLmNvcmUuSW5uZXJDbGFzcy5jcmVhdGUoe21vZGVsOiBvfSkgO1xuICAgICAgfVxuICAgIH1cbiAgXVxufSk7XG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG4vKipcbiAgQ2xhc3NlcyBjYW4gaGF2ZSBcImlubmVyLWVudW1zXCIgd2hpY2ggYXJlIGVudW1zIHdoaWNoIGFyZSBkZWZpbmVkIHdpdGhpblxuICB0aGUgc2NvcGUgb2YgYSBjbGFzcyBpdHNlbGYgcmF0aGVyIHRoYW4gYmVpbmcgdG9wLWxldmVsIGVudW1zIHdoaWNoIHJlc2lkZVxuICBpbiBhIHBhY2thZ2Ugb3IgZ2xvYmFsbHkuIFRoaXMgaGVscHMgdG8gYXZvaWQgcG9sbHV0aW5nIG5hbWVzcGFjZXMgd2l0aCBlbnVtc1xuICB3aGljaCBhcmUgb25seSB1c2VkIGJ5IGEgc2luZ2xlIGNsYXNzLlxuXG48cHJlPlxuICBFeC5cbiAgLy8gQ2xhc3NlcyBjYW4gaGF2ZSBpbm5lci1FbnVtcy5cbiAgZm9hbS5DTEFTUyh7XG4gICAgbmFtZTogJ0lubmVyRW51bVRlc3QnLFxuICAgIGVudW1zOiBbXG4gICAgICB7IG5hbWU6ICdJbm5lckVudW0nLCB2YWx1ZXM6IFtcbiAgICAgICAgeyBuYW1lOiAnT1BFTicsICAgbGFiZWw6ICdPcGVuJyAgIH0sXG4gICAgICAgIHsgbmFtZTogJ0NMT1NFRCcsIGxhYmVsOiAnQ2xvc2VkJyB9XG4gICAgICBdIH1cbiAgICBdLFxuICAgIG1ldGhvZHM6IFtcbiAgICAgIGZ1bmN0aW9uIGluaXQoKSB7XG4gICAgICAgIGxvZyh0aGlzLklubmVyRW51bS5PUEVOLCB0aGlzLklubmVyRW51bS5DTE9TRUQpXG4gICAgICB9XG4gICAgXVxuICB9KTtcbiAgSW5uZXJFbnVtVGVzdC5jcmVhdGUoKTtcbjwvcHJlPlxuKi9cbmZvYW0uQ0xBU1Moe1xuICBwYWNrYWdlOiAnZm9hbS5jb3JlJyxcbiAgbmFtZTogJ0lubmVyRW51bScsXG5cbiAgZG9jdW1lbnRhdGlvbjogJ0F4aW9tIGZvciBkZWZpbmluZyBpbm5lci1lbnVtcy4gQW4gaW5uZXItZW51bSBpcyBhbiBlbnVtIGRlZmluZWQgaW4gdGhlIHNjb3BlIG9mIHRoZSBvdXRlci9vd25lciBjbGFzcy4gVGhpcyBhdm9pZHMgcG9sdXRpbmcgdGhlIHBhY2thZ2UgbmFtZXNwYWNlIHdpdGggZW51bXMgd2hpY2ggYXJlIG9ubHkgdXNlZCBpbnRlcm5hbGx5IGJ5IGEgY2xhc3MuJyxcblxuICBwcm9wZXJ0aWVzOiBbXG4gICAge1xuICAgICAgbmFtZTogJ25hbWUnLFxuICAgICAgZ2V0dGVyOiBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMubW9kZWwubmFtZTsgfVxuICAgIH0sXG4gICAge1xuICAgICAgbmFtZTogJ21vZGVsJyxcbiAgICAgIGFkYXB0OiBmdW5jdGlvbihfLCBtKSB7XG4gICAgICAgIHJldHVybiBmb2FtLmNvcmUuRW51bU1vZGVsLmlzSW5zdGFuY2UobSkgPyBtIDogZm9hbS5jb3JlLkVudW1Nb2RlbC5jcmVhdGUobSk7XG4gICAgICB9XG4gICAgfVxuICBdLFxuXG4gIG1ldGhvZHM6IFtcbiAgICBmdW5jdGlvbiBpbnN0YWxsSW5DbGFzcyhjbHMpIHtcbiAgICAgIGNsc1t0aGlzLm1vZGVsLm5hbWVdID0gdGhpcy5tb2RlbC5idWlsZENsYXNzKCk7XG4gICAgfSxcblxuICAgIGZ1bmN0aW9uIGluc3RhbGxJblByb3RvKHByb3RvKSB7XG4gICAgICAvLyBnZXQgY2xhc3MgYWxyZWFkeSBjcmVhdGVkIGluIGluc3RhbGxJbkNsYXNzKCk7XG4gICAgICB2YXIgbmFtZSA9IHRoaXMubW9kZWwubmFtZTtcbiAgICAgIHZhciBjbHMgPSBwcm90by5jbHNfW25hbWVdO1xuICAgICAgcHJvdG9bbmFtZV0gPSBjbHM7XG4gICAgfVxuICBdXG59KTtcblxuXG5mb2FtLkNMQVNTKHtcbiAgcmVmaW5lczogJ2ZvYW0uY29yZS5Nb2RlbCcsXG4gIHByb3BlcnRpZXM6IFtcbiAgICB7XG4gICAgICBjbGFzczogJ0F4aW9tQXJyYXknLFxuICAgICAgb2Y6ICdJbm5lckVudW0nLFxuICAgICAgbmFtZTogJ2VudW1zJyxcbiAgICAgIC8vIEEgY3VzdG9tIGFkYXB0QXJyYXlFbGVtZW50IGlzIG5lZWRlZCBiZWNhdXNlIHdlJ3JlXG4gICAgICAvLyBwYXNzaW5nIHRoZSBtb2RlbCBkZWZpbml0aW9uIGFzIG1vZGVsOiwgcmF0aGVyIHRoYW5cbiAgICAgIC8vIGFzIGFsbCBvZiB0aGUgYXJndW1lbnRzIHRvIGNyZWF0ZSgpLlxuICAgICAgYWRhcHRBcnJheUVsZW1lbnQ6IGZ1bmN0aW9uKG8pIHtcbiAgICAgICAgcmV0dXJuIGZvYW0uY29yZS5Jbm5lckVudW0uaXNJbnN0YW5jZShvKSA/XG4gICAgICAgICAgbyA6XG4gICAgICAgICAgZm9hbS5jb3JlLklubmVyRW51bS5jcmVhdGUoe21vZGVsOiBvfSkgO1xuICAgICAgfVxuICAgIH1cbiAgXVxufSk7XG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5mb2FtLkNMQVNTKHtcbiAgcGFja2FnZTogJ2ZvYW0uY29yZScsXG4gIG5hbWU6ICdJbXBsZW1lbnRzJyxcblxuICBkb2N1bWVudGF0aW9uOiBmdW5jdGlvbigpIHsvKlxuICAgIEF4aW9tIGZvciBkZWNsYXJpbmcgaW50ZW50IHRvIGltcGxlbWVudCBhbiBpbnRlcmZhY2UuXG5cbiAgICBTaW5jZSBpbnRlcmZhY2VzIGNhbiBhbHNvIGhhdmUgaW1wbGVtZW50YXRpb25zLCBpdFxuICAgIGNhbiBhbHNvIGJlIHVzZWQgdG8gcHJvdmlkZSBtaXgtaW5zLCB3aGljaCBpcyBhIHNhZmUgZm9ybSBvZlxuICAgIG11bHRpcGxlLWluaGVyaXRhbmNlLlxuICA8cHJlPlxuICAgIEV4LlxuICAgIGZvYW0uQ0xBU1Moe1xuICAgICAgbmFtZTogJ1NhbGFyeUknLFxuICAgICAgcHJvcGVydGllczogWyAnc2FsYXJ5JyBdXG4gICAgfSk7XG5cbiAgICBmb2FtLkNMQVNTKHtcbiAgICAgIG5hbWU6ICdFbXBsb3llZScsXG4gICAgICBleHRlbmRzOiAnUGVyc29uJyxcbiAgICAgIGltcGxlbWVudHM6IFsgJ1NhbGFyeUknIF1cbiAgICB9KTtcbiAgPC9wcmU+XG4gIEVtcGxveWVlIGV4dGVuZHMgUGVyc29uIHRocm91Z2ggcmVndWxhciBpbmhlcml0YW5jZSwgYnV0XG4gIHRoZSBheGlvbXMgZnJvbSBTYWxhcnlJIGFyZSBhbHNvIGFkZGVkIHRvIHRoZSBjbGFzcy5cbiAgQW55IG51bWJlciBvZiBtaXgtaW5zL2ludGVyZmFjZXMgY2FuIGJlIHNwZWNpZmllZC5cbiAgKi99LFxuXG4gIHByb3BlcnRpZXM6IFtcbiAgICB7XG4gICAgICBuYW1lOiAnbmFtZScsXG4gICAgICBnZXR0ZXI6IGZ1bmN0aW9uKCkgeyByZXR1cm4gJ2ltcGxlbWVudHNfJyArIHRoaXMucGF0aDsgfVxuICAgIH0sXG4gICAgJ3BhdGgnXG4gIF0sXG5cbiAgbWV0aG9kczogW1xuICAgIGZ1bmN0aW9uIGluc3RhbGxJbkNsYXNzKGNscykge1xuICAgICAgdmFyIG0gPSB0aGlzLmxvb2t1cCh0aGlzLnBhdGgpO1xuICAgICAgaWYgKCAhIG0gKSB0aHJvdyAnTm8gc3VjaCBpbnRlcmZhY2Ugb3IgdHJhaXQ6ICcgKyB0aGlzLnBhdGg7XG5cbiAgICAgIC8vIFRPRE86IGNsb25lIHRoZXNlIGF4aW9tcyBzaW5jZSB0aGV5IGNvdWxkIGJlIHJldXNlZCBhbmQgdGhlbiB3b3VsZFxuICAgICAgLy8gaGF2ZSB0aGUgd3Jvbmcgc291cmNlQ2xzXztcblxuICAgICAgLy8gVGhpcyBuZXh0IHBhcnQgaXMgYSBiaXQgdHJpY2t5LlxuICAgICAgLy8gSWYgd2UgaW5zdGFsbCBhIG1peGluIGFuZCB0aGVuIG92ZXJyaWRlIHByb3BlcnRpZXMgb2Ygb25lIG9mIHRoZVxuICAgICAgLy8gUHJvcGVydGllcyBmcm9tIHRoZSBtaXhpbiwgdGhlIG1peGluIFByb3BlcnR5IHdpbGwgc2VlIHRoZSBvdmVycmlkZGVuXG4gICAgICAvLyBQcm9wZXJ0eSBhcyBpdHMgc3VwZXItcHJvcCwgd2hpY2ggaXMgd3JvbmcuIFNvLCB3ZSBpbnNlcnQgYSBuZXcgbGV2ZWxcbiAgICAgIC8vIGluIHRoZSBheGlvbU1hcF8gYmV0d2VlbiB0aGUgY3VycmVudCBheGlvbU1hcF8gYW5kIGl0cyBwcm90b3R5cGUsIGFuZFxuICAgICAgLy8gdGhlbiBpbnN0YWxsIHRoZSBtaXhpbiB0aGVyZS5cblxuICAgICAgLy8gQ3VycmVudCBBeGlvbU1hcFxuICAgICAgdmFyIGFNYXAgPSBjbHMuYXhpb21NYXBfO1xuXG4gICAgICAvLyBOZXcgbWl4aW4gQXhpb21NYXAgdG8gaW5zdGFsbCBpbnRvXG4gICAgICB2YXIgc01hcCA9IE9iamVjdC5jcmVhdGUoYU1hcC5fX3Byb3RvX18pO1xuXG4gICAgICAvLyBJbnNlcnQgbmV3IEF4aW9tTWFwIGJldHdlZW4gY3VycmVudCBhbmQgaXRzIHBhcmVudFxuICAgICAgYU1hcC5fX3Byb3RvX18gPSBzTWFwO1xuXG4gICAgICAvLyBUZW1wb3JhcmlseSBzZXQgdGhlIGNsYXNzJ2VzIEF4aW9tTWFwIHRvIHNNYXAgc28gdGhhdFxuICAgICAgLy8gbWl4aW4gYXhpb21zIGdldCBpbnN0YWxsZWQgaW50byBpdC5cbiAgICAgIGNscy5heGlvbU1hcF8gPSBzTWFwO1xuXG4gICAgICBjbHMuaW5zdGFsbEF4aW9tcyhtLmdldE93bkF4aW9tcygpKTtcblxuICAgICAgLy8gUHV0IHRoZSBvcmlnaW5hbCBBeGlvbU1hcCBiYWNrLCB3aXRoIHRoZSBpbnNlcnRlZCBwYXJlbnQuXG4gICAgICBjbHMuYXhpb21NYXBfID0gYU1hcDtcbiAgICB9XG4gIF1cbn0pO1xuXG5cbmZvYW0uQ0xBU1Moe1xuICByZWZpbmVzOiAnZm9hbS5jb3JlLk1vZGVsJyxcbiAgcHJvcGVydGllczogW1xuICAgIHtcbiAgICAgIGNsYXNzOiAnQXhpb21BcnJheScsXG4gICAgICBvZjogJ0ltcGxlbWVudHMnLFxuICAgICAgbmFtZTogJ2ltcGxlbWVudHMnLFxuICAgICAgYWRhcHRBcnJheUVsZW1lbnQ6IGZ1bmN0aW9uKG8pIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiBvID09PSAnc3RyaW5nJyA/XG4gICAgICAgICAgZm9hbS5jb3JlLkltcGxlbWVudHMuY3JlYXRlKHtwYXRoOiBvfSkgOlxuICAgICAgICAgIGZvYW0uY29yZS5JbXBsZW1lbnRzLmNyZWF0ZShvKSAgICAgICAgIDtcbiAgICAgIH1cbiAgICB9XG4gIF1cbn0pO1xuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTYgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuLyoqXG4gIEltcG9ydHMgYW5kIEV4cG9ydHMgcHJvdmlkZSBpbXBsaWNpdCBDb250ZXh0IGRlcGVuZGVuY3kgbWFuYWdlbWVudC5cblxuICBBIGNsYXNzIGNhbiBsaXN0IHdoaWNoIHZhbHVlcyBpdCByZXF1aXJlcyBmcm9tIHRoZSBDb250ZXh0LCBhbmQgdGhlblxuICB0aGVzZSB2YWx1ZXMgd2lsbCBiZSBhZGRlZCB0byB0aGUgb2JqZWN0IGl0c2VsZiBzbyB0aGF0IGl0IGRvZXNuJ3QgbmVlZFxuICB0byBleHBsaWNpdGx5IHdvcmsgd2l0aCB0aGUgQ29udGV4dC5cblxuICBBIGNsYXNzIGNhbiBsaXN0IHdoaWNoIHZhbHVlcyAocHJvcGVydGllcywgbWV0aG9kcywgb3IgbWV0aG9kLWxpa2UgYXhpb21zKVxuICB0aGF0IGl0IGV4cG9ydHMsIGFuZCB0aGVzZSB3aWxsIGF1dG9tYXRpY2FsbHkgYmUgYWRkZWQgdG8gdGhlIG9iamVjdCdzXG4gIHN1Yi1Db250ZXh0LiBUaGUgb2JqZWN0J3Mgc3ViLUNvbnRleHQgaXMgdGhlIGNvbnRleHQgdGhhdCBpcyB1c2VkIHdoZW5cbiAgbmV3IG9iamVjdHMgYXJlIGNyZWF0ZWQgYnkgdGhlIG9iamVjdC5cblxuICBFeC5cbjxwcmU+XG5mb2FtLkNMQVNTKHtcbiAgbmFtZTogJ0ltcG9ydHNUZXN0JyxcblxuICBpbXBvcnRzOiBbICdsb2cnLCAnd2FybicgXSxcblxuICBtZXRob2RzOiBbXG4gICAgZnVuY3Rpb24gZm9vKCkge1xuICAgICAgdGhpcy5sb2coJ2xvZyBmb28gZnJvbSBJbXBvcnRUZXN0Jyk7XG4gICAgICB0aGlzLndhcm4oJ3dhcm4gZm9vIGZyb20gSW1wb3J0VGVzdCcpO1xuICAgIH1cbiAgXVxufSk7XG5cbmZvYW0uQ0xBU1Moe1xuICBuYW1lOiAnRXhwb3J0c1Rlc3QnLFxuICByZXF1aXJlczogWyAnSW1wb3J0c1Rlc3QnIF0sXG5cbiAgZXhwb3J0czogWyAnbG9nJywgJ2xvZyBhcyB3YXJuJyBdLFxuXG4gIG1ldGhvZHM6IFtcbiAgICBmdW5jdGlvbiBpbml0KCkge1xuICAgICAgLy8gSW1wb3J0c1Rlc3Qgd2lsbCBiZSBjcmVhdGVkIGluIEV4cG9ydFRlc3Qnc1xuICAgICAgLy8gc3ViLUNvbnRleHQsIHdoaWNoIHdpbGwgaGF2ZSAnbG9nJyBhbmQgJ3dhcm4nXG4gICAgICAvLyBleHBvcnRlZC5cbiAgICAgIHRoaXMuSW1wb3J0c1Rlc3QuY3JlYXRlKCkuZm9vKCk7XG4gICAgfSxcbiAgICBmdW5jdGlvbiBsb2cobXNnKSB7XG4gICAgICBjb25zb2xlLmxvZygnbG9nOicsIG1zZyk7XG4gICAgfVxuICBdXG59KTtcbjwvcHJlPlxuXG4gIEFsaWFzaW5nOlxuICAgIEJpbmRpbmdzIGNhbiBiZSByZW5hbWVkIG9yIGFsaWFzZWQgd2hlbiB0aGV5J3JlIGltcG9ydGVkIG9yIGV4cG9ydGVkIHVzaW5nXG4gICAgJ2FzIGFsaWFzJy5cblxuICBFeGFtcGxlczpcbiAgICAvLyBpbXBvcnQgJ3VzZXJEQU8nIGZyb20gdGhlIENvbnRleHQgYW5kIG1ha2UgYXZhaWxhYmxlIGFzIHRoaXMuZGFvXG4gICAgaW1wb3J0czogWyAndXNlckRBTyBhcyBkYW8nIF1cblxuICAgIC8vIGV4cG9ydCBteSBsb2cgbWV0aG9kIGFzICd3YXJuJ1xuICAgIGV4cG9ydHM6IFsgJ2xvZyBhcyB3YXJuJyBdXG5cbiAgICAvLyBJZiB0aGUgYXhpb20gdG8gYmUgZXhwb3J0ZWQgaXNuJ3QgbmFtZWQsIGJ1dCBqdXN0IGFsaWFzZWQsIHRoZW4gJ3RoaXMnXG4gICAgLy8gaXMgZXhwb3J0ZWQgYXMgdGhlIG5hbWVkIGFsaWFzLiAgVGhpcyBpcyBob3cgb2JqZWN0cyBleHBvcnQgdGhlbXNlbHZlcy5cbiAgICBleHBvcnRzOiBbICdhcyBDb250cm9sbGVyJyBdXG5cbiAgU2VlIENvbnRleHQuanMuXG4gKi9cbmZvYW0uQ0xBU1Moe1xuICBwYWNrYWdlOiAnZm9hbS5jb3JlJyxcbiAgbmFtZTogJ0ltcG9ydCcsXG5cbiAgZG9jdW1lbnRhdGlvbjogJ0F4aW9tIHRvIEltcG9ydCBhIENvbnRleHQgVmFsdWUuJyxcblxuICBwcm9wZXJ0aWVzOiBbXG4gICAge1xuICAgICAgY2xhc3M6ICdTdHJpbmcnLFxuICAgICAgbmFtZTogJ25hbWUnXG4gICAgfSxcbiAgICAna2V5JyxcbiAgICB7XG4gICAgICBjbGFzczogJ0Jvb2xlYW4nLFxuICAgICAgbmFtZTogJ3JlcXVpcmVkJyxcbiAgICAgIHZhbHVlOiB0cnVlXG4gICAgfSxcbiAgICB7XG4gICAgICBuYW1lOiAnc2xvdE5hbWVfJyxcbiAgICAgIGZhY3Rvcnk6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gZm9hbS5TdHJpbmcudG9TbG90TmFtZSh0aGlzLm5hbWUpO1xuICAgICAgfVxuICAgIH1cbiAgXSxcblxuICBtZXRob2RzOiBbXG4gICAgZnVuY3Rpb24gaW5zdGFsbEluUHJvdG8ocHJvdG8pIHtcbiAgICAgIGZvYW0uYXNzZXJ0KHRoaXMua2V5LCAnTm8ga2V5IGZvciBpbXBvcnQ6ICcgKyB0aGlzLm5hbWUpO1xuXG4gICAgICB2YXIgbmFtZSAgICAgPSB0aGlzLm5hbWU7XG4gICAgICB2YXIga2V5ICAgICAgPSBmb2FtLlN0cmluZy50b1Nsb3ROYW1lKHRoaXMua2V5KTtcbiAgICAgIHZhciBzbG90TmFtZSA9IHRoaXMuc2xvdE5hbWVfO1xuICAgICAgdmFyIHJlcXVpcmVkID0gdGhpcy5yZXF1aXJlZDtcblxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb3RvLCBzbG90TmFtZSwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uIGltcG9ydHNTbG90R2V0dGVyKCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLl9fY29udGV4dF9fW2tleV07XG4gICAgICAgIH0sXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlXG4gICAgICB9KTtcblxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb3RvLCBuYW1lLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gaW1wb3J0c0dldHRlcigpICB7XG4gICAgICAgICAgdmFyIHNsb3QgPSB0aGlzW3Nsb3ROYW1lXTtcbiAgICAgICAgICBpZiAoIHNsb3QgKSByZXR1cm4gc2xvdC5nZXQoKTtcbiAgICAgICAgICBpZiAoIHJlcXVpcmVkICkgY29uc29sZS53YXJuKCdBY2Nlc3MgbWlzc2luZyBpbXBvcnQ6JywgbmFtZSk7XG4gICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiBpbXBvcnRzU2V0dGVyKHYpIHtcbiAgICAgICAgICB2YXIgc2xvdCA9IHRoaXNbc2xvdE5hbWVdO1xuICAgICAgICAgIGlmICggc2xvdCApXG4gICAgICAgICAgICBzbG90LnNldCh2KTtcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ0F0dGVtcHQgdG8gc2V0IG1pc3NpbmcgaW1wb3J0OicsIG5hbWUpO1xuICAgICAgICB9LFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlXG4gICAgICB9KTtcbiAgICB9LFxuXG4gICAgZnVuY3Rpb24gdG9TbG90KG9iaikge1xuICAgICAgcmV0dXJuIG9ialt0aGlzLnNsb3ROYW1lX107XG4gICAgfVxuICBdXG59KTtcblxuXG5mb2FtLkNMQVNTKHtcbiAgcGFja2FnZTogJ2ZvYW0uY29yZScsXG4gIG5hbWU6ICdFeHBvcnQnLFxuXG4gIGRvY3VtZW50YXRpb246ICdBeGlvbSB0byBFeHBvcnQgYSBTdWItQ29udGV4dCBWYWx1ZS4nLFxuXG4gIHByb3BlcnRpZXM6IFtcbiAgICB7XG4gICAgICBjbGFzczogJ1N0cmluZycsXG4gICAgICBuYW1lOiAnbmFtZSdcbiAgICB9LFxuICAgIHtcbiAgICAgIG5hbWU6ICdleHBvcnROYW1lJyxcbiAgICAgIHBvc3RTZXQ6IGZ1bmN0aW9uKF8sIG5hbWUpIHtcbiAgICAgICAgdGhpcy5uYW1lID0gJ2V4cG9ydF8nICsgbmFtZTtcbiAgICAgIH1cbiAgICB9LFxuICAgICdrZXknXG4gIF0sXG5cbiAgbWV0aG9kczogW1xuICAgIGZ1bmN0aW9uIGdldEV4cG9ydE1hcCgpIHtcbiAgICAgIHZhciBtID0ge307XG4gICAgICB2YXIgYnMgPSB0aGlzLmNsc18uZ2V0QXhpb21zQnlDbGFzcyhmb2FtLmNvcmUuRXhwb3J0KTtcbiAgICAgIGZvciAoIHZhciBpID0gMCA7IGkgPCBicy5sZW5ndGggOyBpKysgKSB7XG4gICAgICAgIHZhciBiID0gYnNbaV07XG5cbiAgICAgICAgaWYgKCBiLmtleSApIHtcbiAgICAgICAgICB2YXIgcGF0aCA9IGIua2V5LnNwbGl0KCcuJyk7XG5cbiAgICAgICAgICB2YXIgYSA9IHRoaXMuY2xzXy5nZXRBeGlvbUJ5TmFtZShwYXRoWzBdKTtcblxuICAgICAgICAgIGZvYW0uYXNzZXJ0KCEhYSwgJ1Vua25vd24gYXhpb206IFwiJywgcGF0aFswXSwgJ1wiIGluIG1vZGVsOiAnLFxuICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY2xzXy5pZCwgXCIsIHRyeWluZyB0byBleHBvcnQ6ICdcIiwgYi5rZXksIFwiJ1wiKTtcblxuICAgICAgICAgIC8vIEF4aW9tcyBoYXZlIGFuIG9wdGlvbiBvZiB3cmFwcGluZyBhIHZhbHVlIGZvciBleHBvcnQuXG4gICAgICAgICAgLy8gVGhpcyBjb3VsZCBiZSB1c2VkIHRvIGJpbmQgYSBtZXRob2QgdG8gJ3RoaXMnLCBmb3IgZXhhbXBsZS5cbiAgICAgICAgICB2YXIgZSA9IGEuZXhwb3J0QXMgPyBhLmV4cG9ydEFzKHRoaXMsIHBhdGguc2xpY2UoMSkpIDogdGhpc1twYXRoWzBdXTtcblxuICAgICAgICAgIG1bYi5leHBvcnROYW1lXSA9IGU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gRXguICdhcyBCYW5rJywgd2hpY2ggZXhwb3J0cyBhbiBpbXBsaWNpdCAndGhpcydcbiAgICAgICAgICBtW2IuZXhwb3J0TmFtZV0gPSB0aGlzO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbTtcbiAgICB9LFxuXG4gICAgZnVuY3Rpb24gaW5zdGFsbEluUHJvdG8ocHJvdG8pIHtcbiAgICAgIGlmICggT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHByb3RvLCAnX19zdWJDb250ZXh0X18nICkgKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIGF4aW9tID0gdGhpcztcblxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb3RvLCAnX19zdWJDb250ZXh0X18nLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gWUdldHRlcigpIHtcbiAgICAgICAgICBpZiAoICEgdGhpcy5oYXNPd25Qcml2YXRlXygnX19zdWJDb250ZXh0X18nKSApIHtcbiAgICAgICAgICAgIHZhciBjdHggPSB0aGlzLl9fY29udGV4dF9fO1xuICAgICAgICAgICAgdmFyIG0gPSBheGlvbS5nZXRFeHBvcnRNYXAuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgIHRoaXMuc2V0UHJpdmF0ZV8oJ19fc3ViQ29udGV4dF9fJywgY3R4LmNyZWF0ZVN1YkNvbnRleHQobSkpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiB0aGlzLmdldFByaXZhdGVfKCdfX3N1YkNvbnRleHRfXycpO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQXR0ZW1wdGVkIHRvIHNldCB1bnNldHRhYmxlIF9fc3ViQ29udGV4dF9fIGluICcgKyB0aGlzLmNsc18uaWQpO1xuICAgICAgICB9LFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlXG4gICAgICB9KTtcbiAgICB9XG4gIF1cbn0pO1xuXG5cbmZvYW0uQ0xBU1Moe1xuICByZWZpbmVzOiAnZm9hbS5jb3JlLk1vZGVsJyxcblxuICBwcm9wZXJ0aWVzOiBbXG4gICAge1xuICAgICAgY2xhc3M6ICdBeGlvbUFycmF5JyxcbiAgICAgIG9mOiAnSW1wb3J0JyxcbiAgICAgIG5hbWU6ICdpbXBvcnRzJyxcbiAgICAgIGFkYXB0QXJyYXlFbGVtZW50OiBmdW5jdGlvbihvKSB7XG4gICAgICAgIGlmICggdHlwZW9mIG8gPT09ICdzdHJpbmcnICkge1xuICAgICAgICAgIHZhciBhICAgICAgICA9IG8uc3BsaXQoJyBhcyAnKTtcbiAgICAgICAgICB2YXIga2V5ICAgICAgPSBhWzBdO1xuICAgICAgICAgIHZhciBvcHRpb25hbCA9IGtleS5lbmRzV2l0aCgnPycpO1xuICAgICAgICAgIGlmICggb3B0aW9uYWwgKSBrZXkgPSBrZXkuc2xpY2UoMCwga2V5Lmxlbmd0aC0xKTtcbiAgICAgICAgICByZXR1cm4gZm9hbS5jb3JlLkltcG9ydC5jcmVhdGUoe25hbWU6IGFbMV0gfHwga2V5LCBrZXk6IGtleSwgcmVxdWlyZWQ6ICEgb3B0aW9uYWx9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmb2FtLmNvcmUuSW1wb3J0LmNyZWF0ZShvKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHtcbiAgICAgIGNsYXNzOiAnQXhpb21BcnJheScsXG4gICAgICBvZjogJ0V4cG9ydCcsXG4gICAgICBuYW1lOiAnZXhwb3J0cycsXG4gICAgICBhZGFwdEFycmF5RWxlbWVudDogZnVuY3Rpb24obykge1xuICAgICAgICBpZiAoIHR5cGVvZiBvID09PSAnc3RyaW5nJyApIHtcbiAgICAgICAgICB2YXIgYSA9IG8uc3BsaXQoJyAnKTtcblxuICAgICAgICAgIHN3aXRjaCAoIGEubGVuZ3RoICkge1xuICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICByZXR1cm4gZm9hbS5jb3JlLkV4cG9ydC5jcmVhdGUoe2V4cG9ydE5hbWU6IGFbMF0sIGtleTogYVswXX0pO1xuXG4gICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgIC8vIEV4cG9ydCAndGhpcydcbiAgICAgICAgICAgICAgZm9hbS5hc3NlcnQoXG4gICAgICAgICAgICAgICAgICBhWzBdID09PSAnYXMnLFxuICAgICAgICAgICAgICAgICAgJ0ludmFsaWQgZXhwb3J0IHN5bnRheDoga2V5IFthcyB2YWx1ZV0gfCBhcyB2YWx1ZScpO1xuICAgICAgICAgICAgICByZXR1cm4gZm9hbS5jb3JlLkV4cG9ydC5jcmVhdGUoe2V4cG9ydE5hbWU6IGFbMV0sIGtleTogbnVsbH0pO1xuXG4gICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgIGZvYW0uYXNzZXJ0KFxuICAgICAgICAgICAgICAgICAgYVsxXSA9PT0gJ2FzJyxcbiAgICAgICAgICAgICAgICAgICdJbnZhbGlkIGV4cG9ydCBzeW50YXg6IGtleSBbYXMgdmFsdWVdIHwgYXMgdmFsdWUnKTtcbiAgICAgICAgICAgICAgcmV0dXJuIGZvYW0uY29yZS5FeHBvcnQuY3JlYXRlKHtleHBvcnROYW1lOiBhWzJdLCBrZXk6IGFbMF19KTtcblxuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgZm9hbS5hc3NlcnQoZmFsc2UsXG4gICAgICAgICAgICAgICAgICAnSW52YWxpZCBleHBvcnQgc3ludGF4OiBrZXkgW2FzIHZhbHVlXSB8IGFzIHZhbHVlJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZvYW0uY29yZS5FeHBvcnQuY3JlYXRlKG8pO1xuICAgICAgfVxuICAgIH1cbiAgXVxufSk7XG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG4vKipcbiAgTGlzdGVuZXJzIGFyZSBoaWdoLWxldmVsIHByZS1ib3VuZCBldmVudCBjYWxsLWJhY2tzLlxuPHByZT5cbiAgRXguXG4gIGZvYW0uQ0xBU1Moe1xuICAgIG5hbWU6ICdTcHJpbmtsZXInLFxuICAgIGxpc3RlbmVyczogW1xuXG4gICAgICAvLyBzaG9ydC1mb3JtXG4gICAgICBmdW5jdGlvbiBvbkFsYXJtKCkgeyAuLi4gfSxcblxuICAgICAgLy8gbG9uZy1mb3JtXG4gICAgICB7XG4gICAgICAgIG5hbWU6ICdvbkNsZWFyJyxcbiAgICAgICAgaXNGcmFtZWQ6IHRydWUsXG4gICAgICAgIGNvZGU6IGZ1bmN0aW9uKCkgeyAuLi4gfVxuICAgICAgfVxuICAgIF1cbiAgfSk7XG48L3ByZT5cbiAgWW91IG1pZ2h0IHVzZSB0aGUgYWJvdmUgb25BbGFybSBsaXN0ZW5lciBsaWtlIHRoaXM6XG4gIGFsYXJtLnJpbmcuc3ViKHNwcmlua2VyLm9uQWxhcm0pO1xuPHA+XG4gIE5vdGljZSwgdGhhdCBub3JtYWxseSBKUyBtZXRob2RzIGZvcmdldCB3aGljaCBvYmplY3QgdGhleSBiZWxvbmdcbiAgdG8gc28geW91IHdvdWxkIG5lZWQgdG8gZG8gc29tZXRoaW5nIGxpa2U6XG4gICAgPHByZT5hbGFybS5yaW5nLnN1YihzcHJpbmtlci5vbkFsYXJtLmJpbmQoc3ByaW5rbGVyKSk7PC9wcmU+XG4gIEJ1dCBsaXN0ZW5lcnMgYXJlIHByZS1ib3VuZC5cbiovXG4vLyBUT0RPKGtncik6IEFkZCBTVVBFUiBzdXBwb3J0LlxuZm9hbS5DTEFTUyh7XG4gIHBhY2thZ2U6ICdmb2FtLmNvcmUnLFxuICBuYW1lOiAnTGlzdGVuZXInLFxuICBleHRlbmRzOiAnZm9hbS5jb3JlLkFic3RyYWN0TWV0aG9kJyxcblxuICByZXF1aXJlczogW1xuICAgICdmb2FtLmNvcmUuQXJndW1lbnQnLFxuICBdLFxuXG4gIHByb3BlcnRpZXM6IFtcbiAgICB7IGNsYXNzOiAnQm9vbGVhbicsIG5hbWU6ICdpc0ZyYW1lZCcsICAgdmFsdWU6IGZhbHNlIH0sXG4gICAgeyBjbGFzczogJ0Jvb2xlYW4nLCBuYW1lOiAnaXNNZXJnZWQnLCAgIHZhbHVlOiBmYWxzZSB9LFxuICAgIHsgY2xhc3M6ICdJbnQnLCAgICAgbmFtZTogJ21lcmdlRGVsYXknLCB2YWx1ZTogMTYsIHVuaXRzOiAnbXMnIH0sXG4gICAge1xuICAgICAgbmFtZTogJ2FyZ3MnLFxuICAgICAgZmFjdG9yeTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgdGhpcy5Bcmd1bWVudC5jcmVhdGUoe1xuICAgICAgICAgICAgbmFtZTogJ3N1YicsXG4gICAgICAgICAgICBqYXZhVHlwZTogJ2ZvYW0uY29yZS5EZXRhY2hhYmxlJ1xuICAgICAgICAgIH0pXG4gICAgICAgIF07XG4gICAgICB9XG4gICAgfVxuICBdLFxuXG4gIG1ldGhvZHM6IFtcbiAgICBmdW5jdGlvbiBpbnN0YWxsSW5Qcm90byhwcm90bywgc3VwZXJBeGlvbSkge1xuICAgICAgLy8gVGhpcyBjYW4gaGFwcGVuIHdoZW4gdGhlcmUncyBubyBqcyBpbXBsZW1lbnRhdGlvbiBvZiBhIGxpc3RlbmVyLlxuICAgICAgaWYgKCAhIHRoaXMuY29kZSApIHJldHVybjtcblxuICAgICAgZm9hbS5hc3NlcnQoXG4gICAgICAgICEgc3VwZXJBeGlvbSB8fFxuICAgICAgICAgIGZvYW0uY29yZS5MaXN0ZW5lci5pc0luc3RhbmNlKHN1cGVyQXhpb20pLFxuICAgICAgICAnQXR0ZW1wdCB0byBvdmVycmlkZSBub24tbGlzdGVuZXInLCB0aGlzLm5hbWUpO1xuXG4gICAgICB2YXIgbmFtZSAgICAgICA9IHRoaXMubmFtZTtcbiAgICAgIHZhciBjb2RlICAgICAgID0gdGhpcy5vdmVycmlkZV8ocHJvdG8sIGZvYW0uRnVuY3Rpb24uc2V0TmFtZSh0aGlzLmNvZGUsIG5hbWUpLCBzdXBlckF4aW9tKTtcbiAgICAgIHZhciBpc01lcmdlZCAgID0gdGhpcy5pc01lcmdlZDtcbiAgICAgIHZhciBpc0ZyYW1lZCAgID0gdGhpcy5pc0ZyYW1lZDtcbiAgICAgIHZhciBtZXJnZURlbGF5ID0gdGhpcy5tZXJnZURlbGF5O1xuXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvdG8sIG5hbWUsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiBsaXN0ZW5lckdldHRlcigpIHtcbiAgICAgICAgICBpZiAoIHRoaXMuY2xzXy5wcm90b3R5cGUgPT09IHRoaXMgKSByZXR1cm4gY29kZTtcblxuICAgICAgICAgIGlmICggISB0aGlzLmhhc093blByaXZhdGVfKG5hbWUpICkge1xuICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICAgICAgdmFyIGwgPSBmdW5jdGlvbihzdWIpIHtcbiAgICAgICAgICAgICAgLy8gSXMgaXQgcG9zc2libGUgdG8gZGV0ZWN0IHN0YWxlIHN1YnNjcmlwdGlvbnM/XG4gICAgICAgICAgICAgIC8vIGllLiBhZnRlciBhbiBvYmplY3QgaGFzIGJlZW4gZGV0YWNoZWQuXG4gICAgICAgICAgICAgIHJldHVybiBjb2RlLmFwcGx5KHNlbGYsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBpZiAoIGlzTWVyZ2VkICkge1xuICAgICAgICAgICAgICBsID0gdGhpcy5fX2NvbnRleHRfXy5tZXJnZWQobCwgbWVyZ2VEZWxheSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKCBpc0ZyYW1lZCApIHtcbiAgICAgICAgICAgICAgbCA9IHRoaXMuX19jb250ZXh0X18uZnJhbWVkKGwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5zZXRQcml2YXRlXyhuYW1lLCBsKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gdGhpcy5nZXRQcml2YXRlXyhuYW1lKTtcbiAgICAgICAgfSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZVxuICAgICAgfSk7XG4gICAgfVxuICBdXG59KTtcblxuXG5mb2FtLkNMQVNTKHtcbiAgcmVmaW5lczogJ2ZvYW0uY29yZS5Nb2RlbCcsXG5cbiAgcHJvcGVydGllczogW1xuICAgIHtcbiAgICAgIGNsYXNzOiAnQXhpb21BcnJheScsXG4gICAgICBvZjogJ0xpc3RlbmVyJyxcbiAgICAgIG5hbWU6ICdsaXN0ZW5lcnMnLFxuICAgICAgYWRhcHRBcnJheUVsZW1lbnQ6IGZ1bmN0aW9uKG8pIHtcbiAgICAgICAgaWYgKCB0eXBlb2YgbyA9PT0gJ2Z1bmN0aW9uJyApIHtcbiAgICAgICAgICB2YXIgbmFtZSA9IGZvYW0uRnVuY3Rpb24uZ2V0TmFtZShvKTtcbiAgICAgICAgICBmb2FtLmFzc2VydChuYW1lLCAnTGlzdGVuZXIgbXVzdCBiZSBuYW1lZCcpO1xuICAgICAgICAgIHJldHVybiBmb2FtLmNvcmUuTGlzdGVuZXIuY3JlYXRlKHtuYW1lOiBuYW1lLCBjb2RlOiBvfSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZm9hbS5jb3JlLkxpc3RlbmVyLmlzSW5zdGFuY2UobykgP1xuICAgICAgICAgICAgbyA6XG4gICAgICAgICAgICBmb2FtLmNvcmUuTGlzdGVuZXIuY3JlYXRlKG8pIDtcbiAgICAgIH1cbiAgICB9XG4gIF1cbn0pO1xuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTYgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE4IFRoZSBGT0FNIEF1dGhvcnMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqL1xuXG5mb2FtLkNMQVNTKHtcbiAgcGFja2FnZTogJ2ZvYW0uY29yZScsXG4gIG5hbWU6ICdJREFsaWFzJyxcbiAgZXh0ZW5kczogJ2ZvYW0uY29yZS5PYmplY3QnLFxuICBwcm9wZXJ0aWVzOiBbXG4gICAgWyduYW1lJywgJ2lkJ10sXG4gICAge1xuICAgICAgY2xhc3M6ICdTdHJpbmcnLFxuICAgICAgbmFtZTogJ3Byb3BOYW1lJ1xuICAgIH0sXG4gICAge1xuICAgICAgbmFtZTogJ3RhcmdldFByb3BlcnR5JyxcbiAgICAgIHRyYW5zaWVudDogdHJ1ZVxuICAgIH0sXG4gICAgWydnZXR0ZXInLCBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLmNsc18uSUQudGFyZ2V0UHJvcGVydHkuZih0aGlzKTtcbiAgICB9XSxcbiAgICBbJ3NldHRlcicsIGZ1bmN0aW9uKHYpIHtcbiAgICAgIHRoaXMuY2xzXy5JRC50YXJnZXRQcm9wZXJ0eS5zZXQodGhpcywgdik7XG4gICAgfV1cbiAgXSxcbiAgbWV0aG9kczogW1xuICAgIGZ1bmN0aW9uIGluc3RhbGxJbkNsYXNzKGMpIHtcbiAgICAgIHZhciBwcm9wID0gYy5nZXRBeGlvbUJ5TmFtZSh0aGlzLnByb3BOYW1lKTtcbiAgICAgIGZvYW0uYXNzZXJ0KGZvYW0uY29yZS5Qcm9wZXJ0eS5pc0luc3RhbmNlKHByb3ApLCAnSWRzIHByb3BlcnR5OiAnICsgYy5pZCArICcuJyArIHRoaXMucHJvcE5hbWUsICdpcyBub3QgYSBQcm9wZXJ0eScpO1xuICAgICAgdGhpcy50YXJnZXRQcm9wZXJ0eSA9IHByb3A7XG5cbiAgICAgIHRoaXMuU1VQRVIoYyk7XG4gICAgfVxuICBdXG59KTtcblxuZm9hbS5DTEFTUyh7XG4gIHBhY2thZ2U6ICdmb2FtLmNvcmUnLFxuICBuYW1lOiAnTXVsdGlQYXJ0SUQnLFxuICBleHRlbmRzOiAnZm9hbS5jb3JlLkZPYmplY3RQcm9wZXJ0eScsXG5cbiAgZG9jdW1lbnRhdGlvbjogZnVuY3Rpb24oKSB7LypcbiAgQW4gSWRlbnRpdHkgQXhpb20gd2hpY2ggaW5zdGFsbHMgYSBwc2Vkby1wcm9wZXJ0eSB0byB1c2UgYXMgYW4gaWQuXG5cbiAgVXNlIHdoZW4geW91IHdhbnQgYSBtdWx0aS1wYXJ0IHByaW1hcnkta2V5LlxuICA8cHJlPlxuICBFeC5cbiAgZm9hbS5DTEFTUyh7XG4gICAgbmFtZTogJ1BlcnNvbicsXG4gICAgaWRzOiBbICdmaXJzdE5hbWUnLCAnbGFzdE5hbWUnIF0sXG4gICAgcHJvcGVydGllczogWyAnZmlyc3ROYW1lJywgJ2xhc3ROYW1lJywgJ2FnZScsICdzZXgnIF1cbiAgfSk7XG5cbiAgPiB2YXIgcCA9IFBlcnNvbi5jcmVhdGUoe2ZpcnN0TmFtZTogJ0tldmluJywgbGFzdE5hbWU6ICdHcmVlcid9KTtcbiAgPiBwLmlkLmNsc18uaWQ7XG4gIFwiUGVyc29uSWRcIlxuICA+IHAuaWQudG9TdHJpbmcoKTtcbiAgXCJ7Zmlyc3ROYW1lOlxcXCJLZXZpblxcXCIsbGFzdE5hbWU6XFxcIkdyZWVyXFxcIn1cIlxuICA8L3ByZT5cbiAgKi99LFxuXG4gIHByb3BlcnRpZXM6IFtcbiAgICBbICduYW1lJywgJ2lkJyBdLFxuICAgIFsgJ3RyYW5zaWVudCcsIHRydWUgXSxcbiAgICBbICdoaWRkZW4nLCB0cnVlIF0sXG4gICAge1xuICAgICAgY2xhc3M6ICdDbGFzcycsXG4gICAgICBuYW1lOiAnb2YnLFxuICAgICAgdHJhbnNpZW50OiB0cnVlLFxuICAgICAgcmVxdWlyZWQ6IGZhbHNlLFxuICAgICAgdmFsdWU6IG51bGxcbiAgICB9LFxuICAgIHtcbiAgICAgIGNsYXNzOiAnU3RyaW5nQXJyYXknLFxuICAgICAgbmFtZTogJ3Byb3BOYW1lcycsXG4gICAgICByZXF1aXJlZDogdHJ1ZVxuICAgIH0sXG4gICAgWyAnZ2V0dGVyJywgZnVuY3Rpb24gbXVsdGlQYXJ0R2V0dGVyKCkge1xuICAgICAgcmV0dXJuIHRoaXMuY2xzXy5JRC5vZi5jcmVhdGUodGhpcyk7XG4gICAgfV0sXG4gICAgWyAnc2V0dGVyJywgZnVuY3Rpb24gbXVsdGlQYXJ0U2V0dGVyKGEpIHtcbiAgICAgIGlmICggISBmb2FtLkFycmF5LmlzSW5zdGFuY2UoYSkgKSB7XG4gICAgICAgIHRoaXMuY29weUZyb20oYSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gVE9ETyhtYXJrZGl0dG1lcik6IFNob3VsZCBub3QgYXNzdW1lIHRoaXMgcHJvcGVydHkgaXMgbmFtZWQgXCJpZFwiLlxuICAgICAgdmFyIG5hbWVzID0gdGhpcy5jbHNfLklELnByb3BOYW1lcztcbiAgICAgIGZvYW0uYXNzZXJ0KG5hbWVzLmxlbmd0aCA9PT0gYS5sZW5ndGgsXG4gICAgICAgICAgICAgICAgICBgSW1wcm9wZXJseSBzaXplZCBhcnJheSBmb3IgJHt0aGlzLmNsc18uaWR9IGFycmF5IHZhbHVlYCk7XG4gICAgICBmb3IgKCB2YXIgaSA9IDA7IGkgPCBuYW1lcy5sZW5ndGg7IGkrKyApIHtcbiAgICAgICAgdGhpc1tuYW1lc1tpXV0gPSBhW2ldO1xuICAgICAgfVxuICAgIH1dXG4gIF0sXG5cbiAgbWV0aG9kczogW1xuICAgIGZ1bmN0aW9uIGluc3RhbGxJbkNsYXNzKGMpIHtcbiAgICAgIHZhciBnZW5lcmF0ZWRJZCA9IGMucGFja2FnZSA/XG4gICAgICAgICAgYy5wYWNrYWdlICsgJy4nICsgYy5uYW1lICsgJ0lkJyA6XG4gICAgICAgICAgYy5uYW1lICsgJ0lkJztcblxuICAgICAgZm9hbS5DTEFTUyh7XG4gICAgICAgIHBhY2thZ2U6IGMucGFja2FnZSxcbiAgICAgICAgbmFtZTogYy5uYW1lICsgJ0lkJyxcbiAgICAgICAgcHJvcGVydGllczogdGhpcy5wcm9wTmFtZXMubWFwKGZ1bmN0aW9uKG4pIHtcbiAgICAgICAgICB2YXIgcHJvcCA9IGMuZ2V0QXhpb21CeU5hbWUobik7XG4gICAgICAgICAgZm9hbS5hc3NlcnQocHJvcCwgJ1Vua25vd24gaWRzIHByb3BlcnR5OicsIGMuaWQgKyAnLicgKyBuKTtcbiAgICAgICAgICBmb2FtLmFzc2VydChmb2FtLmNvcmUuUHJvcGVydHkuaXNJbnN0YW5jZShwcm9wKSwgJ0lkcyBwcm9wZXJ0eTonLCBjLmlkICsgJy4nICsgbiwgJ2lzIG5vdCBhIFByb3BlcnR5LicpO1xuICAgICAgICAgIHJldHVybiBwcm9wLmNsb25lKCk7XG4gICAgICAgIH0pLFxuICAgICAgICBtZXRob2RzOiBbXG4gICAgICAgICAgZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgICAgICAgICByZXR1cm4gZm9hbS5qc29uLkNvbXBhY3Quc3RyaW5naWZ5KHRoaXMsIHRoaXMuY2xzXyk7XG4gICAgICAgICAgfVxuICAgICAgICBdXG4gICAgICB9KTtcblxuICAgICAgYy5pbnN0YWxsQXhpb20oZm9hbS5jb3JlLlJlcXVpcmVzLmNyZWF0ZSh7XG4gICAgICAgIG5hbWU6IGMubmFtZSArICdJZCcsXG4gICAgICAgIHBhdGg6IGdlbmVyYXRlZElkXG4gICAgICB9KSk7XG5cbiAgICAgIHRoaXMub2YgPSBmb2FtLmxvb2t1cChnZW5lcmF0ZWRJZCk7XG5cbiAgICAgIC8vIEV4dGVuZHMgUHJvcGVydHksIHNvIGFjdHVhbGx5IGdldHMgaW5zdGFsbGVkIGluIFNVUEVSIGNhbGxcbiAgICAgIHRoaXMuU1VQRVIoYyk7XG4gICAgfVxuICBdXG59KTtcblxuZm9hbS5DTEFTUyh7XG4gIHJlZmluZXM6ICdmb2FtLmNvcmUuTW9kZWwnLFxuICBwcm9wZXJ0aWVzOiBbXG4gICAge1xuICAgICAgbmFtZTogJ2lkcycsXG4gICAgICBwb3N0U2V0OiBmdW5jdGlvbihfLCBpZHMpIHtcbiAgICAgICAgZm9hbS5hc3NlcnQoZm9hbS5BcnJheS5pc0luc3RhbmNlKGlkcyksICdJZHMgbXVzdCBiZSBhbiBhcnJheS4nKTtcbiAgICAgICAgZm9hbS5hc3NlcnQoaWRzLmxlbmd0aCwgJ0lkcyBtdXN0IGNvbnRhaW4gYXQgbGVhc3Qgb25lIHByb3BlcnR5LicpO1xuXG4gICAgICAgIC8vIERvbid0IGJ1aWxkIE11bHRpUGFydElEIHByb3BlcnR5IGlmIHRoZSBpZCBpcyBub3QgbXVsdGkgcGFydC5cbiAgICAgICAgaWYgKCBpZHMubGVuZ3RoID09IDEgKSB0aGlzLmF4aW9tc18ucHVzaChmb2FtLmNvcmUuSURBbGlhcy5jcmVhdGUoeyBwcm9wTmFtZTogaWRzWzBdIH0pKTtcbiAgICAgICAgZWxzZSB0aGlzLmF4aW9tc18ucHVzaChmb2FtLmNvcmUuTXVsdGlQYXJ0SUQuY3JlYXRlKHtwcm9wTmFtZXM6IGlkc30pKTtcbiAgICAgIH1cbiAgICB9XG4gIF1cbn0pO1xuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTYgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuLyoqXG4gIFRoZSBSZXF1aXJlcyBBeGlvbSBpcyB1c2VkIHRvIGRlY2xhcmUgdGhhdCBhIGNsYXNzIHJlcXVpcmVzL2NyZWF0ZXMgb2JqZWN0c1xuICBvZiBhIHBhcnRpY3VsYXIgY2xhc3MuIFJlcXVpcmVkIGNsYXNzZXMgY2FuIGJlIGFjY2Vzc2VkIHdpdGhvdXQgZnVsbHlcbiAgcXVhbGlmeWluZyB0aGVpciBwYWNrYWdlIG5hbWVzLiBSZXF1aXJlZCBjbGFzc2VzIGFyZSBhdXRvbWF0aWNhbGx5XG4gIGNyZWF0ZWQgaW4gdGhlIHN1Yi1jb250ZXh0IG9mIHRoZSBjcmVhdGluZyBvYmplY3QuXG48cHJlPlxuICBFeC5cbiAgZm9hbS5DTEFTUyh7XG4gICAgcGFja2FnZTogJ2RlbW8uYmFuaycsXG4gICAgbmFtZTogJ0FjY291bnRUZXN0ZXInLFxuICAgIHJlcXVpcmVzOiBbXG4gICAgICAvLyBSZXF1aXJlIGRlbW8uYmFuay5BY2NvdW50IHNvIHRoYXQgaXQgY2FuIGJlIGFjY2Vzc2VkIGFzIHRoaXMuQWNjb3VudFxuICAgICAgJ2RlbW8uYmFuay5BY2NvdW50JyxcblxuICAgICAgLy8gUmVxdWlyZSBTYXZpbmdzQWNjb3VudCBhbmQgYWxpYXMgaXQgc28gdGhhdCBpdCBjYW4gYmUgYWNjZXNzZWRcbiAgICAgIC8vIGFzIHRoaXMuU0FjY291bnRcbiAgICAgICdkZW1vLmJhbmsuU2F2aW5nc0FjY291bnQgYXMgU0FjY291bnQnXG4gICAgXSxcbiAgICBtZXRob2RzOiBbIGZ1bmN0aW9uIGluaXQoKSB7XG4gICAgICB2YXIgYSA9IHRoaXMuQWNjb3VudC5jcmVhdGUoKTtcbiAgICAgIHZhciBzID0gdGhpcy5TQWNjb3VudC5jcmVhdGUoKTtcbiAgICB9IF1cbiAgfSk7XG48L3ByZT5cbiovXG5mb2FtLkNMQVNTKHtcbiAgcGFja2FnZTogJ2ZvYW0uY29yZScsXG4gIG5hbWU6ICdSZXF1aXJlcycsXG5cbiAgcHJvcGVydGllczogW1xuICAgIHtcbiAgICAgIG5hbWU6ICduYW1lJyxcbiAgICAgIGZhY3Rvcnk6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wYXRoLnNwbGl0KCcuJykucG9wKCk7XG4gICAgICB9LFxuICAgIH0sXG4gICAgJ3BhdGgnLFxuICAgICdmbGFncycsXG4gIF0sXG5cbiAgbWV0aG9kczogW1xuICAgIGZ1bmN0aW9uIGluc3RhbGxJblByb3RvKHByb3RvKSB7XG4gICAgICB2YXIgbmFtZSA9IHRoaXMubmFtZTtcbiAgICAgIHZhciBwYXRoID0gdGhpcy5wYXRoO1xuXG4gICAgICAvLyBDcmVhdGUgYSBwcml2YXRlXyBjbG9uZSBvZiB0aGUgQ2xhc3Mgd2l0aCB0aGUgY3JlYXRlKCkgbWV0aG9kIGRlY29yYXRlZFxuICAgICAgLy8gdG8gcGFzcyAndGhpcycgYXMgdGhlIGNvbnRleHQgaWYgbm90IGV4cGxpY2l0bHkgcHJvdmlkZWQuICBUaGlzIGVuc3VyZXNcbiAgICAgIC8vIHRoYXQgdGhlIGNyZWF0ZWQgb2JqZWN0IGhhcyBhY2Nlc3MgdG8gdGhpcyBvYmplY3QncyBleHBvcnRlZCBiaW5kaW5ncy5cbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm90bywgbmFtZSwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uIHJlcXVpcmVzR2V0dGVyKCkge1xuICAgICAgICAgIGlmICggISB0aGlzLmhhc093blByaXZhdGVfKG5hbWUpICkge1xuICAgICAgICAgICAgdmFyIGNscyAgICA9ICh0aGlzLl9fY29udGV4dF9fIHx8IGZvYW0pLmxvb2t1cChwYXRoKTtcbiAgICAgICAgICAgIHZhciBwYXJlbnQgPSB0aGlzO1xuICAgICAgICAgICAgZm9hbS5hc3NlcnQoY2xzLCAnUmVxdWlyZXM6IFVua25vd24gY2xhc3M6ICcsIHBhdGgpO1xuXG4gICAgICAgICAgICB2YXIgYyA9IE9iamVjdC5jcmVhdGUoY2xzKTtcbiAgICAgICAgICAgIGMuY3JlYXRlID0gZnVuY3Rpb24gcmVxdWlyZXNDcmVhdGUoYXJncywgY3R4KSB7IHJldHVybiBjbHMuY3JlYXRlKGFyZ3MsIGN0eCB8fCBwYXJlbnQpOyB9O1xuICAgICAgICAgICAgdGhpcy5zZXRQcml2YXRlXyhuYW1lLCBjKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gdGhpcy5nZXRQcml2YXRlXyhuYW1lKTtcbiAgICAgICAgfSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZVxuICAgICAgfSk7XG4gICAgfVxuICBdXG59KTtcblxuZm9hbS5DTEFTUyh7XG4gIHJlZmluZXM6ICdmb2FtLmNvcmUuTW9kZWwnLFxuICBwcm9wZXJ0aWVzOiBbXG4gICAge1xuICAgICAgY2xhc3M6ICdBeGlvbUFycmF5JyxcbiAgICAgIG9mOiAnUmVxdWlyZXMnLFxuICAgICAgbmFtZTogJ3JlcXVpcmVzJyxcbiAgICAgIGFkYXB0QXJyYXlFbGVtZW50OiBmdW5jdGlvbihvKSB7XG4gICAgICAgIGlmICggdHlwZW9mIG8gPT09ICdzdHJpbmcnICkge1xuICAgICAgICAgIHZhciBhICAgID0gby5zcGxpdCgnIGFzICcpO1xuICAgICAgICAgIHZhciBwYXRoID0gYVswXTtcbiAgICAgICAgICB2YXIgciA9IGZvYW0uY29yZS5SZXF1aXJlcy5jcmVhdGUoe3BhdGg6IHBhdGh9LCB0aGlzKTtcbiAgICAgICAgICBpZiAoIGFbMV0gKSByLm5hbWUgPSBhWzFdO1xuICAgICAgICAgIHJldHVybiByO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmb2FtLmNvcmUuUmVxdWlyZXMuY3JlYXRlKG8sIHRoaXMpO1xuICAgICAgfVxuICAgIH1cbiAgXVxufSk7XG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5mb2FtLkNMQVNTKHtcbiAgcGFja2FnZTogJ2ZvYW0uY29yZScsXG4gIG5hbWU6ICdTbG90JywgLy8gPz8/OiBSZW5hbWUgQWJzdHJhY3RTbG90IG9yIG1ha2UgYW4gSW50ZXJmYWNlXG5cbiAgZG9jdW1lbnRhdGlvbjogYFxuICAgIFNsb3RzIGFyZSBvYnNlcnZhYmxlIHZhbHVlcyB3aGljaCBjYW4gY2hhbmdlIG92ZXIgdGltZS5cblxuICAgIFNsb3RzIGFyZSBzaW1wbGUgc2luZ2xlLXZhbHVlIE1vZGVsLVZpZXctQ29udHJvbGxlciBNb2RlbHMsIGJ1dCBzaW5jZVxuICAgIGFub3RoZXIgbWVhbmluZyBvZiAnTW9kZWwnIGlzIGFscmVhZHkgaGVhdmlseSB1c2VkIGluIEZPQU0sIFNsb3QgaXNcbiAgICB1c2VkIHRvIGF2b2lkIG92ZXJsb2FkaW5nIHRoZSB0ZXJtLlxuXG4gICAgPHVsPlR5cGVzIG9mIFNsb3RzIGluY2x1ZGU6XG4gICAgICA8bGk+UHJvcGVydHlTbG90XG4gICAgICA8bGk+Q29uc3RhbnRTbG90XG4gICAgICA8bGk+RXhwcmVzc2lvblNsb3RcbiAgICA8L3VsPlxuICBgLFxuXG4gIG1ldGhvZHM6IFtcbiAgICAvKipcbiAgICAgIFN1YnNjcmliZSB0byB0aGUgU2xvdCdzIHZhbHVlLCBpZiBpdCBoYXMgb25lLiBJZiB0aGUgU2xvdCdzXG4gICAgICB2YWx1ZSBjaGFuZ2VzLCB0aGVuIHVuc3Vic2NyaWJlIGZyb20gdGhlIHByZXZpb3VzIHZhbHVlIGFuZFxuICAgICAgcmVzdWJzY3JpYmUgdG8gdGhlIG5ldyBvbmUuXG4gICAgKi9cbiAgICBmdW5jdGlvbiB2YWx1ZVN1YigpIHtcbiAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgIHZhciBhcmdzID0gQXJyYXkuZnJvbShhcmd1bWVudHMpO1xuICAgICAgdmFyIHM7XG4gICAgICB2YXIgbCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgdiA9IHNlbGYuZ2V0KCk7XG4gICAgICAgIGlmICggcyApIHMuZGV0YWNoKCk7XG4gICAgICAgIGlmICggdiApIHMgPSB2LnN1Yi5hcHBseSh2LCBhcmdzKTtcbiAgICAgIH07XG4gICAgICBsKCk7XG4gICAgICB0aGlzLnN1YihsKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICBDcmVhdGUgYSBzdWItU2xvdCBmb3IgdGhpcyBTbG90J3MgdmFsdWUuIElmIHRoaXMgU2xvdCdzXG4gICAgICB2YWx1ZSBjaGFuZ2VzLCB0aGVuIHRoZSBzdWItU2xvdCBiZWNvbWVzIHRoZSBTbG90IGZvclxuICAgICAgdGhlIG5ldyB2YWx1ZSdzIHN1Yi1TbG90IGluc3RlYWQuIFVzZWZ1bCBmb3IgY3JlYXRpbmdcbiAgICAgIFNsb3QgcGF0aHMgd2l0aG91dCBoYXZpbmcgdG8gcmVidWlsZCB3aGVuZXZlciBhIHZhbHVlXG4gICAgICBhbG9uZyB0aGUgY2hhaW4gY2hhbmdlcy5cbiAgICAqL1xuICAgIGZ1bmN0aW9uIGRvdChuYW1lKSB7XG4gICAgICByZXR1cm4gZm9hbS5jb3JlLmludGVybmFsLlN1YlNsb3QuY3JlYXRlKHtcbiAgICAgICAgcGFyZW50OiB0aGlzLFxuICAgICAgICBuYW1lOiAgIG5hbWVcbiAgICAgIH0pO1xuICAgIH0sXG5cbiAgICAvLyBUT0RPOiByZW1vdmUgd2hlbiBhbGwgY29kZSBwb3J0ZWRcbiAgICBmdW5jdGlvbiBsaW5rKG90aGVyKSB7XG4gICAgICBjb25zb2xlLndhcm4oJ2RlcHJlY2F0ZWQgdXNlIG9mIGxpbmsoKSwgdXNlIGxpbmtGcm9tKCkgaW5zdGVhZCcpO1xuICAgICAgcmV0dXJuIHRoaXMubGlua0Zyb20ob3RoZXIpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgIExpbmsgdHdvIFNsb3RzIHRvZ2V0aGVyLCBzZXR0aW5nIGJvdGggdG8gb3RoZXIncyB2YWx1ZS5cbiAgICAgIFJldHVybnMgYSBEZXRhY2hhYmxlIHdoaWNoIGNhbiBiZSB1c2VkIHRvIGJyZWFrIHRoZSBsaW5rLlxuICAgICAgQWZ0ZXIgY29weWluZyBhIHZhbHVlIGZyb20gb25lIHNsb3QgdG8gdGhlIG90aGVyLCB0aGlzIGltcGxlbWVudGF0aW9uXG4gICAgICB0aGVuIGNvcGllcyB0aGUgdmFsdWUgYmFjayBpbiBjYXNlIHRoZSB0YXJnZXQgc2xvdCByZWplY3RlZCB0aGUgdmFsdWUuXG4gICAgKi9cbiAgICBmdW5jdGlvbiBsaW5rRnJvbShzMikge1xuICAgICAgdmFyIHMxICAgICAgICA9IHRoaXM7XG4gICAgICB2YXIgZmVlZGJhY2sxID0gZmFsc2UsIGZlZWRiYWNrMiA9IGZhbHNlO1xuXG4gICAgICAvLyBUT0RPOiBvbmNlIGFsbCBzbG90IHR5cGVzIHByb3BlcnR5IHNldCAnc3JjJywgdGhlc2VcbiAgICAgIC8vIHR3byBsaXN0ZW5lbmVycyBjYW4gYmUgbWVyZ2VkLlxuICAgICAgdmFyIGwxID0gZnVuY3Rpb24oZSkge1xuICAgICAgICBpZiAoIGZlZWRiYWNrMSApIHJldHVybjtcblxuICAgICAgICBpZiAoICEgZm9hbS51dGlsLmlzKHMxLmdldCgpLCBzMi5nZXQoKSkgKSB7XG4gICAgICAgICAgZmVlZGJhY2sxID0gdHJ1ZTtcbiAgICAgICAgICBzMi5zZXQoczEuZ2V0KCkpO1xuICAgICAgICAgIGlmICggISBmb2FtLnV0aWwuaXMoczEuZ2V0KCksIHMyLmdldCgpKSApXG4gICAgICAgICAgICBzMS5zZXQoczIuZ2V0KCkpO1xuICAgICAgICAgIGZlZWRiYWNrMSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICB2YXIgbDIgPSBmdW5jdGlvbihlKSB7XG4gICAgICAgIGlmICggZmVlZGJhY2syICkgcmV0dXJuO1xuXG4gICAgICAgIGlmICggISBmb2FtLnV0aWwuaXMoczEuZ2V0KCksIHMyLmdldCgpKSApIHtcbiAgICAgICAgICBmZWVkYmFjazIgPSB0cnVlO1xuICAgICAgICAgIHMxLnNldChzMi5nZXQoKSk7XG4gICAgICAgICAgaWYgKCAhIGZvYW0udXRpbC5pcyhzMS5nZXQoKSwgczIuZ2V0KCkpIClcbiAgICAgICAgICAgIHMyLnNldChzMS5nZXQoKSk7XG4gICAgICAgICAgZmVlZGJhY2syID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIHZhciBzdWIxID0gczEuc3ViKGwxKTtcbiAgICAgIHZhciBzdWIyID0gczIuc3ViKGwyKVxuXG4gICAgICBsMigpO1xuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBkZXRhY2g6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHN1YjEgJiYgc3ViMS5kZXRhY2goKTtcbiAgICAgICAgICBzdWIyICYmIHN1YjIuZGV0YWNoKCk7XG4gICAgICAgICAgc3ViMSA9IHN1YjIgPSBudWxsO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH0sXG5cbiAgICBmdW5jdGlvbiBsaW5rVG8ob3RoZXIpIHtcbiAgICAgIHJldHVybiBvdGhlci5saW5rRnJvbSh0aGlzKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICBIYXZlIHRoaXMgU2xvdCBkeW5hbWljYWxseSBmb2xsb3cgb3RoZXIncyB2YWx1ZS5cbiAgICAgIFJldHVybnMgYSBEZXRhY2hhYmxlIHdoaWNoIGNhbiBiZSB1c2VkIHRvIGNhbmNlbCB0aGUgYmluZGluZy5cbiAgICAqL1xuICAgIGZ1bmN0aW9uIGZvbGxvdyhvdGhlcikge1xuICAgICAgZm9hbS5hc3NlcnQob3RoZXIsICdTbG90LmZvbGxvdyByZXF1aXJlcyBTbG90IGFyZ3VtZW50LicpO1xuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgdmFyIGwgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKCAhIGZvYW0udXRpbC5pcyhzZWxmLmdldCgpLCBvdGhlci5nZXQoKSkgKSB7XG4gICAgICAgICAgc2VsZi5zZXQob3RoZXIuZ2V0KCkpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgbCgpO1xuICAgICAgcmV0dXJuIG90aGVyLnN1YihsKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTWFwcyB2YWx1ZXMgZnJvbSBvbmUgbW9kZWwgdG8gYW5vdGhlci5cbiAgICAgKiBAcGFyYW0gZiBtYXBzIHZhbHVlcyBmcm9tIHNyY1ZhbHVlIHRvIGRzdFZhbHVlXG4gICAgICovXG4gICAgZnVuY3Rpb24gbWFwRnJvbShvdGhlciwgZikge1xuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgdmFyIGwgPSBmdW5jdGlvbigpIHsgc2VsZi5zZXQoZihvdGhlci5nZXQoKSkpOyB9O1xuICAgICAgbCgpO1xuICAgICAgcmV0dXJuIG90aGVyLnN1YihsKTtcbiAgICB9LFxuXG4gICAgZnVuY3Rpb24gbWFwVG8ob3RoZXIsIGYpIHtcbiAgICAgIHJldHVybiBvdGhlci5tYXBGcm9tKHRoaXMsIGYpO1xuICAgIH0sXG5cbiAgICBmdW5jdGlvbiBtYXAoZikge1xuICAgICAgcmV0dXJuIGZvYW0uY29yZS5FeHByZXNzaW9uU2xvdC5jcmVhdGUoe2NvZGU6IGYsIGFyZ3M6IFt0aGlzXX0pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZWxhdGUgdG8gYW5vdGhlciBTbG90LlxuICAgICAqIEBwYXJhbSBmIG1hcHMgZnJvbSB0aGlzIHRvIG90aGVyXG4gICAgICogQHBhcmFtIGZwcmltZSBtYXBzIG90aGVyIHRvIHRoaXNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiByZWxhdGVUbyhvdGhlciwgZiwgZlByaW1lKSB7XG4gICAgICB2YXIgc2VsZiAgICAgPSB0aGlzO1xuICAgICAgdmFyIGZlZWRiYWNrID0gZmFsc2U7XG4gICAgICB2YXIgc3ViICAgICAgPSBmb2FtLmNvcmUuRk9iamVjdC5jcmVhdGUoKTtcbiAgICAgIHZhciBsMSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoIGZlZWRiYWNrICkgcmV0dXJuO1xuICAgICAgICBmZWVkYmFjayA9IHRydWU7XG4gICAgICAgIG90aGVyLnNldChmKHNlbGYuZ2V0KCkpKTtcbiAgICAgICAgZmVlZGJhY2sgPSBmYWxzZTtcbiAgICAgIH07XG4gICAgICB2YXIgbDIgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKCBmZWVkYmFjayApIHJldHVybjtcbiAgICAgICAgZmVlZGJhY2sgPSB0cnVlO1xuICAgICAgICBzZWxmLnNldChmUHJpbWUob3RoZXIuZ2V0KCkpKTtcbiAgICAgICAgZmVlZGJhY2sgPSBmYWxzZTtcbiAgICAgIH07XG5cbiAgICAgIHN1Yi5vbkRldGFjaCh0aGlzLnN1YihsMSkpO1xuICAgICAgc3ViLm9uRGV0YWNoKG90aGVyLnN1YihsMikpO1xuXG4gICAgICBsMSgpO1xuXG4gICAgICByZXR1cm4gc3ViO1xuICAgIH0sXG5cbiAgICBmdW5jdGlvbiByZWxhdGVGcm9tKG90aGVyLCBmLCBmUHJpbWUpIHtcbiAgICAgIHJldHVybiBvdGhlci5yZWxhdGVUbyh0aGlzLCBmUHJpbWUsIGYpO1xuICAgIH1cbiAgXVxufSk7XG5cblxuZm9hbS5DTEFTUyh7XG4gIHBhY2thZ2U6ICdmb2FtLmNvcmUuaW50ZXJuYWwnLFxuICBuYW1lOiAnUHJvcGVydHlTbG90JyxcbiAgZXh0ZW5kczogJ2ZvYW0uY29yZS5TbG90JyxcblxuICBkb2N1bWVudGF0aW9uOiBgXG4gICAgUmVwcmVzZW50cyBvYmplY3QgcHJvcGVydGllcyBhcyBTbG90cy5cbiAgICBDcmVhdGVkIHdpdGggY2FsbGluZyBvYmoucHJvcCQgb3Igb2JqLnNsb3QoJ3Byb3AnKS5cbiAgICBGb3IgaW50ZXJuYWwgdXNlIG9ubHkuXG4gIGAsXG5cbiAgbWV0aG9kczogW1xuICAgIGZ1bmN0aW9uIGluaXRBcmdzKCkgeyB9LFxuICAgIGZ1bmN0aW9uIGluaXQoKSB7IH0sXG5cbiAgICBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5wcm9wLmdldCh0aGlzLm9iaik7XG4gICAgfSxcblxuICAgIGZ1bmN0aW9uIHNldCh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHRoaXMucHJvcC5zZXQodGhpcy5vYmosIHZhbHVlKTtcbiAgICB9LFxuXG4gICAgZnVuY3Rpb24gZ2V0UHJldigpIHtcbiAgICAgIHJldHVybiB0aGlzLm9sZFZhbHVlO1xuICAgIH0sXG5cbiAgICBmdW5jdGlvbiBzZXRQcmV2KHZhbHVlKSB7XG4gICAgICByZXR1cm4gdGhpcy5vbGRWYWx1ZSA9IHZhbHVlO1xuICAgIH0sXG5cbiAgICBmdW5jdGlvbiBzdWIobCkge1xuICAgICAgdmFyIHMgPSB0aGlzLm9iai5zdWIoJ3Byb3BlcnR5Q2hhbmdlJywgdGhpcy5wcm9wLm5hbWUsIGwpO1xuICAgICAgcy5zcmMgPSB0aGlzO1xuICAgICAgcmV0dXJuIHM7XG4gICAgfSxcblxuICAgIGZ1bmN0aW9uIGlzRGVmaW5lZCgpIHtcbiAgICAgIHJldHVybiB0aGlzLm9iai5oYXNPd25Qcm9wZXJ0eSh0aGlzLnByb3AubmFtZSk7XG4gICAgfSxcblxuICAgIGZ1bmN0aW9uIGNsZWFyKCkge1xuICAgICAgdGhpcy5vYmouY2xlYXJQcm9wZXJ0eSh0aGlzLnByb3AubmFtZSk7XG4gICAgfSxcblxuICAgIGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgICAgcmV0dXJuICdQcm9wZXJ0eVNsb3QoJyArIHRoaXMub2JqLmNsc18uaWQgKyAnLicgKyB0aGlzLnByb3AubmFtZSArICcpJztcbiAgICB9XG4gIF1cbn0pO1xuXG5cbmZvYW0uQ0xBU1Moe1xuICBwYWNrYWdlOiAnZm9hbS5jb3JlLmludGVybmFsJyxcbiAgbmFtZTogJ1N1YlNsb3QnLFxuICBleHRlbmRzOiAnZm9hbS5jb3JlLlNsb3QnLFxuXG4gIGRvY3VtZW50YXRpb246XG4gICAgICAnRm9yIGludGVybmFsIHVzZSBvbmx5LiBJcyB1c2VkIHRvIGltcGxlbWVudCB0aGUgU2xvdC5kb3QoKSBtZXRob2QuJyxcblxuICBwcm9wZXJ0aWVzOiBbXG4gICAgJ29mJyxcbiAgICAncGFyZW50JywgLy8gcGFyZW50IHNsb3QsIG5vdCBwYXJlbnQgb2JqZWN0XG4gICAgJ25hbWUnLFxuICAgICd2YWx1ZScsXG4gICAgJ3ByZXZTdWInXG4gIF0sXG5cbiAgbWV0aG9kczogW1xuICAgIGZ1bmN0aW9uIGluaXQoKSB7XG4gICAgICB0aGlzLnBhcmVudC5zdWIodGhpcy5wYXJlbnRDaGFuZ2UpO1xuICAgICAgdGhpcy5wYXJlbnRDaGFuZ2UoKTtcbiAgICB9LFxuXG4gICAgZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgdmFyIG8gPSB0aGlzLnBhcmVudC5nZXQoKTtcblxuICAgICAgcmV0dXJuIG8gJiYgb1t0aGlzLm5hbWVdO1xuICAgIH0sXG5cbiAgICBmdW5jdGlvbiBzZXQodmFsdWUpIHtcbiAgICAgIHZhciBvID0gdGhpcy5wYXJlbnQuZ2V0KCk7XG5cbiAgICAgIGlmICggbyApIG9bdGhpcy5uYW1lXSA9IHZhbHVlO1xuICAgIH0sXG5cbiAgICAvKiogTmVlZGVkPyAqKi9cbiAgICBmdW5jdGlvbiBnZXRQcmV2KCkge1xuICAgICAgZGVidWdnZXI7XG4gICAgICByZXR1cm4gdGhpcy5vbGRWYWx1ZTtcbiAgICB9LFxuXG4gICAgLyoqIE5lZWRlZD8gKiovXG4gICAgZnVuY3Rpb24gc2V0UHJldih2YWx1ZSkge1xuICAgICAgZGVidWdnZXI7XG4gICAgICByZXR1cm4gdGhpcy5vbGRWYWx1ZSA9IHZhbHVlO1xuICAgIH0sXG5cbiAgICBmdW5jdGlvbiBzdWIobCkge1xuICAgICAgcmV0dXJuIHRoaXMuU1VQRVIoJ3Byb3BlcnR5Q2hhbmdlJywgJ3ZhbHVlJywgbCk7XG4gICAgfSxcblxuICAgIGZ1bmN0aW9uIGlzRGVmaW5lZCgpIHtcbiAgICAgIHJldHVybiB0aGlzLnBhcmVudC5nZXQoKS5oYXNPd25Qcm9wZXJ0eSh0aGlzLm5hbWUpO1xuICAgIH0sXG5cbiAgICBmdW5jdGlvbiBjbGVhcigpIHtcbiAgICAgIHRoaXMucGFyZW50LmdldCgpLmNsZWFyUHJvcGVydHkodGhpcy5uYW1lKTtcbiAgICB9LFxuXG4gICAgZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgICByZXR1cm4gJ1N1YlNsb3QoJyArIHRoaXMucGFyZW50ICsgJywnICsgdGhpcy5uYW1lICsgJyknO1xuICAgIH1cbiAgXSxcblxuICBsaXN0ZW5lcnM6IFtcbiAgICBmdW5jdGlvbiBwYXJlbnRDaGFuZ2Uocykge1xuICAgICAgdGhpcy5wcmV2U3ViICYmIHRoaXMucHJldlN1Yi5kZXRhY2goKTtcbiAgICAgIHZhciBvID0gdGhpcy5wYXJlbnQuZ2V0KCk7XG5cbiAgICAgIC8vIElmIHRoZSBwYXJlbnQgb2JqZWN0IGNoYW5nZXMgY2xhc3MsIHRoZW4gZG9uJ3QgdXBkYXRlXG4gICAgICAvLyBiZWNhdXNlIGEgbmV3IGNsYXNzIHdpbGwgaGF2ZSBkaWZmZXJlbnQgc3ViLXNsb3RzLlxuICAgICAgaWYgKCAoICEgdGhpcy5vZiAgKSAmJiBvICkgdGhpcy5vZiA9IG8uY2xzXztcblxuICAgICAgdGhpcy5wcmV2U3ViID0gbyAmJiBvLnNsb3QodGhpcy5uYW1lKS5zdWIodGhpcy52YWx1ZUNoYW5nZSk7XG4gICAgICB0aGlzLnZhbHVlQ2hhbmdlKCk7XG4gICAgfSxcblxuICAgIGZ1bmN0aW9uIHZhbHVlQ2hhbmdlKCkge1xuICAgICAgdmFyIHBhcmVudFZhbHVlID0gdGhpcy5wYXJlbnQuZ2V0KCk7XG4gICAgICB0aGlzLnZhbHVlID0gcGFyZW50VmFsdWUgPyBwYXJlbnRWYWx1ZVt0aGlzLm5hbWVdIDogdW5kZWZpbmVkO1xuICAgIH1cbiAgXVxufSk7XG5cblxuZm9hbS5DTEFTUyh7XG4gIHBhY2thZ2U6ICdmb2FtLmNvcmUnLFxuICBuYW1lOiAnQ29uc3RhbnRTbG90JyxcblxuICBpbXBsZW1lbnRzOiBbICdmb2FtLmNvcmUuU2xvdCcgXSxcblxuICBkb2N1bWVudGF0aW9uOiAnQW4gaW1tdXRhYmxlIGNvbnN0YW50IHZhbHVlZCBTbG90LicsXG5cbiAgcHJvcGVydGllczogW1xuICAgIHtcbiAgICAgIG5hbWU6ICd2YWx1ZScsXG4gICAgICBnZXR0ZXI6IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcy52YWx1ZV87IH0sXG4gICAgICBzZXR0ZXI6IGZ1bmN0aW9uKCkge31cbiAgICB9XG4gIF0sXG5cbiAgbWV0aG9kczogW1xuICAgIGZ1bmN0aW9uIGluaXRBcmdzKGFyZ3MpIHsgdGhpcy52YWx1ZV8gPSBhcmdzICYmIGFyZ3MudmFsdWU7IH0sXG5cbiAgICBmdW5jdGlvbiBnZXQoKSB7IHJldHVybiB0aGlzLnZhbHVlOyB9LFxuXG4gICAgZnVuY3Rpb24gc2V0KCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdUcmllZCB0byBtdXRhdGUgaW1tdXRhYmxlIENvbnN0YW50U2xvdC4nKTtcbiAgICB9LFxuXG4gICAgZnVuY3Rpb24gc3ViKGwpIHsgLyogbm9wICovIH1cbiAgXVxufSk7XG5cblxuLyoqXG4qL1xuZm9hbS5DTEFTUyh7XG4gIHBhY2thZ2U6ICdmb2FtLmNvcmUnLFxuICBuYW1lOiAnRXhwcmVzc2lvblNsb3QnLFxuICBpbXBsZW1lbnRzOiBbICdmb2FtLmNvcmUuU2xvdCcgXSxcblxuICBkb2N1bWVudGF0aW9uOiBgXG4gICAgVHJhY2tzIGRlcGVuZGVuY2llcyBmb3IgYSBkeW5hbWljIGZ1bmN0aW9uIGFuZCBpbnZhbGlkYXRlcyBpZiB0aGV5IGNoYW5nZS5cblxuICAgIDxwcmU+XG4gICAgICBmb2FtLkNMQVNTKHtuYW1lOiAnUGVyc29uJywgcHJvcGVydGllczogWydmbmFtZScsICdsbmFtZSddfSk7XG4gICAgICB2YXIgcCA9IFBlcnNvbi5jcmVhdGUoe2ZuYW1lOiAnSm9obicsIGxuYW1lOiAnU21pdGgnfSk7XG4gICAgICB2YXIgZSA9IGZvYW0uY29yZS5FeHByZXNzaW9uU2xvdC5jcmVhdGUoe1xuICAgICAgICBhcmdzOiBbIHAuZm5hbWUkLCBwLmxuYW1lJCBdLFxuICAgICAgICBjb2RlOiBmdW5jdGlvbihmLCBsKSB7IHJldHVybiBmICsgJyAnICsgbDsgfVxuICAgICAgfSk7XG4gICAgICBsb2coZS5nZXQoKSk7XG4gICAgICBlLnN1Yihsb2cpO1xuICAgICAgcC5mbmFtZSA9ICdTdGV2ZSc7XG4gICAgICBwLmxuYW1lID0gJ0pvbmVzJztcbiAgICAgIGxvZyhlLmdldCgpKTtcblxuICAgICAgT3V0cHV0OlxuICAgICAgID4gSm9obiBTbWl0aFxuICAgICAgID4gW29iamVjdCBPYmplY3RdIHByb3BlcnR5Q2hhbmdlIHZhbHVlIFtvYmplY3QgT2JqZWN0XVxuICAgICAgID4gW29iamVjdCBPYmplY3RdIHByb3BlcnR5Q2hhbmdlIHZhbHVlIFtvYmplY3QgT2JqZWN0XVxuICAgICAgID4gU3RldmUgSm9uZXNcblxuICAgICAgdmFyIHAgPSBmb2FtLkNMQVNTKHtuYW1lOiAnUGVyc29uJywgcHJvcGVydGllczogWyAnZicsICdsJyBdfSkuY3JlYXRlKHtmOidKb2huJywgbDogJ0RvZSd9KTtcbiAgICAgIHZhciBlID0gZm9hbS5jb3JlLkV4cHJlc3Npb25TbG90LmNyZWF0ZSh7XG4gICAgICAgIG9iajogcCxcbiAgICAgICAgY29kZTogZnVuY3Rpb24oZiwgbCkgeyByZXR1cm4gZiArICcgJyArIGw7IH1cbiAgICAgIH0pO1xuICAgIDwvcHJlPlxuICBgLFxuXG4gIHByb3BlcnRpZXM6IFtcbiAgICAnb2JqJyxcbiAgICAnY29kZScsXG4gICAge1xuICAgICAgbmFtZTogJ2FyZ3MnLFxuICAgICAgZXhwcmVzc2lvbjogZnVuY3Rpb24ob2JqKSB7XG4gICAgICAgIGZvYW0uYXNzZXJ0KG9iaiwgJ0V4cHJlc3Npb25TbG90OiBcIm9ialwiIG9yIFwiYXJnc1wiIHJlcXVpcmVkLicpO1xuXG4gICAgICAgIHZhciBhcmdzID0gZm9hbS5GdW5jdGlvbi5hcmdOYW1lcyh0aGlzLmNvZGUpO1xuICAgICAgICBmb3IgKCB2YXIgaSA9IDAgOyBpIDwgYXJncy5sZW5ndGggOyBpKysgKSB7XG4gICAgICAgICAgYXJnc1tpXSA9IG9iai5zbG90KGFyZ3NbaV0pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gdGhpcy5pbnZhbGlkYXRlKCk7IC8vID8/PzogSXMgdGhpcyBuZWVkZWQ/XG4gICAgICAgIHRoaXMuc3ViVG9BcmdzXyhhcmdzKTtcblxuICAgICAgICByZXR1cm4gYXJncztcbiAgICAgIH0sXG4gICAgICBwb3N0U2V0OiBmdW5jdGlvbihfLCBhcmdzKSB7XG4gICAgICAgIHRoaXMuc3ViVG9BcmdzXyhhcmdzKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHtcbiAgICAgIG5hbWU6ICd2YWx1ZScsXG4gICAgICBmYWN0b3J5OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29kZS5hcHBseSh0aGlzLm9iaiB8fCB0aGlzLCB0aGlzLmFyZ3MubWFwKGZ1bmN0aW9uKGEpIHtcbiAgICAgICAgICByZXR1cm4gYS5nZXQoKTtcbiAgICAgICAgfSkpO1xuICAgICAgfVxuICAgIH0sXG4gICAgJ2NsZWFudXBfJywgLy8gZGV0YWNoYWJsZSB0byBjbGVhbnVwIG9sZCBzdWJzIHdoZW4gb2JqIGNoYW5nZXNcbiAgXSxcblxuICBtZXRob2RzOiBbXG4gICAgZnVuY3Rpb24gaW5pdCgpIHsgdGhpcy5vbkRldGFjaCh0aGlzLmNsZWFudXApOyB9LFxuXG4gICAgZnVuY3Rpb24gZ2V0KCkgeyByZXR1cm4gdGhpcy52YWx1ZTsgfSxcblxuICAgIGZ1bmN0aW9uIHNldCgpIHsgLyogbm9wICovIH0sXG5cbiAgICBmdW5jdGlvbiBzdWIobCkge1xuICAgICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPT09IDEgP1xuICAgICAgICB0aGlzLlNVUEVSKCdwcm9wZXJ0eUNoYW5nZScsICd2YWx1ZScsIGwpIDpcbiAgICAgICAgdGhpcy5TVVBFUi5hcHBseSh0aGlzLGFyZ3VtZW50cyk7XG4gICAgfSxcblxuICAgIGZ1bmN0aW9uIHN1YlRvQXJnc18oYXJncykge1xuICAgICAgdGhpcy5jbGVhbnVwKCk7XG5cbiAgICAgIHZhciBjbGVhbnVwID0gZm9hbS5jb3JlLkZPYmplY3QuY3JlYXRlKCk7XG5cbiAgICAgIGZvciAoIHZhciBpID0gMCA7IGkgPCBhcmdzLmxlbmd0aCA7IGkrKyApIHtcbiAgICAgICAgY2xlYW51cC5vbkRldGFjaChhcmdzW2ldLnN1Yih0aGlzLmludmFsaWRhdGUpKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5jbGVhbnVwXyA9IGNsZWFudXA7XG4gICAgfVxuICBdLFxuXG4gIGxpc3RlbmVyczogW1xuICAgIGZ1bmN0aW9uIGNsZWFudXAoKSB7IHRoaXMuY2xlYW51cF8gJiYgdGhpcy5jbGVhbnVwXy5kZXRhY2goKTsgfSxcbiAgICBmdW5jdGlvbiBpbnZhbGlkYXRlKCkgeyB0aGlzLmNsZWFyUHJvcGVydHkoJ3ZhbHVlJyk7IH1cbiAgXVxufSk7XG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG4vKipcbiAqIFRoZSBQcm94eSBheGlvbSBlbmFibGVzIHlvdXIgY2xhc3MgdG8gYXV0b21hdGljYWxseSBwcm94eSBtZXRob2RzIG9mXG4gKiBhbiBpbnRlcmZhY2UgdG8gYSBkZWxlZ2F0ZSBvYmplY3QuXG4gKlxuICogSXQgaXMgYW4gaW1wbGVtZW50YXRpb24gb2YgdGhlIFByb3h5IGRlc2lnbiBwYXR0ZXJuLlxuICpcbiAqIFRoZSBQcm94eSBheGlvbSBpdHNlbGYgaXMgYSBwcm9wZXJ0eSB3aGljaCBob2xkcyB0aGUgZGVsZWdhdGUgb2JqZWN0XG4gKiB0aGF0IHdlIGFyZSBwcm94eWluZy4gIEl0IGFsc28gaW5zdGFsbHMgYSBudW1iZXIgb2YgTWV0aG9kIGF4aW9tcyBvbnRvXG4gKiB0aGUgdGFyZ2V0IGNsYXNzLCB3aGljaCBwcm94eSBhbGwgdGhlIHRoZSBzcGVjaWZpYyBtZXRob2RzIG9mIHRoZSBpbnRlcmZhY2VcbiAqIGJlaW5nIHByb3hpZWQuXG4gKlxuICogQ3VycmVudGx5IG9ubHkgbWV0aG9kcyBhcmUgcHJveGllZC5cbiAqXG4gKiBVU0FHRTpcbiAqXG4gKiBmb2FtLkNMQVNTKHtcbiAqICAgbmFtZTogJ0FiYycsXG4gKiAgIG1ldGhvZHM6IFtcbiAqICAgICBmdW5jdGlvbiBmb28oKSB7XG4gKiAgICAgICBjb25zb2xlLmxvZyhcImZvb1wiKTtcbiAqICAgICB9XG4gKiAgIF1cbiAqIH0pO1xuICpcbiAqIGZvYW0uQ0xBU1Moe1xuICogICBuYW1lOiAnUHJveHlBYmMnLFxuICogICBwcm9wZXJ0aWVzOiBbXG4gKiAgICAge1xuICogICAgICAgY2xhc3M6ICdQcm94eScsXG4gKiAgICAgICBvZjogJ0FiYydcbiAqICAgICAgIG5hbWU6ICdkZWxlZ2F0ZUFiYydcbiAqICAgICB9XG4gKiAgIF1cbiAqIH0pO1xuICpcbiAqIHZhciBhID0gUHJveHlBYmMuY3JlYXRlKHsgZGVsZWdhdGVBYmM6IEFiYy5jcmVhdGUoKSB9KTtcbiAqIGEuZm9vKCk7XG4gKlxuICogd2lsbCBvdXRwdXQ6XG4gKlxuICogXCJmb29cIlxuICpcbiAqXG4gKiBNZXRob2RzIGNhbiBiZSBmb3J3YXJkZWQgb3IgZGVsZWdhdGVkIHRvIHRoZSBwcm94aWVkIG9iamVjdC5cbiAqIEZvcndhcmRlZCBtZXRob2RzIGFyZSB0aGUgc2ltcGxlIGNhc2U6XG4gKlxuICogZnVuY3Rpb24gZm9vKCkge1xuICogICAvLyBUaGlzIGlzIHdoYXQgYSBmb3J3YXJkZWQgbWV0aG9kIGxvb2tzIGxpa2VcbiAqICAgdGhpcy5kZWxlZ2F0ZUFiYy5mb28oKTtcbiAqIH1cbiAqXG4gKiBEZWxlZ2F0ZWQgbWV0aG9kcyBjYWxsIHRoZSBwcm94aWVkIG9iamVjdCdzIGltcGxlbWVudGF0aW9uXG4gKiBidXQga2VlcCBcInRoaXNcIiBhcyB0aGUgc2FtZSBvYmplY3QuXG4gKlxuICogSWYgdGhlIGZvbyBtZXRob2Qgd2FzIGRlbGVnYXRlZCBpdCB3b3VsZCBsb29rIGxpa2UgdGhpczpcbiAqXG4gKiBmdW5jdGlvbiBmb28oKSB7XG4gKiAgIHRoaXMuZGVsZWdhdGVBYmMuZm9vLmNhbGwodGhpcyk7XG4gKiB9XG4gKlxuICogRlVUVVJFKGFkYW12eSk6IFN1cHBvcnQgcHJveHlpbmcgcHJvcGVydGllcz9cbiAqIFRPRE8oYWRhbXZ5KTogRG9jdW1lbnQgaG93IHRvcGljcyBhcmUgcHJveGllZCBvbmNlIHRoZSBpbXBsZW1lbnRhdGlvbiBpcyBzZXR0bGVkLlxuICovXG4vLyBOQjogRXh0ZW5kaW5nIGEgUHJveGllZCBvYmplY3QgYW5kIHVuc2V0dGluZyBvcHRpb25zIChsaWtlIHNldHRpbmdcbi8vICAgICB0b3BpY3M6IFtdKSB3aWxsIG5vdCB1bmRvIHRoZSB3b3JrIHRoZSBiYXNlIGNsYXNzIGhhcyBhbHJlYWR5IGRvbmUuXG4vLyAgICAgVGhlIFByb3h5U3ViIGlzIGFscmVhZHkgaW5zdGFsbGVkIGluIHRoZSBwcm90b3R5cGUgYW5kIHdpbGwgc3RpbGxcbi8vICAgICBiZSBhY3RpdmUgaW4gdGhlIGRlcml2ZWQgY2xhc3MsIGV2ZW4gdGhvdWdoIGl0IGFwcGVhcnMgdGhhdCB0b3BpY3MgaXNcbi8vICAgICBub3QgcHJveGllZCB3aGVuIGV4YW1pbmluZyB0aGUgZGVydmllZCBjbGFzcycgYXhpb20uXG5mb2FtLkNMQVNTKHtcbiAgcGFja2FnZTogJ2ZvYW0uY29yZScsXG4gIG5hbWU6ICdQcm94eScsXG4gIGV4dGVuZHM6ICdQcm9wZXJ0eScsXG5cbiAgcHJvcGVydGllczogW1xuICAgIHsgbmFtZTogJ29mJywgcmVxdWlyZWQ6IHRydWUgfSxcbiAgICB7XG4gICAgICBjbGFzczogJ1N0cmluZ0FycmF5JyxcbiAgICAgIG5hbWU6ICd0b3BpY3MnXG4gICAgfSxcbiAgICB7XG4gICAgICBjbGFzczogJ1N0cmluZ0FycmF5JyxcbiAgICAgIG5hbWU6ICdmb3J3YXJkcycsXG4gICAgICBmYWN0b3J5OiBudWxsLFxuICAgICAgdmFsdWU6IG51bGxcbiAgICAgIC8vZG9jdW1lbnRhdGlvbjogJ01ldGhvZHMgdGhhdCBhcmUgZm9yd2FyZGVkIHRvIHRoZSBwcm94aWVzIG9iamVjdC4nXG4gICAgfSxcbiAgICB7XG4gICAgICBjbGFzczogJ1N0cmluZ0FycmF5JyxcbiAgICAgIG5hbWU6ICdkZWxlZ2F0ZXMnLFxuICAgICAgZmFjdG9yeTogbnVsbCxcbiAgICAgIHZhbHVlOiBudWxsXG4gICAgICAvL2RvY3VtZW50YXRpb246ICdNZXRob2RzIHRoYXQgYXJlIGRlbGVnYXRlZCB0byB0aGUgcHJveGllZCBvYmplY3QuJ1xuICAgIH0sXG4gICAge1xuICAgICAgbmFtZTogJ2Zyb21KU09OJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbihqc29uLCBjdHgpIHtcbiAgICAgICAgcmV0dXJuIGZvYW0uanNvbi5wYXJzZShqc29uLCBudWxsLCBjdHgpO1xuICAgICAgfVxuICAgIH1cbiAgXSxcblxuICBtZXRob2RzOiBbXG4gICAgZnVuY3Rpb24gaW5zdGFsbEluQ2xhc3MoY2xzKSB7XG4gICAgICB0aGlzLlNVUEVSKGNscyk7XG5cbiAgICAgIHZhciBuYW1lICAgICA9IHRoaXMubmFtZTtcbiAgICAgIHZhciBkZWxlZ2F0ZSA9IHRoaXMubG9va3VwKHRoaXMub2YpO1xuXG4gICAgICBmdW5jdGlvbiByZXNvbHZlTmFtZShuYW1lKSB7XG4gICAgICAgIHZhciBtID0gZGVsZWdhdGUuZ2V0QXhpb21CeU5hbWUobmFtZSk7XG4gICAgICAgIGZvYW0uYXNzZXJ0KGZvYW0uY29yZS5NZXRob2QuaXNJbnN0YW5jZShtKSwgJ0Nhbm5vdCBwcm94eSBub24tbWV0aG9kJywgbmFtZSk7XG4gICAgICAgIHJldHVybiBtO1xuICAgICAgfVxuXG4gICAgICB2YXIgZGVsZWdhdGVzID0gdGhpcy5kZWxlZ2F0ZXMgPyB0aGlzLmRlbGVnYXRlcy5tYXAocmVzb2x2ZU5hbWUpIDogW107XG5cbiAgICAgIHZhciBmb3J3YXJkcyA9IHRoaXMuZm9yd2FyZHMgP1xuICAgICAgICAgIHRoaXMuZm9yd2FyZHMubWFwKHJlc29sdmVOYW1lKSA6XG4gICAgICAgICAgLy8gVE9ETyhhZGFtdnkpOiBUaGlzIGlzbid0IHRoZSByaWdodCBjaGVjay4gIE9uY2Ugd2UgaGF2ZSBtb2RlbGVkIGludGVyZmFjZXNcbiAgICAgICAgICAvLyB3ZSBjYW4gcHJveHkgb25seSB0aGF0IHdoaWNoIGlzIGRlZmluZWQgaW4gdGhlIGludGVyZmFjZS5cbiAgICAgICAgICBkZWxlZ2F0ZS5nZXRPd25BeGlvbXNCeUNsYXNzKGZvYW0uY29yZS5NZXRob2QpO1xuXG4gICAgICB2YXIgYXhpb21zID0gW107XG4gICAgICBmb3IgKCB2YXIgaSA9IDAgOyBpIDwgZm9yd2FyZHMubGVuZ3RoIDsgaSsrICkge1xuICAgICAgICB2YXIgbWV0aG9kID0gZm9yd2FyZHNbaV07XG4gICAgICAgIGF4aW9tcy5wdXNoKGZvYW0uY29yZS5Qcm94aWVkTWV0aG9kLmNyZWF0ZSh7XG4gICAgICAgICAgbmFtZTogbWV0aG9kLm5hbWUsXG4gICAgICAgICAgcmV0dXJuczogbWV0aG9kLnJldHVybnMsXG4gICAgICAgICAgcHJvcGVydHk6IG5hbWUsXG4gICAgICAgICAgYXJnczogbWV0aG9kLmFyZ3NcbiAgICAgICAgfSkpO1xuICAgICAgfVxuXG4gICAgICBmb3IgKCB2YXIgaSA9IDAgOyBpIDwgZGVsZWdhdGVzLmxlbmd0aCA7IGkrKyApIHtcbiAgICAgICAgdmFyIG1ldGhvZCA9IGRlbGVnYXRlc1tpXTtcbiAgICAgICAgYXhpb21zLnB1c2goZm9hbS5jb3JlLlByb3hpZWRNZXRob2QuY3JlYXRlKHtcbiAgICAgICAgICBuYW1lOiBtZXRob2QubmFtZSxcbiAgICAgICAgICByZXR1cm5zOiBtZXRob2QucmV0dXJucyxcbiAgICAgICAgICBwcm9wZXJ0eTogbmFtZSxcbiAgICAgICAgICBhcmdzOiBtZXRob2QuYXJncyxcbiAgICAgICAgICBkZWxlZ2F0ZTogdHJ1ZVxuICAgICAgICB9KSk7XG4gICAgICB9XG5cbiAgICAgIGlmICggISB0aGlzLnRvcGljcyB8fCB0aGlzLnRvcGljcy5sZW5ndGggKSB7XG4gICAgICAgIGF4aW9tcy5wdXNoKGZvYW0uY29yZS5Qcm94eVN1Yi5jcmVhdGUoe1xuICAgICAgICAgIHRvcGljczogdGhpcy50b3BpY3MsXG4gICAgICAgICAgcHJvcDogICB0aGlzLm5hbWVcbiAgICAgICAgfSkpO1xuICAgICAgfVxuXG4gICAgICBjbHMuaW5zdGFsbEF4aW9tcyhheGlvbXMpO1xuICAgIH1cbiAgXVxufSk7XG5cbi8qKlxuICogUHJveGllZE1ldGhvZCBpcyBhIHR5cGUgb2YgbWV0aG9kIHRoYXQgZGVsZWdhdGVzIG9yIGZvcndhcmRzIGNhbGxzXG4gKiB0byBhIGRlbGVnYXRlIG9iamVjdC4gIEl0IGlzIHVzZWQgYXMgYW4gaW1wbGVtZW50YXRpb24gZGV0YWlsIG9mIHRoZVxuICogUHJveHkgYXhpb21cbiAqXG4gKiBEZWxlZ2F0aW9uIG1lYW5zIHRoYXQgdGhlIGRlbGVnYXRlIG9iamVjdCdzIGltcGxlbWVudGF0aW9uIGlzIGNhbGxlZCB3aXRoXG4gKiBcInRoaXNcIiBzdGlsbCBiZWluZyB0aGUgb3JpZ2luYWwgb2JqZWN0LlxuICpcbiAqIEZvcndhcmRpbmcgbWVhbnMgdGhhdCB0aGUgbWV0aG9kIGNhbGwgaXMgc2ltcGx5IFwiZm9yd2FyZGVkXCIgdG8gdGhlIGRlbGVnYXRlXG4gKiBvYmplY3QuICBcInRoaXNcIiB3aWxsIGJlIHRoZSBkZWxlZ2F0ZSBvYmplY3QuXG4gKi9cbmZvYW0uQ0xBU1Moe1xuICBwYWNrYWdlOiAnZm9hbS5jb3JlJyxcbiAgbmFtZTogJ1Byb3hpZWRNZXRob2QnLFxuICBleHRlbmRzOiAnTWV0aG9kJyxcblxuICBwcm9wZXJ0aWVzOiBbXG4gICAge1xuICAgICAgY2xhc3M6ICdTdHJpbmcnLFxuICAgICAgbmFtZTogJ3Byb3BlcnR5J1xuICAgIH0sXG4gICAge1xuICAgICAgY2xhc3M6ICdCb29sZWFuJyxcbiAgICAgIG5hbWU6ICdkZWxlZ2F0ZScsXG4gICAgICB2YWx1ZTogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgIG5hbWU6ICdjb2RlJyxcbiAgICAgIGV4cHJlc3Npb246IGZ1bmN0aW9uKG5hbWUsIHByb3BlcnR5LCByZXR1cm5zLCBkZWxlZ2F0ZSkge1xuICAgICAgICByZXR1cm4gZGVsZWdhdGUgP1xuICAgICAgICAgICAgZnVuY3Rpb24gZGVsZWdhdGUoKSB7XG4gICAgICAgICAgICAgIHJldHVybiB0aGlzW3Byb3BlcnR5XVtuYW1lXS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgfSA6XG4gICAgICAgICAgICBmdW5jdGlvbiBmb3J3YXJkKCkge1xuICAgICAgICAgICAgICByZXR1cm4gdGhpc1twcm9wZXJ0eV1bbmFtZV0uYXBwbHkodGhpc1twcm9wZXJ0eV0sIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICB9IDtcbiAgICAgIH1cbiAgICB9XG4gIF1cbn0pO1xuXG5cbmZvYW0uQ0xBU1Moe1xuICBwYWNrYWdlOiAnZm9hbS5jb3JlJyxcbiAgbmFtZTogJ0V2ZW50UHJveHknLFxuXG4gIHByb3BlcnRpZXM6IFtcbiAgICB7XG4gICAgICBuYW1lOiAnZGVzdCcsXG4gICAgICBzd2lmdFR5cGU6ICdUb3BpYycsXG4gICAgfSxcbiAgICB7XG4gICAgICBjbGFzczogJ1N0cmluZ0FycmF5JyxcbiAgICAgIG5hbWU6ICd0b3BpYycsXG4gICAgICBmYWN0b3J5OiBmdW5jdGlvbigpIHsgcmV0dXJuIFtdOyB9XG4gICAgfSxcbiAgICB7XG4gICAgICBjbGFzczogJ0Jvb2xlYW4nLFxuICAgICAgbmFtZTogJ2FjdGl2ZScsXG4gICAgICB2YWx1ZTogZmFsc2UsXG4gICAgICBwb3N0U2V0OiBmdW5jdGlvbihvbGQsIGEpIHtcbiAgICAgICAgZm9yICggdmFyIGtleSBpbiB0aGlzLmNoaWxkcmVuICkge1xuICAgICAgICAgIHRoaXMuY2hpbGRyZW5ba2V5XS5hY3RpdmUgPSAhIGE7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIG9sZCAhPT0gYSApIHtcbiAgICAgICAgICBpZiAoIGEgKSB7XG4gICAgICAgICAgICB0aGlzLmRvU3ViKCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZG9VbnN1YigpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHN3aWZ0UG9zdFNldDogYFxuZm9yIGNoaWxkIGluIGNoaWxkcmVuLnZhbHVlcyB7XG4gIGNoaWxkLmFjdGl2ZSA9ICFuZXdWYWx1ZVxufVxuXG5pZiAob2xkVmFsdWUgYXM/IEJvb2wgPz8gZmFsc2UpICE9IG5ld1ZhbHVlIHtcbiAgaWYgbmV3VmFsdWUge1xuICAgIHNlbGYuZG9TdWIoKVxuICB9IGVsc2Uge1xuICAgIHNlbGYuZG9VbnN1YigpXG4gIH1cbn1cbiAgICAgIGBcbiAgICB9LFxuICAgIHtcbiAgICAgIG5hbWU6ICdwYXJlbnQnLFxuICAgICAgc3dpZnRUeXBlOiAnRXZlbnRQcm94eT8nLFxuICAgIH0sXG4gICAge1xuICAgICAgbmFtZTogJ2NoaWxkcmVuJyxcbiAgICAgIGZhY3Rvcnk6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4ge307XG4gICAgICB9LFxuICAgICAgc3dpZnRUeXBlOiAnW1N0cmluZzpFdmVudFByb3h5XScsXG4gICAgICBzd2lmdEZhY3Rvcnk6ICdyZXR1cm4gWzpdJyxcbiAgICB9LFxuICAgIHtcbiAgICAgIG5hbWU6ICdzcmMnLFxuICAgICAgcG9zdFNldDogZnVuY3Rpb24obywgc3JjKSB7XG4gICAgICAgIGlmICggdGhpcy5hY3RpdmUgKSB0aGlzLmRvU3ViKCk7XG4gICAgICAgIGZvciAoIHZhciBrZXkgaW4gdGhpcy5jaGlsZHJlbiApIHtcbiAgICAgICAgICB0aGlzLmNoaWxkcmVuW2tleV0uc3JjID0gc3JjO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICB7XG4gICAgICBzd2lmdFR5cGU6ICdTdWJzY3JpcHRpb24/JyxcbiAgICAgIG5hbWU6ICdzdWJzY3JpcHRpb24nLFxuICAgIH1cbiAgXSxcblxuICBtZXRob2RzOiBbXG4gICAge1xuICAgICAgbmFtZTogJ2luaXQnLFxuICAgICAgY29kZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMub25EZXRhY2goZm9hbS5GdW5jdGlvbi5iaW5kKGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHRoaXMuc3Vic2NyaXB0aW9uICYmIHRoaXMuc3Vic2NyaXB0aW9uLmRldGFjaCgpO1xuXG4gICAgICAgICAgaWYgKCB0aGlzLnBhcmVudCApIHtcbiAgICAgICAgICAgIHRoaXMucGFyZW50LnJlbW92ZUNoaWxkKHRoaXMpO1xuICAgICAgICAgICAgdGhpcy5wYXJlbnQuYWN0aXZlID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sIHRoaXMpKTtcbiAgICAgIH0sXG4gICAgICBzd2lmdENvZGU6IGBcbm9uRGV0YWNoKFN1YnNjcmlwdGlvbihkZXRhY2g6IHsgW3dlYWsgc2VsZl0gaW5cbiAgc2VsZj8uc3Vic2NyaXB0aW9uPy5kZXRhY2goKVxuICBpZiBsZXQgcGFyZW50ID0gc2VsZj8ucGFyZW50IHtcbiAgICBwYXJlbnQucmVtb3ZlQ2hpbGQoc2VsZiEpXG4gICAgcGFyZW50LmFjdGl2ZSA9IHRydWVcbiAgfVxufSkpXG4gICAgICBgLFxuICAgIH0sXG5cbiAgICB7XG4gICAgICBuYW1lOiAnZG9TdWInLFxuICAgICAgY29kZTogZnVuY3Rpb24gZG9TdWIoKSB7XG4gICAgICAgIGlmICggdGhpcy5zdWJzY3JpcHRpb24gKSB0aGlzLnN1YnNjcmlwdGlvbi5kZXRhY2goKTtcblxuICAgICAgICBpZiAoICEgdGhpcy5zcmMgKSByZXR1cm47XG5cbiAgICAgICAgdmFyIGFyZ3MgPSB0aGlzLnRvcGljLnNsaWNlKClcbiAgICAgICAgYXJncy5wdXNoKHRoaXMub25FdmVudCk7XG4gICAgICAgIHRoaXMuc3Vic2NyaXB0aW9uID0gdGhpcy5zcmMuc3ViLmFwcGx5KHRoaXMuc3JjLCBhcmdzKTtcbiAgICAgIH0sXG4gICAgICBzd2lmdENvZGU6IGBcbnN1YnNjcmlwdGlvbj8uZGV0YWNoKClcbmlmIGxldCBzcmMgPSBzcmMgYXM/IFRvcGljIHtcbiAgc3Vic2NyaXB0aW9uID0gc3JjLnN1Yih0b3BpY3M6IHRvcGljLCBsaXN0ZW5lcjogb25FdmVudF9saXN0ZW5lcilcbn1cbiAgICAgIGAsXG4gICAgfSxcblxuICAgIHtcbiAgICAgIG5hbWU6ICdkb1Vuc3ViJyxcbiAgICAgIGNvZGU6IGZ1bmN0aW9uIGRvVW5zdWIoKSB7XG4gICAgICAgIGlmICggdGhpcy5zdWJzY3JpcHRpb24gKSB0aGlzLnN1YnNjcmlwdGlvbi5kZXRhY2goKTtcbiAgICAgIH0sXG4gICAgICBzd2lmdENvZGU6ICdzdWJzY3JpcHRpb24/LmRldGFjaCgpJyxcbiAgICB9LFxuXG4gICAge1xuICAgICAgbmFtZTogJ3JlbW92ZUNoaWxkJyxcbiAgICAgIGFyZ3M6IFtcbiAgICAgICAge1xuICAgICAgICAgIG5hbWU6ICdjJyxcbiAgICAgICAgICBzd2lmdFR5cGU6ICdFdmVudFByb3h5JyxcbiAgICAgICAgfSxcbiAgICAgIF0sXG4gICAgICBjb2RlOiBmdW5jdGlvbiByZW1vdmVDaGlsZChjKSB7XG4gICAgICAgIGZvciAoIHZhciBrZXkgaW4gdGhpcy5jaGlsZHJlbiApIHtcbiAgICAgICAgICBpZiAoIHRoaXMuY2hpbGRyZW5ba2V5XSA9PT0gYyApIHtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLmNoaWxkcmVuW2tleV07XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgc3dpZnRDb2RlOiBgXG5mb3IgKGtleSwgY2hpbGQpIGluIGNoaWxkcmVuIHtcbiAgaWYgY2hpbGQgPT09IGMge1xuICAgIGNoaWxkcmVuLnJlbW92ZVZhbHVlKGZvcktleToga2V5KVxuICAgIHJldHVyblxuICB9XG59XG4gICAgICBgLFxuICAgIH0sXG5cbiAgICB7XG4gICAgICBuYW1lOiAnZ2V0Q2hpbGQnLFxuICAgICAgYXJnczogW1xuICAgICAgICB7XG4gICAgICAgICAgbmFtZTogJ2tleScsXG4gICAgICAgICAgc3dpZnRUeXBlOiAnU3RyaW5nJyxcbiAgICAgICAgfSxcbiAgICAgIF0sXG4gICAgICBzd2lmdFJldHVybnM6ICdFdmVudFByb3h5JyxcbiAgICAgIGNvZGU6IGZ1bmN0aW9uIGdldENoaWxkKGtleSkge1xuICAgICAgICBpZiAoICEgdGhpcy5jaGlsZHJlbltrZXldICkge1xuICAgICAgICAgIHRoaXMuY2hpbGRyZW5ba2V5XSA9IHRoaXMuY2xzXy5jcmVhdGUoe1xuICAgICAgICAgICAgcGFyZW50OiB0aGlzLFxuICAgICAgICAgICAgZGVzdDogdGhpcy5kZXN0LFxuICAgICAgICAgICAgc3JjOiB0aGlzLnNyYyxcbiAgICAgICAgICAgIHRvcGljOiB0aGlzLnRvcGljLnNsaWNlKCkuY29uY2F0KGtleSlcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5jaGlsZHJlbltrZXldO1xuICAgICAgfSxcbiAgICAgIHN3aWZ0Q29kZTogYFxuaWYgY2hpbGRyZW5ba2V5XSA9PSBuaWwge1xuICBjaGlsZHJlbltrZXldID0gX19jb250ZXh0X18uY3JlYXRlKEV2ZW50UHJveHkuc2VsZiwgYXJnczogW1xuICAgIFwicGFyZW50XCI6IHNlbGYsXG4gICAgXCJkZXN0XCI6IGRlc3QsXG4gICAgXCJzcmNcIjogc3JjLFxuICAgIFwidG9waWNcIjogdG9waWMgKyBba2V5XSxcbiAgXSkhXG59XG5yZXR1cm4gY2hpbGRyZW5ba2V5XSFcbiAgICAgIGAsXG4gICAgfSxcblxuICAgIHtcbiAgICAgIG5hbWU6ICdhZGRQcm94eScsXG4gICAgICBhcmdzOiBbXG4gICAgICAgIHtcbiAgICAgICAgICBuYW1lOiAndG9waWNzJyxcbiAgICAgICAgICBzd2lmdFR5cGU6ICdbU3RyaW5nXScsXG4gICAgICAgIH0sXG4gICAgICBdLFxuICAgICAgY29kZTogZnVuY3Rpb24gYWRkUHJveHkodG9waWMpIHtcbiAgICAgICAgdmFyIGMgPSB0aGlzO1xuICAgICAgICB2YXIgYWN0aXZlID0gdHJ1ZTtcbiAgICAgICAgZm9yICggdmFyIGkgPSAwIDsgaSA8IHRvcGljLmxlbmd0aCA7IGkrKyApIHtcbiAgICAgICAgICBhY3RpdmUgPSBhY3RpdmUgJiYgISBjLmFjdGl2ZTtcbiAgICAgICAgICBjID0gYy5nZXRDaGlsZCh0b3BpY1tpXSk7XG4gICAgICAgIH1cblxuICAgICAgICBjLmFjdGl2ZSA9IGFjdGl2ZTtcbiAgICAgIH0sXG4gICAgICBzd2lmdENvZGU6IGBcbnZhciBjID0gc2VsZlxudmFyIGFjdGl2ZSA9IHRydWVcbmZvciB0IGluIHRvcGljcyB7XG4gIGFjdGl2ZSA9IGFjdGl2ZSAmJiAhYy5hY3RpdmVcbiAgYyA9IGMuZ2V0Q2hpbGQodClcbn1cblxuYy5hY3RpdmUgPSBhY3RpdmU7XG4gICAgICBgLFxuICAgIH0sXG4gIF0sXG5cbiAgbGlzdGVuZXJzOiBbXG4gICAge1xuICAgICAgbmFtZTogJ29uRXZlbnQnLFxuICAgICAgY29kZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICggdGhpcy5hY3RpdmUgKSB7XG4gICAgICAgICAgdmFyIGFyZ3MgPSBmb2FtLkZ1bmN0aW9uLmFwcGVuZEFyZ3VtZW50cyhbXSwgYXJndW1lbnRzLCAxKTtcbiAgICAgICAgICB2YXIgYyA9IHRoaXMuZGVzdC5wdWIuYXBwbHkodGhpcy5kZXN0LCBhcmdzKTtcbiAgICAgICAgICBpZiAoICEgYyApIHRoaXMuZGV0YWNoKCk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBzd2lmdENvZGU6IGBcbmlmIGFjdGl2ZSB7XG4gIGxldCBjID0gZGVzdC5wdWIoYXJncyk7XG4gIGlmIGMgPT0gMCB7IGRldGFjaCgpIH1cbn1cbiAgICAgIGAsXG4gICAgfSxcbiAgXVxufSk7XG5cbmZvYW0uQ0xBU1Moe1xuICBwYWNrYWdlOiAnZm9hbS5jb3JlJyxcbiAgbmFtZTogJ1Byb3h5U3ViJyxcbiAgZXh0ZW5kczogJ01ldGhvZCcsXG5cbiAgcHJvcGVydGllczogW1xuICAgIHtcbiAgICAgIG5hbWU6ICduYW1lJyxcbiAgICAgIGdldHRlcjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiAnc3ViJztcbiAgICAgIH1cbiAgICB9LFxuICAgIHtcbiAgICAgIGNsYXNzOiAnU3RyaW5nJyxcbiAgICAgIG5hbWU6ICdwcm9wJ1xuICAgIH0sXG4gICAge1xuICAgICAgY2xhc3M6ICdTdHJpbmdBcnJheScsXG4gICAgICBuYW1lOiAndG9waWNzJyxcbiAgICAgIGZhY3Rvcnk6IG51bGxcbiAgICB9LFxuICAgIHtcbiAgICAgIG5hbWU6ICdjb2RlJyxcbiAgICAgIGV4cHJlc3Npb246IGZ1bmN0aW9uKHByb3AsIHRvcGljcykge1xuICAgICAgICB2YXIgcHJpdmF0ZU5hbWUgPSBwcm9wICsgJ0V2ZW50UHJveHlfJztcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIHN1YlByb3h5KGExKSB7XG4gICAgICAgICAgaWYgKCAhIHRvcGljcyB8fCB0b3BpY3MuaW5kZXhPZihhMSkgIT0gLTEgKSB7XG4gICAgICAgICAgICB2YXIgcHJveHkgPSB0aGlzLmdldFByaXZhdGVfKHByaXZhdGVOYW1lKTtcbiAgICAgICAgICAgIGlmICggISBwcm94eSApIHtcbiAgICAgICAgICAgICAgcHJveHkgPSBmb2FtLmNvcmUuRXZlbnRQcm94eS5jcmVhdGUoe1xuICAgICAgICAgICAgICAgIGRlc3Q6IHRoaXMsXG4gICAgICAgICAgICAgICAgc3JjOiB0aGlzW3Byb3BdXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB0aGlzLnNldFByaXZhdGVfKHByaXZhdGVOYW1lLCBwcm94eSk7XG5cbiAgICAgICAgICAgICAgcHJveHkuc3JjJC5mb2xsb3codGhpcy5zbG90KHByb3ApKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcHJveHkuYWRkUHJveHkoQXJyYXkuZnJvbShhcmd1bWVudHMpLnNsaWNlKDAsIC0xKSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHRoaXMuU1VQRVIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XG4gIF1cbn0pO1xuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTYgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuZm9hbS5DTEFTUyh7XG4gIHBhY2thZ2U6ICdmb2FtLmNvcmUnLFxuICBuYW1lOiAnUHJvbWlzZWRNZXRob2QnLFxuICBleHRlbmRzOiAnUHJveGllZE1ldGhvZCcsXG5cbiAgcHJvcGVydGllczogW1xuICAgIHtcbiAgICAgIG5hbWU6ICdjb2RlJyxcbiAgICAgIGV4cHJlc3Npb246IGZ1bmN0aW9uKG5hbWUsIHByb3BlcnR5LCByZXR1cm5zLCBkZWxlZ2F0ZSkge1xuICAgICAgICBpZiAoIGRlbGVnYXRlICkge1xuICAgICAgICAgIHJldHVybiByZXR1cm5zID9cbiAgICAgICAgICAgIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgICAgICAgIHZhciBhcmdzID0gYXJndW1lbnRzO1xuICAgICAgICAgICAgICByZXR1cm4gdGhpc1twcm9wZXJ0eV0udGhlbihmdW5jdGlvbihkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRbbmFtZV0uYXBwbHkoc2VsZiwgYXJncyk7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSA6XG4gICAgICAgICAgICBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICAgICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cztcbiAgICAgICAgICAgICAgdGhpc1twcm9wZXJ0eV0udGhlbihmdW5jdGlvbihkKSB7XG4gICAgICAgICAgICAgICAgZFtuYW1lXS5hcHBseShzZWxmLCBhcmdzKTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXR1cm5zID9cbiAgICAgICAgICBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgICAgIHZhciBhcmdzID0gYXJndW1lbnRzO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXNbcHJvcGVydHldLnRoZW4oZnVuY3Rpb24oZCkge1xuICAgICAgICAgICAgICByZXR1cm4gZFtuYW1lXS5hcHBseShkLCBhcmdzKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gOlxuICAgICAgICAgIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgICAgICAgICB0aGlzW3Byb3BlcnR5XS50aGVuKGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgICAgICAgZFtuYW1lXS5hcHBseShkLCBhcmdzKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuICBdXG59KTtcblxuXG5mb2FtLkNMQVNTKHtcbiAgcGFja2FnZTogJ2ZvYW0uY29yZScsXG4gIG5hbWU6ICdQcm9taXNlZCcsXG4gIGV4dGVuZHM6ICdQcm9wZXJ0eScsXG5cbiAgcHJvcGVydGllczogW1xuICAgIHtcbiAgICAgIG5hbWU6ICdvZicsXG4gICAgICByZXF1aXJlZDogdHJ1ZVxuICAgIH0sXG4gICAge1xuICAgICAgY2xhc3M6ICdTdHJpbmdBcnJheScsXG4gICAgICBuYW1lOiAnbWV0aG9kcycsXG4gICAgICB2YWx1ZTogbnVsbCxcbiAgICAgIGZhY3Rvcnk6IG51bGxcbiAgICB9LFxuICAgIHtcbiAgICAgIGNsYXNzOiAnU3RyaW5nQXJyYXknLFxuICAgICAgbmFtZTogJ3RvcGljcycsXG4gICAgICB2YWx1ZTogbnVsbCxcbiAgICAgIGZhY3Rvcnk6IG51bGxcbiAgICB9LFxuICAgIHtcbiAgICAgIG5hbWU6ICdwb3N0U2V0JyxcbiAgICAgIGV4cHJlc3Npb246IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgICAgdmFyIHN0YXRlTmFtZSAgICA9IG5hbWUgKyAnU3RhdGUnO1xuICAgICAgICB2YXIgZGVsZWdhdGVOYW1lID0gbmFtZSArICdEZWxlZ2F0ZSc7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbihfLCBwKSB7XG4gICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICAgIHRoaXNbc3RhdGVOYW1lXSAgICA9IHVuZGVmaW5lZDtcbiAgICAgICAgICB0aGlzW2RlbGVnYXRlTmFtZV0gPSB1bmRlZmluZWQ7XG5cbiAgICAgICAgICBwLnRoZW4oZnVuY3Rpb24oZCkgeyBzZWxmW2RlbGVnYXRlTmFtZV0gPSBkOyB9KTtcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XG4gIF0sXG5cbiAgbWV0aG9kczogW1xuICAgIGZ1bmN0aW9uIGluc3RhbGxJbkNsYXNzKGNscykge1xuICAgICAgdGhpcy5TVVBFUihjbHMpO1xuXG4gICAgICB2YXIgbXlOYW1lICAgICAgICAgPSB0aGlzLm5hbWU7XG4gICAgICB2YXIgc3RhdGVOYW1lICAgICAgPSB0aGlzLm5hbWUgKyAnU3RhdGUnO1xuICAgICAgdmFyIGRlbGVnYXRlTmFtZSAgID0gdGhpcy5uYW1lICsgJ0RlbGVnYXRlJztcbiAgICAgIHZhciBwZW5kaW5nU3RhdGUgICA9ICdQZW5kaW5nJyArIGZvYW0uU3RyaW5nLmNhcGl0YWxpemUobXlOYW1lKTtcbiAgICAgIHZhciBmdWxmaWxsZWRTdGF0ZSA9ICdGdWxmaWxsZWQnICsgZm9hbS5TdHJpbmcuY2FwaXRhbGl6ZShteU5hbWUpO1xuXG4gICAgICB2YXIgZGVsZWdhdGUgPSB0aGlzLmxvb2t1cCh0aGlzLm9mKTtcblxuICAgICAgZnVuY3Rpb24gcmVzb2x2ZU5hbWUobmFtZSkge1xuICAgICAgICB2YXIgbSA9IGRlbGVnYXRlLmdldEF4aW9tQnlOYW1lKG5hbWUpO1xuICAgICAgICBmb2FtLmFzc2VydChmb2FtLmNvcmUuTWV0aG9kLmlzSW5zdGFuY2UobSksICdDYW5ub3QgcHJveHkgbm9uLW1ldGhvZCcsIG5hbWUpO1xuICAgICAgICByZXR1cm4gbTtcbiAgICAgIH1cblxuICAgICAgdmFyIG1ldGhvZHMgPSB0aGlzLm1ldGhvZHMgP1xuICAgICAgICAgIHRoaXMubWV0aG9kcy5tYXAocmVzb2x2ZU5hbWUpIDpcbiAgICAgICAgICBkZWxlZ2F0ZS5nZXRPd25BeGlvbXNCeUNsYXNzKGZvYW0uY29yZS5NZXRob2QpO1xuXG4gICAgICB2YXIgbWV0aG9kTmFtZXMgPSBtZXRob2RzLm1hcChmdW5jdGlvbihtKSB7IHJldHVybiBtLm5hbWU7IH0pO1xuXG4gICAgICB2YXIgbXlBeGlvbXMgPSBbXG4gICAgICAgIGZvYW0uY29yZS5Qcm94eS5jcmVhdGUoe1xuICAgICAgICAgIG5hbWU6ICAgICAgc3RhdGVOYW1lLFxuICAgICAgICAgIG9mOiAgICAgICAgdGhpcy5vZixcbiAgICAgICAgICBkZWxlZ2F0ZXM6IG1ldGhvZE5hbWVzLFxuICAgICAgICAgIGZvcndhcmRzOiAgW10sXG4gICAgICAgICAgZmFjdG9yeTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpc1twZW5kaW5nU3RhdGVdLmNyZWF0ZSgpO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgc3dpZnRGYWN0b3J5OiBgcmV0dXJuICR7cGVuZGluZ1N0YXRlfV9jcmVhdGUoW1wib2JqXCI6IHNlbGZdKWAsXG4gICAgICAgICAgdHJhbnNpZW50OiB0cnVlXG4gICAgICAgIH0pLFxuICAgICAgICBmb2FtLmNvcmUuUHJvcGVydHkuY3JlYXRlKHtcbiAgICAgICAgICBuYW1lOiBkZWxlZ2F0ZU5hbWUsXG4gICAgICAgICAgcG9zdFNldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB0aGlzW3N0YXRlTmFtZV0gPSB0aGlzW2Z1bGZpbGxlZFN0YXRlXS5jcmVhdGUoKTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIHN3aWZ0R2V0dGVyOiBgcmV0dXJuIHRyeSEgJHtteU5hbWV9LmdldCgpIGFzISAke2ZvYW0ubG9va3VwKHRoaXMub2YpLm1vZGVsXy5zd2lmdE5hbWV9YCxcbiAgICAgICAgfSksXG4gICAgICAgIGZvYW0uY29yZS5Qcm94eVN1Yi5jcmVhdGUoe1xuICAgICAgICAgIHRvcGljczogdGhpcy50b3BpY3MsXG4gICAgICAgICAgcHJvcDogICBkZWxlZ2F0ZU5hbWVcbiAgICAgICAgfSlcbiAgICAgIF07XG5cbiAgICAgIHZhciBwZW5kaW5nTWV0aG9kcyA9IFtdO1xuXG4gICAgICBmb3IgKCB2YXIgaSA9IDAgOyBpIDwgbWV0aG9kcy5sZW5ndGggOyBpKysgKSB7XG4gICAgICAgIHBlbmRpbmdNZXRob2RzLnB1c2goZm9hbS5jb3JlLlByb21pc2VkTWV0aG9kLmNyZWF0ZSh7XG4gICAgICAgICAgbmFtZTogbWV0aG9kc1tpXS5uYW1lLFxuICAgICAgICAgIHByb3BlcnR5OiBteU5hbWUsXG4gICAgICAgICAgcmV0dXJuczogIG1ldGhvZHNbaV0ucmV0dXJucyxcbiAgICAgICAgICBkZWxlZ2F0ZTogZmFsc2VcbiAgICAgICAgfSkpO1xuICAgICAgfVxuXG4gICAgICB2YXIgbmFtZSA9IHRoaXMubmFtZTtcbiAgICAgIG15QXhpb21zID0gbXlBeGlvbXMuY29uY2F0KFxuICAgICAgICBmb2FtLmNvcmUuSW5uZXJDbGFzcy5jcmVhdGUoe1xuICAgICAgICAgIG1vZGVsOiB7XG4gICAgICAgICAgICBuYW1lOiBwZW5kaW5nU3RhdGUsXG4gICAgICAgICAgICBpbXBsZW1lbnRzOiBbdGhpcy5vZl0sXG4gICAgICAgICAgICBheGlvbXM6IFtcbiAgICAgICAgICAgICAgZm9hbS5wYXR0ZXJuLlNpbmdsZXRvbi5jcmVhdGUoKVxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIG1ldGhvZHM6IHBlbmRpbmdNZXRob2RzLFxuICAgICAgICAgICAgcHJvcGVydGllczogW1xuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgc3dpZnRUeXBlOiBjbHMubW9kZWxfLnN3aWZ0TmFtZSxcbiAgICAgICAgICAgICAgICBuYW1lOiAnb2JqJyxcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgfVxuICAgICAgICB9KSxcbiAgICAgICAgZm9hbS5jb3JlLklubmVyQ2xhc3MuY3JlYXRlKHtcbiAgICAgICAgICBtb2RlbDoge1xuICAgICAgICAgICAgbmFtZTogZnVsZmlsbGVkU3RhdGUsXG4gICAgICAgICAgICBwcm9wZXJ0aWVzOiBbXG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBjbGFzczogICAgJ1Byb3h5JyxcbiAgICAgICAgICAgICAgICBuYW1lOiAgICAgZGVsZWdhdGVOYW1lLFxuICAgICAgICAgICAgICAgIG9mOiAgICAgICB0aGlzLm9mLFxuICAgICAgICAgICAgICAgIHRvcGljczogICB0aGlzLnRvcGljcyxcbiAgICAgICAgICAgICAgICBmb3J3YXJkczogbWV0aG9kTmFtZXNcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIGF4aW9tczogW1xuICAgICAgICAgICAgICBmb2FtLnBhdHRlcm4uU2luZ2xldG9uLmNyZWF0ZSgpXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgZ2VuZXJhdGVTd2lmdDogZmFsc2UsXG4gICAgICAgICAgfVxuICAgICAgICB9KSk7XG5cbiAgICAgIGNscy5pbnN0YWxsQXhpb21zKG15QXhpb21zKTtcbiAgICB9XG4gIF1cbn0pO1xuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTYgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuZm9hbS5DTEFTUyh7XG4gIHBhY2thZ2U6ICdmb2FtLmNvcmUuaW50ZXJuYWwnLFxuICBuYW1lOiAnSW50ZXJmYWNlTWV0aG9kJyxcbiAgZXh0ZW5kczogJ2ZvYW0uY29yZS5NZXRob2QnLFxuXG4gIGRvY3VtZW50YXRpb246ICdBbiBJbnRlcmZhY2VNZXRob2QgaXMgYSBNZXRob2QgZGVjbGFyYXRpb24sIGJ1dCBsYWNrcyBjb2RlLicsXG5cbiAgcHJvcGVydGllczogW1xuICAgIHtcbiAgICAgIG5hbWU6ICdjb2RlJyxcbiAgICAgIHJlcXVpcmVkOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgY2xhc3M6ICdCb29sZWFuJyxcbiAgICAgIG5hbWU6ICdhYnN0cmFjdCcsXG4gICAgICB2YWx1ZTogdHJ1ZVxuICAgIH1cbiAgXSxcblxuICBtZXRob2RzOiBbXG4gICAgZnVuY3Rpb24gaW5zdGFsbEluUHJvdG8oKSB7IH0sXG4gICAgZnVuY3Rpb24gaW5zdGFsbEluQ2xhc3MoY2xzLCBzdXBlck1ldGhvZCwgZXhpc3RpbmdNZXRob2QpIHtcbiAgICAgIC8vIFRoaXMgaXMgcmVxdWlyZWQgdG8gYXZvaWQgaW5oZXJpdGFuY2UgZnJvbSByZWd1bGFyIG1ldGhvZHMsXG4gICAgICAvLyB3aGljaCB3b3VsZCBwcmV2ZW50IG1ldGhvZHMgZnJvbSBiZWluZyBuYW1lZCB0aGUgc2FtZSBhcyBtZXRob2RzXG4gICAgICAvLyBkZWZpbmVkIG9uIEZPYmplY3QsIGxpa2U6IGxvZywgd2FybiwgZXJyb3IuXG4gICAgICBjbHMuYXhpb21NYXBfW3RoaXMubmFtZV0gPSB0aGlzO1xuICAgIH1cbiAgXVxufSk7XG5cblxuZm9hbS5DTEFTUyh7XG4gIHBhY2thZ2U6ICdmb2FtLmNvcmUnLFxuICBuYW1lOiAnSW50ZXJmYWNlTW9kZWwnLFxuICBleHRlbmRzOiAnZm9hbS5jb3JlLk1vZGVsJyxcblxuICBkb2N1bWVudGF0aW9uOiAnQW4gSW50ZXJmYWNlIE1vZGUvZGVmaW5pdGlvbi4gQ3JlYXRlZCB3aXRoIGZvYW0uSU5URVJGQUNFKCkuJyxcblxuICBwcm9wZXJ0aWVzOiBbXG4gICAgWyAnZXh0ZW5kcycsICdmb2FtLmNvcmUuQWJzdHJhY3RJbnRlcmZhY2UnIF0sXG4gICAge1xuICAgICAgY2xhc3M6ICdBeGlvbUFycmF5JyxcbiAgICAgIG5hbWU6ICdtZXRob2RzJyxcbiAgICAgIG9mOiAnZm9hbS5jb3JlLmludGVybmFsLkludGVyZmFjZU1ldGhvZCdcbiAgICB9LFxuICAgIHtcbiAgICAgIGNsYXNzOiAnU3RyaW5nQXJyYXknLFxuICAgICAgbmFtZTogJ2phdmFFeHRlbmRzJ1xuICAgIH1cbiAgXVxufSk7XG5cblxuZm9hbS5DTEFTUyh7XG4gIHBhY2thZ2U6ICdmb2FtLmNvcmUnLFxuICBuYW1lOiAnQWJzdHJhY3RJbnRlcmZhY2UnLFxuXG4gIGRvY3VtZW50YXRpb246ICdBYnN0cmFjdCBiYXNlLWNsYXNzIGZvciBJbnRlcmZhY2VzLicsXG5cbiAgYXhpb21zOiBbXG4gICAge1xuICAgICAgaW5zdGFsbEluQ2xhc3M6IGZ1bmN0aW9uKGNscykge1xuICAgICAgICBjbHMuY3JlYXRlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGluc3RhbnRpYXRlIGFuIEludGVyZmFjZS5cIik7XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuICBdXG59KTtcblxuXG5mb2FtLkxJQih7XG4gIG5hbWU6ICdmb2FtJyxcblxuICBtZXRob2RzOiBbXG4gICAgZnVuY3Rpb24gSU5URVJGQUNFKG0pIHtcblxuICAgICAgbS5jbGFzcyA9IG0uY2xhc3MgfHwgJ2ZvYW0uY29yZS5JbnRlcmZhY2VNb2RlbCc7XG4gICAgICAvLyBpZiBtLmltcGxlbWVudHMgbm90IGRlZmluZWQsIGFkZCBpdCBhcyBhbiBhcnJheSwgb3RoZXJ3aXNlIGFkZCBpdHMgY29udGVudFxuICAgICAgLy8gaW4gYW4gYXJyYXlcbiAgICAgIGlmICggISBtLmltcGxlbWVudHMgKSB7XG4gICAgICAgIG0uaW1wbGVtZW50cyA9IFtdO1xuICAgICAgfSBlbHNlIGlmICggdHlwZW9mIG0uaW1wbGVtZW50cyA9PT0gJ3N0cmluZycgKSB7XG4gICAgICAgIG0uaW1wbGVtZW50cyA9IFttLmltcGxlbWVudHNdO1xuICAgICAgfVxuICAgICAgLy8gYWRkcyBtLmV4dGVuZHMgY29udGVudCB0byBtLmltcGxlbWVudHMgYW5kIHRoZW4gcmVtb3ZlIGl0XG4gICAgICBpZiAoIG0uZXh0ZW5kcyApIHtcbiAgICAgICAgaWYgKCB0eXBlb2YgbS5leHRlbmRzID09PSAnc3RyaW5nJyApIHtcbiAgICAgICAgICBtLmltcGxlbWVudHMucHVzaChtLmV4dGVuZHMpO1xuICAgICAgICB9IGVsc2UgaWYoIG0uZXh0ZW5kcy5sZW5ndGggPiAwICkge1xuICAgICAgICAgIG0uaW1wbGVtZW50cyA9IG0uaW1wbGVtZW50cy5jb25jYXQobS5leHRlbmRzKTtcbiAgICAgICAgfVxuICAgICAgICBkZWxldGUgbS5leHRlbmRzO1xuICAgICAgfVxuICAgICAgZm9hbS5DTEFTUyhtKTtcbiAgICB9XG4gIF1cbn0pO1xuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgVGhlIEZPQU0gQXV0aG9ycy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICovXG5cbmZvYW0uSU5URVJGQUNFKHtcbiAgcGFja2FnZTogJ2ZvYW0uY29yZScsXG4gIG5hbWU6ICdBeGlvbScsXG5cbiAgZG9jdW1lbnRhdGlvbjogJ1JlcHJlc2VudHMgYW4gYXhpb20nLFxuXG4gIG1ldGhvZHM6IFtcbiAgICB7XG4gICAgICBuYW1lOiAnZ2V0TmFtZScsXG4gICAgICByZXR1cm5zOiAnU3RyaW5nJyxcbiAgICAgIGphdmFSZXR1cm5zOiAnU3RyaW5nJ1xuICAgIH1cbiAgXVxufSk7XG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBUaGUgRk9BTSBBdXRob3JzLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5mb2FtLklOVEVSRkFDRSh7XG4gIHBhY2thZ2U6ICdmb2FtLmNvcmUnLFxuICBuYW1lOiAnRXhjZXB0aW9uJyxcbiAgc3dpZnRJbXBsZW1lbnRzOiBbJ0Vycm9yJ10sXG59KTtcbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmZvYW0uQ0xBU1Moe1xuICBwYWNrYWdlOiAnZm9hbS5jb3JlJyxcbiAgbmFtZTogJ0NvbnRleHRNZXRob2QnLFxuICBleHRlbmRzOiAnZm9hbS5jb3JlLk1ldGhvZCcsXG5cbiAgZG9jdW1lbnRhdGlvbjogJ0EgTWV0aG9kIHdoaWNoIGhhcyB0aGUgY2FsbC1zaXRlIGNvbnRleHQgYWRkZWQgYXMgdGhlIGZpcnN0IGFyZ3VtZW50IHdoZW4gZXhwb3J0ZWQuIFNlZSB1c2UgaW4gZm9hbS51Mi5VMkNvbnRleHQuRScsXG5cbiAgbWV0aG9kczogW1xuICAgIGZ1bmN0aW9uIGV4cG9ydEFzKG9iaikge1xuICAgICAgdmFyIG0gPSBvYmpbdGhpcy5uYW1lXTtcblxuICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgY3R4ID0gZm9hbS5jb3JlLkZPYmplY3QuaXNJbnN0YW5jZSh0aGlzKSA/IHRoaXMuX19jb250ZXh0X18gOiB0aGlzO1xuXG4gICAgICAgIHJldHVybiBtLmFwcGx5KG9iaiwgZm9hbS5GdW5jdGlvbi5hcHBlbmRBcmd1bWVudHMoW2N0eF0sIGFyZ3VtZW50cywgMCkpO1xuICAgICAgfTtcbiAgICB9XG4gIF1cbn0pO1xuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTYgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuZm9hbS5DTEFTUyh7XG4gIHBhY2thZ2U6ICdmb2FtLmNvcmUnLFxuICBuYW1lOiAnV2luZG93JyxcblxuICBkb2N1bWVudGF0aW9uOiBmdW5jdGlvbigpey8qXG4gICAgRW5jYXBzdWxhdGVzIHRvcC1sZXZlbCB3aW5kb3cvZG9jdW1lbnQgZmVhdHVyZXMuXG5cbiAgICBFeHBvcnQgY29tbW9uIHdpbmRvdy9kb2N1bWVudCBzZXJ2aWNlcyB0aHJvdWdoIHRoZSBDb250ZXh0LlxuXG4gICAgUmF0aGVyIHRoYW4gdXNpbmcgd2luZG93IG9yIGRvY3VtZW50IGRpcmVjdGx5LCBvYmplY3RzIHNob3VsZCBpbXBvcnQ6IHRoZVxuICAgIHNlcnZpY2VzIHRoYXQgZm9hbS5jb3JlLldpbmRvdyBleHBvcnRzOiwgYW5kIHRoZW4gYWNjZXNzIHRoZW0gYXMgdGhpcy5uYW1lLFxuICAgIHJhdGhlciB0aGFuIGFzIGNvbnNvbGUubmFtZSBvciBkb2N1bWVudC5uYW1lLlxuXG4gICAgQWxsIEZPYmplY3RzIGFscmVhZHkgaW1wb3J0OiBbICdlcnJvcicsICdsb2cnLCAnd2FybicgXSwgbWVhbmluZ1xuICAgIHRoYXQgdGhlc2UgZG8gbm90IG5lZWQgdG8gYmUgZXhwbGljaXRseSBpbXBvcnRlZC5cblxuICAgIFRoaXMgaXMgZG9uZSB0byByZW1vdmUgZGVwZW5kZW5jeSBvbiB0aGUgZ2xvYmFscyAnZG9jdW1lbnQnIGFuZCAnd2luZG93JyxcbiAgICB3aGljaCBtYWtlcyBpdCBlYXNpZXIgdG8gd3JpdGUgY29kZSB3aGljaCB3b3JrcyB3aXRoIG11bHRpcGxlIHdpbmRvd3MuXG5cbiAgICBJdCBhbHNvIGFsbG93cyBmb3IgY29tbW9uIHNlcnZpY2VzIHRvIGJlIGRlY29yYXRlZCwgdHJhcHBlZCwgb3IgcmVwbGFjZWRcbiAgICBpbiBzdWItY29udGV4dHMgKGZvciBleGFtcGxlLCB0byByZXBsYWNlIGNvbnNvbGUuZXJyb3IgYW5kIGNvbnNvbGUud2FybiB3aGVuXG4gICAgcnVubmluZyB0ZXN0KS5cblxuICAgIEEgZm9hbS5jb3JlLldpbmRvdyBpcyBpbnN0YWxsZWQgYnkgRk9BTSBvbiBzdGFydXAgZm9yIHRoZSBkZWZhdWx0XG4gICAgd2luZG93L2RvY3VtZW50LCBidXQgaWYgdXNlciBjb2RlIG9wZW5zIGEgbmV3IFdpbmRvdywgaXQgc2hvdWxkIGNyZWF0ZVxuICAgIGFuZCBpbnN0YWxsIGEgbmV3IGZvYW0uY29yZS5XaW5kb3cgZXhwbGljaXRseS5cbiAgKi99LFxuXG4gIGV4cG9ydHM6IFtcbiAgICAnZ2V0RWxlbWVudHNCeUNsYXNzTmFtZScsXG4gICAgJ2dldEVsZW1lbnRCeUlkJyxcbiAgICAnYXN5bmMnLFxuICAgICdjYW5jZWxBbmltYXRpb25GcmFtZScsXG4gICAgJ2NsZWFySW50ZXJ2YWwnLFxuICAgICdjbGVhclRpbWVvdXQnLFxuICAgICdjb25zb2xlJyxcbiAgICAnZGVidWcnLFxuICAgICdkZWxheWVkJyxcbiAgICAnZG9jdW1lbnQnLFxuICAgICdlcnJvcicsXG4gICAgJ2ZyYW1lZCcsXG4gICAgJ2luZm8nLFxuICAgICdpbnN0YWxsQ1NTJyxcbiAgICAnbG9nJyxcbiAgICAnbWVyZ2VkJyxcbiAgICAncmVxdWVzdEFuaW1hdGlvbkZyYW1lJyxcbiAgICAnc2V0SW50ZXJ2YWwnLFxuICAgICdzZXRUaW1lb3V0JyxcbiAgICAnd2FybicsXG4gICAgJ3dpbmRvdydcbiAgXSxcblxuICBwcm9wZXJ0aWVzOiBbXG4gICAgWyAnbmFtZScsICd3aW5kb3cnIF0sXG4gICAgJ3dpbmRvdycsXG4gICAge1xuICAgICAgbmFtZTogJ2RvY3VtZW50JyxcbiAgICAgIGZhY3Rvcnk6IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcy53aW5kb3cuZG9jdW1lbnQ7IH1cbiAgICB9LFxuICAgIHtcbiAgICAgIG5hbWU6ICdjb25zb2xlJyxcbiAgICAgIGZhY3Rvcnk6IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcy53aW5kb3cuY29uc29sZTsgfVxuICAgIH1cbiAgXSxcblxuICBtZXRob2RzOiBbXG4gICAgZnVuY3Rpb24gZ2V0RWxlbWVudEJ5SWQoaWQpIHtcbiAgICAgIHJldHVybiB0aGlzLmRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGlkKTtcbiAgICB9LFxuXG4gICAgZnVuY3Rpb24gZ2V0RWxlbWVudHNCeUNsYXNzTmFtZShjbHMpIHtcbiAgICAgIHJldHVybiB0aGlzLmRvY3VtZW50LmdldEVsZW1lbnRzQnlDbGFzc05hbWUoY2xzKTtcbiAgICB9LFxuXG4gICAgZnVuY3Rpb24gZGVidWcoKSB7XG4gICAgICB0aGlzLmNvbnNvbGUuZGVidWcuYXBwbHkodGhpcy5jb25zb2xlLCBhcmd1bWVudHMpO1xuICAgIH0sXG5cbiAgICBmdW5jdGlvbiBlcnJvcigpIHtcbiAgICAgIHRoaXMuY29uc29sZS5lcnJvci5hcHBseSh0aGlzLmNvbnNvbGUsIGFyZ3VtZW50cyk7XG4gICAgfSxcblxuICAgIGZ1bmN0aW9uIGluZm8oKSB7XG4gICAgICB0aGlzLmNvbnNvbGUuaW5mby5hcHBseSh0aGlzLmNvbnNvbGUsIGFyZ3VtZW50cyk7XG4gICAgfSxcblxuICAgIGZ1bmN0aW9uIGxvZygpIHtcbiAgICAgIHRoaXMuY29uc29sZS5sb2cuYXBwbHkodGhpcy5jb25zb2xlLCBhcmd1bWVudHMpO1xuICAgIH0sXG5cbiAgICBmdW5jdGlvbiB3YXJuKCkge1xuICAgICAgdmFyIG1zZyA9IEFycmF5LnByb3RvdHlwZS5qb2luLmNhbGwoYXJndW1lbnRzLCAnJyk7XG4gICAgICBpZiAoIFNVUFBSRVNTRURfV0FSTklOR1NbbXNnXSApIHJldHVybjtcbiAgICAgIHRoaXMuY29uc29sZS53YXJuKG1zZylcbiAgICB9LFxuXG4gICAgZnVuY3Rpb24gYXN5bmMobCkge1xuICAgICAgLyogRGVjb3JhdGUgYSBsaXN0ZW5lciBzbyB0aGF0IHRoZSBldmVudCBpcyBkZWxpdmVyZWQgYXN5bmNocm9ub3VzbHkuICovXG4gICAgICByZXR1cm4gdGhpcy5kZWxheWVkKGwsIDApO1xuICAgIH0sXG5cbiAgICBmdW5jdGlvbiBkZWxheWVkKGwsIGRlbGF5KSB7XG4gICAgICAvKiBEZWNvcmF0ZSBhIGxpc3RlbmVyIHNvIHRoYXQgZXZlbnRzIGFyZSBkZWxpdmVyZWQgJ2RlbGF5JyBtcyBsYXRlci4gKi9cbiAgICAgIHJldHVybiBmb2FtLkZ1bmN0aW9uLmJpbmQoZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuc2V0VGltZW91dChcbiAgICAgICAgICBmdW5jdGlvbigpIHsgbC5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9LFxuICAgICAgICAgIGRlbGF5KTtcbiAgICAgIH0sIHRoaXMpO1xuICAgIH0sXG5cbiAgICBmdW5jdGlvbiBtZXJnZWQobCwgb3B0X2RlbGF5KSB7XG4gICAgICB2YXIgZGVsYXkgPSBvcHRfZGVsYXkgfHwgMTY7XG4gICAgICB2YXIgY3R4ICAgICA9IHRoaXM7XG5cbiAgICAgIHJldHVybiBmb2FtLkZ1bmN0aW9uLnNldE5hbWUoZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciB0cmlnZ2VyZWQgPSBmYWxzZTtcbiAgICAgICAgdmFyIGxhc3RBcmdzICA9IG51bGw7XG4gICAgICAgIGZ1bmN0aW9uIG1lcmdlZExpc3RlbmVyKCkge1xuICAgICAgICAgIHRyaWdnZXJlZCA9IGZhbHNlO1xuICAgICAgICAgIHZhciBhcmdzID0gQXJyYXkuZnJvbShsYXN0QXJncyk7XG4gICAgICAgICAgbGFzdEFyZ3MgPSBudWxsO1xuICAgICAgICAgIGwuYXBwbHkodGhpcywgYXJncyk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZiA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGxhc3RBcmdzID0gYXJndW1lbnRzO1xuXG4gICAgICAgICAgaWYgKCAhIHRyaWdnZXJlZCApIHtcbiAgICAgICAgICAgIHRyaWdnZXJlZCA9IHRydWU7XG4gICAgICAgICAgICBjdHguc2V0VGltZW91dChtZXJnZWRMaXN0ZW5lciwgZGVsYXkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gZjtcbiAgICAgIH0oKSwgJ21lcmdlZCgnICsgbC5uYW1lICsgJyknKTtcbiAgICB9LFxuXG4gICAgZnVuY3Rpb24gZnJhbWVkKGwpIHtcbiAgICAgIHZhciBjdHggPSB0aGlzO1xuXG4gICAgICByZXR1cm4gZm9hbS5GdW5jdGlvbi5zZXROYW1lKGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgdHJpZ2dlcmVkID0gZmFsc2U7XG4gICAgICAgIHZhciBsYXN0QXJncyAgPSBudWxsO1xuICAgICAgICBmdW5jdGlvbiBmcmFtZUZpcmVkKCkge1xuICAgICAgICAgIHRyaWdnZXJlZCA9IGZhbHNlO1xuICAgICAgICAgIHZhciBhcmdzID0gbGFzdEFyZ3M7XG4gICAgICAgICAgbGFzdEFyZ3MgPSBudWxsO1xuICAgICAgICAgIGwuYXBwbHkodGhpcywgYXJncyk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZiA9IGZ1bmN0aW9uIGZyYW1lZCgpIHtcbiAgICAgICAgICBsYXN0QXJncyA9IGFyZ3VtZW50cztcblxuICAgICAgICAgIGlmICggISB0cmlnZ2VyZWQgKSB7XG4gICAgICAgICAgICB0cmlnZ2VyZWQgPSB0cnVlO1xuICAgICAgICAgICAgY3R4LnJlcXVlc3RBbmltYXRpb25GcmFtZShmcmFtZUZpcmVkKTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIGY7XG4gICAgICB9KCksICdmcmFtZWQoJyArIGwubmFtZSArICcpJyk7XG4gICAgfSxcblxuICAgIGZ1bmN0aW9uIHNldFRpbWVvdXQoZiwgdCkge1xuICAgICAgcmV0dXJuIHRoaXMud2luZG93LnNldFRpbWVvdXQoZiwgdCk7XG4gICAgfSxcbiAgICBmdW5jdGlvbiBjbGVhclRpbWVvdXQoaWQpIHtcbiAgICAgIHRoaXMud2luZG93LmNsZWFyVGltZW91dChpZCk7XG4gICAgfSxcblxuICAgIGZ1bmN0aW9uIHNldEludGVydmFsKGYsIHQpIHtcbiAgICAgIHJldHVybiB0aGlzLndpbmRvdy5zZXRJbnRlcnZhbChmLCB0KTtcbiAgICB9LFxuICAgIGZ1bmN0aW9uIGNsZWFySW50ZXJ2YWwoaWQpIHtcbiAgICAgIHRoaXMud2luZG93LmNsZWFySW50ZXJ2YWwoaWQpO1xuICAgIH0sXG5cbiAgICBmdW5jdGlvbiByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZikge1xuICAgICAgcmV0dXJuIHRoaXMud2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZShmKTtcbiAgICB9LFxuICAgIGZ1bmN0aW9uIGNhbmNlbEFuaW1hdGlvbkZyYW1lKGlkKSB7XG4gICAgICB0aGlzLndpbmRvdy5jYW5jZWxBbmltYXRpb25GcmFtZShpZCk7XG4gICAgfSxcbiAgICBmdW5jdGlvbiBpbnN0YWxsQ1NTKHRleHQsIGlkKSB7XG4gICAgICAvKiBDcmVhdGUgYSBuZXcgPHN0eWxlPiB0YWcgY29udGFpbmluZyB0aGUgZ2l2ZW4gQ1NTIGNvZGUuICovXG4gICAgICB0aGlzLmRvY3VtZW50ICYmIHRoaXMuZG9jdW1lbnQuaGVhZC5pbnNlcnRBZGphY2VudEhUTUwoJ2JlZm9yZWVuZCcsXG4gICAgICAgICAgJzxzdHlsZSBvd25lcj1cIicgKyBpZCArICdcIj4nICsgdGV4dCArICc8L3N0eWxlPicpO1xuICAgIH1cbiAgXVxufSk7XG5cblxuLypcbiAqIHJlcXVlc3RBbmltYXRpb25GcmFtZSBpcyBub3QgYXZhaWxhYmxlIG9uIG5vZGVqcyxcbiAqIHNvIHN3YXAgb3V0IHdpdGggY2FsbHMgdG8gc2V0VGltZW91dC5cbiAqL1xuaWYgKCBmb2FtLmlzU2VydmVyICkge1xuICBmb2FtLkNMQVNTKHtcbiAgICByZWZpbmVzOiAnZm9hbS5jb3JlLldpbmRvdycsXG4gICAgbWV0aG9kczogW1xuICAgICAgZnVuY3Rpb24gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGYpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2V0VGltZW91dChmLCAxNik7XG4gICAgICB9LFxuICAgICAgZnVuY3Rpb24gY2FuY2VsQW5pbWF0aW9uRnJhbWUoaWQpIHtcbiAgICAgICAgdGhpcy5jbGVhclRpbWVvdXQoaWQpO1xuICAgICAgfVxuICAgIF1cbiAgfSk7XG59XG5cblxuLy8gUmVwbGFjZSB0b3AtbGV2ZWwgQ29udGV4dCB3aXRoIG9uZSB3aGljaCBpbmNsdWRlcyBXaW5kb3cncyBleHBvcnRzLlxuZm9hbS5fX2NvbnRleHRfXyA9IGZvYW0uY29yZS5XaW5kb3cuY3JlYXRlKFxuICB7IHdpbmRvdzogZ2xvYmFsIH0sXG4gIGZvYW0uX19jb250ZXh0X19cbikuX19zdWJDb250ZXh0X187XG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBUaGUgRk9BTSBBdXRob3JzLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKi9cblxuZm9hbS5DTEFTUyh7XG4gIHBhY2thZ2U6ICdmb2FtLmNvcmUuaW50ZXJuYWwnLFxuICBuYW1lOiAnQ29udGV4dE11bHRpcGxlSW5oZXJpdGVuY2UnLFxuICBcbiAgZXhwb3J0czogW1xuICAgICdjcmVhdGVTdWJDb250ZXh0J1xuICBdLFxuXG4gIG1ldGhvZHM6IFtcbiAgICB7XG4gICAgICBjbGFzczogJ0NvbnRleHRNZXRob2QnLFxuICAgICAgbmFtZTogJ2NyZWF0ZVN1YkNvbnRleHQnLFxuICAgICAgY29kZTogZnVuY3Rpb24gY3JlYXRlU3ViQ29udGV4dChYLCBvcHRfYXJncywgb3B0X25hbWUpIHtcbiAgICAgICAgLy8gVE9ETyhhZGFtdnkpOiBSZXZpc2l0IHRoaXMuICBDb25zaWRlciBhZGRpbmcgYSBNdWx0aUNvbnRleHQgb2JqZWN0IHdoaWNoXG4gICAgICAgIC8vIGltcGxlbWVudGVkIGNvbnRleHQgbXVsdGlwbGUgaW5oZXJpdGVuY2UgcHJvcGVydHkuXG4gICAgICAgIGlmICggZm9hbS5jb3JlLkZPYmplY3QuaXNJbnN0YW5jZShvcHRfYXJncykgKSB7XG4gICAgICAgICAgdmFyIG9iaiA9IG9wdF9hcmdzO1xuXG4gICAgICAgICAgdmFyIGV4cG9ydHMgPSBvYmouY2xzXy5nZXRBeGlvbXNCeUNsYXNzKGZvYW0uY29yZS5FeHBvcnQpO1xuXG4gICAgICAgICAgaWYgKCAoICEgZXhwb3J0cyApIHx8ICggISBleHBvcnRzLmxlbmd0aCApICkgcmV0dXJuIFg7XG5cbiAgICAgICAgICBvcHRfYXJncyA9IGV4cG9ydHNbMF0uZ2V0RXhwb3J0TWFwLmNhbGwob2JqKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLl9fY29udGV4dF9fLmNyZWF0ZVN1YkNvbnRleHQuY2FsbChYLCBvcHRfYXJncywgb3B0X25hbWUpO1xuICAgICAgfVxuICAgIH1cbiAgXVxufSk7XG5cbihmdW5jdGlvbigpIHtcbiAgdmFyIHRtcCA9IGZvYW0uY29yZS5pbnRlcm5hbC5Db250ZXh0TXVsdGlwbGVJbmhlcml0ZW5jZS5jcmVhdGUoKTtcbiAgdG1wLnNldFByaXZhdGVfKCdfX2NvbnRleHRfXycsIGZvYW0uX19jb250ZXh0X18pO1xuICBmb2FtLl9fY29udGV4dF9fID0gdG1wLl9fc3ViQ29udGV4dF9fO1xufSkoKTtcbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmZvYW0uQ0xBU1Moe1xuICBwYWNrYWdlOiAnZm9hbS5jbGFzc2xvYWRlcicsXG4gIG5hbWU6ICdNb2RlbEFSZXF1aXJlRXh0ZW5zaW9uJyxcbiAgcmVmaW5lczogJ2ZvYW0uY29yZS5Nb2RlbCcsXG5cbiAgbWV0aG9kczogW1xuICAgIGZ1bmN0aW9uIGFyZXF1aXJlKG9wdF9kZXBzKSB7XG4gICAgICB2YXIgWCA9IHRoaXMuX19jb250ZXh0X187XG4gICAgICB2YXIgcHJvbWlzZXMgPSBbXTtcbiAgICAgIGlmICggdGhpcy5leHRlbmRzICkgcHJvbWlzZXMucHVzaChYLmFyZXF1aXJlKHRoaXMuZXh0ZW5kcywgb3B0X2RlcHMpKTtcblxuICAgICAgZm9yICggdmFyIGkgPSAwLCBhOyBhID0gdGhpcy5heGlvbXNfW2ldOyBpKysgKSB7XG4gICAgICAgIGlmICggYS5hcmVxdWlyZSApIHByb21pc2VzLnB1c2goYS5hcmVxdWlyZShvcHRfZGVwcykpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gUHJvbWlzZS5hbGwocHJvbWlzZXMpO1xuICAgIH1cbiAgXVxufSk7XG5cblxuZm9hbS5DTEFTUyh7XG4gIHBhY2thZ2U6ICdmb2FtLmNsYXNzbG9hZGVyJyxcbiAgbmFtZTogJ1JlcXVpcmVzQVJlcXVpcmVFeHRlbnNpb24nLFxuICByZWZpbmVzOiAnZm9hbS5jb3JlLlJlcXVpcmVzJyxcblxuICBtZXRob2RzOiBbXG4gICAgZnVuY3Rpb24gYXJlcXVpcmUob3B0X2RlcHMpIHtcbiAgICAgIHJldHVybiB0aGlzLl9fY29udGV4dF9fLmFyZXF1aXJlKHRoaXMucGF0aCwgb3B0X2RlcHMpO1xuICAgIH1cbiAgXVxufSk7XG5cblxuZm9hbS5DTEFTUyh7XG4gIHBhY2thZ2U6ICdmb2FtLmNsYXNzbG9hZGVyJyxcbiAgbmFtZTogJ0NsYXNzTG9hZGVyJyxcblxuICBkb2N1bWVudGF0aW9uOiAnQXN5bmNocm9ub3VzIGNsYXNzIGxvYWRlciBzZXJ2aWNlLiBMb2FkcyBjbGFzc2VzIGR5bmFtaWNhbGx5LicsXG5cbiAgZXhwb3J0czogW1xuICAgICdhcmVxdWlyZSdcbiAgXSxcblxuICBwcm9wZXJ0aWVzOiBbXG4gICAge1xuICAgICAgbmFtZTogJ3BlbmRpbmcnLFxuICAgICAgY2xhc3M6ICdPYmplY3QnLFxuICAgICAgZmFjdG9yeTogZnVuY3Rpb24oKSB7IHJldHVybiB7fTsgfVxuICAgIH1cbiAgXSxcblxuICBtZXRob2RzOiBbXG4gICAge1xuICAgICAgbmFtZTogJ2FyZXF1aXJlJyxcbiAgICAgIGNsYXNzOiAnZm9hbS5jb3JlLkNvbnRleHRNZXRob2QnLFxuICAgICAgY29kZTogZnVuY3Rpb24oWCwgbW9kZWxJZCwgb3B0X2RlcHMpIHtcbiAgICAgICAgLy8gQ29udGFpbnMgbW9kZWxzIHRoYXQgZGVwZW5kIG9uIHRoZSBtb2RlbElkIGFuZCBoYXZlIGFscmVhZHkgYmVlblxuICAgICAgICAvLyBhcmVxdWlyZWQuIFVzZWQgdG8gYXZvaWQgY2lyY3VsYXIgZGVwZW5kZW5jaWVzIGZyb20gd2FpdGluZyBvblxuICAgICAgICAvLyBlYWNoIG90aGVyLlxuICAgICAgICB2YXIgZGVwcyA9IG9wdF9kZXBzIHx8IHt9O1xuXG4gICAgICAgIGlmICggWC5pc1JlZ2lzdGVyZWQobW9kZWxJZCkgKSByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgICAgIGlmICggZGVwc1ttb2RlbElkXSApIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICAgICAgaWYgKCB0aGlzLnBlbmRpbmdbbW9kZWxJZF0gKSByZXR1cm4gdGhpcy5wZW5kaW5nW21vZGVsSWRdO1xuICAgICAgICBkZXBzW21vZGVsSWRdID0gdHJ1ZTtcblxuICAgICAgICB2YXIgbW9kZWxEYW8gPSBYLmNsYXNzbG9hZGVyW2ZvYW0uU3RyaW5nLmRhb2l6ZShmb2FtLmNvcmUuTW9kZWwubmFtZSldO1xuICAgICAgICB0aGlzLnBlbmRpbmdbbW9kZWxJZF0gPSBtb2RlbERhby5maW5kKG1vZGVsSWQpLnRoZW4oZnVuY3Rpb24obSkge1xuICAgICAgICAgIC8vIE1vZGVsIHZhbGlkYXRpb24gbWF5IG1ha2UgdXNlIG9mIGRlcHMuIFJlcXVpcmUgdGhlbSBmaXJzdCwgdGhlblxuICAgICAgICAgIC8vIHZhbGlkYXRlIHRoZSBtb2RlbC5cbiAgICAgICAgICBmb2FtLmFzc2VydChtLCAnQ2Fubm90IGZpbmQgJyArIG1vZGVsSWQpO1xuICAgICAgICAgIHJldHVybiBtLmFyZXF1aXJlKGRlcHMpLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBtLnZhbGlkYXRlKCk7XG4gICAgICAgICAgICByZXR1cm4gbTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSkudGhlbihmdW5jdGlvbihtKSB7XG4gICAgICAgICAgaWYgKCBYLmlzUmVnaXN0ZXJlZChtb2RlbElkKSApIHJldHVybiBtO1xuXG4gICAgICAgICAgaWYgKCBtLnJlZmluZXMgKSB7XG4gICAgICAgICAgICBmb2FtLkNMQVNTKG0pO1xuICAgICAgICAgICAgcmV0dXJuIG07XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgbS5pZCA9IG0ucGFja2FnZSA/IG0ucGFja2FnZSArICcuJyArIG0ubmFtZSA6IG0ubmFtZTtcbiAgICAgICAgICBmb2FtLlVOVVNFRFttLmlkXSA9IHRydWU7XG5cbiAgICAgICAgICB2YXIgZiA9IGZvYW0uRnVuY3Rpb24ubWVtb2l6ZTAoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBkZWxldGUgZm9hbS5VTlVTRURbbS5pZF07XG4gICAgICAgICAgICB2YXIgYyA9IG0uYnVpbGRDbGFzcygpO1xuICAgICAgICAgICAgYy52YWxpZGF0ZSgpO1xuICAgICAgICAgICAgZm9hbS5VU0VEW20uaWRdID0gYztcbiAgICAgICAgICAgIHJldHVybiBjO1xuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgLy8gUmVnaXN0ZXIgbW9kZWwgaW4gZ2xvYmFsIGNvbnRleHQgYW5kIGdsb2JhbCBuYW1lc3BhY2UuXG4gICAgICAgICAgZm9hbS5fX2NvbnRleHRfXy5yZWdpc3RlckZhY3RvcnkobSwgZik7XG4gICAgICAgICAgZm9hbS5wYWNrYWdlLnJlZ2lzdGVyQ2xhc3NGYWN0b3J5KG0sIGYpO1xuICAgICAgICAgIHJldHVybiBtO1xuICAgICAgICB9KTtcblxuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIHRoaXMucGVuZGluZ1ttb2RlbElkXS50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGRlbGV0ZSBzZWxmLnBlbmRpbmdbbW9kZWxJZF07XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiB0aGlzLnBlbmRpbmdbbW9kZWxJZF07XG4gICAgICB9XG4gICAgfVxuICBdXG59KTtcblxuLy8gRXhwb3J0IENsYXNzTG9hZGVyLmFyZXF1aXJlIGJ5IG92ZXJ3cml0aW5nIGdsb2JhbCBjb250ZXh0IHdpdGhcbi8vIENsYXNzTG9hZGVyJ3Mgc3ViLWNvbnRleHQuXG5mb2FtLl9fY29udGV4dF9fID0gZm9hbS5jbGFzc2xvYWRlci5DbGFzc0xvYWRlci5jcmVhdGUoXG4gIHt9LFxuICBmb2FtLl9fY29udGV4dF9fXG4pLl9fc3ViQ29udGV4dF9fO1xuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTYgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuZm9hbS5MSUIoe1xuICBuYW1lOiAnZm9hbS5GdW5jdGlvbicsXG5cbiAgbWV0aG9kczogW1xuICAgIChmdW5jdGlvbigpIHtcbiAgICAgIHZhciByZXQgPSBmdW5jdGlvbiByZXNvbHZlVHlwZVN0cmluZyh0eXBlU3RyKSB7XG4gICAgICAgIC8qKiBMb29rcyB1cCBhIHR5cGUgYXMgYSBGT0FNIGNsYXNzLCBzdGRsaWIgU3RyaW5nLCBOdW1iZXIsIGV0Yy4sIG9yICdhbnknICovXG4gICAgICAgIC8vIG1pc3NpbmcgdHlwZXMgYXJlIGNoZWNrZWQgZm9yIF9hZnRlcl8gdGhlIGJvZHkgY29tbWVudCBpcyBjaGVja2VkXG4gICAgICAgIGlmICggISB0eXBlU3RyICkgcmV0dXJuIHVuZGVmaW5lZDtcblxuICAgICAgICB0eXBlU3RyID0gdHlwZVN0ci50cmltKCk7XG4gICAgICAgIGlmICggdHlwZVN0ci5zdWJzdHJpbmcodHlwZVN0ci5sZW5ndGggLSAyKSA9PT0gJ1tdJyApIHtcbiAgICAgICAgICByZXR1cm4gZm9hbS5BcnJheTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIHR5cGVTdHIgPT09ICdhbnknIHx8IHR5cGVTdHIgPT0gJ2BgJyApIHtcbiAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gb3RoZXJ3aXNlIGxvb2sgZm9yIGZvYW0uPHByaW1pdGl2ZT4gdHlwZVxuICAgICAgICBjbHMgPSBmb2FtW3R5cGVTdHJdO1xuICAgICAgICBpZiAoIGNscyApIHJldHVybiBjbHM7XG5cbiAgICAgICAgdmFyIGNscyA9IGZvYW0ubG9va3VwKHR5cGVTdHIsIHRydWUpO1xuICAgICAgICBpZiAoIGNscyApIHJldHVybiBjbHM7XG5cbiAgICAgICAgLy8gY291bGQgbm90IHJlc29sdmVcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignZm9hbS5GdW5jdGlvbi5hcmdzIGNvdWxkIG5vdCByZXNvbHZlIHR5cGUgJyArXG4gICAgICAgICAgdHlwZVN0cik7XG4gICAgICB9O1xuICAgICAgcmV0LmlzVHlwZUNoZWNrZWRfXyA9IHRydWU7XG4gICAgICByZXR1cm4gcmV0O1xuICAgIH0pKCksXG5cbiAgICBmdW5jdGlvbiBhcmdzKGZuKSB7XG4gICAgICAvKipcbiAgICAgICAqIEV4dHJhY3RzIHRoZSBhcmd1bWVudHMgYW5kIHRoZWlyIHR5cGVzIGZyb20gdGhlIGdpdmVuIGZ1bmN0aW9uLlxuICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGZ1bmN0aW9uIHRvIGV4dHJhY3QgZnJvbS4gVGhlIHRvU3RyaW5nKCkgb2YgdGhlIGZ1bmN0aW9uXG4gICAgICAgKiAgICAgbXVzdCBiZSBhY2N1cmF0ZS5cbiAgICAgICAqIEByZXR1cm4ge0FycmF5fSBBbiBhcnJheSBvZiBBcmd1bWVudCBvYmplY3RzLlxuICAgICAgICovXG4gICAgICAvLyBzdHJpcCBuZXdsaW5lcyBhbmQgZmluZCB0aGUgZnVuY3Rpb24oLi4uKSBkZWNsYXJhdGlvblxuICAgICAgdmFyIGFyZ3MgPSBmb2FtLkZ1bmN0aW9uLmFyZ3NTdHIoZm4pO1xuXG4gICAgICBpZiAoICEgYXJncyApIHJldHVybiBbXTtcblxuICAgICAgYXJncyArPSAnLCc7IC8vIGVhc2llciBtYXRjaGluZ1xuXG4gICAgICB2YXIgcmV0ID0gW107XG4gICAgICB2YXIgcmV0TWFwQnlOYW1lID0ge307XG4gICAgICAvLyBjaGVjayBlYWNoIGFyZyBmb3IgdHlwZXNcbiAgICAgIC8vIE9wdGlvbmFsIGNvbW1lbnRlZCB0eXBlKGluY2wuIGRvdHMgZm9yIHBhY2thZ2VzKSwgYXJndW1lbnQgbmFtZSxcbiAgICAgIC8vIG9wdGlvbmFsIGNvbW1lbnRlZCByZXR1cm4gdHlwZVxuICAgICAgLy8gd3MgWy8qIHdzIHBhY2thZ2UudHlwZT8gd3MgKi9dIHdzIGFyZ25hbWUgd3MgWy8qIHdzIHJldFR5cGUgd3MgKi9dXG4gICAgICB2YXIgYXJnSWR4ID0gMDtcbiAgICAgIHZhciBhcmdNYXRjaGVyID0gLyhcXHMqXFwvXFwqXFxzKihcXC5cXC5cXC4pPyhbXFx3Ll8kXFxbXFxdXSspKFxcPSk/XFxzKihcXC9cXC9cXHMqKC4qPykpP1xccypcXCpcXC8pP1xccyooXFwuXFwuXFwuKT8oW1xcd18kXSspXFxzKihcXC9cXCpcXHMqKFtcXHcuXyRcXFtcXF1gXSopKFxcPyk/XFxzKlxcKlxcLyk/XFxzKlxcLCsvZztcbiAgICAgIHZhciB0eXBlTWF0Y2g7XG5cbiAgICAgIHdoaWxlICggdHlwZU1hdGNoID0gYXJnTWF0Y2hlci5leGVjKGFyZ3MpICkge1xuICAgICAgICAvLyBpZiBjYW4ndCBtYXRjaCBmcm9tIHN0YXJ0IG9mIHN0cmluZywgZmFpbFxuICAgICAgICBpZiAoIGFyZ0lkeCA9PT0gMCAmJiB0eXBlTWF0Y2guaW5kZXggPiAwICkgYnJlYWs7XG5cbiAgICAgICAgaWYgKCByZXQucmV0dXJuVHlwZSApIHtcbiAgICAgICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoJ2ZvYW0uRnVuY3Rpb24uYXJncyByZXR1cm4gdHlwZSBcXCcnICtcbiAgICAgICAgICAgIHJldC5yZXR1cm5UeXBlLnR5cGVOYW1lICtcbiAgICAgICAgICAgICdcXCcgbXVzdCBhcHBlYXIgYWZ0ZXIgdGhlIGxhc3QgYXJndW1lbnQgb25seTogJyArXG4gICAgICAgICAgICBhcmdzLnRvU3RyaW5nKCkgKyAnXFxuJyArXG4gICAgICAgICAgICAnRm9yIGZ1bmN0aW9uOlxcbicgK1xuICAgICAgICAgICAgZm4udG9TdHJpbmcoKSArICdcXG4nXG5cbiAgICAgICAgICApO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gcmVjb3JkIHRoZSBhcmd1bWVudFxuICAgICAgICB2YXIgYXJnID0gZm9hbS5jb3JlLkFyZ3VtZW50LmNyZWF0ZSh7XG4gICAgICAgICAgbmFtZTogICAgICAgICAgdHlwZU1hdGNoWzhdLFxuICAgICAgICAgIHR5cGVOYW1lOiAgICAgIHR5cGVNYXRjaFszXSxcbiAgICAgICAgICB0eXBlOiAgICAgICAgICB0aGlzLnJlc29sdmVUeXBlU3RyaW5nKHR5cGVNYXRjaFszXSksXG4gICAgICAgICAgb3B0aW9uYWw6ICAgICAgdHJ1ZSwgLy90eXBlTWF0Y2hbNF0gPT09ICc9JywgLy8gVE9ETzogbWFuZGF0b3J5XG4gICAgICAgICAgcmVwZWF0czogICAgICAgdHlwZU1hdGNoWzJdID09PSAnLi4uJyB8fCB0eXBlTWF0Y2hbN10gPT09ICcuLi4nLFxuICAgICAgICAgIGluZGV4OiAgICAgICAgIGFyZ0lkeCsrLFxuICAgICAgICAgIGRvY3VtZW50YXRpb246IHR5cGVNYXRjaFs2XVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0LnB1c2goYXJnKTtcbiAgICAgICAgcmV0TWFwQnlOYW1lW2FyZy5uYW1lXSA9IGFyZztcblxuICAgICAgICAvLyBpZiBwcmVzZW50LCByZWNvcmQgcmV0dXJuIHR5cGUgKGlmIG5vdCB0aGUgbGFzdCBhcmcsIHdlIGZhaWwgb24gdGhlXG4gICAgICAgIC8vIG5leHQgaXRlcmF0aW9uKVxuICAgICAgICBpZiAoIHR5cGVNYXRjaFs5XSApIHtcbiAgICAgICAgICByZXQucmV0dXJuVHlwZSA9IGZvYW0uY29yZS5Bcmd1bWVudC5jcmVhdGUoe1xuICAgICAgICAgICAgbmFtZTogJ1JldHVyblZhbHVlJyxcbiAgICAgICAgICAgIG9wdGlvbmFsOiB0eXBlTWF0Y2hbMTFdLFxuICAgICAgICAgICAgdHlwZU5hbWU6IHR5cGVNYXRjaFsxMF1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoIGFyZ0lkeCA9PT0gMCApIHtcbiAgICAgICAgLy8gY2hlY2sgZm9yIGJhcmUgcmV0dXJuIHR5cGUgd2l0aCBubyBhcmdzXG4gICAgICAgIHR5cGVNYXRjaCA9IGFyZ3MubWF0Y2goL15cXHMqXFwvXFwqXFxzKihbXFx3Ll8kXFxbXFxdXSspKFxcPSk/XFxzKlxcKlxcL1xccyovKTtcbiAgICAgICAgaWYgKCB0eXBlTWF0Y2ggJiYgdHlwZU1hdGNoWzFdICkge1xuICAgICAgICAgIGZvYW0uYXNzZXJ0KCEgcmV0LnJldHVyblR5cGUsXG4gICAgICAgICAgICAnZm9hbS5GdW5jdGlvbi5hcmdzIGZvdW5kIHR3byByZXR1cm4gdHlwZXM6ICcgKyBmbi50b1N0cmluZygpKTtcbiAgICAgICAgICByZXQucmV0dXJuVHlwZSA9IGZvYW0uY29yZS5Bcmd1bWVudC5jcmVhdGUoe1xuICAgICAgICAgICAgbmFtZTogJ1JldHVyblZhbHVlJyxcbiAgICAgICAgICAgIG9wdGlvbmFsOiB0eXBlTWF0Y2hbMl0gPT09ICc9JyxcbiAgICAgICAgICAgIHR5cGVOYW1lOiB0eXBlTWF0Y2hbMV1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoXG4gICAgICAgICAgICAgICdmb2FtLkZ1bmN0aW9uLmFyZ3MgYXJndW1lbnQgcGFyc2luZyBlcnJvcjpcXG4nICtcbiAgICAgICAgICAgICAgYXJncy50b1N0cmluZygpICsgJ1xcbicgK1xuICAgICAgICAgICAgJ0ZvciBmdW5jdGlvbjpcXG4nICtcbiAgICAgICAgICAgIGZuLnRvU3RyaW5nKCkgKyAnXFxuJ1xuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gQWxzbyBwdWxsIGFyZ3Mgb3V0IG9mIHRoZSBkb2N1bWVudGF0aW9uIGNvbW1lbnQgKGlmIGluc2lkZSB0aGUgYm9keVxuICAgICAgLy8gc28gd2UgY2FuIGFjY2VzcyBpdClcbiAgICAgIHZhciBjb21tZW50ID0gZm9hbS5GdW5jdGlvbi5mdW5jdGlvbkNvbW1lbnQoZm4pO1xuICAgICAgaWYgKCBjb21tZW50ICkge1xuICAgICAgICAvLyBtYXRjaCBAYXJnIG9yIEBwYXJhbSB7b3B0X3R5cGV9IGFyZ19uYW1lXG4gICAgICAgIHZhciBjb21tZW50TWF0Y2hlciA9IC8uKihcXEBhcmd8XFxAcGFyYW18XFxAcmV0dXJuKVxccysoPzpcXHsoXFwuXFwuXFwuKT8oW1xcdy5fJFxcW1xcXV0rKShcXD0pP1xcfVxccyspPyguKj8pXFxzKyg/OihbXlxcQF0qKSk/L2c7XG4gICAgICAgIHZhciBjb21tZW50TWF0Y2g7XG4gICAgICAgIHdoaWxlICggY29tbWVudE1hdGNoID0gY29tbWVudE1hdGNoZXIuZXhlYyhjb21tZW50KSApIHtcbiAgICAgICAgICB2YXIgbmFtZSAgICAgPSBjb21tZW50TWF0Y2hbNV07XG4gICAgICAgICAgdmFyIG9wdGlvbmFsID0gY29tbWVudE1hdGNoWzRdID09PSAnPSc7XG4gICAgICAgICAgdmFyIHJlcGVhdHMgID0gY29tbWVudE1hdGNoWzJdID09PSAnLi4uJztcbiAgICAgICAgICB2YXIgdHlwZSAgICAgPSBjb21tZW50TWF0Y2hbM107XG4gICAgICAgICAgdmFyIGRvY3MgICAgID0gY29tbWVudE1hdGNoWzZdICYmIGNvbW1lbnRNYXRjaFs2XS50cmltKCk7XG5cbiAgICAgICAgICBpZiAoIGNvbW1lbnRNYXRjaFsxXSA9PT0gJ0ByZXR1cm4nICkge1xuICAgICAgICAgICAgaWYgKCByZXQucmV0dXJuVHlwZSApIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKFxuICAgICAgICAgICAgICAgICAgJ2ZvYW0uRnVuY3Rpb24uYXJncyBkdXBsaWNhdGUgcmV0dXJuIHR5cGUgJyArXG4gICAgICAgICAgICAgICAgICAnZGVmaW5pdGlvbiBpbiBibG9jayBjb21tZW50OiBcXFwiJyArXG4gICAgICAgICAgICAgICAgICB0eXBlICsgJ1xcXCIgZnJvbSBcXDpcXG4nICsgZm4udG9TdHJpbmcoKSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldC5yZXR1cm5UeXBlID0gZm9hbS5jb3JlLkFyZ3VtZW50LmNyZWF0ZSh7XG4gICAgICAgICAgICAgIG5hbWU6ICdSZXR1cm5WYWx1ZScsXG4gICAgICAgICAgICAgIG9wdGlvbmFsOiBvcHRpb25hbCxcbiAgICAgICAgICAgICAgcmVwZWF0czogcmVwZWF0cyxcbiAgICAgICAgICAgICAgdHlwZU5hbWU6IHR5cGUsXG4gICAgICAgICAgICAgIHR5cGU6IHRoaXMucmVzb2x2ZVR5cGVTdHJpbmcodHlwZSksXG4gICAgICAgICAgICAgIGRvY3VtZW50YXRpb246IGRvY3NcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBjaGVjayBleGlzdGluZyBhcmdzXG4gICAgICAgICAgICBpZiAoIHJldE1hcEJ5TmFtZVtuYW1lXSApIHtcbiAgICAgICAgICAgICAgaWYgKCByZXRNYXBCeU5hbWVbbmFtZV0udHlwZU5hbWUgKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKFxuICAgICAgICAgICAgICAgICAgICAnZm9hbS5GdW5jdGlvbi5hcmdzIGR1cGxpY2F0ZSBhcmd1bWVudCAnICtcbiAgICAgICAgICAgICAgICAgICAgJ2RlZmluaXRpb24gaW4gYmxvY2sgY29tbWVudDogXFxcIicgK1xuICAgICAgICAgICAgICAgICAgICBuYW1lICsgJ1xcXCIgZnJvbTpcXG4nICsgZm4udG9TdHJpbmcoKSk7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICByZXRNYXBCeU5hbWVbbmFtZV0udHlwZU5hbWUgICAgICA9IHR5cGU7XG4gICAgICAgICAgICAgIHJldE1hcEJ5TmFtZVtuYW1lXS5vcHRpb25hbCAgICAgID0gb3B0aW9uYWw7XG4gICAgICAgICAgICAgIHJldE1hcEJ5TmFtZVtuYW1lXS5yZXBlYXRzICAgICAgID0gcmVwZWF0cztcbiAgICAgICAgICAgICAgcmV0TWFwQnlOYW1lW25hbWVdLmRvY3VtZW50YXRpb24gPSBkb2NzO1xuICAgICAgICAgICAgICByZXRNYXBCeU5hbWVbbmFtZV0udHlwZSAgICAgICAgICA9IHRoaXMucmVzb2x2ZVR5cGVTdHJpbmcodHlwZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB2YXIgYXJnID0gZm9hbS5jb3JlLkFyZ3VtZW50LmNyZWF0ZSh7XG4gICAgICAgICAgICAgICAgbmFtZTogICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgICAgICBvcHRpb25hbDogICAgICBvcHRpb25hbCxcbiAgICAgICAgICAgICAgICByZXBlYXRzOiAgICAgICByZXBlYXRzLFxuICAgICAgICAgICAgICAgIHR5cGVOYW1lOiAgICAgIHR5cGUsXG4gICAgICAgICAgICAgICAgaW5kZXg6ICAgICAgICAgYXJnSWR4KyssXG4gICAgICAgICAgICAgICAgZG9jdW1lbnRhdGlvbjogZG9jc1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgcmV0LnB1c2goYXJnKTtcbiAgICAgICAgICAgICAgcmV0TWFwQnlOYW1lW2FyZy5uYW1lXSA9IGFyZztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gQ2hlY2sgZm9yIG1pc3NpbmcgdHlwZXNcbiAgICAgIHZhciBtaXNzaW5nVHlwZXMgPSBbXTtcbiAgICAgIGZvciAoIHZhciBpID0gMDsgaSA8IHJldC5sZW5ndGg7IGkrKyApIHtcbiAgICAgICAgaWYgKCAhIHJldFtpXS50eXBlTmFtZSApIG1pc3NpbmdUeXBlcy5wdXNoKHJldFtpXS5uYW1lKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCBtaXNzaW5nVHlwZXMubGVuZ3RoICkge1xuICAgICAgICAvLyh0aGlzLndhcm4gfHwgY29uc29sZS53YXJuKSgnTWlzc2luZyB0eXBlKHMpIGZvciAnICtcbiAgICAgICAgLy8gIG1pc3NpbmdUeXBlcy5qb2luKCcsICcpICsgJyBpbjpcXG4nICsgZm4udG9TdHJpbmcoKSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuICBdXG59KTtcblxuXG5mb2FtLkNMQVNTKHtcbiAgcGFja2FnZTogJ2ZvYW0uY29yZScsXG4gIG5hbWU6ICdBcmd1bWVudCcsXG5cbiAgZG9jdW1lbnRhdGlvbjogJ0Rlc2NyaWJlcyBvbmUgYXJndW1lbnQgb2YgYSBmdW5jdGlvbiBvciBtZXRob2QuJyxcblxuICBwcm9wZXJ0aWVzOiBbXG4gICAge1xuICAgICAgLyoqIFRoZSBuYW1lIG9mIHRoZSBhcmd1bWVudCAqL1xuICAgICAgbmFtZTogJ25hbWUnXG4gICAgfSxcbiAgICB7XG4gICAgICBuYW1lOiAnb2YnXG4gICAgfSxcbiAgICB7XG4gICAgICAvKipcbiAgICAgICAqIFRoZSBzdHJpbmcgbmFtZSBvZiB0aGUgdHlwZVxuICAgICAgICogKGVpdGhlciBhIG1vZGVsIG5hbWUgb3IgZm9hbS5TdHJpbmcsIGZvYW0uRnVuY3Rpb24sIGV0Yy4gb3IgW10pXG4gICAgICAgKi9cbiAgICAgIG5hbWU6ICd0eXBlTmFtZSdcbiAgICB9LFxuICAgIHtcbiAgICAgIC8qKlxuICAgICAgICogSWYgc2V0LCB0aGlzIGhvbGRzIHRoZSBhY3R1YWwgRk9BTSBDbGFzcyBvciBMSUIgcmVwcmVzZW50ZWRcbiAgICAgICAqIGJ5IHR5cGVOYW1lLlxuICAgICAgICovXG4gICAgICBuYW1lOiAndHlwZScsXG4gICAgICBmYWN0b3J5OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIGZvYW0uRnVuY3Rpb24ucmVzb2x2ZVR5cGVTdHJpbmcodGhpcy50eXBlTmFtZSkgfHwgbnVsbDtcbiAgICAgIH1cbiAgICB9LFxuICAgIHtcbiAgICAgIC8qKiBJZiB0cnVlLCBpbmRpY2F0ZXMgdGhhdCB0aGlzIGFyZ3VtZW50IGlzIG9wdGlvbmFsLiAqL1xuICAgICAgbmFtZTogJ29wdGlvbmFsJywgdmFsdWU6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICAvKiogSWYgdHJ1ZSwgaW5kaWNhdGVzIGEgdmFyaWFibGUgbnVtYmVyIG9mIGFyZ3VtZW50cy4gKi9cbiAgICAgIG5hbWU6ICdyZXBlYXRzJywgdmFsdWU6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICAvKiogVGhlIGluZGV4IG9mIHRoZSBhcmd1bWVudCAodGhlIGZpcnN0IGFyZ3VtZW50IGlzIGF0IGluZGV4IDApLiAqL1xuICAgICAgbmFtZTogJ2luZGV4JywgdmFsdWU6IC0xXG4gICAgfSxcbiAgICB7XG4gICAgICAvKiogVGhlIGRvY3VtZW50YXRpb24gYXNzb2NpYXRlZCB3aXRoIHRoZSBhcmd1bWVudCAoZGVub3RlZCBieSBhIC8vICkgKi9cbiAgICAgIG5hbWU6ICdkb2N1bWVudGF0aW9uJywgdmFsdWU6ICcnXG4gICAgfVxuICBdLFxuXG4gIG1ldGhvZHM6IFtcbiAgICAoZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgdmFsaWRhdGUgPSBmdW5jdGlvbiB2YWxpZGF0ZShhcmcpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAgVmFsaWRhdGVzIHRoZSBnaXZlbiBhcmd1bWVudCBhZ2FpbnN0IHRoaXMgdHlwZSBpbmZvcm1hdGlvbi5cbiAgICAgICAgICBJZiBhbnkgdHlwZSBjaGVja3MgYXJlIGZhaWxlZCwgYSBUeXBlRXJyb3IgaXMgdGhyb3duLlxuICAgICAgICAgKi9cbiAgICAgICAgaWYgKCAhIHRoaXMudHlwZSApIHtcbiAgICAgICAgICAvLyBubyB0eXBlLCBubyBjaGVjayB0byBwZXJmb3JtXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGkgPSAoIHRoaXMuaW5kZXggPj0gMCApID8gJyAnICsgdGhpcy5pbmRleCArICcsICcgOiAnLCAnO1xuXG4gICAgICAgIC8vIG9wdGlvbmFsIGNoZWNrXG4gICAgICAgIGlmICggZm9hbS5OdWxsLmlzSW5zdGFuY2UoYXJnKSB8fCBmb2FtLlVuZGVmaW5lZC5pc0luc3RhbmNlKGFyZykgKSB7XG4gICAgICAgICAgaWYgKCAhIHRoaXMub3B0aW9uYWwgKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICAgICAgICAnQXJndW1lbnQgJyArIGkgKyB0aGlzLm5hbWUgKyAnIHsnICsgdGhpcy50eXBlTmFtZSArICd9JyArXG4gICAgICAgICAgICAgICAgJywgaXMgbm90IG9wdGlvbmFsLCBidXQgd2FzIHVuZGVmaW5lZCBpbiBhIGZ1bmN0aW9uIGNhbGwnKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm47IC8vIHZhbHVlIGlzIHVuZGVmaW5lZCwgYnV0IG9rIHdpdGggdGhhdFxuICAgICAgICB9XG5cbiAgICAgICAgLy8gaGF2ZSBhIG1vZGVsbGVkIHR5cGVcbiAgICAgICAgaWYgKCAhIHRoaXMudHlwZS5pc0luc3RhbmNlKGFyZykgKSB7XG4gICAgICAgICAgdmFyIGdvdFR5cGUgPSAoYXJnLmNsc18pID8gYXJnLmNsc18ubmFtZSA6IHR5cGVvZiBhcmc7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgICAgICAgJ0FyZ3VtZW50ICcgKyBpICsgdGhpcy5uYW1lICtcbiAgICAgICAgICAgICAgJywgZXhwZWN0ZWQgdHlwZSAnICsgdGhpcy50eXBlTmFtZSArICcgYnV0IHBhc3NlZCAnICsgZ290VHlwZSk7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIHZhbGlkYXRlLmlzVHlwZUNoZWNrZWRfXyA9IHRydWU7IC8vIGF2b2lkIHR5cGUgY2hlY2tpbmcgdGhpcyBtZXRob2RcbiAgICAgIHJldHVybiB2YWxpZGF0ZTtcbiAgICB9KSgpXG4gIF1cbn0pO1xuXG5mb2FtLkNMQVNTKHtcbiAgcmVmaW5lczogJ2ZvYW0uY29yZS5NZXRob2QnLFxuICBwcm9wZXJ0aWVzOiBbXG4gICAge1xuICAgICAgY2xhc3M6ICdGT2JqZWN0QXJyYXknLFxuICAgICAgb2Y6ICdmb2FtLmNvcmUuQXJndW1lbnQnLFxuICAgICAgbmFtZTogJ2FyZ3MnLFxuICAgICAgYWRhcHRBcnJheUVsZW1lbnQ6IGZ1bmN0aW9uKGUsIG9iaikge1xuICAgICAgICB2YXIgY3R4ID0gb2JqLl9fc3ViQ29udGV4dF9fIHx8IGZvYW07XG4gICAgICAgIHZhciBvZiA9IGUuY2xhc3MgfHwgdGhpcy5vZjtcbiAgICAgICAgdmFyIGNscyA9IGN0eC5sb29rdXAob2YpO1xuXG4gICAgICAgIHJldHVybiBjbHMuaXNJbnN0YW5jZShlKSA/IGUgOlxuICAgICAgICAgIGZvYW0uU3RyaW5nLmlzSW5zdGFuY2UoZSkgPyBjbHMuY3JlYXRlKHsgbmFtZTogZSB9KSA6XG4gICAgICAgICAgY2xzLmNyZWF0ZShlLCBvYmopO1xuICAgICAgfVxuICAgIH1cbiAgXVxufSk7XG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG4vKlxuICBBIC0+IGZvbyhDKVxuICAgICAgIGZvbyhEKVxuICBCIC0+IGZvbyhDKVxuXG4gIEhvdyBkb2VzIEIuZm9vKEQpIHdvcms/XG4gIENvcHkgbWV0aG9kcz8gVGhlbiB3aGF0IGlmIEEgZ2V0cyByZWZpbmVkP1xuICBMb29rdXAgQi5mb28sIG90aGVyd2lzZSBsb29rdXAgQS5mb28oKT9cbiAgICBUaGVuIHdoYXQgYWJvdXQgRk9iamVjdCB2cy4gcGFydGljdWxhciBjbGFzcyBsb29rdXA/XG4gIFdoYXQgYWJvdXQgdHJlYXRpbmcgJ3RoaXMnIGFzIGZpcnN0IGFyZ3VtZW50P1xuKi9cblxuZm9hbS5DTEFTUyh7XG4gIHBhY2thZ2U6ICdmb2FtLmNvcmUnLFxuICBuYW1lOiAnTXVsdGlNZXRob2QnLFxuICBleHRlbmRzOiAnZm9hbS5jb3JlLkFic3RyYWN0TWV0aG9kJyxcblxuICBwcm9wZXJ0aWVzOiBbXG4gICAge1xuICAgICAgbmFtZTogJ25hbWUnLFxuICAgICAgZmFjdG9yeTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1ldGhvZE5hbWUgK1xuICAgICAgICAgIHRoaXMuYXJncy5tYXAoZnVuY3Rpb24oYSkgeyByZXR1cm4gYS50eXBlTmFtZTsgfSkuam9pbignOicpO1xuICAgICAgfVxuICAgIH0sXG4gICAge1xuICAgICAgbmFtZTogJ21ldGhvZE5hbWUnLFxuICAgICAgcmVxdWlyZWQ6IHRydWVcbiAgICB9XG4gIF0sXG5cbiAgbWV0aG9kczogW1xuICAgIGZ1bmN0aW9uIGluc3RhbGxJblByb3RvKHByb3RvKSB7XG4gICAgICB2YXIga2V5ID0gdGhpcy5jbHNfLmlkLnJlcGxhY2UoL1xcLi9nLCc6JykgKyAnOicgKyB0aGlzLm1ldGhvZE5hbWU7XG4gICAgICBjb25zb2xlLmxvZygnSW5zdGFsbGluZzogJyArIGtleSk7XG4gICAgICB2YXIgZGlzcGF0aCA9IHRoaXMuY3JlYXRlRGlzcGF0Y2gocHJvdG8sIGtleSwgMCwgdGhpcy5hcmdzKTtcbiAgICAgIGRpc3BsYXRjaC5jb2RlID0gdGhpcy5jb2RlO1xuICAgIH0sXG5cbiAgICBmdW5jdGlvbiBjcmVhdGVEaXNwYXRjaChwcm90bywgcHJlZml4LCBwb3MsIGFyZ3MpIHtcbiAgICAgIHZhciBkID0gcHJvdG9bcHJlZml4XTtcblxuICAgICAgaWYgKCAhIGQgKSB7XG4gICAgICAgIHZhciBwcmVmaXgyID0gcHJlZml4ICsgJzonICsgYXJnc1twb3NdICsgdHlwZU5hbWU7XG4gICAgICAgIHByb3RvW3ByZWZpeF0gPSBmdW5jdGlvbiBkaXNwYXRjaCgpIHtcbiAgICAgICAgICBpZiAoIGFyZ3VtZW50cy5sZW5ndGggPT09IHBvcyApIHtcbiAgICAgICAgICAgIHJldHVybiBhcmd1bWVudHMuY2FsbGVlLmNvZGUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIHQgPSBmb2FtLnR5cGVPZihhcmd1bWVudHNbcG9zXSk7XG4gICAgICAgICAgdmFyIGYgPSB0W3ByZWZpeDJdO1xuICAgICAgICAgIHJldHVybiBmLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIGlmICggcG9zID09PSBhcmdzLmxlbmd0aCApIHJldHVybiBwcm90b1twcmVmaXhdO1xuICAgIH0sXG5cbiAgICBmdW5jdGlvbiBleHBvcnRBcyhvYmopIHtcbiAgICAgIHZhciBtID0gb2JqW3RoaXMubmFtZV07XG4gICAgICAvKiogQmluZCB0aGUgbWV0aG9kIHRvICd0aGlzJyB3aGVuIGV4cG9ydGVkIHNvIHRoYXQgaXQgc3RpbGwgd29ya3MuICoqL1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uIGV4cG9ydGVkTWV0aG9kKCkgeyByZXR1cm4gbS5hcHBseShvYmosIGFyZ3VtZW50cyk7IH07XG4gICAgfVxuICBdXG59KTtcbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmZvYW0uQ0xBU1Moe1xuICBwYWNrYWdlOiAnZm9hbS5wYXR0ZXJuJyxcbiAgbmFtZTogJ1NpbmdsZXRvbicsXG5cbiAgZG9jdW1lbnRhdGlvbjogYFxuICBBIFNpbmdsZXRvbiBBeGlvbSwgd2hlbiBhZGRlZCB0byBhIENsYXNzLCBtYWtlcyBpdCBpbXBsZW1lbnRcbiAgdGhlIFNpbmdsZXRvbiBQYXR0ZXJuLCBtZWFuaW5nIHRoYXQgYWxsIGNhbGxzIHRvIGNyZWF0ZSgpXG4gIHdpbGwgcmV0dXJuIHRoZSBzYW1lIChzaW5nbGUpIGluc3RhbmNlLlxuICBgLFxuXG4gIHByb3BlcnRpZXM6IFsgWyAnbmFtZScsICdjcmVhdGUnIF0gXSxcblxuICBtZXRob2RzOiBbXG4gICAgZnVuY3Rpb24gaW5zdGFsbEluQ2xhc3MoY2xzKSB7XG4gICAgICAvKiogQHBhcmFtIHthbnl9IGNscyAqL1xuICAgICAgdmFyIG9sZENyZWF0ZSA9IGNscy5jcmVhdGU7XG4gICAgICB2YXIgbmV3Q3JlYXRlID0gY2xzLmNyZWF0ZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAvLyBUaGlzIGhhcHBlbnMgd2hlbiBhIG5ld2VyIEF4aW9tIHJlcGxhY2VzIGNyZWF0ZSgpLlxuICAgICAgICAvLyBJZiB0aGlzIGhhcHBlbnMsIGRvbid0IGFwcGx5IFNpbmdsZXRvbiBiZWhhdmlvdXIuXG4gICAgICAgIGlmICggdGhpcy5jcmVhdGUgIT09IG5ld0NyZWF0ZSApXG4gICAgICAgICAgcmV0dXJuIG9sZENyZWF0ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXG4gICAgICAgIHJldHVybiB0aGlzLnByaXZhdGVfLmluc3RhbmNlXyB8fFxuICAgICAgICAgICAgKCB0aGlzLnByaXZhdGVfLmluc3RhbmNlXyA9IG9sZENyZWF0ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpICk7XG4gICAgICB9O1xuICAgIH0sXG5cbiAgICBmdW5jdGlvbiBpbnN0YWxsSW5Qcm90byhwKSB7XG4gICAgICAvLyBOb3QgbmVlZGVkLCBidXQgaW1wcm92ZXMgcGVyZm9ybWFuY2UuXG4gICAgICBwLmNsb25lICA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpczsgfTtcbiAgICAgIHAuZXF1YWxzID0gZnVuY3Rpb24obykgeyAvKiogQHBhcmFtIHthbnk9fSBvICovIHJldHVybiB0aGlzID09PSBvOyB9O1xuICAgIH1cbiAgXVxufSk7XG5cbi8vIFdlIG9ubHkgbmVlZCBvbmUgU2luZ2xldG9uLCBzbyBtYWtlIGl0IGEgU2luZ2xldG9uLlxuZm9hbS5DTEFTUyh7XG4gIHJlZmluZXM6ICdmb2FtLnBhdHRlcm4uU2luZ2xldG9uJyxcbiAgYXhpb21zOiBbIGZvYW0ucGF0dGVybi5TaW5nbGV0b24uY3JlYXRlKCkgXVxufSk7XG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG4vKipcbiAgQSBNdWx0aXRvbiBBeGlvbSwgd2hlbiBhZGRlZCB0byBhIENsYXNzLCBtYWtlcyBpdCBpbXBsZW1lbnRcbiAgdGhlIE11bHRpdG9uIFBhdHRlcm4sIG1lYW5pbmcgdGhhdCBjYWxscyB0byBjcmVhdGUoKSB3aXRoXG4gIHRoZSBzYW1lIHZhbHVlIGZvciB0aGUgc3BlY2lmaWVkICdwcm9wZXJ0eScsIHdpbGwgcmV0dXJuIHRoZVxuICBzYW1lIGluc3RhbmNlLlxuXG4gIEV4LjpcbiAgZm9hbS5DTEFTUyh7XG4gICAgbmFtZTogJ0NvbG9yJyxcbiAgICBheGlvbXM6IFsgZm9hbS5wYXR0ZXJuLk11bHRpdG9uLmNyZWF0ZSh7cHJvcGVydHk6ICdjb2xvcid9KSBdLFxuICAgIHByb3BlcnRpZXM6IFsgJ2NvbG9yJyBdLFxuICAgIG1ldGhvZHM6IFsgZnVuY3Rpb24gaW5pdCgpIHsgbG9nKCdDcmVhdGluZyBDb2xvcjonLCB0aGlzLmNvbG9yKTsgfSBdXG4gIH0pO1xuXG4gIHZhciByZWQxID0gQ29sb3IuY3JlYXRlKHtjb2xvcjogJ3JlZCd9KTtcbiAgdmFyIHJlZDIgPSBDb2xvci5jcmVhdGUoe2NvbG9yOiAncmVkJ30pO1xuICB2YXIgYmx1ZSA9IENvbG9yLmNyZWF0ZSh7Y29sb3I6ICdibHVlJ30pO1xuXG4gIGxvZyhyZWQxID09PSByZWQyKTsgLy8gdHJ1ZSwgc2FtZSBvYmplY3RcbiAgbG9nKHJlZDEgPT09IGJsdWUpOyAvLyBmYWxzZSwgZGlmZmVyZW50IG9iamVjdHNcbiovXG5mb2FtLkNMQVNTKHtcbiAgcGFja2FnZTogJ2ZvYW0ucGF0dGVybicsXG4gIG5hbWU6ICdNdWx0aXRvbicsXG5cbiAgcHJvcGVydGllczogW1xuICAgIFsgJ25hbWUnLCAnY3JlYXRlJyBdLFxuICAgIHtcbiAgICAgIC8vIEZVVFVSRTogc3dpdGNoIHRvICdwcm9wZXJ0aWVzJyB0byBzdXBwb3J0IG11bHRpcGxlIGtleXMgd2hlbi9pZiBuZWVkZWQuXG4gICAgICBjbGFzczogJ1N0cmluZycsXG4gICAgICBuYW1lOiAncHJvcGVydHknXG4gICAgfVxuICBdLFxuXG4gIG1ldGhvZHM6IFtcbiAgICBmdW5jdGlvbiBpbnN0YWxsSW5DbGFzcyhjbHMpIHtcbiAgICAgIHZhciBwcm9wZXJ0eSAgPSB0aGlzLnByb3BlcnR5O1xuICAgICAgdmFyIG9sZENyZWF0ZSA9IGNscy5jcmVhdGU7XG5cbiAgICAgIGNscy5jcmVhdGUgPSBmdW5jdGlvbihhcmdzKSB7XG4gICAgICAgIHZhciBpbnN0YW5jZXMgPSB0aGlzLnByaXZhdGVfLmluc3RhbmNlcyB8fFxuICAgICAgICAgICAgKCB0aGlzLnByaXZhdGVfLmluc3RhbmNlcyA9IHt9ICk7XG4gICAgICAgIHZhciBrZXkgPSBhcmdzW3Byb3BlcnR5XTtcblxuICAgICAgICAvLyBJZiBrZXkgaXNuJ3QgcHJvdmlkZWQsIHRyeSB1c2luZyBwcm9wZXJ0eS52YWx1ZSBpbnN0ZWFkXG4gICAgICAgIGlmICgga2V5ID09PSB1bmRlZmluZWQgKSB7XG4gICAgICAgICAga2V5ID0gY2xzLmdldEF4aW9tQnlOYW1lKHByb3BlcnR5KS52YWx1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBpbnN0YW5jZXNba2V5XSB8fFxuICAgICAgICAgICAgKCBpbnN0YW5jZXNba2V5XSA9IG9sZENyZWF0ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpICk7XG4gICAgICB9O1xuICAgIH0sXG5cbiAgICBmdW5jdGlvbiBpbnN0YWxsSW5Qcm90byhwKSB7XG4gICAgICAvLyBOb3QgbmVlZGVkLCBidXQgaW1wcm92ZXMgcGVyZm9ybWFuY2UuXG4gICAgICBwLmNsb25lICA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpczsgfTtcbiAgICAgIHAuZXF1YWxzID0gZnVuY3Rpb24obykgeyByZXR1cm4gdGhpcyA9PT0gbzsgfTtcbiAgICB9XG4gIF1cbn0pO1xuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuLyoqXG4gKiBGb3IgdGhvc2UgZmFtaWxpYXIgd2l0aCBKYXZhLCBGT0FNIEVudW1zIGFyZSB2ZXJ5IHNpbWlsYXIgdG8gSmF2YSBlbnVtcyBpblxuICogZGVzaWduLlxuICpcbiAqIEFuIEVudW0gaXMgZXNzZW50aWFsbHkgYSBjbGFzcyB3aXRoIGEgZml4ZWQgbnVtYmVyIG9mIG5hbWVkIGluc3RhbmNlcy5cbiAqIFRoZSBpbnN0YW5jZXMgYXJlIGZyZXF1ZW50bHkgcmVmZXJyZWQgdG8gYXMgRW51bSBWYWx1ZXMsIG9yIHRoZSAndmFsdWVzJ1xuICogb2YgYW4gRW51bS5cbiAqXG4gKiBFbnVtcyBoYXZlIG1vc3Qgb2YgdGhlIGZlYXR1cmVzIGF2YWlsYWJsZSB0byBGT0FNIGNsYXNzZXMsIGluY2x1ZGluZ1xuICogcHJvcGVydGllcywgbWV0aG9kcywgY29uc3RhbnRzLCB0ZW1wbGF0ZXMsIGFuZCBsaXN0ZW5lcnMuXG4gKlxuICogRW51bXMgZXh0ZW5kIGZyb20gRk9iamVjdCwgc28gdGhleSBpbmhlcml0IEZPYmplY3QgZmVhdHVyZXMgc3VjaCBhc1xuICogcHViL3N1YiBldmVudHMsIGRpZmZpbmcsIGhhc2hDb2RlLCBldGMuXG4gKlxuICogRW51bXMgYWxzbyBoYXZlIGEgZmV3IGJ1aWx0LWluIHByb3BlcnRpZXMgYnkgZGVmYXVsdC4gRXZlcnkgRW51bSBoYXMgYW5cbiAqICdvcmRpbmFsJyBwcm9wZXJ0eSwgd2hpY2ggaXMgYSBpbnRlZ2VyIHVuaXF1ZSB0byBhbGwgdGhlIEVudW0gVmFsdWVzIG9mIGFcbiAqIHBhcnRpY3VsYXIgRW51bS4gRWFjaCBlbnVtIGFsc28gaGFzIGEgJ25hbWUnIHByb3BlcnR5LCB3aGljaCBpcyB0aGUgbmFtZVxuICogZ2l2ZW4gdG8gZWFjaCBFbnVtIFZhbHVlLlxuICpcbiAqIEV4YW1wbGUgdXNhZ2U6XG4gKiA8cHJlPlxuICogLy8gVG8gZGVmaW5lIGFuIGVudW0gd2UgdXNlIHRoZSBmb2FtLkVOVU0oKSBmdW5jdGlvbi5cbiAqIGZvYW0uRU5VTSh7XG4gKiAgIG5hbWU6ICdJc3N1ZVN0YXR1cycsXG4gKlxuICogICAvLyBFbnVtcyBzaGFyZSBtYW55IGZlYXR1cmVzIHdpdGggcmVndWxhciBjbGFzc2VzLCB0aGUgcHJvcGVydGllc1xuICogICAvLyBhbmQgbWV0aG9kcyB3ZSB3YW50IG91ciBlbnVtcyB0byBoYXZlIGFyZSBkZWZpbmVkIGFzIGZvbGxvd3MuXG4gKiAgIHByb3BlcnRpZXM6IFtcbiAqICAgICB7XG4gKiAgICAgICBjbGFzczogJ0Jvb2xlYW4nLFxuICogICAgICAgbmFtZTogJ2NvbnNpZGVyZWRPcGVuJyxcbiAqICAgICAgIHZhbHVlOiB0cnVlXG4gKiAgICAgfVxuICogICBdLFxuICpcbiAqICAgbWV0aG9kczogW1xuICogICAgIGZ1bmN0aW9uIGZvbygpIHtcbiAqICAgICAgIHJldHVybiB0aGlzLmxhYmVsICsgKCB0aGlzLmNvbnNpZGVyZWRPcGVuID8gJyBpcycgOiAnIGlzIG5vdCcgKSArXG4gKiAgICAgICAgICAgJyBjb25zaWRlcmVkIG9wZW4uJztcbiAqICAgICB9XG4gKiAgIF0sXG4gKlxuICogICAvLyBVc2UgdGhlIHZhbHVlczoga2V5IHRvIGRlZmluZSB0aGUgYWN0dWFsIEVudW0gVmFsdWVzIHRoYXQgd2VcbiAqICAgLy8gd2FudCB0byBleGlzdC5cbiAqICAgdmFsdWVzOiBbXG4gKiAgICAge1xuICogICAgICAgbmFtZTogJ09QRU4nXG4gKiAgICAgfSxcbiAqICAgICB7XG4gKiAgICAgICAvLyBUaGUgb3JkaW5hbCBjYW4gYmUgc3BlY2lmaWVkIGV4cGxpY2l0bHkuXG4gKiAgICAgICBuYW1lOiAnQ0xPU0VEJyxcbiAqICAgICAgIG9yZGluYWw6IDEwMFxuICogICAgIH0sXG4gKiAgICAge1xuICogICAgICAgLy8gSWYgdGhlIG9yZGluYWwgaXNuJ3QgZ2l2ZW4gZXhwbGljaXRseSBpdCBpcyBhdXRvIGFzc2lnbmVkIGFzXG4gKiAgICAgICAvLyB0aGUgcHJldmlvdXMgb3JkaW5hbCArIDFcbiAqICAgICAgIG5hbWU6ICdBU1NJR05FRCdcbiAqICAgICB9LFxuICogICAgIHtcbiAqICAgICAgIC8vIFlvdSBjYW4gc3BlY2lmeSB0aGUgbGFiZWwsIHdoaWNoIHdpbGwgYmUgdXNlZCB3aGVuIHJlbmRlcmluZyBpbiBhXG4gKiAgICAgICAvLyBjb21ibyBib3ggb3Igc2ltaWxhclxuICogICAgICAgbmFtZTogJ1VOVkVSSUZJRUQnLFxuICogICAgICAgbGFiZWw6ICdVbnZlcmlmaWVkJ1xuICogICAgIH0sXG4gKiAgICAge1xuICogICAgICAgLy8gVmFsdWVzIGZvciBhZGRpdGlvbmFsIHByb3BlcnRpZXMgdG8geW91ciBlbnVtIGFyZSBhbHNvIGRlZmluZWRcbiAqICAgICAgIC8vIGlubGluZS5cbiAqICAgICAgIG5hbWU6ICdGSVhFRCcsXG4gKiAgICAgICBsYWJlbDogJ0ZpeGVkJyxcbiAqICAgICAgIGNvbnNpZGVyZWRPcGVuOiBmYWxzZVxuICogICAgIH1cbiAqICAgXVxuICogfSk7XG4gKlxuICogY29uc29sZS5sb2coSXNzdWVTdGF0dXMuT1BFTi5uYW1lKTsgLy8gb3V0cHV0cyBcIk9QRU5cIlxuICogY29uc29sZS5sb2coSXNzdWVTdGF0dXMuQVNTSUdORUQuY29uc2lkZXJlZE9wZW4pOyAvLyBvdXRwdXRzIFwidHJ1ZVwiXG4gKlxuICogLy8gRW51bSB2YWx1ZSBvcmRpbmFscyBjYW4gYmUgc3BlY2lmaWVkLlxuICogY29uc29sZS5sb2coSXNzdWVTdGF0dXMuQ0xPU0VELm9yZGluYWwpOyAvLyBvdXRwdXRzIDEwMFxuICogLy8gdmFsdWVzIHdpdGhvdXQgc3BlY2lmaWVkIG9yZGluYWxzIGdldCBhdXRvIGFzc2lnbmVkLlxuICogY29uc29sZS5sb2coSXNzdWVTdGF0dXMuQVNTSUdORUQub3JkaW5hbCk7IC8vIG91dHB1dHMgMTAxXG4gKlxuICogLy8gTWV0aG9kcyBjYW4gYmUgY2FsbGVkIG9uIHRoZSBlbnVtIHZhbHVlcy5cbiAqIC8vIG91dHB1dHMgXCJGaXhlZCBpcyBub3QgY29uc2lkZXJlZCBvcGVuLlwiXG4gKiBjb25zb2xlLmxvZyhJc3N1ZVN0YXR1cy5GSVhFRC5mb28oKSk7XG4gKlxuICogLy8gVG8gc3RvcmUgZW51bXMgb24gYSBjbGFzcywgaXQgaXMgcmVjb21tZW5kZWQgdG8gdXNlIHRoZSBFbnVtIHByb3BlcnR5XG4gKiAvLyB0eXBlLlxuICogZm9hbS5DTEFTUyh7XG4gKiAgIG5hbWU6ICdJc3N1ZScsXG4gKiAgIHByb3BlcnRpZXM6IFtcbiAqICAgICB7XG4gKiAgICAgICBjbGFzczogJ0VudW0nLFxuICogICAgICAgb2Y6ICdJc3N1ZVN0YXR1cycsXG4gKiAgICAgICBuYW1lOiAnc3RhdHVzJ1xuICogICAgIH1cbiAqICAgXVxuICogfSk7XG4gKlxuICogdmFyIGlzc3VlID0gSXNzdWUuY3JlYXRlKHsgc3RhdHVzOiBJc3N1ZVN0YXR1cy5VTlZFUklGSUVEIH0pO1xuICogY29uc29sZS5sb2coaXNzdWUuc3RhdHVzLmxhYmVsKTsgLy8gb3V0cHV0cyBcIlVudmVyaWZpZWRcIlxuICpcbiAqIC8vIEVudW0gcHJvcGVydGllcyBnaXZlIHlvdSBzb21lIGNvbnZlbmllbnQgYWRhcHRpbmcuXG4gKiAvLyBZb3UgY2FuIHNldCB0aGUgcHJvcGVydHkgdG8gdGhlIG9yZGluYWwgb3IgdGhlXG4gKiAvLyBuYW1lIG9mIGFuIGVudW0sIGFuZCBpdCB3aWxsIHNldCB0aGUgcHJvcGVydHlcbiAqIC8vIHRvIHRoZSBjb3JyZWN0IEVudW0gdmFsdWUuXG4gKlxuICogaXNzdWUuc3RhdHVzID0gMTAwO1xuICpcbiAqIGlzc3VlLnN0YXR1cyA9PT0gSXNzdWVTdGF0dXMuQ0xPU0VEOyAvLyBpcyB0cnVlXG4gKlxuICogLy8gRW51bSBwcm9wZXJ0aWVzIGFsc28gYWxsb3cgeW91IHRvIGFzc2lnbiB0aGVtIHZpYSB0aGUgbmFtZVxuICogLy8gb2YgdGhlIGVudW0uXG4gKlxuICogaXNzdWUuc3RhdHVzID0gXCJBU1NJR05FRFwiXG4gKlxuICogaXNzdWUuc3RhdHVzID09PSBJc3N1ZVN0YXR1cy5BU1NJR05FRDsgLy8gaXMgdHJ1ZVxuICpcbiAqIFRoZSBleHRlbnQgb2YgYWxsIEVudW0gdmFsdWVzIGNhbiBiZSBhY2Nlc3NlZCBmcm9tIGVpdGhlciB0aGUgY29sbGVjdGlvbiBvciBmcm9tIGFueVxuICogaW5kaXZpZHVhbCBFbnVtIHZhbHVlOlxuICogY29uc29sZS5sb2coSXNzdWVTdGF0dXMuVkFMVUVTLCBJc3N1ZVN0YXR1cy5DTE9TRUQuVkFMVUVTKTtcbiAqXG4gKiBWYWx1ZXMgY2FuIGJlIHNwZWNpZmllZCBhcyBqdXN0IFN0cmluZ3MgaWYgeW91IGRvbid0IHdhbnQgdG8gZXhwbGljaXRseSBzZXQgdGhlIGxhYmVsXG4gKiBvciBvcmRpbmFsLiBFeC46XG4gKlxuICogZm9hbS5FTlVNKHtcbiAqICBuYW1lOiAnRGF5c09mV2VlaycsXG4gKiAgdmFsdWVzOiBbXG4gKiAgICAnU1VOREFZJyxcbiAqICAgICdNT05EQVknLFxuICogICAgJ1RVRVNEQVknLFxuICogICAgJ1dFRE5FU0RBWScsXG4gKiAgICAnVEhVUlNEQVknLFxuICogICAgJ0ZSSURBWScsXG4gKiAgICAnU0FUVVJEQVknXG4gKiAgXVxuICogfSk7XG4gKlxuICogPC9wcmU+XG4gKi9cbi8vIFRPRE86IE1ha2UgZXh0ZW5kIE1vZGVsIHNvIGNhbiBvdmVycmlkZSBtZXRob2RzIChvciBkbyBzb21lIG90aGVyIHdheSkuXG5mb2FtLkNMQVNTKHtcbiAgcGFja2FnZTogJ2ZvYW0uY29yZS5pbnRlcm5hbCcsXG4gIG5hbWU6ICdFbnVtVmFsdWVBeGlvbScsXG5cbiAgZG9jdW1lbnRhdGlvbjogJ1RoZSBkZWZpbml0aW9uIG9mIGEgc2luZ2xlIEVudW0gdmFsdWUuJyxcblxuICBwcm9wZXJ0aWVzOiBbXG4gICAge1xuICAgICAgbmFtZTogJ29yZGluYWwnLFxuICAgICAgZ2V0dGVyOiBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMuZGVmaW5pdGlvbi5vcmRpbmFsOyB9LFxuICAgICAgc2V0dGVyOiBmdW5jdGlvbihvKSB7IHRoaXMuZGVmaW5pdGlvbi5vcmRpbmFsID0gbzsgfVxuICAgIH0sXG4gICAge1xuICAgICAgbmFtZTogJ25hbWUnLFxuICAgICAgZ2V0dGVyOiBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMuZGVmaW5pdGlvbi5uYW1lOyB9XG4gICAgfSxcbiAgICAnZGVmaW5pdGlvbidcbiAgXSxcblxuICBtZXRob2RzOiBbXG4gICAgZnVuY3Rpb24gaW5zdGFsbEluQ2xhc3MoY2xzKSB7XG4gICAgICB2YXIgZSA9IGNscy5jcmVhdGUodGhpcy5kZWZpbml0aW9uKTtcbiAgICAgIGNscy5pbnN0YWxsQ29uc3RhbnQodGhpcy5uYW1lLCBlKTtcbiAgICAgIGNscy5WQUxVRVMucHVzaChlKTtcbiAgICB9XG4gIF1cbn0pO1xuXG5cbmZvYW0uQ0xBU1Moe1xuICBwYWNrYWdlOiAnZm9hbS5jb3JlJyxcbiAgbmFtZTogJ0VudW1Nb2RlbCcsXG4gIGV4dGVuZHM6ICdNb2RlbCcsXG5cbiAgZG9jdW1lbnRhdGlvbjogJ01vZGVsIGZvciBkZWZpbmluZyBFbnVtKGVyYXRpb25zKS4nLFxuXG4gIHByb3BlcnRpZXM6IFtcbiAgICBbICdleHRlbmRzJywgJ2ZvYW0uY29yZS5BYnN0cmFjdEVudW0nIF0sXG4gICAge1xuICAgICAgY2xhc3M6ICdBeGlvbUFycmF5JyxcbiAgICAgIG9mOiAnZm9hbS5jb3JlLmludGVybmFsLkVudW1WYWx1ZUF4aW9tJyxcbiAgICAgIG5hbWU6ICd2YWx1ZXMnLFxuICAgICAgYWRhcHQ6IGZ1bmN0aW9uKF8sIHYpIHtcbiAgICAgICAgdmFyIHVzZWQgPSB7fTsgLy8gbWFwIG9mIG9yZGluYWxzIHVzZWQgdG8gY2hlY2sgZm9yIGR1cGxpY2F0ZXNcblxuICAgICAgICB2YXIgbmV4dCA9IDA7XG4gICAgICAgIGZvciAoIHZhciBpID0gMCA7IGkgPCB2Lmxlbmd0aCA7IGkrKyApIHtcbiAgICAgICAgICB2YXIgZGVmID0gdltpXTtcblxuICAgICAgICAgIGlmICggZm9hbS5TdHJpbmcuaXNJbnN0YW5jZShkZWYpICkge1xuICAgICAgICAgICAgZGVmID0geyBsYWJlbDogZGVmLCBuYW1lOiBmb2FtLlN0cmluZy5jb25zdGFudGl6ZShkZWYpIH07XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKCBkZWYub3JkaW5hbCB8fCBkZWYub3JkaW5hbCA9PT0gMCApIHtcbiAgICAgICAgICAgIG5leHQgPSBkZWYub3JkaW5hbCArIDE7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGRlZi5vcmRpbmFsID0gbmV4dCsrO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICggISBmb2FtLmNvcmUuaW50ZXJuYWwuRW51bVZhbHVlQXhpb20uaXNJbnN0YW5jZShkZWYpICkge1xuICAgICAgICAgICAgdltpXSA9IGRlZiA9IGZvYW0uY29yZS5pbnRlcm5hbC5FbnVtVmFsdWVBeGlvbS5jcmVhdGUoe2RlZmluaXRpb246IGRlZn0pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICggdXNlZFtkZWYub3JkaW5hbF0gKSB7XG4gICAgICAgICAgICB0aHJvdyB0aGlzLmlkICtcbiAgICAgICAgICAgICAgICAnIEVudW0gZXJyb3I6IGR1cGxpY2F0ZSBvcmRpbmFsIGZvdW5kICcgKyBkZWYubmFtZSArICcgJyArXG4gICAgICAgICAgICAgICAgdXNlZFtkZWYub3JkaW5hbF0gKyAnIGJvdGggaGF2ZSBhbiBvcmRpbmFsIG9mICcgKyBkZWYub3JkaW5hbDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB1c2VkW2RlZi5vcmRpbmFsXSA9IGRlZi5uYW1lO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHY7XG4gICAgICB9XG4gICAgfVxuICBdXG59KTtcblxuXG5mb2FtLkNMQVNTKHtcbiAgcGFja2FnZTogJ2ZvYW0uY29yZScsXG4gIG5hbWU6ICdBYnN0cmFjdEVudW0nLFxuXG4gIGRvY3VtZW50YXRpb246ICdBYnN0cmFjdCBiYXNlIGNsYXNzIGZvciBhbGwgRW51bSBjbGFzc2VzLicsXG5cbiAgYXhpb21zOiBbXG4gICAgZm9hbS5wYXR0ZXJuLk11bHRpdG9uLmNyZWF0ZSh7cHJvcGVydHk6ICdvcmRpbmFsJ30pLFxuICAgIHtcbiAgICAgIGluc3RhbGxJbkNsYXNzOiBmdW5jdGlvbihjbHMpIHtcbiAgICAgICAgLy8gRWFjaCBzdWItY2xhc3Mgb2YgQWJzdHJhY3RFbnVtIGdldHMgaXQncyBvd24gVkFMVUVTIGFycmF5LlxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY2xzLCAnVkFMVUVTJywge1xuICAgICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wcml2YXRlXy5WQUxVRVMgfHwgKCB0aGlzLnByaXZhdGVfLlZBTFVFUyA9IFtdICk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgZW51bWVyYWJsZTogZmFsc2VcbiAgICAgICAgfSk7XG4gICAgICB9LFxuICAgICAgaW5zdGFsbEluUHJvdG86IGZ1bmN0aW9uKHApIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHAsICdWQUxVRVMnLCB7XG4gICAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMuY2xzXy5WQUxVRVM7IH0sXG4gICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgXSxcblxuICBwcm9wZXJ0aWVzOiBbXG4gICAge1xuICAgICAgY2xhc3M6ICdTdHJpbmcnLFxuICAgICAgbmFtZTogJ2RvY3VtZW50YXRpb24nLFxuICAgICAgYWRhcHQ6IGZ1bmN0aW9uKF8sIGQpIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiBkID09PSAnZnVuY3Rpb24nID8gZm9hbS5TdHJpbmcubXVsdGlsaW5lKGQpLnRyaW0oKSA6IGQ7XG4gICAgICB9XG4gICAgfSxcbiAgICB7XG4gICAgICBjbGFzczogJ0ludCcsXG4gICAgICBuYW1lOiAnb3JkaW5hbCcsXG4gICAgICAvLyBOT1RFOiBEZWZhdWx0IHZhbHVlIG9mIC0xIGZvcmNlcyBsZWdpdGltYXRlIHZhbHVlcyAoc3RhcnRpbmcgYXQgMCkgdG9cbiAgICAgIC8vIGFsbCBiZSBub24tZGVmYXVsdC4gVGhpcyBpcyBpbXBvcnRhbnQgZm9yLCBlLmcuLCBzZXJpYWxpemF0aW9uIG9mIGVudW1cbiAgICAgIC8vIHZhbHVlczpcbiAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mb2FtLWZyYW1ld29yay9mb2FtMi9pc3N1ZXMvNjM3XG4gICAgICB2YWx1ZTogLTEsXG4gICAgICBmaW5hbDogdHJ1ZVxuICAgIH0sXG4gICAge1xuICAgICAgY2xhc3M6ICdTdHJpbmcnLFxuICAgICAgbmFtZTogJ25hbWUnLFxuICAgICAgZmluYWw6IHRydWVcbiAgICB9LFxuICAgIHtcbiAgICAgIGNsYXNzOiAnU3RyaW5nJyxcbiAgICAgIG5hbWU6ICdsYWJlbCcsXG4gICAgICBmaW5hbDogdHJ1ZSxcbiAgICAgIGZhY3Rvcnk6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5uYW1lO1xuICAgICAgfVxuICAgIH1cbiAgXSxcblxuICBtZXRob2RzOiBbXG4gICAgZnVuY3Rpb24gb3V0cHV0Rk9iamVjdChvKSB7XG4gICAgICBvLm91dCh0aGlzLm9yZGluYWwpO1xuICAgIH0sXG4gICAgZnVuY3Rpb24gdG9TdHJpbmcoKSB7IHJldHVybiB0aGlzLm5hbWU7IH1cbiAgXVxufSk7XG5cblxuZm9hbS5DTEFTUyh7XG4gIHBhY2thZ2U6ICdmb2FtLmNvcmUnLFxuICBuYW1lOiAnRW51bScsXG4gIGV4dGVuZHM6ICdQcm9wZXJ0eScsXG5cbiAgZG9jdW1lbnRhdGlvbjogJ0EgUHJvcGVydHkgdHlwZSBmb3Igc3RvcmluZyBlbnVtIHZhbHVlcy4nLFxuXG4gIHByb3BlcnRpZXM6IFtcbiAgICB7XG4gICAgICBjbGFzczogJ0NsYXNzJyxcbiAgICAgIG5hbWU6ICdvZicsXG4gICAgICByZXF1aXJlZDogdHJ1ZVxuICAgIH0sXG4gICAge1xuICAgICAgbmFtZTogJ3ZhbHVlJyxcbiAgICAgIGFkYXB0OiBmdW5jdGlvbihfLCBuKSB7XG4gICAgICAgIGlmICggZm9hbS5TdHJpbmcuaXNJbnN0YW5jZShuKSApIG4gPSB0aGlzLm9mW25dO1xuICAgICAgICByZXR1cm4gblxuICAgICAgfSxcbiAgICAgIGV4cHJlc3Npb246IGZ1bmN0aW9uKG9mKSB7XG4gICAgICAgIHJldHVybiBvZiAmJiBvZi5WQUxVRVNbMF07XG4gICAgICB9LFxuICAgIH0sXG4gICAge1xuICAgICAgbmFtZTogJ2phdmFWYWx1ZScsXG4gICAgICBleHByZXNzaW9uOiBmdW5jdGlvbihvZiwgdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIG9mLmlkICsgJy4nICsgdmFsdWU7XG4gICAgICB9LFxuICAgIH0sXG4gICAgW1xuICAgICAgJ2FkYXB0JyxcbiAgICAgIGZ1bmN0aW9uKG8sIG4sIHByb3ApIHtcbiAgICAgICAgdmFyIG9mID0gcHJvcC5vZjtcblxuICAgICAgICBpZiAoIG4gJiYgbi5jbHNfID09PSBvZiApIHJldHVybiBuO1xuXG4gICAgICAgIHZhciB0eXBlID0gZm9hbS50eXBlT2YobiksIHJldDtcblxuICAgICAgICBpZiAoIHR5cGUgPT09IGZvYW0uU3RyaW5nICkge1xuICAgICAgICAgIHJldCA9IG9mW2ZvYW0uU3RyaW5nLmNvbnN0YW50aXplKG4pXTtcbiAgICAgICAgfSBlbHNlIGlmICggdHlwZSA9PT0gZm9hbS5OdW1iZXIgKSB7XG4gICAgICAgICAgcmV0ID0gb2YuY3JlYXRlKHtvcmRpbmFsOiBufSwgZm9hbS5fX2NvbnRleHRfXyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIHJldCApIHJldHVybiByZXQ7XG5cbiAgICAgICAgdGhyb3cgJ0F0dGVtcHQgdG8gc2V0IGludmFsaWQgRW51bSB2YWx1ZS4gRW51bTogJyArIG9mLmlkICsgJywgdmFsdWU6ICcgKyBuO1xuICAgICAgfVxuICAgIF0sXG4gICAge1xuICAgICAgbmFtZTogJ3RvSlNPTicsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24odmFsdWUpIHsgcmV0dXJuIHZhbHVlLm9yZGluYWw7IH1cbiAgICB9XG4gIF1cbn0pO1xuXG5cbmZvYW0uTElCKHtcbiAgbmFtZTogJ2ZvYW0nLFxuXG4gIG1ldGhvZHM6IFtcbiAgICBmdW5jdGlvbiBFTlVNKG0pIHtcbiAgICAgIG0uY2xhc3MgPSBtLmNsYXNzIHx8ICdmb2FtLmNvcmUuRW51bU1vZGVsJztcbiAgICAgIHJldHVybiBmb2FtLkNMQVNTKG0pO1xuICAgIH1cbiAgXVxufSk7XG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG4vKipcbi8vIEpTT04gU3VwcG9ydFxuLy9cbi8vIFRPRE86XG4vLyAgIC0gZG9uJ3Qgb3V0cHV0IGRlZmF1bHQgY2xhc3Nlc1xuKi9cbmZvYW0uQ0xBU1Moe1xuICByZWZpbmVzOiAnZm9hbS5jb3JlLlByb3BlcnR5JyxcblxuICBwcm9wZXJ0aWVzOiBbXG4gICAge1xuICAgICAgbmFtZTogJ2Zyb21KU09OJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBmcm9tSlNPTih2YWx1ZSwgY3R4LCBwcm9wLCBqc29uKSB7XG4gICAgICAgIHJldHVybiBmb2FtLmpzb24ucGFyc2UodmFsdWUsIG51bGwsIGN0eCk7XG4gICAgICB9XG4gICAgfSxcbiAgICB7XG4gICAgICBuYW1lOiAndG9KU09OJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiB0b0pTT04odmFsdWUsIG91dHB1dHRlcikgeyByZXR1cm4gdmFsdWU7IH1cbiAgICB9XG4gIF0sXG5cbiAgbWV0aG9kczogW1xuICAgIGZ1bmN0aW9uIG91dHB1dEpTT04obykge1xuICAgICAgaWYgKCBvLnBhc3NQcm9wZXJ0aWVzQnlSZWZlcmVuY2UgKSB7XG4gICAgICAgIG8ub3V0cHV0KHsgY2xhc3M6ICdfX1Byb3BlcnR5X18nLCBmb3JDbGFzc186IHRoaXMuZm9yQ2xhc3NfLCBuYW1lOiB0aGlzLm5hbWUgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvLm91dHB1dEZPYmplY3RfKHRoaXMpO1xuICAgICAgfVxuICAgIH1cbiAgXVxufSk7XG5cbmZvYW0uQ0xBU1Moe1xuICBuYW1lOiAnX19Qcm9wZXJ0eV9fJyxcbiAgcGFja2FnZTogJ2ZvYW0uY29yZScsXG4gIGF4aW9tczogW1xuICAgIHtcbiAgICAgIG5hbWU6ICdjcmVhdGUnLFxuICAgICAgaW5zdGFsbEluQ2xhc3M6IGZ1bmN0aW9uKGMpIHtcbiAgICAgICAgdmFyIG9sZENyZWF0ZSA9IGMuY3JlYXRlO1xuICAgICAgICBjLmNyZWF0ZSA9IGZ1bmN0aW9uKGFyZ3MsIFgpIHtcbiAgICAgICAgICB2YXIgY2xzTmFtZSA9IGFyZ3MuZm9yQ2xhc3NfO1xuICAgICAgICAgIHZhciBuYW1lID0gYXJncy5uYW1lO1xuXG4gICAgICAgICAgdmFyIGNscyA9IFgubG9va3VwKGNsc05hbWUsIHRydWUpO1xuXG4gICAgICAgICAgLy8gSWYgd2UgZmFpbGVkIHRvIGZpbmQgdGhlIGNsYXNzLCB0cnkgdG8gZGVzZXJpYWxpemUgdGhlIG9sZCBmb3JtYXRcbiAgICAgICAgICAvLyB3aGVyZSBmb3JDbGFzc18gY29udGFpbnMgdGhlIGZ1bGwgcGF0aCB0byB0aGUgcHJvcGVydHk6IGZvby5iYXIuUGVyZXNvbi5sYXN0TmFtZVxuICAgICAgICAgIGlmICggISBjbHMgKSB7XG4gICAgICAgICAgICBjbHNOYW1lID0gYXJncy5mb3JDbGFzc18uc3Vic3RyaW5nKDAsIGFyZ3MuZm9yQ2xhc3NfLmxhc3RJbmRleE9mKCcuJykpO1xuICAgICAgICAgICAgbmFtZSA9IGFyZ3MuZm9yQ2xhc3NfLnN1YnN0cmluZyhhcmdzLmZvckNsYXNzXy5sYXN0SW5kZXhPZignLicpICsgMSk7XG5cbiAgICAgICAgICAgIGNscyA9IFgubG9va3VwKGNsc05hbWUpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBwcm9wID0gY2xzLmdldEF4aW9tQnlOYW1lKG5hbWUpO1xuXG4gICAgICAgICAgZm9hbS5hc3NlcnQocHJvcCwgJ0NvdWxkIG5vdCBmaW5kIHByb3BlcnR5IFwiJywgYXJncy5mb3JDbGFzc18gKyAnLicgKyBuYW1lLCAnXCInKTtcblxuICAgICAgICAgIHJldHVybiBwcm9wO1xuICAgICAgICB9O1xuICAgICAgfVxuICAgIH1cbiAgXVxufSk7XG5cbi8qKiBBZGQgdG9KU09OKCkgbWV0aG9kIHRvIEZPYmplY3QuICoqL1xuZm9hbS5DTEFTUyh7XG4gIHJlZmluZXM6ICdmb2FtLmNvcmUuRk9iamVjdCcsXG5cbiAgbWV0aG9kczogW1xuICAgIC8qKlxuICAgICAgT3V0cHV0IGFzIGEgcHJldHR5LXByaW50ZWQgSlNPTi1pc2ggU3RyaW5nLlxuICAgICAgVXNlIGZvciBkZWJ1Z2dpbmcvdGVzdGluZyBwdXJwb3Nlcy4gSWYgeW91IHdhbnQgYWN0dWFsXG4gICAgICBKU09OIG91dHB1dCwgdXNlIGZvYW0uanNvbi4qIGluc3RlYWQuXG4gICAgKi9cbiAgICBmdW5jdGlvbiBzdHJpbmdpZnkoKSB7XG4gICAgICByZXR1cm4gZm9hbS5qc29uLlByZXR0eS5zdHJpbmdpZnkodGhpcyk7XG4gICAgfVxuICBdXG59KTtcblxuXG4vKiogSlNPTiBPdXRwdXR0ZXIuICoqL1xuZm9hbS5DTEFTUyh7XG4gIHBhY2thZ2U6ICdmb2FtLmpzb24nLFxuICBuYW1lOiAnT3V0cHV0dGVyJyxcblxuICBkb2N1bWVudGF0aW9uOiAnSlNPTiBPdXRwdXR0ZXIuJyxcblxuICBwcm9wZXJ0aWVzOiBbXG4gICAge1xuICAgICAgY2xhc3M6ICdTdHJpbmcnLFxuICAgICAgbmFtZTogJ2J1Zl8nLFxuICAgICAgdmFsdWU6ICcnXG4gICAgfSxcbiAgICB7XG4gICAgICBjbGFzczogJ0ludCcsXG4gICAgICBuYW1lOiAnaW5kZW50TGV2ZWxfJyxcbiAgICAgIHZhbHVlOiAwXG4gICAgfSxcbiAgICB7XG4gICAgICBjbGFzczogJ1N0cmluZycsXG4gICAgICBuYW1lOiAnaW5kZW50U3RyJyxcbiAgICAgIHZhbHVlOiAnXFx0J1xuICAgIH0sXG4gICAge1xuICAgICAgY2xhc3M6ICdTdHJpbmcnLFxuICAgICAgbmFtZTogJ25sU3RyJyxcbiAgICAgIHZhbHVlOiAnXFxuJ1xuICAgIH0sXG4gICAge1xuICAgICAgY2xhc3M6ICdTdHJpbmcnLFxuICAgICAgbmFtZTogJ3Bvc3RDb2xvblN0cicsXG4gICAgICB2YWx1ZTogJyAnXG4gICAgfSxcbiAgICB7XG4gICAgICBjbGFzczogJ0Jvb2xlYW4nLFxuICAgICAgbmFtZTogJ3VzZVRlbXBsYXRlTGl0ZXJhbHMnLFxuICAgICAgaGVscDogJ0lmIHRydWUsIG11bHRpbGluZSBzdHJpbmdzIHdpbGwgYmUgb3V0cHV0dGVkIHVzaW5nIHRlbXBsYXRlIGxpdGVyYWxzIChpLmUuIHN1cnJvdW5kZWQgYnkgYmFja3RpY2tzKScsXG4gICAgICB2YWx1ZTogZmFsc2UsXG4gICAgfSxcbiAgICB7XG4gICAgICBjbGFzczogJ0Jvb2xlYW4nLFxuICAgICAgbmFtZTogJ2Fsd2F5c1F1b3RlS2V5cycsXG4gICAgICBoZWxwOiAnSWYgdHJ1ZSwga2V5cyBhcmUgYWx3YXlzIHF1b3RlZCwgYXMgcmVxdWlyZWQgYnkgdGhlIEpTT04gc3RhbmRhcmQuIElmIGZhbHNlLCBvbmx5IHF1b3RlIGtleXMgd2hpY2ggYXJlblxcJ3R2YWxpZCBKUyBpZGVudGlmaWVycy4nLFxuICAgICAgdmFsdWU6IHRydWVcbiAgICB9LFxuICAgIHtcbiAgICAgIGNsYXNzOiAnQm9vbGVhbicsXG4gICAgICBuYW1lOiAncGFzc1Byb3BlcnRpZXNCeVJlZmVyZW5jZScsXG4gICAgICBoZWxwOiAnSWYgdHJ1ZSwgUHJvcGVydHkgb2JqZWN0cyBhcmUgcGFzc2VkIGFzIF9fUHJvcGVydHlfXyByZWZlcmVuY2VzIHJhdGhlciB0aGFuIGJ5IHZhbHVlLicsXG4gICAgICB2YWx1ZTogdHJ1ZVxuICAgIH0sXG4gICAge1xuICAgICAgY2xhc3M6ICdCb29sZWFuJyxcbiAgICAgIG5hbWU6ICdmb3JtYXREYXRlc0FzTnVtYmVycycsXG4gICAgICB2YWx1ZTogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgIGNsYXNzOiAnQm9vbGVhbicsXG4gICAgICBuYW1lOiAnZm9ybWF0RnVuY3Rpb25zQXNTdHJpbmdzJyxcbiAgICAgIHZhbHVlOiB0cnVlXG4gICAgfSxcbiAgICB7XG4gICAgICBjbGFzczogJ0Jvb2xlYW4nLFxuICAgICAgbmFtZTogJ291dHB1dERlZmF1bHRWYWx1ZXMnLFxuICAgICAgdmFsdWU6IHRydWVcbiAgICB9LFxuICAgIHtcbiAgICAgIGNsYXNzOiAnQm9vbGVhbicsXG4gICAgICBuYW1lOiAnb3V0cHV0T3duUHJvcGVydGllc09ubHknLFxuICAgICAgZG9jdW1lbnRhdGlvbjogJ0lmIHRydWUgZXhwcmVzc2lvbnMgYXJlIG5vdCBzdG9yZWQuJyxcbiAgICAgIHZhbHVlOiB0cnVlXG4gICAgfSxcbiAgICB7XG4gICAgICBjbGFzczogJ0Jvb2xlYW4nLFxuICAgICAgbmFtZTogJ291dHB1dENsYXNzTmFtZXMnLFxuICAgICAgdmFsdWU6IHRydWVcbiAgICB9LFxuICAgIHtcbiAgICAgIGNsYXNzOiAnRnVuY3Rpb24nLFxuICAgICAgbmFtZTogJ3Byb3BlcnR5UHJlZGljYXRlJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbihvLCBwKSB7IHJldHVybiAhIHAudHJhbnNpZW50OyB9XG4gICAgfSxcbiAgICB7XG4gICAgICBjbGFzczogJ0Z1bmN0aW9uJyxcbiAgICAgIG5hbWU6ICdvYmplY3RLZXlWYWx1ZVByZWRpY2F0ZScsXG4gICAgICBkb2N1bWVudGF0aW9uOiAnQ2FsbGVkIGJlZm9yZSBvdXRwdXR0aW5nIGEga2V5L3ZhbHVlLiBPdXRwdXRzIGlmIHRydWUuJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbihrLCB2KSB7IHJldHVybiB0cnVlOyB9XG4gICAgfSxcbiAgICB7XG4gICAgICBjbGFzczogJ0Jvb2xlYW4nLFxuICAgICAgbmFtZTogJ3VzZVNob3J0TmFtZXMnLFxuICAgICAgdmFsdWU6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICBjbGFzczogJ0Jvb2xlYW4nLFxuICAgICAgbmFtZTogJ3NvcnRPYmplY3RLZXlzJyxcbiAgICAgIHZhbHVlOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgY2xhc3M6ICdCb29sZWFuJyxcbiAgICAgIG5hbWU6ICdjb252ZXJ0VW5zZXJpYWxpemFibGVUb1N0dWJzJyxcbiAgICAgIHZhbHVlOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgY2xhc3M6ICdCb29sZWFuJyxcbiAgICAgIG5hbWU6ICdwcmV0dHknLFxuICAgICAgdmFsdWU6IHRydWUsXG4gICAgICBwb3N0U2V0OiBmdW5jdGlvbihfLCBwKSB7XG4gICAgICAgIGlmICggcCApIHtcbiAgICAgICAgICB0aGlzLmNsZWFyUHJvcGVydHkoJ2luZGVudFN0cicpO1xuICAgICAgICAgIHRoaXMuY2xlYXJQcm9wZXJ0eSgnbmxTdHInKTtcbiAgICAgICAgICB0aGlzLmNsZWFyUHJvcGVydHkoJ3Bvc3RDb2xvblN0cicpO1xuICAgICAgICAgIHRoaXMuY2xlYXJQcm9wZXJ0eSgndXNlU2hvcnROYW1lcycpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuaW5kZW50U3RyID0gdGhpcy5ubFN0ciA9IHRoaXMucG9zdENvbG9uU3RyID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAge1xuICAgICAgLy8gVE9ETzogcmVuYW1lIHRvIEZPTlxuICAgICAgY2xhc3M6ICdCb29sZWFuJyxcbiAgICAgIG5hbWU6ICdzdHJpY3QnLFxuICAgICAgdmFsdWU6IHRydWUsXG4gICAgICBwb3N0U2V0OiBmdW5jdGlvbihfLCBzKSB7XG4gICAgICAgIGlmICggcyApIHtcbiAgICAgICAgICB0aGlzLnVzZVNob3J0TmFtZXMgICAgICAgICAgICA9IGZhbHNlO1xuICAgICAgICAgIHRoaXMuZm9ybWF0RGF0ZXNBc051bWJlcnMgICAgID0gZmFsc2U7XG4gICAgICAgICAgdGhpcy5hbHdheXNRdW90ZUtleXMgICAgICAgICAgPSB0cnVlO1xuICAgICAgICAgIHRoaXMuZm9ybWF0RnVuY3Rpb25zQXNTdHJpbmdzID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmFsd2F5c1F1b3RlS2V5cyAgICAgICAgICA9IGZhbHNlO1xuICAgICAgICAgIHRoaXMuZm9ybWF0RnVuY3Rpb25zQXNTdHJpbmdzID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgLypcbiAgICB7XG4gICAgICBjbGFzczogJ0Jvb2xlYW4nLFxuICAgICAgbmFtZTogJ2Z1bmN0aW9uRm9ybWF0JyxcbiAgICAgIHZhbHVlOiBmYWxzZVxuICAgIH0sXG4gICAgKi9cbiAgXSxcblxuICBtZXRob2RzOiBbXG4gICAgZnVuY3Rpb24gcmVzZXQoKSB7XG4gICAgICB0aGlzLmluZGVudExldmVsXyA9IDA7XG4gICAgICB0aGlzLmJ1Zl8gPSAnJztcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBmdW5jdGlvbiBlc2NhcGUoc3RyKSB7XG4gICAgICByZXR1cm4gc3RyXG4gICAgICAgIC5yZXBsYWNlKC9cXFxcL2csICdcXFxcXFxcXCcpXG4gICAgICAgIC5yZXBsYWNlKC9cIi9nLCAnXFxcXFwiJylcbiAgICAgICAgLnJlcGxhY2UoL1tcXHgwMC1cXHgxZl0vZywgZnVuY3Rpb24oYykge1xuICAgICAgICAgIHJldHVybiBcIlxcXFx1MDBcIiArICgoYy5jaGFyQ29kZUF0KDApIDwgMHgxMCkgP1xuICAgICAgICAgICAgICAnMCcgKyBjLmNoYXJDb2RlQXQoMCkudG9TdHJpbmcoMTYpIDpcbiAgICAgICAgICAgICAgYy5jaGFyQ29kZUF0KDApLnRvU3RyaW5nKDE2KSk7XG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICBmdW5jdGlvbiBtYXliZUVzY2FwZUtleShzdHIpIHtcbiAgICAgIHJldHVybiB0aGlzLmFsd2F5c1F1b3RlS2V5cyB8fCAhIC9eW2EtekEtWlxcJF9dWzAtOWEtekEtWiRfXSokLy50ZXN0KHN0cikgP1xuICAgICAgICAgICdcIicgKyBzdHIgKyAnXCInIDpcbiAgICAgICAgICBzdHIgO1xuICAgIH0sXG5cbiAgICBmdW5jdGlvbiBvdXQoKSB7XG4gICAgICBmb3IgKCB2YXIgaSA9IDAgOyBpIDwgYXJndW1lbnRzLmxlbmd0aCA7IGkrKyApIHRoaXMuYnVmXyArPSBhcmd1bWVudHNbaV07XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICBTdGFydCBhIGJsb2NrLCB1c2luZyB0aGUgc3VwcGxpZWQgc3RhcnQgY2hhcmFjdGVyLCB3aGljaCB3b3VsZCB0eXBpY2FsbHlcbiAgICAgIGJlICd7JyBmb3Igb2JqZWN0cyBvciAnWycgZm9yIGFycmF5cy4gIEhhbmRsZXMgaW5kZW50YXRpb24gaWYgZW5hYmxlZC5cbiAgICAqL1xuICAgIGZ1bmN0aW9uIHN0YXJ0KGMpIHtcbiAgICAgIGlmICggYyApIHRoaXMub3V0KGMpLm5sKCk7XG4gICAgICBpZiAoIHRoaXMuaW5kZW50U3RyICkge1xuICAgICAgICB0aGlzLmluZGVudExldmVsXysrO1xuICAgICAgICB0aGlzLmluZGVudCgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAgRW5kIGEgYmxvY2ssIHVzaW5nIHRoZSBzdXBwbGllZCBlbmQgY2hhcmFjdGVyLCB3aGljaCB3b3VsZCB0eXBpY2FsbHlcbiAgICAgIGJlICd9JyBmb3Igb2JqZWN0cyBvciAnXScgZm9yIGFycmF5cy5cbiAgICAqL1xuICAgIGZ1bmN0aW9uIGVuZChjKSB7XG4gICAgICBpZiAoIHRoaXMuaW5kZW50ICkge1xuICAgICAgICB0aGlzLmluZGVudExldmVsXy0tO1xuICAgICAgfVxuICAgICAgaWYgKCBjICkgdGhpcy5ubCgpLmluZGVudCgpLm91dChjKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBmdW5jdGlvbiBubCgpIHtcbiAgICAgIGlmICggdGhpcy5ubFN0ciAmJiB0aGlzLm5sU3RyLmxlbmd0aCApIHtcbiAgICAgICAgdGhpcy5vdXQodGhpcy5ubFN0cik7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgZnVuY3Rpb24gaW5kZW50KCkge1xuICAgICAgZm9yICggdmFyIGkgPSAwIDsgaSA8IHRoaXMuaW5kZW50TGV2ZWxfIDsgaSsrICkgdGhpcy5vdXQodGhpcy5pbmRlbnRTdHIpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIGZ1bmN0aW9uIG91dHB1dFByb3BlcnR5TmFtZShwKSB7XG4gICAgICB0aGlzLm91dCh0aGlzLm1heWJlRXNjYXBlS2V5KHRoaXMudXNlU2hvcnROYW1lcyAmJiBwLnNob3J0TmFtZSA/IHAuc2hvcnROYW1lIDogcC5uYW1lKSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgZnVuY3Rpb24gb3V0cHV0UHJvcGVydHkobywgcCwgaW5jbHVkZUNvbW1hKSB7XG4gICAgICBpZiAoICEgdGhpcy5wcm9wZXJ0eVByZWRpY2F0ZShvLCBwICkgKSByZXR1cm4gZmFsc2U7XG4gICAgICBpZiAoICEgdGhpcy5vdXRwdXREZWZhdWx0VmFsdWVzICYmIHAuaXNEZWZhdWx0VmFsdWUob1twLm5hbWVdKSApXG4gICAgICAgIHJldHVybiBmYWxzZTtcblxuICAgICAgLy8gQWNjZXNzIHByb3BlcnR5IGJlZm9yZSBjaGVja2luZyBvLmhhc093blByb3BlcnR5LlxuICAgICAgdmFyIHYgPSBvW3AubmFtZV07XG4gICAgICBpZiAoIHRoaXMub3V0cHV0T3duUHJvcGVydGllc09ubHkgJiYgISBvLmhhc093blByb3BlcnR5KHAubmFtZSkgKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG5cbiAgICAgIGlmICggZm9hbS5BcnJheS5pc0luc3RhbmNlKHYpICYmIHYubGVuZ3RoID09IDAgKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG5cbiAgICAgIGlmICggaW5jbHVkZUNvbW1hICkgdGhpcy5vdXQoJywnKTtcblxuICAgICAgdGhpcy5ubCgpLmluZGVudCgpLm91dHB1dFByb3BlcnR5TmFtZShwKS5vdXQoJzonLCB0aGlzLnBvc3RDb2xvblN0cik7XG4gICAgICB0aGlzLm91dHB1dChwLnRvSlNPTih2LCB0aGlzKSwgcC5vZik7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9LFxuXG4gICAgZnVuY3Rpb24gb3V0cHV0U3RyaW5nKHN0cikge1xuICAgICAgaWYgKCB0aGlzLnVzZVRlbXBsYXRlTGl0ZXJhbHMgJiYgc3RyLmluZGV4T2YoJ1xcbicpICE9IC0xICkge1xuICAgICAgICB0aGlzLm91dCgnYCcsIHN0ci5yZXBsYWNlKC9gLywgJ1xcXFxgJyksICdgJyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLm91dCgnXCInLCB0aGlzLmVzY2FwZShzdHIpLCAnXCInKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgZnVuY3Rpb24gb3V0cHV0RGF0ZShvKSB7XG4gICAgICBpZiAoIHRoaXMuZm9ybWF0RGF0ZXNBc051bWJlcnMgKSB7XG4gICAgICAgIHRoaXMub3V0KG8udmFsdWVPZigpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMub3V0KEpTT04uc3RyaW5naWZ5KG8pKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgZnVuY3Rpb24gb3V0cHV0RnVuY3Rpb24obykge1xuICAgICAgaWYgKCB0aGlzLmZvcm1hdEZ1bmN0aW9uc0FzU3RyaW5ncyApIHtcbiAgICAgICAgdGhpcy5vdXRwdXQoby50b1N0cmluZygpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMub3V0KG8udG9TdHJpbmcoKSk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIGZ1bmN0aW9uIG91dHB1dEZPYmplY3Qobywgb3B0X2Nscykge1xuICAgICAgaWYgKCBvLm91dHB1dEpTT04gKSB7XG4gICAgICAgIG8ub3V0cHV0SlNPTih0aGlzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMub3V0cHV0Rk9iamVjdF8obywgb3B0X2Nscyk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIGZ1bmN0aW9uIG91dHB1dEZPYmplY3RfKG8sIG9wdF9jbHMpIHtcbiAgICAgIC8qKiBPdXRwdXQgYW4gRk9iamVjdCB3aXRob3V0IGNoZWNraW5nIGlmIGl0IGltcGxlbWVudHMgb3V0cHV0SlNPTi4gKiovXG4gICAgICB0aGlzLnN0YXJ0KCd7Jyk7XG4gICAgICB2YXIgY2xzID0gdGhpcy5nZXRDbHMob3B0X2Nscyk7XG4gICAgICB2YXIgb3V0cHV0Q2xhc3NOYW1lID0gdGhpcy5vdXRwdXRDbGFzc05hbWVzICYmIG8uY2xzXyAhPT0gY2xzO1xuICAgICAgaWYgKCBvdXRwdXRDbGFzc05hbWUgKSB7XG4gICAgICAgIHRoaXMub3V0KFxuICAgICAgICAgIHRoaXMubWF5YmVFc2NhcGVLZXkoJ2NsYXNzJyksXG4gICAgICAgICAgJzonLFxuICAgICAgICAgIHRoaXMucG9zdENvbG9uU3RyLFxuICAgICAgICAgICdcIicsXG4gICAgICAgICAgby5jbHNfLmlkLFxuICAgICAgICAgICdcIicpO1xuICAgICAgfVxuICAgICAgdmFyIHBzID0gby5jbHNfLmdldEF4aW9tc0J5Q2xhc3MoZm9hbS5jb3JlLlByb3BlcnR5KTtcbiAgICAgIHZhciBvdXRwdXRDb21tYSA9IG91dHB1dENsYXNzTmFtZTtcbiAgICAgIGZvciAoIHZhciBpID0gMCA7IGkgPCBwcy5sZW5ndGggOyBpKysgKSB7XG4gICAgICAgIG91dHB1dENvbW1hID0gdGhpcy5vdXRwdXRQcm9wZXJ0eShvLCBwc1tpXSwgb3V0cHV0Q29tbWEpIHx8XG4gICAgICAgICAgb3V0cHV0Q29tbWE7XG4gICAgICB9XG4gICAgICB0aGlzLmVuZCgnfScpO1xuICAgIH0sXG5cbiAgICBmdW5jdGlvbiBvdXRwdXRPYmplY3RLZXlWYWx1ZV8oa2V5LCB2YWx1ZSwgZmlyc3QpIHtcbiAgICAgIGlmICggdGhpcy5vYmplY3RLZXlWYWx1ZVByZWRpY2F0ZShrZXksIHZhbHVlKSApIHtcbiAgICAgICAgaWYgKCAhIGZpcnN0ICkgdGhpcy5vdXQoJywnKS5ubCgpLmluZGVudCgpO1xuICAgICAgICB0aGlzLm91dChcbiAgICAgICAgICB0aGlzLm1heWJlRXNjYXBlS2V5KGtleSksXG4gICAgICAgICAgJzonLFxuICAgICAgICAgIHRoaXMucG9zdENvbG9uU3RyKS5vdXRwdXQodmFsdWUpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9LFxuXG4gICAgZnVuY3Rpb24gb3V0cHV0T2JqZWN0S2V5VmFsdWVzXyhvKSB7XG4gICAgICB2YXIgZmlyc3QgPSB0cnVlO1xuICAgICAgZm9yICggdmFyIGtleSBpbiBvICkge1xuICAgICAgICBmaXJzdCA9ICF0aGlzLm91dHB1dE9iamVjdEtleVZhbHVlXyhrZXksIG9ba2V5XSwgZmlyc3QpICYmIGZpcnN0O1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBmdW5jdGlvbiBvdXRwdXRTb3J0ZWRPYmplY3RLZXlWYWx1ZXNfKG8pIHtcbiAgICAgIHZhciBrZXksIGtleXMgPSBbXTtcblxuICAgICAgZm9yICgga2V5IGluIG8gKSBrZXlzLnB1c2goa2V5KTtcbiAgICAgIGtleXMuc29ydCgpO1xuXG4gICAgICB2YXIgZmlyc3QgPSB0cnVlO1xuICAgICAgZm9yICggdmFyIGkgPSAwIDsgaSA8IGtleXMubGVuZ3RoOyBpKysgKSB7XG4gICAgICAgIGtleSA9IGtleXNbaV07XG4gICAgICAgIGZpcnN0ID0gIXRoaXMub3V0cHV0T2JqZWN0S2V5VmFsdWVfKGtleSwgb1trZXldLCBmaXJzdCkgJiYgZmlyc3Q7XG4gICAgICB9XG4gICAgfSxcblxuICAgIHtcbiAgICAgIG5hbWU6ICdvdXRwdXQnLFxuICAgICAgY29kZTogZm9hbS5tbWV0aG9kKHtcbiAgICAgICAgLy8gSlNPTiBkb2Vzbid0IHN1cHBvcnQgc2VuZGluZyAndW5kZWZpbmVkJ1xuICAgICAgICBVbmRlZmluZWQ6IGZ1bmN0aW9uKG8pIHsgdGhpcy5vdXQoJ251bGwnKTsgfSxcbiAgICAgICAgTnVsbDogICAgICBmdW5jdGlvbihvKSB7IHRoaXMub3V0KCdudWxsJyk7IH0sXG4gICAgICAgIFN0cmluZzogICAgZnVuY3Rpb24obykgeyB0aGlzLm91dHB1dFN0cmluZyhvKTsgfSxcbiAgICAgICAgTnVtYmVyOiAgICBmdW5jdGlvbihvKSB7IHRoaXMub3V0KG8pOyB9LFxuICAgICAgICBCb29sZWFuOiAgIGZ1bmN0aW9uKG8pIHsgdGhpcy5vdXQobyk7IH0sXG4gICAgICAgIERhdGU6ICAgICAgZnVuY3Rpb24obykgeyB0aGlzLm91dHB1dERhdGUobyk7IH0sXG4gICAgICAgIEZ1bmN0aW9uOiAgZnVuY3Rpb24obykgeyB0aGlzLm91dHB1dEZ1bmN0aW9uKG8pOyB9LFxuICAgICAgICBGT2JqZWN0OiBmdW5jdGlvbihvLCBvcHRfY2xzKSB7IHRoaXMub3V0cHV0Rk9iamVjdChvLCBvcHRfY2xzKTsgfSxcbiAgICAgICAgQXJyYXk6IGZ1bmN0aW9uKG8sIG9wdF9jbHMpIHtcbiAgICAgICAgICB0aGlzLnN0YXJ0KCdbJyk7XG4gICAgICAgICAgdmFyIGNscyA9IHRoaXMuZ2V0Q2xzKG9wdF9jbHMpO1xuICAgICAgICAgIGZvciAoIHZhciBpID0gMCA7IGkgPCBvLmxlbmd0aCA7IGkrKyApIHtcbiAgICAgICAgICAgIHRoaXMub3V0cHV0KG9baV0sIGNscyk7XG4gICAgICAgICAgICBpZiAoIGkgPCBvLmxlbmd0aC0xICkgdGhpcy5vdXQoJywnKS5ubCgpLmluZGVudCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvL3RoaXMubmwoKTtcbiAgICAgICAgICB0aGlzLmVuZCgnXScpO1xuICAgICAgICB9LFxuICAgICAgICBPYmplY3Q6IGZ1bmN0aW9uKG8pIHtcbiAgICAgICAgICBpZiAoIG8ub3V0cHV0SlNPTiApIHtcbiAgICAgICAgICAgIG8ub3V0cHV0SlNPTih0aGlzKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5zdGFydCgneycpO1xuICAgICAgICAgICAgaWYgKCB0aGlzLnNvcnRPYmplY3RLZXlzICkge1xuICAgICAgICAgICAgICB0aGlzLm91dHB1dFNvcnRlZE9iamVjdEtleVZhbHVlc18obyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB0aGlzLm91dHB1dE9iamVjdEtleVZhbHVlc18obyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmVuZCgnfScpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSlcbiAgICB9LFxuXG4gICAgZnVuY3Rpb24gc3RyaW5naWZ5KG8sIG9wdF9jbHMpIHtcbiAgICAgIC8vIEZvY2libHkgc2V0IHRoaXMuYnVmXyB0byBlbXB0eSBzdHJpbmcuXG4gICAgICAvLyBJdCBjYW4gYmUgbm9uLWVtcHR5IGlmIGEgcHJldmlvdXMgc2VyaWFsaXplZCB0aHJldyBhbiBleGNlcHRpb24gYW5kIGRpZG4ndCBjb21wbGV0ZS5cbiAgICAgIHRoaXMuYnVmXyA9IFwiXCI7XG5cbiAgICAgIHRoaXMub3V0cHV0KG8sIG9wdF9jbHMpO1xuICAgICAgdmFyIHJldCA9IHRoaXMuYnVmXztcbiAgICAgIHRoaXMucmVzZXQoKTsgLy8gcmVzZXQgdG8gYXZvaWQgcmV0YWluaW5nIGdhcmJhZ2VcbiAgICAgIHJldHVybiByZXQ7XG4gICAgfSxcblxuICAgIHtcbiAgICAgIG5hbWU6ICdvYmplY3RpZnknLFxuICAgICAgY29kZTogZm9hbS5tbWV0aG9kKHtcbiAgICAgICAgRGF0ZTogZnVuY3Rpb24obykge1xuICAgICAgICAgIHJldHVybiB0aGlzLmZvcm1hdERhdGVzQXNOdW1iZXJzID8gby52YWx1ZU9mKCkgOiBvO1xuICAgICAgICB9LFxuICAgICAgICBGdW5jdGlvbjogZnVuY3Rpb24obykge1xuICAgICAgICAgIHJldHVybiB0aGlzLmZvcm1hdEZ1bmN0aW9uc0FzU3RyaW5ncyA/IG8udG9TdHJpbmcoKSA6IG87XG4gICAgICAgIH0sXG4gICAgICAgIEZPYmplY3Q6IGZ1bmN0aW9uKG8sIG9wdF9jbHMpIHtcbiAgICAgICAgICB2YXIgbSA9IHt9O1xuICAgICAgICAgIHZhciBjbHMgPSB0aGlzLmdldENscyhvcHRfY2xzKTtcbiAgICAgICAgICBpZiAoIHRoaXMub3V0cHV0Q2xhc3NOYW1lcyAmJiBvLmNsc18gIT09IGNscyApIHtcbiAgICAgICAgICAgIG0uY2xhc3MgPSBvLmNsc18uaWQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBwcyA9IG8uY2xzXy5nZXRBeGlvbXNCeUNsYXNzKGZvYW0uY29yZS5Qcm9wZXJ0eSk7XG4gICAgICAgICAgZm9yICggdmFyIGkgPSAwIDsgaSA8IHBzLmxlbmd0aCA7IGkrKyApIHtcbiAgICAgICAgICAgIHZhciBwID0gcHNbaV07XG4gICAgICAgICAgICBpZiAoICEgdGhpcy5wcm9wZXJ0eVByZWRpY2F0ZShvLCBwKSApIGNvbnRpbnVlO1xuICAgICAgICAgICAgaWYgKCAhIHRoaXMub3V0cHV0RGVmYXVsdFZhbHVlcyAmJiBwLmlzRGVmYXVsdFZhbHVlKG9bcC5uYW1lXSkgKVxuICAgICAgICAgICAgICBjb250aW51ZTtcblxuICAgICAgICAgICAgbVtwLm5hbWVdID0gdGhpcy5vYmplY3RpZnkocC50b0pTT04ob1twLm5hbWVdLCB0aGlzKSwgcC5vZik7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBtO1xuICAgICAgICB9LFxuICAgICAgICBBcnJheTogZnVuY3Rpb24obywgb3B0X2Nscykge1xuICAgICAgICAgIHZhciBhID0gW107XG4gICAgICAgICAgdmFyIGNscyA9IHRoaXMuZ2V0Q2xzKG9wdF9jbHMpO1xuICAgICAgICAgIGZvciAoIHZhciBpID0gMCA7IGkgPCBvLmxlbmd0aCA7IGkrKyApIHtcbiAgICAgICAgICAgIGFbaV0gPSB0aGlzLm9iamVjdGlmeShvW2ldLCBjbHMpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gYTtcbiAgICAgICAgfSxcbiAgICAgICAgT2JqZWN0OiBmdW5jdGlvbihvKSB7XG4gICAgICAgICAgdmFyIHJldCA9IHt9O1xuICAgICAgICAgIGZvciAoIHZhciBrZXkgaW4gbyApIHtcbiAgICAgICAgICAgIC8vIE5PVEU6IENvdWxkIGxhemlseSBjb25zdHJ1Y3QgXCJyZXRcIiBmaXJzdCB0aW1lXG4gICAgICAgICAgICAvLyB0aGlzLm9iamVjdGlmeShvW2tleV0pICE9PSBvW2tleV0uXG4gICAgICAgICAgICBpZiAoIG8uaGFzT3duUHJvcGVydHkoa2V5KSApIHJldFtrZXldID0gdGhpcy5vYmplY3RpZnkob1trZXldKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGZ1bmN0aW9uKG8pIHsgcmV0dXJuIG87IH0pXG4gICAgfSxcblxuICAgIGZ1bmN0aW9uIGdldENscyhvcHRfY2xzKSB7XG4gICAgICByZXR1cm4gZm9hbS50eXBlT2Yob3B0X2NscykgPT09IGZvYW0uU3RyaW5nID8gdGhpcy5sb29rdXAob3B0X2NscywgdHJ1ZSkgOlxuICAgICAgICAgIG9wdF9jbHM7XG4gICAgfVxuICBdXG59KTtcblxuXG5mb2FtLkNMQVNTKHtcbiAgcGFja2FnZTogJ2ZvYW0uanNvbicsXG4gIG5hbWU6ICdQYXJzZXInLFxuXG4gIHByb3BlcnRpZXM6IFtcbiAgICB7XG4gICAgICBjbGFzczogJ0Jvb2xlYW4nLFxuICAgICAgbmFtZTogJ3N0cmljdCcsXG4gICAgICB2YWx1ZTogdHJ1ZVxuICAgIH0sXG4gICAge1xuICAgICAgbmFtZTogJ2NyZWF0aW9uQ29udGV4dCdcbiAgICB9LFxuICAgIHtcbiAgICAgIG5hbWU6ICdmb25QYXJzZXJfJyxcbiAgICAgIGV4cHJlc3Npb246IGZ1bmN0aW9uKGNyZWF0aW9uQ29udGV4dCkge1xuICAgICAgICByZXR1cm4gZm9hbS5wYXJzZXJzLkZPTi5jcmVhdGUoe1xuICAgICAgICAgIGNyZWF0aW9uQ29udGV4dDogY3JlYXRpb25Db250ZXh0XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgXSxcblxuICBtZXRob2RzOiBbXG4gICAgZnVuY3Rpb24gcGFyc2VTdHJpbmcoc3RyLCBvcHRfY3R4KSB7XG4gICAgICByZXR1cm4gdGhpcy5wYXJzZUNsYXNzRnJvbVN0cmluZyhzdHIsIG51bGwsIG9wdF9jdHgpO1xuICAgIH0sXG4gICAgZnVuY3Rpb24gYXBhcnNlKHN0ciwgb3B0X2N0eCkge1xuICAgICAgdmFyIHggPSB0aGlzLl9fY29udGV4dF9fO1xuXG4gICAgICB2YXIganNvbiA9IEpTT04ucGFyc2Uoc3RyKTtcblxuICAgICAgdmFyIHJlZmVyZW5jZXMgPSBmb2FtLmpzb24ucmVmZXJlbmNlcyh4LCBqc29uKTs7XG5cbiAgICAgIHJldHVybiBQcm9taXNlLmFsbChyZWZlcmVuY2VzKS50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gZm9hbS5qc29uLnBhcnNlKGpzb24sIHVuZGVmaW5lZCwgb3B0X2N0eCB8fCB0aGlzLmNyZWF0aW9uQ29udGV4dCk7XG4gICAgICB9LmJpbmQodGhpcykpO1xuICAgIH0sXG4gICAgZnVuY3Rpb24gcGFyc2VDbGFzc0Zyb21TdHJpbmcoc3RyLCBvcHRfY2xzLCBvcHRfY3R4KSB7XG4gICAgICByZXR1cm4gdGhpcy5zdHJpY3QgP1xuICAgICAgICAgIC8vIEpTT04ucGFyc2UoKSBpcyBmYXN0ZXI7IHVzZSBpdCB3aGVuIGRhdGEgZm9ybWF0IGFsbG93cy5cbiAgICAgICAgICBmb2FtLmpzb24ucGFyc2UoSlNPTi5wYXJzZShzdHIpLCBvcHRfY2xzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRfY3R4IHx8IHRoaXMuY3JlYXRpb25Db250ZXh0KSA6XG4gICAgICAgICAgLy8gQ3JlYXRlIG5ldyBwYXJzZXIgaWZmIGRpZmZlcmVudCBjb250ZXh0IHdhcyBpbmplY3RlZDsgb3RoZXJ3aXNlXG4gICAgICAgICAgLy8gdXNlIHNhbWUgcGFyc2VyIGJvdW5kIHRvIFwiY3JlYXRpb25Db250ZXh0XCIgZWFjaCB0aW1lLlxuICAgICAgICAgIG9wdF9jdHggPyBmb2FtLnBhcnNlcnMuRk9OLmNyZWF0ZSh7XG4gICAgICAgICAgICBjcmVhdGlvbkNvbnRleHQ6IG9wdF9jdHggfHwgdGhpcy5jcmVhdGlvbkNvbnRleHRcbiAgICAgICAgICB9KS5wYXJzZUNsYXNzRnJvbVN0cmluZyhzdHIsIG9wdF9jbHMpIDpcbiAgICAgICAgICB0aGlzLmZvblBhcnNlcl8ucGFyc2VDbGFzc0Zyb21TdHJpbmcoc3RyLCBvcHRfY2xzKTtcbiAgICB9XG4gIF1cbn0pO1xuXG5cbi8qKiBMaWJyYXJ5IG9mIHByZS1jb25maWd1cmVkIEpTT04gT3V0cHV0dGVycy4gKiovXG5mb2FtLkxJQih7XG4gIG5hbWU6ICdmb2FtLmpzb24nLFxuXG4gIGNvbnN0YW50czoge1xuXG4gICAgLy8gUHJldHR5IFByaW50XG4gICAgUHJldHR5OiBmb2FtLmpzb24uT3V0cHV0dGVyLmNyZWF0ZSh7XG4gICAgICBzdHJpY3Q6IGZhbHNlXG4gICAgfSksXG5cbiAgICAvLyBTdHJpY3QgbWVhbnMgb3V0cHV0IGFzIHByb3BlciBKU09OLlxuICAgIFN0cmljdDogZm9hbS5qc29uLk91dHB1dHRlci5jcmVhdGUoe1xuICAgICAgcHJldHR5OiBmYWxzZSxcbiAgICAgIHN0cmljdDogdHJ1ZVxuICAgIH0pLFxuXG4gICAgLy8gUHJldHR5IGFuZCBwcm9wZXIgSlNPTi5cbiAgICBQcmV0dHlTdHJpY3Q6IGZvYW0uanNvbi5PdXRwdXR0ZXIuY3JlYXRlKHtcbiAgICAgIHByZXR0eTogdHJ1ZSxcbiAgICAgIHN0cmljdDogdHJ1ZVxuICAgIH0pLFxuXG4gICAgLy8gQ29tcGFjdCBvdXRwdXQgKG5vdCBwcmV0dHkpXG4gICAgQ29tcGFjdDogZm9hbS5qc29uLk91dHB1dHRlci5jcmVhdGUoe1xuICAgICAgcHJldHR5OiBmYWxzZSxcbiAgICAgIGZvcm1hdERhdGVzQXNOdW1iZXJzOiB0cnVlLFxuICAgICAgb3V0cHV0RGVmYXVsdFZhbHVlczogZmFsc2UsXG4gICAgICBzdHJpY3Q6IGZhbHNlXG4gICAgfSksXG5cbiAgICAvLyBTaG9ydGVyIHRoYW4gQ29tcGFjdCAodXNlcyBzaG9ydC1uYW1lcyBpZiBhdmFpbGFibGUpXG4gICAgU2hvcnQ6IGZvYW0uanNvbi5PdXRwdXR0ZXIuY3JlYXRlKHtcbiAgICAgIHByZXR0eTogZmFsc2UsXG4gICAgICBmb3JtYXREYXRlc0FzTnVtYmVyczogdHJ1ZSxcbiAgICAgIG91dHB1dERlZmF1bHRWYWx1ZXM6IGZhbHNlLFxuICAgICAgLy8gVE9ETzogTm8gZGVzZXJpYWxpemF0aW9uIHN1cHBvcnQgZm9yIHNob3J0bmFtZXMgeWV0LlxuICAgICAgLy8gICAgICB1c2VTaG9ydE5hbWVzOiB0cnVlLFxuICAgICAgdXNlU2hvcnROYW1lczogZmFsc2UsXG4gICAgICBzdHJpY3Q6IGZhbHNlXG4gICAgfSksXG5cbiAgICAvLyBTaG9ydCwgYnV0IGV4Y2x1ZGUgbmV0d29yay10cmFuc2llbnQgcHJvcGVydGllcy5cbiAgICBOZXR3b3JrOiBmb2FtLmpzb24uT3V0cHV0dGVyLmNyZWF0ZSh7XG4gICAgICBwcmV0dHk6IGZhbHNlLFxuICAgICAgZm9ybWF0RGF0ZXNBc051bWJlcnM6IHRydWUsXG4gICAgICBvdXRwdXREZWZhdWx0VmFsdWVzOiBmYWxzZSxcbiAgICAgIC8vIFRPRE86IE5vIGRlc2VyaWFsaXphdGlvbiBzdXBwb3J0IGZvciBzaG9ydG5hbWVzIHlldC5cbiAgICAgIC8vICAgICAgdXNlU2hvcnROYW1lczogdHJ1ZSxcbiAgICAgIHVzZVNob3J0TmFtZXM6IGZhbHNlLFxuICAgICAgLy8gVE9ETzogQ3VycmVudGx5IGZhc3RlciB0byB1c2Ugc3RyaWN0IEpTT04gYW5kIG5hdGl2ZSBKU09OLnBhcnNlXG4gICAgICBzdHJpY3Q6IHRydWUsXG4gICAgICBjb252ZXJ0VW5zZXJpYWxpemFibGVUb1N0dWJzOiB0cnVlLFxuICAgICAgcHJvcGVydHlQcmVkaWNhdGU6IGZ1bmN0aW9uKG8sIHApIHsgcmV0dXJuICEgcC5uZXR3b3JrVHJhbnNpZW50OyB9XG4gICAgfSksXG5cbiAgICAvLyBTaG9ydCwgYnV0IGV4Y2x1ZGUgc3RvcmFnZS10cmFuc2llbnQgcHJvcGVydGllcy5cbiAgICBTdG9yYWdlOiBmb2FtLmpzb24uT3V0cHV0dGVyLmNyZWF0ZSh7XG4gICAgICBwcmV0dHk6IGZhbHNlLFxuICAgICAgZm9ybWF0RGF0ZXNBc051bWJlcnM6IHRydWUsXG4gICAgICBvdXRwdXREZWZhdWx0VmFsdWVzOiBmYWxzZSxcbiAgICAgIC8vIFRPRE86IE5vIGRlc2VyaWFsaXphdGlvbiBzdXBwb3J0IGZvciBzaG9ydG5hbWVzIHlldC5cbiAgICAgIC8vICAgICAgdXNlU2hvcnROYW1lczogdHJ1ZSxcbiAgICAgIHVzZVNob3J0TmFtZXM6IGZhbHNlLFxuICAgICAgc3RyaWN0OiBmYWxzZSxcbiAgICAgIHByb3BlcnR5UHJlZGljYXRlOiBmdW5jdGlvbihvLCBwKSB7IHJldHVybiAhIHAuc3RvcmFnZVRyYW5zaWVudDsgfVxuICAgIH0pXG4gIH0sXG5cbiAgbWV0aG9kczogW1xuICAgIHtcbiAgICAgIC8vIFRPRE86IHdoeSBpcyB0aGlzIGNhbGxlZCBwYXJzZSB3aGVuIGl0J3MgcmVhbGx5IG9iamVjdGlmeT9cbiAgICAgIG5hbWU6ICdwYXJzZScsXG4gICAgICBjb2RlOiBmb2FtLm1tZXRob2Qoe1xuICAgICAgICBBcnJheTogZnVuY3Rpb24obywgb3B0X2NsYXNzLCBvcHRfY3R4KSB7XG4gICAgICAgICAgdmFyIGEgPSBuZXcgQXJyYXkoby5sZW5ndGgpO1xuICAgICAgICAgIGZvciAoIHZhciBpID0gMCA7IGkgPCBvLmxlbmd0aCA7IGkrKyApIHtcbiAgICAgICAgICAgIGFbaV0gPSB0aGlzLnBhcnNlKG9baV0sIG9wdF9jbGFzcywgb3B0X2N0eCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIGE7XG4gICAgICAgIH0sXG4gICAgICAgIEZPYmplY3Q6IGZ1bmN0aW9uKG8pIHsgcmV0dXJuIG87IH0sXG4gICAgICAgIE9iamVjdDogZnVuY3Rpb24oanNvbiwgb3B0X2NsYXNzLCBvcHRfY3R4KSB7XG4gICAgICAgICAgdmFyIGNscyA9IGpzb24uY2xhc3MgfHwgb3B0X2NsYXNzO1xuXG4gICAgICAgICAgaWYgKCBjbHMgKSB7XG4gICAgICAgICAgICB2YXIgYyA9IHR5cGVvZiBjbHMgPT09ICdzdHJpbmcnID8gKCBvcHRfY3R4IHx8IGZvYW0gKS5sb29rdXAoY2xzKSA6IGNscztcbiAgICAgICAgICAgIC8vIFRPRE8obWFya2RpdHRtZXIpOiBUdXJuIGludG8gc3RhdGljIG1ldGhvZDogXCJwYXJzZUpTT05cIiBvbmNlXG4gICAgICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vZm9hbS1mcmFtZXdvcmsvZm9hbTIvaXNzdWVzLzYxMyBpcyBmaXhlZC5cbiAgICAgICAgICAgIGlmICggYy5QQVJTRV9KU09OICkgcmV0dXJuIGMuUEFSU0VfSlNPTihqc29uLCBvcHRfY2xhc3MsIG9wdF9jdHgpO1xuXG4gICAgICAgICAgICBmb3IgKCB2YXIga2V5IGluIGpzb24gKSB7XG4gICAgICAgICAgICAgIHZhciBwcm9wID0gYy5nZXRBeGlvbUJ5TmFtZShrZXkpO1xuICAgICAgICAgICAgICBpZiAoIHByb3AgKSB7XG4gICAgICAgICAgICAgICAganNvbltrZXldID0gcHJvcC5mcm9tSlNPTihqc29uW2tleV0sIG9wdF9jdHgsIHByb3AsIHRoaXMpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBjLmNyZWF0ZShqc29uLCBvcHRfY3R4KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmb3IgKCB2YXIga2V5IGluIGpzb24gKSB7XG4gICAgICAgICAgICB2YXIgbyA9IGpzb25ba2V5XTtcbiAgICAgICAgICAgIGpzb25ba2V5XSA9IHRoaXMucGFyc2UoanNvbltrZXldLCBudWxsLCBvcHRfY3R4KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4ganNvbjtcbiAgICAgICAgfVxuICAgICAgfSwgZnVuY3Rpb24obykgeyByZXR1cm4gbzsgfSlcbiAgICB9LFxuXG4gICAge1xuICAgICAgbmFtZTogJ3JlZmVyZW5jZXMnLFxuICAgICAgY29kZTogZnVuY3Rpb24oeCwgbywgcikge1xuICAgICAgICByID0gciB8fCBbXTtcblxuICAgICAgICBpZiAoIGZvYW0uQXJyYXkuaXNJbnN0YW5jZShvKSApIHtcbiAgICAgICAgICBmb3IgKCB2YXIgaSA9IDAgOyBpIDwgby5sZW5ndGggOyBpKysgKSB7XG4gICAgICAgICAgICBmb2FtLmpzb24ucmVmZXJlbmNlcyh4LCBvW2ldLCByKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gVE9ETzogU2hvdWxkIGp1c3QgYmUgZm9hbS5jb3JlLkZPYmplY3QuaXNTdWJDbGFzcyhvKSwgYnV0IGl0cyBicm9rZW4gIzEwMjNcbiAgICAgICAgfSBlbHNlIGlmICggKCBvICYmIG8ucHJvdG90eXBlICYmIGZvYW0uY29yZS5GT2JqZWN0LnByb3RvdHlwZS5pc1Byb3RvdHlwZU9mKG8ucHJvdG90eXBlKSApIHx8XG4gICAgICAgICAgICAgICAgICAgIGZvYW0uY29yZS5GT2JqZWN0LmlzSW5zdGFuY2UobykgKSB7XG4gICAgICAgICAgcmV0dXJuIHI7XG4gICAgICAgIH0gZWxzZSBpZiAoIGZvYW0uT2JqZWN0LmlzSW5zdGFuY2UobykgKSB7XG4gICAgICAgICAgZm9yICggdmFyIGtleSBpbiBvICkge1xuICAgICAgICAgICAgLy8gYW5vbnltb3VzIGNsYXNzIHN1cHBvcnQuXG4gICAgICAgICAgICBpZiAoIGtleSA9PT0gJ2NsYXNzJyAmJiBmb2FtLk9iamVjdC5pc0luc3RhbmNlKG9ba2V5XSkgKSB7XG4gICAgICAgICAgICAgIHZhciBqc29uID0gb1trZXldO1xuICAgICAgICAgICAgICBqc29uLm5hbWUgPSAnQW5vbnltb3VzQ2xhc3MnICsgZm9hbS5uZXh0JFVJRCgpO1xuICAgICAgICAgICAgICBjb25zb2xlLmxvZygnQ29uc3RydWN0aW5nIGFub255bW91cyBjbGFzcycsIGpzb24ubmFtZSk7XG5cbiAgICAgICAgICAgICAgci5wdXNoKFByb21pc2UuYWxsKGZvYW0uanNvbi5yZWZlcmVuY2VzKHgsIGpzb24sIFtdKSkudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geC5jbGFzc2xvYWRlci5tYXliZUxvYWQoZm9hbS5jb3JlLk1vZGVsLmNyZWF0ZShqc29uKSk7XG4gICAgICAgICAgICAgIH0pKTtcblxuICAgICAgICAgICAgICBvW2tleV0gPSBqc29uLm5hbWU7XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfSBlbHNlIGlmICggKCBrZXkgPT09ICdvZicgfHwga2V5ID09PSAnY2xhc3MnIHx8IGtleSA9PSAndmlldycgKSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgZm9hbS5TdHJpbmcuaXNJbnN0YW5jZShvW2tleV0pICkge1xuICAgICAgICAgICAgICByLnB1c2goeC5jbGFzc2xvYWRlci5tYXliZUxvYWQob1trZXldKSk7XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmb2FtLmpzb24ucmVmZXJlbmNlcyh4LCBvW2tleV0sIHIpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiByO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8vIFRPRE86IHVuc2FmZSBhbmQgb25seSB1c2VkIGJ5IExvY2FsU3RvcmFnZURBTywgc28gcmVtb3ZlLlxuICAgIGZ1bmN0aW9uIHBhcnNlU3RyaW5nKGpzb25TdHIsIG9wdF9jdHgpIHtcbiAgICAgIHJldHVybiB0aGlzLnBhcnNlKGV2YWwoJygnICsganNvblN0ciArICcpJyksIHVuZGVmaW5lZCwgb3B0X2N0eCk7XG4gICAgfSxcblxuICAgIGZ1bmN0aW9uIHN0cmluZ2lmeShvKSB7XG4gICAgICByZXR1cm4gZm9hbS5qc29uLkNvbXBhY3Quc3RyaW5naWZ5KG8pO1xuICAgIH0sXG5cbiAgICBmdW5jdGlvbiBvYmplY3RpZnkobykge1xuICAgICAgcmV0dXJuIGZvYW0uanNvbi5Db21wYWN0Lm9iamVjdGlmeShvKTtcbiAgICB9XG4gIF1cbn0pO1xuLyoqXG5AbGljZW5zZVxuQ29weXJpZ2h0IDIwMTcgVGhlIEZPQU0gQXV0aG9ycy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbmh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKi9cblxuZm9hbS5DTEFTUyh7XG4gIHJlZmluZXM6ICdmb2FtLmNvcmUuUHJvcGVydHknLFxuXG4gIHByb3BlcnRpZXM6IFtcbiAgICB7XG4gICAgICBjbGFzczogJ0Jvb2xlYW4nLFxuICAgICAgbmFtZTogJ3htbEF0dHJpYnV0ZScsXG4gICAgICB2YWx1ZTogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgIGNsYXNzOiAnQm9vbGVhbicsXG4gICAgICBuYW1lOiAneG1sVGV4dE5vZGUnLFxuICAgICAgdmFsdWU6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICBuYW1lOiAnZnJvbVhNTCcsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZnJvbVhNTCh2YWx1ZSwgY3R4LCBwcm9wLCB4bWwpIHtcbiAgICAgICAgcmV0dXJuIGZvYW0ueG1sLnBhcnNlKHZhbHVlLCBudWxsLCBjdHgpO1xuICAgICAgfVxuICAgIH0sXG4gICAge1xuICAgICAgbmFtZTogJ3RvWE1MJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiB0b1hNTCh2YWx1ZSwgT3V0cHV0dGVyKSB7IHJldHVybiB2YWx1ZTsgfVxuICAgIH1cbiAgXSxcblxuICBtZXRob2RzOiBbXG4gICAgZnVuY3Rpb24gb3V0cHV0WE1MKG8pIHtcbiAgICAgIG8ub3V0cHV0KHsgY2xhc3M6ICdfX1Byb3BlcnR5X18nLCBmb3JDbGFzc186IHRoaXMuZm9yQ2xhc3NfLCBuYW1lOiB0aGlzLm5hbWUgfSk7XG4gICAgfVxuICBdXG59KTtcblxuLyoqIEFkZCB0b1hNTCgpIG1ldGhvZCB0byBGT2JqZWN0LiAqKi9cbmZvYW0uQ0xBU1Moe1xuICByZWZpbmVzOiAnZm9hbS5jb3JlLkZPYmplY3QnLFxuXG4gIG1ldGhvZHM6IFtcbiAgICAvKipcbiAgICAgIE91dHB1dCBhcyBhIHByZXR0eS1wcmludGVkIFhNTC1pc2ggU3RyaW5nLlxuICAgICAgVXNlIGZvciBkZWJ1Z2dpbmcvdGVzdGluZyBwdXJwb3Nlcy4gSWYgeW91IHdhbnQgYWN0dWFsXG4gICAgICBYTUwgb3V0cHV0LCB1c2UgZm9hbS54bWwuKiBpbnN0ZWFkLlxuICAgICovXG4gICAgZnVuY3Rpb24gc3RyaW5naWZ5KCkge1xuICAgICAgcmV0dXJuIGZvYW0ueG1sLlByZXR0eS5zdHJpbmdpZnkodGhpcyk7XG4gICAgfVxuICBdXG59KTtcblxuXG4vKiogWE1MIE91dHB1dHRlciAqKi9cbmZvYW0uQ0xBU1Moe1xuICBwYWNrYWdlOiAnZm9hbS54bWwnLFxuICBuYW1lOiBcIk91dHB1dHRlclwiLFxuXG4gIGRvY3VtZW50YXRpb246ICdYTUwgT3V0cHV0dGVyLicsXG5cbiAgcHJvcGVydGllczogW1xuICAgIHtcbiAgICAgIGNsYXNzOiAnU3RyaW5nJyxcbiAgICAgIG5hbWU6ICdidWZfJyxcbiAgICAgIHZhbHVlOiAnJ1xuICAgIH0sXG4gICAge1xuICAgICAgY2xhc3M6ICdJbnQnLFxuICAgICAgbmFtZTogJ2luZGVudExldmVsXycsXG4gICAgICB2YWx1ZTogMFxuICAgIH0sXG4gICAge1xuICAgICAgY2xhc3M6ICdTdHJpbmcnLFxuICAgICAgbmFtZTogJ2luZGVudFN0cicsXG4gICAgICB2YWx1ZTogJ1xcdCdcbiAgICB9LFxuICAgIHtcbiAgICAgIGNsYXNzOiAnU3RyaW5nJyxcbiAgICAgIG5hbWU6ICdubFN0cicsXG4gICAgICB2YWx1ZTogJ1xcbidcbiAgICB9LFxuICAgIHtcbiAgICAgIGNsYXNzOiAnQm9vbGVhbicsXG4gICAgICBuYW1lOiAnb3V0cHV0RGVmYXVsdFZhbHVlcycsXG4gICAgICB2YWx1ZTogdHJ1ZVxuICAgIH0sXG4gICAge1xuICAgICAgY2xhc3M6ICdCb29sZWFuJyxcbiAgICAgIG5hbWU6ICdvdXRwdXREZWZpbmVkVmFsdWVzJyxcbiAgICAgIHZhbHVlOiB0cnVlXG4gICAgfSxcbiAgICB7XG4gICAgICBjbGFzczogJ0Jvb2xlYW4nLFxuICAgICAgbmFtZTogJ2Zvcm1hdERhdGVzQXNOdW1iZXJzJyxcbiAgICAgIHZhbHVlOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgY2xhc3M6ICdCb29sZWFuJyxcbiAgICAgIG5hbWU6ICdvdXRwdXRDbGFzc05hbWVzJyxcbiAgICAgIHZhbHVlOiB0cnVlXG4gICAgfSxcbiAgICB7XG4gICAgICBjbGFzczogJ0Z1bmN0aW9uJyxcbiAgICAgIG5hbWU6ICdwcm9wZXJ0eVByZWRpY2F0ZScsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24obywgcCkgeyByZXR1cm4gISBwLnRyYW5zaWVudDsgfVxuICAgIH0sXG4gICAge1xuICAgICAgY2xhc3M6ICdCb29sZWFuJyxcbiAgICAgIG5hbWU6ICd1c2VTaG9ydE5hbWVzJyxcbiAgICAgIHZhbHVlOiBmYWxzZVxuICAgIH0sXG4gICAgICAgIHtcbiAgICAgIGNsYXNzOiAnQm9vbGVhbicsXG4gICAgICBuYW1lOiAnc29ydE9iamVjdEtleXMnLFxuICAgICAgdmFsdWU6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICBjbGFzczogJ0Jvb2xlYW4nLFxuICAgICAgbmFtZTogJ3ByZXR0eScsXG4gICAgICB2YWx1ZTogdHJ1ZSxcbiAgICAgIHBvc3RTZXQ6IGZ1bmN0aW9uKF8sIHApIHtcbiAgICAgICAgaWYgKCBwICkge1xuICAgICAgICAgIHRoaXMuY2xlYXJQcm9wZXJ0eSgnaW5kZW50U3RyJyk7XG4gICAgICAgICAgdGhpcy5jbGVhclByb3BlcnR5KCdubFN0cicpO1xuICAgICAgICAgIHRoaXMuY2xlYXJQcm9wZXJ0eSgndXNlU2hvcnROYW1lcycpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuaW5kZW50U3RyID0gdGhpcy5ubFN0ciA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIF0sXG5cbiAgbWV0aG9kczogW1xuXG4gICAgZnVuY3Rpb24gcmVzZXQoKSB7XG4gICAgICB0aGlzLmluZGVudExldmVsXyA9IDA7XG4gICAgICB0aGlzLmJ1Zl8gPSAnJztcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBmdW5jdGlvbiBlc2NhcGUoc3RyKSB7XG4gICAgICAgIHJldHVybiBzdHIgJiYgc3RyLnRvU3RyaW5nKClcbiAgICAgICAgICAgIC5yZXBsYWNlKC8mL2csICcmYW1wOycpXG4gICAgICAgICAgICAucmVwbGFjZSgvPC9nLCAnJmx0OycpXG4gICAgICAgICAgICAucmVwbGFjZSgvPi9nLCAnJmd0OycpO1xuICAgIH0sXG5cbiAgICBmdW5jdGlvbiBtYXliZUVzY2FwZUtleShzdHIpIHtcbiAgICAgIHJldHVybiB0aGlzLmFsd2F5c1F1b3RlS2V5cyB8fCAhIC9eW2EtekEtWlxcJF9dWzAtOWEtekEtWiRfXSokLy50ZXN0KHN0cikgP1xuICAgICAgICAgICdcIicgKyBzdHIgKyAnXCInIDpcbiAgICAgICAgICBzdHIgO1xuICAgIH0sXG5cbiAgICBmdW5jdGlvbiBlc2NhcGVBdHRyKHN0cikge1xuICAgICAgICByZXR1cm4gc3RyICYmIHN0ci5yZXBsYWNlKC9cIi9nLCAnJnF1b3Q7Jyk7XG4gICAgfSxcblxuICAgIGZ1bmN0aW9uIG91dCgpIHtcbiAgICAgIGZvciAoIHZhciBpID0gMCA7IGkgPCBhcmd1bWVudHMubGVuZ3RoIDsgaSsrICkgdGhpcy5idWZfICs9IGFyZ3VtZW50c1tpXTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBmdW5jdGlvbiBzdGFydChjKSB7XG4gICAgICBpZiAoIGMgKSB0aGlzLm91dChjKTtcbiAgICAgIGlmICggdGhpcy5pbmRlbnRTdHIgKSB7XG4gICAgICAgIHRoaXMuaW5kZW50TGV2ZWxfKys7XG4gICAgICAgIHRoaXMuaW5kZW50KCk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIGZ1bmN0aW9uIGVuZChjKSB7XG4gICAgICBpZiAoIHRoaXMuaW5kZW50ICkge1xuICAgICAgICB0aGlzLmluZGVudExldmVsXy0tO1xuICAgICAgfVxuICAgICAgaWYgKCBjICkgdGhpcy5ubCgpLmluZGVudCgpLm91dChjKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBmdW5jdGlvbiBubCgpIHtcbiAgICAgIGlmICggdGhpcy5ubFN0ciAmJiB0aGlzLm5sU3RyLmxlbmd0aCApIHtcbiAgICAgICAgdGhpcy5vdXQodGhpcy5ubFN0cik7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgZnVuY3Rpb24gaW5kZW50KCkge1xuICAgICAgZm9yICggdmFyIGkgPSAwIDsgaSA8IHRoaXMuaW5kZW50TGV2ZWxfIDsgaSsrICkgdGhpcy5vdXQodGhpcy5pbmRlbnRTdHIpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIGZ1bmN0aW9uIG91dHB1dFByb3BlcnR5TmFtZShwKSB7XG4gICAgICB0aGlzLm91dCh0aGlzLm1heWJlRXNjYXBlS2V5KHRoaXMudXNlU2hvcnROYW1lcyAmJiBwLnNob3J0TmFtZSA/IHAuc2hvcnROYW1lIDogcC5uYW1lKSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgZnVuY3Rpb24gb3V0cHV0QXR0cmlidXRlcyh2KSB7XG4gICAgICB2YXIgYXR0cmlidXRlcyA9IHYuY2xzXy5nZXRBeGlvbXNCeUNsYXNzKGZvYW0uY29yZS5Qcm9wZXJ0eSkuZmlsdGVyKGZ1bmN0aW9uIChwKSB7IHJldHVybiBwLnhtbEF0dHJpYnV0ZSB9KTtcbiAgICAgIGlmICggYXR0cmlidXRlcy5sZW5ndGggPT09IDAgKSByZXR1cm4gdGhpcztcblxuICAgICAgZm9yICggdmFyIGkgPSAwIDsgaSA8IGF0dHJpYnV0ZXMubGVuZ3RoIDsgaSsrICkge1xuICAgICAgICB0aGlzLm91dCgnICcgKyBhdHRyaWJ1dGVzW2ldLm5hbWUgKyAnPVwiJyArIHRoaXMuZXNjYXBlQXR0cihhdHRyaWJ1dGVzW2ldLmdldCh2KSkgKyAnXCInKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBmdW5jdGlvbiBwcm9wZXJ0eU5hbWUocCkge1xuICAgICAgcmV0dXJuIHRoaXMubWF5YmVFc2NhcGVLZXkodGhpcy51c2VTaG9ydE5hbWVzICYmIHAuc2hvcnROYW1lID8gcC5zaG9ydE5hbWUgOiBwLm5hbWUpXG4gICAgfSxcblxuICAgIGZ1bmN0aW9uIG91dHB1dFByb3BlcnR5XyhvLCBwKSB7XG4gICAgICBpZiAoICEgdGhpcy5wcm9wZXJ0eVByZWRpY2F0ZShvLCBwICkgKSByZXR1cm47XG4gICAgICAvLyBkb24ndCBvdXRwdXQgZGVmYXVsdCB2YWx1ZXMgdW5sZXNzIHZhbHVlIGlzIGRlZmluZWQgYW5kIG91dHB1dERlZmluZWRWYWx1ZXMgc2V0IHRvIHRydWVcbiAgICAgIGlmICggdGhpcy5vdXRwdXREZWZpbmVkVmFsdWVzICkge1xuICAgICAgICBpZiAoICEgby5oYXNPd25Qcm9wZXJ0eShwLm5hbWUpICkgcmV0dXJuO1xuICAgICAgfSBlbHNlIGlmICggdGhpcy5vdXRwdXREZWZhdWx0VmFsdWVzICkge1xuICAgICAgICBpZiAoIHAuaXNEZWZhdWx0VmFsdWUob1twLm5hbWVdKSApIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIHYgPSBvW3AubmFtZV07XG4gICAgICBpZiAoICEgdiB8fCAoIHYgaW5zdGFuY2VvZiBBcnJheSAmJiB2Lmxlbmd0aCA9PT0gMCApICkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHRoaXMubmwoKS5pbmRlbnQoKTtcbiAgICAgIHRoaXMub3V0cHV0UHJvcGVydHkodiwgcCk7XG4gICAgfSxcblxuICAgIHtcbiAgICAgIG5hbWU6ICdvdXRwdXRQcm9wZXJ0eScsXG4gICAgICBjb2RlOiBmb2FtLm1tZXRob2Qoe1xuICAgICAgICBVbmRlZmluZWQ6ICAgIGZ1bmN0aW9uKHYsIHApIHt9LFxuICAgICAgICBTdHJpbmc6ICAgICAgIGZ1bmN0aW9uKHYsIHApIHsgdGhpcy5vdXRwdXRQcmltaXRpdmUodiwgcCk7IH0sXG4gICAgICAgIE51bWJlcjogICAgICAgZnVuY3Rpb24odiwgcCkgeyB0aGlzLm91dHB1dFByaW1pdGl2ZSh2LCBwKTsgfSxcbiAgICAgICAgQm9vbGVhbjogICAgICBmdW5jdGlvbih2LCBwKSB7IHRoaXMub3V0cHV0UHJpbWl0aXZlKHYsIHApOyB9LFxuICAgICAgICBEYXRlOiAgICAgICAgIGZ1bmN0aW9uKHYsIHApIHsgdGhpcy5vdXRwdXRQcmltaXRpdmUodiwgcCk7IH0sXG4gICAgICAgIEFic3RyYWN0RW51bTogZnVuY3Rpb24odiwgcCkgeyB0aGlzLm91dHB1dFByaW1pdGl2ZSh2Lm5hbWUsIHApOyB9LFxuICAgICAgICBBcnJheTogICAgIGZ1bmN0aW9uKHYsIHApIHtcbiAgICAgICAgICBmb3IgKCB2YXIgaSA9IDAgOyBpIDwgdi5sZW5ndGggOyBpKysgKSB7XG4gICAgICAgICAgICBpZiAoIGZvYW0uY29yZS5GT2JqZWN0QXJyYXkuaXNJbnN0YW5jZShwKSApIHtcbiAgICAgICAgICAgICAgLy8gb3V0cHV0IEZPYmplY3QgYXJyYXlcbiAgICAgICAgICAgICAgdGhpcy5zdGFydCgnPCcgKyB0aGlzLnByb3BlcnR5TmFtZShwKSArICc+Jyk7XG4gICAgICAgICAgICAgIHRoaXMub3V0cHV0KHAudG9YTUwodltpXSwgdGhpcykpO1xuICAgICAgICAgICAgICB0aGlzLmVuZCgnPC8nICsgdGhpcy5wcm9wZXJ0eU5hbWUocCkgKyAnPicpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgLy8gb3V0cHV0IHByaW1pdGl2ZSBhcnJheVxuICAgICAgICAgICAgICB0aGlzLm91dHB1dFByaW1pdGl2ZSh2W2ldLCBwKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gbmV3IGxpbmUgYW5kIGluZGVudCBleGNlcHQgb24gbGFzdCBlbGVtZW50XG4gICAgICAgICAgICBpZiAoIGkgIT0gdi5sZW5ndGggLSAxICkgdGhpcy5ubCgpLmluZGVudCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgRk9iamVjdDogZnVuY3Rpb24odiwgcCkge1xuICAgICAgICAgIGlmICggdi54bWxWYWx1ZSApIHtcbiAgICAgICAgICAgIC8vIGlmIHYueG1sVmFsdWUgZXhpc3RzIHRoZW4gd2UgaGF2ZSBhdHRyaWJ1dGVzXG4gICAgICAgICAgICAvLyBjaGVjayBpZiB0aGUgdmFsdWUgaXMgYW4gRk9iamVjdCBhbmQgc3RydWN0dXJlIFhNTCBhY2NvcmRpbmdseVxuICAgICAgICAgICAgaWYgKCBmb2FtLmNvcmUuRk9iamVjdC5pc0luc3RhbmNlKHYueG1sVmFsdWUpICkge1xuICAgICAgICAgICAgICB0aGlzLnN0YXJ0KCc8JyArIHRoaXMucHJvcGVydHlOYW1lKHApICsgdGhpcy5vdXRwdXRBdHRyaWJ1dGVzKHYpICsgJz4nKTtcbiAgICAgICAgICAgICAgdGhpcy5vdXRwdXQocC50b1hNTCh2LCB0aGlzKSk7XG4gICAgICAgICAgICAgIHRoaXMuZW5kKCc8LycgKyAgdGhpcy5wcm9wZXJ0eU5hbWUocCkgKyAnPicpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdGhpcy5vdXQoJzwnKS5vdXRwdXRQcm9wZXJ0eU5hbWUocCkub3V0cHV0QXR0cmlidXRlcyh2KS5vdXQoJz4nKTtcbiAgICAgICAgICAgICAgdGhpcy5vdXQocC50b1hNTCh2LnhtbFZhbHVlLCB0aGlzKSk7XG4gICAgICAgICAgICAgIHRoaXMub3V0KCc8LycpLm91dHB1dFByb3BlcnR5TmFtZShwKS5vdXQoJz4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gYXNzdW1lIG5vIGF0dHJpYnV0ZXNcbiAgICAgICAgICAgIHRoaXMuc3RhcnQoJzwnICsgdGhpcy5wcm9wZXJ0eU5hbWUocCkgKyAnPicpO1xuICAgICAgICAgICAgdGhpcy5vdXRwdXQocC50b1hNTCh2LCB0aGlzKSk7XG4gICAgICAgICAgICB0aGlzLmVuZCgnPC8nICsgIHRoaXMucHJvcGVydHlOYW1lKHApICsgJz4nKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfSxcblxuICAgIGZ1bmN0aW9uIG91dHB1dFByaW1pdGl2ZSh2LCBwKXtcbiAgICAgIHRoaXMub3V0KCc8Jykub3V0cHV0UHJvcGVydHlOYW1lKHApLm91dCgnPicpO1xuICAgICAgdGhpcy5vdXRwdXQocC50b1hNTCh2LCB0aGlzKSk7XG4gICAgICB0aGlzLm91dCgnPC8nKS5vdXRwdXRQcm9wZXJ0eU5hbWUocCkub3V0KCc+Jyk7XG4gICAgfSxcblxuICAgIGZ1bmN0aW9uIG91dHB1dERhdGUobykge1xuICAgICAgaWYgKCB0aGlzLmZvcm1hdERhdGVzQXNOdW1iZXJzICkge1xuICAgICAgICB0aGlzLm91dChvLnZhbHVlT2YoKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLm91dChvLnRvSVNPU3RyaW5nKCkpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBmdW5jdGlvbiBvdXRwdXRGdW5jdGlvbihvKSB7XG4gICAgICBpZiAoIHRoaXMuZm9ybWF0RnVuY3Rpb25zQXNTdHJpbmdzICkge1xuICAgICAgICB0aGlzLm91dHB1dChvLnRvU3RyaW5nKCkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5vdXQoby50b1N0cmluZygpKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgZnVuY3Rpb24gb3V0cHV0T2JqZWN0S2V5VmFsdWVfKGtleSwgdmFsdWUsIGZpcnN0KSB7XG4gICAgICBpZiAoICEgZmlyc3QgKSB0aGlzLm91dCgnLCcpLm5sKCkuaW5kZW50KCk7XG4gICAgICB0aGlzLm91dCh0aGlzLm1heWJlRXNjYXBlS2V5KGtleSksICc6Jykub3V0cHV0KHZhbHVlKTtcbiAgICB9LFxuXG4gICAgZnVuY3Rpb24gb3V0cHV0T2JqZWN0S2V5VmFsdWVzXyhvKSB7XG4gICAgICB2YXIgZmlyc3QgPSB0cnVlO1xuICAgICAgZm9yICggdmFyIGtleSBpbiBvICkge1xuICAgICAgICB0aGlzLm91dHB1dE9iamVjdEtleVZhbHVlXyhrZXksIG9ba2V5XSwgZmlyc3QpO1xuICAgICAgICBmaXJzdCA9IGZhbHNlO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBmdW5jdGlvbiBvdXRwdXRTb3J0ZWRPYmplY3RLZXlWYWx1ZXNfKG8pIHtcbiAgICAgIHZhciBrZXksIGtleXMgPSBbXTtcblxuICAgICAgZm9yICgga2V5IGluIG8gKSBrZXlzLnB1c2goa2V5KTtcbiAgICAgIGtleXMuc29ydCgpO1xuXG4gICAgICB2YXIgZmlyc3QgPSB0cnVlO1xuICAgICAgZm9yICggdmFyIGkgPSAwIDsgaSA8IGtleXMubGVuZ3RoOyBpKysgKSB7XG4gICAgICAgIGtleSA9IGtleXNbaV07XG4gICAgICAgIHRoaXMub3V0cHV0T2JqZWN0S2V5VmFsdWVfKGtleSwgb1trZXldLCBmaXJzdCk7XG4gICAgICAgIGZpcnN0ID0gZmFsc2U7XG4gICAgICB9XG4gICAgfSxcblxuICAgIHtcbiAgICAgIG5hbWU6ICdvdXRwdXQnLFxuICAgICAgY29kZTogZm9hbS5tbWV0aG9kKHtcbiAgICAgICAgVW5kZWZpbmVkOiAgICBmdW5jdGlvbihvKSB7IHRoaXMub3V0KCdudWxsJyk7IH0sXG4gICAgICAgIE51bGw6ICAgICAgICAgZnVuY3Rpb24obykgeyB0aGlzLm91dCgnbnVsbCcpOyB9LFxuICAgICAgICBTdHJpbmc6ICAgICAgIGZ1bmN0aW9uKG8pIHsgdGhpcy5vdXQodGhpcy5lc2NhcGUobykpOyB9LFxuICAgICAgICBOdW1iZXI6ICAgICAgIGZ1bmN0aW9uKG8pIHsgdGhpcy5vdXQobyk7IH0sXG4gICAgICAgIEJvb2xlYW46ICAgICAgZnVuY3Rpb24obykgeyB0aGlzLm91dChvKTsgfSxcbiAgICAgICAgRGF0ZTogICAgICAgICBmdW5jdGlvbihvKSB7IHRoaXMub3V0cHV0RGF0ZShvKTsgfSxcbiAgICAgICAgRnVuY3Rpb246ICAgICBmdW5jdGlvbihvKSB7IHRoaXMub3V0cHV0RnVuY3Rpb24obyk7IH0sXG4gICAgICAgIEFic3RyYWN0RW51bTogZnVuY3Rpb24obykgeyB9LFxuICAgICAgICBGT2JqZWN0OiAgICAgIGZ1bmN0aW9uKG8pIHtcbiAgICAgICAgICBpZiAoIG8ub3V0cHV0WE1MICkge1xuICAgICAgICAgICAgby5vdXRwdXRYTUwodGhpcylcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgY2xzTmFtZSA9IG8uY2xzXy5pZDtcbiAgICAgICAgICAvLyBJdGVyYXRlIHRocm91Z2ggcHJvcGVydGllcyBhbmQgb3V0cHV0XG4gICAgICAgICAgdmFyIHBzID0gby5jbHNfLmdldEF4aW9tc0J5Q2xhc3MoZm9hbS5jb3JlLlByb3BlcnR5KTtcbiAgICAgICAgICBmb3IgKCB2YXIgaSA9IDAgOyBpIDwgcHMubGVuZ3RoIDsgaSsrICkge1xuICAgICAgICAgICAgLy8gc2tpcCBvdXRwdXR0aW5nIG9mIGF0dHJpYnV0ZXNcbiAgICAgICAgICAgIGlmICggcHNbaV0ueG1sQXR0cmlidXRlICkgY29udGludWU7XG4gICAgICAgICAgICB0aGlzLm91dHB1dFByb3BlcnR5XyhvLCBwc1tpXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBBcnJheTogZnVuY3Rpb24obywgb3B0X2Nscykge1xuICAgICAgICAgIHRoaXMuc3RhcnQoJzxvYmplY3RzPlxcbicpO1xuICAgICAgICAgIHZhciBjbHMgPSB0aGlzLmdldENscyhvcHRfY2xzKTtcbiAgICAgICAgICBmb3IgKCB2YXIgaSA9IDAgOyBpIDwgby5sZW5ndGggOyBpKysgKSB7XG4gICAgICAgICAgICB0aGlzLm91dHB1dChvW2ldLCBjbHMpO1xuICAgICAgICAgICAgaWYgKCBpIDwgby5sZW5ndGgtMSApIHRoaXMub3V0KCdcXG4nKS5ubCgpLmluZGVudCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLmVuZCgnXFxuPC9vYmplY3RzPicpO1xuICAgICAgICB9LFxuICAgICAgICBPYmplY3Q6ICAgICAgICBmdW5jdGlvbihvKSB7XG4gICAgICAgICAgaWYgKCBvLm91dHB1dFhNTCApIHtcbiAgICAgICAgICAgIG8ub3V0cHV0WE1MKHRoaXMpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgb05hbWUgPSBvLm5hbWU7XG4gICAgICAgICAgICB0aGlzLnN0YXJ0KFwiPG9iamVjdCBuYW1lPSdcIiArIG9OYW1lICsgXCInPlwiKTtcbiAgICAgICAgICAgIGlmICggdGhpcy5zb3J0T2JqZWN0S2V5cyApIHtcbiAgICAgICAgICAgICAgdGhpcy5vdXRwdXRTb3J0ZWRPYmplY3RLZXlWYWx1ZXNfKG8pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdGhpcy5vdXRwdXRPYmplY3RLZXlWYWx1ZXNfKG8pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5lbmQoJzwvb2JqZWN0PicpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSlcbiAgICB9LFxuXG4gICAgZnVuY3Rpb24gc3RyaW5naWZ5KG8pIHtcbiAgICAgIC8vIFJvb3QgdGFncyBvZiBvYmplY3RzIGZvciBhcnJheSBvZiBGT2JqZWN0c1xuICAgICAgdGhpcy5vdXRwdXQobyk7XG4gICAgICB2YXIgcmV0ID0gdGhpcy5idWZfO1xuICAgICAgdGhpcy5yZXNldCgpOyAvLyByZXNldCB0byBhdm9pZCByZXRhaW5pbmcgZ2FyYmFnZVxuICAgICAgcmV0dXJuIHJldDtcbiAgICB9LFxuXG4gICAgZnVuY3Rpb24gb2JqZWN0aWZ5KGRvYywgY2xzKSB7XG4gICAgICB2YXIgb2JqID0gY2xzLmNyZWF0ZSgpO1xuICAgICAgdmFyIGNoaWxkcmVuID0gZG9jLmNoaWxkcmVuO1xuXG4gICAgICBmb3IgKCB2YXIgaSA9IDAgOyBpIDwgY2hpbGRyZW4ubGVuZ3RoIDsgaSsrICkge1xuICAgICAgICAvLyBmZXRjaCBwcm9wZXJ0eSBiYXNlZCBvbiB4bWwgdGFnIG5hbWUgc2luY2UgdGhleSBtYXkgbm90IGJlIGluIG9yZGVyXG4gICAgICAgIHZhciBub2RlID0gY2hpbGRyZW5baV07XG4gICAgICAgIHZhciBwcm9wID0gb2JqLmNsc18uZ2V0QXhpb21CeU5hbWUobm9kZS50YWdOYW1lKTtcblxuICAgICAgICBpZiAoIGZvYW0uY29yZS5GT2JqZWN0UHJvcGVydHkuaXNJbnN0YW5jZShwcm9wKSApIHtcbiAgICAgICAgICAvLyBwYXJzZSBGT2JqZWN0UHJvcGVydHlcbiAgICAgICAgICBwcm9wLnNldChvYmosIHRoaXMub2JqZWN0aWZ5KG5vZGUsIHByb3Aub2YpKTtcbiAgICAgICAgfSBlbHNlIGlmICggZm9hbS5jb3JlLkZPYmplY3RBcnJheS5pc0luc3RhbmNlKHByb3ApICkge1xuICAgICAgICAgIC8vIHBhcnNlIGFycmF5IHByb3BlcnR5XG4gICAgICAgICAgcHJvcC5nZXQob2JqKS5wdXNoKHRoaXMub2JqZWN0aWZ5KG5vZGUsIGZvYW0ubG9va3VwKHByb3Aub2YpKSk7XG5cbiAgICAgICAgfSBlbHNlIGlmICggZm9hbS5jb3JlLlN0cmluZ0FycmF5LmlzSW5zdGFuY2UocHJvcCkgKSB7XG4gICAgICAgICAgLy8gcGFyc2Ugc3RyaW5nIGFycmF5XG4gICAgICAgICAgcHJvcC5nZXQob2JqKS5wdXNoKG5vZGUuZmlyc3RDaGlsZCA/IG5vZGUuZmlyc3RDaGlsZC5ub2RlVmFsdWUgOiBudWxsKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBwYXJzZSBwcm9wZXJ0eVxuICAgICAgICAgIHByb3Auc2V0KG9iaiwgbm9kZS5maXJzdENoaWxkID8gbm9kZS5maXJzdENoaWxkLm5vZGVWYWx1ZSA6IG51bGwpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIGNoZWNrIHRvIHNlZSBpZiB4bWxWYWx1ZSBwcm9wZXJ0eSBleGlzdHNcbiAgICAgIHZhciB4bWxWYWx1ZVByb3AgPSBvYmouY2xzXy5nZXRBeGlvbUJ5TmFtZSgneG1sVmFsdWUnKTtcbiAgICAgIGlmICggeG1sVmFsdWVQcm9wICkge1xuICAgICAgICAvLyBwYXJzZSBhdHRyaWJ1dGVzIGlmIHRoZXkgZXhpc3RcbiAgICAgICAgdmFyIGF0dHJpYnV0ZXMgPSBkb2MuYXR0cmlidXRlcztcbiAgICAgICAgZm9yICggdmFyIGkgPSAwIDsgaSA8IGF0dHJpYnV0ZXMubGVuZ3RoIDsgaSsrICkge1xuICAgICAgICAgIHZhciBhdHRyaWJ1dGUgPSBhdHRyaWJ1dGVzW2ldO1xuICAgICAgICAgIHZhciBwcm9wID0gb2JqLmNsc18uZ2V0QXhpb21CeU5hbWUoYXR0cmlidXRlLm5hbWUpO1xuICAgICAgICAgIC8vIGRvbid0IG5lZWQgdG8gY2hlY2sgZm9yIHR5cGVzIGFzIGF0dHJpYnV0ZXMgYXJlIGFsd2F5cyBzaW1wbGUgdHlwZXNcbiAgICAgICAgICBwcm9wLnNldChvYmosIGF0dHJpYnV0ZS52YWx1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIGZvYW0uY29yZS5GT2JqZWN0UHJvcGVydHkuaXNJbnN0YW5jZSh4bWxWYWx1ZVByb3ApICkge1xuICAgICAgICAgIHhtbFZhbHVlUHJvcC5zZXQob2JqLCB0aGlzLm9iamVjdGlmeShkb2MsIHhtbFZhbHVlUHJvcC5vZikpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHhtbFZhbHVlUHJvcC5zZXQob2JqLCBkb2MuZmlyc3RDaGlsZCA/IGRvYy5maXJzdENoaWxkLm5vZGVWYWx1ZSA6IG51bGwpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBvYmo7XG4gICAgfSxcblxuICAgIGZ1bmN0aW9uIHBhcnNlU3RyaW5nKHN0ciwgb3B0X2NsYXNzKSB7XG4gICAgICAvLyBjcmVhdGUgRE9NXG4gICAgICB2YXIgcGFyc2VyID0gbmV3IERPTVBhcnNlcigpO1xuICAgICAgdmFyIGRvYyA9IHBhcnNlci5wYXJzZUZyb21TdHJpbmcoc3RyLCAndGV4dC94bWwnKTtcbiAgICAgIHZhciByb290ID0gZG9jLmZpcnN0Q2hpbGQ7XG5cbiAgICAgIHZhciByb290Q2xhc3MgPSByb290LmdldEF0dHJpYnV0ZSgnY2xhc3MnKTtcbiAgICAgIGlmICggcm9vdENsYXNzIClcbiAgICAgICAgcmV0dXJuIHRoaXMub2JqZWN0aWZ5KHJvb3QsIGZvYW0ubG9va3VwKHJvb3RDbGFzcykpO1xuXG4gICAgICBpZiAoIG9wdF9jbGFzcyApIHtcbiAgICAgICAgLy8gbG9va3VwIGNsYXNzIGlmIGdpdmVuIGEgc3RyaW5nXG4gICAgICAgIGlmICggdHlwZW9mKG9wdF9jbGFzcykgPT09ICdzdHJpbmcnIClcbiAgICAgICAgICBvcHRfY2xhc3MgPSBmb2FtLmxvb2t1cChvcHRfY2xhc3MpO1xuICAgICAgICByZXR1cm4gdGhpcy5vYmplY3RpZnkocm9vdCwgb3B0X2NsYXNzKTtcbiAgICAgIH1cblxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdDbGFzcyBub3QgcHJvdmlkZWQnKTtcbiAgICB9LFxuXG4gICAgZnVuY3Rpb24gZ2V0Q2xzKG9wdF9jbHMpIHtcbiAgICAgIHJldHVybiBmb2FtLlN0cmluZy5pc0luc3RhbmNlKG9wdF9jbHMpO1xuICAgIH1cbiAgXVxufSk7XG5cblxuLyoqIExpYnJhcnkgb2YgcHJlLWNvbmZpZ3VyZWQgWE1MIE91dHB1dHRlcnMuICoqL1xuZm9hbS5MSUIoe1xuICBuYW1lOiAnZm9hbS54bWwnLFxuXG4gIGNvbnN0YW50czoge1xuICAgIC8vIFByZXR0eSBQcmludFxuICAgIFByZXR0eTogZm9hbS54bWwuT3V0cHV0dGVyLmNyZWF0ZSh7XG4gICAgICBvdXRwdXREZWZhdWx0VmFsdWVzOiBmYWxzZSxcbiAgICAgIG91dHB1dERlZmluZWRWYWx1ZXM6IHRydWVcbiAgICB9KSxcblxuICAgIC8vIENvbXBhY3Qgb3V0cHV0IChub3QgcHJldHR5KVxuICAgIENvbXBhY3Q6IGZvYW0ueG1sLk91dHB1dHRlci5jcmVhdGUoe1xuICAgICAgcHJldHR5OiBmYWxzZSxcbiAgICAgIGZvcm1hdERhdGVzQXNOdW1iZXJzOiB0cnVlLFxuICAgICAgb3V0cHV0RGVmYXVsdFZhbHVlczogZmFsc2UsXG4gICAgICBvdXRwdXREZWZpbmVkVmFsdWVzOiBmYWxzZVxuICAgIH0pLFxuXG4gICAgLy8gU2hvcnRlciB0aGFuIENvbXBhY3QgKHVzZXMgc2hvcnQtbmFtZXMgaWYgYXZhaWxhYmxlKVxuICAgIFNob3J0OiBmb2FtLnhtbC5PdXRwdXR0ZXIuY3JlYXRlKHtcbiAgICAgIHByZXR0eTogZmFsc2UsXG4gICAgICBmb3JtYXREYXRlc0FzTnVtYmVyczogdHJ1ZSxcbiAgICAgIG91dHB1dERlZmF1bHRWYWx1ZXM6IGZhbHNlLFxuICAgICAgb3V0cHV0RGVmaW5lZFZhbHVlczogZmFsc2UsXG4gICAgICAvLyBUT0RPOiBObyBkZXNlcmlhbGl6YXRpb24gc3VwcG9ydCBmb3Igc2hvcnRuYW1lcyB5ZXQuXG4gICAgICAvLyAgICAgIHVzZVNob3J0TmFtZXM6IHRydWUsXG4gICAgICB1c2VTaG9ydE5hbWVzOiBmYWxzZSxcbiAgICB9KVxuICB9LFxuXG4gIG1ldGhvZHM6IFtcbiAgICBmdW5jdGlvbiBzdHJpbmdpZnkobykge1xuICAgICAgcmV0dXJuIGZvYW0ueG1sLkNvbXBhY3Quc3RyaW5naWZ5KG8pO1xuICAgIH0sXG5cbiAgICBmdW5jdGlvbiBvYmplY3RpZnkobykge1xuICAgICAgcmV0dXJuIGZvYW0ueG1sLkNvbXBhY3Qub2JqZWN0aWZ5KG8pO1xuICAgIH1cbiAgXVxufSk7XG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBUaGUgRk9BTSBBdXRob3JzLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKi9cblxuZm9hbS5DTEFTUyh7XG4gIHBhY2thZ2U6ICdmb2FtLmxpYi5jc3YnLFxuICBuYW1lOiAnT3V0cHV0dGVyJyxcblxuICBkb2N1bWVudGF0aW9uOiAnQ1NWIE91dHB1dHRlci4nLFxuXG4gIHByb3BlcnRpZXM6IFtcbiAgICB7XG4gICAgICBjbGFzczogJ1N0cmluZycsXG4gICAgICBuYW1lOiAnYnVmXycsXG4gICAgICB2YWx1ZTogJydcbiAgICB9LFxuICAgIHtcbiAgICAgIGNsYXNzOiAnU3RyaW5nJyxcbiAgICAgIG5hbWU6ICdkZWxpbWl0ZXInLFxuICAgICAgdmFsdWU6ICcsJ1xuICAgIH0sXG4gICAge1xuICAgICAgY2xhc3M6ICdTdHJpbmcnLFxuICAgICAgbmFtZTogJ25lc3RlZE9iamVjdFNlcGVyYXRvcicsXG4gICAgICB2YWx1ZTogJ19fJ1xuICAgIH0sXG4gICAge1xuICAgICAgY2xhc3M6ICdTdHJpbmcnLFxuICAgICAgbmFtZTogJ25sU3RyJyxcbiAgICAgIHZhbHVlOiAnXFxuJ1xuICAgIH0sXG4gICAge1xuICAgICAgY2xhc3M6ICdTdHJpbmcnLFxuICAgICAgbmFtZTogJ3VuZGVmaW5lZFN0cicsXG4gICAgICB2YWx1ZTogJydcbiAgICB9LFxuICAgIHtcbiAgICAgIGNsYXNzOiAnQm9vbGVhbicsXG4gICAgICBuYW1lOiAnb3V0cHV0SGVhZGVyUm93JyxcbiAgICAgIHZhbHVlOiB0cnVlXG4gICAgfSxcbiAgICB7XG4gICAgICBjbGFzczogJ0Z1bmN0aW9uJyxcbiAgICAgIG5hbWU6ICdwcm9wZXJ0eVByZWRpY2F0ZScsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24obywgcCkgeyByZXR1cm4gISBwLnRyYW5zaWVudDsgfVxuICAgIH1cbiAgXSxcblxuICBtZXRob2RzOiBbXG4gICAgZnVuY3Rpb24gb3V0KCkge1xuICAgICAgZm9yICggdmFyIGkgPSAwIDsgaSA8IGFyZ3VtZW50cy5sZW5ndGggOyBpKysgKSB0aGlzLmJ1Zl8gKz0gYXJndW1lbnRzW2ldO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIGZ1bmN0aW9uIHRvQ1NWKG8pIHtcbiAgICAgIC8vIFJlc2V0cyBidWZmZXJcbiAgICAgIHRoaXMucmVzZXQoKTtcblxuICAgICAgLy8gT3V0cHV0cyBvYmplY3QgaGVhZGVyc1xuICAgICAgdGhpcy5vdXRwdXRIZWFkZXIobyk7XG5cbiAgICAgIC8vIE91dHB1dHMgb2JqZWN0IHZhbHVlc1xuICAgICAgdGhpcy5vdXRwdXQobywgdHJ1ZSk7XG4gICAgICB0aGlzLm91dCh0aGlzLm5sU3RyKTtcblxuICAgICAgcmV0dXJuIHRoaXMuYnVmXztcbiAgICB9LFxuXG4gICAgZnVuY3Rpb24gb3V0cHV0SGVhZGVyKG8pIHtcbiAgICAgIGlmICggISB0aGlzLm91dHB1dEhlYWRlclJvdyApIHJldHVybjtcblxuICAgICAgdGhpcy5vdXRwdXRQcm9wZXJ0eU5hbWUobywgJycsIHRydWUpO1xuICAgICAgdGhpcy5vdXQodGhpcy5ubFN0cik7XG4gICAgfSxcblxuICAgIGZ1bmN0aW9uIG91dHB1dEhlYWRlclRpdGxlKG8sIHByZWZpeCwgZmlyc3QpIHtcbiAgICAgIHRoaXMub3V0KGZpcnN0ID8gJycgOiB0aGlzLmRlbGltaXRlcilcbiAgICAgICAgICAub3V0KHRoaXMuZXNjYXBlU3RyaW5nKHByZWZpeCArIHRoaXMuc2FuaXRpemVIZWFkZXJUaXRsZShvKSkpO1xuICAgIH0sXG5cbiAgICBmdW5jdGlvbiBvdXRwdXRQcm9wZXJ0eU5hbWVfKG8sIHAsIHByZWZpeCwgZmlyc3QpIHtcbiAgICAgIGlmICggISB0aGlzLnByb3BlcnR5UHJlZGljYXRlKG8sIHApICkgcmV0dXJuO1xuXG4gICAgICBpZiAoIGZvYW0uY29yZS5GT2JqZWN0UHJvcGVydHkuaXNJbnN0YW5jZShwKSApIHtcbiAgICAgICAgLy8gR2V0cyBuZXcgZW1wdHkgb2JqZWN0IGlmIEZPYmplY3RQcm9wZXJ0eSBpcyBjdXJyZW50bHkgdW5kZWZpbmVkXG4gICAgICAgIC8vIERvbmUgdG8gcGVybWl0IGFwcHJvcHJpYXRlIGhlYWRlcnMgZm9yIG11bHRpLWxpbmUgQ1NWcyAobXVsdGlwbGUgb2JqZWN0cyB0byBjb252ZXJ0KVxuICAgICAgICBpZiAoIG9bcC5uYW1lXSA9PSB1bmRlZmluZWQgKSBvW3AubmFtZV0gPSBwLm9mLmlkO1xuXG4gICAgICAgIC8vIEFwcGVuZHMgb2JqZWN0IG5hbWUgdG8gcHJlZml4IGZvciBDU1YgSGVhZGVyXG4gICAgICAgIHByZWZpeCArPSB0aGlzLnNhbml0aXplSGVhZGVyVGl0bGUocC5uYW1lKSArIHRoaXMubmVzdGVkT2JqZWN0U2VwZXJhdG9yO1xuICAgICAgICB0aGlzLm91dHB1dFByb3BlcnR5TmFtZShvW3AubmFtZV0sIHByZWZpeCwgZmlyc3QpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5vdXRwdXRQcm9wZXJ0eU5hbWUocC5uYW1lLCBwcmVmaXgsIGZpcnN0KTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgZnVuY3Rpb24gc2FuaXRpemVIZWFkZXJUaXRsZSh0KSB7XG4gICAgICAvLyBTYW5pdGl6ZXMgaGVhZGVyIHRpdGxlIGJ5IHJlcGxhY2luZyB0aGUgbmVzdGVkIG9iamVjdCBzZXBlcmF0b3IsIGJ5IGl0c2VsZiB4IDJcbiAgICAgIHJldHVybiB0aGlzLnJlcGxhY2VBbGwodCwgdGhpcy5uZXN0ZWRPYmplY3RTZXBlcmF0b3IsIFxuICAgICAgICAgICAgICAgICAgICB0aGlzLm5lc3RlZE9iamVjdFNlcGVyYXRvciArIHRoaXMubmVzdGVkT2JqZWN0U2VwZXJhdG9yKTtcbiAgICB9LFxuXG4gICAge1xuICAgICAgbmFtZTogJ291dHB1dFByb3BlcnR5TmFtZScsXG4gICAgICBjb2RlOiBmb2FtLm1tZXRob2Qoe1xuICAgICAgICBGT2JqZWN0OiAgIGZ1bmN0aW9uKG8sIHByZWZpeCwgZmlyc3QpIHtcbiAgICAgICAgICAvLyBHZXQgYW5kIHJlY3Vyc2UgdGhyb3VnaCBvYmplY3QgcHJvcGVydGllc1xuICAgICAgICAgIHZhciBwcyA9IG8uY2xzXy5nZXRBeGlvbXNCeUNsYXNzKGZvYW0uY29yZS5Qcm9wZXJ0eSk7XG5cbiAgICAgICAgICBmb3IgKCB2YXIgaSA9IDAgOyBpIDwgcHMubGVuZ3RoIDsgaSsrICkge1xuICAgICAgICAgICAgdGhpcy5vdXRwdXRQcm9wZXJ0eU5hbWVfKG8sIHBzW2ldLCBwcmVmaXgsIChpID09IDAgJiYgZmlyc3QpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIEFycmF5OiBmdW5jdGlvbihvLCBwcmVmaXgsIGZpcnN0KSB7XG4gICAgICAgICAgaWYgKCAhIG8gfHwgby5sZW5ndGggPT09IDAgKSByZXR1cm47XG5cbiAgICAgICAgICAvLyBHZXQgYW5kIHJlY3Vyc2UgdGhyb3VnaCBvYmplY3QgcHJvcGVydGllc1xuICAgICAgICAgIHZhciBwcyA9IG9bMF0uY2xzXy5nZXRBeGlvbXNCeUNsYXNzKGZvYW0uY29yZS5Qcm9wZXJ0eSk7XG5cbiAgICAgICAgICBmb3IgKCB2YXIgaSA9IDAgOyBpIDwgcHMubGVuZ3RoIDsgaSsrICkge1xuICAgICAgICAgICAgdGhpcy5vdXRwdXRQcm9wZXJ0eU5hbWVfKG8sIHBzW2ldLCBwcmVmaXgsIChpID09IDAgJiYgZmlyc3QpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIEZ1bmN0aW9uOiBmdW5jdGlvbihvKSB7IC8qIElnbm9yZSBmdW5jdGlvbnMgaW4gQ1NWICovIH0sXG4gICAgICAgIE9iamVjdDogZnVuY3Rpb24obykgeyAvKiBJZ25vcmUgZ2VuZXJpYyBvYmplY3RzIGluIENTViAqLyB9XG4gICAgICB9LCBmdW5jdGlvbihvLCBwcmVmaXgsIGZpcnN0KSB7IHRoaXMub3V0cHV0SGVhZGVyVGl0bGUobywgcHJlZml4LCBmaXJzdCk7IH0pXG4gICAgfSxcblxuICAgIGZ1bmN0aW9uIG91dHB1dFByb3BlcnR5KG8sIHAsIGZpcnN0KSB7XG4gICAgICBpZiAoIHRoaXMucHJvcGVydHlQcmVkaWNhdGUobywgcCkgKSB0aGlzLm91dHB1dChvW3AubmFtZV0sIGZpcnN0KTtcbiAgICB9LFxuXG4gICAgZnVuY3Rpb24gcmVzZXQoKSB7XG4gICAgICB0aGlzLmJ1Zl8gPSAnJztcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBmdW5jdGlvbiBvdXRwdXRQcmltaXRpdmUodmFsLCBmaXJzdCkge1xuICAgICAgdGhpcy5vdXQoZmlyc3QgPyAnJyA6IHRoaXMuZGVsaW1pdGVyLCB2YWwpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIGZ1bmN0aW9uIGVzY2FwZVN0cmluZyhzb3VyY2UpIHtcbiAgICAgIGlmICggc291cmNlLmluY2x1ZGVzKCcsJykgKSB7XG4gICAgICAgIC8vIFN1cnJvdW5kcyBmaWVsZHMgd2l0aCAnLCcgaW4gcXVvdGVzXG4gICAgICAgIC8vIEVzY2FwZXMgaW5uZXIgcXVvdGVzIGJ5IGFkZGluZyBhbm90aGVyIHF1b3RlIGNoYXIgKEdvb2dsZSBTaGVldHMgc3RyYXRlZ3kpXG4gICAgICAgIHNvdXJjZSA9ICdcIicgKyB0aGlzLnJlcGxhY2VBbGwoc291cmNlLCAnXCInLCAnXCJcIicpICsgJ1wiJztcbiAgICAgIH1cbiAgICAgIFxuICAgICAgcmV0dXJuIHNvdXJjZTtcbiAgICB9LFxuXG4gICAge1xuICAgICAgbmFtZTogJ291dHB1dCcsXG4gICAgICBjb2RlOiBmb2FtLm1tZXRob2Qoe1xuICAgICAgICBVbmRlZmluZWQ6ICAgIGZ1bmN0aW9uKG8sIGZpcnN0KSB7IHRoaXMub3V0cHV0UHJpbWl0aXZlKHRoaXMudW5kZWZpbmVkU3RyLCBmaXJzdCk7IH0sXG4gICAgICAgIFN0cmluZzogICAgICAgZnVuY3Rpb24obywgZmlyc3QpIHsgdGhpcy5vdXRwdXRQcmltaXRpdmUodGhpcy5lc2NhcGVTdHJpbmcobyksIGZpcnN0KTsgfSxcbiAgICAgICAgQWJzdHJhY3RFbnVtOiBmdW5jdGlvbihvLCBmaXJzdCkgeyB0aGlzLm91dHB1dFByaW1pdGl2ZShvLm9yZGluYWwsIGZpcnN0KTsgfSxcbiAgICAgICAgRk9iamVjdDogICBmdW5jdGlvbihvLCBmaXJzdCkge1xuICAgICAgICAgIGlmICggby5vdXRwdXRDU1YgKSB7XG4gICAgICAgICAgICBvLm91dHB1dENTVih0aGlzKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBcbiAgICAgICAgICB2YXIgcHMgPSBvLmNsc18uZ2V0QXhpb21zQnlDbGFzcyhmb2FtLmNvcmUuUHJvcGVydHkpO1xuXG4gICAgICAgICAgZm9yICggdmFyIGkgPSAwIDsgaSA8IHBzLmxlbmd0aCA7IGkrKyApIHtcbiAgICAgICAgICAgIHRoaXMub3V0cHV0UHJvcGVydHkobywgcHNbaV0sIChpID09IDAgJiYgZmlyc3QpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIEFycmF5OiAgZnVuY3Rpb24obywgb3B0X2NscykgeyBcbiAgICAgICAgICB2YXIgY2xzID0gdGhpcy5nZXRDbHMob3B0X2Nscyk7XG4gICAgICAgICAgZm9yICggdmFyIGkgPSAwIDsgaSA8IG8ubGVuZ3RoIDsgaSsrICkge1xuICAgICAgICAgICAgdGhpcy5vdXRwdXQob1tpXSwgY2xzKTtcbiAgICAgICAgICAgIGlmICggaSA8IG8ubGVuZ3RoLTEgKSB0aGlzLm91dCgnXFxuJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBGdW5jdGlvbjogICAgIGZ1bmN0aW9uKG8pIHsgLyogSWdub3JlIGZ1bmN0aW9ucyBpbiBDU1YgKi8gfSxcbiAgICAgICAgT2JqZWN0OiAgICAgICBmdW5jdGlvbihvKSB7IC8qIElnbm9yZSBnZW5lcmljIG9iamVjdHMgaW4gQ1NWICovIH1cbiAgICAgIH0sIGZ1bmN0aW9uKG8sIGZpcnN0KSB7IHRoaXMub3V0cHV0UHJpbWl0aXZlKG8sIGZpcnN0KTsgfSlcbiAgICB9LFxuXG4gICAgZnVuY3Rpb24gZnJvbUNTVihjbHMsIHMsIHNpbmspIHtcbiAgICAgIGlmICggISBzICkgdGhyb3cgJ0ludmFsaWQgQ1NWIGlucHV0IHRvIGNvbnZlcnQuIEFyZ3VtZW50cyBtdXN0IGJlIChjbGFzcywgY3N2U3RyaW5nKS4nXG4gICAgICB2YXIgbGluZXMgPSBzLnNwbGl0KCdcXG4nKTtcblxuICAgICAgaWYgKCBsaW5lcy5sZW5ndGggPT0gMCApIHRocm93ICdJbnN1ZmZpY2llbnQgQ1NWIElucHV0JztcblxuICAgICAgLy8gVHJpbXMgcXVvdGVzIGFuZCBzcGxpdHMgQ1NWIHJvdyBpbnRvIGFycmF5XG4gICAgICB2YXIgcHJvcHMgPSB0aGlzLnNwbGl0SW50b1ZhbHVlcyhsaW5lc1swXSkubWFwKHRoaXMuc3BsaXRIZWFkZXJUaXRsZS5iaW5kKHRoaXMpKTtcblxuICAgICAgZm9yICggdmFyIGkgPSAxIDsgaSA8IGxpbmVzLmxlbmd0aCA7IGkrKyApIHtcbiAgICAgICAgdmFyIHZhbHVlcyA9IHRoaXMuc3BsaXRJbnRvVmFsdWVzKGxpbmVzW2ldKTtcblxuICAgICAgICAvLyBTa2lwcyBibGFuayBsaW5lc1xuICAgICAgICBpZiAoIHZhbHVlcy5sZW5ndGggPT0gMCApIGNvbnRpbnVlO1xuXG4gICAgICAgIC8vIENhbGxzIGZvciBjcmVhdGlvbiBvZiBuZXcgbW9kZWwsIGFuZCBgcHV0c2AgaW50byBzaW5rXG4gICAgICAgIHNpbmsucHV0KHRoaXMuY3JlYXRlTW9kZWwocHJvcHMsIHZhbHVlcywgY2xzKSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzaW5rO1xuICAgIH0sXG5cbiAgICBmdW5jdGlvbiB2YWxpZFN0cmluZyhzKSB7XG4gICAgICByZXR1cm4gKCBzICE9IHVuZGVmaW5lZCApICYmICggcy5sZW5ndGggPiAwKTtcbiAgICB9LFxuXG4gICAgZnVuY3Rpb24gc3BsaXRJbnRvVmFsdWVzKGNzdlN0cmluZykge1xuICAgICAgaWYgKCAhIHRoaXMudmFsaWRTdHJpbmcoY3N2U3RyaW5nKSApIHJldHVybiBbXTtcblxuICAgICAgdmFyIHBhcnNlciA9IGZvYW0ubGliLmNzdi5DU1ZQYXJzZXIuY3JlYXRlKCk7XG4gICAgICByZXR1cm4gcGFyc2VyLnBhcnNlU3RyaW5nKGNzdlN0cmluZywgdGhpcy5kZWxpbWl0ZXIpLm1hcChmaWVsZCA9PiBmaWVsZC52YWx1ZSA9PSB1bmRlZmluZWQgPyAnJyA6IGZpZWxkLnZhbHVlKTtcbiAgICB9LFxuXG4gICAgZnVuY3Rpb24gc3BsaXRIZWFkZXJUaXRsZShwKSB7XG4gICAgICBpZiAoICEgdGhpcy52YWxpZFN0cmluZyhwKSApIHJldHVybiBbXTtcblxuICAgICAgdmFyIHBhcnNlciA9IGZvYW0ubGliLmNzdi5DU1ZQYXJzZXIuY3JlYXRlKCk7XG4gICAgICByZXR1cm4gcGFyc2VyLnBhcnNlSGVhZGVyKHAsIHRoaXMubmVzdGVkT2JqZWN0U2VwZXJhdG9yKS5tYXAoZmllbGQgPT4gZmllbGQudmFsdWUgPT0gdW5kZWZpbmVkID8gJycgOiBmaWVsZC52YWx1ZSk7XG4gICAgfSxcblxuICAgIC8vIFBlcmhhcHMgbW92ZSB0aGlzIHRvIGZvYW0uY29yZS5zdHJpbmdcbiAgICBmdW5jdGlvbiByZXBsYWNlQWxsKHRleHQsIHNlYXJjaCwgcmVwbGFjZW1lbnQpIHtcbiAgICAgIHJldHVybiB0ZXh0LnJlcGxhY2UobmV3IFJlZ0V4cChzZWFyY2gsICdnJyksIHJlcGxhY2VtZW50KTtcbiAgICB9LFxuXG4gICAgZnVuY3Rpb24gY3JlYXRlTW9kZWwocHJvcHMsIHZhbHVlcywgY2xzKSB7XG4gICAgICBmb2FtLmFzc2VydChwcm9wcy5sZW5ndGggPT0gdmFsdWVzLmxlbmd0aCxcbiAgICAgICAgJ0ludmFsaWQgQ1NWIElucHV0LCBoZWFkZXIgYW5kIHZhbHVlIHJvd3MgbXVzdCBiZSB0aGUgc2FtZSBudW1iZXIgb2YgY2VsbHMnKTtcblxuICAgICAgdmFyIG1vZGVsID0gY2xzLmNyZWF0ZSgpO1xuXG4gICAgICBmb3IgKCB2YXIgaSA9IDAgOyBpIDwgcHJvcHMubGVuZ3RoIDsgaSsrICkge1xuICAgICAgICB2YXIgcCA9IHByb3BzW2ldO1xuICAgICAgICB2YXIgdiA9IHZhbHVlc1tpXTtcblxuICAgICAgICAvLyBBZGRzIG5lc3RlZCBwcm9wXG4gICAgICAgIGlmICggcC5sZW5ndGggPiAxICkge1xuICAgICAgICAgIHZhciBwcmVmaXggPSBwWzBdO1xuXG4gICAgICAgICAgZm9yICggdmFyIGogPSBpIDsgaiA8PSBwcm9wcy5sZW5ndGggOyArK2ogKSB7XG4gICAgICAgICAgICAvLyBJZiBsYXN0IGVsZW1lbnQsIG9yIHByZWZpeCBubyBsb25nZXIgbWF0Y2hlcyBwcm9wXG4gICAgICAgICAgICBpZiAoICggaiA9PSBwcm9wcy5sZW5ndGggKSB8fCAoIHByb3BzW2pdWzBdICE9IHByZWZpeCApICkge1xuICAgICAgICAgICAgICAvLyBDcmVhdGVzIGEgbmV3IG1vZGVsIGZvciB0aGUgaW5uZXIgb2JqZWN0XG4gICAgICAgICAgICAgIHZhciBwcm9wID0gbW9kZWwuY2xzXy5nZXRBeGlvbUJ5TmFtZShwWzBdKTtcbiAgICAgICAgICAgICAgcHJvcC5zZXQobW9kZWwsIHRoaXMuY3JlYXRlTW9kZWwocHJvcHMuc2xpY2UoaSwgaikubWFwKG5lc3RlZFByb3AgPT4gbmVzdGVkUHJvcC5zbGljZSgxKSksIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWVzLnNsaWNlKGksIGopLCBwcm9wLm9mKSk7XG4gICAgICAgICAgICAgIFxuICAgICAgICAgICAgICBpID0gaiAtIDE7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgLy8gQWRkcyByZWd1bGFyIHByb3BcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgcHJvcCA9IG1vZGVsLmNsc18uZ2V0QXhpb21CeU5hbWUocFswXSk7XG4gICAgICAgICAgcHJvcC5zZXQobW9kZWwsIHByb3Aub2YgPyBwcm9wLm9mLmNyZWF0ZSh7IG9yZGluYWw6IHYgfSkgOiB2KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gbW9kZWw7XG4gICAgfSxcblxuICAgIGZ1bmN0aW9uIGdldENscyhvcHRfY2xzKSB7XG4gICAgICByZXR1cm4gZm9hbS5TdHJpbmcuaXNJbnN0YW5jZShvcHRfY2xzKTtcbiAgICB9XG4gIF1cbn0pO1xuXG5mb2FtLkxJQih7XG4gIG5hbWU6ICdmb2FtLmxpYi5jc3YnLFxuXG4gIGNvbnN0YW50czoge1xuICAgIFN0YW5kYXJkOiBmb2FtLmxpYi5jc3YuT3V0cHV0dGVyLmNyZWF0ZSgpLFxuICB9LFxuXG4gIG1ldGhvZHM6IFtcbiAgICBmdW5jdGlvbiB0b0NTVihvKSB7XG4gICAgICByZXR1cm4gZm9hbS5saWIuY3N2LlN0YW5kYXJkLnRvQ1NWKG8pO1xuICAgIH0sXG5cbiAgICBmdW5jdGlvbiBmcm9tQ1NWKGNscywgY3N2U3RyaW5nLCBzaW5rKSB7XG4gICAgICByZXR1cm4gZm9hbS5saWIuY3N2LlN0YW5kYXJkLmZyb21DU1YoY2xzLCBjc3ZTdHJpbmcsIHNpbmspO1xuICAgIH1cbiAgXVxufSk7XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IFRoZSBGT0FNIEF1dGhvcnMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqL1xuXG5mb2FtLkNMQVNTKHtcbiAgcGFja2FnZTogJ2ZvYW0ubGliLmNzdicsXG4gIG5hbWU6ICdDU1ZQYXJzZXInLFxuICBcbiAgcmVxdWlyZXM6IFtcbiAgICAnZm9hbS5wYXJzZS5JbXBlcmF0aXZlR3JhbW1hcidcbiAgXSxcblxuICBwcm9wZXJ0aWVzOiBbXG4gICAge1xuICAgICAgY2xhc3M6ICdTdHJpbmcnLFxuICAgICAgbmFtZTogJ2RlbGltaXRlcidcbiAgICB9LFxuICAgIHtcbiAgICAgIGNsYXNzOiAnU3RyaW5nJyxcbiAgICAgIG5hbWU6ICduZXN0ZWRPYmplY3RTZXBlcmF0b3InXG4gICAgfSxcbiAgICB7XG4gICAgICBuYW1lOiAnc3RyaW5nUGFyc2VyJyxcbiAgICAgIGZhY3Rvcnk6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgWCA9IHRoaXMuWDtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICBcbiAgICAgICAgcmV0dXJuIHRoaXMuSW1wZXJhdGl2ZUdyYW1tYXIuY3JlYXRlKHsgXG4gICAgICAgICAgc3ltYm9sczogZnVuY3Rpb24oYWx0LCBhbnlDaGFyLCBsaXRlcmFsLCBsaXRlcmFsSUMsIG5vdCwgbm90Q2hhcnMsIG9wdGlvbmFsLFxuICAgICAgICAgIHBsdXMsIHJhbmdlLCByZXBlYXQsIHJlcGVhdDAsIHNlcSwgc2VxMSwgc3RyLCBzeW0pIHtcbiAgICAgICAgICAgIHJldHVybiB7XG5cbiAgICAgICAgICAgICAgU1RBUlQ6IHNlcTEoMSwgc3ltKCd3cycpLCByZXBlYXQoc3ltKCdmaWVsZCcpLCBsaXRlcmFsKHNlbGYuZGVsaW1pdGVyKSksIHN5bSgnd3MnKSksXG5cbiAgICAgICAgICAgICAgZmllbGQ6IGFsdChzeW0oJ3F1b3RlZFRleHQnKSwgc3ltKCd1bnF1b3RlZFRleHQnKSwgJycpLFxuXG4gICAgICAgICAgICAgIHVucXVvdGVkVGV4dDogcmVwZWF0KG5vdChsaXRlcmFsKHNlbGYuZGVsaW1pdGVyKSwgYW55Q2hhcigpKSwgJycsIDEpLFxuXG4gICAgICAgICAgICAgIHF1b3RlZFRleHQ6IHNlcTEoMSwgJ1wiJywgcmVwZWF0KGFsdChzeW0oJ2VzY2FwZWRRdW90ZScpLCBub3QoJ1wiJywgYW55Q2hhcigpKSkpLCAnXCInKSxcblxuICAgICAgICAgICAgICBlc2NhcGVkUXVvdGU6ICdcIlwiJyxcblxuICAgICAgICAgICAgICB3aGl0ZTogYWx0KCcgJywgJ1xcdCcsICdcXHInLCAnXFxuJyksXG5cbiAgICAgICAgICAgICAgLy8gMCBvciBtb3JlIHdoaXRlc3BhY2UgY2hhcmFjdGVycy5cbiAgICAgICAgICAgICAgd3M6IHJlcGVhdDAoc3ltKCd3aGl0ZScpKVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSkuYWRkQWN0aW9ucyh7XG4gICAgICAgICAgdW5xdW90ZWRUZXh0OiBmdW5jdGlvbihhKSB7XG4gICAgICAgICAgICByZXR1cm4geyBub2RlOiAndW5xdW90ZWRUZXh0JywgdmFsdWU6IGEuam9pbignJykgfTtcbiAgICAgICAgICB9LFxuXG4gICAgICAgICAgcXVvdGVkVGV4dDogZnVuY3Rpb24oYSkge1xuICAgICAgICAgICAgcmV0dXJuIHsgbm9kZTogJ3F1b3RlZFRleHQnLCB2YWx1ZTogYS5qb2luKCcnKSB9O1xuICAgICAgICAgIH0sXG5cbiAgICAgICAgICBlc2NhcGVkUXVvdGU6IGZ1bmN0aW9uKCkgeyByZXR1cm4gJ1wiJzsgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHtcbiAgICAgIG5hbWU6ICdoZWFkZXJQYXJzZXInLFxuICAgICAgZmFjdG9yeTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBYID0gdGhpcy5YO1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIFxuICAgICAgICByZXR1cm4gdGhpcy5JbXBlcmF0aXZlR3JhbW1hci5jcmVhdGUoeyBcbiAgICAgICAgICBzeW1ib2xzOiBmdW5jdGlvbihhbHQsIGFueUNoYXIsIGxpdGVyYWwsIGxpdGVyYWxJQywgbm90LCBub3RDaGFycywgb3B0aW9uYWwsXG4gICAgICAgICAgcGx1cywgcmFuZ2UsIHJlcGVhdCwgcmVwZWF0MCwgc2VxLCBzZXExLCBzdHIsIHN5bSkge1xuICAgICAgICAgICAgcmV0dXJuIHtcblxuICAgICAgICAgICAgICBTVEFSVDogc2VxMSgxLCBzeW0oJ3dzJyksIHJlcGVhdChzeW0oJ2ZpZWxkJyksIGxpdGVyYWwoc2VsZi5uZXN0ZWRPYmplY3RTZXBlcmF0b3IpKSwgc3ltKCd3cycpKSxcblxuICAgICAgICAgICAgICBmaWVsZDogYWx0KHN5bSgndGV4dCcpLCAnJyksXG5cbiAgICAgICAgICAgICAgdGV4dDogcmVwZWF0KGFsdChzeW0oJ2VzY2FwZWRTZXBlcmF0b3InKSwgbm90KHNlbGYubmVzdGVkT2JqZWN0U2VwZXJhdG9yLCBhbnlDaGFyKCkpKSwgJycsIDEpLFxuXG4gICAgICAgICAgICAgIGVzY2FwZWRTZXBlcmF0b3I6IGxpdGVyYWwoc2VsZi5uZXN0ZWRPYmplY3RTZXBlcmF0b3IgKyBzZWxmLm5lc3RlZE9iamVjdFNlcGVyYXRvciksXG5cbiAgICAgICAgICAgICAgd2hpdGU6IGFsdCgnICcsICdcXHQnLCAnXFxyJywgJ1xcbicpLFxuXG4gICAgICAgICAgICAgIC8vIDAgb3IgbW9yZSB3aGl0ZXNwYWNlIGNoYXJhY3RlcnMuXG4gICAgICAgICAgICAgIHdzOiByZXBlYXQwKHN5bSgnd2hpdGUnKSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0pLmFkZEFjdGlvbnMoe1xuICAgICAgICAgIHRleHQ6IGZ1bmN0aW9uKGEpIHtcbiAgICAgICAgICAgIHJldHVybiB7IG5vZGU6ICd0ZXh0JywgdmFsdWU6IHNlbGYucmVjb3ZlckhlYWRlclRpdGxlKGEuam9pbignJykpIH07XG4gICAgICAgICAgfSxcblxuICAgICAgICAgIGVzY2FwZWRRdW90ZTogZnVuY3Rpb24oKSB7IHJldHVybiAnXCInOyB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgXSxcblxuICBtZXRob2RzOiBbXG4gICAgZnVuY3Rpb24gcGFyc2VTdHJpbmcoc3RyLCBkZWxpbWl0ZXIpIHtcbiAgICAgIHRoaXMuZGVsaW1pdGVyID0gZGVsaW1pdGVyO1xuICAgICAgcmV0dXJuIHRoaXMuc3RyaW5nUGFyc2VyLnBhcnNlU3RyaW5nKHN0cik7XG4gICAgfSxcbiAgICBcbiAgICBmdW5jdGlvbiBwYXJzZUhlYWRlcihzdHIsIG5lc3RlZE9iamVjdFNlcGVyYXRvcikge1xuICAgICAgdGhpcy5uZXN0ZWRPYmplY3RTZXBlcmF0b3IgPSBuZXN0ZWRPYmplY3RTZXBlcmF0b3I7XG4gICAgICByZXR1cm4gdGhpcy5oZWFkZXJQYXJzZXIucGFyc2VTdHJpbmcoc3RyKTtcbiAgICB9LFxuXG4gICAgZnVuY3Rpb24gcmVjb3ZlckhlYWRlclRpdGxlKHQpIHtcbiAgICAgIC8vIFJlY292ZXJzIGhlYWRlciB0aXRsZSBieSByZXBsYWNpbmcgdGhlIG5lc3RlZCBvYmplY3Qgc2VwZXJhdG9yIHggMiwgYnkgaXRzZWxmXG4gICAgICByZXR1cm4gdC5yZXBsYWNlKG5ldyBSZWdFeHAodGhpcy5uZXN0ZWRPYmplY3RTZXBlcmF0b3IgKyB0aGlzLm5lc3RlZE9iamVjdFNlcGVyYXRvciwgJ2cnKSwgXG4gICAgICAgICAgICAgICAgdGhpcy5uZXN0ZWRPYmplY3RTZXBlcmF0b3IpO1xuICAgIH1cbiAgXVxufSk7XG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG4vKipcbiAgUGFyc2UgY29tYmluYXRvciBsaWJyYXJ5LlxuXG4gIENyZWF0ZSBjb21wbGV4IHBhcnNlcnMgYnkgY29tcG9zaW5nIHNpbXBsZSBwYXJzZXJzLnNcblxuICBBIFBTdHJlYW0gaXMgYSBcIlBhcnNlciBTdHJlYW1cIiwgdGhlIGlucHV0IGZvcm1hdCBhY2NlcHRlZCBieVxuICBGT0FNIHBhcnNlcnMuXG5cbiAgUFN0cmVhbXMgaGF2ZSB0aGUgZm9sbG93aW5nIGludGVyZmFjZTpcbiAgICBnZXQgaW50ICAgICBwb3MgICAtIFRoZSBjaGFyYWN0ZXIgcG9zaXRpb24gaW4gdGhlIGlucHV0IHN0cmVhbS5cblxuICAgIGdldCBDaGFyICAgIGhlYWQgIC0gVGhlIGZpcnN0IGNoYXJhY3RlciBpbiB0aGUgc3RyZWFtLlxuXG4gICAgZ2V0IFBTdHJlYW0gdGFpbCAgLSBBIFBTdHJlYW0gZm9yIHRoZSBuZXh0IHBvc2l0aW9uIGluIHRoZSBpbnB1dCBzdGVhbS5cblxuICAgIGdldCBPYmplY3QgIHZhbHVlIC0gJ1ZhbHVlJyBhc3NvY2lhdGVkIHdpdGggdGhpcyBQU3RyZWFtLlxuXG4gICAgUFN0cmVhbSBzZXRWYWx1ZShPYmplY3QgdmFsdWUpIC0gQ3JlYXRlIGEgbmV3IFBTdHJlYW0gYXQgdGhlIHNhbWUgcG9zaXRpb25cbiAgICAgICAgYnV0IHdpdGggYSBuZXcgJ3ZhbHVlJy4gVGhlIHZhbHVlIGlzIHVzZWQgdG8gaG9sZCB0aGUgcmVzdWx0IG9mIGFcbiAgICAgICAgKHN1Yi0pcGFyc2UuXG5cbiAgUFN0cmVhbXMgYXJlIGltbXV0YWJsZSwgd2hpY2ggZ3JlYXRseSBzaW1wbGlmaWVzIGJhY2t0cmFja2luZy5cblxuICBBIHBhcnNlciBoYXMgdGhlIGZvbGxvd2luZyBpbnRlcmZhY2U6XG4gICAgUFN0cmVhbSBwYXJzZShQU3RyZWFtIHN0cmVhbSk7XG5cbiAgSXQgdGFrZXMgYXMgaW5wdXQgYSBQU3RyZWFtLCBhbmQgcmV0dXJucyBlaXRoZXIgYSBQU3RyZWFtXG4gIGFkdmFuY2VkIHRvIHRoZSBwb2ludCBhZnRlciBhbGwgaW5wdXQgY29uc3VtZWQgYnkgdGhlIHBhcnNlcixcbiAgb3IgdW5kZWZpbmVkIGlmIHRoZSBwYXJzZSBmYWlsZWQuIFRoZSB2YWx1ZSBnZW5lcmF0ZWQgYnkgdGhlIHBhcnNlclxuICBpcyBzdG9yZWQgaW4gdGhlIC52YWx1ZSBwcm9wZXJ0eSBvZiB0aGUgcmV0dXJuZWQgUFN0cmVhbS5cbiAqL1xuZm9hbS5DTEFTUyh7XG4gIHBhY2thZ2U6ICdmb2FtLnBhcnNlJyxcbiAgbmFtZTogJ1N0cmluZ1BTdHJlYW0nLFxuXG4gIHByb3BlcnRpZXM6IFtcbiAgICB7XG4gICAgICBuYW1lOiAnc3RyJyxcbiAgICAgIGNsYXNzOiAnU2ltcGxlJ1xuICAgIH0sXG4gICAge1xuICAgICAgbmFtZTogJ3BvcycsXG4gICAgICBjbGFzczogJ1NpbXBsZSdcbiAgICB9LFxuICAgIHtcbiAgICAgIG5hbWU6ICdoZWFkJyxcbiAgICAgIGdldHRlcjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0clswXVt0aGlzLnBvc107XG4gICAgICB9XG4gICAgfSxcbiAgICB7XG4gICAgICBuYW1lOiAndGFpbCcsXG4gICAgICBnZXR0ZXI6IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoICEgdGhpcy5pbnN0YW5jZV8udGFpbCApIHtcbiAgICAgICAgICB2YXIgcHMgPSB0aGlzLmNsc18uY3JlYXRlKCk7XG4gICAgICAgICAgcHMuc3RyID0gdGhpcy5zdHI7XG4gICAgICAgICAgcHMucG9zID0gdGhpcy5wb3MgKyAxO1xuICAgICAgICAgIHRoaXMuaW5zdGFuY2VfLnRhaWwgPSBwcztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5pbnN0YW5jZV8udGFpbDtcbiAgICAgIH0sXG4gICAgICBzZXR0ZXI6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuaW5zdGFuY2VfLnRhaWwgPSB2YWx1ZTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHtcbiAgICAgIG5hbWU6ICd2YWxpZCcsXG4gICAgICBnZXR0ZXI6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wb3MgPD0gdGhpcy5zdHJbMF0ubGVuZ3RoO1xuICAgICAgfVxuICAgIH0sXG4gICAge1xuICAgICAgbmFtZTogJ3ZhbHVlJyxcbiAgICAgIHNldHRlcjogZnVuY3Rpb24odmFsdWUpIHsgdGhpcy5pbnN0YW5jZV8udmFsdWUgPSB2YWx1ZTsgfSxcbiAgICAgIGdldHRlcjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmluc3RhbmNlXy52YWx1ZSAhPT0gdW5kZWZpbmVkID9cbiAgICAgICAgICB0aGlzLmluc3RhbmNlXy52YWx1ZSA6XG4gICAgICAgICAgdGhpcy5zdHJbMF0uY2hhckF0KHRoaXMucG9zIC0gMSk7XG4gICAgICB9XG4gICAgfVxuICBdLFxuXG4gIG1ldGhvZHM6IFtcbiAgICBmdW5jdGlvbiBpbml0QXJncygpIHt9LFxuXG4gICAgZnVuY3Rpb24gc2V0VmFsdWUodmFsdWUpIHtcbiAgICAgIC8vIEZvcmNlIHVuZGVmaW5lZCB2YWx1ZXMgdG8gbnVsbCBzbyB0aGF0IGhhc093blByb3BlcnR5IGNoZWNrcyBhcmUgZmFzdGVyLlxuICAgICAgaWYgKCB2YWx1ZSA9PT0gdW5kZWZpbmVkICkgdmFsdWUgPSBudWxsO1xuICAgICAgdmFyIHBzID0gdGhpcy5jbHNfLmNyZWF0ZSgpO1xuICAgICAgcHMuc3RyID0gdGhpcy5zdHI7XG4gICAgICBwcy5wb3MgPSB0aGlzLnBvcztcbiAgICAgIHBzLnRhaWwgPSB0aGlzLnRhaWw7XG4gICAgICBwcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgcmV0dXJuIHBzO1xuICAgIH0sXG5cbiAgICBmdW5jdGlvbiBzZXRTdHJpbmcocykge1xuICAgICAgaWYgKCAhIHRoaXMucG9zICkgdGhpcy5wb3MgPSAwO1xuICAgICAgaWYgKCAhIHRoaXMuc3RyICkgdGhpcy5zdHIgPSBbXTtcbiAgICAgIHRoaXMuc3RyWzBdID0gcztcbiAgICB9LFxuXG4gICAgZnVuY3Rpb24gc3Vic3RyaW5nKGVuZCkge1xuICAgICAgZm9hbS5hc3NlcnQodGhpcy5zdHIgPT09IGVuZC5zdHIgJiZcbiAgICAgICAgICAgICAgICAgIGVuZC5wb3MgPj0gdGhpcy5wb3MsXG4gICAgICAgICAgICAgICAgICAnQ2Fubm90IG1ha2Ugc3Vic3RyaW5nOiBlbmQgUFN0cmVhbSBpcyBub3QgYSB0YWlsIG9mIHRoaXMuJyk7XG5cbiAgICAgIHJldHVybiB0aGlzLnN0clswXS5zdWJzdHJpbmcodGhpcy5wb3MsIGVuZC5wb3MpO1xuICAgIH0sXG5cbiAgICBmdW5jdGlvbiBhcHBseShwLCBvYmopIHtcbiAgICAgIHJldHVybiBwLnBhcnNlKHRoaXMsIG9iaik7XG4gICAgfVxuICBdXG59KTtcblxuXG5mb2FtLkNMQVNTKHtcbiAgcGFja2FnZTogJ2ZvYW0ucGFyc2UnLFxuICBuYW1lOiAnUGFyc2VyQXJyYXknLFxuICBleHRlbmRzOiAnRk9iamVjdEFycmF5JyxcblxuICBwcm9wZXJ0aWVzOiBbXG4gICAgWydvZicsICdmb2FtLnBhcnNlLlBhcnNlciddLFxuICAgIFsnYWRhcHQnLCBmdW5jdGlvbihfLCBhKSB7XG4gICAgICAgIGlmICggISBhICkgcmV0dXJuIFtdO1xuICAgICAgICB2YXIgYiA9IG5ldyBBcnJheShhLmxlbmd0aCk7XG4gICAgICAgIGZvciAoIHZhciBpID0gMCA7IGkgPCBhLmxlbmd0aCA7IGkrKyApIHtcbiAgICAgICAgICBiW2ldID0gdHlwZW9mIGFbaV0gPT09ICdzdHJpbmcnID9cbiAgICAgICAgICAgICAgZm9hbS5wYXJzZS5MaXRlcmFsLmNyZWF0ZSh7czogYVtpXX0pIDpcbiAgICAgICAgICAgICAgYVtpXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYjtcbiAgICAgIH1cbiAgICBdXG4gIF1cbn0pO1xuXG5cbmZvYW0uQ0xBU1Moe1xuICBwYWNrYWdlOiAnZm9hbS5wYXJzZScsXG4gIG5hbWU6ICdQYXJzZXJQcm9wZXJ0eScsXG4gIGV4dGVuZHM6ICdQcm9wZXJ0eScsXG5cbiAgcHJvcGVydGllczogW1xuICAgIHtcbiAgICAgIG5hbWU6ICdhZGFwdCcsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24oXywgdikge1xuICAgICAgICByZXR1cm4gdHlwZW9mIHYgPT09ICdzdHJpbmcnID8gZm9hbS5wYXJzZS5MaXRlcmFsLmNyZWF0ZSh7czogdn0pIDogdjtcbiAgICAgIH1cbiAgICB9XG4gIF1cbn0pO1xuXG5cbmZvYW0uQ0xBU1Moe1xuICBwYWNrYWdlOiAnZm9hbS5wYXJzZScsXG4gIG5hbWU6ICdQYXJzZXJEZWNvcmF0b3InLFxuXG4gIHByb3BlcnRpZXM6IFtcbiAgICB7XG4gICAgICBuYW1lOiAncCcsXG4gICAgICBjbGFzczogJ2ZvYW0ucGFyc2UuUGFyc2VyUHJvcGVydHknLFxuICAgICAgZmluYWw6IHRydWVcbiAgICB9XG4gIF0sXG5cbiAgbWV0aG9kczogW1xuICAgIGZ1bmN0aW9uIHRvU3RyaW5nKCkgeyByZXR1cm4gdGhpcy5wLnRvU3RyaW5nKCk7IH1cbiAgXVxufSk7XG5cblxuZm9hbS5DTEFTUyh7XG4gIHBhY2thZ2U6ICdmb2FtLnBhcnNlJyxcbiAgbmFtZTogJ0xpdGVyYWwnLFxuXG4gIGRvY3VtZW50YXRpb246ICdNYXRjaGVzIGEgbGl0ZXJhbCB3aXRoIHRoZSBwYXJzZSBzdHJlYW0gKGNhc2Ugc2Vuc2l0aXZlKScsXG5cbiAgcHJvcGVydGllczogW1xuICAgIHtcbiAgICAgIG5hbWU6ICdzJyxcbiAgICAgIGZpbmFsOiB0cnVlXG4gICAgfSxcbiAgICB7XG4gICAgICBuYW1lOiAndmFsdWUnLFxuICAgICAgZmluYWw6IHRydWVcbiAgICB9XG4gIF0sXG5cbiAgbWV0aG9kczogW1xuICAgIGZ1bmN0aW9uIHBhcnNlKHBzKSB7XG4gICAgICB2YXIgc3RyID0gdGhpcy5zO1xuICAgICAgZm9yICggdmFyIGkgPSAwIDsgaSA8IHN0ci5sZW5ndGggOyBpKyssIHBzID0gcHMudGFpbCApIHtcbiAgICAgICAgaWYgKCBzdHIuY2hhckF0KGkpICE9PSBwcy5oZWFkICkge1xuICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBwcy5zZXRWYWx1ZSh0aGlzLnZhbHVlICE9PSB1bmRlZmluZWQgPyB0aGlzLnZhbHVlIDogc3RyKTtcbiAgICB9LFxuXG4gICAgZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgICByZXR1cm4gJ1wiJyArIHRoaXMucyArICdcIic7XG4gICAgfVxuICBdXG59KTtcblxuXG5mb2FtLkNMQVNTKHtcbiAgcGFja2FnZTogJ2ZvYW0ucGFyc2UnLFxuICBuYW1lOiAnTGl0ZXJhbElDJyxcblxuICBkb2N1bWVudGF0aW9uOiAnTWF0Y2hlcyBhIGxpdGVyYWwgd2l0aCB0aGUgcGFyc2Ugc3RyZWFtIChjYXNlIGluc2Vuc2l0aXZlKScsXG5cbiAgcHJvcGVydGllczogW1xuICAgIHtcbiAgICAgIG5hbWU6ICdzJyxcbiAgICAgIGZpbmFsOiB0cnVlLFxuICAgICAgcG9zdFNldDogZnVuY3Rpb24ob2xkLCBudSkge1xuICAgICAgICB0aGlzLmxvd2VyID0gbnUudG9Mb3dlckNhc2UoKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHtcbiAgICAgIG5hbWU6ICdsb3dlcicsXG4gICAgICBmaW5hbDogdHJ1ZVxuICAgIH0sXG4gICAge1xuICAgICAgbmFtZTogJ3ZhbHVlJyxcbiAgICAgIGZpbmFsOiB0cnVlXG4gICAgfVxuICBdLFxuXG4gIG1ldGhvZHM6IFtcbiAgICBmdW5jdGlvbiBwYXJzZShwcykge1xuICAgICAgdmFyIHN0ciA9IHRoaXMubG93ZXI7XG4gICAgICBmb3IgKCB2YXIgaSA9IDAgOyBpIDwgc3RyLmxlbmd0aCA7IGkrKywgcHMgPSBwcy50YWlsICkge1xuICAgICAgICBpZiAoICEgcHMuaGVhZCB8fCBzdHIuY2hhckF0KGkpICE9PSBwcy5oZWFkLnRvTG93ZXJDYXNlKCkgKSB7XG4gICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHBzLnNldFZhbHVlKHRoaXMudmFsdWUgIT09IHVuZGVmaW5lZCA/IHRoaXMudmFsdWUgOiB0aGlzLnMpO1xuICAgIH0sXG5cbiAgICBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICAgIHJldHVybiAnaWdub3JlQ2FzZShcIicgKyB0aGlzLmxvd2VyICsgJ1wiKSc7XG4gICAgfVxuICBdXG59KTtcblxuXG5mb2FtLkNMQVNTKHtcbiAgcGFja2FnZTogJ2ZvYW0ucGFyc2UnLFxuICBuYW1lOiAnQWx0ZXJuYXRlJyxcblxuICBkb2N1bWVudGF0aW9uOiAnQXR0ZW1wdHMgdG8gbWF0Y2ggb25lIG9mIHRoZSBwYXJzZXIgcHJvcGVydGllcyB0byB0aGUgcGFyc2Ugc3RyZWFtLicsXG5cbiAgcHJvcGVydGllczogW1xuICAgIHtcbiAgICAgIG5hbWU6ICdhcmdzJyxcbiAgICAgIGZpbmFsOiB0cnVlLFxuICAgICAgY2xhc3M6ICdmb2FtLnBhcnNlLlBhcnNlckFycmF5J1xuICAgIH1cbiAgXSxcblxuICBtZXRob2RzOiBbXG4gICAgZnVuY3Rpb24gcGFyc2UocHMsIG9iaikge1xuICAgICAgLy8gVE9ETyhhZGFtdnkpOiBTaG91bGQgd2UgcmVtb3ZlIHRoZSBvYmogYXJndW1lbnQgaW4gZmF2b3VyIG9mXG4gICAgICAvLyBwYXNzaW5nIHRoZSBvYmogYWxvbmcgdmlhIGNvbnRleHQgb3Igc29tZXRoaW5nP1xuICAgICAgdmFyIGFyZ3MgPSB0aGlzLmFyZ3M7XG4gICAgICBmb3IgKCB2YXIgaSA9IDAsIHAgOyBwID0gYXJnc1tpXSA7IGkrKyApIHtcbiAgICAgICAgdmFyIHJldCA9IHBzLmFwcGx5KHAsIG9iaik7XG4gICAgICAgIGlmICggcmV0ICkgcmV0dXJuIHJldDtcbiAgICAgIH1cbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfSxcblxuICAgIGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgICAgdmFyIGFyZ3MgPSB0aGlzLmFyZ3M7XG4gICAgICB2YXIgc3RycyA9IG5ldyBBcnJheShhcmdzLmxlbmd0aCk7XG4gICAgICBmb3IgKCB2YXIgaSA9IDA7IGkgPCBhcmdzLmxlbmd0aDsgaSsrICkge1xuICAgICAgICBzdHJzW2ldID0gYXJnc1tpXS50b1N0cmluZygpO1xuICAgICAgfVxuICAgICAgcmV0dXJuICdhbHQoJyArIHN0cnMuam9pbignLCAnKSArICcpJztcbiAgICB9XG4gIF1cbn0pO1xuXG5cbmZvYW0uQ0xBU1Moe1xuICBwYWNrYWdlOiAnZm9hbS5wYXJzZScsXG4gIG5hbWU6ICdTZXF1ZW5jZScsXG5cbiAgZG9jdW1lbnRhdGlvbjogJ1BhcnNlcyB0aGUgcGFyc2VyIHByb3BlcnRpZXMgc2VxdWVudGlhbGx5LicsXG5cbiAgcHJvcGVydGllczogW1xuICAgIHtcbiAgICAgIG5hbWU6ICdhcmdzJyxcbiAgICAgIGZpbmFsOiB0cnVlLFxuICAgICAgY2xhc3M6ICdmb2FtLnBhcnNlLlBhcnNlckFycmF5J1xuICAgIH1cbiAgXSxcblxuICBtZXRob2RzOiBbXG4gICAgZnVuY3Rpb24gcGFyc2UocHMsIG9iaikge1xuICAgICAgdmFyIHJldCA9IFtdO1xuICAgICAgdmFyIGFyZ3MgPSB0aGlzLmFyZ3M7XG4gICAgICBmb3IgKCB2YXIgaSA9IDAsIHAgOyBwID0gYXJnc1tpXSA7IGkrKyApIHtcbiAgICAgICAgaWYgKCAhICggcHMgPSBwcy5hcHBseShwLCBvYmopICkgKSByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICByZXQucHVzaChwcy52YWx1ZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcHMuc2V0VmFsdWUocmV0KTtcbiAgICB9LFxuXG4gICAgZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgICB2YXIgYXJncyA9IHRoaXMuYXJncztcbiAgICAgIHZhciBzdHJzID0gbmV3IEFycmF5KGFyZ3MubGVuZ3RoKTtcbiAgICAgIGZvciAoIHZhciBpID0gMDsgaSA8IGFyZ3MubGVuZ3RoOyBpKysgKSB7XG4gICAgICAgIHN0cnNbaV0gPSBhcmdzW2ldLnRvU3RyaW5nKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gJ3NlcSgnICsgc3Rycy5qb2luKCcsICcpICsgJyknO1xuICAgIH1cbiAgXVxufSk7XG5cblxuZm9hbS5DTEFTUyh7XG4gIHBhY2thZ2U6ICdmb2FtLnBhcnNlJyxcbiAgbmFtZTogJ1N0cmluZycsXG4gIGV4dGVuZHM6ICdmb2FtLnBhcnNlLlBhcnNlckRlY29yYXRvcicsXG4gIG1ldGhvZHM6IFtcbiAgICBmdW5jdGlvbiBwYXJzZShwcywgb2JqKSB7XG4gICAgICBwcyA9IHBzLmFwcGx5KHRoaXMucCwgb2JqKTtcbiAgICAgIHJldHVybiBwcyA/IHBzLnNldFZhbHVlKHBzLnZhbHVlLmpvaW4oJycpKSA6IHVuZGVmaW5lZDtcbiAgICB9LFxuXG4gICAgZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgICByZXR1cm4gJ3N0cignICsgdGhpcy5TVVBFUigpICsgJyknO1xuICAgIH1cbiAgXVxufSk7XG5cblxuZm9hbS5DTEFTUyh7XG4gIHBhY2thZ2U6ICdmb2FtLnBhcnNlJyxcbiAgbmFtZTogJ1N1YnN0cmluZycsXG4gIGV4dGVuZHM6ICdmb2FtLnBhcnNlLlBhcnNlckRlY29yYXRvcicsXG4gIG1ldGhvZHM6IFtcbiAgICBmdW5jdGlvbiBwYXJzZShwcywgb2JqKSB7XG4gICAgICB2YXIgc3RhcnQgPSBwcztcbiAgICAgIHBzID0gcHMuYXBwbHkodGhpcy5wLCBvYmopO1xuICAgICAgcmV0dXJuIHBzID8gcHMuc2V0VmFsdWUoc3RhcnQuc3Vic3RyaW5nKHBzKSkgOiB1bmRlZmluZWQ7XG4gICAgfSxcblxuICAgIGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgICAgcmV0dXJuICdzdHIoJyArIHRoaXMuU1VQRVIoKSArICcpJztcbiAgICB9XG4gIF1cbn0pO1xuXG5cbmZvYW0uQ0xBU1Moe1xuICBwYWNrYWdlOiAnZm9hbS5wYXJzZScsXG4gIG5hbWU6ICdTZXF1ZW5jZTAnLFxuXG4gIGRvY3VtZW50YXRpb246IGBQYXJzZXMgdGhlIHBhcnNlciBwcm9wZXJ0aWVzIHNlcXVlbnRpYWxseSxcbiAgICB3aXRob3V0IHJldHVybmluZyB2YWx1ZWAsXG5cbiAgcHJvcGVydGllczogW1xuICAgIHtcbiAgICAgIG5hbWU6ICdhcmdzJyxcbiAgICAgIGZpbmFsOiB0cnVlLFxuICAgICAgY2xhc3M6ICdmb2FtLnBhcnNlLlBhcnNlckFycmF5J1xuICAgIH1cbiAgXSxcblxuICBtZXRob2RzOiBbXG4gICAgZnVuY3Rpb24gcGFyc2UocHMsIG9iaikge1xuICAgICAgdmFyIGFyZ3MgPSB0aGlzLmFyZ3M7XG4gICAgICBmb3IgKCB2YXIgaSA9IDAsIHAgOyBwID0gYXJnc1tpXSA7IGkrKyApIHtcbiAgICAgICAgaWYgKCAhICggcHMgPSBwcy5hcHBseShwLCBvYmopICkgKSByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHBzO1xuICAgIH0sXG5cbiAgICBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICAgIHZhciBhcmdzID0gdGhpcy5hcmdzO1xuICAgICAgdmFyIHN0cnMgPSBuZXcgQXJyYXkoYXJncy5sZW5ndGgpO1xuICAgICAgZm9yICggdmFyIGkgPSAwOyBpIDwgYXJncy5sZW5ndGg7IGkrKyApIHtcbiAgICAgICAgc3Ryc1tpXSA9IGFyZ3NbaV0udG9TdHJpbmcoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiAnc2VxMCgnICsgc3Rycy5qb2luKCcsICcpICsgJyknO1xuICAgIH1cbiAgXVxufSk7XG5cbmZvYW0uQ0xBU1Moe1xuICBwYWNrYWdlOiAnZm9hbS5wYXJzZScsXG4gIG5hbWU6ICdTZXF1ZW5jZTEnLFxuXG4gIGRvY3VtZW50YXRpb246IGBQYXJzZXMgdGhlIHBhcnNlciBwcm9wZXJ0aWVzIHNlcXVlbnRpYWxseSwgcmV0dXJuaW5nXG4gICAgdGhlIG4odGgpIHByb3BlcnR5IHZhbHVlIHBhcnNlZC5gLFxuXG4gIHByb3BlcnRpZXM6IFtcbiAgICB7XG4gICAgICBuYW1lOiAnYXJncycsXG4gICAgICBmaW5hbDogdHJ1ZSxcbiAgICAgIGNsYXNzOiAnZm9hbS5wYXJzZS5QYXJzZXJBcnJheSdcbiAgICB9LFxuICAgIHtcbiAgICAgIG5hbWU6ICduJyxcbiAgICAgIGZpbmFsOiB0cnVlXG4gICAgfVxuICBdLFxuXG4gIG1ldGhvZHM6IFtcbiAgICBmdW5jdGlvbiBwYXJzZShwcywgb2JqKSB7XG4gICAgICB2YXIgcmV0O1xuICAgICAgdmFyIGFyZ3MgPSB0aGlzLmFyZ3M7XG4gICAgICB2YXIgbiA9IHRoaXMubjtcbiAgICAgIGZvciAoIHZhciBpID0gMCwgcCA7IHAgPSBhcmdzW2ldIDsgaSsrICkge1xuICAgICAgICBpZiAoICEgKCBwcyA9IHBzLmFwcGx5KHAsIG9iaikgKSApIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIGlmICggaSA9PT0gbiApIHJldCA9IHBzLnZhbHVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHBzLnNldFZhbHVlKHJldCk7XG4gICAgfSxcblxuICAgIGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgICAgdmFyIGFyZ3MgPSB0aGlzLmFyZ3M7XG4gICAgICB2YXIgc3RycyA9IG5ldyBBcnJheShhcmdzLmxlbmd0aCk7XG4gICAgICBmb3IgKCB2YXIgaSA9IDA7IGkgPCBhcmdzLmxlbmd0aDsgaSsrICkge1xuICAgICAgICBzdHJzW2ldID0gYXJnc1tpXS50b1N0cmluZygpO1xuICAgICAgfVxuICAgICAgcmV0dXJuICdzZXExKCcgKyB0aGlzLm4gKyAnLCAnICsgc3Rycy5qb2luKCcsICcpICsgJyknO1xuICAgIH1cbiAgXVxufSk7XG5cbmZvYW0uQ0xBU1Moe1xuICBwYWNrYWdlOiAnZm9hbS5wYXJzZScsXG4gIG5hbWU6ICdPcHRpb25hbCcsXG4gIGV4dGVuZHM6ICdmb2FtLnBhcnNlLlBhcnNlckRlY29yYXRvcicsXG5cbiAgZG9jdW1lbnRhdGlvbjogJ1JlZmVycyB0byBhbiBvcHRpb25hbCBwYXJzZXIgcHJvcGVydHkuJyxcblxuICBtZXRob2RzOiBbXG4gICAgZnVuY3Rpb24gcGFyc2UocHMsIG9iaikge1xuICAgICAgcmV0dXJuIHBzLmFwcGx5KHRoaXMucCwgb2JqKSB8fCBwcy5zZXRWYWx1ZShudWxsKTtcbiAgICB9LFxuXG4gICAgZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgICByZXR1cm4gJ29wdCgnICsgdGhpcy5TVVBFUigpICsgJyknO1xuICAgIH1cbiAgXSxcbn0pO1xuXG5cbmZvYW0uQ0xBU1Moe1xuICBwYWNrYWdlOiAnZm9hbS5wYXJzZScsXG4gIG5hbWU6ICdBbnlDaGFyJyxcblxuICBkb2N1bWVudGF0aW9uOiBgTWF0Y2hlcyBhbnkgY2hhciB3aXRoaW4gdGhlIHBhcnNlIHN0cmVhbS5cbiAgICBPZnRlbiB1c2VkIHVuZGVyIHRoZSBlbHNlIGNsYXVzZSBvZiB0aGUgJ25vdCcgcGFyc2VyXG4gICAgcHJvcGVydHkuIEV4LiBcXGBub3QoJywnLCBhbnlDaGFyKCkpXFxgYCxcblxuICBheGlvbXM6IFsgZm9hbS5wYXR0ZXJuLlNpbmdsZXRvbi5jcmVhdGUoKSBdLFxuXG4gIG1ldGhvZHM6IFtcbiAgICBmdW5jdGlvbiBwYXJzZShwcykge1xuICAgICAgcmV0dXJuIHBzLmhlYWQgPyBwcy50YWlsIDogdW5kZWZpbmVkO1xuICAgIH0sXG5cbiAgICBmdW5jdGlvbiB0b1N0cmluZygpIHsgcmV0dXJuICdhbnlDaGFyKCknOyB9XG4gIF1cbn0pO1xuXG5cbmZvYW0uQ0xBU1Moe1xuICBwYWNrYWdlOiAnZm9hbS5wYXJzZScsXG4gIG5hbWU6ICdOb3RDaGFycycsXG5cbiAgZG9jdW1lbnRhdGlvbjogYE1hdGNoZXMgYWdhaW5zdCBhbGwgYnV0IHRoZSBjaGFycyBzcGVjaWZpZWRcbiAgICBpbiB0aGUgYXJndW1lbnQgc3RyaW5nLmAsXG5cbiAgcHJvcGVydGllczogW1xuICAgIHtcbiAgICAgIG5hbWU6ICdzdHJpbmcnLFxuICAgICAgZmluYWw6IHRydWVcbiAgICB9XG4gIF0sXG5cbiAgbWV0aG9kczogW1xuICAgIGZ1bmN0aW9uIHBhcnNlKHBzKSB7XG4gICAgICByZXR1cm4gcHMuaGVhZCAmJiB0aGlzLnN0cmluZy5pbmRleE9mKHBzLmhlYWQpID09PSAtMSA/XG4gICAgICAgIHBzLnRhaWwgOiB1bmRlZmluZWQ7XG4gICAgfSxcblxuICAgIGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgICAgdmFyIHN0ciA9IHRoaXMuc3RyaW5nO1xuICAgICAgdmFyIGNoYXJzID0gbmV3IEFycmF5KHN0ci5sZW5ndGgpO1xuICAgICAgZm9yICggdmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSsrICkge1xuICAgICAgICBjaGFyc1tpXSA9IHN0ci5jaGFyQXQoaSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gJ25vdENoYXJzKFwiJyArIGNoYXJzLmpvaW4oJ1wiLCBcIicpICsgJ1wiKSc7XG4gICAgfVxuICBdXG59KTtcblxuXG5mb2FtLkNMQVNTKHtcbiAgcGFja2FnZTogJ2ZvYW0ucGFyc2UnLFxuICBuYW1lOiAnQ2hhcnMnLFxuXG4gIGRvY3VtZW50YXRpb246IGBNYXRjaGVzIGFnYWluc3QgYW55IG9mIHRoZSBjaGFycyBzcGVjaWZpZWRcbiAgICBpbiB0aGUgYXJndW1lbnQgc3RyaW5nLmAsXG5cbiAgcHJvcGVydGllczogW1xuICAgIHtcbiAgICAgIG5hbWU6ICdzdHJpbmcnLFxuICAgICAgZmluYWw6IHRydWVcbiAgICB9XG4gIF0sXG5cbiAgbWV0aG9kczogW1xuICAgIGZ1bmN0aW9uIHBhcnNlKHBzKSB7XG4gICAgICByZXR1cm4gcHMudmFsaWQgJiYgdGhpcy5zdHJpbmcuaW5kZXhPZihwcy5oZWFkKSAhPT0gLTEgP1xuICAgICAgICBwcy50YWlsIDogdW5kZWZpbmVkO1xuICAgIH0sXG5cbiAgICBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICAgIHZhciBzdHIgPSB0aGlzLnN0cmluZztcbiAgICAgIHZhciBjaGFycyA9IG5ldyBBcnJheShzdHIubGVuZ3RoKTtcbiAgICAgIGZvciAoIHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkrKyApIHtcbiAgICAgICAgY2hhcnNbaV0gPSBzdHIuY2hhckF0KGkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuICdjaGFycyhcIicgKyBjaGFycy5qb2luKCdcIiwgXCInKSArICdcIiknO1xuICAgIH1cbiAgXVxufSk7XG5cblxuZm9hbS5DTEFTUyh7XG4gIHBhY2thZ2U6ICdmb2FtLnBhcnNlJyxcbiAgbmFtZTogJ1JhbmdlJyxcblxuICBkb2N1bWVudGF0aW9uOiBgTWF0Y2hlcyBhZ2FpbnN0IGEgcmFuZ2Ugb2YgY2hhcnMgc3BlY2lmaWVkXG4gICAgd2l0aCBmcm9tL3RvLiBFeC4gXFxgcmFuZ2UoJzAnLCAnOScpXFxgIGZvciBkaWdpdHNgLFxuXG4gIHByb3BlcnRpZXM6IFtcbiAgICB7XG4gICAgICBuYW1lOiAnZnJvbScsXG4gICAgICBmaW5hbDogdHJ1ZVxuICAgIH0sXG4gICAge1xuICAgICAgbmFtZTogJ3RvJyxcbiAgICAgIGZpbmFsOiB0cnVlXG4gICAgfVxuICBdLFxuXG4gIG1ldGhvZHM6IFtcbiAgICBmdW5jdGlvbiBwYXJzZShwcykge1xuICAgICAgaWYgKCAhIHBzLmhlYWQgKSByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgcmV0dXJuICggdGhpcy5mcm9tIDw9IHBzLmhlYWQgJiYgcHMuaGVhZCA8PSB0aGlzLnRvICkgP1xuICAgICAgICAgIHBzLnRhaWwuc2V0VmFsdWUocHMuaGVhZCkgOlxuICAgICAgICAgIHVuZGVmaW5lZDtcbiAgICB9LFxuXG4gICAgZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgICByZXR1cm4gJ3JhbmdlKFwiJyArIHRoaXMuZnJvbSArICdcIiwgXCInICsgdGhpcy50byArICdcIiknO1xuICAgIH1cbiAgXVxufSk7XG5cblxuZm9hbS5DTEFTUyh7XG4gIHBhY2thZ2U6ICdmb2FtLnBhcnNlJyxcbiAgbmFtZTogJ1JlcGVhdCcsXG4gIGV4dGVuZHM6ICdmb2FtLnBhcnNlLlBhcnNlckRlY29yYXRvcicsXG5cbiAgZG9jdW1lbnRhdGlvbjogYFJlcGVhdHMgbWF0Y2hpbmcgdG8gdGhlIHBhcnNlciBwcm9wZXJ0eSBzcGVjaWZpZWRcbiAgICB3aXRoIGFuIG9wdGlvbmFsIGRlbGltaXRlciwgYW5kIG1pbiBudW1iZXIgb2YgbWF0Y2hlcy5gLFxuXG4gIHByb3BlcnRpZXM6IFtcbiAgICB7XG4gICAgICBjbGFzczogJ2ZvYW0ucGFyc2UuUGFyc2VyUHJvcGVydHknLFxuICAgICAgbmFtZTogJ2RlbGltaXRlcidcbiAgICB9LFxuICAgIHtcbiAgICAgIGNsYXNzOiAnSW50JyxcbiAgICAgIG5hbWU6ICdtaW5pbXVtJ1xuICAgIH1cbiAgXSxcblxuICBtZXRob2RzOiBbXG4gICAgZnVuY3Rpb24gcGFyc2UocHMsIG9iaikge1xuICAgICAgdmFyIHJldCA9IFtdO1xuICAgICAgdmFyIHAgPSB0aGlzLnA7XG4gICAgICB2YXIgbGFzdDtcbiAgICAgIHZhciBkZWxpbSA9IHRoaXMuZGVsaW1pdGVyO1xuXG4gICAgICB3aGlsZSAoIHBzICkge1xuICAgICAgICAvLyBDaGVja3MgZm9yIGVuZCBvZiBzdHJpbmdcbiAgICAgICAgaWYgKCBsYXN0ICYmICggbGFzdC5wb3MgPT0gcHMuc3RyWzBdLmxlbmd0aCApICkge1xuICAgICAgICAgIC8vIENoZWNrcyBpZiBwcmV2aW91cyBjaGFyIHdhcyBkZWxpbWl0ZXIsIGlmIG5vdCByZW1vdmVzIHRyYWlsaW5nIGVtcHR5IHN0cmluZ1xuICAgICAgICAgIC8vIFRPRE86IEZpbmQgYSBiZXR0ZXIgd2F5IHRvIGhhbmRsZSByZWFkaW5nIHBhc3QgaW5wdXRcbiAgICAgICAgICBpZiAoIGRlbGltICYmICggcHMuc3RyWzBdW2xhc3QucG9zIC0gMV0gIT0gZGVsaW0ucyApICkgcmV0LnBvcCgpO1xuICAgICAgICAgIHJldHVybiBwcy5zZXRWYWx1ZShyZXQpO1xuICAgICAgICB9XG5cbiAgICAgICAgbGFzdCA9IHBzO1xuICAgICAgICBwcyA9IHBzLmFwcGx5KHAsIG9iaik7XG4gICAgICAgIGlmICggcHMgKSByZXQucHVzaChwcy52YWx1ZSk7XG4gICAgICAgIGlmICggZGVsaW0gJiYgcHMgKSB7XG4gICAgICAgICAgcHMgPSBwcy5hcHBseShkZWxpbSwgb2JqKSB8fCBwcztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoIHRoaXMubWluaW11bSA+IDAgJiYgcmV0Lmxlbmd0aCA8IHRoaXMubWluaW11bSApIHJldHVybiB1bmRlZmluZWQ7XG5cbiAgICAgIHJldHVybiBsYXN0LnNldFZhbHVlKHJldCk7XG4gICAgfSxcblxuICAgIGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgICAgdmFyIHN0ciA9ICdyZXBlYXQoJyArIHRoaXMuU1VQRVIoKTtcbiAgICAgIGlmICggdGhpcy5kZWxpbWl0ZXIgKSBzdHIgKz0gJywgJyArIHRoaXMuZGVsaW1pdGVyO1xuICAgICAgaWYgKCB0aGlzLm1pbmltdW0gKSBzdHIgKz0gJywgJyArIHRoaXMubWluaW11bTtcbiAgICAgIHN0ciArPSAnKSc7XG4gICAgICByZXR1cm4gc3RyO1xuICAgIH1cbiAgXVxufSk7XG5cblxuZm9hbS5DTEFTUyh7XG4gIHBhY2thZ2U6ICdmb2FtLnBhcnNlJyxcbiAgbmFtZTogJ1BsdXMnLFxuICBleHRlbmRzOiAnZm9hbS5wYXJzZS5SZXBlYXQnLFxuXG4gIGRvY3VtZW50YXRpb246IGBSZXBlYXRzIG1hdGNoaW5nIHRvIGEgcGFyc2VyIHByb3BlcnR5IGF0IGxlYXN0IG9uZSB0aW1lXG4gICAgd2l0aCBhbiBvcHRpb25hbCBkZWxpbWl0ZXIuYCxcblxuICBwcm9wZXJ0aWVzOiBbXG4gICAgWydtaW5pbXVtJywgMV1cbiAgXSxcblxuICBtZXRob2RzOiBbXG4gICAgZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgICB2YXIgc3RyID0gJ3BsdXMoJyArIHRoaXMucC50b1N0cmluZygpO1xuICAgICAgaWYgKCB0aGlzLmRlbGltaXRlciApIHN0ciArPSAnLCAnICsgdGhpcy5kZWxpbWl0ZXI7XG4gICAgICBzdHIgKz0gJyknO1xuICAgICAgcmV0dXJuIHN0cjtcbiAgICB9XG4gIF1cbn0pO1xuXG5cbmZvYW0uQ0xBU1Moe1xuICBwYWNrYWdlOiAnZm9hbS5wYXJzZScsXG4gIG5hbWU6ICdSZXBlYXQwJyxcbiAgZXh0ZW5kczogJ2ZvYW0ucGFyc2UuUmVwZWF0JyxcblxuICBkb2N1bWVudGF0aW9uOiBgUmVwZWF0cyBtYXRjaGluZyB0byBhIHBhcnNlciBwcm9wZXJ0eSxcbiAgICB3aXRob3V0IHJldHVybmluZyBhIHZhbHVlLiBVc2VmdWwgZm9yIHdoaXRlc3BhY2UuXG4gICAgRXguIFxcYHJlcGVhdDAoc3ltKCd3aGl0ZScpKVxcYGAsXG5cbiAgbWV0aG9kczogW1xuICAgIGZ1bmN0aW9uIHBhcnNlKHBzLCBvYmopIHtcbiAgICAgIHZhciBwID0gdGhpcy5wO1xuICAgICAgdmFyIGxhc3Q7XG4gICAgICB2YXIgZGVsaW0gPSB0aGlzLmRlbGltaXRlcjtcbiAgICAgIHZhciBpID0gMDtcblxuICAgICAgd2hpbGUgKCBwcyApIHtcbiAgICAgICAgbGFzdCA9IHBzO1xuICAgICAgICBwcyA9IHBzLmFwcGx5KHAsIG9iaik7XG4gICAgICAgIGlmICggcHMgKSBpKys7XG4gICAgICAgIGlmICggZGVsaW0gJiYgcHMgKSB7XG4gICAgICAgICAgcHMgPSBwcy5hcHBseShkZWxpbSwgb2JqKSB8fCBwcztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoIHRoaXMubWluaW11bSA+IDAgJiYgaSA8IHRoaXMubWluaW11bSApIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICByZXR1cm4gbGFzdDtcbiAgICB9LFxuXG4gICAgZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgICB2YXIgc3RyID0gJ3JlcGVhdDAoJyArIHRoaXMucC50b1N0cmluZygpO1xuICAgICAgaWYgKCB0aGlzLmRlbGltaXRlciApIHN0ciArPSAnLCAnICsgdGhpcy5kZWxpbWl0ZXI7XG4gICAgICBpZiAoIHRoaXMubWluaW11bSApIHN0ciArPSAnLCAnICsgdGhpcy5taW5pbXVtO1xuICAgICAgc3RyICs9ICcpJztcbiAgICAgIHJldHVybiBzdHI7XG4gICAgfVxuICBdXG59KTtcblxuXG5mb2FtLkNMQVNTKHtcbiAgcGFja2FnZTogJ2ZvYW0ucGFyc2UnLFxuICBuYW1lOiAnTm90JyxcbiAgZXh0ZW5kczogJ2ZvYW0ucGFyc2UuUGFyc2VyRGVjb3JhdG9yJyxcblxuICBkb2N1bWVudGF0aW9uOiBgRW5zdXJlcyB0aGUgbGVhZGluZyBjaGFyIGlzbid0IHRoZSBwYXJzZXJcbiAgICBwcm9wZXJ0eSBzcGVjaWZpZWQuIElmIG5vdCwgYXR0ZW1wdHMgdG8gcGFyc2Ugd2l0aCB0aGVcbiAgICBlbHNlIGNsYXVzZSBwYXJzZXIgcHJvcGVydHkuIFVzZWZ1bCBmb3IgbWF0Y2hpbmcgYWxsIGJ1dFxuICAgIGEgcGFydGljdWxhciBjaGFyYWN0ZXIuIEV4LiBcXGBub3QoJ1wiJywgYW55Q2hhcigpKVxcYGAsXG5cbiAgcHJvcGVydGllczogW1xuICAgIHtcbiAgICAgIG5hbWU6ICdlbHNlJyxcbiAgICAgIGZpbmFsOiB0cnVlLFxuICAgICAgY2xhc3M6ICdmb2FtLnBhcnNlLlBhcnNlclByb3BlcnR5J1xuICAgIH1cbiAgXSxcblxuICBtZXRob2RzOiBbXG4gICAgZnVuY3Rpb24gcGFyc2UocHMsIG9iaikge1xuICAgICAgcmV0dXJuIHBzLmFwcGx5KHRoaXMucCwgb2JqKSA/XG4gICAgICAgIHVuZGVmaW5lZCA6XG4gICAgICAgICh0aGlzLmVsc2UgPyBwcy5hcHBseSh0aGlzLmVsc2UsIG9iaikgOiBwcyk7XG4gICAgfSxcblxuICAgIGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgICAgdmFyIHN0ciA9ICdub3QoJyArIHRoaXMuU1VQRVIoKTtcbiAgICAgIGlmICggdGhpcy5lbHNlICkgc3RyICs9ICcsICcgKyB0aGlzLmVsc2UudG9TdHJpbmcoKTtcbiAgICAgIHN0ciArPSAnKSc7XG4gICAgICByZXR1cm4gc3RyO1xuICAgIH1cbiAgXVxufSk7XG5cblxuZm9hbS5DTEFTUyh7XG4gIHBhY2thZ2U6ICdmb2FtLnBhcnNlJyxcbiAgbmFtZTogJ1BhcnNlcldpdGhBY3Rpb24nLFxuICBleHRlbmRzOiAnZm9hbS5wYXJzZS5QYXJzZXJEZWNvcmF0b3InLFxuXG4gIHByb3BlcnRpZXM6IFtcbiAgICAnYWN0aW9uJ1xuICBdLFxuXG4gIG1ldGhvZHM6IFtcbiAgICBmdW5jdGlvbiBwYXJzZShwcywgb2JqKSB7XG4gICAgICBwcyA9IHBzLmFwcGx5KHRoaXMucCwgb2JqKTtcbiAgICAgIHJldHVybiBwcyA/XG4gICAgICAgIHBzLnNldFZhbHVlKHRoaXMuYWN0aW9uKHBzLnZhbHVlKSkgOlxuICAgICAgICB1bmRlZmluZWQ7XG4gICAgfVxuICBdXG59KTtcblxuXG5mb2FtLkNMQVNTKHtcbiAgcGFja2FnZTogJ2ZvYW0ucGFyc2UnLFxuICBuYW1lOiAnU3ltYm9sJyxcblxuICBkb2N1bWVudGF0aW9uOiBgUGFyc2VzIGJhc2VkIG9uIHRoZSBwYXJzZXIgcHJvcGVydHkgbmFtZWQuYCxcblxuICBwcm9wZXJ0aWVzOiBbXG4gICAge1xuICAgICAgbmFtZTogJ25hbWUnLFxuICAgICAgZmluYWw6IHRydWVcbiAgICB9LFxuICBdLFxuXG4gIG1ldGhvZHM6IFtcbiAgICBmdW5jdGlvbiBwYXJzZShwcywgZ3JhbW1hcikge1xuICAgICAgdmFyIHAgPSBncmFtbWFyLmdldFN5bWJvbCh0aGlzLm5hbWUpO1xuICAgICAgaWYgKCAhIHAgKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ05vIHN5bWJvbCBmb3VuZCBmb3InLCB0aGlzLm5hbWUpO1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHBzLmFwcGx5KHAsIGdyYW1tYXIpO1xuICAgIH0sXG5cbiAgICBmdW5jdGlvbiB0b1N0cmluZygpIHsgcmV0dXJuICdzeW0oXCInICsgdGhpcy5uYW1lICsgJ1wiKSc7IH1cbiAgXVxufSk7XG5cblxuZm9hbS5DTEFTUyh7XG4gIHBhY2thZ2U6ICdmb2FtLnBhcnNlJyxcbiAgbmFtZTogJ1BhcnNlcnMnLFxuXG4gIGF4aW9tczogWyBmb2FtLnBhdHRlcm4uU2luZ2xldG9uLmNyZWF0ZSgpIF0sXG5cbiAgbWV0aG9kczogW1xuICAgIGZ1bmN0aW9uIHNlcSgpIHtcbiAgICAgIHJldHVybiB0aGlzLmxvb2t1cCgnZm9hbS5wYXJzZS5TZXF1ZW5jZScpLmNyZWF0ZSh7XG4gICAgICAgIGFyZ3M6IEFycmF5LmZyb20oYXJndW1lbnRzKVxuICAgICAgfSk7XG4gICAgfSxcblxuICAgIGZ1bmN0aW9uIHJlcGVhdDAocCwgZGVsaW0sIG1pbikge1xuICAgICAgcmV0dXJuIHRoaXMubG9va3VwKCdmb2FtLnBhcnNlLlJlcGVhdDAnKS5jcmVhdGUoe1xuICAgICAgICBwOiBwLFxuICAgICAgICBtaW5pbXVtOiBtaW4gfHwgMCxcbiAgICAgICAgZGVsaW1pdGVyOiBkZWxpbVxuICAgICAgfSk7XG4gICAgfSxcblxuICAgIGZ1bmN0aW9uIHNpbXBsZUFsdCgpIHtcbiAgICAgIHJldHVybiB0aGlzLmxvb2t1cCgnZm9hbS5wYXJzZS5BbHRlcm5hdGUnKS5jcmVhdGUoe1xuICAgICAgICBhcmdzOiBBcnJheS5mcm9tKGFyZ3VtZW50cylcbiAgICAgIH0pO1xuICAgIH0sXG5cbiAgICBmdW5jdGlvbiBhbHQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5sb29rdXAoJ2ZvYW0ucGFyc2UuQWx0ZXJuYXRlJykuY3JlYXRlKHtcbiAgICAgICAgYXJnczogQXJyYXkuZnJvbShhcmd1bWVudHMpXG4gICAgICB9KTtcbiAgICB9LFxuXG4gICAgZnVuY3Rpb24gc3ltKG5hbWUpIHtcbiAgICAgIHJldHVybiB0aGlzLmxvb2t1cCgnZm9hbS5wYXJzZS5TeW1ib2wnKS5jcmVhdGUoe1xuICAgICAgICBuYW1lOiBuYW1lXG4gICAgICB9KTtcbiAgICB9LFxuXG4gICAgZnVuY3Rpb24gc2VxMShuKSB7XG4gICAgICByZXR1cm4gdGhpcy5sb29rdXAoJ2ZvYW0ucGFyc2UuU2VxdWVuY2UxJykuY3JlYXRlKHtcbiAgICAgICAgbjogbixcbiAgICAgICAgYXJnczogQXJyYXkuZnJvbShhcmd1bWVudHMpLnNsaWNlKDEpXG4gICAgICB9KTtcbiAgICB9LFxuXG4gICAgZnVuY3Rpb24gc2VxMCgpIHtcbiAgICAgIHJldHVybiB0aGlzLmxvb2t1cCgnZm9hbS5wYXJzZS5TZXF1ZW5jZTAnKS5jcmVhdGUoe1xuICAgICAgICBhcmdzOiBBcnJheS5mcm9tKGFyZ3VtZW50cylcbiAgICAgIH0pO1xuICAgIH0sXG5cbiAgICBmdW5jdGlvbiByZXBlYXQocCwgZGVsaW0sIG1pbikge1xuICAgICAgcmV0dXJuIHRoaXMubG9va3VwKCdmb2FtLnBhcnNlLlJlcGVhdCcpLmNyZWF0ZSh7XG4gICAgICAgIHA6IHAsXG4gICAgICAgIG1pbmltdW06IG1pbiB8fCAwLFxuICAgICAgICBkZWxpbWl0ZXI6IGRlbGltXG4gICAgICB9KTtcbiAgICB9LFxuXG4gICAgZnVuY3Rpb24gcGx1cyhwLCBkZWxpbSkge1xuICAgICAgcmV0dXJuIHRoaXMubG9va3VwKCdmb2FtLnBhcnNlLlBsdXMnKS5jcmVhdGUoe1xuICAgICAgICBwOiBwLFxuICAgICAgICBkZWxpbWl0ZXI6IGRlbGltXG4gICAgICB9KTtcbiAgICB9LFxuXG4gICAgZnVuY3Rpb24gc3RyKHApIHtcbiAgICAgIHJldHVybiB0aGlzLmxvb2t1cCgnZm9hbS5wYXJzZS5TdHJpbmcnKS5jcmVhdGUoe1xuICAgICAgICBwOiBwXG4gICAgICB9KTtcbiAgICB9LFxuXG4gICAgZnVuY3Rpb24gc3Vic3RyaW5nKHApIHtcbiAgICAgIHJldHVybiB0aGlzLmxvb2t1cCgnZm9hbS5wYXJzZS5TdWJzdHJpbmcnKS5jcmVhdGUoe1xuICAgICAgICBwOiBwXG4gICAgICB9KTtcbiAgICB9LFxuXG4gICAgZnVuY3Rpb24gcmFuZ2UoYSwgYikge1xuICAgICAgcmV0dXJuIHRoaXMubG9va3VwKCdmb2FtLnBhcnNlLlJhbmdlJykuY3JlYXRlKHtcbiAgICAgICAgZnJvbTogYSxcbiAgICAgICAgdG86IGJcbiAgICAgIH0pO1xuICAgIH0sXG5cbiAgICBmdW5jdGlvbiBub3RDaGFycyhzKSB7XG4gICAgICByZXR1cm4gdGhpcy5sb29rdXAoJ2ZvYW0ucGFyc2UuTm90Q2hhcnMnKS5jcmVhdGUoe1xuICAgICAgICBzdHJpbmc6IHNcbiAgICAgIH0pO1xuICAgIH0sXG5cbiAgICBmdW5jdGlvbiBjaGFycyhzKSB7XG4gICAgICByZXR1cm4gdGhpcy5sb29rdXAoJ2ZvYW0ucGFyc2UuQ2hhcnMnKS5jcmVhdGUoe1xuICAgICAgICBzdHJpbmc6IHNcbiAgICAgIH0pO1xuICAgIH0sXG5cbiAgICBmdW5jdGlvbiBub3QocCwgb3B0X2Vsc2UpIHtcbiAgICAgIHJldHVybiB0aGlzLmxvb2t1cCgnZm9hbS5wYXJzZS5Ob3QnKS5jcmVhdGUoe1xuICAgICAgICBwOiBwLFxuICAgICAgICBlbHNlOiBvcHRfZWxzZVxuICAgICAgfSk7XG4gICAgfSxcblxuICAgIGZ1bmN0aW9uIG9wdGlvbmFsKHApIHtcbiAgICAgIHJldHVybiB0aGlzLmxvb2t1cCgnZm9hbS5wYXJzZS5PcHRpb25hbCcpLmNyZWF0ZSh7XG4gICAgICAgIHA6IHBcbiAgICAgIH0pO1xuICAgIH0sXG5cbiAgICBmdW5jdGlvbiBsaXRlcmFsKHMsIHZhbHVlKSB7XG4gICAgICByZXR1cm4gdGhpcy5sb29rdXAoJ2ZvYW0ucGFyc2UuTGl0ZXJhbCcpLmNyZWF0ZSh7XG4gICAgICAgIHM6IHMsXG4gICAgICAgIHZhbHVlOiB2YWx1ZVxuICAgICAgfSk7XG4gICAgfSxcblxuICAgIGZ1bmN0aW9uIGxpdGVyYWxJQyhzLCB2YWx1ZSkge1xuICAgICAgcmV0dXJuIHRoaXMubG9va3VwKCdmb2FtLnBhcnNlLkxpdGVyYWxJQycpLmNyZWF0ZSh7XG4gICAgICAgIHM6IHMsXG4gICAgICAgIHZhbHVlOiB2YWx1ZVxuICAgICAgfSk7XG4gICAgfSxcblxuICAgIGZ1bmN0aW9uIGFueUNoYXIoKSB7XG4gICAgICByZXR1cm4gZm9hbS5wYXJzZS5BbnlDaGFyLmNyZWF0ZSgpO1xuICAgIH1cbiAgXVxufSk7XG5cblxuZm9hbS5DTEFTUyh7XG4gIHBhY2thZ2U6ICdmb2FtLnBhcnNlJyxcbiAgbmFtZTogJ1BTeW1ib2wnLFxuXG4gIHByb3BlcnRpZXM6IFsnbmFtZScsICdwYXJzZXInXVxufSk7XG5cblxuZm9hbS5DTEFTUyh7XG4gIHBhY2thZ2U6ICdmb2FtLnBhcnNlJyxcbiAgbmFtZTogJ0dyYW1tYXInLFxuXG4gIHJlcXVpcmVzOiBbXG4gICAgJ2ZvYW0ucGFyc2UuU3RyaW5nUFN0cmVhbScsXG4gICAgJ2ZvYW0ucGFyc2UuUGFyc2VycydcbiAgXSxcblxuICBwcm9wZXJ0aWVzOiBbXG4gICAge1xuICAgICAgY2xhc3M6ICdGT2JqZWN0QXJyYXknLFxuICAgICAgb2Y6ICdmb2FtLnBhcnNlLlBTeW1ib2wnLFxuICAgICAgbmFtZTogJ3N5bWJvbHMnLFxuICAgICAgYWRhcHQ6IGZ1bmN0aW9uKF8sIG8pIHtcbiAgICAgICAgaWYgKCBBcnJheS5pc0FycmF5KG8pICkgcmV0dXJuIG87XG5cbiAgICAgICAgaWYgKCB0eXBlb2YgbyA9PT0gJ2Z1bmN0aW9uJyApIHtcbiAgICAgICAgICB2YXIgYXJncyA9IG8udG9TdHJpbmcoKS5tYXRjaCgvXFwoKC4qPylcXCkvKTtcbiAgICAgICAgICBpZiAoICEgYXJncyApIHtcbiAgICAgICAgICAgIHRocm93ICdDb3VsZCBub3QgcGFyc2UgYXJndW1lbnRzIGZyb20gcGFyc2VyIGZhY3RvcnkgZnVuY3Rpb24nO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIG8gPSBmb2FtLkZ1bmN0aW9uLndpdGhBcmdzKG8sIHRoaXMuUGFyc2Vycy5jcmVhdGUoKSwgdGhpcyk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgYSA9IFtdO1xuICAgICAgICBmb3IgKCB2YXIga2V5IGluIG8gKSB7XG4gICAgICAgICAgYS5wdXNoKGZvYW0ucGFyc2UuUFN5bWJvbC5jcmVhdGUoe1xuICAgICAgICAgICAgbmFtZToga2V5LFxuICAgICAgICAgICAgcGFyc2VyOiBvW2tleV1cbiAgICAgICAgICB9KSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGE7XG4gICAgICB9XG4gICAgfSxcbiAgICB7XG4gICAgICBuYW1lOiAnc3ltYm9sTWFwXycsXG4gICAgICBleHByZXNzaW9uOiBmdW5jdGlvbihzeW1ib2xzKSB7XG4gICAgICAgIHZhciBtID0ge307XG4gICAgICAgIGZvciAoIHZhciBpID0gMCA7IGkgPCBzeW1ib2xzLmxlbmd0aCA7IGkrKyApIHtcbiAgICAgICAgICBpZiAoIG1bc3ltYm9sc1tpXS5uYW1lXSApIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0R1cGxpY2F0ZSBzeW1ib2wgZm91bmQnLCBzeW1ib2xzW2ldLm5hbWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBtW3N5bWJvbHNbaV0ubmFtZV0gPSBzeW1ib2xzW2ldO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtO1xuICAgICAgfVxuICAgIH0sXG4gICAge1xuICAgICAgbmFtZTogJ3BzJyxcbiAgICAgIGZhY3Rvcnk6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5TdHJpbmdQU3RyZWFtLmNyZWF0ZSgpO1xuICAgICAgfVxuICAgIH1cbiAgXSxcblxuICBtZXRob2RzOiBbXG4gICAgZnVuY3Rpb24gcGFyc2VTdHJpbmcoc3RyLCBvcHRfbmFtZSkge1xuICAgICAgdmFyIHJlc3VsdCA9IHRoaXMuZ2V0UGFyc2Uoc3RyLCBvcHRfbmFtZSk7XG4gICAgICByZXR1cm4gcmVzdWx0ICYmIHJlc3VsdC52YWx1ZTtcbiAgICB9LFxuXG4gICAgZnVuY3Rpb24gZ2V0UGFyc2Uoc3RyLCBvcHRfbmFtZSkge1xuICAgICAgb3B0X25hbWUgPSBvcHRfbmFtZSB8fCAnU1RBUlQnO1xuXG4gICAgICB0aGlzLnBzLnNldFN0cmluZyhzdHIpO1xuICAgICAgdmFyIHN0YXJ0ID0gdGhpcy5nZXRTeW1ib2wob3B0X25hbWUpO1xuICAgICAgZm9hbS5hc3NlcnQoc3RhcnQsICdObyBzeW1ib2wgZm91bmQgZm9yJywgb3B0X25hbWUpO1xuXG4gICAgICByZXR1cm4gdGhpcy5wcy5hcHBseShzdGFydCwgdGhpcyk7XG4gICAgfSxcblxuICAgIGZ1bmN0aW9uIGdldFN5bWJvbChuYW1lKSB7XG4gICAgICByZXR1cm4gdGhpcy5zeW1ib2xNYXBfW25hbWVdLnBhcnNlcjtcbiAgICB9LFxuXG4gICAgZnVuY3Rpb24gYWRkU3ltYm9sKG5hbWUsIHBhcnNlcikge1xuICAgICAgdGhpcy5zeW1ib2xzLnB1c2goZm9hbS5wYXJzZS5QU3ltYm9sLmNyZWF0ZSh7XG4gICAgICAgIG5hbWU6IG5hbWUsIHBhcnNlcjogcGFyc2VyXG4gICAgICB9KSk7XG4gICAgfSxcblxuICAgIGZ1bmN0aW9uIGFkZEFjdGlvbnMobWFwKSB7XG4gICAgICBmb3IgKCB2YXIga2V5IGluIG1hcCApIHtcbiAgICAgICAgdGhpcy5hZGRBY3Rpb24oa2V5LCBtYXBba2V5XSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgZnVuY3Rpb24gYWRkQWN0aW9uKG5hbWUsIGFjdGlvbikge1xuICAgICAgZm9yICggdmFyIGkgPSAwIDsgaSA8IHRoaXMuc3ltYm9scy5sZW5ndGggOyBpKysgKSB7XG4gICAgICAgIGlmICggdGhpcy5zeW1ib2xzW2ldLm5hbWUgPT09IG5hbWUgKSB7XG4gICAgICAgICAgdGhpcy5zeW1ib2xzW2ldLnBhcnNlciA9IGZvYW0ucGFyc2UuUGFyc2VyV2l0aEFjdGlvbi5jcmVhdGUoe1xuICAgICAgICAgICAgcDogdGhpcy5zeW1ib2xzW2ldLnBhcnNlcixcbiAgICAgICAgICAgIGFjdGlvbjogYWN0aW9uXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gVE9ETyhhZGFtdnkpOiBBcnJheSBwcm9wZXJ0eSBzaG91bGQgaGVscCBtZSBoZXJlXG4gICAgICB0aGlzLnB1YigncHJvcGVydHlDaGFuZ2UnLCAnc3ltYm9scycsIHRoaXMuc2xvdCgnc3ltYm9scycpKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgXVxufSk7XG5cbmZvYW0uQ0xBU1Moe1xuICBwYWNrYWdlOiAnZm9hbS5wYXJzZScsXG4gIG5hbWU6ICdHcmFtbWFyQXhpb20nLFxuICBwcm9wZXJ0aWVzOiBbXG4gICAge1xuICAgICAgY2xhc3M6ICdTdHJpbmcnLFxuICAgICAgbmFtZTogJ25hbWUnXG4gICAgfSxcbiAgICB7XG4gICAgICBjbGFzczogJ1N0cmluZycsXG4gICAgICBuYW1lOiAnbGFuZ3VhZ2UnLFxuICAgICAgdmFsdWU6ICdmb2FtLnBhcnNlLlBhcnNlcnMnXG4gICAgfSxcbiAgICB7XG4gICAgICBuYW1lOiAnc3ltYm9scydcbiAgICB9LFxuICAgIHtcbiAgICAgIGNsYXNzOiAnQXJyYXknLFxuICAgICAgbmFtZTogJ2FjdGlvbnMnXG4gICAgfSxcbiAgICB7XG4gICAgICBjbGFzczogJ0Jvb2xlYW4nLFxuICAgICAgZG9jdW1lbnRhdGlvbjogYFdoZW4gdHJ1ZSwgdXNlIGZvYW0uRnVuY3Rpb24ud2l0aEFyZ3MoKSB0byBldmFsdWF0ZVxuICAgICAgICAgIHN5bWJvbHMgZnVuY3Rpb24gaW4gaXRzIG9yaWdpbmFsIHNjcmlwdCBjbG9zdXJlIGNvbnRleHQuIE90aGVyd2lzZSxcbiAgICAgICAgICB1c2Ugd2l0aChsYW5ndWFnZSkgeyBldmFsKHN5bWJvbHMoKSk7IH0uYCxcbiAgICAgIG5hbWU6ICd3aXRoQXJncydcbiAgICB9XG4gIF0sXG4gIG1ldGhvZHM6IFtcbiAgICBmdW5jdGlvbiBpbnN0YWxsSW5Qcm90byhwcm90bykge1xuICAgICAgdmFyIG5hbWUgPSB0aGlzLm5hbWU7XG4gICAgICB2YXIgYXhpb20gPSB0aGlzO1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb3RvLCBuYW1lLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdmFyIGcgPSB0aGlzLmdldFByaXZhdGVfKG5hbWUpO1xuXG4gICAgICAgICAgaWYgKCAhIGcgKSB7XG4gICAgICAgICAgICB0aGlzLnNldFByaXZhdGVfKG5hbWUsIGcgPSBheGlvbS5idWlsZEdyYW1tYXIodGhpcykpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiB0aGlzLmdldFByaXZhdGVfKG5hbWUpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9LFxuICAgIGZ1bmN0aW9uIGJ1aWxkR3JhbW1hcihvYmopIHtcbiAgICAgIHZhciBnID0gb2JqLmxvb2t1cCgnZm9hbS5wYXJzZS5HcmFtbWFyJykuY3JlYXRlKG51bGwsIG9iaik7XG5cbiAgICAgIHZhciBzeW1ib2xzO1xuXG4gICAgICBpZiAoIHR5cGVvZiB0aGlzLnN5bWJvbHMgPT0gJ2Z1bmN0aW9uJyApIHtcbiAgICAgICAgdmFyIGxhbmd1YWdlID0gb2JqLmxvb2t1cCh0aGlzLmxhbmd1YWdlKS5jcmVhdGUoKTtcbiAgICAgICAgaWYgKHRoaXMud2l0aEFyZ3MpIHtcbiAgICAgICAgICBzeW1ib2xzID0gZm9hbS5GdW5jdGlvbi53aXRoQXJncyh0aGlzLnN5bWJvbHMsIGxhbmd1YWdlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB3aXRoKG9iai5sb29rdXAodGhpcy5sYW5ndWFnZSkuY3JlYXRlKCkpIHtcbiAgICAgICAgICAgIHN5bWJvbHMgPSBldmFsKCcoJyArIHRoaXMuc3ltYm9scy50b1N0cmluZygpICsgJykoKScpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3ltYm9scyA9IHRoaXMuc3ltYm9scztcbiAgICAgIH1cblxuICAgICAgZm9yICggdmFyIGtleSBpbiBzeW1ib2xzICkge1xuICAgICAgICBnLmFkZFN5bWJvbChrZXksIHN5bWJvbHNba2V5XSk7XG4gICAgICB9XG5cbiAgICAgIGZvciAoIHZhciBpID0gMCA7IGkgPCB0aGlzLmFjdGlvbnMubGVuZ3RoIDsgaSsrICkge1xuICAgICAgICBnLmFkZEFjdGlvbih0aGlzLmFjdGlvbnNbaV0ubmFtZSwgKHRoaXMuYWN0aW9uc1tpXS5jb2RlIHx8IHRoaXMuYWN0aW9uc1tpXSkuYmluZChvYmopKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGc7XG4gICAgfVxuICBdXG59KTtcblxuXG5mb2FtLkNMQVNTKHtcbiAgcmVmaW5lczogJ2ZvYW0uY29yZS5Nb2RlbCcsXG4gIHByb3BlcnRpZXM6IFtcbiAgICB7XG4gICAgICBjbGFzczogJ0F4aW9tQXJyYXknLFxuICAgICAgbmFtZTogJ2dyYW1tYXJzJyxcbiAgICAgIG9mOiAnZm9hbS5wYXJzZS5HcmFtbWFyQXhpb20nXG4gICAgfVxuICBdXG59KTtcblxuZm9hbS5DTEFTUyh7XG4gIHBhY2thZ2U6ICdmb2FtLnBhcnNlJyxcbiAgbmFtZTogJ0ltcGVyYXRpdmVHcmFtbWFyJyxcbiAgZXh0ZW5kczogJ2ZvYW0ucGFyc2UuR3JhbW1hcicsXG59KTtcblxuLypcblRPRE8oYWRhbXZ5KTpcbiAgLWRldGVjdCBub24gc3RyaW5nIHZhbHVlcyBwYXNzZWQgdG8gU3RyaW5nUFN0cmVhbS5zZXRTdHJpbmcoKVxuKi9cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IFRoZSBGT0FNIEF1dGhvcnMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmZvYW0uQ0xBU1Moe1xuICBwYWNrYWdlOiAnZm9hbS5wYXJzZS5qc29uJyxcbiAgbmFtZTogJ1N0cmluZycsXG5cbiAgY29uc3RhbnRzOiB7XG4gICAgQ0hBUl9DT0RFXzA6ICAgICAgICcwJy5jaGFyQ29kZUF0KDApLFxuICAgIENIQVJfQ09ERV85OiAgICAgICAnOScuY2hhckNvZGVBdCgwKSxcbiAgICBDSEFSX0NPREVfQV9MT1dFUjogJ2EnLmNoYXJDb2RlQXQoMCksXG4gICAgQ0hBUl9DT0RFX0ZfTE9XRVI6ICdmJy5jaGFyQ29kZUF0KDApLFxuICAgIENIQVJfQ09ERV9BX1VQUEVSOiAnQScuY2hhckNvZGVBdCgwKSxcbiAgICBDSEFSX0NPREVfRl9VUFBFUjogJ0YnLmNoYXJDb2RlQXQoMClcbiAgfSxcblxuICBwcm9wZXJ0aWVzOiBbXG4gICAge1xuICAgICAgY2xhc3M6ICdTdHJpbmcnLFxuICAgICAgbmFtZTogJ2VzY2FwZScsXG4gICAgICB2YWx1ZTogJ1xcXFwnXG4gICAgfSxcbiAgICB7XG4gICAgICBuYW1lOiAnZXNjYXBlQ2hhcnMnLFxuICAgICAgdmFsdWU6IHtcbiAgICAgICAgJ24nOiAnXFx1MDAwYScsXG4gICAgICAgICdmJzogJ1xcdTAwMGMnLFxuICAgICAgICAnYic6ICdcXHUwMDA4JyxcbiAgICAgICAgJ3InOiAnXFx1MDAwZCcsXG4gICAgICAgICd0JzogJ1xcdTAwMDknXG4gICAgICB9XG4gICAgfVxuICBdLFxuXG4gIG1ldGhvZHM6IFtcbiAgICBmdW5jdGlvbiBwYXJzZShwcywgb2JqKSB7XG4gICAgICB2YXIgZGVsaW0gPSBwcy5oZWFkO1xuICAgICAgdmFyIGVzY2FwZSA9IHRoaXMuZXNjYXBlO1xuXG4gICAgICBpZiAoIGRlbGltICE9PSAnXCInICYmIGRlbGltICE9PSBcIidcIiApIHJldHVybiB1bmRlZmluZWQ7XG5cbiAgICAgIHBzID0gcHMudGFpbDtcblxuICAgICAgdmFyIGxhc3RjID0gZGVsaW07XG4gICAgICB2YXIgc3RyID0gJyc7XG5cbiAgICAgIHdoaWxlICggcHMudmFsaWQgKSB7XG4gICAgICAgIHZhciBjID0gcHMuaGVhZDtcbiAgICAgICAgaWYgKCBjID09PSBkZWxpbSAmJiBsYXN0YyAhPT0gZXNjYXBlICkgYnJlYWs7XG5cbiAgICAgICAgaWYgKCBjICE9PSBlc2NhcGUgKSB7XG4gICAgICAgICAgc3RyICs9IGM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIG5leHQgPSBwcy50YWlsLmhlYWQ7XG4gICAgICAgICAgaWYgKCBuZXh0ID09PSBlc2NhcGUgKSB7XG4gICAgICAgICAgICAvLyBcIlxcXFxcIiBwYXJzZXMgdG8gXCJcXFwiLlxuICAgICAgICAgICAgc3RyICs9IGVzY2FwZTtcbiAgICAgICAgICAgIHBzID0gcHMudGFpbDtcbiAgICAgICAgICB9IGVsc2UgaWYgKCBwcy50YWlsLmhlYWQgPT09ICd1JyApIHtcbiAgICAgICAgICAgIC8vIFVuaWNvZGUgZXNjYXBlIHNlcXVlbmNlOiBcIlxcdSMjIyNcIi5cbiAgICAgICAgICAgIC8vIEV4dHJhY3QgXCIjIyNcIi5cbiAgICAgICAgICAgIHZhciBoZXhDaGFyQ29kZSA9IHBzLnRhaWwuc3RyWzBdLnN1YnN0cihwcy5wb3MgKyAyLCA0KTtcbiAgICAgICAgICAgIC8vIFZlcmlmeSB0aGF0IGVhY2ggY2hhcmFjdGVyIGluIHNlcXVlbmNlIGlzIGEgaGV4IGRpZ2l0LlxuICAgICAgICAgICAgZm9yICggdmFyIGkgPSAwOyBpIDwgaGV4Q2hhckNvZGUubGVuZ3RoOyBpKysgKSB7XG4gICAgICAgICAgICAgIHZhciBoZXhEaWdpdENoYXJDb2RlID0gaGV4Q2hhckNvZGUuY2hhckNvZGVBdChpKTtcbiAgICAgICAgICAgICAgaWYgKCAhIHRoaXMuaXNIZXhEaWdpdENoYXJDb2RlXyhoZXhEaWdpdENoYXJDb2RlKSApXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdGT04gc3RyaW5nIHBhcnNlIGVycm9yIGF0ICcgKyBwcy5wb3MgKyAnOiAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ0ludmFsaWQgdW5pY29kZSBlc2NhcGUgc2VxdWVuY2U6IFxcXFx1JyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhleENoYXJDb2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIENvbnN0cnVjdCBoZXggY2hhcmFjdGVyIGFuZCBhZGQgaXQgdG8gc3RyLlxuICAgICAgICAgICAgdmFyIGNoYXJDb2RlID0gcGFyc2VJbnQoaGV4Q2hhckNvZGUsIDE2KTtcbiAgICAgICAgICAgIGMgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGNoYXJDb2RlKTtcbiAgICAgICAgICAgIHN0ciArPSBjO1xuICAgICAgICAgICAgLy8gQWR2YW5jZSB0byBsYXN0IGNoYXIgaW4gXCJcXHUjIyMjXCIgZXNjYXBlIHNlcXVlbmNlLlxuICAgICAgICAgICAgcHMgPSBwcy50YWlsLnRhaWwudGFpbC50YWlsLnRhaWw7XG4gICAgICAgICAgfSBlbHNlIGlmICggdGhpcy5lc2NhcGVDaGFyc1twcy50YWlsLmhlYWRdICkge1xuICAgICAgICAgICAgYyA9IHRoaXMuZXNjYXBlQ2hhcnNbcHMudGFpbC5oZWFkXTtcbiAgICAgICAgICAgIHN0ciArPSBjO1xuICAgICAgICAgICAgcHMgPSBwcy50YWlsO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGxhc3RjID0gYztcbiAgICAgICAgcHMgPSBwcy50YWlsO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcHMudGFpbC5zZXRWYWx1ZShzdHIpO1xuICAgIH0sXG5cbiAgICBmdW5jdGlvbiBpc0hleERpZ2l0Q2hhckNvZGVfKGNoYXJDb2RlKSB7XG4gICAgICByZXR1cm4gKCAoIGNoYXJDb2RlID49IHRoaXMuQ0hBUl9DT0RFXzAgJiZcbiAgICAgICAgICAgICAgICAgY2hhckNvZGUgPD0gdGhpcy5DSEFSX0NPREVfOSApIHx8XG4gICAgICAgICAgICAgICAoIGNoYXJDb2RlID49IHRoaXMuQ0hBUl9DT0RFX0FfTE9XRVIgJiZcbiAgICAgICAgICAgICAgICAgY2hhckNvZGUgPD0gdGhpcy5DSEFSX0NPREVfRl9MT1dFUiApIHx8XG4gICAgICAgICAgICAgICAoIGNoYXJDb2RlID49IHRoaXMuQ0hBUl9DT0RFX0FfVVBQRVIgJiZcbiAgICAgICAgICAgICAgICAgY2hhckNvZGUgPD0gdGhpcy5DSEFSX0NPREVfRl9VUFBFUiApICk7XG4gICAgfVxuICBdXG59KTtcblxuXG5mb2FtLkNMQVNTKHtcbiAgcGFja2FnZTogJ2ZvYW0ucGFyc2UuanNvbicsXG4gIG5hbWU6ICdQYXJzZXJzJyxcbiAgZXh0ZW5kczogJ2ZvYW0ucGFyc2UuUGFyc2VycycsXG5cbiAgbWV0aG9kczogW1xuICAgIGZ1bmN0aW9uIHN0cmluZygpIHtcbiAgICAgIHJldHVybiBmb2FtLnBhcnNlLmpzb24uU3RyaW5nLmNyZWF0ZSgpO1xuICAgIH1cbiAgXVxufSk7XG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBUaGUgRk9BTSBBdXRob3JzLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5mb2FtLkNMQVNTKHtcbiAgcGFja2FnZTogJ2ZvYW0ucGFyc2VycycsXG4gIG5hbWU6ICdGT04nLFxuICBpbXBsZW1lbnRzOiBbICdmb2FtLmpzb24uUGFyc2VyJyBdLFxuICBwcm9wZXJ0aWVzOiBbXG4gICAge1xuICAgICAgbmFtZTogJ2NyZWF0aW9uQ29udGV4dCdcbiAgICB9XG4gIF0sXG4gIG1ldGhvZHM6IFtcbiAgICBmdW5jdGlvbiBwYXJzZVN0cmluZyhzdHIpIHtcbiAgICAgIHJldHVybiB0aGlzLnBhcnNlQ2xhc3NGcm9tU3RyaW5nKHN0ciwgbnVsbCk7XG4gICAgfSxcbiAgICBmdW5jdGlvbiBwYXJzZUNsYXNzRnJvbVN0cmluZyhzdHIsIG9wdF9jbHMpIHtcbiAgICAgIGZvYW0uYXNzZXJ0KHRoaXMuY3JlYXRpb25Db250ZXh0LCAnTm8gY3JlYXRpb24gY29udGV4dCBhc3NpZ25lZC4nKTtcblxuICAgICAgdmFyIHJlcyA9IHRoaXMuZ3JhbW1hci5wYXJzZVN0cmluZyhzdHIsICdvYmonKTtcbiAgICAgIGlmICggISByZXMgKSByZXR1cm4gbnVsbDtcbiAgICAgIHJldHVybiBmb2FtLmpzb24ucGFyc2UocmVzLCBvcHRfY2xzLCB0aGlzLmNyZWF0aW9uQ29udGV4dCk7XG4gICAgfVxuICBdLFxuICBncmFtbWFyczogW1xuICAgIHtcbiAgICAgIG5hbWU6ICdncmFtbWFyJyxcbiAgICAgIGxhbmd1YWdlOiAnZm9hbS5wYXJzZS5qc29uLlBhcnNlcnMnLFxuICAgICAgc3ltYm9sczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgJ29iaic6IHNlcTEoMyxcbiAgICAgICAgICAgICAgICAgICAgICBzeW0oJ3dzJyksXG4gICAgICAgICAgICAgICAgICAgICAneycsIHN5bSgnd3MnKSxcbiAgICAgICAgICAgICAgICAgICAgIHJlcGVhdChzeW0oJ2tleVZhbHVlJyksIHNlcTAoJywnLCBzeW0oJ3dzJykpKSxcbiAgICAgICAgICAgICAgICAgICAgIHN5bSgnd3MnKSxcbiAgICAgICAgICAgICAgICAgICAgICd9JyxcbiAgICAgICAgICAgICAgICAgICAgIHN5bSgnd3MnKSksXG4gICAgICAgICAgJ2tleVZhbHVlJzogc2VxKHN5bSgna2V5JyksIHN5bSgnd3MnKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgJzonLCBzeW0oJ3dzJyksXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHN5bSgndmFsdWUnKSwgc3ltKCd3cycpKSxcblxuICAgICAgICAgICdrZXknOiBhbHQoc3RyaW5nKCksXG4gICAgICAgICAgICAgICAgICAgICBzeW0oJ2lkZW50aWZpZXInKSksXG5cbiAgICAgICAgICAnd3MnOiByZXBlYXQwKGNoYXJzKCcgXFx0XFxyXFxuJykpLFxuXG4gICAgICAgICAgLy8gVE9ETzogU3VwcG9ydCBhbGwgdmFsaWQgY2hhcmFjdGVycywgc2hvdWxkIGNvbnN1bHQgdW5pY29kZSB0YWJsZXMgZm9yIHRoaW5ncyBsaWtlIElEX1N0YXJ0XG4gICAgICAgICAgJ2lkX3N0YXJ0JzogYWx0KFxuICAgICAgICAgICAgcmFuZ2UoJ2EnLCAneicpLFxuICAgICAgICAgICAgcmFuZ2UoJ0EnLCAnWicpLFxuICAgICAgICAgICAgJ18nLFxuICAgICAgICAgICAgJyQnKSxcblxuICAgICAgICAgICdpZGVudGlmaWVyJzogc3Vic3RyaW5nKHNlcTAoXG4gICAgICAgICAgICBzeW0oJ2lkX3N0YXJ0JyksXG4gICAgICAgICAgICByZXBlYXQwKGFsdChyYW5nZSgnMCcsICc5JyksIHN5bSgnaWRfc3RhcnQnKSkpKSksXG5cbiAgICAgICAgICAndmFsdWUnOiBhbHQoXG4gICAgICAgICAgICBzdHJpbmcoKSxcbiAgICAgICAgICAgIHN5bSgnbnVsbCcpLFxuICAgICAgICAgICAgc3ltKCd1bmRlZmluZWQnKSxcbiAgICAgICAgICAgIHN5bSgnbnVtYmVyJyksXG4gICAgICAgICAgICBzeW0oJ2Jvb2wnKSxcbiAgICAgICAgICAgIHN5bSgnYXJyYXknKSxcbiAgICAgICAgICAgIHN5bSgnb2JqJykpLFxuXG4gICAgICAgICAgJ251bGwnOiBsaXRlcmFsKCdudWxsJywgbnVsbCksXG4gICAgICAgICAgJ3VuZGVmaW5lZCc6IGxpdGVyYWwoJ3VuZGVmaW5lZCcsIHVuZGVmaW5lZCksXG4gICAgICAgICAgJ251bWJlcic6IHN1YnN0cmluZyhzZXEwKG9wdGlvbmFsKCctJyksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcGVhdDAocmFuZ2UoJzAnLCAnOScpLCBudWxsLCAxKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9uYWwoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VxMCgnLicsIHJlcGVhdDAocmFuZ2UoJzAnLCAnOScpKSkpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25hbChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXEwKCdlJywgYWx0KCctJywgJysnKSwgcmVwZWF0MChyYW5nZSgnMCcsICc5JykpKSkpKSxcbiAgICAgICAgICAnYm9vbCc6IGFsdChsaXRlcmFsKCd0cnVlJywgdHJ1ZSksXG4gICAgICAgICAgICAgICAgICAgICAgbGl0ZXJhbCgnZmFsc2UnLCBmYWxzZSkpLFxuXG4gICAgICAgICAgJ2FycmF5Jzogc2VxMSgyLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ1snLCBzeW0oJ3dzJyksXG4gICAgICAgICAgICAgICAgICAgICAgICByZXBlYXQoc3ltKCd2YWx1ZScpLCBzZXEwKCcsJywgc3ltKCd3cycpKSksIHN5bSgnd3MnKSxcbiAgICAgICAgICAgICAgICAgICAgICAgJ10nLCBzeW0oJ3dzJykpXG4gICAgICAgIH07XG4gICAgICB9LFxuICAgICAgYWN0aW9uczogW1xuICAgICAgICBmdW5jdGlvbiBvYmooYSkge1xuICAgICAgICAgIHZhciBvYmogPSB7fTtcbiAgICAgICAgICBmb3IgKCB2YXIgaSA9IDAgOyBpIDwgYS5sZW5ndGggOyBpKysgKSB7XG4gICAgICAgICAgICBvYmpbYVtpXVswXV0gPSBhW2ldWzRdO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gb2JqXG4gICAgICAgIH0sXG4gICAgICAgIGZ1bmN0aW9uIG51bWJlcihhKSB7XG4gICAgICAgICAgcmV0dXJuIHBhcnNlRmxvYXQoYSk7XG4gICAgICAgIH1cbiAgICAgIF1cbiAgICB9XG4gIF1cbn0pO1xuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTYgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuZm9hbS5DTEFTUyh7XG4gIHBhY2thZ2U6ICdmb2FtLnRlbXBsYXRlcycsXG4gIG5hbWU6ICdUZW1wbGF0ZU91dHB1dCcsXG5cbiAgZG9jdW1lbnRhdGlvbjogJ0EgYnVmZmVyIGZvciBzdG9yaW5nIFRlbXBsYXRlIG91dHB1dC4nLFxuXG4gIHByb3BlcnRpZXM6IFtcbiAgICB7XG4gICAgICBuYW1lOiAnYnVmJyxcbiAgICAgIGZhY3Rvcnk6IGZ1bmN0aW9uKCkgeyByZXR1cm4gW107IH1cbiAgICB9XG4gIF0sXG5cbiAgbWV0aG9kczogW1xuICAgIGZ1bmN0aW9uIG91dHB1dCgpIHtcbiAgICAgIGZvciAoIHZhciBpID0gMCA7IGkgPCBhcmd1bWVudHMubGVuZ3RoIDsgaSsrICkge1xuICAgICAgICB2YXIgbyA9IGFyZ3VtZW50c1tpXTtcblxuICAgICAgICBpZiAoIHR5cGVvZiBvID09PSAnb2JqZWN0JyApIHtcbiAgICAgICAgICB0aGlzLmJ1Zi5wdXNoKG8udG9TdHJpbmcoKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5idWYucHVzaChvKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICAgIHJldHVybiB0aGlzLmJ1Zi5sZW5ndGggPT0gMCA/ICcnIDpcbiAgICAgICAgdGhpcy5idWYubGVuZ3RoID09IDEgPyB0aGlzLmJ1ZlswXSA6XG4gICAgICAgIHRoaXMuYnVmLmpvaW4oJycpO1xuICAgIH1cbiAgXVxufSk7XG5cblxuZm9hbS5DTEFTUyh7XG4gIHBhY2thZ2U6ICdmb2FtLnRlbXBsYXRlcycsXG4gIG5hbWU6ICdUZW1wbGF0ZVV0aWwnLFxuXG4gIGRvY3VtZW50YXRpb246ICdVdGlsaXR5IG1ldGhvZHMgZm9yIHdvcmtpbmcgd2l0aCBUZW1wbGF0ZXMuIE1vc3RseSBqdXN0IGZvciBpbnRlcm5hbCB1c2UuJyxcblxuICBheGlvbXM6IFsgZm9hbS5wYXR0ZXJuLlNpbmdsZXRvbi5jcmVhdGUoKSBdLFxuXG4gIHJlcXVpcmVzOiBbXG4gICAgJ2ZvYW0ucGFyc2UuSW1wZXJhdGl2ZUdyYW1tYXIgYXMgR3JhbW1hcidcbiAgXSxcblxuICBjb25zdGFudHM6IHtcbiAgICBIRUFERVI6ICd2YXIgc2VsZiA9IHRoaXMsIGN0eCA9IHRoaXMuX19jb250ZXh0X18sIFkgPSB0aGlzLl9fc3ViQ29udGV4dF9fO1xcbicgK1xuICAgICAgJ3ZhciBvdXRwdXQgPSBvcHRfb3V0cHV0dGVyID8gb3B0X291dHB1dHRlciA6IFRPQyh0aGlzKTtcXG4nICtcbiAgICAgICd2YXIgb3V0ID0gb3V0cHV0Lm91dHB1dC5iaW5kKG91dHB1dCk7XFxuJyArXG4gICAgICBcIm91dCgnXCIsXG4gICAgRk9PVEVSOiBcIicpO1xcbnJldHVybiBvcHRfb3V0cHV0dGVyID8gb3V0cHV0IDogb3V0cHV0LnRvU3RyaW5nKCk7XFxuXCJcbiAgfSxcblxuICBwcm9wZXJ0aWVzOiBbXG4gICAge1xuICAgICAgbmFtZTogJ2dyYW1tYXInLFxuICAgICAgZmFjdG9yeTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBnID0gdGhpcy5HcmFtbWFyLmNyZWF0ZSh7XG4gICAgICAgICAgc3ltYm9sczogZnVuY3Rpb24ocmVwZWF0MCwgc2ltcGxlQWx0LCBzeW0sIHNlcTEsIHNlcSwgcmVwZWF0LCBub3RDaGFycywgYW55Q2hhciwgbm90LCBvcHRpb25hbCwgbGl0ZXJhbCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgU1RBUlQ6IHN5bSgnbWFya3VwJyksXG5cbiAgICAgICAgICAgICAgbWFya3VwOiByZXBlYXQwKHNpbXBsZUFsdChcbiAgICAgICAgICAgICAgICBzeW0oJ2NvbW1lbnQnKSxcbiAgICAgICAgICAgICAgICBzeW0oJ3NpbXBsZSB2YWx1ZScpLFxuICAgICAgICAgICAgICAgIHN5bSgncmF3IHZhbHVlcyB0YWcnKSxcbiAgICAgICAgICAgICAgICBzeW0oJ2NvZGUgdGFnJyksXG4gICAgICAgICAgICAgICAgc3ltKCdpZ25vcmVkIG5ld2xpbmUnKSxcbiAgICAgICAgICAgICAgICBzeW0oJ25ld2xpbmUnKSxcbiAgICAgICAgICAgICAgICBzeW0oJ3NpbmdsZSBxdW90ZScpLFxuICAgICAgICAgICAgICAgIHN5bSgndGV4dCcpXG4gICAgICAgICAgICAgICkpLFxuXG4gICAgICAgICAgICAgICdjb21tZW50Jzogc2VxMSgxLCAnPCEtLScsIHJlcGVhdDAobm90KCctLT4nLCBhbnlDaGFyKCkpKSwgJy0tPicpLFxuXG4gICAgICAgICAgICAgICdzaW1wbGUgdmFsdWUnOiBzZXEoJyUlJywgcmVwZWF0KG5vdENoYXJzKCcgKCktXCJcXHJcXG4+PDo7LCcpKSwgb3B0aW9uYWwoJygpJykpLFxuXG4gICAgICAgICAgICAgICdyYXcgdmFsdWVzIHRhZyc6IHNpbXBsZUFsdChcbiAgICAgICAgICAgICAgICBzZXEoJzwlPScsIHJlcGVhdChub3QoJyU+JywgYW55Q2hhcigpKSksICclPicpXG4gICAgICAgICAgICAgICksXG5cbiAgICAgICAgICAgICAgJ2NvZGUgdGFnJzogc2VxKCc8JScsIHJlcGVhdChub3QoJyU+JywgYW55Q2hhcigpKSksICclPicpLFxuICAgICAgICAgICAgICAnaWdub3JlZCBuZXdsaW5lJzogc2ltcGxlQWx0KFxuICAgICAgICAgICAgICAgIGxpdGVyYWwoJ1xcXFxcXHJcXFxcXFxuJyksXG4gICAgICAgICAgICAgICAgbGl0ZXJhbCgnXFxcXFxcbicpXG4gICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgIG5ld2xpbmU6IHNpbXBsZUFsdChcbiAgICAgICAgICAgICAgICBsaXRlcmFsKCdcXHJcXG4nKSxcbiAgICAgICAgICAgICAgICBsaXRlcmFsKCdcXG4nKVxuICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAnc2luZ2xlIHF1b3RlJzogbGl0ZXJhbChcIidcIiksXG4gICAgICAgICAgICAgIHRleHQ6IGFueUNoYXIoKVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgICAgIGcuYWRkQWN0aW9ucyh7XG4gICAgICAgICAgbWFya3VwOiBmdW5jdGlvbih2KSB7XG4gICAgICAgICAgICB2YXIgd2FzU2ltcGxlID0gc2VsZi5zaW1wbGU7XG4gICAgICAgICAgICB2YXIgcmV0ID0gd2FzU2ltcGxlID8gbnVsbCA6IHNlbGYub3V0LmpvaW4oJycpO1xuICAgICAgICAgICAgc2VsZi5vdXQgPSBbXTtcbiAgICAgICAgICAgIHNlbGYuc2ltcGxlID0gdHJ1ZTtcbiAgICAgICAgICAgIHJldHVybiBbd2FzU2ltcGxlLCByZXRdO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgJ3NpbXBsZSB2YWx1ZSc6IGZ1bmN0aW9uKHYpIHtcbiAgICAgICAgICAgIHNlbGYucHVzaChcIicsXFxuIHNlbGYuXCIsXG4gICAgICAgICAgICAgICAgdlsxXS5qb2luKCcnKSxcbiAgICAgICAgICAgICAgICB2WzJdLFxuICAgICAgICAgICAgICAgIFwiLFxcbidcIik7XG4gICAgICAgICAgfSxcbiAgICAgICAgICAncmF3IHZhbHVlcyB0YWcnOiBmdW5jdGlvbiAodikge1xuICAgICAgICAgICAgc2VsZi5wdXNoKFwiJyxcXG5cIixcbiAgICAgICAgICAgICAgICB2WzFdLmpvaW4oJycpLFxuICAgICAgICAgICAgICAgIFwiLFxcbidcIik7XG4gICAgICAgICAgfSxcbiAgICAgICAgICAnY29kZSB0YWcnOiBmdW5jdGlvbiAodikge1xuICAgICAgICAgICAgc2VsZi5wdXNoKFwiJyk7XFxuXCIsXG4gICAgICAgICAgICAgICAgdlsxXS5qb2luKCcnKSxcbiAgICAgICAgICAgICAgICBcIjtvdXQoJ1wiKTtcbiAgICAgICAgICB9LFxuICAgICAgICAgICdzaW5nbGUgcXVvdGUnOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHNlbGYucHVzaChcIlxcXFwnXCIpO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgbmV3bGluZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBzZWxmLnB1c2goJ1xcXFxuJyk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICB0ZXh0OiBmdW5jdGlvbih2KSB7XG4gICAgICAgICAgICBzZWxmLnB1c2hTaW1wbGUodik7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGc7XG4gICAgICB9XG4gICAgfSxcbiAgICB7XG4gICAgICBuYW1lOiAnb3V0JyxcbiAgICAgIGZhY3Rvcnk6IGZ1bmN0aW9uKCkgeyByZXR1cm4gW107IH1cbiAgICB9LFxuICAgIHtcbiAgICAgIG5hbWU6ICdzaW1wbGUnLFxuICAgICAgdmFsdWU6IHRydWVcbiAgICB9XG4gIF0sXG5cbiAgbWV0aG9kczogW1xuICAgIGZ1bmN0aW9uIHB1c2goKSB7XG4gICAgICB0aGlzLnNpbXBsZSA9IGZhbHNlO1xuICAgICAgdGhpcy5wdXNoU2ltcGxlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfSxcblxuICAgIGZ1bmN0aW9uIHB1c2hTaW1wbGUoKSB7XG4gICAgICB0aGlzLm91dC5wdXNoLmFwcGx5KHRoaXMub3V0LCBhcmd1bWVudHMpO1xuICAgIH0sXG5cbiAgICBmdW5jdGlvbiBjb21waWxlKHQsIG5hbWUsIGFyZ3MpIHtcbiAgICAgIHZhciByZXN1bHQgPSB0aGlzLmdyYW1tYXIucGFyc2VTdHJpbmcodCk7XG4gICAgICBpZiAoICEgcmVzdWx0ICkgdGhyb3cgXCJFcnJvciBwYXJzaW5nIHRlbXBsYXRlIFwiICsgbmFtZTtcblxuICAgICAgdmFyIGNvZGUgPSB0aGlzLkhFQURFUiArXG4gICAgICAgICAgKCByZXN1bHRbMF0gPyB0IDogcmVzdWx0WzFdICkgK1xuICAgICAgICAgIHRoaXMuRk9PVEVSO1xuXG4gICAgICB2YXIgbmV3QXJncyA9IFsnb3B0X291dHB1dHRlciddLmNvbmNhdChhcmdzLm1hcChmdW5jdGlvbihhKSB7IHJldHVybiBhLm5hbWUgfHwgYSB9KSk7XG4gICAgICB2YXIgZiA9IGV2YWwoXG4gICAgICAgICcoZnVuY3Rpb24oKSB7ICcgK1xuICAgICAgICAgICd2YXIgVE9DID0gZnVuY3Rpb24obykgeyByZXR1cm4gZm9hbS50ZW1wbGF0ZXMuVGVtcGxhdGVPdXRwdXQuY3JlYXRlKCk7IH07JyArXG4gICAgICAgICAgJ3ZhciBmID0gZnVuY3Rpb24oJyArIG5ld0FyZ3Muam9pbignLCcpICsgJyl7JyArIGNvZGUgKyAnfTsnICtcbiAgICAgICAgICAncmV0dXJuIGZ1bmN0aW9uKCkgeyAnK1xuICAgICAgICAgICdpZiAoIGFyZ3VtZW50cy5sZW5ndGggJiYgYXJndW1lbnRzWzBdICYmICEgYXJndW1lbnRzWzBdLm91dHB1dCApIHJldHVybiBmLmFwcGx5KHRoaXMsIFt1bmRlZmluZWRdLmNvbmNhdChBcnJheS5mcm9tKGFyZ3VtZW50cykpKTsnICtcbiAgICAgICAgICAncmV0dXJuIGYuYXBwbHkodGhpcywgYXJndW1lbnRzKTt9O30pKCknKTtcblxuICAgICAgcmV0dXJuIGY7XG4gICAgfSxcblxuICAgIGZ1bmN0aW9uIGxhenlDb21waWxlKHQsIG5hbWUsIGFyZ3MpIHtcbiAgICAgIHJldHVybiAoZnVuY3Rpb24odXRpbCkge1xuICAgICAgICB2YXIgZGVsZWdhdGU7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgICBpZiAoICEgZGVsZWdhdGUgKSBkZWxlZ2F0ZSA9IHV0aWwuY29tcGlsZSh0LCBuYW1lLCBhcmdzKVxuICAgICAgICAgIHJldHVybiBkZWxlZ2F0ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB9O1xuICAgICAgfSkodGhpcyk7XG4gICAgfVxuICBdXG59KTtcblxuXG5mb2FtLkNMQVNTKHtcbiAgcGFja2FnZTogJ2ZvYW0udGVtcGxhdGVzJyxcbiAgbmFtZTogJ1RlbXBsYXRlQXhpb20nLFxuICBleHRlbmRzOiAnTWV0aG9kJyxcblxuICBwcm9wZXJ0aWVzOiBbXG4gICAge1xuICAgICAgbmFtZTogJ3RlbXBsYXRlJyxcbiAgICAgIGNsYXNzOiAnU3RyaW5nJ1xuICAgIH0sXG4gICAgeyBuYW1lOiAnY29kZScsIHJlcXVpcmVkOiBmYWxzZSB9LFxuICAgICdhcmdzJ1xuICBdLFxuXG4gIG1ldGhvZHM6IFtcbiAgICBmdW5jdGlvbiBpbnN0YWxsSW5Qcm90byhwcm90bykge1xuICAgICAgcHJvdG9bdGhpcy5uYW1lXSA9XG4gICAgICAgICAgZm9hbS50ZW1wbGF0ZXMuVGVtcGxhdGVVdGlsLmNyZWF0ZSgpLmxhenlDb21waWxlKFxuICAgICAgICAgICAgICB0aGlzLnRlbXBsYXRlLCB0aGlzLm5hbWUsIHRoaXMuYXJncyB8fCBbXSk7XG4gICAgfVxuICBdXG59KTtcblxuXG5mb2FtLkNMQVNTKHtcbiAgcGFja2FnZTogJ2ZvYW0udGVtcGxhdGVzJyxcbiAgbmFtZTogJ1RlbXBsYXRlRXh0ZW5zaW9uJyxcbiAgcmVmaW5lczogJ2ZvYW0uY29yZS5Nb2RlbCcsXG5cbiAgcHJvcGVydGllczogW1xuICAgIHtcbiAgICAgIG5hbWU6ICd0ZW1wbGF0ZXMnLFxuICAgICAgY2xhc3M6ICdBeGlvbUFycmF5JyxcbiAgICAgIG9mOiAnZm9hbS50ZW1wbGF0ZXMuVGVtcGxhdGVBeGlvbScsXG4gICAgICBhZGFwdEFycmF5RWxlbWVudDogZnVuY3Rpb24obywgcHJvcCkge1xuICAgICAgICByZXR1cm4gdGhpcy5sb29rdXAocHJvcC5vZikuY3JlYXRlKG8pO1xuICAgICAgfVxuICAgIH1cbiAgXVxufSk7XG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5mb2FtLmxvY2FsZSA9IGZvYW0ubG9jYWxlIHx8ICdlbic7XG5cbmZvYW0uQ0xBU1Moe1xuICBwYWNrYWdlOiAnZm9hbS5pMThuJyxcbiAgbmFtZTogJ01lc3NhZ2VBeGlvbScsXG5cbiAgcHJvcGVydGllczogW1xuICAgIHtcbiAgICAgIGNsYXNzOiAnU3RyaW5nJyxcbiAgICAgIG5hbWU6ICduYW1lJ1xuICAgIH0sXG4gICAge1xuICAgICAgY2xhc3M6ICdTdHJpbmcnLFxuICAgICAgbmFtZTogJ2Rlc2NyaXB0aW9uJ1xuICAgIH0sXG4gICAge1xuICAgICAgY2xhc3M6ICdPYmplY3QnLFxuICAgICAgbmFtZTogJ21lc3NhZ2VNYXAnLFxuICAgICAgaGVscDogJ01hcCBvZiBsYW5ndWFnZSBjb2RlcyB0byB0aGUgbWVzc2FnZSBpbiB0aGF0IGxhbmd1YWdlLicsXG4gICAgICBmYWN0b3J5OiBmdW5jdGlvbigpIHsgcmV0dXJuIHt9OyB9XG4gICAgfSxcbiAgICB7XG4gICAgICBjbGFzczogJ1N0cmluZycsXG4gICAgICBuYW1lOiAnbWVzc2FnZScsXG4gICAgICBnZXR0ZXI6IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcy5tZXNzYWdlXyB8fCB0aGlzLm1lc3NhZ2VNYXBbZm9hbS5sb2NhbGVdOyB9LFxuICAgICAgc2V0dGVyOiBmdW5jdGlvbihtKSB7IHRoaXMubWVzc2FnZV8gPSB0aGlzLm1lc3NhZ2VNYXBbZm9hbS5sb2NhbGVdID0gbTsgfVxuICAgIH0sXG4gICAge1xuICAgICAgY2xhc3M6ICdTaW1wbGUnLFxuICAgICAgbmFtZTogJ21lc3NhZ2VfJ1xuICAgIH1cbiAgXSxcblxuICBtZXRob2RzOiBbXG4gICAgZnVuY3Rpb24gaW5zdGFsbEluQ2xhc3MoY2xzKSB7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoXG4gICAgICAgIGNscyxcbiAgICAgICAgdGhpcy5uYW1lLFxuICAgICAgICB7XG4gICAgICAgICAgdmFsdWU6IHRoaXMubWVzc2FnZSxcbiAgICAgICAgICBjb25maWd1cmFibGU6IGZhbHNlXG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICBmdW5jdGlvbiBpbnN0YWxsSW5Qcm90byhwcm90bykge1xuICAgICAgdGhpcy5pbnN0YWxsSW5DbGFzcyhwcm90byk7XG4gICAgfVxuICBdXG59KTtcblxuXG5mb2FtLkNMQVNTKHtcbiAgcGFja2FnZTogJ2ZvYW0uaTE4bicsXG4gIG5hbWU6ICdNZXNzYWdlc0V4dGVuc2lvbicsXG4gIHJlZmluZXM6ICdmb2FtLmNvcmUuTW9kZWwnLFxuXG4gIHByb3BlcnRpZXM6IFtcbiAgICB7XG4gICAgICBuYW1lOiAnbWVzc2FnZXMnLFxuICAgICAgY2xhc3M6ICdBeGlvbUFycmF5JyxcbiAgICAgIG9mOiAnZm9hbS5pMThuLk1lc3NhZ2VBeGlvbSdcbiAgICB9XG4gIF1cbn0pO1xuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTYgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuLyoqXG4gIEFjdGlvbnMgYXJlIGhpZ2gtbGV2ZWwgZXhlY3V0YWJsZSBiZWhhdmlvdXJzIHRoYXQgYXJlIHR5cGljYWxseVxuICB0cmlnZ2VyZWQgYnkgdXNlcnMgYW5kIHJlcHJlc2VudGVkIGFzIGJ1dHRvbnMgb3IgbWVudXMuXG5cbiAgQWN0aW9ucyBhcmUgaW5zdGFsbGVkIGFzIG1ldGhvZHMgb24gdGhlIGNsYXNzLCBidXQgY29udGFpbiBtb3JlXG4gIG1ldGEtaW5mb3JtYXRpb24gdGhhbiByZWd1bGFyIG1ldGhvZHMuIE1ldGEtaW5mb3JtYXRpb24gaW5jbHVkZXNcbiAgaW5mb3JtYXRpb24gbmVlZGVkIHRvIHN1cmZhY2UgdG8gYWN0aW9uIGluIGEgbWVhbmluZ2Z1bCB3YXkgdG9cbiAgdXNlcnMsIGFuZCBpbmNsdWRlcyB0aGluZ3MgbGlrZSB0aGUgbGFiZWwgdG8gYXBwZWFyIGluIHRoZSBidXR0b25cbiAgb3IgbWVudSwgYSBzcGVlY2gtbGFiZWwgZm9yIGkxOG4sIGhlbHAgdGV4dCwgZHluYW1pYyBmdW5jdGlvbnMgdG9cbiAgZW5hYmxlIG9yIGRpc2FibGUgYW5kIGhpZGUgb3IgdW5oaWRlIHRoZSBVSSBhc3NvY2lhdGVkIHdpdGggdGhpcyBBY3Rpb24uXG5cbiAgQWN0aW9ucyBpbXBsZW1lbnQgdGhlIEFjdGlvbiBEZXNpZ24gUGF0dGVybi5cbiovXG5mb2FtLkNMQVNTKHtcbiAgcGFja2FnZTogJ2ZvYW0uY29yZScsXG4gIG5hbWU6ICdBY3Rpb24nLFxuXG4gIGRvY3VtZW50YXRpb246ICdBbiBBY3Rpb24gaXMgYSBtZXRob2Qgd2l0aCBleHRyYSBHVUkgc3VwcG9ydC4nLFxuXG4gIHByb3BlcnRpZXM6IFtcbiAgICB7XG4gICAgICBjbGFzczogJ1N0cmluZycsXG4gICAgICBuYW1lOiAnbmFtZScsXG4gICAgICByZXF1aXJlZDogdHJ1ZVxuICAgIH0sXG4gICAge1xuICAgICAgY2xhc3M6ICdTdHJpbmcnLFxuICAgICAgbmFtZTogJ2xhYmVsJyxcbiAgICAgIGV4cHJlc3Npb246IGZ1bmN0aW9uKG5hbWUpIHsgcmV0dXJuIGZvYW0uU3RyaW5nLmxhYmVsaXplKG5hbWUpOyB9XG4gICAgfSxcbiAgICB7XG4gICAgICBjbGFzczogJ1N0cmluZycsXG4gICAgICBuYW1lOiAnc3BlZWNoTGFiZWwnLFxuICAgICAgZXhwcmVzc2lvbjogZnVuY3Rpb24obGFiZWwpIHsgcmV0dXJuIGxhYmVsOyB9XG4gICAgfSxcbiAgICB7XG4gICAgICBkb2N1bWVudGF0aW9uOiAnZGlzcGxheWVkIG9uIDpob3ZlcicsXG4gICAgICBjbGFzczogJ1N0cmluZycsXG4gICAgICBuYW1lOiAndG9vbFRpcCcsXG4gICAgICBleHByZXNzaW9uOiBmdW5jdGlvbihsYWJlbCkgeyByZXR1cm4gbGFiZWw7IH1cbiAgICB9LFxuICAgIHtcbiAgICAgIG5hbWU6ICdpY29uJ1xuICAgIH0sXG4gICAge1xuICAgICAgY2xhc3M6ICdCb29sZWFuJyxcbiAgICAgIG5hbWU6ICdjb25maXJtYXRpb25SZXF1aXJlZCcsXG4gICAgICBkb2N1bWVudGF0aW9uOiAnSWYgY29uZmlybWF0aW9uIGlzIHJlcXVpcmVkLiBSZWNvbW1lbmRlZCBmb3IgZGVzdHJ1Y3RpdmUgYWN0aW9ucy4nXG4gICAgfSxcbiAgICB7XG4gICAgICBjbGFzczogJ1N0cmluZycsXG4gICAgICBuYW1lOiAnaWNvbkZvbnRGYW1pbHknLFxuICAgICAgdmFsdWU6ICdNYXRlcmlhbCBJY29ucydcbiAgICB9LFxuICAgIHtcbiAgICAgIGNsYXNzOiAnU3RyaW5nJyxcbiAgICAgIG5hbWU6ICdpY29uRm9udENsYXNzJyxcbiAgICAgIHZhbHVlOiAnbWF0ZXJpYWwtaWNvbnMnXG4gICAgfSxcbiAgICB7XG4gICAgICBjbGFzczogJ1N0cmluZycsXG4gICAgICBuYW1lOiAnaWNvbkZvbnROYW1lJ1xuICAgIH0sXG4gICAge1xuICAgICAgY2xhc3M6ICdBcnJheScsXG4gICAgICBuYW1lOiAna2V5Ym9hcmRTaG9ydGN1dHMnXG4gICAgfSxcbiAgICB7XG4gICAgICBjbGFzczogJ1N0cmluZycsXG4gICAgICBuYW1lOiAnaGVscCdcbiAgICB9LFxuICAgIHtcbiAgICAgIGNsYXNzOiAnQm9vbGVhbicsXG4gICAgICBuYW1lOiAnaXNEZWZhdWx0JyxcbiAgICAgIGhlbHA6ICdJbmRpY2F0ZXMgaWYgdGhpcyBpcyB0aGUgZGVmYXVsdCBhY3Rpb24uJyxcbiAgICAgIHZhbHVlOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgY2xhc3M6ICdGdW5jdGlvbicsXG4gICAgICBuYW1lOiAnaXNBdmFpbGFibGUnLFxuICAgICAgbGFiZWw6ICdBdmFpbGFibGUnLFxuICAgICAgaGVscDogJ0Z1bmN0aW9uIHRvIGRldGVybWluZSBpZiBhY3Rpb24gaXMgYXZhaWxhYmxlLicsXG4gICAgICB2YWx1ZTogbnVsbFxuICAgIH0sXG4gICAge1xuICAgICAgY2xhc3M6ICdGdW5jdGlvbicsXG4gICAgICBuYW1lOiAnaXNFbmFibGVkJyxcbiAgICAgIGxhYmVsOiAnRW5hYmxlZCcsXG4gICAgICBoZWxwOiAnRnVuY3Rpb24gdG8gZGV0ZXJtaW5lIGlmIGFjdGlvbiBpcyBlbmFibGVkLicsXG4gICAgICB2YWx1ZTogbnVsbFxuICAgIH0sXG4gICAge1xuICAgICAgY2xhc3M6ICdGdW5jdGlvbicsXG4gICAgICBuYW1lOiAnY29kZScsXG4gICAgICByZXF1aXJlZDogdHJ1ZSxcbiAgICAgIHZhbHVlOiBudWxsXG4gICAgfVxuICBdLFxuXG4gIG1ldGhvZHM6IFtcbiAgICBmdW5jdGlvbiBpc0VuYWJsZWRGb3IoZGF0YSkge1xuICAgICAgcmV0dXJuIHRoaXMuaXNFbmFibGVkID9cbiAgICAgICAgZGF0YS5zbG90KHRoaXMuaXNFbmFibGVkKS5nZXQoKSA6XG4gICAgICAgIHRydWU7XG4gICAgfSxcblxuICAgIGZ1bmN0aW9uIGNyZWF0ZUlzRW5hYmxlZCQoZGF0YSQpIHtcbiAgICAgIHJldHVybiBmb2FtLmNvcmUuRXhwcmVzc2lvblNsb3QuY3JlYXRlKHtcbiAgICAgICAgb2JqJDogZGF0YSQsXG4gICAgICAgIGNvZGU6IHRoaXMuaXNFbmFibGVkXG4gICAgICB9KTtcbiAgICB9LFxuXG4gICAgZnVuY3Rpb24gaXNBdmFpbGFibGVGb3IoZGF0YSkge1xuICAgICAgcmV0dXJuIHRoaXMuaXNBdmFpbGFibGUgP1xuICAgICAgICBmb2FtLkZ1bmN0aW9uLndpdGhBcmdzKHRoaXMuaXNBdmFpbGFibGUsIGRhdGEpIDpcbiAgICAgICAgdHJ1ZSA7XG4gICAgfSxcblxuICAgIGZ1bmN0aW9uIGNyZWF0ZUlzQXZhaWxhYmxlJChkYXRhJCkge1xuICAgICAgcmV0dXJuIGZvYW0uY29yZS5FeHByZXNzaW9uU2xvdC5jcmVhdGUoe1xuICAgICAgICBvYmokOiBkYXRhJCxcbiAgICAgICAgY29kZTogdGhpcy5pc0F2YWlsYWJsZVxuICAgICAgfSk7XG4gICAgfSxcblxuICAgIGZ1bmN0aW9uIG1heWJlQ2FsbChjdHgsIGRhdGEpIHtcbiAgICAgIGlmICggdGhpcy5pc0VuYWJsZWRGb3IoZGF0YSkgJiYgdGhpcy5pc0F2YWlsYWJsZUZvcihkYXRhKSApIHtcbiAgICAgICAgdGhpcy5jb2RlLmNhbGwoZGF0YSwgY3R4LCB0aGlzKTtcbiAgICAgICAgZGF0YSAmJiBkYXRhLnB1YignYWN0aW9uJywgdGhpcy5uYW1lLCB0aGlzKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9LFxuXG4gICAgZnVuY3Rpb24gaW5zdGFsbEluQ2xhc3MoYykge1xuICAgICAgYy5pbnN0YWxsQ29uc3RhbnQodGhpcy5uYW1lLCB0aGlzKTtcbiAgICB9LFxuXG4gICAgZnVuY3Rpb24gaW5zdGFsbEluUHJvdG8ocHJvdG8pIHtcbiAgICAgIHZhciBhY3Rpb24gPSB0aGlzO1xuICAgICAgcHJvdG9bdGhpcy5uYW1lXSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gYWN0aW9uLm1heWJlQ2FsbCh0aGlzLl9fY29udGV4dF9fLCB0aGlzKTtcbiAgICAgIH07XG4gICAgfVxuICBdXG59KTtcblxuXG4vKiogQWRkIEFjdGlvbiBzdXBwb3J0IHRvIE1vZGVsLiAqL1xuZm9hbS5DTEFTUyh7XG4gIHJlZmluZXM6ICdmb2FtLmNvcmUuTW9kZWwnLFxuXG4gIHByb3BlcnRpZXM6IFtcbiAgICB7XG4gICAgICBjbGFzczogJ0F4aW9tQXJyYXknLFxuICAgICAgb2Y6ICdBY3Rpb24nLFxuICAgICAgbmFtZTogJ2FjdGlvbnMnLFxuICAgICAgYWRhcHRBcnJheUVsZW1lbnQ6IGZ1bmN0aW9uKG8sIHByb3ApIHtcbiAgICAgICAgaWYgKCB0eXBlb2YgbyA9PT0gJ2Z1bmN0aW9uJyApIHtcbiAgICAgICAgICByZXR1cm4gZm9hbS5jb3JlLkFjdGlvbi5jcmVhdGUoe25hbWU6IG8ubmFtZSwgY29kZTogb30pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCBvLmNsYXNzICkge1xuICAgICAgICAgIHZhciBhID0gdGhpcy5sb29rdXAoby5jbGFzcyk7XG4gICAgICAgICAgaWYgKCAhIGEgKSB0aHJvdyAnVW5rbm93biBjbGFzcyA6ICcgKyBvLmNsYXNzO1xuICAgICAgICAgIHJldHVybiBhLmNyZWF0ZShvLCB0aGlzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLmxvb2t1cChwcm9wLm9mKS5jcmVhdGUobywgdGhpcyk7XG4gICAgICB9XG4gICAgfVxuICBdXG59KTtcbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxNyBUaGUgRk9BTSBBdXRob3JzLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxyXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICovXHJcblxyXG5mb2FtLkNMQVNTKHtcclxuICBwYWNrYWdlOiAnZm9hbS5jb3JlJyxcclxuICBuYW1lOiAnU3RhdGljJyxcclxuICBleHRlbmRzOiAnZm9hbS5jb3JlLkFic3RyYWN0TWV0aG9kJyxcclxuXHJcbiAgZG9jdW1lbnRhdGlvbjogJ0FuIEF4aW9tIGZvciBkZWZpbmluZyBzdGF0aWMgbWV0aG9kcy4nLFxyXG5cclxuICBtZXRob2RzOiBbXHJcbiAgICBmdW5jdGlvbiBpc1N0YXRpYygpIHsgcmV0dXJuIHRydWU7IH0sXHJcblxyXG4gICAgZnVuY3Rpb24gaW5zdGFsbEluQ2xhc3MoY2xzKSB7XHJcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShcclxuICAgICAgICBjbHMsXHJcbiAgICAgICAgdGhpcy5uYW1lLFxyXG4gICAgICAgIHtcclxuICAgICAgICAgIHZhbHVlOiB0aGlzLmNvZGUsXHJcbiAgICAgICAgICBjb25maWd1cmFibGU6IGZhbHNlXHJcbiAgICAgICAgfSk7XHJcbiAgICB9LFxyXG5cclxuICAgIGZ1bmN0aW9uIGluc3RhbGxJblByb3RvKHByb3RvKSB7XHJcbiAgICAgIHRoaXMuaW5zdGFsbEluQ2xhc3MocHJvdG8pO1xyXG4gICAgfVxyXG4gIF1cclxufSk7XHJcblxyXG5cclxuZm9hbS5DTEFTUyh7XHJcbiAgcmVmaW5lczogJ2ZvYW0uY29yZS5Nb2RlbCcsXHJcblxyXG4gIHByb3BlcnRpZXM6IFtcclxuICAgIHtcclxuICAgICAgY2xhc3M6ICdBeGlvbUFycmF5JyxcclxuICAgICAgb2Y6ICdTdGF0aWMnLFxyXG4gICAgICBuYW1lOiAnc3RhdGljJyxcclxuICAgICAgYWRhcHRBcnJheUVsZW1lbnQ6IGZ1bmN0aW9uKG8pIHtcclxuICAgICAgICBpZiAoIHR5cGVvZiBvID09PSAnZnVuY3Rpb24nICkge1xyXG4gICAgICAgICAgdmFyIG5hbWUgPSBmb2FtLkZ1bmN0aW9uLmdldE5hbWUobyk7XHJcbiAgICAgICAgICBmb2FtLmFzc2VydChuYW1lLCAnU3RhdGljIG11c3QgYmUgbmFtZWQnKTtcclxuICAgICAgICAgIHJldHVybiBmb2FtLmNvcmUuU3RhdGljLmNyZWF0ZSh7bmFtZTogbmFtZSwgY29kZTogb30pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIGZvYW0uY29yZS5TdGF0aWMuaXNJbnN0YW5jZShvKSA/XHJcbiAgICAgICAgICAgIG8gOlxyXG4gICAgICAgICAgICBmb2FtLmNvcmUuU3RhdGljLmNyZWF0ZShvKSA7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICBdXHJcbn0pO1xyXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBUaGUgRk9BTSBBdXRob3JzLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKi9cblxuZm9hbS5DTEFTUyh7XG4gIHBhY2thZ2U6ICdmb2FtLmNvcmUnLFxuICBuYW1lOiAnUmVhY3Rpb24nLFxuXG4gIHByb3BlcnRpZXM6IFtcbiAgICB7XG4gICAgICBuYW1lOiAnbmFtZScsXG4gICAgICBleHByZXNzaW9uOiBmdW5jdGlvbih0YXJnZXQsIHRvcGljLCBsaXN0ZW5lcikge1xuICAgICAgICByZXR1cm4gJ3JlYWN0aW9uXycgKyB0YXJnZXQgKyAgJyQkJyArIHRvcGljICsgJyQkJyArIGxpc3RlbmVyO1xuICAgICAgfVxuICAgIH0sXG4gICAge1xuICAgICAgY2xhc3M6ICdTdHJpbmcnLFxuICAgICAgbmFtZTogJ3RhcmdldCdcbiAgICB9LFxuICAgIHtcbiAgICAgIGNsYXNzOiAnU3RyaW5nQXJyYXknLFxuICAgICAgbmFtZTogJ3RvcGljJ1xuICAgIH0sXG4gICAge1xuICAgICAgbmFtZTogJ2xpc3RlbmVyJ1xuICAgIH0sXG4gIF0sXG5cbiAgbWV0aG9kczogW1xuICAgIGZ1bmN0aW9uIGluaXRPYmplY3Qob2JqKSB7XG4gICAgICB2YXIgbGlzdGVuZXIgPSBvYmpbdGhpcy5saXN0ZW5lcl07XG4gICAgICB2YXIgdG9waWMgPSB0aGlzLnRvcGljO1xuXG4gICAgICBpZiAoIHRoaXMudGFyZ2V0ID09PSAnJyApIHtcbiAgICAgICAgb2JqLm9uRGV0YWNoKG9iai5zdWIuYXBwbHkob2JqLCB0aGlzLnRvcGljLmNvbmNhdChsaXN0ZW5lcikpKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgcGF0aCA9IHRoaXMudGFyZ2V0LnNwbGl0KCcuJyk7XG5cbiAgICAgIHZhciBzbG90ID0gb2JqO1xuXG4gICAgICBmb3IgKCB2YXIgaSA9IDAgOyBpIDwgcGF0aC5sZW5ndGggOyBpKysgKSB7XG4gICAgICAgIHNsb3QgPSBzbG90LmRvdChwYXRoW2ldKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCB0b3BpYy5sZW5ndGggKSB7XG4gICAgICAgIHZhciBsID0gbGlzdGVuZXI7XG4gICAgICAgIHZhciBwcmV2U3ViO1xuICAgICAgICB2YXIgYXJncyA9IHRvcGljLmNvbmNhdChsKTtcblxuICAgICAgICBsaXN0ZW5lciA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHByZXZTdWIgJiYgcHJldlN1Yi5kZXRhY2goKTtcbiAgICAgICAgICB2YXIgdGFyZ2V0ID0gc2xvdC5nZXQoKTtcbiAgICAgICAgICBpZiAoIHRhcmdldCAmJiBmb2FtLmNvcmUuRk9iamVjdC5pc0luc3RhbmNlKHRhcmdldCkgKSB7XG4gICAgICAgICAgICBvYmoub25EZXRhY2gocHJldlN1YiA9IHRhcmdldC5zdWIuYXBwbHkodGFyZ2V0LCBhcmdzKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIGxpc3RlbmVyKCk7XG4gICAgICB9XG5cbiAgICAgIG9iai5vbkRldGFjaChzbG90LnN1YihsaXN0ZW5lcikpO1xuICAgIH1cbiAgXVxufSk7XG5cblxuZm9hbS5DTEFTUyh7XG4gIHJlZmluZXM6ICdmb2FtLmNvcmUuTW9kZWwnLFxuXG4gIHByb3BlcnRpZXM6IFtcbiAgICB7XG4gICAgICBjbGFzczogJ0F4aW9tQXJyYXknLFxuICAgICAgbmFtZTogJ3JlYWN0aW9ucycsXG4gICAgICBvZjogJ2ZvYW0uY29yZS5SZWFjdGlvbicsXG4gICAgICBhZGFwdEFycmF5RWxlbWVudDogZnVuY3Rpb24oZSwgcHJvcCkge1xuICAgICAgICByZXR1cm4gZm9hbS5BcnJheS5pc0luc3RhbmNlKGUpID9cbiAgICAgICAgICBmb2FtLmNvcmUuUmVhY3Rpb24uY3JlYXRlKHt0YXJnZXQ6IGVbMF0sIHRvcGljOiBlWzFdID8gZVsxXS5zcGxpdCgnLicpIDogW10sIGxpc3RlbmVyOiBlWzJdIH0pIDpcbiAgICAgICAgICBlLmNsYXNzID8gdGhpcy5sb29rdXAoZS5jbGFzcykuY3JlYXRlKGUsIHRoaXMpIDpcbiAgICAgICAgICB0aGlzLmxvb2t1cChwcm9wLm9mKS5jcmVhdGUoZSwgdGhpcyk7XG4gICAgICB9XG4gICAgfVxuICBdXG59KTtcbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmZvYW0uSU5URVJGQUNFKHtcbiAgcGFja2FnZTogJ2ZvYW0uY29yZScsXG4gIG5hbWU6ICdTZXJpYWxpemFibGUnLFxuXG4gIGRvY3VtZW50YXRpb246XG4gICAgICAnTWFya2VyIGludGVyZmFjZSB0byBpbmRpY2F0ZSB0aGF0IGEgQ0xBU1MgaXMgc2VyaWFsaXpibGUgb3Igbm90Lidcbn0pO1xuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTggVGhlIEZPQU0gQXV0aG9ycy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICovXG5cbmZvYW0uSU5URVJGQUNFKHtcbiAgcGFja2FnZTogJ2ZvYW0uY29yZScsXG4gIG5hbWU6ICdWYWxpZGF0YWJsZScsXG4gIGRvY3VtZW50YXRpb246XG4gICAgYER1bW15IGludGVyZmFjZSBzbyBGT0FNIE1vZGVscyBjYW5cbiAgICBpbXBsZW1lbnQgamF2YSB2YWxpZGF0YWJsZSBpbnRlcmZhY2VgXG59KTsvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxOCBUaGUgRk9BTSBBdXRob3JzLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5mb2FtLkNMQVNTKHtcbiAgcGFja2FnZTogJ2ZvYW0uanNvbjInLFxuICBuYW1lOiAnT3V0cHV0dGVyJyxcbiAgcHJvcGVydGllczogW1xuICAgIHtcbiAgICAgIGNsYXNzOiAnU3RyaW5nJyxcbiAgICAgIG5hbWU6ICdzdHInXG4gICAgfSxcbiAgICB7XG4gICAgICBuYW1lOiAnc3RhdGUnLFxuICAgICAgZmFjdG9yeTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBbe31dO1xuICAgICAgfVxuICAgIH1cbiAgXSxcbiAgbWV0aG9kczogW1xuICAgIGZ1bmN0aW9uIG9iaigpIHtcbiAgICAgIHRoaXMuZSgpO1xuICAgICAgdGhpcy5zdHIgKz0gJ3snO1xuICAgICAgdGhpcy5zdGF0ZS5wdXNoKHtcbiAgICAgICAgZW5kOiAnfScsXG4gICAgICAgIGNvbW1hOiBmYWxzZVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIGZ1bmN0aW9uIGFycmF5KCkge1xuICAgICAgdGhpcy5lKCk7XG4gICAgICB0aGlzLnN0ciArPSAnWyc7XG4gICAgICB0aGlzLnN0YXRlLnB1c2goe1xuICAgICAgICBlbmQ6ICddJyxcbiAgICAgICAgYXJyYXk6IHRydWUsXG4gICAgICAgIGNvbW1hOiBmYWxzZVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIGZ1bmN0aW9uIHRvcCgpIHtcbiAgICAgIHJldHVybiB0aGlzLnN0YXRlW3RoaXMuc3RhdGUubGVuZ3RoIC0gMV07XG4gICAgfSxcbiAgICBmdW5jdGlvbiBrZXkocykge1xuICAgICAgaWYgKCB0aGlzLnRvcCgpLmNvbW1hICkgdGhpcy5zdHIgKz0gJywnO1xuICAgICAgZWxzZSB0aGlzLnRvcCgpLmNvbW1hID0gdHJ1ZTtcblxuICAgICAgdGhpcy5zdHIgKz0gdGhpcy5zdHJpbmcocyk7XG4gICAgICB0aGlzLnN0ciArPSAnOic7XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgZnVuY3Rpb24gZSgpIHtcbiAgICAgIGlmICggdGhpcy50b3AoKS5hcnJheSApIHtcbiAgICAgICAgaWYgKCB0aGlzLnRvcCgpLmNvbW1hICkgdGhpcy5zdHIgKz0gJywnO1xuICAgICAgICB0aGlzLnRvcCgpLmNvbW1hID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGZ1bmN0aW9uIHN0cmluZyhzKSB7XG4gICAgICByZXR1cm4gJ1wiJyArIHMuXG4gICAgICAgIHJlcGxhY2UoL1xcXFwvZywgJ1xcXFxcXFxcJykuXG4gICAgICAgIHJlcGxhY2UoL1wiL2csICdcXFxcXCInKS5cbiAgICAgICAgcmVwbGFjZSgvW1xceDAwLVxceDFmXS9nLCBmdW5jdGlvbihjKSB7XG4gICAgICAgICAgcmV0dXJuIFwiXFxcXHUwMFwiICsgKChjLmNoYXJDb2RlQXQoMCkgPCAweDEwKSA/XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJzAnICsgYy5jaGFyQ29kZUF0KDApLnRvU3RyaW5nKDE2KSA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYy5jaGFyQ29kZUF0KDApLnRvU3RyaW5nKDE2KSk7XG4gICAgICAgIH0pICsgJ1wiJztcbiAgICB9LFxuICAgIGZ1bmN0aW9uIHMocykge1xuICAgICAgdGhpcy5lKCk7XG4gICAgICB0aGlzLnN0ciArPSB0aGlzLnN0cmluZyhzKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgZnVuY3Rpb24gbihuKSB7XG4gICAgICB0aGlzLmUoKTtcbiAgICAgIHRoaXMuc3RyICs9IG47XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIGZ1bmN0aW9uIGIoYikge1xuICAgICAgdGhpcy5lKCk7XG4gICAgICB0aGlzLnN0ciArPSBiO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICBmdW5jdGlvbiBudWwoKSB7XG4gICAgICB0aGlzLmUoKTtcbiAgICAgIHRoaXMuc3RyICs9ICdudWxsJztcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgZnVuY3Rpb24gZW5kKCkge1xuICAgICAgdmFyIHMgPSB0aGlzLnN0YXRlLnBvcCgpO1xuICAgICAgdGhpcy5zdHIgKz0gcy5lbmQ7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIF1cbn0pO1xuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTggVGhlIEZPQU0gQXV0aG9ycy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICovXG5cbmZvYW0uQ0xBU1Moe1xuICBwYWNrYWdlOiAnZm9hbS5qc29uMicsXG4gIG5hbWU6ICdEZXNlcmlhbGl6ZXInLFxuICBpbXBvcnRzOiBbXG4gICAgJ2NsYXNzbG9hZGVyJyxcbiAgXSxcbiAgcHJvcGVydGllczogW1xuICAgIHtcbiAgICAgIGNsYXNzOiAnQm9vbGVhbicsXG4gICAgICBuYW1lOiAncGFyc2VGdW5jdGlvbnMnLFxuICAgICAgdmFsdWU6IGZhbHNlXG4gICAgfVxuICBdLFxuICBtZXRob2RzOiBbXG4gICAgZnVuY3Rpb24gYXBhcnNlU3RyaW5nKHgsIHN0cikge1xuICAgICAgcmV0dXJuIHRoaXMuYXBhcnNlKHgsIEpTT04ucGFyc2Uoc3RyKSk7XG4gICAgfSxcbiAgICBmdW5jdGlvbiBhcGFyc2UoeCwgdikge1xuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJldCkge1xuICAgICAgICBpZiAoIHZbJyRERVBTJCddICYmIHZbJyRCT0RZJCddICkge1xuICAgICAgICAgIHZhciBsb2FkID0gc2VsZi5jbGFzc2xvYWRlci5sb2FkLmJpbmQoc2VsZi5jbGFzc2xvYWRlcik7XG4gICAgICAgICAgUHJvbWlzZS5hbGwodlsnJERFUFMkJ10ubWFwKGxvYWQpKS50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0KHNlbGYucGFyc2UoeCwgdlsnJEJPRFkkJ10pKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXQoc2VsZi5wYXJzZSh4LCB2KSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0sXG4gICAgZnVuY3Rpb24gcGFyc2UoeCwgdikge1xuICAgICAgdmFyIHR5cGUgPSBmb2FtLnR5cGVPZih2KTtcblxuICAgICAgaWYgKCB0eXBlID09IGZvYW0uT2JqZWN0ICkge1xuICAgICAgICBpZiAoICEgZm9hbS5VbmRlZmluZWQuaXNJbnN0YW5jZSh2W1wiJFVOREVGXCJdKSApIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIGlmICggISBmb2FtLlVuZGVmaW5lZC5pc0luc3RhbmNlKHZbXCIkREFURSRcIl0pICkge1xuICAgICAgICAgIHZhciBkID0gbmV3IERhdGUoKTtcbiAgICAgICAgICBkLnNldFRpbWUodltcIiREQVRFXCJdKTtcbiAgICAgICAgICByZXR1cm4gZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoICEgZm9hbS5VbmRlZmluZWQuaXNJbnN0YW5jZSh2W1wiJEZVTkMkXCJdKSApIHtcbiAgICAgICAgICBpZiAoIHRoaXMucGFyc2VGdW5jdGlvbnMgKSB7XG4gICAgICAgICAgICB2YXIgbmFtZSA9IHYubmFtZTtcbiAgICAgICAgICAgIHZhciBhcmdzID0gdi5hcmdzO1xuICAgICAgICAgICAgdmFyIGJvZHkgPSB2LmJvZHk7XG4gICAgICAgICAgICB2YXIgZiA9IEZ1bmN0aW9uLmFwcGx5KG51bGwsIGFyZ3MuY29uY2F0KGJvZHkpKTtcbiAgICAgICAgICAgIGlmICggbmFtZSApIGZvYW0uRnVuY3Rpb24uc2V0TmFtZShmLCBuYW1lKTtcbiAgICAgICAgICAgIHJldHVybiBmO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmICggISBmb2FtLlVuZGVmaW5lZC5pc0luc3RhbmNlKHZbXCIkSU5TVCRcIl0pICkge1xuICAgICAgICAgIC8vIElzIGFuIGluc3RhbmNlIG9mIHRoZSBjbGFzcyBkZWZpbmVkIGJ5ICRJTlNUJCBrZXlcbiAgICAgICAgICB2YXIgY2xzID0gdGhpcy5wYXJzZSh4LCB2W1wiJElOU1QkXCJdKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoICEgZm9hbS5VbmRlZmluZWQuaXNJbnN0YW5jZSh2W1wiJENMUyRcIl0pICkge1xuICAgICAgICAgIC8vIERlZmluZXMgYSBjbGFzcyByZWZlcmVuY2VkIGJ5ICRDTFMkIGtleVxuICAgICAgICAgIHJldHVybiBmb2FtLmxvb2t1cCh2W1wiJENMUyRcIl0pO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyh2KTtcbiAgICAgICAgdmFyIGFyZ3MgPSB7fVxuICAgICAgICBmb3IgKCB2YXIgaSA9IDAgOyBpIDwga2V5cy5sZW5ndGggOyBpKysgKSB7XG4gICAgICAgICAgaWYgKCBrZXlzW2ldID09ICckSU5TVCQnICkgY29udGludWU7XG5cbiAgICAgICAgICBhcmdzW2tleXNbaV1dID0gdGhpcy5wYXJzZSh4LCB2W2tleXNbaV1dKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBjbHMgP1xuICAgICAgICAgIGNscy5jcmVhdGUoYXJncywgeCkgOlxuICAgICAgICAgIGFyZ3M7XG5cbiAgICAgIH0gZWxzZSBpZiAoIHR5cGUgPT0gZm9hbS5BcnJheSApIHtcbiAgICAgICAgZm9yICggdmFyIGkgPSAwIDsgaSA8IHYubGVuZ3RoIDsgaSsrICkge1xuICAgICAgICAgIHZbaV0gPSB0aGlzLnBhcnNlKHgsIHZbaV0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2O1xuLyogICAgICB9IGVsc2UgaWYgKCB0eXBlID09IGZvYW0uTnVsbCApIHtcbiAgICAgIH0gZWxzZSBpZiAoIHR5cGUgPT0gZm9hbS5OdW1iZXIgKSB7XG4gICAgICB9IGVsc2UgaWYgKCB0eXBlID09IGZvYW0uU3RyaW5nICkge1xuICAgICAgfSBlbHNlIGlmICggdHlwZSA9PSBmb2FtLkJvb2xlYW4gKSB7ICovXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdjtcbiAgICAgIH1cbiAgICB9XG4gIF1cbn0pO1xuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTggVGhlIEZPQU0gQXV0aG9ycy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICovXG5cbmZvYW0uQ0xBU1Moe1xuICBwYWNrYWdlOiAnZm9hbS5qc29uMicsXG4gIG5hbWU6ICdTZXJpYWxpemVyJyxcbiAgcmVxdWlyZXM6IFtcbiAgICAnZm9hbS5qc29uMi5PdXRwdXR0ZXInLFxuICBdLFxuICBtZXRob2RzOiBbXG4gICAgZnVuY3Rpb24gc3RyaW5naWZ5KHgsIHYpIHtcbiAgICAgIHZhciBzZXJpYWxpemVyID0gdGhpcy5Jbm5lclNlcmlhbGl6ZXIuY3JlYXRlKCk7XG4gICAgICBzZXJpYWxpemVyLm91dHB1dCh4LCB2KTtcbiAgICAgIHJldHVybiBzZXJpYWxpemVyLmdldFN0cmluZygpO1xuICAgIH1cbiAgXSxcbiAgY2xhc3NlczogW1xuICAgIHtcbiAgICAgIG5hbWU6ICdJbm5lclNlcmlhbGl6ZXInLFxuICAgICAgcmVxdWlyZXM6IFtcbiAgICAgICAgJ2ZvYW0uanNvbjIuT3V0cHV0dGVyJ1xuICAgICAgXSxcbiAgICAgIHByb3BlcnRpZXM6IFtcbiAgICAgICAge1xuICAgICAgICAgIGNsYXNzOiAnTWFwJyxcbiAgICAgICAgICBuYW1lOiAnZGVwcydcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIGNsYXNzOiAnRk9iamVjdFByb3BlcnR5JyxcbiAgICAgICAgICBvZjogJ2ZvYW0uanNvbjIuT3V0cHV0dGVyJyxcbiAgICAgICAgICBuYW1lOiAnb3V0JyxcbiAgICAgICAgICBmYWN0b3J5OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLk91dHB1dHRlci5jcmVhdGUoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIF0sXG4gICAgICBtZXRob2RzOiBbXG4gICAgICAgIGZ1bmN0aW9uIGdldFN0cmluZygpIHtcbiAgICAgICAgICB2YXIgZGVwcyA9IE9iamVjdC5rZXlzKHRoaXMuZGVwcykubWFwKGZ1bmN0aW9uKGQpIHsgcmV0dXJuIGBcIiR7ZH1cImAgfSkuam9pbignLCcpO1xuICAgICAgICAgIHJldHVybiBge1wiJERFUFMkXCI6WyR7ZGVwc31dLFwiJEJPRFkkXCI6JHt0aGlzLm91dC5zdHJ9fWBcbiAgICAgICAgfSxcbiAgICAgICAgZnVuY3Rpb24gb3V0cHV0KHgsIHYpIHtcbiAgICAgICAgICB2YXIgb3V0ID0gdGhpcy5vdXQ7XG4gICAgICAgICAgdmFyIHR5cGUgPSBmb2FtLnR5cGVPZih2KTtcblxuICAgICAgICAgIGlmICggdHlwZSA9PSBmb2FtLk51bWJlciApIHtcbiAgICAgICAgICAgIG91dC5uKHYpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoIHR5cGUgPT0gZm9hbS5TdHJpbmcgKSB7XG4gICAgICAgICAgICBvdXQucyh2KTtcbiAgICAgICAgICB9IGVsc2UgaWYgKCB0eXBlID09IGZvYW0uVW5kZWZpbmVkICkge1xuICAgICAgICAgICAgb3V0Lm9iaigpO1xuICAgICAgICAgICAgb3V0LmtleShcIiRVTkRFRlwiKTtcbiAgICAgICAgICAgIG91dC5iKHRydWUpO1xuICAgICAgICAgICAgb3V0LmVuZCgpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoIHR5cGUgPT0gZm9hbS5OdWxsICkge1xuICAgICAgICAgICAgb3V0Lm51bCgpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoIHR5cGUgPT0gZm9hbS5Cb29sZWFuICkge1xuICAgICAgICAgICAgb3V0LmIodik7XG4gICAgICAgICAgfSBlbHNlIGlmICggdHlwZSA9PSBmb2FtLkFycmF5ICkge1xuICAgICAgICAgICAgb3V0LmFycmF5KCk7XG4gICAgICAgICAgICBmb3IgKCB2YXIgaSA9IDAgOyBpIDwgdi5sZW5ndGggOyBpKysgKSB7XG4gICAgICAgICAgICAgIHRoaXMub3V0cHV0KHgsIHZbaV0pXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvdXQuZW5kKClcbiAgICAgICAgICB9IGVsc2UgaWYgKCB0eXBlID09IGZvYW0uRGF0ZSApIHtcbiAgICAgICAgICAgIG91dC5vYmooKTtcbiAgICAgICAgICAgIG91dC5rZXkoXCIkREFURSRcIik7XG4gICAgICAgICAgICBvdXQubih2LmdldFRpbWUoKSk7XG4gICAgICAgICAgICBvdXQuZW5kKCk7XG4gICAgICAgICAgfSBlbHNlIGlmICggdHlwZSA9PSBmb2FtLk9iamVjdCApIHtcbiAgICAgICAgICAgIGlmICggZm9hbS5jb3JlLkZPYmplY3QuaXNTdWJDbGFzcyh2KSApIHsgLy8gSXMgYW4gYWN0dWFsIGNsYXNzXG4gICAgICAgICAgICAgIGlmICggdi5pZC5pbmRleE9mKCdBbm9ueW1vdXNDbGFzcycpID09IDAgKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5vdXRwdXQoeCwgdi5tb2RlbF8pO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG91dC5vYmooKTtcbiAgICAgICAgICAgICAgICBvdXQua2V5KFwiJENMUyRcIik7XG4gICAgICAgICAgICAgICAgb3V0LnModi5pZCk7XG4gICAgICAgICAgICAgICAgb3V0LmVuZCgpO1xuICAgICAgICAgICAgICAgIHRoaXMuZGVwc1t2LmlkXSA9IHRydWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7IC8vIGlzIHNvbWUgb3RoZXIgSlMgb2JqZWN0XG4gICAgICAgICAgICAgIGlmICggdi5vdXRwdXRKU09OMiApIHtcbiAgICAgICAgICAgICAgICAvLyBJZiBpdCBrbm93cyBob3cgdG8gb3V0cHV0IGl0c2VsZiwgbGV0IGl0IGRvIHNvXG4gICAgICAgICAgICAgICAgdi5vdXRwdXRKU09OMih4LCB0aGlzLCBvdXQpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIE90aGVyd2lzZSBqdXN0IGRvIG91ciBiZXN0LiAgVGhpcyBpcyBwcmV0dHkgZXF1aXZhbGVudCB0b1xuICAgICAgICAgICAgICAgIC8vIEpTT04uc3RyaW5naWZ5KClcbiAgICAgICAgICAgICAgICBvdXQub2JqKCk7XG4gICAgICAgICAgICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyh2KTtcbiAgICAgICAgICAgICAgICBmb3IgKCB2YXIgaSA9IDAgOyBpIDwga2V5cy5sZW5ndGggOyBpKysgKSB7XG4gICAgICAgICAgICAgICAgICBpZiAoIGZvYW0uVW5kZWZpbmVkLmlzSW5zdGFuY2UodltrZXlzW2ldXSkgKSBjb250aW51ZTtcblxuICAgICAgICAgICAgICAgICAgb3V0LmtleShrZXlzW2ldKTtcbiAgICAgICAgICAgICAgICAgIHRoaXMub3V0cHV0KHgsIHZba2V5c1tpXV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBvdXQuZW5kKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgaWYgKCB0eXBlID09IGZvYW0uY29yZS5GT2JqZWN0ICkge1xuICAgICAgICAgICAgaWYgKCB2Lm91dHB1dEpTT04yICkgdi5vdXRwdXRKU09OMih4LCB0aGlzLCBvdXQpO1xuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgIG91dC5vYmooKTtcbiAgICAgICAgICAgICAgdmFyIGNscyA9IHYuY2xzXztcbiAgICAgICAgICAgICAgdmFyIGF4aW9tcyA9IHYuY2xzXy5nZXRBeGlvbXMoKTtcblxuICAgICAgICAgICAgICBvdXQua2V5KFwiJElOU1QkXCIpO1xuICAgICAgICAgICAgICB0aGlzLm91dHB1dCh4LCBjbHMpO1xuXG4gICAgICAgICAgICAgIGZvciAoIHZhciBpID0gMCA7IGkgPCBheGlvbXMubGVuZ3RoIDsgaSsrICkge1xuICAgICAgICAgICAgICAgIHZhciBhID0gYXhpb21zW2ldO1xuICAgICAgICAgICAgICAgIGlmICggYS5vdXRwdXRQcm9wZXJ0eUpTT04yICkgYS5vdXRwdXRQcm9wZXJ0eUpTT04yKHgsIHYsIHRoaXMsIG91dCk7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBvdXQuZW5kKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIGlmICggdHlwZSA9PSBmb2FtLkZ1bmN0aW9uICkge1xuXG4gICAgICAgICAgICB2YXIgYnJlYWtkb3duID0gZm9hbS5GdW5jdGlvbi5icmVha2Rvd24odik7XG4gICAgICAgICAgICBpZiAoIGJyZWFrZG93biA9PSBudWxsICkge1xuICAgICAgICAgICAgICBkZWJ1Z2dlcjtcbiAgICAgICAgICAgICAgYnJlYWtkb3duID0gZm9hbS5GdW5jdGlvbi5icmVha2Rvd24odik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZvYW0uYXNzZXJ0KGJyZWFrZG93biwgXCJGYWlsZWQgdG8gcGFyc2UgZnVuY2l0b24sIHRoaXMgaXMgYSBidWchXCIpO1xuXG4gICAgICAgICAgICBvdXQub2JqKCk7XG5cbiAgICAgICAgICAgIG91dC5rZXkoXCIkRlVOQyRcIik7XG4gICAgICAgICAgICBvdXQuYih0cnVlKTtcblxuICAgICAgICAgICAgb3V0LmtleShcIm5hbWVcIilcbiAgICAgICAgICAgIG91dC5zKGJyZWFrZG93bi5uYW1lKTtcblxuICAgICAgICAgICAgb3V0LmtleShcImFyZ3NcIik7XG4gICAgICAgICAgICBvdXQuYXJyYXkoKTtcbiAgICAgICAgICAgIGZvciAoIHZhciBpID0gMCA7IGkgPCBicmVha2Rvd24uYXJncy5sZW5ndGggOyBpKysgKSB7XG4gICAgICAgICAgICAgIG91dC5zKGJyZWFrZG93bi5hcmdzW2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG91dC5lbmQoKTtcblxuICAgICAgICAgICAgb3V0LmtleShcImJvZHlcIik7XG4gICAgICAgICAgICBvdXQucyhicmVha2Rvd24uYm9keSk7XG5cbiAgICAgICAgICAgIG91dC5lbmQoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIF1cbiAgICB9XG4gIF1cbn0pO1xuXG5mb2FtLkNMQVNTKHtcbiAgcmVmaW5lczogJ2ZvYW0uY29yZS5Qcm9wZXJ0eScsXG4gIG1ldGhvZHM6IFtcbiAgICBmdW5jdGlvbiBvdXRwdXRQcm9wZXJ0eUpTT04yKHgsIG9iaiwgb3V0cHV0dGVyLCBvdXQpIHtcbiAgICAgIGlmICggb2JqLmhhc0RlZmF1bHRWYWx1ZSh0aGlzLm5hbWUpICkgcmV0dXJuO1xuXG4gICAgICBpZiAoIHRoaXMudHJhbnNpZW50ICkgcmV0dXJuO1xuXG4gICAgICBpZiAoICEgZm9hbS51dGlsLmZsYWdGaWx0ZXIoeC5mbGFncykodGhpcykgKSByZXR1cm47XG5cbiAgICAgIG91dC5rZXkodGhpcy5uYW1lKTtcblxuICAgICAgb3V0cHV0dGVyLm91dHB1dCh4LCB0aGlzLmYob2JqKSwgb3V0KTtcbiAgICB9XG4gIF1cbn0pO1xuXG5mb2FtLkNMQVNTKHtcbiAgcmVmaW5lczogJ2ZvYW0uY29yZS5BeGlvbUFycmF5JyxcbiAgbWV0aG9kczogW1xuICAgIGZ1bmN0aW9uIG91dHB1dFByb3BlcnR5SlNPTjIoeCwgb2JqLCBvdXRwdXR0ZXIsIG91dCkge1xuICAgICAgaWYgKCBvYmouaGFzRGVmYXVsdFZhbHVlKHRoaXMubmFtZSkgKSByZXR1cm47XG5cbiAgICAgIGlmICggdGhpcy50cmFuc2llbnQgKSByZXR1cm47XG5cbiAgICAgIHZhciBvID0gdGhpcy5mKG9iaikuZmlsdGVyKGZvYW0udXRpbC5mbGFnRmlsdGVyKHguZmxhZ3MpKTtcblxuICAgICAgb3V0LmtleSh0aGlzLm5hbWUpO1xuXG4gICAgICBvdXRwdXR0ZXIub3V0cHV0KHgsIG8sIG91dCk7XG4gICAgfVxuICBdXG59KTtcbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE1IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmZvYW0uQ0xBU1Moe1xuICBwYWNrYWdlOiAnZm9hbS51dGlsJyxcbiAgbmFtZTogJ1RpbWVyJyxcbiAgc3dpZnROYW1lOiAnRm9hbVRpbWVyJyxcblxuICBkb2N1bWVudGF0aW9uOiAnVGltZXIgb2JqZWN0LiBVc2VmdWwgZm9yIGNyZWF0aW5nIGFuaW1hdGlvbnMuJyxcblxuICBwcm9wZXJ0aWVzOiBbXG4gICAge1xuICAgICAgY2xhc3M6ICdJbnQnLFxuICAgICAgbmFtZTogJ2ludGVydmFsJyxcbiAgICAgIGhlbHA6ICdJbnRlcnZhbCBvZiB0aW1lIGJldHdlZW4gdXBkYXRpbmcgdGltZS4nLFxuICAgICAgLy8gdW5pdHM6ICdtcycsXG4gICAgICB2YWx1ZTogMTBcbiAgICB9LFxuICAgIHtcbiAgICAgIGNsYXNzOiAnSW50JyxcbiAgICAgIG5hbWU6ICdpJyxcbiAgICAgIHZhbHVlOiAwXG4gICAgfSxcbiAgICB7XG4gICAgICBjbGFzczogJ0Zsb2F0JyxcbiAgICAgIG5hbWU6ICd0aW1lV2FycCcsXG4gICAgICB2YWx1ZTogMS4wXG4gICAgfSxcbiAgICB7XG4gICAgICBjbGFzczogJ0ludCcsXG4gICAgICBuYW1lOiAgJ2R1cmF0aW9uJyxcbiAgICAgIHVuaXRzOiAnbXMnLFxuICAgICAgdmFsdWU6IC0xXG4gICAgfSxcbiAgICB7XG4gICAgICBjbGFzczogJ0Zsb2F0JyxcbiAgICAgIG5hbWU6ICdwZXJjZW50JyxcbiAgICAgIHZhbHVlOiAwXG4gICAgfSxcbiAgICB7XG4gICAgICBjbGFzczogJ0xvbmcnLFxuICAgICAgbmFtZTogICdzdGFydFRpbWUnLFxuICAgICAgdmFsdWU6IDBcbiAgICB9LFxuICAgIHtcbiAgICAgIGNsYXNzOiAnTG9uZycsXG4gICAgICBuYW1lOiAgJ3RpbWUnLFxuICAgICAgaGVscDogICdUaGUgY3VycmVudCB0aW1lIGluIG1pbGxpc2Vjb25kcyBzaW5jZSBlcG9jaC4nLFxuICAgICAgYWRhcHQ6IGZ1bmN0aW9uKF8sIHQpIHsgcmV0dXJuIE1hdGguY2VpbCh0KTsgfSxcbiAgICAgIHN3aWZ0QWRhcHQ6IGZ1bmN0aW9uKCkgey8qXG5pZiBsZXQgbmV3VmFsdWUgPSBuZXdWYWx1ZSBhcz8gRG91YmxlIHtcbiAgcmV0dXJuIEludChjZWlsKG5ld1ZhbHVlKSlcbn1cbnJldHVybiBuZXdWYWx1ZSBhcyEgSW50XG4gICAgICAqL30sXG4gICAgICB2YWx1ZTogMFxuICAgIH0sXG4gICAge1xuICAgICAgY2xhc3M6ICdJbnQnLFxuICAgICAgbmFtZTogICdzZWNvbmQnLFxuICAgICAgaGVscDogICdUaGUgc2Vjb25kIG9mIHRoZSBjdXJyZW50IG1pbnV0ZS4nLFxuICAgICAgdmFsdWU6IDBcbiAgICB9LFxuICAgIHtcbiAgICAgIGNsYXNzOiAnSW50JyxcbiAgICAgIG5hbWU6ICAnbWludXRlJyxcbiAgICAgIGhlbHA6ICAnVGhlIG1pbnV0ZSBvZiB0aGUgY3VycmVudCBob3VyLicsXG4gICAgICB2YWx1ZTogMFxuICAgIH0sXG4gICAge1xuICAgICAgY2xhc3M6ICdJbnQnLFxuICAgICAgbmFtZTogICdob3VyJyxcbiAgICAgIGhlbHA6ICAnVGhlIGhvdXIgb2YgdGhlIGN1cnJlbnQgZGF5LicsXG4gICAgICB2YWx1ZTogMFxuICAgIH0sXG4gICAge1xuICAgICAgY2xhc3M6ICdCb29sZWFuJyxcbiAgICAgIG5hbWU6ICdpc1N0YXJ0ZWQnLFxuICAgICAgaGlkZGVuOiB0cnVlXG4gICAgfSxcbiAgICB7XG4gICAgICBjbGFzczogJ0xvbmcnLFxuICAgICAgbmFtZTogJ3N0YXJ0VGltZV8nLFxuICAgICAgaGlkZGVuOiB0cnVlXG4gICAgfVxuICBdLFxuXG4gIG1ldGhvZHM6IFtcbiAgICB7XG4gICAgICAvKipcbiAgICAgICAgIGN5Y2xlKGZyZXF1ZW5jeSkgICAgICAgICAgICAgLSBjeWNsZSBiZXR3ZWVuIC0xIGFuZCAxIGZyZXF1ZW5jeSB0aW1lcyBhIHNlY29uZFxuICAgICAgICAgY3ljbGUoZnJlcXVlbmN5LCBhbXBsaXR1ZGUpICAtIGN5Y2xlIGJldHdlZW4gLWFtcGxpdHVkZSBhbmQgYW1wbGl0dWRlIGZyZXF1ZW5jeSB0aW1lcyBhIHNlY29uZFxuICAgICAgICAgY3ljbGUoZnJlcXVlbmN5LCBzdGFydCwgZW5kKSAtIGN5Y2xlIGJldHdlZW4gc3RhcnQgYW5kIGVuZCBmcmVxdWVuY3kgdGltZXMgYSBzZWNvbmRcbiAgICAgICovXG4gICAgICBuYW1lOiAnY3ljbGUnLFxuICAgICAgc3dpZnRSZXR1cm5zOiAnRmxvYXQnLFxuICAgICAgYXJnczogW1xuICAgICAgICB7XG4gICAgICAgICAgbmFtZTogJ2ZyZXF1ZW5jeScsXG4gICAgICAgICAgc3dpZnRUeXBlOiAnRmxvYXQnLFxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgbmFtZTogJ2EnLFxuICAgICAgICAgIHN3aWZ0VHlwZTogJ0Zsb2F0PycsXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICBuYW1lOiAnYicsXG4gICAgICAgICAgc3dpZnRUeXBlOiAnRmxvYXQ/JyxcbiAgICAgICAgfSxcbiAgICAgIF0sXG4gICAgICBjb2RlOiBmdW5jdGlvbihmcmVxdWVuY3ksIGEsIGIpIHtcbiAgICAgICAgdmFyIHMgPSBNYXRoLnNpbih0aGlzLnRpbWUvMTAwMCpmcmVxdWVuY3kqTWF0aC5QSSoyKTtcbiAgICAgICAgaWYgKCBhcmd1bWVudHMubGVuZ3RoID09PSAxICkgcmV0dXJuIHM7XG4gICAgICAgIGlmICggYXJndW1lbnRzLmxlbmd0aCA9PT0gMiApIHJldHVybiBzICogYTtcbiAgICAgICAgcmV0dXJuIGEgKyAoMSArIHMpICogKGItYSkvMjtcbiAgICAgIH0sXG4gICAgICBzd2lmdENvZGU6IGZ1bmN0aW9uKCkgey8qXG5sZXQgcyA9IHNpbihGbG9hdCh0aW1lKS8xMDAwKmZyZXF1ZW5jeSpGbG9hdC5waSoyKVxuaWYgYSA9PSBuaWwgeyByZXR1cm4gcyB9XG5pZiBiID09IG5pbCB7IHJldHVybiBzICogYSEgfVxucmV0dXJuIGEhICsgKDEgKyBzKSAqIChiIS1hISkvMjtcbiAgICAgICovfSxcbiAgICB9LFxuICBdLFxuXG4gIGFjdGlvbnM6IFtcbiAgICB7XG4gICAgICBuYW1lOiAgJ3N0YXJ0JyxcbiAgICAgIGhlbHA6ICAnU3RhcnQgdGhlIHRpbWVyLicsXG4gICAgICBpc0VuYWJsZWQ6IGZ1bmN0aW9uKGlzU3RhcnRlZCkgeyByZXR1cm4gISBpc1N0YXJ0ZWQ7IH0sXG4gICAgICBjb2RlOiAgICAgIGZ1bmN0aW9uKCkgeyB0aGlzLmlzU3RhcnRlZCA9IHRydWU7IHRoaXMudGljaygpOyB9LFxuICAgICAgc3dpZnRDb2RlOiAnaXNTdGFydGVkID0gdHJ1ZTsgdGljaygpJyxcbiAgICB9LFxuICAgIHtcbiAgICAgIG5hbWU6ICAnc3RlcCcsXG4gICAgICBoZWxwOiAgJ1N0ZXAgdGhlIHRpbWVyLicsXG4gICAgICBjb2RlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5pKys7XG4gICAgICAgIHRoaXMudGltZSAgKz0gdGhpcy5pbnRlcnZhbCAqIHRoaXMudGltZVdhcnA7XG4gICAgICAgIHRoaXMuc2Vjb25kID0gdGhpcy50aW1lIC8gICAgMTAwMCAlIDYwIDw8IDA7XG4gICAgICAgIHRoaXMubWludXRlID0gdGhpcy50aW1lIC8gICA2MDAwMCAlIDYwIDw8IDA7XG4gICAgICAgIHRoaXMuaG91ciAgID0gdGhpcy50aW1lIC8gMzYwMDAwMCAlIDI0IDw8IDA7XG4gICAgICB9LFxuICAgICAgc3dpZnRDb2RlOiBmdW5jdGlvbigpIHsvKlxuaSs9MVxudGltZSAgKz0gSW50KEZsb2F0KGludGVydmFsKSAqIHRpbWVXYXJwKVxuc2Vjb25kID0gdGltZSAvICAgIDEwMDAgJSA2MCA8PCAwO1xubWludXRlID0gdGltZSAvICAgNjAwMDAgJSA2MCA8PCAwO1xuaG91ciAgID0gdGltZSAvIDM2MDAwMDAgJSAyNCA8PCAwO1xuICAgICAgKi99XG4gICAgfSxcbiAgICB7XG4gICAgICBuYW1lOiAgJ3N0b3AnLFxuICAgICAgaGVscDogICdTdG9wIHRoZSB0aW1lci4nLFxuICAgICAgaXNFbmFibGVkOiBmdW5jdGlvbihpc1N0YXJ0ZWQpIHsgcmV0dXJuIGlzU3RhcnRlZDsgfSxcbiAgICAgIGNvZGU6ICAgICAgZnVuY3Rpb24oKSB7IHRoaXMuaXNTdGFydGVkID0gZmFsc2U7IH0sXG4gICAgICBzd2lmdENvZGU6ICdpc1N0YXJ0ZWQgPSBmYWxzZSdcbiAgICB9XG4gIF0sXG5cbiAgbGlzdGVuZXJzOiBbXG4gICAge1xuICAgICAgbmFtZTogJ3RpY2snLFxuICAgICAgaXNGcmFtZWQ6IHRydWUsXG4gICAgICBjb2RlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKCAhIHRoaXMuaXNTdGFydGVkICkgcmV0dXJuO1xuXG4gICAgICAgIHZhciBwcmV2VGltZSA9IHRoaXMuc3RhcnRUaW1lXztcbiAgICAgICAgdGhpcy5zdGFydFRpbWVfID0gRGF0ZS5ub3coKTtcbiAgICAgICAgdGhpcy5pbnRlcnZhbCA9IE1hdGgubWluKDEwMCwgdGhpcy5zdGFydFRpbWVfIC0gcHJldlRpbWUpO1xuICAgICAgICB0aGlzLnN0ZXAoKTtcbiAgICAgICAgdGhpcy50aWNrKCk7XG4gICAgICB9LFxuICAgICAgc3dpZnRDb2RlOiBmdW5jdGlvbigpIHsvKlxuaWYgIWlzU3RhcnRlZCB7IHJldHVybiB9XG5cbmxldCBwcmV2VGltZSA9IHN0YXJ0VGltZV9cbnN0YXJ0VGltZV8gPSBJbnQoRGF0ZSgpLnRpbWVJbnRlcnZhbFNpbmNlMTk3MCAqIERvdWJsZSgxMDAwKSlcbmludGVydmFsID0gbWluKDEwMCwgc3RhcnRUaW1lXyAtIHByZXZUaW1lKVxuc3RlcCgpXG50aWNrKClcbiAgICAgICovfVxuICAgIH1cbiAgXVxufSk7XG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBUaGUgRk9BTSBBdXRob3JzLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5mb2FtLkVOVU0oe1xuICBwYWNrYWdlOiAnZm9hbS5sb2cnLFxuICBuYW1lOiAnTG9nTGV2ZWwnLFxuXG4gIHByb3BlcnRpZXM6IFtcbiAgICB7XG4gICAgICBjbGFzczogJ1N0cmluZycsXG4gICAgICBuYW1lOiAnc2hvcnROYW1lJ1xuICAgIH0sXG4gICAge1xuICAgICAgY2xhc3M6ICdTdHJpbmcnLFxuICAgICAgbmFtZTogJ2NvbnNvbGVNZXRob2ROYW1lJ1xuICAgIH1cbiAgXSxcblxuICB2YWx1ZXM6IFtcbiAgICB7XG4gICAgICBuYW1lOiAnREVCVUcnLFxuICAgICAgc2hvcnROYW1lOiAnREVCRycsXG4gICAgICBsYWJlbDogJ0RlYnVnJyxcbiAgICAgIGNvbnNvbGVNZXRob2ROYW1lOiAnZGVidWcnXG4gICAgfSxcbiAgICB7XG4gICAgICBuYW1lOiAnSU5GTycsXG4gICAgICBzaG9ydE5hbWU6ICdJTkZPJyxcbiAgICAgIGxhYmVsOiAnSW5mbycsXG4gICAgICBjb25zb2xlTWV0aG9kTmFtZTogJ2luZm8nXG4gICAgfSxcbiAgICB7XG4gICAgICBuYW1lOiAnV0FSTicsXG4gICAgICBzaG9ydE5hbWU6ICdXQVJOJyxcbiAgICAgIGxhYmVsOiAnV2FybicsXG4gICAgICBjb25zb2xlTWV0aG9kTmFtZTogJ3dhcm4nXG4gICAgfSxcbiAgICB7XG4gICAgICBuYW1lOiAnRVJST1InLFxuICAgICAgc2hvcnROYW1lOiAnRVJSUicsXG4gICAgICBsYWJlbDogJ0Vycm9yJyxcbiAgICAgIGNvbnNvbGVNZXRob2ROYW1lOiAnZXJyb3InXG4gICAgfVxuICBdXG59KTtcbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IFRoZSBGT0FNIEF1dGhvcnMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmZvYW0uSU5URVJGQUNFKHtcbiAgcGFja2FnZTogJ2ZvYW0ubG9nJyxcbiAgbmFtZTogJ0xvZ2dlcicsXG5cbiAgbWV0aG9kczogW1xuICAgIHsgbmFtZTogJ2RlYnVnJywgZG9jdW1lbnRhdGlvbjogJ0xvZyBhdCBcImRlYnVnXCIgbG9nIGxldmVsLicgfSxcbiAgICB7IG5hbWU6ICdsb2cnLCAgIGRvY3VtZW50YXRpb246ICdTeW5vbnltIGZvciBcImluZm9cIi4nICAgICAgIH0sXG4gICAgeyBuYW1lOiAnaW5mbycsICBkb2N1bWVudGF0aW9uOiAnTG9nIGF0IFwiaW5mb1wiIGxvZyBsZXZlbC4nICB9LFxuICAgIHsgbmFtZTogJ3dhcm4nLCAgZG9jdW1lbnRhdGlvbjogJ0xvZyBhdCBcIndhcm5cIiBsb2cgbGV2ZWwuJyAgfSxcbiAgICB7IG5hbWU6ICdlcnJvcicsIGRvY3VtZW50YXRpb246ICdMb2cgYXQgXCJlcnJvclwiIGxvZyBsZXZlbC4nIH1cbiAgXSxcbn0pO1xuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgVGhlIEZPQU0gQXV0aG9ycy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuZm9hbS5DTEFTUyh7XG4gIHBhY2thZ2U6ICdmb2FtLmxvZycsXG4gIG5hbWU6ICdDb25zb2xlTG9nZ2VyJyxcbiAgaW1wbGVtZW50czogWyAnZm9hbS5sb2cuTG9nZ2VyJyBdLFxuXG4gIGRvY3VtZW50YXRpb246IGBEZWNvcmF0ZSBjb250ZXh0dWFsIGxvZ2dpbmcgbWV0aG9kcyB3aXRoIGxvZyBsZXZlbCAoc2hvcnRcbiAgICAgIG5hbWUpIGFuZCBkYXRlIHN0cmluZ2AsXG5cbiAgcmVxdWlyZXM6IFsgJ2ZvYW0ubG9nLkxvZ0xldmVsJyBdLFxuXG4gIGltcG9ydHM6IFtcbiAgICAnZGVidWcgYXMgZGVidWdfJyxcbiAgICAnbG9nIGFzIGxvZ18nLFxuICAgICdpbmZvIGFzIGluZm9fJyxcbiAgICAnd2FybiBhcyB3YXJuXycsXG4gICAgJ2Vycm9yIGFzIGVycm9yXydcbiAgXSxcblxuICBleHBvcnRzOiBbXG4gICAgJ2RlYnVnJyxcbiAgICAnbG9nJyxcbiAgICAnaW5mbycsXG4gICAgJ3dhcm4nLFxuICAgICdlcnJvcidcbiAgXSxcblxuICBwcm9wZXJ0aWVzOiBbXG4gICAge1xuICAgICAgY2xhc3M6ICdGdW5jdGlvbicsXG4gICAgICBuYW1lOiAnZGVidWcnLFxuICAgICAgZmFjdG9yeTogZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLnB1dC5iaW5kKHRoaXMsIHRoaXMuTG9nTGV2ZWwuREVCVUcpOyB9XG4gICAgfSxcbiAgICB7XG4gICAgICBjbGFzczogJ0Z1bmN0aW9uJyxcbiAgICAgIGRvY3VtZW50YXRpb246ICdTeW5vbnltIGZvciBcImluZm9cIi4nLFxuICAgICAgbmFtZTogJ2xvZycsXG4gICAgICBmYWN0b3J5OiBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMucHV0LmJpbmQodGhpcywgdGhpcy5Mb2dMZXZlbC5JTkZPKTsgfVxuICAgIH0sXG4gICAge1xuICAgICAgY2xhc3M6ICdGdW5jdGlvbicsXG4gICAgICBuYW1lOiAnaW5mbycsXG4gICAgICBmYWN0b3J5OiBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMucHV0LmJpbmQodGhpcywgdGhpcy5Mb2dMZXZlbC5JTkZPKTsgfVxuICAgIH0sXG4gICAge1xuICAgICAgY2xhc3M6ICdGdW5jdGlvbicsXG4gICAgICBuYW1lOiAnd2FybicsXG4gICAgICBmYWN0b3J5OiBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMucHV0LmJpbmQodGhpcywgdGhpcy5Mb2dMZXZlbC5XQVJOKTsgfVxuICAgIH0sXG4gICAge1xuICAgICAgY2xhc3M6ICdGdW5jdGlvbicsXG4gICAgICBuYW1lOiAnZXJyb3InLFxuICAgICAgZmFjdG9yeTogZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLnB1dC5iaW5kKHRoaXMsIHRoaXMuTG9nTGV2ZWwuRVJST1IpOyB9XG4gICAgfSxcbiAgICB7XG4gICAgICBjbGFzczogJ0Z1bmN0aW9uJyxcbiAgICAgIG5hbWU6ICdnZXREYXRlU3RyaW5nJyxcbiAgICAgIGZhY3Rvcnk6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7IHJldHVybiAobmV3IERhdGUoKSkudG9TdHJpbmcoKTsgfTtcbiAgICAgIH1cbiAgICB9XG4gIF0sXG5cbiAgbWV0aG9kczogW1xuICAgIGZ1bmN0aW9uIHB1dChsb2dMZXZlbCkge1xuICAgICAgdmFyIGFyZ3MgPSBbIGxvZ0xldmVsLnNob3J0TmFtZSwgJ1snICsgdGhpcy5nZXREYXRlU3RyaW5nKCkgKyAnXScgXVxuICAgICAgICAgIC5jb25jYXQoQXJyYXkuZnJvbShhcmd1bWVudHMpLnNsaWNlKDEpKTtcbiAgICAgIHRoaXNbbG9nTGV2ZWwuY29uc29sZU1ldGhvZE5hbWUgKyAnXyddLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgIH1cbiAgXVxufSk7XG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNSBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5mb2FtLkNMQVNTKHtcbiAgcGFja2FnZTogJ2ZvYW0ubWVtZW50bycsXG4gIG5hbWU6ICdNZW1lbnRvTWdyJyxcblxuICBkb2N1bWVudGF0aW9uOiAnUHJvdmlkZSBtZW1lbnRvIHVuZG8vcmVkbyBzdXBwb3J0LicsXG5cbiAgcHJvcGVydGllczogW1xuICAgIHtcbiAgICAgIG5hbWU6ICdtZW1lbnRvJ1xuICAgIH0sXG4gICAge1xuICAgICAgbmFtZTogJ3N0YWNrJyxcbiAgICAgIGZhY3Rvcnk6IGZ1bmN0aW9uKCkgeyByZXR1cm4gW107IH1cbiAgICB9LFxuICAgIHtcbiAgICAgIG5hbWU6ICdyZWRvJyxcbiAgICAgIGZhY3Rvcnk6IGZ1bmN0aW9uKCkgeyByZXR1cm4gW107IH1cbiAgICB9LFxuICAgICdwb3NGZWVkYmFja18nLFxuICAgIHtcbiAgICAgIGNsYXNzOiAnSW50JyxcbiAgICAgIG5hbWU6ICdwb3NpdGlvbicsXG4gICAgICBwb3N0U2V0OiBmdW5jdGlvbihfLCBuKSB7XG4gICAgICAgIGlmICggdGhpcy5wb3NGZWVkYmFja18gKSByZXR1cm47XG5cbiAgICAgICAgd2hpbGUgKCBuIDwgdGhpcy5zdGFja1NpemVfICkgdGhpcy5iYWNrKCk7XG4gICAgICAgIHdoaWxlICggbiA+IHRoaXMuc3RhY2tTaXplXyApIHRoaXMuZm9ydGgoKTtcbiAgICAgIH1cbiAgICB9LFxuICAgICdzdGFja1NpemVfJyxcbiAgICAncmVkb1NpemVfJyxcbiAgICAndG90YWxTaXplXydcbiAgXSxcblxuICBtZXRob2RzOiBbXG4gICAgZnVuY3Rpb24gaW5pdCgpIHtcbiAgICAgIHRoaXMubWVtZW50byQuc3ViKHRoaXMub25NZW1lbnRvQ2hhbmdlKTtcbiAgICB9LFxuXG4gICAgZnVuY3Rpb24gdXBkYXRlU2l6ZXMoKSB7XG4gICAgICB0aGlzLnBvc0ZlZWRiYWNrXyAgPSB0cnVlO1xuICAgICAgdGhpcy5zdGFja1NpemVfICAgID0gdGhpcy5zdGFjay5sZW5ndGg7XG4gICAgICB0aGlzLnJlZG9TaXplXyAgICAgPSB0aGlzLnJlZG8ubGVuZ3RoO1xuICAgICAgdGhpcy50b3RhbFNpemVfICAgID0gdGhpcy5zdGFjay5sZW5ndGggKyB0aGlzLnJlZG8ubGVuZ3RoO1xuICAgICAgdGhpcy5wb3NpdGlvbiAgICAgID0gdGhpcy5zdGFjay5sZW5ndGg7XG4gICAgICB0aGlzLnBvc0ZlZWRiYWNrXyAgPSBmYWxzZTtcbiAgICB9LFxuXG4gICAgZnVuY3Rpb24gcmVtZW1iZXIobWVtZW50bykge1xuICAgICAgdGhpcy5kdW1wU3RhdGUoJ3ByZVJlbWVtYmVyJyk7XG4gICAgICB0aGlzLnN0YWNrLnB1c2gobWVtZW50byk7XG4gICAgICB0aGlzLnVwZGF0ZVNpemVzKCk7XG4gICAgICB0aGlzLmR1bXBTdGF0ZSgncG9zdFJlbWVtYmVyJyk7XG4gICAgfSxcblxuICAgIGZ1bmN0aW9uIHJlc3RvcmUobWVtZW50bykge1xuICAgICAgdGhpcy5kdW1wU3RhdGUoJ3ByZVJlc3RvcmUnKTtcbiAgICAgIHRoaXMuaWdub3JlXyA9IHRydWU7XG4gICAgICB0aGlzLm1lbWVudG8gPSBtZW1lbnRvO1xuICAgICAgdGhpcy5pZ25vcmVfID0gZmFsc2U7XG4gICAgICB0aGlzLmR1bXBTdGF0ZSgncG9zdFJlc3RvcmUnKTtcbiAgICB9LFxuXG4gICAgZnVuY3Rpb24gZHVtcFN0YXRlKHNwb3QpIHtcbiAgICAgIC8vIFVuY29tbWVudCBmb3IgZGVidWdnaW5nXG4gICAgICAvKlxuICAgICAgY29uc29sZS5sb2coJy0tLSAnLCBzcG90KTtcbiAgICAgIGNvbnNvbGUubG9nKCdzdGFjazogJywgSlNPTi5zdHJpbmdpZnkodGhpcy5zdGFjaykpO1xuICAgICAgY29uc29sZS5sb2coJ3JlZG86ICcsIEpTT04uc3RyaW5naWZ5KHRoaXMucmVkbykpO1xuICAgICAgKi9cbiAgICB9XG4gIF0sXG5cbiAgYWN0aW9uczogW1xuICAgIHtcbiAgICAgIG5hbWU6ICAnYmFjaycsXG4gICAgICBsYWJlbDogJyA8LS0gJyxcbiAgICAgIGhlbHA6ICAnR28gdG8gcHJldmlvdXMgdmlldycsXG5cbiAgICAgIGlzRW5hYmxlZDogZnVuY3Rpb24oc3RhY2tTaXplXykgeyByZXR1cm4gISEgc3RhY2tTaXplXzsgfSxcbiAgICAgIGNvZGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLmR1bXBTdGF0ZSgncHJlQmFjaycpO1xuICAgICAgICB0aGlzLnJlZG8ucHVzaCh0aGlzLm1lbWVudG8pO1xuICAgICAgICB0aGlzLnJlc3RvcmUodGhpcy5zdGFjay5wb3AoKSk7XG4gICAgICAgIHRoaXMudXBkYXRlU2l6ZXMoKTtcbiAgICAgICAgdGhpcy5kdW1wU3RhdGUoJ3Bvc3RCYWNrJyk7XG4gICAgICB9XG4gICAgfSxcbiAgICB7XG4gICAgICBuYW1lOiAgJ2ZvcnRoJyxcbiAgICAgIGxhYmVsOiAnIC0tPiAnLFxuICAgICAgaGVscDogICdVbmRvIHRoZSBwcmV2aW91cyBiYWNrLicsXG5cbiAgICAgIGlzRW5hYmxlZDogZnVuY3Rpb24ocmVkb1NpemVfKSB7IHJldHVybiAhISByZWRvU2l6ZV87IH0sXG4gICAgICBjb2RlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5kdW1wU3RhdGUoJ3ByZUZvcnRoJyk7XG4gICAgICAgIHRoaXMucmVtZW1iZXIodGhpcy5tZW1lbnRvKTtcbiAgICAgICAgdGhpcy5yZXN0b3JlKHRoaXMucmVkby5wb3AoKSk7XG4gICAgICAgIHRoaXMudXBkYXRlU2l6ZXMoKTtcbiAgICAgICAgdGhpcy5kdW1wU3RhdGUoJ3Bvc3RGb3J0aCcpO1xuICAgICAgfVxuICAgIH1cbiAgXSxcblxuICBsaXN0ZW5lcnM6IFtcbiAgICBmdW5jdGlvbiBvbk1lbWVudG9DaGFuZ2UoXyxfXyxfX18sbWVtZW50byQpIHtcbiAgICAgIGlmICggdGhpcy5pZ25vcmVfICkgcmV0dXJuO1xuXG4gICAgICAvLyBjb25zb2xlLmxvZygnTWVtZW50b01nci5vbkNoYW5nZScsIG9sZFZhbHVlLCBuZXdWYWx1ZSk7XG4gICAgICB0aGlzLnJlbWVtYmVyKG1lbWVudG8kLm9sZFZhbHVlKTtcbiAgICAgIHRoaXMucmVkbyA9IFtdO1xuICAgICAgdGhpcy51cGRhdGVTaXplcygpO1xuICAgIH1cbiAgXVxufSk7XG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBUaGUgRk9BTSBBdXRob3JzLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5mb2FtLkNMQVNTKHtcbiAgcGFja2FnZTogJ2ZvYW0ud2ViJyxcbiAgbmFtZTogJ0RldGFjaGVkVVJMU3RhdGUnLFxuXG4gIGRvY3VtZW50YXRpb246IGBmb2FtLndlYi5VUkxTdGF0ZSB0aGF0IGlzIGRldGFjaGVkIGZyb21cbiAgICAgIHdpbmRvdy5sb2NhdGlvbi5oYXNoLmAsXG5cbiAgcmVxdWlyZXM6IFtcbiAgICAnZm9hbS5qc29uLk91dHB1dHRlcicsXG4gICAgJ2ZvYW0uanNvbi5QYXJzZXInXG4gIF0sXG4gIGltcG9ydHM6IFsgJ3dhcm4nLCAnd2luZG93JyBdLFxuXG4gIHByb3BlcnRpZXM6IFtcbiAgICB7XG4gICAgICBuYW1lOiAnc2VyaWFsaXplcicsXG4gICAgICBkb2N1bWVudGF0aW9uOiAnSW1wbGVtZW50ZXIgb2Ygc3RyaW5naWZ5KHZhbHVlKSBmb3IgdmFsdWUgc2VyaWFsaXphdGlvbi4nLFxuICAgICAgZmFjdG9yeTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLk91dHB1dHRlci5jcmVhdGUoe1xuICAgICAgICAgIHByZXR0eTogZmFsc2UsXG4gICAgICAgICAgZm9ybWF0RGF0ZXNBc051bWJlcnM6IHRydWUsXG4gICAgICAgICAgb3V0cHV0RGVmYXVsdFZhbHVlczogZmFsc2UsXG4gICAgICAgICAgc3RyaWN0OiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0sXG4gICAge1xuICAgICAgbmFtZTogJ2Rlc2VyaWFsaXplcicsXG4gICAgICBkb2N1bWVudGF0aW9uOiBgSW1wbGVtZW50ZXIgb2YgcGFyc2VTdHJpbmcoc3RyKSBmb3IgdmFsdWVcbiAgICAgICAgICBkZXNlcmlhbGl6YXRpb24uYCxcbiAgICAgIGZhY3Rvcnk6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5QYXJzZXIuY3JlYXRlKHtcbiAgICAgICAgICBzdHJpY3Q6IHRydWUsXG4gICAgICAgICAgY3JlYXRpb25Db250ZXh0OiB0aGlzLl9fc3ViQ29udGV4dF9fXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0sXG4gICAge1xuICAgICAgbmFtZTogJ2JpbmRpbmdzTWFwXycsXG4gICAgICBkb2N1bWVudGF0aW9uOiAnTWFwIG9mIHs8a2V5PjogZm9hbS5jb3JlLlNsb3R9IGNvbXByaXNpbmcgc3RhdGUuJyxcbiAgICAgIGZhY3Rvcnk6IGZ1bmN0aW9uKCkgeyByZXR1cm4ge307IH1cbiAgICB9LFxuICAgIHtcbiAgICAgIG5hbWU6ICdzdWJNYXBfJyxcbiAgICAgIGRvY3VtZW50YXRpb246IGBNYXAgb2YgezxrZXk+OiA8ZXZlbnQgc3Vic2NyaXB0aW9uPn0gcGFyYWxsZWwgdG9cbiAgICAgICAgICBiaW5kaW5nc01hcF8uYCxcbiAgICAgIGZhY3Rvcnk6IGZ1bmN0aW9uKCkgeyByZXR1cm4ge307IH1cbiAgICB9LFxuICAgIHtcbiAgICAgIG5hbWU6ICd1bmJvdW5kTWFwXycsXG4gICAgICBkb2N1bWVudGF0aW9uOiBgTWFwIG9mIHs8a2V5PjogPGRlc2VyaWFsaXplZCB2YWx1ZT59IHRoYXQgY29udGFpbnNcbiAgICAgICAgICBiaW5kaW5ncyBsb2FkZWQgZnJvbSBoYXNoLCBidXQgbm90IGJvdW5kIHRvIGEgZm9hbS5jb3JlLlNsb3QuYCxcbiAgICAgIGZhY3Rvcnk6IGZ1bmN0aW9uKCkgeyByZXR1cm4ge307IH1cbiAgICB9LFxuICAgIHtcbiAgICAgIGNsYXNzOiAnU3RyaW5nJyxcbiAgICAgIG5hbWU6ICdwYXRoXycsXG4gICAgICBkb2N1bWVudGF0aW9uOiBgXCJwYXRoXCIgcGFydCBvZiBoYXNoOyBoYXNoIGlzOlxuICAgICAgICAgIFwiIzxwYXRoPj88a2V5MT49PHZhbHVlMT4mPGtleTI+PTx2YWx1ZTI+Li4uXCJgLFxuICAgICAgcG9zdFNldDogZnVuY3Rpb24ob2xkLCBudSkge1xuICAgICAgICBpZiAoIG9sZCAhPT0gbnUgKSB0aGlzLm9uU3RhdGVDaGFuZ2UoKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHtcbiAgICAgIGNsYXNzOiAnU3RyaW5nJyxcbiAgICAgIG5hbWU6ICdoYXNoXycsXG4gICAgICBkb2N1bWVudGF0aW9uOiAnQ29tcGxldGUgc3RhdGUgc2VyaWFsaXplZCB0byBhIFVSTCBoYXNoIHZhbHVlLicsXG4gICAgfSxcbiAgXSxcblxuICBtZXRob2RzOiBbXG4gICAgZnVuY3Rpb24gaW5pdCgpIHtcbiAgICAgIHRoaXMuU1VQRVIoKTtcbiAgICAgIHRoaXMuaGFzaFRvU3RhdGVfKCk7XG4gICAgfSxcbiAgICBmdW5jdGlvbiBnZXRIYXNoKCkgeyByZXR1cm4gdGhpcy5oYXNoXzsgfSxcbiAgICBmdW5jdGlvbiBzZXRIYXNoKGhhc2gpIHtcbiAgICAgIHRoaXMuaGFzaF8gPSBoYXNoO1xuICAgICAgdGhpcy5oYXNoVG9TdGF0ZV8oKTtcbiAgICB9LFxuICAgIGZ1bmN0aW9uIGdldFBhdGgoKSB7IHJldHVybiB0aGlzLnBhdGhfOyB9LFxuICAgIGZ1bmN0aW9uIHNldFBhdGgocGF0aCkgeyByZXR1cm4gdGhpcy5wYXRoXyA9IHBhdGg7IH0sXG4gICAgZnVuY3Rpb24gZ2V0U2xvdChuYW1lKSB7XG4gICAgICByZXR1cm4gdGhpcy5iaW5kaW5nc01hcF9bbmFtZV0gfHwgbnVsbDtcbiAgICB9LFxuICAgIGZ1bmN0aW9uIGFkZEJpbmRpbmcobmFtZSwgc2xvdCkge1xuICAgICAgaWYgKCB0aGlzLmJpbmRpbmdzTWFwXy5oYXNPd25Qcm9wZXJ0eShuYW1lKSApIHtcbiAgICAgICAgdGhpcy53YXJuKCdPdmVyd3JpdGluZyBVUkxTdGF0ZTonLCBuYW1lLCB0aGlzLmJpbmRpbmdzTWFwX1tuYW1lXSxcbiAgICAgICAgICAgICAgICAgICd3aXRoJywgc2xvdCk7XG4gICAgICAgIHRoaXMuc3ViTWFwX1tuYW1lXS5kZXRhY2goKTtcbiAgICAgIH1cbiAgICAgIGlmICggdGhpcy51bmJvdW5kTWFwXy5oYXNPd25Qcm9wZXJ0eShuYW1lKSApIHtcbiAgICAgICAgc2xvdC5zZXQodGhpcy51bmJvdW5kTWFwX1tuYW1lXSk7XG4gICAgICAgIGRlbGV0ZSB0aGlzLnVuYm91bmRNYXBfW25hbWVdO1xuICAgICAgfVxuICAgICAgdGhpcy5iaW5kaW5nc01hcF9bbmFtZV0gPSBzbG90O1xuICAgICAgdGhpcy5zdWJNYXBfW25hbWVdID0gc2xvdC5zdWIodGhpcy5vblN0YXRlQ2hhbmdlKTtcbiAgICAgIHRoaXMub25TdGF0ZUNoYW5nZSgpO1xuICAgIH0sXG4gICAgZnVuY3Rpb24gcmVtb3ZlQmluZGluZyhuYW1lKSB7XG4gICAgICBpZiAoICEgdGhpcy5iaW5kaW5nc01hcF8uaGFzT3duUHJvcGVydHkobmFtZSkgKSByZXR1cm47XG4gICAgICB0aGlzLnN1Yk1hcF9bbmFtZV0uZGV0YWNoKCk7XG4gICAgICBkZWxldGUgdGhpcy5zdWJNYXBfW25hbWVdO1xuICAgICAgZGVsZXRlIHRoaXMuYmluZGluZ3NNYXBfW25hbWVdO1xuICAgICAgdGhpcy5vblN0YXRlQ2hhbmdlKCk7XG4gICAgfSxcbiAgICBmdW5jdGlvbiBjbGVhckJpbmRpbmdzKCkge1xuICAgICAgdmFyIHN1Yk1hcCA9IHRoaXMuc3ViTWFwXztcbiAgICAgIGZvciAoIHZhciBrZXkgaW4gc3ViTWFwICkge1xuICAgICAgICBpZiAoICEgc3ViTWFwLmhhc093blByb3BlcnR5KGtleSkgKSBjb250aW51ZTtcbiAgICAgICAgc3ViTWFwW2tleV0uZGV0YWNoKCk7XG4gICAgICB9XG4gICAgICB0aGlzLnN1Yk1hcF8gPSB7fTtcbiAgICAgIHRoaXMuYmluZGluZ3NNYXBfID0ge307XG4gICAgICB0aGlzLnVuYm91bmRNYXBfID0ge307XG4gICAgICB0aGlzLm9uU3RhdGVDaGFuZ2UoKTtcbiAgICB9LFxuICAgIGZ1bmN0aW9uIHN0YXRlVG9IYXNoXygpIHtcbiAgICAgIHZhciBzdGF0ZVN0ciA9ICcnO1xuICAgICAgc3RhdGVTdHIgPSB0aGlzLmFwcGVuZE1hcFRvU3RhdGVTdHJfKFxuICAgICAgICAgIHN0YXRlU3RyLCB0aGlzLmJpbmRpbmdzTWFwXywgdGhpcy5nZXRCb3VuZFZhbHVlKTtcbiAgICAgIHN0YXRlU3RyID0gdGhpcy5hcHBlbmRNYXBUb1N0YXRlU3RyXyhcbiAgICAgICAgICBzdGF0ZVN0ciwgdGhpcy51bmJvdW5kTWFwXywgdGhpcy5nZXRVbmJvdW5kVmFsdWUpO1xuXG4gICAgICB0aGlzLmhhc2hfID0gJyMnICsgdGhpcy5wYXRoXyArICc/JyArIHN0YXRlU3RyO1xuICAgIH0sXG4gICAgZnVuY3Rpb24gYXBwZW5kTWFwVG9TdGF0ZVN0cl8oc3RyLCBtYXAsIGdldE1hcFZhbHVlKSB7XG4gICAgICBmb3IgKCB2YXIga2V5IGluIG1hcCApIHtcbiAgICAgICAgaWYgKCAhIG1hcC5oYXNPd25Qcm9wZXJ0eShrZXkpICkgY29udGludWU7XG5cbiAgICAgICAgaWYgKCBzdHIgIT09ICcnICkgc3RyICs9ICcmJztcblxuICAgICAgICB2YXIgdmFsdWUgPSB0aGlzLnNlcmlhbGl6ZXIuc3RyaW5naWZ5KGdldE1hcFZhbHVlKGtleSkpO1xuICAgICAgICBzdHIgKz0gdGhpcy53aW5kb3cuZW5jb2RlVVJJQ29tcG9uZW50KGtleSkgKyAnPScgK1xuICAgICAgICAgICAgdGhpcy53aW5kb3cuZW5jb2RlVVJJQ29tcG9uZW50KHZhbHVlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzdHI7XG4gICAgfSxcbiAgICBmdW5jdGlvbiBoYXNoVG9TdGF0ZV8oKSB7XG4gICAgICB2YXIgaGFzaCA9IHRoaXMuaGFzaF87XG4gICAgICB2YXIgcmVzID0gdGhpcy5oYXNoR3JhbW1hci5wYXJzZVN0cmluZyhoYXNoLCAnaGFzaCcpO1xuICAgICAgZm9hbS5hc3NlcnQocmVzLCAnSW52YWxpZCBVUkxTdGF0ZSBoYXNoOiAnICsgaGFzaCk7XG5cbiAgICAgIHRoaXMucGF0aF8gPSB0aGlzLndpbmRvdy5kZWNvZGVVUklDb21wb25lbnQocmVzLnBhdGgpO1xuICAgICAgdmFyIGJpbmRpbmdzTWFwID0gdGhpcy5iaW5kaW5nc01hcF87XG4gICAgICB2YXIgYmluZGluZ3MgPSByZXMuYmluZGluZ3M7XG4gICAgICBmb3IgKCB2YXIgaSA9IDA7IGkgPCBiaW5kaW5ncy5sZW5ndGg7IGkrKyApIHtcbiAgICAgICAgdmFyIGJpbmRpbmcgPSBiaW5kaW5nc1tpXTtcbiAgICAgICAgdmFyIGtleSA9IHRoaXMud2luZG93LmRlY29kZVVSSUNvbXBvbmVudChiaW5kaW5nLmtleSk7XG4gICAgICAgIHZhciB2YWx1ZSA9IHRoaXMuZGVzZXJpYWxpemVyLnBhcnNlU3RyaW5nKFxuICAgICAgICAgICAgdGhpcy53aW5kb3cuZGVjb2RlVVJJQ29tcG9uZW50KGJpbmRpbmcudmFsdWUpKTtcbiAgICAgICAgaWYgKCBiaW5kaW5nc01hcC5oYXNPd25Qcm9wZXJ0eShrZXkpICkge1xuICAgICAgICAgIGlmICggISBmb2FtLnV0aWwuZXF1YWxzKGJpbmRpbmdzTWFwW2tleV0uZ2V0KCksIHZhbHVlKSApXG4gICAgICAgICAgICBiaW5kaW5nc01hcFtrZXldLnNldCh2YWx1ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy51bmJvdW5kTWFwX1trZXldID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIF0sXG5cbiAgbGlzdGVuZXJzOiBbXG4gICAgZnVuY3Rpb24gb25TdGF0ZUNoYW5nZSgpIHsgdGhpcy5zdGF0ZVRvSGFzaF8oKTsgfSxcbiAgICBmdW5jdGlvbiBnZXRCb3VuZFZhbHVlKGtleSkge1xuICAgICAgcmV0dXJuIHRoaXMuYmluZGluZ3NNYXBfW2tleV0gJiYgdGhpcy5iaW5kaW5nc01hcF9ba2V5XS5nZXQoKTtcbiAgICB9LFxuICAgIGZ1bmN0aW9uIGdldFVuYm91bmRWYWx1ZShrZXkpIHsgcmV0dXJuIHRoaXMudW5ib3VuZE1hcF9ba2V5XTsgfVxuICBdLFxuXG4gIGdyYW1tYXJzOiBbXG4gICAge1xuICAgICAgbmFtZTogJ2hhc2hHcmFtbWFyJyxcbiAgICAgIGxhbmd1YWdlOiAnZm9hbS5wYXJzZS5qc29uLlBhcnNlcnMnLFxuICAgICAgc3ltYm9sczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgaGFzaDogb3B0aW9uYWwoXG4gICAgICAgICAgICAgIHNlcSgnIycsIG9wdGlvbmFsKHN5bSgncGF0aCcpKSxcbiAgICAgICAgICAgICAgICAgIG9wdGlvbmFsKHNlcTEoMSwgJz8nLCByZXBlYXQoc3ltKCdiaW5kaW5nJyksICcmJykpKSkpLFxuICAgICAgICAgIHBhdGg6IHN0cihyZXBlYXQobm90Q2hhcnMoJz8nKSkpLFxuICAgICAgICAgIGJpbmRpbmc6IHNlcShzeW0oJ2tleScpLCBvcHRpb25hbChzZXExKDEsICc9Jywgc3ltKCd2YWx1ZScpKSkpLFxuICAgICAgICAgIGtleTogc3RyKHBsdXMobm90Q2hhcnMoJz0mJykpKSxcbiAgICAgICAgICB2YWx1ZTogc3RyKHBsdXMobm90Q2hhcnMoJz0mJykpKVxuICAgICAgICB9O1xuICAgICAgfSxcbiAgICAgIGFjdGlvbnM6IFtcbiAgICAgICAgZnVuY3Rpb24gYmluZGluZyh2KSB7IHJldHVybiB7IGtleTogdlswXSwgdmFsdWU6IHZbMV0gfTsgfSxcbiAgICAgICAgZnVuY3Rpb24gaGFzaCh2KSB7XG4gICAgICAgICAgcmV0dXJuIHsgcGF0aDogdiAmJiB2WzFdIHx8ICcnICwgYmluZGluZ3M6IHYgJiYgdlsyXSB8fCBbXSB9O1xuICAgICAgICB9XG4gICAgICBdXG4gICAgfVxuICBdXG59KTtcbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IFRoZSBGT0FNIEF1dGhvcnMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmZvYW0uQ0xBU1Moe1xuICBwYWNrYWdlOiAnZm9hbS53ZWInLFxuICBuYW1lOiAnVVJMU3RhdGUnLFxuICBleHRlbmRzOiAnZm9hbS53ZWIuRGV0YWNoZWRVUkxTdGF0ZScsXG5cbiAgZG9jdW1lbnRhdGlvbjogYEEgVVJMLWJhc2VkIHN0cmF0ZWd5IGZvciBzdG9yaW5nIGFwcGxpY2F0aW9uIHN0YXRlIGluIHRoZSBVUkxcbiAgICAgIGhhc2guIFByb2R1Y2VzIGhhc2hlcyBvZiB0aGUgZm9ybTpcblxuICAgICAgIzxwYXRoPj88a2V5MT49PHZhbHVlMT4mPGtleTI+PTx2YWx1ZTI+Li4uXG5cbiAgICAgIEFsbCBwYXJ0cyBhcmUgVVJJLWVuY29kZWQuIFRoZSBcInBhdGhcIiBpcyBpbnRlbmRlZCBhcyBhIHRvcC1sZXZlbFxuICAgICAgZGVzY3JpcHRpb24gd2hhdCB2aWV3L2NvbnRyb2xsZXIgdGhlIGFwcGxpY2F0aW9uIGlzIHJlbmRlcmluZy4gS2V5cyBhbmRcbiAgICAgIHZhbHVlcyBhZGRpdGlvbmFsIHN0YXRlIGJpbmRpbmdzIHRvIGJlIHJlZmxlY3RlZCBpbiB0aGUgVVJMIGhhc2guYCxcblxuICByZXF1aXJlczogW1xuICAgICdmb2FtLmpzb24uT3V0cHV0dGVyJyxcbiAgICAnZm9hbS5qc29uLlBhcnNlcidcbiAgXSxcbiAgaW1wb3J0czogWyAnd2FybicsICd3aW5kb3cnIF0sXG5cbiAgbWV0aG9kczogW1xuICAgIGZ1bmN0aW9uIGluaXQoKSB7XG4gICAgICB0aGlzLlNVUEVSKCk7XG4gICAgICB0aGlzLnNldEhhc2godGhpcy53aW5kb3cubG9jYXRpb24uaGFzaCk7XG4gICAgICB0aGlzLndpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdoYXNoY2hhbmdlJywgdGhpcy5vbkhhc2hDaGFuZ2UpO1xuICAgIH0sXG4gIF0sXG5cbiAgbGlzdGVuZXJzOiBbXG4gICAgZnVuY3Rpb24gb25IYXNoQ2hhbmdlKCkge1xuICAgICAgdGhpcy5zZXRIYXNoKHRoaXMud2luZG93LmxvY2F0aW9uLmhhc2gpO1xuICAgICAgdGhpcy5oYXNoVG9TdGF0ZV8oKTtcbiAgICB9LFxuICAgIHtcbiAgICAgIG5hbWU6ICdvblN0YXRlQ2hhbmdlJyxcbiAgICAgIGlzTWVyZ2VkOiB0cnVlLFxuICAgICAgbWVyZ2VEZWxheTogMTUwLFxuICAgICAgY29kZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuc3RhdGVUb0hhc2hfKCk7XG4gICAgICAgIHRoaXMud2luZG93LmxvY2F0aW9uLmhhc2ggPSB0aGlzLmhhc2hfO1xuICAgICAgfVxuICAgIH1cbiAgXVxufSk7XG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5mb2FtLkNMQVNTKHtcbiAgcGFja2FnZTogJ2ZvYW0uaW5wdXQnLFxuICBuYW1lOiAnVG91Y2hFdmVudCcsXG5cbiAgcHJvcGVydGllczogW1xuICAgIHtcbiAgICAgIGNsYXNzOiAnRmxvYXQnLFxuICAgICAgbmFtZTogJ3gnXG4gICAgfSxcbiAgICB7XG4gICAgICBjbGFzczogJ0Zsb2F0JyxcbiAgICAgIG5hbWU6ICd5J1xuICAgIH0sXG4gICAge1xuICAgICAgY2xhc3M6ICdCb29sZWFuJyxcbiAgICAgIG5hbWU6ICdjbGFpbWVkJyxcbiAgICAgIHZhbHVlOiBmYWxzZVxuICAgIH1cbiAgXVxufSk7XG5cblxuZm9hbS5DTEFTUyh7XG4gIHBhY2thZ2U6ICdmb2FtLmlucHV0JyxcbiAgbmFtZTogJ01vdXNlJyxcblxuICB0b3BpY3M6IFtcbiAgICAnZG93bicsXG4gICAgJ21vdmUnLFxuICAgICd0b3VjaCcsXG4gICAgJ3VwJ1xuICBdLFxuXG4gIHByb3BlcnRpZXM6IFtcbiAgICAnbGFzdFRvdWNoJyxcbiAgICAneCcsXG4gICAgJ3knLFxuICAgIHtcbiAgICAgIG5hbWU6ICdlbGVtZW50JyxcbiAgICAgIHBvc3RTZXQ6IGZ1bmN0aW9uKG9sZCwgZSkge1xuICAgICAgICBpZiAoIG9sZCApIHtcbiAgICAgICAgICBvbGQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgdGhpcy5vbk1vdXNlRG93bik7XG4gICAgICAgICAgb2xkLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCAgIHRoaXMub25Nb3VzZVVwKTtcbiAgICAgICAgICBvbGQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgdGhpcy5vbk1vdXNlTW92ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZS5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCB0aGlzLm9uTW91c2VEb3duKTtcbiAgICAgICAgZS5hZGRFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgICB0aGlzLm9uTW91c2VVcCk7XG4gICAgICAgIGUuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgdGhpcy5vbk1vdXNlTW92ZSk7XG4gICAgICB9XG4gICAgfVxuICBdLFxuXG4gIG1ldGhvZHM6IFtcbiAgICBmdW5jdGlvbiBpbnN0YWxsKGVsZW1lbnQpIHtcbiAgICAgIHRoaXMucmVmID0gZWxlbWVudDtcbiAgICB9XG4gIF0sXG5cbiAgbGlzdGVuZXJzOiBbXG4gICAge1xuICAgICAgbmFtZTogJ29uTW91c2VEb3duJyxcbiAgICAgIGNvZGU6IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgdmFyIGJvdW5kcyA9IHRoaXMuZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcblxuICAgICAgICB0aGlzLnggPSBlLmNsaWVudFggLSBib3VuZHMubGVmdDtcbiAgICAgICAgdGhpcy55ID0gZS5jbGllbnRZIC0gYm91bmRzLnRvcDtcblxuICAgICAgICB0aGlzLmRvd24ucHViKCk7XG5cbiAgICAgICAgaWYgKCB0aGlzLnRvdWNoLmhhc0xpc3RlbmVycygpICkge1xuICAgICAgICAgIGlmICggdGhpcy5sYXN0VG91Y2ggKSB0aGlzLmxhc3RUb3VjaC5kZXRhY2goKTtcblxuICAgICAgICAgIHRoaXMubGFzdFRvdWNoID0gZm9hbS5pbnB1dC5Ub3VjaEV2ZW50LmNyZWF0ZSgpO1xuICAgICAgICAgIHRoaXMubGFzdFRvdWNoLm9uRGV0YWNoKHRoaXMubGFzdFRvdWNoLngkLmZvbGxvdyh0aGlzLngkKSk7XG4gICAgICAgICAgdGhpcy5sYXN0VG91Y2gub25EZXRhY2godGhpcy5sYXN0VG91Y2gueSQuZm9sbG93KHRoaXMueSQpKTtcblxuICAgICAgICAgIHRoaXMudG91Y2gucHViKHRoaXMubGFzdFRvdWNoKTtcblxuICAgICAgICAgIGlmICggdGhpcy5sYXN0VG91Y2ggJiYgdGhpcy5sYXN0VG91Y2guY2xhaW1lZCApIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFdoaWxlIHRoZSBtb3VzZSBpcyBkb3duLCB0cmFjayB0aGUgbW92ZW1lbnRzIGFuZCBtb3VzZXVwIG9uIHRoZVxuICAgICAgICAvLyBlbnRpcmUgd2luZG93IHNvIGl0J3MgdHJhY2tlZCBpZi93aGVuIHRoZSBtb3VzZSBsZWF2ZXMgdGhlIGVsZW1lbnQuXG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgICB0aGlzLm9uTW91c2VVcCk7XG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCB0aGlzLm9uTW91c2VNb3ZlKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHtcbiAgICAgIG5hbWU6ICdvbk1vdXNlVXAnLFxuICAgICAgY29kZTogZnVuY3Rpb24oZSkge1xuICAgICAgICB0aGlzLnVwLnB1YigpO1xuXG4gICAgICAgIGlmICggdGhpcy5sYXN0VG91Y2ggKSB7XG4gICAgICAgICAgdGhpcy5sYXN0VG91Y2guZGV0YWNoKCk7XG4gICAgICAgICAgdGhpcy5sYXN0VG91Y2ggPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsICAgdGhpcy5vbk1vdXNlVXApO1xuICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgdGhpcy5vbk1vdXNlTW92ZSk7XG4gICAgICB9XG4gICAgfSxcbiAgICB7XG4gICAgICBuYW1lOiAnb25Nb3VzZU1vdmUnLFxuICAgICAgY29kZTogZnVuY3Rpb24oZSkge1xuICAgICAgICBpZiAoIHRoaXMubGFzdFRvdWNoIHx8XG4gICAgICAgICAgICAgdGhpcy5oYXNMaXN0ZW5lcnMoJ3Byb3BlcnR5Q2hhbmdlJykgfHxcbiAgICAgICAgICAgICB0aGlzLm1vdmUuaGFzTGlzdGVuZXJzKCkgKSB7XG5cbiAgICAgICAgICB2YXIgYm91bmRzID0gdGhpcy5lbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuXG4gICAgICAgICAgdGhpcy54ID0gZS5jbGllbnRYIC0gYm91bmRzLmxlZnQ7XG4gICAgICAgICAgdGhpcy55ID0gZS5jbGllbnRZIC0gYm91bmRzLnRvcDtcblxuICAgICAgICAgIHRoaXMubW92ZS5wdWIoKTtcblxuICAgICAgICAgIGlmICggdGhpcy5sYXN0VG91Y2ggJiYgdGhpcy5sYXN0VG91Y2guY2xhaW1lZCApIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgXVxufSk7XG5cblxuZm9hbS5DTEFTUyh7XG4gIHBhY2thZ2U6ICdmb2FtLmlucHV0JyxcbiAgbmFtZTogJ1RvdWNoJyxcblxuICB0b3BpY3M6IFtcbiAgICAndG91Y2gnXG4gIF0sXG5cbiAgcHJvcGVydGllczogW1xuICAgIHtcbiAgICAgIG5hbWU6ICd0b3VjaGVzJyxcbiAgICAgIGZhY3Rvcnk6IGZ1bmN0aW9uKCkgeyByZXR1cm4ge307IH1cbiAgICB9LFxuICAgIHtcbiAgICAgIG5hbWU6ICdlbGVtZW50JyxcbiAgICAgIHBvc3RTZXQ6IGZ1bmN0aW9uKG9sZCwgZSkge1xuICAgICAgICBpZiAoIG9sZCApIHtcbiAgICAgICAgICBvbGQucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2hzdGFydCcsIHRoaXMub25Ub3VjaFN0YXJ0KTtcbiAgICAgICAgICBvbGQucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2htb3ZlJywgIHRoaXMub25Ub3VjaE1vdmUpO1xuICAgICAgICAgIG9sZC5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaGVuZCcsICAgdGhpcy5vblRvdWNoRW5kKTtcbiAgICAgICAgfVxuICAgICAgICBlLmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoc3RhcnQnLCB0aGlzLm9uVG91Y2hTdGFydCk7XG4gICAgICAgIGUuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2htb3ZlJywgIHRoaXMub25Ub3VjaE1vdmUpO1xuICAgICAgICBlLmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoZW5kJywgICB0aGlzLm9uVG91Y2hFbmQpO1xuICAgICAgfVxuICAgIH1cbiAgXSxcblxuICBsaXN0ZW5lcnM6IFtcbiAgICBmdW5jdGlvbiBvblRvdWNoU3RhcnQoZSkge1xuICAgICAgdmFyIG5ld1RvdWNoZXMgPSBlLmNoYW5nZWRUb3VjaGVzO1xuICAgICAgdmFyIGJvdW5kcyAgICAgPSB0aGlzLmVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG5cbiAgICAgIGZvciAoIHZhciBpID0gMCA7IGkgPCBuZXdUb3VjaGVzLmxlbmd0aCA7IGkrKyApIHtcbiAgICAgICAgdmFyIHRvdWNoID0gbmV3VG91Y2hlcy5pdGVtKGkpO1xuXG4gICAgICAgIHZhciB0b3VjaEV2ZW50ID0gZm9hbS5pbnB1dC5Ub3VjaEV2ZW50LmNyZWF0ZSh7XG4gICAgICAgICAgeDogdG91Y2guY2xpZW50WCAtIGJvdW5kcy5sZWZ0LFxuICAgICAgICAgIHk6IHRvdWNoLmNsaWVudFkgLSBib3VuZHMudG9wXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMudG91Y2gucHViKHRvdWNoRXZlbnQpO1xuICAgICAgICBpZiAoIHRvdWNoRXZlbnQuY2xhaW1lZCApIGUucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgICB0aGlzLnRvdWNoZXNbdG91Y2guaWRlbnRpZmllcl0gPSB0b3VjaEV2ZW50O1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBmdW5jdGlvbiBvblRvdWNoTW92ZShlKSB7XG4gICAgICB2YXIgY2hhbmdlZCA9IGUuY2hhbmdlZFRvdWNoZXM7XG4gICAgICB2YXIgYm91bmRzICA9IHRoaXMuZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcblxuICAgICAgZm9yICggdmFyIGkgPSAwIDsgaSA8IGNoYW5nZWQubGVuZ3RoIDsgaSsrICkge1xuICAgICAgICB2YXIgdG91Y2ggPSBjaGFuZ2VkLml0ZW0oaSk7XG5cbiAgICAgICAgdmFyIGV2ZW50ID0gdGhpcy50b3VjaGVzW3RvdWNoLmlkZW50aWZpZXJdO1xuICAgICAgICBldmVudC54ID0gdG91Y2guY2xpZW50WCAtIGJvdW5kcy5sZWZ0O1xuICAgICAgICBldmVudC55ID0gdG91Y2guY2xpZW50WSAtIGJvdW5kcy50b3A7XG4gICAgICAgIGlmICggZXZlbnQuY2xhaW1lZCApIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgZnVuY3Rpb24gb25Ub3VjaEVuZChlKSB7XG4gICAgICB2YXIgY2hhbmdlZCA9IGUuY2hhbmdlZFRvdWNoZXM7XG4gICAgICBmb3IgKCB2YXIgaSA9IDAgOyBpIDwgY2hhbmdlZC5sZW5ndGggOyBpKysgKSB7XG4gICAgICAgIHZhciB0b3VjaCA9IGNoYW5nZWQuaXRlbShpKTtcblxuICAgICAgICB0aGlzLnRvdWNoZXNbdG91Y2guaWRlbnRpZmllcl0uZGV0YWNoKCk7XG4gICAgICAgIGRlbGV0ZSB0aGlzLnRvdWNoZXNbdG91Y2guaWRlbnRpZmllcl07XG4gICAgICB9XG4gICAgfVxuICBdXG59KTtcblxuXG5mb2FtLkNMQVNTKHtcbiAgcGFja2FnZTogJ2ZvYW0uaW5wdXQnLFxuICBuYW1lOiAnUG9pbnRlcicsXG5cbiAgcmVxdWlyZXM6IFtcbiAgICAnZm9hbS5pbnB1dC5Nb3VzZScsXG4gICAgJ2ZvYW0uaW5wdXQuVG91Y2gnXG4gIF0sXG5cbiAgdG9waWNzOiBbXG4gICAgJ3RvdWNoJ1xuICBdLFxuXG4gIHByb3BlcnRpZXM6IFtcbiAgICB7XG4gICAgICBuYW1lOiAnZWxlbWVudCcsXG4gICAgICByZXF1aXJlZDogdHJ1ZVxuICAgIH0sXG4gICAge1xuICAgICAgbmFtZTogJ21vdXNlSW5wdXQnLFxuICAgICAgZmFjdG9yeTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBtID0gdGhpcy5Nb3VzZS5jcmVhdGUoKTtcbiAgICAgICAgdGhpcy5vbkRldGFjaChtLmVsZW1lbnQkLmZvbGxvdyh0aGlzLmVsZW1lbnQkKSk7XG4gICAgICAgIHRoaXMub25EZXRhY2gobS50b3VjaC5zdWIodGhpcy5vblRvdWNoKSk7XG4gICAgICAgIHJldHVybiBtO1xuICAgICAgfVxuICAgIH0sXG4gICAge1xuICAgICAgbmFtZTogJ3RvdWNoSW5wdXQnLFxuICAgICAgZmFjdG9yeTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciB0ID0gdGhpcy5Ub3VjaC5jcmVhdGUoKTtcbiAgICAgICAgdGhpcy5vbkRldGFjaCh0LmVsZW1lbnQkLmZvbGxvdyh0aGlzLmVsZW1lbnQkKSk7XG4gICAgICAgIHRoaXMub25EZXRhY2godC50b3VjaC5zdWIodGhpcy5vblRvdWNoKSk7XG4gICAgICAgIHJldHVybiB0O1xuICAgICAgfVxuICAgIH1cbiAgXSxcblxuICBtZXRob2RzOiBbXG4gICAgZnVuY3Rpb24gaW5pdCgpIHtcbiAgICAgIC8vIEFzc2lnbmluZyB0byB1bnVzZWQgdmFyaWFibGVzIHRvIG1ha2UgQ2xvc3VyZSBoYXBweS5cbiAgICAgIHZhciBtaSA9IHRoaXMubW91c2VJbnB1dDtcbiAgICAgIHZhciB0aSA9IHRoaXMudG91Y2hJbnB1dDtcbiAgICB9XG4gIF0sXG5cbiAgbGlzdGVuZXJzOiBbXG4gICAgZnVuY3Rpb24gb25Ub3VjaChlLCBfLCB0KSB7XG4gICAgICB0aGlzLnRvdWNoLnB1Yih0KTtcbiAgICB9XG4gIF1cbn0pO1xuXG5mb2FtLkNMQVNTKHtcbiAgcGFja2FnZTogJ2ZvYW0ubmFub3MuY29udHJvbGxlcicsXG4gIG5hbWU6ICdBcHBTdHlsZXMnLFxuICBleHRlbmRzOiAnZm9hbS51Mi5WaWV3JyxcblxuICBkb2N1bWVudGF0aW9uOiAnR2VuZXJpYyBDU1MgdGhhdCBjYW4gYmUgaW5jbHVkZWQgaW50byB0aGUgdG9wIGxldmVsIGNvbnRyb2xsZXIgb2YgZm9hbSBhcHAuIEltcGxlbWVudCB0byBmb2FtIGNsYXNzIHRvIHVzZS4nLFxuXG4gIGNzczogYFxuICAgIGJvZHkge1xuICAgICAgZm9udC1mYW1pbHk6ICdSb2JvdG8nLCBzYW5zLXNlcmlmO1xuICAgICAgZm9udC1zaXplOiAxNHB4O1xuICAgICAgbGV0dGVyLXNwYWNpbmc6IDAuMnB4O1xuICAgICAgY29sb3I6ICMzNzNhM2M7XG4gICAgICBiYWNrZ3JvdW5kOiAjZWRmMGY1O1xuICAgICAgbWFyZ2luOiAwO1xuICAgIH1cbiAgICB0YWJsZSB7XG4gICAgICBib3JkZXItY29sbGFwc2U6IGNvbGxhcHNlO1xuICAgICAgbWFyZ2luOiBhdXRvO1xuICAgICAgd2lkdGg6IDk2MnB4O1xuICAgIH1cbiAgICB0aGVhZCA+IHRyID4gdGgge1xuICAgICAgZm9udC1mYW1pbHk6ICdSb2JvdG8nO1xuICAgICAgZm9udC1zaXplOiAxNHB4O1xuICAgICAgYmFja2dyb3VuZC1jb2xvcjogcmdiYSgxMTAsIDE3NCwgMTk1LCAwLjIpO1xuICAgICAgY29sb3I6ICMwOTM2NDk7XG4gICAgICBsaW5lLWhlaWdodDogMS4xNDtcbiAgICAgIGxldHRlci1zcGFjaW5nOiAwLjNweDtcbiAgICAgIGJvcmRlci1zcGFjaW5nOiAwO1xuICAgICAgdGV4dC1hbGlnbjogbGVmdDtcbiAgICAgIHBhZGRpbmctbGVmdDogMTVweDtcbiAgICAgIGhlaWdodDogNDBweDtcbiAgICB9XG4gICAgdGJvZHkgPiB0ciA+IHRoID4gdGQge1xuICAgICAgZm9udC1zaXplOiAxMnB4O1xuICAgICAgbGV0dGVyLXNwYWNpbmc6IDAuMnB4O1xuICAgICAgdGV4dC1hbGlnbjogbGVmdDtcbiAgICAgIGNvbG9yOiAjMDkzNjQ5O1xuICAgICAgcGFkZGluZy1sZWZ0OiAxNXB4O1xuICAgICAgaGVpZ2h0OiA2MHB4O1xuICAgIH1cbiAgICAuZm9hbS11Mi12aWV3LVRhYmxlVmlldyB0aCB7XG4gICAgICBmb250LWZhbWlseTogJ1JvYm90byc7XG4gICAgICBwYWRkaW5nLWxlZnQ6IDE1cHg7XG4gICAgICBmb250LXNpemU6IDE0cHg7XG4gICAgICBsaW5lLWhlaWdodDogMTtcbiAgICAgIGxldHRlci1zcGFjaW5nOiAwLjRweDtcbiAgICAgIGNvbG9yOiAjMDkzNjQ5O1xuICAgIH1cbiAgICAuZm9hbS11Mi12aWV3LVRhYmxlVmlldyB0ZCB7XG4gICAgICBmb250LWZhbWlseTogUm9ib3RvO1xuICAgICAgZm9udC1zaXplOiAxMnB4O1xuICAgICAgbGluZS1oZWlnaHQ6IDEuMzM7XG4gICAgICBsZXR0ZXItc3BhY2luZzogMC4ycHg7XG4gICAgICBwYWRkaW5nLWxlZnQ6IDE1cHg7XG4gICAgICBmb250LXNpemU6IDEycHg7XG4gICAgICBjb2xvcjogIzA5MzY0OTtcbiAgICB9XG4gICAgLmZvYW0tdTItdmlldy1UYWJsZVZpZXcgdGJvZHkgPiB0ciB7XG4gICAgICBoZWlnaHQ6IDYwcHg7XG4gICAgICBiYWNrZ3JvdW5kOiB3aGl0ZTtcbiAgICB9XG4gICAgLmZvYW0tdTItdmlldy1UYWJsZVZpZXcgdGJvZHkgPiB0cjpudGgtY2hpbGQob2RkKSB7XG4gICAgICBiYWNrZ3JvdW5kOiAjZjZmOWY5O1xuICAgIH1cbiAgYFxufSk7Zm9hbS5DTEFTUyh7XG4gIHBhY2thZ2U6ICdmb2FtLnUyJyxcbiAgbmFtZTogJ01vZGFsSGVhZGVyJyxcbiAgZXh0ZW5kczogJ2ZvYW0udTIuVmlldycsXG5cbiAgZG9jdW1lbnRhdGlvbjogJ01vZGFsIENvbnRhaW5lciBjbG9zZS90aXRsZSB1c2UgaW4gbW9kYWwgY2xhc3MgdG8gYXBwZW5kIHRpdGxlICYgY2xvc2UgYnV0dG9ucy4nLFxuXG4gIGltcG9ydHM6IFtcbiAgICAnc3RhY2snLFxuICAgICdjbG9zZURpYWxvZydcbiAgXSxcblxuICBwcm9wZXJ0aWVzOiBbXG4gICAgJ3RpdGxlJ1xuICBdLFxuXG4gIGNzczogYFxuICAgIF57XG4gICAgICB3aWR0aDogNDQ4cHg7XG4gICAgICBtYXJnaW46IGF1dG87XG4gICAgfVxuICAgIF4gLmNvbnRhaW5lcntcbiAgICAgIGhlaWdodDogNDAuOHB4O1xuICAgICAgYmFja2dyb3VuZC1jb2xvcjogIzA5MzY0OTtcbiAgICAgIG1hcmdpbi1ib3R0b206IDIwcHg7XG4gICAgfVxuICAgIF4gLnRpdGxle1xuICAgICAgaGVpZ2h0OiA0MHB4O1xuICAgICAgZm9udC1mYW1pbHk6IFJvYm90bztcbiAgICAgIGZvbnQtc2l6ZTogMTRweDtcbiAgICAgIGxpbmUtaGVpZ2h0OiAyLjg2O1xuICAgICAgdGV4dC1hbGlnbjogbGVmdDtcbiAgICAgIGNvbG9yOiAjZmZmZmZmO1xuICAgICAgbWFyZ2luLWxlZnQ6IDE5cHg7XG4gICAgICBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7XG4gICAgfVxuICAgIF4gLmNsb3Nle1xuICAgICAgd2lkdGg6IDI0cHg7XG4gICAgICBoZWlnaHQ6IDI0cHg7XG4gICAgICBtYXJnaW4tdG9wOiA1cHg7XG4gICAgICBjdXJzb3I6IHBvaW50ZXI7XG4gICAgICBwb3NpdGlvbjogcmVsYXRpdmU7XG4gICAgICB0b3A6IDRweDtcbiAgICAgIHJpZ2h0OiAyMHB4O1xuICAgICAgZmxvYXQ6IHJpZ2h0O1xuICAgIH1cbiAgICBeIC5mb2FtLXUyLUFjdGlvblZpZXctY2xvc2VNb2RhbHtcbiAgICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcbiAgICAgIHJpZ2h0OiAwcHg7XG4gICAgICB3aWR0aDogNTBweDtcbiAgICAgIGhlaWdodDogNDBweDtcbiAgICAgIGJhY2tncm91bmQ6IHRyYW5zcGFyZW50O1xuICAgICAgbWFyZ2luLXRvcDogMDtcbiAgICAgIHRvcDogMDtcbiAgICAgIHJpZ2h0OiAwO1xuICAgICAgYm9yZGVyOiBub25lO1xuICAgIH1cbiAgYCxcblxuICBtZXRob2RzOiBbXG4gICAgZnVuY3Rpb24gaW5pdEUoKXtcbiAgICB0aGlzLlNVUEVSKCk7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgdGhpc1xuICAgIC5hZGRDbGFzcyh0aGlzLm15Q2xhc3MoKSlcbiAgICAgIC5zdGFydCgpXG4gICAgICAgIC5zdGFydCgpXG4gICAgICAgICAgLnN0YXJ0KCkuYWRkQ2xhc3MoJ2NvbnRhaW5lcicpXG4gICAgICAgICAgICAuc3RhcnQoKS5hZGRDbGFzcygndGl0bGUnKS5hZGQodGhpcy50aXRsZSkuZW5kKClcbiAgICAgICAgICAgIC5zdGFydCh0aGlzLkNMT1NFX01PREFMKS5hZGRDbGFzcygnY2xvc2UnKS5lbmQoKVxuICAgICAgICAgIC5lbmQoKVxuICAgICAgICAuZW5kKClcbiAgICAgIC5lbmQoKVxuICAgIH1cbiAgXSxcblxuICBhY3Rpb25zOiBbXG4gICAge1xuICAgICAgbmFtZTogJ2Nsb3NlTW9kYWwnLFxuICAgICAgaWNvbjogJ2ljLWNhbmNlbHdoaXRlLnN2ZycsXG4gICAgICBjb2RlOiBmdW5jdGlvbihYKXtcbiAgICAgICAgWC5jbG9zZURpYWxvZygpXG4gICAgICB9XG4gICAgfVxuICBdXG59KTsvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNSBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5mb2FtLkNMQVNTKHtcbiAgcGFja2FnZTogJ2ZvYW0udTInLFxuICBuYW1lOiAnQXR0clNsb3QnLFxuICBpbXBsZW1lbnRzOiBbICdmb2FtLmNvcmUuU2xvdCcgXSxcblxuICBkb2N1bWVudGF0aW9uOiAnQSBWYWx1ZSBib3VuZCB0byBhbiBFbGVtZW50IGF0dHJpYnV0ZS4gVXNlZCB0byBiaW5kIHZhbHVlcyB0byBET00uJyxcblxuICBwcm9wZXJ0aWVzOiBbXG4gICAge1xuICAgICAgbmFtZTogJ2VsZW1lbnQnLFxuICAgICAgcmVxdWlyZWQ6IHRydWVcbiAgICB9LFxuICAgICd2YWx1ZScsXG4gICAgWyAncHJvcGVydHknLCAndmFsdWUnICBdLFxuICAgIFsgJ2V2ZW50JywgICAgJ2NoYW5nZScgXVxuICBdLFxuXG4gIG1ldGhvZHM6IFtcbiAgICBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5lbGVtZW50LmdldEF0dHJpYnV0ZSh0aGlzLnByb3BlcnR5KTtcbiAgICB9LFxuXG4gICAgZnVuY3Rpb24gc2V0KHZhbHVlKSB7XG4gICAgICB0aGlzLmVsZW1lbnQuc2V0QXR0cmlidXRlKHRoaXMucHJvcGVydHksIHZhbHVlKTtcblxuICAgICAgLy8gVGhlIG5leHQgbGluZSBpcyBuZWNlc3NhcnkgdG8gZmlyZSBhIGNoYW5nZSBldmVudC5cbiAgICAgIC8vIFRoaXMgaXMgbmVjZXNzYXJ5IGJlY2F1c2UgRE9NIGlzbid0IHByb3BlciBNVkMgYW5kXG4gICAgICAvLyBkb2Vzbid0IGZpcmUgYSBjaGFuZ2UgZXZlbnQgd2hlbiB0aGUgdmFsdWUgaXMgZXhwbGljaXRseSBzZXQuXG4gICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgfSxcblxuICAgIGZ1bmN0aW9uIHN1YihsKSB7XG4gICAgICAvLyBUT0RPOiByZW1vdmUgbGlzdGVuZXIgb24gdW5zdWJzY3JpYmUuIEJ1dCBob3c/XG4gICAgICBpZiAoICEgdGhpcy5oYXNMaXN0ZW5lcnMoKSApIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICB0aGlzLmVsZW1lbnQub24odGhpcy5ldmVudCwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgc2VsZi52YWx1ZSA9IHNlbGYuZ2V0KCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuU1VQRVIoJ3Byb3BlcnR5Q2hhbmdlJywgJ3ZhbHVlJywgbCk7XG4gICAgfSxcblxuICAgIGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgICAgcmV0dXJuICdBdHRyU2xvdCgnICsgdGhpcy5ldmVudCArICcsICcgKyB0aGlzLnByb3BlcnR5ICsgJyknO1xuICAgIH1cbiAgXVxufSk7XG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5mb2FtLkNMQVNTKHtcbiAgcGFja2FnZTogJ2ZvYW0udTInLFxuICBuYW1lOiAnVmlld1NwZWMnLFxuICBleHRlbmRzOiAnZm9hbS5jb3JlLlByb3BlcnR5JyxcblxuICBkb2N1bWVudGF0aW9uOiAnU2V0IGEgVmlld0ZhY3RvcnkgdG8gYmUgYSBzdHJpbmcgY29udGFpbmluZyBhIGNsYXNzIG5hbWUsICcgK1xuICAgICAgJ2EgQ2xhc3Mgb2JqZWN0LCBvciBhIGZhY3RvcnkgZnVuY3Rpb24oYXJncywgY29udGV4dCkuICcgK1xuICAgICAgJ1VzZWZ1bCBmb3Igcm93Vmlld3MgYW5kIHNpbWlsYXIuJyxcblxuICBheGlvbXM6IFtcbiAgICB7XG4gICAgICBpbnN0YWxsSW5DbGFzczogZnVuY3Rpb24oY2xzKSB7XG4gICAgICAgIGNscy5jcmVhdGVWaWV3ID0gZnVuY3Rpb24oc3BlYywgYXJncywgc2VsZiwgY3R4KSB7XG4gICAgICAgICAgaWYgKCBmb2FtLnUyLkVsZW1lbnQuaXNJbnN0YW5jZShzcGVjKSApXG4gICAgICAgICAgICByZXR1cm4gc3BlYy5jb3B5RnJvbShhcmdzKTtcblxuICAgICAgICAgIGlmICggZm9hbS5jb3JlLlNsb3QuaXNJbnN0YW5jZShzcGVjKSApXG4gICAgICAgICAgICByZXR1cm4gc3BlYztcblxuICAgICAgICAgIGlmICggc3BlYyAmJiBzcGVjLnRvRSApXG4gICAgICAgICAgICByZXR1cm4gc3BlYy50b0UoYXJncywgY3R4KTtcblxuICAgICAgICAgIGlmICggZm9hbS5GdW5jdGlvbi5pc0luc3RhbmNlKHNwZWMpIClcbiAgICAgICAgICAgIHJldHVybiBmb2FtLnUyLlZpZXdTcGVjLmNyZWF0ZVZpZXcoc3BlYy5jYWxsKHNlbGYsIGFyZ3MsIGN0eCksIGFyZ3MsIHNlbGYsIGN0eCk7XG5cbiAgICAgICAgICBpZiAoIGZvYW0uT2JqZWN0LmlzSW5zdGFuY2Uoc3BlYykgKSB7XG4gICAgICAgICAgICB2YXIgcmV0ID0gc3BlYy5jcmVhdGUgP1xuICAgICAgICAgICAgICAgIHNwZWMuY3JlYXRlKGFyZ3MsIGN0eCkgOlxuICAgICAgICAgICAgICAgIGN0eC5sb29rdXAoc3BlYy5jbGFzcykuY3JlYXRlKHNwZWMsIGN0eCkuY29weUZyb20oYXJncyB8fCB7fSk7XG5cbiAgICAgICAgICAgIGZvYW0uYXNzZXJ0KFxuICAgICAgICAgICAgICAgIGZvYW0udTIuRWxlbWVudC5pc0luc3RhbmNlKHJldCkgfHwgcmV0LnRvRSxcbiAgICAgICAgICAgICAgICAnVmlld1NwZWMgcmVzdWx0IG11c3QgZXh0ZW5kIGZvYW0udTIuRWxlbWVudCBvciBiZSB0b0UoKS1hYmxlLicpO1xuXG4gICAgICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICggZm9hbS5jb3JlLkZPYmplY3QuaXNTdWJDbGFzcyhzcGVjKSApIHtcbiAgICAgICAgICAgIHZhciByZXQgPSBzcGVjLmNyZWF0ZShhcmdzLCBjdHgpO1xuXG4gICAgICAgICAgICBmb2FtLmFzc2VydChmb2FtLnUyLkVsZW1lbnQuaXNJbnN0YW5jZShyZXQpLCAnVmlld1NwZWMgY2xhc3MgbXVzdCBleHRlbmQgZm9hbS51Mi5FbGVtZW50IG9yIGJlIHRvRSgpLWFibGUuJyk7XG5cbiAgICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKCBmb2FtLlN0cmluZy5pc0luc3RhbmNlKHNwZWMpIHx8IHNwZWMgPT09IHVuZGVmaW5lZCB8fCBzcGVjID09PSBudWxsIClcbiAgICAgICAgICAgIHJldHVybiBmb2FtLnUyLkVsZW1lbnQuY3JlYXRlKHsgbm9kZU5hbWU6IHNwZWMgfHwgJ2RpdicgfSwgY3R4KTtcblxuICAgICAgICAgIHRocm93ICdJbnZhbGlkIFZpZXdTcGVjLCBtdXN0IHByb3ZpZGUgYW4gRWxlbWVudCwgU2xvdCwgdG9FKCktYWJsZSwgRnVuY3Rpb24sIHtjcmVhdGU6IGZ1bmN0aW9uKCkge319LCB7Y2xhc3M6IFxcJ25hbWVcXCd9LCBDbGFzcywgb3IgU3RyaW5nLCBidXQgcmVjZWl2ZWQ6ICcgKyBzcGVjO1xuICAgICAgICB9O1xuICAgICAgfVxuICAgIH1cbiAgXSxcblxuICBwcm9wZXJ0aWVzOiBbXG4gICAgLyogVE9ETzogdW5jb21tZW50IHRoaXMgdG8gZml4IFZpZXdTcGVjcyBjb252ZXJ0aW5nIGludG8gVmlld3Mgd2hlbiBsb2FkaW5nLlxuICAgIFtcbiAgICAgICdmcm9tSlNPTicsXG4gICAgICBmdW5jdGlvbiBmcm9tSlNPTih2YWx1ZSwgY3R4LCBwcm9wLCBqc29uKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgIH1cbiAgICBdLFxuICAgICovXG4gICAgWyAnYWRhcHQnLCBmdW5jdGlvbihfLCBzcGVjLCBwcm9wKSB7XG4gICAgICByZXR1cm4gZm9hbS5TdHJpbmcuaXNJbnN0YW5jZShzcGVjKSA/IHsgY2xhc3M6IHNwZWMgfSA6IHNwZWMgO1xuICAgIH0gXVxuICAgIC8qXG4gICAgWyAndG9KU09OJywgZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgIE91dHB1dCBhcyBzdHJpbmcgaWYgJ2NsYXNzJyBpcyBvbmx5IGRlZmluZWQgdmFsdWUuXG4gICAgfSBdXG4gICAgKi9cbiAgXVxufSk7XG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBUaGUgRk9BTSBBdXRob3JzLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKi9cblxuZm9hbS5FTlVNKHtcbiAgcGFja2FnZTogJ2ZvYW0udTInLFxuICBuYW1lOiAnVmlzaWJpbGl0eScsXG5cbiAgZG9jdW1lbnRhdGlvbjogJ1ZpZXcgdmlzaWJpbGl0eSBtb2RlIGNvbWJpbmVzIHdpdGggY3VycmVudCBDb250cm9sbGVyTW9kZWwgdG8gZGV0ZXJtaW5lIERpc3BsYXlNb2RlLicsXG5cbiAgdmFsdWVzOiBbXG4gICAgeyBuYW1lOiAnUlcnLCAgICAgICBsYWJlbDogJ1JlYWQtV3JpdGUnIH0sXG4gICAgeyBuYW1lOiAnRklOQUwnLCAgICBsYWJlbDogJ0ZpbmFsJywgICAgIGRvY3VtZW50YXRpb246ICdGSU5BTCB2aWV3cyBhcmUgZWRpdGFibGUgb25seSBpbiBDUkVBVEUgQ29udHJvbGxlck1vZGUuJyB9LFxuICAgIHsgbmFtZTogJ0RJU0FCTEVEJywgbGFiZWw6ICdEaXNhYmxlZCcsICBkb2N1bWVudGF0aW9uOiAnRElTQUJMRUQgdmlld3MgYXJlIHZpc2libGUgYnV0IG5vdCBlZGl0YWJsZS4nIH0sXG4gICAgeyBuYW1lOiAnUk8nLCAgICAgICBsYWJlbDogJ1JlYWQtT25seScgIH0sXG4gICAgeyBuYW1lOiAnSElEREVOJywgICBsYWJlbDogJ0hpZGRlbicgICAgIH1cbiAgXVxufSk7LyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgVGhlIEZPQU0gQXV0aG9ycy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuZm9hbS5DTEFTUyh7XG4gIHJlZmluZXM6ICdmb2FtLmNvcmUuTWV0aG9kJyxcbiAgcHJvcGVydGllczogWyAnc3dpZnRSZXR1cm5zJywgJ3N3aWZ0Q29kZScsICdzd2lmdFN5bmNocm9uaXplZCcgXVxufSk7XG5mb2FtLkNMQVNTKHtcbiAgcmVmaW5lczogJ2ZvYW0uY29yZS5pbnRlcm5hbC5JbnRlcmZhY2VNZXRob2QnLFxuICBwcm9wZXJ0aWVzOiBbICdzd2lmdFJldHVybnMnLCAnc3dpZnRUaHJvd3MnLCAnc3dpZnRTdXBwb3J0JyBdXG59KTtcbmZvYW0uQ0xBU1Moe1xuICByZWZpbmVzOiAnZm9hbS5jb3JlLlByb3BlcnR5JyxcbiAgcHJvcGVydGllczogWyAnc3dpZnRUeXBlJywgJ3N3aWZ0RXhwcmVzc2lvbicsICdzd2lmdEV4cHJlc3Npb25BcmdzJywgJ3N3aWZ0UG9zdFNldCcsICdzd2lmdEZhY3RvcnknLCAnc3dpZnRSZXF1aXJlc0VzY2FwaW5nJywgJ3N3aWZ0R2V0dGVyJyBdXG59KTtcbmZvYW0uQ0xBU1Moe1xuICByZWZpbmVzOiAnZm9hbS5jb3JlLkFyZ3VtZW50JyxcbiAgcHJvcGVydGllczogWyAnc3dpZnRUeXBlJywgJ3N3aWZ0RGVmYXVsdFZhbHVlJyBdXG59KTtcbmZvYW0uQ0xBU1Moe1xuICByZWZpbmVzOiAnZm9hbS5jb3JlLkludGVyZmFjZU1vZGVsJyxcbiAgcHJvcGVydGllczogWyAnc3dpZnROYW1lJywgJ3N3aWZ0SW1wbGVtZW50cycgXVxufSk7XG5mb2FtLkNMQVNTKHtcbiAgcmVmaW5lczogJ2ZvYW0uY29yZS5Nb2RlbCcsXG4gIHByb3BlcnRpZXM6IFsgJ3N3aWZ0TmFtZScsICdnZW5lcmF0ZVN3aWZ0JyBdXG59KTtcbmZvYW0uQ0xBU1Moe1xuICByZWZpbmVzOiAnZm9hbS5jb3JlLkZPYmplY3RQcm9wZXJ0eScsXG4gIHByb3BlcnRpZXM6IFsgJ3N3aWZ0RmFjdG9yeScsICdzd2lmdFBvc3RTZXQnIF1cbn0pO1xuZm9hbS5DTEFTUyh7XG4gIHJlZmluZXM6ICdmb2FtLmNvcmUuU3RyaW5nJyxcbiAgcHJvcGVydGllczogWyAnc3dpZnRGYWN0b3J5JyBdXG59KTtcbmZvYW0uQ0xBU1Moe1xuICByZWZpbmVzOiAnZm9hbS5jb3JlLkNvbnN0YW50JyxcbiAgcHJvcGVydGllczogWyAndHlwZScsICdzd2lmdFZhbHVlJywgJ3N3aWZ0VHlwZScgXVxufSk7XG5mb2FtLkNMQVNTKHtcbiAgcmVmaW5lczogJ2ZvYW0uY29yZS5MaXN0ZW5lcicsXG4gIHByb3BlcnRpZXM6IFsgJ3N3aWZ0Q29kZScgXVxufSk7XG5mb2FtLkNMQVNTKHtcbiAgcmVmaW5lczogJ2ZvYW0uY29yZS5Db250ZXh0TWV0aG9kJyxcbiAgcHJvcGVydGllczogWyAnc3dpZnRUaHJvd3MnIF1cbn0pO1xuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgVGhlIEZPQU0gQXV0aG9ycy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuZm9hbS5JTlRFUkZBQ0Uoe1xuICBwYWNrYWdlOiAnZm9hbS51MicsXG4gIG5hbWU6ICdSb3dGb3JtYXR0ZXInLFxuXG4gIGRvY3VtZW50YXRpb246ICdCYXNlIGNsYXNzIGZvciBtYXJrdXAtZ2VuZXJhdGluZyByb3cgZm9ybWF0dGVycy4nLFxuXG4gIG1ldGhvZHM6IFtcbiAgICBmdW5jdGlvbiBmb3JtYXQoZGF0YSwgb3B0X2NvbHVtbnMpIHt9XG4gIF1cbn0pO1xuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgVGhlIEZPQU0gQXV0aG9ycy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICovXG5cbi8vIFdlYWtNYXAgUG9seWZpbGwsIGRvZXNuJ3QgaW1wbGVtZW50IHRoZSBmdWxsIGludGVyZmFjZSwganVzdCB0aGUgcGFydHNcbi8vIHRoYXQgRk9BTSB1c2VzLiBPbmx5IHVzZWQgaW4gRWxlbWVudC5qcywgd2hpY2ggaXMgd2h5IGl0J3MgaW4gdGhlIHUyIHBhY2thZ2Vcbi8vIHJhdGhlciB0aGFuIGluIGNvcmUgd2l0aCBvdGhlciBwb2x5Zmlscy5cbmlmICggISBnbG9iYWwuV2Vha01hcCApIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHdpbmRvdywgJ1dlYWtNYXAnLCB7XG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBXZWFrTWFwKCkge1xuICAgICAgdmFyIGlkID0gJ19fV0VBS19NQVBfXycgKyB0aGlzLiRVSUQ7XG5cbiAgICAgIGZ1bmN0aW9uIGRlbChrZXkpIHsgZGVsZXRlIGtleVtpZF07IH1cbiAgICAgIGZ1bmN0aW9uIGdldChrZXkpIHsgcmV0dXJuIGtleVtpZF07IH1cbiAgICAgIGZ1bmN0aW9uIHNldChrZXksIHZhbHVlKSB7IGtleVtpZF0gPSB2YWx1ZTsgfVxuICAgICAgZnVuY3Rpb24gaGFzKGtleSkgeyByZXR1cm4gISFrZXlbaWRdOyB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIF9fcHJvdG9fXzogdGhpcyxcbiAgICAgICAgXCJkZWxldGVcIjogZGVsLFxuICAgICAgICBnZXQ6IGdldCxcbiAgICAgICAgc2V0OiBzZXQsXG4gICAgICAgIGhhczogaGFzXG4gICAgICB9O1xuICAgIH1cbiAgfSk7XG59XG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBUaGUgRk9BTSBBdXRob3JzLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKi9cblxuLypcblRPRE86XG4gLSBSZW1vdmUgdXNlIG9mIEUoKSBhbmQgcmVwbGFjZSB3aXRoIGNyZWF0ZS1pbmcgYXhpb20gdG8gYWRkIHNhbWUgYmVoYXZpb3VyLlxuIC0gY3JlYXRlICdpbm5lcicgZWxlbWVudCB3aGljaCBkZWZhdWx0cyB0byB0aGlzLiBhZGQoKSBhZGRzIHRvIGlubmVyIHRvIG1ha2VcbiAgIGNyZWF0aW5nIGJvcmRlcnMgc2ltcGxlXG4gLSBzdGFydCgnbGVmdFBhbmVsJykgc2hvdWxkIHdvcmsgZm9yIGxvY2F0aW5nIHByZS1leGlzdGluZyBuYW1lZCBzcGFjZXNcbiAtIHN0YXJ0LCB0YWcsIGFuZCBhZGQoKSBzaG91bGQgdXNlIHN0YW5kYXJkIGhlbHBlciBtZXRob2RcbiAtIEZpeCBoYW5kbGluZyBvZiBTbG90cyB0aGF0IHJldHVybiBhcnJheXMuXG4gLSBQcm9wZXJseSBoYW5kbGUgaW5zZXJ0QmVmb3JlXyBvZiBhbiBlbGVtZW50IHRoYXQncyBhbHJlYWR5IGJlZW4gaW5zZXJ0ZWQ/XG4qL1xuXG5mb2FtLkVOVU0oe1xuICBwYWNrYWdlOiAnZm9hbS51MicsXG4gIG5hbWU6ICdDb250cm9sbGVyTW9kZScsXG5cbiAgZG9jdW1lbnRhdGlvbjogJ0NSVUQgY29udHJvbGxlciBtb2RlczogQ1JFQVRFL1ZJRVcvRURJVC4nLFxuXG4gIHZhbHVlczogW1xuICAgIHsgbmFtZTogJ0NSRUFURScsIGxhYmVsOiAnQ3JlYXRlJyB9LFxuICAgIHsgbmFtZTogJ1ZJRVcnLCAgIGxhYmVsOiAnVmlldycgICB9LFxuICAgIHsgbmFtZTogJ0VESVQnLCAgIGxhYmVsOiAnRWRpdCcgICB9XG4gIF1cbn0pO1xuXG5mb2FtLkVOVU0oe1xuICBwYWNrYWdlOiAnZm9hbS51MicsXG4gIG5hbWU6ICdEaXNwbGF5TW9kZScsXG5cbiAgZG9jdW1lbnRhdGlvbjogJ1ZpZXcgZGlzcGxheSBtb2RlOyBob3cgb3IgaWYgYSB2aWV3IGlzIGRpc3BsYXllZC4nLFxuXG4gIHZhbHVlczogW1xuICAgIHsgbmFtZTogJ1JXJywgICAgICAgbGFiZWw6ICdSZWFkLVdyaXRlJyB9LFxuICAgIHsgbmFtZTogJ0RJU0FCTEVEJywgbGFiZWw6ICdEaXNhYmxlZCcgICB9LFxuICAgIHsgbmFtZTogJ1JPJywgICAgICAgbGFiZWw6ICdSZWFkLU9ubHknICB9LFxuICAgIHsgbmFtZTogJ0hJRERFTicsICAgbGFiZWw6ICdIaWRkZW4nICAgICB9XG4gIF1cbn0pO1xuXG5cbmZvYW0uQ0xBU1Moe1xuICBwYWNrYWdlOiAnZm9hbS51MicsXG4gIG5hbWU6ICdFbnRpdHknLFxuXG4gIGRvY3VtZW50YXRpb246IGBcbiAgICBWaXJ0dWFsLURPTSBFbnRpdHkuXG4gICAgLy8gVE9ETzogTWFrZSBib3RoIEVudGl0eSBhbmQgRWxlbWVudCBleHRlbmQgYSBjb21tb24gYmFzZS1Nb2RlbCAoTm9kZT8pXG4gIGAsXG5cbiAgcHJvcGVydGllczogW1xuICAgIHtcbiAgICAgIG5hbWU6ICduYW1lJyxcbiAgICAgIGRvY3VtZW50YXRpb246IGBcbiAgICAgICAgLy8gcGFyc2VyOiBzZXEoYWxwaGFDaGFyLCByZXBlYXQwKHdvcmRDaGFyKSksXG4gICAgICAgIC8vIFRPRE8oYWRhbXZ5KTogVGhpcyBzaG91bGQgYmUgJ3BhdHRlcm4nIG9yICdyZWdleCcsIGlmIHRob3NlIGFyZSBldmVyXG4gICAgICAgIC8vIGFkZGVkLlxuICAgICAgYCxcbiAgICAgIGFzc2VydFZhbHVlOiBmdW5jdGlvbihudSkge1xuICAgICAgICBpZiAoICEgbnUubWF0Y2goL15bYS16I11cXHcqJC9pKSApIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgRW50aXR5IG5hbWU6ICcgKyBudSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIF0sXG5cbiAgbWV0aG9kczogW1xuICAgIGZ1bmN0aW9uIG91dHB1dChvdXQpIHsgb3V0KCcmJywgdGhpcy5uYW1lLCAnOycpOyB9LFxuICAgIGZ1bmN0aW9uIHRvRSgpIHsgcmV0dXJuIHRoaXM7IH1cbiAgXVxufSk7XG5cblxuZm9hbS5DTEFTUyh7XG4gIHBhY2thZ2U6ICdmb2FtLnUyJyxcbiAgbmFtZTogJ0NTUycsXG5cbiAgZG9jdW1lbnRhdGlvbjogJ0F4aW9tIHRvIGluc3RhbGwgQ1NTLicsXG5cbiAgcHJvcGVydGllczogW1xuICAgIHtcbiAgICAgIGNsYXNzOiAnU3RyaW5nJyxcbiAgICAgIG5hbWU6ICdjb2RlJ1xuICAgIH0sXG4gICAge1xuICAgICAgbmFtZTogJ25hbWUnLFxuICAgICAgZmFjdG9yeTogZnVuY3Rpb24oKSB7IHJldHVybiAnQ1NTLScgKyB0aGlzLiRVSUQ7IH1cbiAgICB9LFxuICAgIHtcbiAgICAgIG5hbWU6ICdpbnN0YWxsZWREb2N1bWVudHNfJyxcbiAgICAgIGZhY3Rvcnk6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbmV3IFdlYWtNYXAoKTsgfSxcbiAgICAgIHRyYW5zaWVudDogdHJ1ZVxuICAgIH1cbiAgXSxcblxuICBtZXRob2RzOiBbXG4gICAgZnVuY3Rpb24gaW5zdGFsbEluQ2xhc3MoY2xzKSB7XG4gICAgICAvLyBJbnN0YWxsIG15c2VsZiBpbiB0aGlzIFdpbmRvdywgaWYgbm90IGFscmVhZHkgdGhlcmUuXG4gICAgICB2YXIgb2xkQ3JlYXRlID0gY2xzLmNyZWF0ZTtcbiAgICAgIHZhciBheGlvbSAgICAgPSB0aGlzO1xuXG4gICAgICBjbHMuY3JlYXRlID0gZnVuY3Rpb24oYXJncywgb3B0X3BhcmVudCkge1xuICAgICAgICAvLyBUT0RPOiBtb3ZlIHRoaXMgZnVuY3Rpb25hbGl0eSBzb21ld2hlcmUgcmV1c2FibGVcbiAgICAgICAgdmFyIFggPSBvcHRfcGFyZW50ID9cbiAgICAgICAgICAoIG9wdF9wYXJlbnQuX19zdWJDb250ZXh0X18gfHwgb3B0X3BhcmVudC5fX2NvbnRleHRfXyB8fCBvcHRfcGFyZW50ICkgOlxuICAgICAgICAgIGZvYW0uX19jb250ZXh0X187XG5cbiAgICAgICAgLy8gSW5zdGFsbCBvdXIgb3duIENTUywgYW5kIHRoZW4gYWxsIHBhcmVudCBtb2RlbHMgYXMgd2VsbC5cbiAgICAgICAgaWYgKCBYLmRvY3VtZW50ICYmICEgYXhpb20uaW5zdGFsbGVkRG9jdW1lbnRzXy5oYXMoWC5kb2N1bWVudCkgKSB7XG4gICAgICAgICAgWC5pbnN0YWxsQ1NTKGF4aW9tLmV4cGFuZENTUyh0aGlzLCBheGlvbS5jb2RlKSwgY2xzLmlkKTtcbiAgICAgICAgICBheGlvbS5pbnN0YWxsZWREb2N1bWVudHNfLnNldChYLmRvY3VtZW50LCB0cnVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIE5vdyBjYWxsIHRocm91Z2ggdG8gdGhlIG9yaWdpbmFsIGNyZWF0ZS5cbiAgICAgICAgcmV0dXJuIG9sZENyZWF0ZS5jYWxsKHRoaXMsIGFyZ3MsIFgpO1xuICAgICAgfTtcbiAgICB9LFxuXG4gICAgZnVuY3Rpb24gZXhwYW5kQ1NTKGNscywgdGV4dCkge1xuICAgICAgLyogUGVyZm9ybXMgZXhwYW5zaW9uIG9mIHRoZSBeIHNob3J0aGFuZCBvbiB0aGUgQ1NTLiAqL1xuICAgICAgLy8gVE9ETyhicmFkZW4pOiBQYXJzZSBhbmQgdmFsaWRhdGUgdGhlIENTUy5cbiAgICAgIC8vIFRPRE8oYnJhZGVuKTogQWRkIHRoZSBhdXRvbWF0aWMgcHJlZml4aW5nIG9uY2Ugd2UgaGF2ZSB0aGUgcGFyc2VyLlxuICAgICAgdmFyIGJhc2UgPSAnLicgKyBmb2FtLlN0cmluZy5jc3NDbGFzc2l6ZShjbHMuaWQpO1xuICAgICAgcmV0dXJuIHRleHQucmVwbGFjZSgvXFxeKC4pL2csIGZ1bmN0aW9uKG1hdGNoLCBuZXh0KSB7XG4gICAgICAgIHZhciBjID0gbmV4dC5jaGFyQ29kZUF0KDApO1xuICAgICAgICAvLyBDaGVjayBpZiB0aGUgbmV4dCBjaGFyYWN0ZXIgaXMgYW4gdXBwZXJjYXNlIG9yIGxvd2VyY2FzZSBsZXR0ZXIsXG4gICAgICAgIC8vIG51bWJlciwgLSBvciBfLiBJZiBzbywgYWRkIGEgLSBiZWNhdXNlIHRoaXMgaXMgYSBtb2RpZmllZCBzdHJpbmcuXG4gICAgICAgIC8vIElmIG5vdCwgdGhlcmUncyBubyBleHRyYSAtLlxuICAgICAgICBpZiAoICg2NSA8PSBjICYmIGMgPD0gOTApIHx8ICg5NyA8PSBjICYmIGMgPD0gMTIyKSB8fFxuICAgICAgICAgICAgKDQ4IDw9IGMgJiYgYyA8PSA1NykgfHwgYyA9PT0gNDUgfHwgYyA9PT0gOTUgKSB7XG4gICAgICAgICAgcmV0dXJuIGJhc2UgKyAnLScgKyBuZXh0O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGJhc2UgKyBuZXh0O1xuICAgICAgfSk7XG4gICAgfVxuICBdXG59KTtcblxuXG5mb2FtLkNMQVNTKHtcbiAgcGFja2FnZTogJ2ZvYW0udTInLFxuICBuYW1lOiAnRGVmYXVsdFZhbGlkYXRvcicsXG5cbiAgZG9jdW1lbnRhdGlvbjogJ0RlZmF1bHQgRWxlbWVudCB2YWxpZGF0b3IuJyxcblxuICBheGlvbXM6IFsgZm9hbS5wYXR0ZXJuLlNpbmdsZXRvbi5jcmVhdGUoKSBdLFxuXG4gIG1ldGhvZHM6IFtcbiAgICBmdW5jdGlvbiB2YWxpZGF0ZU5vZGVOYW1lKG5hbWUpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0sXG5cbiAgICBmdW5jdGlvbiB2YWxpZGF0ZUNsYXNzKGNscykge1xuICAgICAgLy8gVE9ET1xuICAgIH0sXG5cbiAgICBmdW5jdGlvbiB2YWxpZGF0ZUF0dHJpYnV0ZU5hbWUobmFtZSkge1xuICAgICAgLy8gVE9ET1xuICAgIH0sXG5cbiAgICBmdW5jdGlvbiB2YWxpZGF0ZUF0dHJpYnV0ZVZhbHVlKHZhbHVlKSB7XG4gICAgICAvLyBUT0RPXG4gICAgfSxcblxuICAgIGZ1bmN0aW9uIHZhbGlkYXRlU3R5bGVOYW1lKG5hbWUpIHtcbiAgICAgIC8vIFRPRE9cbiAgICB9LFxuXG4gICAgZnVuY3Rpb24gdmFsaWRhdGVTdHlsZVZhbHVlKHZhbHVlKSB7XG4gICAgICAvLyBUT0RPXG4gICAgfSxcblxuICAgIGZ1bmN0aW9uIHNhbml0aXplVGV4dCh0ZXh0KSB7XG4gICAgICBpZiAoICEgdGV4dCApIHJldHVybiB0ZXh0O1xuICAgICAgdGV4dCA9IHRleHQudG9TdHJpbmcoKTtcbiAgICAgIHJldHVybiB0ZXh0LnJlcGxhY2UoL1smPFwiJ10vZywgZnVuY3Rpb24obSkge1xuICAgICAgICBzd2l0Y2ggKCBtICkge1xuICAgICAgICAgIGNhc2UgJyYnOiByZXR1cm4gJyZhbXA7JztcbiAgICAgICAgICBjYXNlICc8JzogcmV0dXJuICcmbHQ7JztcbiAgICAgICAgICBjYXNlICdcIic6IHJldHVybiAnJnF1b3Q7JztcbiAgICAgICAgICBjYXNlIFwiJ1wiOiByZXR1cm4gJyYjMDM5JztcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICBdXG59KTtcblxuXG5mb2FtLkNMQVNTKHtcbiAgcGFja2FnZTogJ2ZvYW0udTInLFxuICBuYW1lOiAnRWxlbWVudFN0YXRlJyxcblxuICBkb2N1bWVudGF0aW9uOiBgXG4gICAgQ3VycmVudCBsaWZlY3ljbGUgc3RhdGUgb2YgYW4gRWxlbWVudC5cbiAgICAvLyBUT0RPOiBEbyB3ZSB3YW50IHRoZSBmb2xsb3dpbmcgbWV0aG9kP1xuICAgIC8vIGZ1bmN0aW9uIGRldGFjaCgpIHt9LFxuICBgLFxuXG4gIG1ldGhvZHM6IFtcbiAgICBmdW5jdGlvbiBvdXRwdXQob3V0KSB7fSxcbiAgICBmdW5jdGlvbiBsb2FkKCkge30sXG4gICAgZnVuY3Rpb24gdW5sb2FkKCkge30sXG4gICAgZnVuY3Rpb24gb25SZW1vdmUoKSB7fSxcbiAgICBmdW5jdGlvbiBvblNldENsYXNzKCkge30sXG4gICAgZnVuY3Rpb24gb25Gb2N1cygpIHt9LFxuICAgIGZ1bmN0aW9uIG9uQWRkTGlzdGVuZXIoKSB7fSxcbiAgICBmdW5jdGlvbiBvblJlbW92ZUxpc3RlbmVyKCkge30sXG4gICAgZnVuY3Rpb24gb25TZXRTdHlsZSgpIHt9LFxuICAgIGZ1bmN0aW9uIG9uU2V0QXR0cigpIHt9LFxuICAgIGZ1bmN0aW9uIG9uUmVtb3ZlQXR0cigpIHt9LFxuICAgIGZ1bmN0aW9uIG9uQWRkQ2hpbGRyZW4oKSB7fSxcbiAgICBmdW5jdGlvbiBvbkluc2VydENoaWxkcmVuKCkge30sXG4gICAgZnVuY3Rpb24gb25SZXBsYWNlQ2hpbGQoKSB7fSxcbiAgICBmdW5jdGlvbiBvblJlbW92ZUNoaWxkKCkge30sXG4gICAgZnVuY3Rpb24gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbGVmdDogMCxcbiAgICAgICAgcmlnaHQ6IDAsXG4gICAgICAgIGJvdHRvbTogMCxcbiAgICAgICAgdG9wOiAwLFxuICAgICAgICB3aWR0aDogMCxcbiAgICAgICAgaGVpZ2h0OiAwXG4gICAgICB9O1xuICAgIH1cbiAgXVxufSk7XG5cblxuZm9hbS5DTEFTUyh7XG4gIHBhY2thZ2U6ICdmb2FtLnUyJyxcbiAgbmFtZTogJ1VubG9hZGVkRWxlbWVudFN0YXRlJyxcbiAgZXh0ZW5kczogJ2ZvYW0udTIuRWxlbWVudFN0YXRlJyxcblxuICBkb2N1bWVudGF0aW9uOiAnU3RhdGUgb2YgYW4gdW5sb2FkZWQgRWxlbWVudC4nLFxuXG4gIG1ldGhvZHM6IFtcbiAgICBmdW5jdGlvbiBvdXRwdXQob3V0KSB7XG4gICAgICB0aGlzLnN0YXRlID0gdGhpcy5PVVRQVVQ7XG4gICAgICB0aGlzLm91dHB1dF8ob3V0KTtcbiAgICAgIHJldHVybiBvdXQ7XG4gICAgfSxcbiAgICBmdW5jdGlvbiBsb2FkKCkge1xuICAgICAgdGhpcy5lcnJvcignTXVzdCBvdXRwdXQgYmVmb3JlIGxvYWRpbmcuJyk7XG4gICAgfSxcbiAgICBmdW5jdGlvbiB1bmxvYWQoKSB7XG4gICAgICB0aGlzLmVycm9yKCdNdXN0IG91dHB1dCBhbmQgbG9hZCBiZWZvcmUgdW5sb2FkaW5nLicpO1xuICAgIH0sXG4gICAgZnVuY3Rpb24gdG9TdHJpbmcoKSB7IHJldHVybiAnVU5MT0FERUQnOyB9XG4gIF1cbn0pO1xuXG5cbmZvYW0uQ0xBU1Moe1xuICBwYWNrYWdlOiAnZm9hbS51MicsXG4gIG5hbWU6ICdJbml0aWFsRWxlbWVudFN0YXRlJyxcbiAgZXh0ZW5kczogJ2ZvYW0udTIuVW5sb2FkZWRFbGVtZW50U3RhdGUnLFxuXG4gIGRvY3VtZW50YXRpb246ICdJbml0aWFsIHN0YXRlIG9mIGEgbmV3bHkgY3JlYXRlZCBFbGVtZW50LicsXG5cbiAgbWV0aG9kczogW1xuICAgIGZ1bmN0aW9uIG91dHB1dChvdXQpIHtcbiAgICAgIHRoaXMuaW5pdEUoKTtcbiAgICAgIHJldHVybiB0aGlzLlNVUEVSKG91dCk7XG4gICAgfSxcbiAgICBmdW5jdGlvbiB0b1N0cmluZygpIHsgcmV0dXJuICdJTklUSUFMJzsgfVxuICBdXG59KTtcblxuXG5mb2FtLkNMQVNTKHtcbiAgcGFja2FnZTogJ2ZvYW0udTInLFxuICBuYW1lOiAnT3V0cHV0RWxlbWVudFN0YXRlJyxcbiAgZXh0ZW5kczogJ2ZvYW0udTIuRWxlbWVudFN0YXRlJyxcblxuICBkb2N1bWVudGF0aW9uOiAnU3RhdGUgb2YgRWxlbWVudCBhZnRlciBpdCBoYXMgYmVlbiBvdXRwdXQgdG8gRE9NLCBidXQgbm90IHlldCBsb2FkZWQuJyxcblxuICBtZXRob2RzOiBbXG4gICAgZnVuY3Rpb24gb3V0cHV0KG91dCkge1xuICAgICAgLy8gVE9ETzogcmFpc2UgYSByZWFsIGVycm9yXG4gICAgICB0aGlzLndhcm4oJ0VSUk9SOiBEdXBsaWNhdGUgb3V0cHV0LicpO1xuICAgICAgcmV0dXJuIHRoaXMuVU5MT0FERUQub3V0cHV0LmNhbGwodGhpcywgb3V0KTtcbiAgICB9LFxuICAgIGZ1bmN0aW9uIGxvYWQoKSB7XG4gICAgICBpZiAoIHRoaXMuaGFzT3duUHJvcGVydHkoJ2VsTGlzdGVuZXJzJykgKSB7XG4gICAgICAgIHZhciBscyA9IHRoaXMuZWxMaXN0ZW5lcnM7XG4gICAgICAgIGZvciAoIHZhciBpID0gMCA7IGkgPCBscy5sZW5ndGggOyBpKz0yICkge1xuICAgICAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcl8obHNbaV0sIGxzW2krMV0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHRoaXMudmlzaXRDaGlsZHJlbignbG9hZCcpO1xuICAgICAgdGhpcy5zdGF0ZSA9IHRoaXMuTE9BREVEO1xuICAgICAgaWYgKCB0aGlzLnRhYkluZGV4ICkgdGhpcy5zZXRBdHRyaWJ1dGUoJ3RhYmluZGV4JywgdGhpcy50YWJJbmRleCk7XG4gICAgICBpZiAoIHRoaXMuZm9jdXNlZCApIHRoaXMuZWwoKS5mb2N1cygpO1xuICAgICAgLy8gQWxsb3dzIHlvdSB0byB0YWtlIHRoZSBET00gZWxlbWVudCBhbmQgbWFwIGl0IGJhY2sgdG8gYVxuICAgICAgLy8gZm9hbS51Mi5FbGVtZW50IG9iamVjdC4gIFRoaXMgaXMgZXhwZW5zaXZlIHdoZW4gYnVpbGRpbmdcbiAgICAgIC8vIGxvdHMgb2YgRE9NIHNpbmNlIGl0IGFkZHMgYW4gZXh0cmEgRE9NIGNhbGwgcGVyIEVsZW1lbnQuXG4gICAgICAvLyBCdXQgeW91IGNvdWxkIHVzZSBpdCB0byBjdXQgZG93biBvbiB0aGUgbnVtYmVyIG9mIGxpc3RlbmVyc1xuICAgICAgLy8gaW4gc29tZXRoaW5nIGxpa2UgYSB0YWJsZSB2aWV3IGJ5IGRvaW5nIHBlciB0YWJsZSBsaXN0ZW5lcnNcbiAgICAgIC8vIHJhdGhlciB0aGFuIHBlci1yb3cgbGlzdGVuZXJzIGFuZCBpbiB0aGUgZXZlbnQgZmluZGluZyB0aGUgcmlnaHRcbiAgICAgIC8vIFUyIHZpZXcgYnkgd2Fsa2luZyB0aGUgRE9NIHRyZWUgYW5kIGNoZWNraW5nIGVfLlxuICAgICAgLy8gVGhpcyBjb3VsZCBzYXZlIG1vcmUgdGltZSB0aGFuIHRoZSB3b3JrIHNwZW50IGhlcmUgYWRkaW5nIGVfIHRvIGVhY2hcbiAgICAgIC8vIERPTSBlbGVtZW50LlxuICAgICAgLy8gdGhpcy5lbCgpLmVfID0gdGhpcztcbiAgICB9LFxuICAgIGZ1bmN0aW9uIHVubG9hZCgpIHtcbiAgICAgIHRoaXMuc3RhdGUgPSB0aGlzLlVOTE9BREVEO1xuICAgICAgdGhpcy52aXNpdENoaWxkcmVuKCd1bmxvYWQnKTtcbiAgICB9LFxuICAgIGZ1bmN0aW9uIGVycm9yKCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdNdXRhdGlvbnMgbm90IGFsbG93ZWQgaW4gT1VUUFVUIHN0YXRlLicpO1xuICAgIH0sXG4gICAgZnVuY3Rpb24gb25TZXRDbGFzcyhjbHMsIGVuYWJsZWQpIHsgdGhpcy5lcnJvcigpOyB9LFxuICAgIGZ1bmN0aW9uIG9uRm9jdXMoY2xzLCBlbmFibGVkKSB7IHRoaXMuZXJyb3IoKTsgfSxcbiAgICBmdW5jdGlvbiBvbkFkZExpc3RlbmVyKHRvcGljLCBsaXN0ZW5lcikgeyB0aGlzLmVycm9yKCk7IH0sXG4gICAgZnVuY3Rpb24gb25SZW1vdmVMaXN0ZW5lcih0b3BpYywgbGlzdGVuZXIpIHsgdGhpcy5lcnJvcigpOyB9LFxuICAgIGZ1bmN0aW9uIG9uU2V0U3R5bGUoa2V5LCB2YWx1ZSkgeyB0aGlzLmVycm9yKCk7IH0sXG4gICAgZnVuY3Rpb24gb25TZXRBdHRyKGtleSwgdmFsdWUpIHsgdGhpcy5lcnJvcigpOyB9LFxuICAgIGZ1bmN0aW9uIG9uUmVtb3ZlQXR0cihrZXkpIHsgdGhpcy5lcnJvcigpOyB9LFxuICAgIGZ1bmN0aW9uIG9uQWRkQ2hpbGRyZW4oYykgeyB0aGlzLmVycm9yKCk7IH0sXG4gICAgZnVuY3Rpb24gb25JbnNlcnRDaGlsZHJlbigpIHsgdGhpcy5lcnJvcigpOyB9LFxuICAgIGZ1bmN0aW9uIG9uUmVwbGFjZUNoaWxkKCkgeyB0aGlzLmVycm9yKCk7IH0sXG4gICAgZnVuY3Rpb24gb25SZW1vdmVDaGlsZCgpIHsgdGhpcy5lcnJvcigpOyB9LFxuICAgIGZ1bmN0aW9uIHRvU3RyaW5nKCkgeyByZXR1cm4gJ09VVFBVVCc7IH1cbiAgXVxufSk7XG5cblxuZm9hbS5DTEFTUyh7XG4gIHBhY2thZ2U6ICdmb2FtLnUyJyxcbiAgbmFtZTogJ0xvYWRlZEVsZW1lbnRTdGF0ZScsXG4gIGV4dGVuZHM6ICdmb2FtLnUyLkVsZW1lbnRTdGF0ZScsXG5cbiAgZG9jdW1lbnRhdGlvbjogJ1N0YXRlIG9mIGFuIEVsZW1lbnQgYWZ0ZXIgaXQgaGFzIGJlZW4gb3V0cHV0IHRvIHRoZSBET00gYW5kIGxvYWRlZC4nLFxuXG4gIG1ldGhvZHM6IFtcbiAgICBmdW5jdGlvbiBvdXRwdXQob3V0KSB7XG4gICAgICB0aGlzLndhcm4oJ0R1cGxpY2F0ZSBvdXRwdXQuJyk7XG4gICAgICByZXR1cm4gdGhpcy5VTkxPQURFRC5vdXRwdXQuY2FsbCh0aGlzLCBvdXQpO1xuICAgIH0sXG4gICAgZnVuY3Rpb24gbG9hZCgpIHsgdGhpcy5lcnJvcignRHVwbGljYXRlIGxvYWQuJyk7IH0sXG4gICAgZnVuY3Rpb24gdW5sb2FkKCkge1xuICAgICAgaWYgKCAhIHRoaXMucGFyZW50Tm9kZSB8fCB0aGlzLnBhcmVudE5vZGUuc3RhdGUgPT09IHRoaXMuTE9BREVEICkge1xuICAgICAgICB2YXIgZSA9IHRoaXMuZWwoKTtcbiAgICAgICAgaWYgKCBlICkgZS5yZW1vdmUoKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5zdGF0ZSA9IHRoaXMuVU5MT0FERUQ7XG4gICAgICB0aGlzLnZpc2l0Q2hpbGRyZW4oJ3VubG9hZCcpO1xuICAgIH0sXG4gICAgZnVuY3Rpb24gb25SZW1vdmUoKSB7IHRoaXMudW5sb2FkKCk7IH0sXG4gICAgZnVuY3Rpb24gb25TZXRDbGFzcyhjbHMsIGVuYWJsZWQpIHtcbiAgICAgIHZhciBlID0gdGhpcy5lbCgpO1xuICAgICAgaWYgKCBlICkge1xuICAgICAgICBlLmNsYXNzTGlzdFtlbmFibGVkID8gJ2FkZCcgOiAncmVtb3ZlJ10oY2xzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMud2FybignTWlzc2luZyBFbGVtZW50OiAnLCB0aGlzLmlkKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGZ1bmN0aW9uIG9uRm9jdXMoKSB7XG4gICAgICB0aGlzLmVsKCkuZm9jdXMoKTtcbiAgICB9LFxuICAgIGZ1bmN0aW9uIG9uQWRkTGlzdGVuZXIodG9waWMsIGxpc3RlbmVyKSB7XG4gICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXJfKHRvcGljLCBsaXN0ZW5lcik7XG4gICAgfSxcbiAgICBmdW5jdGlvbiBvblJlbW92ZUxpc3RlbmVyKHRvcGljLCBsaXN0ZW5lcikge1xuICAgICAgdGhpcy5hZGRSZW1vdmVMaXN0ZW5lcl8odG9waWMsIGxpc3RlbmVyKTtcbiAgICB9LFxuICAgIGZ1bmN0aW9uIG9uU2V0U3R5bGUoa2V5LCB2YWx1ZSkge1xuICAgICAgdGhpcy5lbCgpLnN0eWxlW2tleV0gPSB2YWx1ZTtcbiAgICB9LFxuICAgIGZ1bmN0aW9uIG9uU2V0QXR0cihrZXksIHZhbHVlKSB7XG4gICAgICBpZiAoIHRoaXMuUFNFRE9fQVRUUklCVVRFU1trZXldICkge1xuICAgICAgICB0aGlzLmVsKClba2V5XSA9IHZhbHVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5lbCgpLnNldEF0dHJpYnV0ZShrZXksIHZhbHVlID09PSB0cnVlID8gJycgOiB2YWx1ZSk7XG4gICAgICB9XG4gICAgfSxcbiAgICBmdW5jdGlvbiBvblJlbW92ZUF0dHIoa2V5KSB7XG4gICAgICBpZiAoIHRoaXMuUFNFRE9fQVRUUklCVVRFU1trZXldICkge1xuICAgICAgICB0aGlzLmVsKClba2V5XSA9ICcnO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5lbCgpLnJlbW92ZUF0dHJpYnV0ZShrZXkpO1xuICAgICAgfVxuICAgIH0sXG4gICAgZnVuY3Rpb24gb25BZGRDaGlsZHJlbigpIHtcbiAgICAgIHZhciBlID0gdGhpcy5lbCgpO1xuICAgICAgaWYgKCAhIGUgKSB7XG4gICAgICAgIHRoaXMud2FybignTWlzc2luZyBFbGVtZW50OiAnLCB0aGlzLmlkKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIG91dCA9IHRoaXMuY3JlYXRlT3V0cHV0U3RyZWFtKCk7XG4gICAgICBmb3IgKCB2YXIgaSA9IDAgOyBpIDwgYXJndW1lbnRzLmxlbmd0aCA7IGkrKyApIHtcbiAgICAgICAgb3V0KGFyZ3VtZW50c1tpXSk7XG4gICAgICB9XG4gICAgICBlLmluc2VydEFkamFjZW50SFRNTCgnYmVmb3JlZW5kJywgb3V0KTtcbiAgICAgIGZvciAoIHZhciBpID0gMCA7IGkgPCBhcmd1bWVudHMubGVuZ3RoIDsgaSsrICkge1xuICAgICAgICBhcmd1bWVudHNbaV0ubG9hZCAmJiBhcmd1bWVudHNbaV0ubG9hZCgpO1xuICAgICAgfVxuICAgIH0sXG4gICAgZnVuY3Rpb24gb25JbnNlcnRDaGlsZHJlbihjaGlsZHJlbiwgcmVmZXJlbmNlLCB3aGVyZSkge1xuICAgICAgdmFyIGUgPSB0aGlzLmVsKCk7XG4gICAgICBpZiAoICEgZSApIHtcbiAgICAgICAgdGhpcy53YXJuKCdNaXNzaW5nIEVsZW1lbnQ6ICcsIHRoaXMuaWQpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB2YXIgb3V0ID0gdGhpcy5jcmVhdGVPdXRwdXRTdHJlYW0oKTtcbiAgICAgIGZvciAoIHZhciBpID0gMCA7IGkgPCBjaGlsZHJlbi5sZW5ndGggOyBpKysgKSB7XG4gICAgICAgIG91dChjaGlsZHJlbltpXSk7XG4gICAgICB9XG5cbiAgICAgIHJlZmVyZW5jZS5lbCgpLmluc2VydEFkamFjZW50SFRNTCh3aGVyZSwgb3V0KTtcblxuICAgICAgLy8gRVhQRVJJTUVOVEFMOlxuICAgICAgLy8gVE9ETyhrZ3IpOiBUaGlzIGNhdXNlcyBzb21lIGVsZW1lbnRzIHRvIGdldCBzdHVjayBpbiBPVVRQVVQgc3RhdGVcbiAgICAgIC8vIGZvcmV2ZXIuIEl0IGNhbiBiZSByZXN1cnJlY3RlZCBpZiB0aGF0IHByb2JsZW0gaXMgZml4ZWQuXG4gICAgICAvLyBMb2FkIChtb3N0bHkgYWRkaW5nIGxpc3RlbmVycykgb24gdGhlIG5leHQgZnJhbWVcbiAgICAgIC8vIHRvIGFsbG93IHRoZSBIVE1MIHRvIGJlIHNob3duIG1vcmUgcXVpY2tseS5cbiAgICAgIC8vIHRoaXMuX19jb250ZXh0X18ud2luZG93LnNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICBmb3IgKCB2YXIgaSA9IDAgOyBpIDwgY2hpbGRyZW4ubGVuZ3RoIDsgaSsrICkge1xuICAgICAgICBjaGlsZHJlbltpXS5sb2FkICYmIGNoaWxkcmVuW2ldLmxvYWQoKTtcbiAgICAgIH1cbiAgICAgIC8vIH0sIDMzKTtcbiAgICB9LFxuICAgIGZ1bmN0aW9uIG9uUmVwbGFjZUNoaWxkKG9sZEUsIG5ld0UpIHtcbiAgICAgIHZhciBlID0gdGhpcy5lbCgpO1xuICAgICAgaWYgKCAhIGUgKSB7XG4gICAgICAgIHRoaXMud2FybignTWlzc2luZyBFbGVtZW50OiAnLCB0aGlzLmlkKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIG91dCA9IHRoaXMuY3JlYXRlT3V0cHV0U3RyZWFtKCk7XG4gICAgICBvdXQobmV3RSk7XG4gICAgICBvbGRFLmVsKCkub3V0ZXJIVE1MID0gb3V0LnRvU3RyaW5nKCk7XG4gICAgICBuZXdFLmxvYWQgJiYgbmV3RS5sb2FkKCk7XG4gICAgfSxcbiAgICBmdW5jdGlvbiBvblJlbW92ZUNoaWxkKGNoaWxkLCBpbmRleCkge1xuICAgICAgaWYgKCB0eXBlb2YgY2hpbGQgPT09ICdzdHJpbmcnICkge1xuICAgICAgICB0aGlzLmVsKCkuY2hpbGROb2Rlc1tpbmRleF0ucmVtb3ZlKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjaGlsZC5yZW1vdmUoKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGZ1bmN0aW9uIGdldEJvdW5kaW5nQ2xpZW50UmVjdCgpIHtcbiAgICAgIHJldHVybiB0aGlzLmVsKCkuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgfSxcbiAgICBmdW5jdGlvbiB0b1N0cmluZygpIHsgcmV0dXJuICdMT0FERUQnOyB9XG4gIF1cbn0pO1xuXG5cbmZvYW0uQ0xBU1Moe1xuICBwYWNrYWdlOiAnZm9hbS51MicsXG4gIG5hbWU6ICdSZW5kZXJTaW5rJyxcbiAgaW1wbGVtZW50czogWyAnZm9hbS5kYW8uU2luaycgXSxcbiAgYXhpb21zOiBbXG4gICAge1xuICAgICAgY2xhc3M6ICdmb2FtLmJveC5SZW1vdGUnLFxuICAgICAgY2xpZW50Q2xhc3M6ICdmb2FtLmRhby5DbGllbnRTaW5rJ1xuICAgIH1cbiAgXSxcbiAgcHJvcGVydGllczogW1xuICAgIHtcbiAgICAgIGNsYXNzOiAnRnVuY3Rpb24nLFxuICAgICAgbmFtZTogJ2FkZFJvdydcbiAgICB9LFxuICAgIHtcbiAgICAgIGNsYXNzOiAnRnVuY3Rpb24nLFxuICAgICAgbmFtZTogJ2NsZWFudXAnXG4gICAgfSxcbiAgICAnZGFvJyxcbiAgICB7XG4gICAgICBjbGFzczogJ0ludCcsXG4gICAgICBuYW1lOiAnYmF0Y2gnXG4gICAgfVxuICBdLFxuICBtZXRob2RzOiBbXG4gICAgZnVuY3Rpb24gcHV0KG9iaiwgcykge1xuICAgICAgdGhpcy5yZXNldCgpO1xuICAgIH0sXG4gICAgZnVuY3Rpb24gcmVtb3ZlKG9iaiwgcykge1xuICAgICAgdGhpcy5yZXNldCgpO1xuICAgIH0sXG4gICAgZnVuY3Rpb24gcmVzZXQoKSB7XG4gICAgICB0aGlzLnBhaW50KCk7XG4gICAgfVxuICBdLFxuICBsaXN0ZW5lcnM6IFtcbiAgICB7XG4gICAgICBuYW1lOiAncGFpbnQnLFxuICAgICAgaXNNZXJnZWQ6IDEwMCxcbiAgICAgIGNvZGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgYmF0Y2ggPSArK3RoaXMuYmF0Y2g7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgdGhpcy5kYW8uc2VsZWN0KCkudGhlbihmdW5jdGlvbihhKSB7XG4gICAgICAgICAgLy8gQ2hlY2sgaWYgdGhpcyBpcyBhIHN0YWxlIHJlbmRlclxuICAgICAgICAgIGlmICggc2VsZi5iYXRjaCAhPT0gYmF0Y2ggKSByZXR1cm47XG5cbiAgICAgICAgICB2YXIgb2JqcyA9IGEuYXJyYXk7XG4gICAgICAgICAgc2VsZi5jbGVhbnVwKCk7XG4gICAgICAgICAgZm9yICggdmFyIGkgPSAwIDsgaSA8IG9ianMubGVuZ3RoIDsgaSsrICkge1xuICAgICAgICAgICAgc2VsZi5hZGRSb3cob2Jqc1tpXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gIF1cbn0pO1xuXG5mb2FtLkNMQVNTKHtcbiAgcGFja2FnZTogJ2ZvYW0udTInLFxuICBuYW1lOiAnRWxlbWVudCcsXG5cbiAgZG9jdW1lbnRhdGlvbjogYFxuICAgIFZpcnR1YWwtRE9NIEVsZW1lbnQuIFJvb3QgbW9kZWwgZm9yIGFsbCBVMiBVSSBjb21wb25lbnRzLlxuXG4gICAgVG8gaW5zZXJ0IGEgVTIgRWxlbWVudCBpbnRvIGEgcmVndWxhciBET00gZWxlbWVudCwgZWl0aGVyOlxuXG4gICAgZWwuaW5uZXJIVE1MID0gdmlldy5vdXRlckhUTUw7XG4gICAgdmlldy5sb2FkKCk7XG5cbiAgICBPciB1c2UgYSBmb2FtIHRhZyBpbiB5b3VyIG1hcmt1cDpcblxuICAgIDxmb2FtIGNsYXNzPVwiY29tLmFjbWUubXlwYWNrYWdlLk15Vmlld1wiPjwvZm9hbT5cblxuICAgIC8vIFRPRE86IERlY2lkZSBpZiB3ZSB3YW50IHRoaXMgb3Igbm90OlxuICAgIC8vIGZ1bmN0aW9uIFhYWEUob3B0X25vZGVOYW1lIC8qIHwgRElWICovKSB7XG4gICAgLy8gICAvKiBDcmVhdGUgYSBuZXcgRWxlbWVudCAqL1xuICAgIC8vICAgdmFyIFkgPSB0aGlzLl9fc3ViQ29udGV4dF9fO1xuICAgIC8vXG4gICAgLy8gICAvLyA/Pz86IElzIHRoaXMgbmVlZGVkIC8gYSBnb29kIGlkZWE/XG4gICAgLy8gICBpZiAoIHRoaXMuZGF0YSAmJiAhIFkuZGF0YSApIFkgPSBZLmNyZWF0ZVN1YkNvbnRleHQoeyBkYXRhOiB0aGlzLmRhdGEgfSk7XG4gICAgLy9cbiAgICAvLyAgIC8vIFNvbWUgbmFtZXMgaGF2ZSBzdWItTW9kZWxzIHJlZ2lzdGVyZWQgZm9yIHRoZW0uXG4gICAgLy8gICAvLyBFeGFtcGxlICdpbnB1dCdcbiAgICAvLyAgIHZhciBlID0gWS5lbGVtZW50Rm9yTmFtZShvcHRfbm9kZU5hbWUpO1xuICAgIC8vXG4gICAgLy8gICBpZiAoICEgZSApIHtcbiAgICAvLyAgICAgZSA9IGZvYW0udTIuRWxlbWVudC5jcmVhdGUobnVsbCwgWSk7XG4gICAgLy8gICAgIGlmICggb3B0X25vZGVOYW1lICkgZS5ub2RlTmFtZSA9IG9wdF9ub2RlTmFtZTtcbiAgICAvLyAgIH1cbiAgICAvL1xuICAgIC8vICAgcmV0dXJuIGU7XG4gICAgLy8gfSxcbiAgYCxcblxuICByZXF1aXJlczogW1xuICAgICdmb2FtLnUyLkF0dHJTbG90JyxcbiAgICAnZm9hbS51Mi5EZWZhdWx0VmFsaWRhdG9yJyxcbiAgICAnZm9hbS51Mi5FbnRpdHknLFxuICAgICdmb2FtLnUyLlZpZXdTcGVjJ1xuICBdLFxuXG4gIGltcG9ydHM6IFtcbiAgICAnZG9jdW1lbnQnLFxuICAgICdlbGVtZW50VmFsaWRhdG9yJyxcbiAgICAnZnJhbWVkJyxcbiAgICAnZ2V0RWxlbWVudEJ5SWQnXG4gIF0sXG5cbiAgdG9waWNzOiBbXG4gICAgJ29ubG9hZCcsXG4gICAgJ29udW5sb2FkJ1xuICBdLFxuXG4gIGNvbnN0YW50czogW1xuICAgIHtcbiAgICAgIGRvY3VtZW50YXRpb246IGBcbiAgICAgICAgUHNlZG8tYXR0cmlidXRlcyBkb24ndCB3b3JrIGNvbnNpc3RlbnRseSB3aXRoIHNldEF0dHJpYnV0ZSgpIHNvIG5lZWQgdG9cbiAgICAgICAgYmUgc2V0IG9uIHRoZSByZWFsIERPTSBlbGVtZW50IGRpcmVjdGx5LlxuICAgICAgYCxcbiAgICAgIG5hbWU6ICdQU0VET19BVFRSSUJVVEVTJyxcbiAgICAgIHZhbHVlOiB7XG4gICAgICAgIHZhbHVlOiB0cnVlLFxuICAgICAgICBjaGVja2VkOiB0cnVlXG4gICAgICB9LFxuICAgIH0sXG5cbiAgICB7XG4gICAgICBuYW1lOiAnREVGQVVMVF9WQUxJREFUT1InLFxuICAgICAgZmFjdG9yeTogZnVuY3Rpb24oKSB7IHJldHVybiBmb2FtLnUyLkRlZmF1bHRWYWxpZGF0b3IuY3JlYXRlKCkgfSxcbiAgICB9LFxuXG4gICAge1xuICAgICAgZG9jdW1lbnRhdGlvbjogYFxuICAgICAgICBTdGF0ZSBvZiBhbiBFbGVtZW50IGFmdGVyIGl0IGhhcyBiZWVuIG91dHB1dCAodG8gYSBTdHJpbmcpIGJ1dCBiZWZvcmUgaXRcbiAgICAgICAgaXMgbG9hZGVkLiBUaGlzIHNob3VsZCBiZSBvbmx5IGEgYnJpZWYgdHJhbnNpdG9yeSBzdGF0ZSwgYXMgdGhlIEVsZW1lbnRcbiAgICAgICAgc2hvdWxkIGJlIGxvYWRlZCBhbG1vc3QgaW1tZWRpYXRlbHkgYWZ0ZXIgYmVpbmcgb3V0cHV0LiBJdCBpcyBhbiBlcnJvclxuICAgICAgICB0byB0cnkgYW5kIG11dGF0ZSB0aGUgRWxlbWVudCB3aGlsZSBpbiB0aGUgT1VUUFVUIHN0YXRlLlxuICAgICAgYCxcbiAgICAgIG5hbWU6ICdPVVRQVVQnLFxuICAgICAgZmFjdG9yeTogZnVuY3Rpb24oKSB7IHJldHVybiBmb2FtLnUyLk91dHB1dEVsZW1lbnRTdGF0ZS5jcmVhdGUoKSB9LFxuICAgIH0sXG5cbiAgICB7XG4gICAgICBkb2N1bWVudGF0aW9uOiBgXG4gICAgICAgIFN0YXRlIG9mIGFuIEVsZW1lbnQgYWZ0ZXIgaXQgaGFzIGJlZW4gbG9hZGVkLlxuICAgICAgICBBIExvYWRlZCBFbGVtZW50IHNob3VsZCBiZSB2aXNpYmxlIGluIHRoZSBET00uXG4gICAgICBgLFxuICAgICAgbmFtZTogJ0xPQURFRCcsXG4gICAgICBmYWN0b3J5OiBmdW5jdGlvbigpIHsgcmV0dXJuIGZvYW0udTIuTG9hZGVkRWxlbWVudFN0YXRlLmNyZWF0ZSgpIH0sXG4gICAgfSxcblxuICAgIHtcbiAgICAgIGRvY3VtZW50YXRpb246IGBcbiAgICAgICAgU3RhdGUgb2YgYW4gRWxlbWVudCBhZnRlciBpdCBoYXMgYmVlbiByZW1vdmVkIGZyb20gdGhlIERPTS5cbiAgICAgICAgQW4gdW5sb2FkZWQgRWxlbWVudCBjYW4gYmUgcmVhZGRlZCB0byB0aGUgRE9NLlxuICAgICAgYCxcbiAgICAgIG5hbWU6ICdVTkxPQURFRCcsXG4gICAgICBmYWN0b3J5OiBmdW5jdGlvbigpIHsgcmV0dXJuIGZvYW0udTIuVW5sb2FkZWRFbGVtZW50U3RhdGUuY3JlYXRlKCkgfSxcbiAgICB9LFxuXG4gICAge1xuICAgICAgZG9jdW1lbnRhdGlvbjogYFxuICAgICAgICBJbml0aWFsIHN0YXRlIG9mIGFuIEVsZW1lbnQgYmVmb3JlIGl0IGhhcyBiZWVuIGFkZGVkIHRvIHRoZSBET00uXG4gICAgICBgLFxuICAgICAgbmFtZTogJ0lOSVRJQUwnLFxuICAgICAgZmFjdG9yeTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBmb2FtLnUyLkluaXRpYWxFbGVtZW50U3RhdGUuY3JlYXRlKCk7XG4gICAgICB9LFxuICAgIH0sXG5cbiAgICAvLyA/Pz86IEFkZCBERVNUUk9ZRUQgU3RhdGU/XG5cbiAgICB7XG4gICAgICBkb2N1bWVudGF0aW9uOiBgVE9ETzogRG9uJ3QgYWxsb3cgdGhlc2UgYXMgdGhleSBsZWFkIHRvIGFtYmlndW91cyBtYXJrdXAuYCxcbiAgICAgIG5hbWU6ICdPUFRJT05BTF9DTE9TRV9UQUdTJyxcbiAgICAgIHZhbHVlOiB7XG4gICAgICAgIEJPRFk6IHRydWUsXG4gICAgICAgIENPTEdST1VQOiB0cnVlLFxuICAgICAgICBERDogdHJ1ZSxcbiAgICAgICAgRFQ6IHRydWUsXG4gICAgICAgIEhFQUQ6IHRydWUsXG4gICAgICAgIEhUTUw6IHRydWUsXG4gICAgICAgIExJOiB0cnVlLFxuICAgICAgICBPUFRJT046IHRydWUsXG4gICAgICAgIFA6IHRydWUsXG4gICAgICAgIFRCT0RZOiB0cnVlLFxuICAgICAgICBURDogdHJ1ZSxcbiAgICAgICAgVEZPT1Q6IHRydWUsXG4gICAgICAgIFRIOiB0cnVlLFxuICAgICAgICBUSEVBRDogdHJ1ZSxcbiAgICAgICAgVFI6IHRydWVcbiAgICAgIH1cbiAgICB9LFxuXG4gICAge1xuICAgICAgZG9jdW1lbnRhdGlvbjogYFxuICAgICAgICBFbGVtZW50IG5vZGVOYW1lJ3MgdGhhdCBhcmUgc2VsZi1jbG9zaW5nLlxuICAgICAgICBVc2VkIHRvIGdlbmVyYXRlIHZhbGlkIEhUTUwgb3V0cHV0LlxuICAgICAgICBVc2VkIGJ5IEVsZW1lbnRQYXJzZXIgZm9yIHZhbGlkIEhUTUwgcGFyc2luZy5cbiAgICAgIGAsXG4gICAgICBuYW1lOiAnSUxMRUdBTF9DTE9TRV9UQUdTJyxcbiAgICAgIHZhbHVlOiB7XG4gICAgICAgIEFSRUE6IHRydWUsXG4gICAgICAgIEJBU0U6IHRydWUsXG4gICAgICAgIEJBU0VGT05UOiB0cnVlLFxuICAgICAgICBCUjogdHJ1ZSxcbiAgICAgICAgQ09MOiB0cnVlLFxuICAgICAgICBGUkFNRTogdHJ1ZSxcbiAgICAgICAgSFI6IHRydWUsXG4gICAgICAgIElNRzogdHJ1ZSxcbiAgICAgICAgSU5QVVQ6IHRydWUsXG4gICAgICAgIElTSU5ERVg6IHRydWUsXG4gICAgICAgIExJTks6IHRydWUsXG4gICAgICAgIE1FVEE6IHRydWUsXG4gICAgICAgIFBBUkFNOiB0cnVlXG4gICAgICB9LFxuICAgIH0sXG5cbiAgICB7XG4gICAgICBuYW1lOiAnX19JRF9fJyxcbiAgICAgIHZhbHVlOiBbIDAgXSxcbiAgICB9LFxuXG4gICAge1xuICAgICAgbmFtZTogJ05FWFRfSUQnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gJ3YnICsgdGhpcy5fX0lEX19bIDAgXSsrO1xuICAgICAgfSxcbiAgICB9LFxuXG4gICAge1xuICAgICAgZG9jdW1lbnRhdGlvbjogYEtleXMgd2hpY2ggcmVzcG9uZCB0byBrZXlkb3duIGJ1dCBub3Qga2V5cHJlc3NgLFxuICAgICAgbmFtZTogJ0tFWVBSRVNTX0NPREVTJyxcbiAgICAgIHZhbHVlOiB7IDg6IHRydWUsIDEzOiB0cnVlLCAyNzogdHJ1ZSwgMzM6IHRydWUsIDM0OiB0cnVlLCAzNzogdHJ1ZSwgMzg6IHRydWUsIDM5OiB0cnVlLCA0MDogdHJ1ZSB9LFxuICAgIH0sXG5cbiAgICB7XG4gICAgICBuYW1lOiAnTkFNRURfQ09ERVMnLFxuICAgICAgdmFsdWU6IHtcbiAgICAgICAgJzEzJzogJ2VudGVyJyxcbiAgICAgICAgJzM3JzogJ2xlZnQnLFxuICAgICAgICAnMzgnOiAndXAnLFxuICAgICAgICAnMzknOiAncmlnaHQnLFxuICAgICAgICAnNDAnOiAnZG93bidcbiAgICAgIH1cbiAgICB9LFxuICBdLFxuXG4gIGNzczogYFxuICAgIC8qXG4gICAgIFdlIGhpZGUgRWxlbWVudHMgYnkgYWRkaW5nIHRoaXMgc3R5bGUgcmF0aGVyIHRoYW4gc2V0dGluZ1xuICAgICAnZGlzcGxheTogbm9uZScgZGlyZWN0bHkgYmVjYXVzZSB0aGVuIHdoZW4gd2UgcmUtc2hvdyB0aGVcbiAgICAgRWxlbWVudCB3ZSBkb24ndCBuZWVkIHRvIHJlbWVtYmVyIGl0J3MgZGVzaXJlZCAnZGlzcGxheScgdmFsdWUuXG4gICAgKi9cbiAgICAuZm9hbS11Mi1FbGVtZW50LWhpZGRlbiB7XG4gICAgICBkaXNwbGF5OiBub25lICFpbXBvcnRhbnQ7XG4gICAgfVxuICBgLFxuXG4gIHByb3BlcnRpZXM6IFtcbiAgICB7XG4gICAgICBuYW1lOiAnaWQnLFxuICAgICAgdHJhbnNpZW50OiB0cnVlLFxuICAgICAgZmFjdG9yeTogZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLk5FWFRfSUQoKTsgfVxuICAgIH0sXG4gICAge1xuICAgICAgbmFtZTogJ3N0YXRlJyxcbiAgICAgIGNsYXNzOiAnUHJveHknLFxuICAgICAgb2Y6ICdmb2FtLnUyLkVsZW1lbnRTdGF0ZScsXG4gICAgICB0cmFuc2llbnQ6IHRydWUsXG4gICAgICB0b3BpY3M6IFtdLFxuICAgICAgZGVsZWdhdGVzOiBmb2FtLnUyLkVsZW1lbnRTdGF0ZS5nZXRPd25BeGlvbXNCeUNsYXNzKGZvYW0uY29yZS5NZXRob2QpLlxuICAgICAgICAgIG1hcChmdW5jdGlvbihtKSB7IHJldHVybiBtLm5hbWU7IH0pLFxuICAgICAgZmFjdG9yeTogZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLklOSVRJQUw7IH0sXG4gICAgICBwb3N0U2V0OiBmdW5jdGlvbihvbGRTdGF0ZSwgc3RhdGUpIHtcbiAgICAgICAgaWYgKCBzdGF0ZSA9PT0gdGhpcy5MT0FERUQgKSB7XG4gICAgICAgICAgdGhpcy5wdWIoJ29ubG9hZCcpO1xuICAgICAgICB9IGVsc2UgaWYgKCBzdGF0ZSA9PT0gdGhpcy5VTkxPQURFRCApIHtcbiAgICAgICAgICB0aGlzLnB1Yignb251bmxvYWQnKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAge1xuICAgICAgbmFtZTogJ2NvbnRlbnQnLFxuICAgICAgcHJlU2V0OiBmdW5jdGlvbihvLCBuKSB7XG4gICAgICAgIC8vIFByZXZlbnQgc2V0dGluZyB0byAndGhpcycsIHdoaWNoIHdvdWxkbid0IGNoYW5nZSB0aGUgYmVoYXZpb3VyLlxuICAgICAgICByZXR1cm4gbiA9PT0gdGhpcyA/IG51bGwgOiBuIDtcbiAgICAgIH1cbiAgICB9LFxuICAgIHtcbiAgICAgIG5hbWU6ICdwYXJlbnROb2RlJyxcbiAgICAgIHRyYW5zaWVudDogdHJ1ZVxuICAgIH0sXG4gICAge1xuICAgICAgY2xhc3M6ICdCb29sZWFuJyxcbiAgICAgIG5hbWU6ICdzaG93bicsXG4gICAgICB2YWx1ZTogdHJ1ZSxcbiAgICAgIHBvc3RTZXQ6IGZ1bmN0aW9uKG8sIG4pIHtcbiAgICAgICAgaWYgKCBvID09PSBuICkgcmV0dXJuO1xuICAgICAgICBpZiAoIG4gKSB7XG4gICAgICAgICAgdGhpcy5yZW1vdmVDbGFzcygnZm9hbS11Mi1FbGVtZW50LWhpZGRlbicpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuYWRkQ2xhc3MoJ2ZvYW0tdTItRWxlbWVudC1oaWRkZW4nKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAge1xuICAgICAgY2xhc3M6ICdQcm94eScsXG4gICAgICBvZjogJ2ZvYW0udTIuRGVmYXVsdFZhbGlkYXRvcicsXG4gICAgICBuYW1lOiAndmFsaWRhdG9yJyxcbiAgICAgIHRvcGljczogW10sXG4gICAgICBmYWN0b3J5OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZWxlbWVudFZhbGlkYXRvciQgPyB0aGlzLmVsZW1lbnRWYWxpZGF0b3IgOiB0aGlzLkRFRkFVTFRfVkFMSURBVE9SO1xuICAgICAgfVxuICAgIH0sXG4gICAge1xuICAgICAgbmFtZTogJ25vZGVOYW1lJyxcbiAgICAgIGFkYXB0OiBmdW5jdGlvbihfLCB2KSB7XG4gICAgICAgIC8vIENvbnZlcnQgdG8gdXBwZXJjYXNlIHNvIHRoYXQgY2hlY2tzIGFnYWluc3QgT1BUSU9OQUxfQ0xPU0VfVEFHU1xuICAgICAgICAvLyBhbmQgSUxMRUdBTF9DTE9TRV9UQUdTIHdvcmsuXG4gICAgICAgIHJldHVybiBmb2FtLlN0cmluZy50b1VwcGVyQ2FzZSh2KTtcbiAgICAgIH0sXG4gICAgICB2YWx1ZTogJ0RJVidcbiAgICB9LFxuICAgIHtcbiAgICAgIG5hbWU6ICdhdHRyaWJ1dGVNYXAnLFxuICAgICAgZG9jdW1lbnRhdGlvbjogJ1NhbWUgaW5mb3JtYXRpb24gYXMgXCJhdHRyaWJ1dGVzXCIsIGJ1dCBpbiBtYXAgZm9ybSBmb3IgZmFzdGVyIGxvb2t1cCcsXG4gICAgICB0cmFuc2llbnQ6IHRydWUsXG4gICAgICBmYWN0b3J5OiBmdW5jdGlvbigpIHsgcmV0dXJuIHt9OyB9XG4gICAgfSxcbiAgICB7XG4gICAgICBuYW1lOiAnYXR0cmlidXRlcycsXG4gICAgICBkb2N1bWVudGF0aW9uOiAnQXJyYXkgb2Yge25hbWU6IC4uLiwgdmFsdWU6IC4uLn0gYXR0cmlidXRlcy4nLFxuICAgICAgZmFjdG9yeTogZnVuY3Rpb24oKSB7IHJldHVybiBbXTsgfSxcbiAgICAgIHBvc3RTZXQ6IGZ1bmN0aW9uKF8sIGF0dHJzKSB7XG4gICAgICAgIHRoaXMuYXR0cmlidXRlTWFwID0ge307XG4gICAgICAgIGZvciAoIHZhciBpID0gMCA7IGkgPCBhdHRycy5sZW5ndGggOyBpKysgKSB7XG4gICAgICAgICAgdGhpcy5hdHRyaWJ1dGVNYXBbYXR0cnNbaV0ubmFtZV0gPSBhdHRyc1tpXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAge1xuICAgICAgbmFtZTogJ2NsYXNzZXMnLFxuICAgICAgZG9jdW1lbnRhdGlvbjogJ0NTUyBjbGFzc2VzIGFzc2lnbmVkIHRvIHRoaXMgRWxlbWVudC4gU3RvcmVkIGFzIGEgbWFwIG9mIHRydWUgdmFsdWVzLicsXG4gICAgICBmYWN0b3J5OiBmdW5jdGlvbigpIHsgcmV0dXJuIHt9OyB9XG4gICAgfSxcbiAgICB7XG4gICAgICBuYW1lOiAnY3NzJyxcbiAgICAgIGRvY3VtZW50YXRpb246ICdTdHlsZXMgYWRkZWQgdG8gdGhpcyBFbGVtZW50LicsXG4gICAgICBmYWN0b3J5OiBmdW5jdGlvbigpIHsgcmV0dXJuIHt9OyB9XG4gICAgfSxcbiAgICB7XG4gICAgICBuYW1lOiAnY2hpbGROb2RlcycsXG4gICAgICBkb2N1bWVudGF0aW9uOiAnQ2hpbGRyZW4gb2YgdGhpcyBFbGVtZW50LicsXG4gICAgICBmYWN0b3J5OiBmdW5jdGlvbigpIHsgcmV0dXJuIFtdOyB9XG4gICAgfSxcbiAgICB7XG4gICAgICBuYW1lOiAnZWxMaXN0ZW5lcnMnLFxuICAgICAgZG9jdW1lbnRhdGlvbjogJ0RPTSBsaXN0ZW5lcnMgb2YgdGhpcyBFbGVtZW50LiBTdG9yZWQgYXMgdG9waWMgdGhlbiBsaXN0ZW5lci4nLFxuICAgICAgZmFjdG9yeTogZnVuY3Rpb24oKSB7IHJldHVybiBbXTsgfVxuICAgIH0sXG4gICAge1xuICAgICAgbmFtZTogJ2NoaWxkcmVuJyxcbiAgICAgIGRvY3VtZW50YXRpb246ICdWaXJ0dWFsIHByb3BlcnR5IG9mIG5vbi1TdHJpbmcgY2hpbGROb2Rlcy4nLFxuICAgICAgdHJhbnNpZW50OiB0cnVlLFxuICAgICAgZ2V0dGVyOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2hpbGROb2Rlcy5maWx0ZXIoZnVuY3Rpb24oYykge1xuICAgICAgICAgIHJldHVybiB0eXBlb2YgYyAhPT0gJ3N0cmluZyc7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0sXG4gICAge1xuICAgICAgY2xhc3M6ICdCb29sZWFuJyxcbiAgICAgIG5hbWU6ICdmb2N1c2VkJ1xuICAgIH0sXG4gICAge1xuICAgICAgbmFtZTogJ291dGVySFRNTCcsXG4gICAgICB0cmFuc2llbnQ6IHRydWUsXG4gICAgICBoaWRkZW46IHRydWUsXG4gICAgICBnZXR0ZXI6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5vdXRwdXQodGhpcy5jcmVhdGVPdXRwdXRTdHJlYW0oKSkudG9TdHJpbmcoKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHtcbiAgICAgIG5hbWU6ICdpbm5lckhUTUwnLFxuICAgICAgdHJhbnNpZW50OiB0cnVlLFxuICAgICAgaGlkZGVuOiB0cnVlLFxuICAgICAgZ2V0dGVyOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3V0cHV0SW5uZXJIVE1MKHRoaXMuY3JlYXRlT3V0cHV0U3RyZWFtKCkpLnRvU3RyaW5nKCk7XG4gICAgICB9XG4gICAgfSxcbiAgICB7XG4gICAgICBuYW1lOiAnc2Nyb2xsSGVpZ2h0JyxcbiAgICB9LFxuICAgIHtcbiAgICAgIGNsYXNzOiAnSW50JyxcbiAgICAgIG5hbWU6ICd0YWJJbmRleCcsXG4gICAgfSxcbiAgICB7XG4gICAgICBuYW1lOiAnY2xpY2tUYXJnZXRfJ1xuICAgIH0sXG4gICAge1xuICAgICAgbmFtZTogJ19fc3ViU3ViQ29udGV4dF9fJyxcbiAgICAgIGZhY3Rvcnk6IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcy5fX3N1YkNvbnRleHRfXzsgfVxuICAgIH0sXG4gICAgJ2tleU1hcF8nXG4gIF0sXG5cbiAgbWV0aG9kczogW1xuICAgIGZ1bmN0aW9uIGluaXQoKSB7XG4gICAgICB0aGlzLm9uRGV0YWNoKHRoaXMudmlzaXRDaGlsZHJlbi5iaW5kKHRoaXMsICdkZXRhY2gnKSk7XG4gICAgfSxcblxuICAgIGZ1bmN0aW9uIGluaXRFKCkge1xuICAgICAgLypcbiAgICAgICAgVGVtcGxhdGUgbWV0aG9kIGZvciBhZGRpbmcgYWRkdGlvbiBlbGVtZW50IGluaXRpYWxpemF0aW9uXG4gICAgICAgIGp1c3QgYmVmb3JlIEVsZW1lbnQgaXMgb3V0cHV0KCkuXG4gICAgICAqL1xuICAgICAgdGhpcy5pbml0S2V5Ym9hcmRTaG9ydGN1dHMoKTtcbiAgICB9LFxuXG4gICAgZnVuY3Rpb24gb2JzZXJ2ZVNjcm9sbEhlaWdodCgpIHtcbiAgICAgIC8vIFRPRE86IFRoaXMgc2hvdWxkIGJlIGhhbmRsZWQgYnkgYW4gb25zdWIgZXZlbnQgd2hlbiBzb21lb25lIHN1YnNjcmliZXMgdG9cbiAgICAgIC8vIHNjcm9sbCBoZWlnaHQgY2hhbmdlcy5cbiAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgIHZhciBvYnNlcnZlciA9IG5ldyBNdXRhdGlvbk9ic2VydmVyKGZ1bmN0aW9uKG11dGF0aW9ucykge1xuICAgICAgICBzZWxmLnNjcm9sbEhlaWdodCA9IHNlbGYuZWwoKS5zY3JvbGxIZWlnaHQ7XG4gICAgICB9KTtcbiAgICAgIHZhciBjb25maWcgPSB7IGF0dHJpYnV0ZXM6IHRydWUsIGNoaWxkTGlzdDogdHJ1ZSwgY2hhcmFjdGVyRGF0YTogdHJ1ZSB9O1xuXG4gICAgICB0aGlzLm9ubG9hZC5zdWIoZnVuY3Rpb24ocykge1xuICAgICAgICBvYnNlcnZlci5vYnNlcnZlKHNlbGYuZWwoKSwgY29uZmlnKTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5vbnVubG9hZC5zdWIoZnVuY3Rpb24ocykge1xuICAgICAgICBvYnNlcnZlci5kaXNjb25uZWN0KClcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIGZ1bmN0aW9uIGV2dFRvQ2hhckNvZGUoZXZ0KSB7XG4gICAgICAvKiBNYXBzIGFuIGV2ZW50IGtleWNvZGUgdG8gYSBzdHJpbmcgKi9cbiAgICAgIHZhciBzID0gJyc7XG4gICAgICBpZiAoIGV2dC5hbHRLZXkgICApIHMgKz0gJ2FsdC0nO1xuICAgICAgaWYgKCBldnQuY3RybEtleSAgKSBzICs9ICdjdHJsLSc7XG4gICAgICBpZiAoIGV2dC5zaGlmdEtleSAmJiBldnQudHlwZSA9PT0gJ2tleWRvd24nICkgcyArPSAnc2hpZnQtJztcbiAgICAgIGlmICggZXZ0Lm1ldGFLZXkgICkgcyArPSAnbWV0YS0nO1xuICAgICAgcyArPSBldnQudHlwZSA9PT0gJ2tleWRvd24nID9cbiAgICAgICAgICB0aGlzLk5BTUVEX0NPREVTW2V2dC53aGljaF0gfHwgU3RyaW5nLmZyb21DaGFyQ29kZShldnQud2hpY2gpIDpcbiAgICAgICAgICBTdHJpbmcuZnJvbUNoYXJDb2RlKGV2dC5jaGFyQ29kZSk7XG4gICAgICByZXR1cm4gcztcbiAgICB9LFxuXG4gICAgZnVuY3Rpb24gaW5pdEtleU1hcF8oa2V5TWFwLCBjbHMpIHtcbiAgICAgIHZhciBjb3VudCA9IDA7XG5cbiAgICAgIHZhciBhcyA9IGNscy5nZXRBeGlvbXNCeUNsYXNzKGZvYW0uY29yZS5BY3Rpb24pO1xuXG4gICAgICBmb3IgKCB2YXIgaSA9IDAgOyBpIDwgYXMubGVuZ3RoIDsgaSsrICkge1xuICAgICAgICB2YXIgYSA9IGFzW2ldO1xuXG4gICAgICAgIGZvciAoIHZhciBqID0gMCA7IGEua2V5Ym9hcmRTaG9ydGN1dHMgJiYgaiA8IGEua2V5Ym9hcmRTaG9ydGN1dHMubGVuZ3RoIDsgaisrLCBjb3VudCsrICkge1xuICAgICAgICAgIHZhciBrZXkgPSBhLmtleWJvYXJkU2hvcnRjdXRzW2pdO1xuXG4gICAgICAgICAgLy8gRmlyc3QsIGxvb2t1cCBuYW1lZCBjb2RlcywgdGhlbiBjb252ZXJ0IG51bWJlcnMgdG8gY2hhciBjb2RlcyxcbiAgICAgICAgICAvLyBvdGhlcndpc2UsIGFzc3VtZSB3ZSBoYXZlIGEgc2luZ2xlIGNoYXJhY3RlciBzdHJpbmcgdHJlYXRlZCBhc1xuICAgICAgICAgIC8vIGEgY2hhcmFjdGVyIHRvIGJlIHJlY29nbml6ZWQuXG4gICAgICAgICAgaWYgKCB0aGlzLk5BTUVEX0NPREVTW2tleV0gKSB7XG4gICAgICAgICAgICBrZXkgPSB0aGlzLk5BTUVEX0NPREVTW2tleV07XG4gICAgICAgICAgfSBlbHNlIGlmICggdHlwZW9mIGtleSA9PT0gJ251bWJlcicgKSB7XG4gICAgICAgICAgICBrZXkgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGtleSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAga2V5TWFwW2tleV0gPSBhLm1heWJlQ2FsbC5iaW5kKGEsIHRoaXMuX19zdWJDb250ZXh0X18sIHRoaXMpO1xuICAgICAgICAgIC8qXG4gICAgICAgICAga2V5TWFwW2tleV0gPSBvcHRfdmFsdWUgP1xuICAgICAgICAgICAgZnVuY3Rpb24oKSB7IGEubWF5YmVDYWxsKHRoaXMuX19zdWJDb250ZXh0X18sIG9wdF92YWx1ZS5nZXQoKSk7IH0gOlxuICAgICAgICAgICAgYS5tYXliZUNhbGwuYmluZChhY3Rpb24sIHNlbGYuWCwgc2VsZikgO1xuICAgICAgICAgICovXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGNvdW50O1xuICAgIH0sXG5cbiAgICBmdW5jdGlvbiBpbml0S2V5Ym9hcmRTaG9ydGN1dHMoKSB7XG4gICAgICAvKiBJbml0aWFsaXplcyBrZXlib2FyZCBzaG9ydGN1dHMuICovXG4gICAgICB2YXIga2V5TWFwID0ge31cbiAgICAgIHZhciBjb3VudCA9IHRoaXMuaW5pdEtleU1hcF8oa2V5TWFwLCB0aGlzLmNsc18pO1xuXG4gICAgICAvLyAgICAgIGlmICggdGhpcy5vZiApIGNvdW50ICs9IHRoaXMuaW5pdEtleU1hcF8oa2V5TWFwLCB0aGlzLm9mKTtcblxuICAgICAgaWYgKCBjb3VudCApIHtcbiAgICAgICAgdGhpcy5rZXlNYXBfID0ga2V5TWFwO1xuICAgICAgICB2YXIgdGFyZ2V0ID0gdGhpcy5wYXJlbnROb2RlIHx8IHRoaXM7XG5cbiAgICAgICAgLy8gRW5zdXJlIHRoYXQgdGFyZ2V0IGlzIGZvY3VzYWJsZSwgYW5kIHRoZXJlZm9yZSB3aWxsIGNhcHR1cmUga2V5ZG93blxuICAgICAgICAvLyBhbmQga2V5cHJlc3MgZXZlbnRzLlxuICAgICAgICB0YXJnZXQudGFiSW5kZXggPSB0YXJnZXQudGFiSW5kZXggfHwgMTtcblxuICAgICAgICB0YXJnZXQub24oJ2tleWRvd24nLCAgdGhpcy5vbktleWJvYXJkU2hvcnRjdXQpO1xuICAgICAgICB0YXJnZXQub24oJ2tleXByZXNzJywgdGhpcy5vbktleWJvYXJkU2hvcnRjdXQpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBmdW5jdGlvbiBlbCgpIHtcbiAgICAgIC8qIFJldHVybiB0aGlzIEVsZW1lbnQncyByZWFsIERPTSBlbGVtZW50LCBpZiBsb2FkZWQuICovXG4gICAgICByZXR1cm4gdGhpcy5nZXRFbGVtZW50QnlJZCh0aGlzLmlkKTtcbiAgICB9LFxuXG4gICAgZnVuY3Rpb24gZmluZENoaWxkRm9yRXZlbnQoZSkge1xuICAgICAgdmFyIHNyYyAgPSBlLnNyY0VsZW1lbnQ7XG4gICAgICB2YXIgZWwgICA9IHRoaXMuZWwoKTtcbiAgICAgIHZhciBjTWFwID0ge307XG4gICAgICB2YXIgY3MgICA9IHRoaXMuY2hpbGRyZW47XG5cbiAgICAgIGlmICggISBlbCApIHJldHVybjtcblxuICAgICAgZm9yICggdmFyIGkgPSAwIDsgaSA8IGNzLmxlbmd0aCA7IGkrKyApIHtcbiAgICAgICAgdmFyIGMgPSBjc1tpXTtcbiAgICAgICAgY01hcFtjLmlkXSA9IGM7XG4gICAgICB9XG5cbiAgICAgIHdoaWxlICggc3JjICE9PSBlbCApIHtcbiAgICAgICAgdmFyIGMgPSBjTWFwW3NyYy5pZF07XG4gICAgICAgIGlmICggYyApIHJldHVybiBjO1xuICAgICAgICBzcmMgPSBzcmMucGFyZW50RWxlbWVudDtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgZnVuY3Rpb24gRShvcHRfbm9kZU5hbWUpIHtcbiAgICAgIHJldHVybiB0aGlzLl9fc3ViU3ViQ29udGV4dF9fLkUob3B0X25vZGVOYW1lKTtcbiAgICB9LFxuXG4gICAgZnVuY3Rpb24gYXR0clNsb3Qob3B0X25hbWUsIG9wdF9ldmVudCkge1xuICAgICAgLyogQ29udmVuaWVuY2UgbWV0aG9kIGZvciBjcmVhdGluZyBhbiBBdHRyU2xvdCdzLiAqL1xuICAgICAgdmFyIGFyZ3MgPSB7IGVsZW1lbnQ6IHRoaXMgfTtcblxuICAgICAgaWYgKCBvcHRfbmFtZSAgKSBhcmdzLnByb3BlcnR5ID0gb3B0X25hbWU7XG4gICAgICBpZiAoIG9wdF9ldmVudCApIGFyZ3MuZXZlbnQgICAgPSBvcHRfZXZlbnQ7XG5cbiAgICAgIHJldHVybiB0aGlzLkF0dHJTbG90LmNyZWF0ZShhcmdzKTtcbiAgICB9LFxuXG4gICAgZnVuY3Rpb24gbXlDbHMob3B0X2V4dHJhKSB7XG4gICAgICBjb25zb2xlLndhcm4oJ0RlcHJlY2F0ZWQgdXNlIG9mIEVsZW1lbnQubXlDbHMoKS4gVXNlIG15Q2xhc3MoKSBpbnN0ZWFkLicpO1xuICAgICAgcmV0dXJuIHRoaXMubXlDbGFzcyhvcHRfZXh0cmEpO1xuICAgIH0sXG5cbiAgICBmdW5jdGlvbiBteUNsYXNzKG9wdF9leHRyYSkge1xuICAgICAgLy8gVXNlIGhhc093blByb3BlcnR5IHNvIHRoYXQgY2xhc3MgZG9lc24ndCBpbmhlcml0IENTUyBjbGFzc25hbWVcbiAgICAgIC8vIGZyb20gYW5jZXN0b3IgRk9BTSBjbGFzcy5cbiAgICAgIHZhciBmID0gdGhpcy5jbHNfLmhhc093blByb3BlcnR5KCdteUNsYXNzXycpICYmIHRoaXMuY2xzXy5teUNsYXNzXztcblxuICAgICAgaWYgKCAhIGYgKSB7XG4gICAgICAgIHZhciBiYXNlID0gdGhpcy5jbHNfLmhhc093blByb3BlcnR5KCdDU1NfQ0xBU1MnKSA/XG4gICAgICAgICAgdGhpcy5jbHNfLkNTU19DTEFTUy5zcGxpdCgvICsvKSA6XG4gICAgICAgICAgZm9hbS5TdHJpbmcuY3NzQ2xhc3NpemUodGhpcy5jbHNfLmlkKS5zcGxpdCgvICsvKSA7XG5cbiAgICAgICAgZiA9IHRoaXMuY2xzXy5teUNsYXNzXyA9IGZvYW0uRnVuY3Rpb24ubWVtb2l6ZTEoZnVuY3Rpb24oZSkge1xuICAgICAgICAgIHJldHVybiBiYXNlLm1hcChmdW5jdGlvbihjKSB7IHJldHVybiBjICsgKGUgPyAnLScgKyBlIDogJycpOyB9KS5qb2luKCcgJyk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZihvcHRfZXh0cmEpO1xuICAgIH0sXG5cbiAgICBmdW5jdGlvbiB2aXNpdENoaWxkcmVuKG1ldGhvZE5hbWUpIHtcbiAgICAgIC8qXG4gICAgICAgIENhbGwgdGhlIG5hbWVkIG1ldGhvZCBvbiBhbGwgY2hpbGRyZW4uXG4gICAgICAgIFR5cGljYWxseSB1c2VkIHRvIHRyYW5zaXRpb24gc3RhdGUgb2YgYWxsIGNoaWxkcmVuIGF0IG9uY2UuXG4gICAgICAgIEV4LjogdGhpcy52aXNpdENoaWxkcmVuKCdsb2FkJyk7XG4gICAgICAqL1xuICAgICAgdmFyIGNzID0gdGhpcy5jaGlsZE5vZGVzO1xuICAgICAgZm9yICggdmFyIGkgPSAwIDsgaSA8IGNzLmxlbmd0aCA7IGkrKyApIHtcbiAgICAgICAgdmFyIGMgPSBjc1tpXTtcbiAgICAgICAgY1ttZXRob2ROYW1lXSAmJiBjW21ldGhvZE5hbWVdLmNhbGwoYyk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIGZ1bmN0aW9uIGZvY3VzKCkge1xuICAgICAgdGhpcy5mb2N1c2VkID0gdHJ1ZTtcbiAgICAgIHRoaXMub25Gb2N1cygpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIGZ1bmN0aW9uIGJsdXIoKSB7XG4gICAgICB0aGlzLmZvY3VzZWQgPSBmYWxzZTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBmdW5jdGlvbiBzaG93KG9wdF9zaG93bikge1xuICAgICAgaWYgKCBvcHRfc2hvd24gPT09IHVuZGVmaW5lZCApIHtcbiAgICAgICAgdGhpcy5zaG93biA9IHRydWU7XG4gICAgICB9IGVsc2UgaWYgKCBmb2FtLmNvcmUuU2xvdC5pc0luc3RhbmNlKG9wdF9zaG93bikgKSB7XG4gICAgICAgIHRoaXMuc2hvd24kLmZvbGxvdyhvcHRfc2hvd24pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5zaG93biA9ICEhIG9wdF9zaG93bjtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIGZ1bmN0aW9uIGhpZGUob3B0X2hpZGRlbikge1xuICAgICAgcmV0dXJuIHRoaXMuc2hvdyhcbiAgICAgICAgICBvcHRfaGlkZGVuID09PSB1bmRlZmluZWQgICAgICAgICAgICAgID8gZmFsc2UgOlxuICAgICAgICAgIGZvYW0uY29yZS5TbG90LmlzSW5zdGFuY2Uob3B0X2hpZGRlbikgPyBvcHRfaGlkZGVuLm1hcChmdW5jdGlvbihzKSB7IHJldHVybiAhIHM7IH0pIDpcbiAgICAgICAgICAhIG9wdF9oaWRkZW4pO1xuICAgIH0sXG5cbiAgICBmdW5jdGlvbiBzZXRBdHRyaWJ1dGUobmFtZSwgdmFsdWUpIHtcbiAgICAgIC8qXG4gICAgICAgIFNldCBhbiBFbGVtZW50IGF0dHJpYnV0ZSBvciBwcm9wZXJ0eS5cblxuICAgICAgICBJZiB0aGlzIG1vZGVsIGhhcyBhIHByb3BlcnR5IG5hbWVkICduYW1lJyB3aGljaCBoYXMgJ2F0dHJpYnV0ZTogdHJ1ZScsXG4gICAgICAgIHRoZW4gdGhlIHByb3BlcnR5IHdpbGwgYmUgdXBkYXRlZCB3aXRoIHZhbHVlLlxuICAgICAgICBPdGhlcndpc2UsIHRoZSBET00gYXR0cmlidXRlIHdpbGwgYmUgc2V0LlxuXG4gICAgICAgIFZhbHVlIGNhbiBiZSBlaXRoZXIgYSBzdHJpbmcsIGEgVmFsdWUsIG9yIGFuIE9iamVjdC5cbiAgICAgICAgSWYgVmFsdWUgaXMgdW5kZWZpbmVkLCBudWxsIG9yIGZhbHNlLCB0aGUgYXR0cmlidXRlIHdpbGwgYmUgcmVtb3ZlZC5cbiAgICAgICovXG5cbiAgICAgIC8vIFRPRE86IHR5cGUgY2hlY2tpbmdcblxuICAgICAgaWYgKCBuYW1lID09PSAndGFiaW5kZXgnICkgdGhpcy50YWJJbmRleCA9IHBhcnNlSW50KHZhbHVlKTtcblxuICAgICAgLy8gaGFuZGxlIHNsb3QgYmluZGluZywgZXguOiBkYXRhJDogLi4uLFxuICAgICAgLy8gUmVtb3ZlIGlmIHdlIGFkZCBhIHByb3BzKCkgbWV0aG9kXG4gICAgICBpZiAoIG5hbWUuZW5kc1dpdGgoJyQnKSApIHtcbiAgICAgICAgdGhpc1tuYW1lXSA9IHZhbHVlO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBwcm9wID0gdGhpcy5jbHNfLmdldEF4aW9tQnlOYW1lKG5hbWUpO1xuXG4gICAgICBpZiAoIHByb3AgJiZcbiAgICAgICAgICAgZm9hbS5jb3JlLlByb3BlcnR5LmlzSW5zdGFuY2UocHJvcCkgJiZcbiAgICAgICAgICAgcHJvcC5hdHRyaWJ1dGUgKVxuICAgICAge1xuICAgICAgICBpZiAoIHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgKSB7XG4gICAgICAgICAgLy8gVE9ETzogcmVtb3ZlIGNoZWNrIHdoZW4gYWxsIHByb3BlcnRpZXMgaGF2ZSBmcm9tU3RyaW5nKClcbiAgICAgICAgICB0aGlzW25hbWVdID0gcHJvcC5mcm9tU3RyaW5nID8gcHJvcC5mcm9tU3RyaW5nKHZhbHVlKSA6IHZhbHVlO1xuICAgICAgICB9IGVsc2UgaWYgKCBmb2FtLmNvcmUuU2xvdC5pc0luc3RhbmNlKHZhbHVlKSApIHtcbiAgICAgICAgICB0aGlzLnNsb3QobmFtZSkuZm9sbG93KHZhbHVlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzW25hbWVdID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICggdmFsdWUgPT09IHVuZGVmaW5lZCB8fCB2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gZmFsc2UgKSB7XG4gICAgICAgICAgdGhpcy5yZW1vdmVBdHRyaWJ1dGUobmFtZSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCBmb2FtLmNvcmUuU2xvdC5pc0luc3RhbmNlKHZhbHVlKSApIHtcbiAgICAgICAgICB0aGlzLnNsb3RBdHRyXyhuYW1lLCB2YWx1ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZm9hbS5hc3NlcnQoXG4gICAgICAgICAgICAgIHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyB8fCB0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJyB8fCBmb2FtLkRhdGUuaXNJbnN0YW5jZSh2YWx1ZSksXG4gICAgICAgICAgICAgICdBdHRyaWJ1dGUgdmFsdWUgbXVzdCBiZSBhIHByaW1pdGl2ZSB0eXBlLicpO1xuXG4gICAgICAgICAgdmFyIGF0dHIgPSB0aGlzLmdldEF0dHJpYnV0ZU5vZGUobmFtZSk7XG5cbiAgICAgICAgICBpZiAoIGF0dHIgKSB7XG4gICAgICAgICAgICBhdHRyLnZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGF0dHIgPSB7IG5hbWU6IG5hbWUsIHZhbHVlOiB2YWx1ZSB9O1xuICAgICAgICAgICAgdGhpcy5hdHRyaWJ1dGVzLnB1c2goYXR0cik7XG4gICAgICAgICAgICB0aGlzLmF0dHJpYnV0ZU1hcFtuYW1lXSA9IGF0dHI7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGhpcy5vblNldEF0dHIobmFtZSwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIGZ1bmN0aW9uIHJlbW92ZUF0dHJpYnV0ZShuYW1lKSB7XG4gICAgICAvKiBSZW1vdmUgYXR0cmlidXRlIG5hbWVkICduYW1lJy4gKi9cbiAgICAgIGZvciAoIHZhciBpID0gMCA7IGkgPCB0aGlzLmF0dHJpYnV0ZXMubGVuZ3RoIDsgaSsrICkge1xuICAgICAgICBpZiAoIHRoaXMuYXR0cmlidXRlc1tpXS5uYW1lID09PSBuYW1lICkge1xuICAgICAgICAgIHRoaXMuYXR0cmlidXRlcy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgZGVsZXRlIHRoaXMuYXR0cmlidXRlTWFwW25hbWVdO1xuICAgICAgICAgIHRoaXMub25SZW1vdmVBdHRyKG5hbWUpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBmdW5jdGlvbiBnZXRBdHRyaWJ1dGVOb2RlKG5hbWUpIHtcbiAgICAgIC8qXG4gICAgICAgIEdldCB7bmFtZTogLi4uLCB2YWx1ZTogLi4ufSBhdHRyaWJ1dGVOb2RlIGFzc29jaWF0ZWRcbiAgICAgICAgd2l0aCAnbmFtZScsIGlmIGV4aXN0cy5cbiAgICAgICovXG4gICAgICByZXR1cm4gdGhpcy5hdHRyaWJ1dGVNYXBbbmFtZV07XG4gICAgfSxcblxuICAgIGZ1bmN0aW9uIGdldEF0dHJpYnV0ZShuYW1lKSB7XG4gICAgICAvLyBUT0RPOiBhZGQgc3VwcG9ydCBmb3Igb3RoZXIgZHluYW1pYyBhdHRyaWJ1dGVzIGFsc29cbiAgICAgIC8vIFRPRE86IGRvbid0IGxvb2t1cCBpbiByZWFsIERPTSBpZiBsaXN0ZW5lciBwcmVzZW50XG4gICAgICBpZiAoIHRoaXMuUFNFRE9fQVRUUklCVVRFU1tuYW1lXSAmJiB0aGlzLmVsKCkgKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IHRoaXMuZWwoKVtuYW1lXTtcbiAgICAgICAgdmFyIGF0dHIgID0gdGhpcy5nZXRBdHRyaWJ1dGVOb2RlKG5hbWUpO1xuXG4gICAgICAgIGlmICggYXR0ciApIHtcbiAgICAgICAgICBhdHRyW25hbWVdID0gdmFsdWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYXR0ciA9IHsgbmFtZTogbmFtZSwgdmFsdWU6IHZhbHVlIH07XG4gICAgICAgICAgdGhpcy5hdHRyaWJ1dGVzLnB1c2goYXR0cik7XG4gICAgICAgICAgdGhpcy5hdHRyaWJ1dGVNYXBbbmFtZV0gPSBhdHRyO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfVxuXG4gICAgICAvKlxuICAgICAgICBHZXQgdmFsdWUgYXNzb2NpYXRlZCB3aXRoIGF0dHJpYnV0ZSAnbmFtZScsXG4gICAgICAgIG9yIHVuZGVmaW5lZCBpZiBhdHRyaWJ1dGUgbm90IHNldC5cbiAgICAgICovXG4gICAgICB2YXIgYXR0ciA9IHRoaXMuZ2V0QXR0cmlidXRlTm9kZShuYW1lKTtcbiAgICAgIHJldHVybiBhdHRyICYmIGF0dHIudmFsdWU7XG4gICAgfSxcblxuICAgIGZ1bmN0aW9uIGFwcGVuZENoaWxkKGMpIHtcbiAgICAgIC8vIFRPRE86IGZpbmlzaCBpbXBsZW1lbnRhdGlvblxuICAgICAgdGhpcy5jaGlsZE5vZGVzLnB1c2goYyk7XG4gICAgfSxcblxuICAgIGZ1bmN0aW9uIHJlbW92ZUNoaWxkKGMpIHtcbiAgICAgIC8qIFJlbW92ZSBhIENoaWxkIG5vZGUgKFN0cmluZyBvciBFbGVtZW50KS4gKi9cbiAgICAgIHZhciBjcyA9IHRoaXMuY2hpbGROb2RlcztcbiAgICAgIGZvciAoIHZhciBpID0gMCA7IGkgPCBjcy5sZW5ndGggOyArK2kgKSB7XG4gICAgICAgIGlmICggY3NbaV0gPT09IGMgKSB7XG4gICAgICAgICAgY3Muc3BsaWNlKGksIDEpO1xuICAgICAgICAgIHRoaXMuc3RhdGUub25SZW1vdmVDaGlsZC5jYWxsKHRoaXMsIGMsIGkpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBmdW5jdGlvbiByZXBsYWNlQ2hpbGQobmV3RSwgb2xkRSkge1xuICAgICAgLyogUmVwbGFjZSBjdXJyZW50IGNoaWxkIG9sZEUgd2l0aCBuZXdFLiAqL1xuICAgICAgdmFyIGNzID0gdGhpcy5jaGlsZE5vZGVzO1xuICAgICAgZm9yICggdmFyIGkgPSAwIDsgaSA8IGNzLmxlbmd0aCA7ICsraSApIHtcbiAgICAgICAgaWYgKCBjc1tpXSA9PT0gb2xkRSApIHtcbiAgICAgICAgICBjc1tpXSA9IG5ld0U7XG4gICAgICAgICAgbmV3RS5wYXJlbnROb2RlID0gdGhpcztcbiAgICAgICAgICB0aGlzLnN0YXRlLm9uUmVwbGFjZUNoaWxkLmNhbGwodGhpcywgb2xkRSwgbmV3RSk7XG4gICAgICAgICAgb2xkRS51bmxvYWQgJiYgb2xkRS51bmxvYWQoKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgZnVuY3Rpb24gaW5zZXJ0QmVmb3JlKGNoaWxkLCByZWZlcmVuY2UpIHtcbiAgICAgIC8qIEluc2VydCBhIHNpbmdsZSBjaGlsZCBiZWZvcmUgdGhlIHJlZmVyZW5jZSBlbGVtZW50LiAqL1xuICAgICAgcmV0dXJuIHRoaXMuaW5zZXJ0QXRfKGNoaWxkLCByZWZlcmVuY2UsIHRydWUpO1xuICAgIH0sXG5cbiAgICBmdW5jdGlvbiBpbnNlcnRBZnRlcihjaGlsZCwgcmVmZXJlbmNlKSB7XG4gICAgICAvKiBJbnNlcnQgYSBzaW5nbGUgY2hpbGQgYWZ0ZXIgdGhlIHJlZmVyZW5jZSBlbGVtZW50LiAqL1xuICAgICAgcmV0dXJuIHRoaXMuaW5zZXJ0QXRfKGNoaWxkLCByZWZlcmVuY2UsIGZhbHNlKTtcbiAgICB9LFxuXG4gICAgZnVuY3Rpb24gcmVtb3ZlKCkge1xuICAgICAgLypcbiAgICAgICAgUmVtb3ZlIHRoaXMgRWxlbWVudCBmcm9tIGl0cyBwYXJlbnQgRWxlbWVudC5cbiAgICAgICAgV2lsbCB0cmFuc2l0aW9uIHRvIFVOTE9BREVEIHN0YXRlLlxuICAgICAgKi9cbiAgICAgIHRoaXMub25SZW1vdmUoKTtcblxuICAgICAgaWYgKCB0aGlzLnBhcmVudE5vZGUgKSB7XG4gICAgICAgIHZhciBjcyA9IHRoaXMucGFyZW50Tm9kZS5jaGlsZE5vZGVzO1xuICAgICAgICBmb3IgKCB2YXIgaSA9IDAgOyBpIDwgY3MubGVuZ3RoIDsgaSsrICkge1xuICAgICAgICAgIGlmICggY3NbaV0gPT09IHRoaXMgKSB7XG4gICAgICAgICAgICBjcy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMucGFyZW50Tm9kZSA9IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgZnVuY3Rpb24gYWRkRXZlbnRMaXN0ZW5lcih0b3BpYywgbGlzdGVuZXIpIHtcbiAgICAgIC8qIEFkZCBET00gbGlzdGVuZXIuICovXG4gICAgICB0aGlzLmVsTGlzdGVuZXJzLnB1c2godG9waWMsIGxpc3RlbmVyKTtcbiAgICAgIHRoaXMub25BZGRMaXN0ZW5lcih0b3BpYywgbGlzdGVuZXIpO1xuICAgIH0sXG5cbiAgICBmdW5jdGlvbiByZW1vdmVFdmVudExpc3RlbmVyKHRvcGljLCBsaXN0ZW5lcikge1xuICAgICAgLyogUmVtb3ZlIERPTSBsaXN0ZW5lci4gKi9cbiAgICAgIHZhciBscyA9IHRoaXMuZWxMaXN0ZW5lcnM7XG4gICAgICBmb3IgKCB2YXIgaSA9IDAgOyBpIDwgbHMubGVuZ3RoIDsgaSs9MiApIHtcbiAgICAgICAgdmFyIHQgPSBsc1tpXSwgbCA9IGxzW2krMV07XG4gICAgICAgIGlmICggdCA9PT0gdG9waWMgJiYgbCA9PT0gbGlzdGVuZXIgKSB7XG4gICAgICAgICAgbHMuc3BsaWNlKGksIDIpO1xuICAgICAgICAgIHRoaXMub25SZW1vdmVMaXN0ZW5lcih0b3BpYywgbGlzdGVuZXIpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBmdW5jdGlvbiBzZXROb2RlTmFtZShuYW1lKSB7XG4gICAgICB0aGlzLm5vZGVOYW1lID0gbmFtZTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBmdW5jdGlvbiBzZXRJRChpZCkge1xuICAgICAgLypcbiAgICAgICAgRXhwbGljaXRseSBzZXQgRWxlbWVudCdzIGlkLlxuICAgICAgICBOb3JtYWxseSBpZCdzIGFyZSBhdXRvbWF0aWNhbGx5IGFzc2lnbmVkLlxuICAgICAgICBTZXR0aW5nIHNwZWNpZmljIElEJ3MgaGluZGVycyBjb21wb3NhYmlsaXR5LlxuICAgICAgKi9cbiAgICAgIHRoaXMuaWQgPSBpZDtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBmdW5jdGlvbiBlbnRpdHkobmFtZSkge1xuICAgICAgLyogQ3JlYXRlIGFuZCBhZGQgYSBuYW1lZCBlbnRpdHkuIEV4LiAuZW50aXR5KCdndCcpICovXG4gICAgICB0aGlzLmFkZCh0aGlzLkVudGl0eS5jcmVhdGUoeyBuYW1lOiBuYW1lIH0pKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBmdW5jdGlvbiBuYnNwKCkge1xuICAgICAgcmV0dXJuIHRoaXMuZW50aXR5KCduYnNwJyk7XG4gICAgfSxcblxuICAgIGZ1bmN0aW9uIGNzc0NsYXNzKGNscykge1xuICAgICAgcmV0dXJuIHRoaXMuYWRkQ2xhc3MoY2xzKTtcbiAgICB9LFxuXG4gICAgZnVuY3Rpb24gYWRkQ2xhc3MoY2xzKSB7IC8qIFNsb3QgfCBTdHJpbmcgKi9cbiAgICAgIC8qIEFkZCBhIENTUyBjbHMgdG8gdGhpcyBFbGVtZW50LiAqL1xuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgaWYgKCBmb2FtLmNvcmUuU2xvdC5pc0luc3RhbmNlKGNscykgKSB7XG4gICAgICAgIHZhciBsYXN0VmFsdWUgPSBudWxsO1xuICAgICAgICB2YXIgbCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHZhciB2ID0gY2xzLmdldCgpO1xuICAgICAgICAgIHNlbGYuYWRkQ2xhc3NfKGxhc3RWYWx1ZSwgdik7XG4gICAgICAgICAgbGFzdFZhbHVlID0gdjtcbiAgICAgICAgfTtcbiAgICAgICAgY2xzLnN1YihsKTtcbiAgICAgICAgbCgpO1xuICAgICAgfSBlbHNlIGlmICggdHlwZW9mIGNscyA9PT0gJ3N0cmluZycgKSB7XG4gICAgICAgIHRoaXMuYWRkQ2xhc3NfKG51bGwsIGNscyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmVycm9yKCdjc3NDbGFzcyB0eXBlIGVycm9yLiBNdXN0IGJlIFNsb3Qgb3IgU3RyaW5nLicpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgZnVuY3Rpb24gZW5hYmxlQ2xzKGNscywgZW5hYmxlZCwgb3B0X25lZ2F0ZSkge1xuICAgICAgY29uc29sZS53YXJuKCdEZXByZWNhdGVkIHVzZSBvZiBFbGVtZW50LmVuYWJsZUNscygpLiBVc2UgZW5hYmxlQ2xhc3MoKSBpbnN0ZWFkLicpO1xuICAgICAgcmV0dXJuIHRoaXMuZW5hYmxlQ2xhc3MoY2xzLCBlbmFibGVkLCBvcHRfbmVnYXRlKTtcbiAgICB9LFxuXG4gICAgZnVuY3Rpb24gZW5hYmxlQ2xhc3MoY2xzLCBlbmFibGVkLCBvcHRfbmVnYXRlKSB7XG4gICAgICAvKiBFbmFibGUvZGlzYWJsZSBhIENTUyBjbGFzcyBiYXNlZCBvbiBhIGJvb2xlYW4taXNoIGR5bmFtaWMgdmFsdWUuICovXG4gICAgICBmdW5jdGlvbiBuZWdhdGUoYSwgYikgeyByZXR1cm4gYiA/ICEgYSA6IGE7IH1cblxuICAgICAgLy8gVE9ETzogYWRkIHR5cGUgY2hlY2tpbmdcbiAgICAgIGlmICggZm9hbS5jb3JlLlNsb3QuaXNJbnN0YW5jZShlbmFibGVkKSApIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICB2YXIgdmFsdWUgPSBlbmFibGVkO1xuICAgICAgICB2YXIgbCA9IGZ1bmN0aW9uKCkgeyBzZWxmLmVuYWJsZUNsYXNzKGNscywgdmFsdWUuZ2V0KCksIG9wdF9uZWdhdGUpOyB9O1xuICAgICAgICB2YWx1ZS5zdWIobCk7XG4gICAgICAgIGwoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVuYWJsZWQgPSBuZWdhdGUoZW5hYmxlZCwgb3B0X25lZ2F0ZSk7XG4gICAgICAgIHZhciBwYXJ0cyA9IGNscy5zcGxpdCgnICcpO1xuICAgICAgICBmb3IgKCB2YXIgaSA9IDAgOyBpIDwgcGFydHMubGVuZ3RoIDsgaSsrICkge1xuICAgICAgICAgIHRoaXMuY2xhc3Nlc1twYXJ0c1tpXV0gPSBlbmFibGVkO1xuICAgICAgICAgIHRoaXMub25TZXRDbGFzcyhwYXJ0c1tpXSwgZW5hYmxlZCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBmdW5jdGlvbiByZW1vdmVDbHMoY2xzKSB7XG4gICAgICBjb25zb2xlLndhcm4oJ0RlcHJlY2F0ZWQgdXNlIG9mIEVsZW1lbnQucmVtb3ZlQ2xzKCkuIFVzZSByZW1vdmVDbGFzcygpIGluc3RlYWQuJyk7XG4gICAgICByZXR1cm4gdGhpcy5yZW1vdmVDbGFzcyhjbHMpO1xuICAgIH0sXG5cbiAgICBmdW5jdGlvbiByZW1vdmVDbGFzcyhjbHMpIHtcbiAgICAgIC8qIFJlbW92ZSBzcGVjaWZpZWQgQ1NTIGNsYXNzLiAqL1xuICAgICAgaWYgKCBjbHMgKSB7XG4gICAgICAgIGRlbGV0ZSB0aGlzLmNsYXNzZXNbY2xzXTtcbiAgICAgICAgdGhpcy5vblNldENsYXNzKGNscywgZmFsc2UpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIGZ1bmN0aW9uIG9uKHRvcGljLCBsaXN0ZW5lcikge1xuICAgICAgLyogU2hvcnRlciBmbHVlbnQgdmVyc2lvbiBvZiBhZGRFdmVudExpc3RlbmVyLiBQcmVmZXJlZCBtZXRob2QuICovXG4gICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIodG9waWMsIGxpc3RlbmVyKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBmdW5jdGlvbiBhdHRyKGtleSwgdmFsdWUpIHtcbiAgICAgIHRoaXMuc2V0QXR0cmlidXRlKGtleSwgdmFsdWUpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIGZ1bmN0aW9uIGF0dHJzKG1hcCkge1xuICAgICAgLyogU2V0IG11bHRpcGxlIGF0dHJpYnV0ZXMgYXQgb25jZS4gKi9cbiAgICAgIGZvciAoIHZhciBrZXkgaW4gbWFwICkgdGhpcy5zZXRBdHRyaWJ1dGUoa2V5LCBtYXBba2V5XSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgZnVuY3Rpb24gc3R5bGUobWFwKSB7XG4gICAgICAvKlxuICAgICAgICBTZXQgQ1NTIHN0eWxlcy5cbiAgICAgICAgTWFwIHZhbHVlcyBjYW4gYmUgT2JqZWN0cyBvciBkeW5hbWljIFZhbHVlcy5cbiAgICAgICovXG4gICAgICBmb3IgKCB2YXIga2V5IGluIG1hcCApIHtcbiAgICAgICAgdmFyIHZhbHVlID0gbWFwW2tleV07XG4gICAgICAgIGlmICggZm9hbS5jb3JlLlNsb3QuaXNJbnN0YW5jZSh2YWx1ZSkgKSB7XG4gICAgICAgICAgdGhpcy5zbG90U3R5bGVfKGtleSwgdmFsdWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuc3R5bGVfKGtleSwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFRPRE86IGFkZCB0eXBlIGNoZWNraW5nIGZvciB0aGlzXG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBmdW5jdGlvbiB0YWcoc3BlYywgYXJncywgc2xvdCkge1xuICAgICAgLyogQ3JlYXRlIGEgbmV3IEVsZW1lbnQgYW5kIGFkZCBpdCBhcyBhIGNoaWxkLiBSZXR1cm4gdGhpcy4gKi9cbiAgICAgIHZhciBjID0gdGhpcy5jcmVhdGVDaGlsZF8oc3BlYywgYXJncyk7XG4gICAgICB0aGlzLmFkZChjKTtcbiAgICAgIGlmICggc2xvdCApIHNsb3Quc2V0KGMpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIGZ1bmN0aW9uIGJyKCkge1xuICAgICAgcmV0dXJuIHRoaXMudGFnKCdicicpO1xuICAgIH0sXG5cbiAgICBmdW5jdGlvbiBzdGFydENvbnRleHQobWFwKSB7XG4gICAgICB2YXIgbSA9IHt9O1xuICAgICAgT2JqZWN0LmFzc2lnbihtLCBtYXApO1xuICAgICAgbS5fX29sZEFkZENvbnRleHRfXyA9IHRoaXMuX19zdWJTdWJDb250ZXh0X187XG4gICAgICB0aGlzLl9fc3ViU3ViQ29udGV4dF9fID0gdGhpcy5fX3N1YlN1YkNvbnRleHRfXy5jcmVhdGVTdWJDb250ZXh0KG0pO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIGZ1bmN0aW9uIGVuZENvbnRleHQoKSB7XG4gICAgICB0aGlzLl9fc3ViU3ViQ29udGV4dF9fID0gdGhpcy5fX3N1YlN1YkNvbnRleHRfXy5fX29sZEFkZENvbnRleHRfXztcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBmdW5jdGlvbiBjcmVhdGVDaGlsZF8oc3BlYywgYXJncykge1xuICAgICAgcmV0dXJuIGZvYW0udTIuVmlld1NwZWMuY3JlYXRlVmlldyhzcGVjLCBhcmdzLCB0aGlzLCB0aGlzLl9fc3ViU3ViQ29udGV4dF9fKTtcbiAgICB9LFxuXG4gICAgZnVuY3Rpb24gc3RhcnQoc3BlYywgYXJncywgc2xvdCkge1xuICAgICAgLyogQ3JlYXRlIGEgbmV3IEVsZW1lbnQgYW5kIGFkZCBpdCBhcyBhIGNoaWxkLiBSZXR1cm4gdGhlIGNoaWxkLiAqL1xuICAgICAgdmFyIGMgPSB0aGlzLmNyZWF0ZUNoaWxkXyhzcGVjLCBhcmdzKTtcbiAgICAgIHRoaXMuYWRkKGMpO1xuICAgICAgaWYgKCBzbG90ICkgc2xvdC5zZXQoYyk7XG4gICAgICByZXR1cm4gYztcbiAgICB9LFxuXG4gICAgZnVuY3Rpb24gZW5kKCkge1xuICAgICAgLyogUmV0dXJuIHRoaXMgRWxlbWVudCdzIHBhcmVudC4gVXNlZCB0byB0ZXJtaW5hdGUgYSBzdGFydCgpLiAqL1xuICAgICAgcmV0dXJuIHRoaXMucGFyZW50Tm9kZTtcbiAgICB9LFxuXG4gICAgZnVuY3Rpb24gYWRkKCkge1xuICAgICAgaWYgKCB0aGlzLmNvbnRlbnQgKSB7XG4gICAgICAgIHRoaXMuY29udGVudC5hZGRfKGFyZ3VtZW50cywgdGhpcyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmFkZF8oYXJndW1lbnRzLCB0aGlzKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBmdW5jdGlvbiB0b0UoKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgZnVuY3Rpb24gYWRkXyhjcywgcGFyZW50Tm9kZSkge1xuICAgICAgLyogQWRkIENoaWxkcmVuIHRvIHRoaXMgRWxlbWVudC4gKi9cbiAgICAgIHZhciBlcyA9IFtdO1xuICAgICAgdmFyIFkgPSB0aGlzLl9fc3ViU3ViQ29udGV4dF9fO1xuXG4gICAgICBmb3IgKCB2YXIgaSA9IDAgOyBpIDwgY3MubGVuZ3RoIDsgaSsrICkge1xuICAgICAgICB2YXIgYyA9IGNzW2ldO1xuXG4gICAgICAgIC8vIFJlbW92ZSBudWxsIHZhbHVlc1xuICAgICAgICBpZiAoIGMgPT09IHVuZGVmaW5lZCB8fCBjID09PSBudWxsICkge1xuICAgICAgICAgIC8vIG5vcFxuICAgICAgICB9IGVsc2UgaWYgKCBBcnJheS5pc0FycmF5KGMpICkge1xuICAgICAgICAgIGZvciAoIHZhciBqID0gMCA7IGogPCBjLmxlbmd0aCA7IGorKyApIHtcbiAgICAgICAgICAgIHZhciB2ID0gY1tqXTtcbiAgICAgICAgICAgIGVzLnB1c2godi50b0UgPyB2LnRvRShudWxsLCBZKSA6IHYpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICggYy50b0UgKSB7XG4gICAgICAgICAgdmFyIGUgPSBjLnRvRShudWxsLCBZKTtcbiAgICAgICAgICBpZiAoIGZvYW0uY29yZS5TbG90LmlzSW5zdGFuY2UoZSkgKSB7XG4gICAgICAgICAgICBlID0gdGhpcy5zbG90RV8oZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVzLnB1c2goZSk7XG4gICAgICAgIH0gZWxzZSBpZiAoIHR5cGVvZiBjID09PSAnZnVuY3Rpb24nICkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVW5zdXBwb3J0ZWQnKTtcbiAgICAgICAgfSBlbHNlIGlmICggZm9hbS5jb3JlLlNsb3QuaXNJbnN0YW5jZShjKSApIHtcbiAgICAgICAgICB2YXIgdiA9IHRoaXMuc2xvdEVfKGMpO1xuICAgICAgICAgIGlmICggQXJyYXkuaXNBcnJheSh2KSApIHtcbiAgICAgICAgICAgIGZvciAoIHZhciBqID0gMCA7IGogPCB2Lmxlbmd0aCA7IGorKyApIHtcbiAgICAgICAgICAgICAgdmFyIHUgPSB2W2pdO1xuICAgICAgICAgICAgICBlcy5wdXNoKHUudG9FID8gdS50b0UobnVsbCwgWSkgOiB1KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZXMucHVzaCh2LnRvRSA/IHYudG9FKG51bGwsIFkpIDogdik7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGVzLnB1c2goYyk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKCBlcy5sZW5ndGggKSB7XG4gICAgICAgIGZvciAoIHZhciBpID0gMCA7IGkgPCBlcy5sZW5ndGggOyBpKysgKSB7XG4gICAgICAgICAgaWYgKCBmb2FtLnUyLkVsZW1lbnQuaXNJbnN0YW5jZShlc1tpXSkgKSB7XG4gICAgICAgICAgICBlc1tpXS5wYXJlbnROb2RlID0gcGFyZW50Tm9kZTtcbiAgICAgICAgICB9IGVsc2UgaWYgKCBlc1tpXS5jbHNfICYmIGVzW2ldLmNsc18uaWQgPT09ICdmb2FtLnUyLkVudGl0eScgKSB7XG4gICAgICAgICAgICAvLyBOT1BcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZXNbaV0gPSB0aGlzLnNhbml0aXplVGV4dChlc1tpXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5jaGlsZE5vZGVzLnB1c2guYXBwbHkodGhpcy5jaGlsZE5vZGVzLCBlcyk7XG4gICAgICAgIHRoaXMub25BZGRDaGlsZHJlbi5hcHBseSh0aGlzLCBlcyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBmdW5jdGlvbiBhZGRCZWZvcmUocmVmZXJlbmNlKSB7IC8qLCB2YXJncyAqL1xuICAgICAgLyogQWRkIGEgdmFyaWFibGUgbnVtYmVyIG9mIGNoaWxkcmVuIGJlZm9yZSB0aGUgcmVmZXJlbmNlIGVsZW1lbnQuICovXG4gICAgICB2YXIgY2hpbGRyZW4gPSBbXTtcbiAgICAgIGZvciAoIHZhciBpID0gMSA7IGkgPCBhcmd1bWVudHMubGVuZ3RoIDsgaSsrICkge1xuICAgICAgICBjaGlsZHJlbi5wdXNoKGFyZ3VtZW50c1tpXSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5pbnNlcnRBdF8oY2hpbGRyZW4sIHJlZmVyZW5jZSwgdHJ1ZSk7XG4gICAgfSxcblxuICAgIGZ1bmN0aW9uIHJlbW92ZUFsbENoaWxkcmVuKCkge1xuICAgICAgLyogUmVtb3ZlIGFsbCBvZiB0aGlzIEVsZW1lbnQncyBjaGlsZHJlbi4gKi9cbiAgICAgIHZhciBjcyA9IHRoaXMuY2hpbGROb2RlcztcbiAgICAgIHdoaWxlICggY3MubGVuZ3RoICkge1xuICAgICAgICB0aGlzLnJlbW92ZUNoaWxkKGNzWzBdKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBmdW5jdGlvbiBzZXRDaGlsZHJlbihzbG90KSB7XG4gICAgICAvKipcbiAgICAgICAgIHNsb3QgLS0gYSBTbG90IG9mIGFuIGFycmF5IG9mIGNoaWxkcmVuIHdoaWNoIHNldCB0aGlzIGVsZW1lbnQnc1xuICAgICAgICAgY29udGVudHMsIHJlcGxhY2luZyBvbGQgY2hpbGRyZW5cbiAgICAgICoqL1xuICAgICAgdmFyIGwgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5yZW1vdmVBbGxDaGlsZHJlbigpO1xuICAgICAgICB0aGlzLmFkZC5hcHBseSh0aGlzLCBzbG90LmdldCgpKTtcbiAgICAgIH0uYmluZCh0aGlzKTtcblxuICAgICAgc2xvdC5zdWIobCk7XG4gICAgICBsKCk7XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBmdW5jdGlvbiByZXBlYXQocywgZSwgZikge1xuICAgICAgLy8gVE9ETzogc3VwcG9ydCBkZXNjZW5kaW5nXG4gICAgICBmb3IgKCB2YXIgaSA9IHMgOyBpIDw9IGUgOyBpKysgKSB7XG4gICAgICAgIGYuY2FsbCh0aGlzLCBpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBmdW5jdGlvbiBkYW9TbG90KGRhbywgc2luaykge1xuICAgICAgdmFyIHNsb3QgPSBmb2FtLmRhby5EQU9TbG90LmNyZWF0ZSh7XG4gICAgICAgIGRhbzogZGFvLFxuICAgICAgICBzaW5rOiBzaW5rXG4gICAgICB9KTtcblxuICAgICAgdGhpcy5vbkRldGFjaChzbG90KTtcblxuICAgICAgcmV0dXJuIHNsb3Q7XG4gICAgfSxcblxuICAgIGZ1bmN0aW9uIHNlbGVjdChkYW8sIGYsIHVwZGF0ZSkge1xuICAgICAgdmFyIGVzICAgPSB7fTtcbiAgICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgICAgdmFyIGxpc3RlbmVyID0gZm9hbS51Mi5SZW5kZXJTaW5rLmNyZWF0ZSh7XG4gICAgICAgIGRhbzogZGFvLFxuICAgICAgICBhZGRSb3c6IGZ1bmN0aW9uKG8pIHtcbiAgICAgICAgICBpZiAoIHVwZGF0ZSApIG8gPSBvLmNsb25lKCk7XG5cbiAgICAgICAgICBzZWxmLnN0YXJ0Q29udGV4dCh7ZGF0YTogb30pO1xuXG4gICAgICAgICAgdmFyIGUgPSBmLmNhbGwoc2VsZiwgbyk7XG5cbiAgICAgICAgICBpZiAoIHVwZGF0ZSApIHtcbiAgICAgICAgICAgIG8ucHJvcGVydHlDaGFuZ2Uuc3ViKGZ1bmN0aW9uKF8sX18scHJvcCxzbG90KSB7XG4gICAgICAgICAgICAgIGRhby5wdXQoby5jbG9uZSgpKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHNlbGYuZW5kQ29udGV4dCgpO1xuXG4gICAgICAgICAgaWYgKCBlc1tvLmlkXSApIHtcbiAgICAgICAgICAgIHNlbGYucmVwbGFjZUNoaWxkKGVzW28uaWRdLCBlKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc2VsZi5hZGQoZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVzW28uaWRdID0gZTtcbiAgICAgICAgfSxcbiAgICAgICAgY2xlYW51cDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgZm9yICggdmFyIGtleSBpbiBlcyApIHtcbiAgICAgICAgICAgIGVzW2tleV0ucmVtb3ZlKCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZXMgPSB7fTtcbiAgICAgICAgfVxuICAgICAgfSwgdGhpcyk7XG5cbiAgICAgIGxpc3RlbmVyID0gZm9hbS5kYW8uTWVyZ2VkUmVzZXRTaW5rLmNyZWF0ZSh7XG4gICAgICAgIGRlbGVnYXRlOiBsaXN0ZW5lclxuICAgICAgfSwgdGhpcyk7XG5cbiAgICAgIHRoaXMub25EZXRhY2goZGFvLmxpc3RlbihsaXN0ZW5lcikpO1xuICAgICAgbGlzdGVuZXIuZGVsZWdhdGUucGFpbnQoKTtcblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIGZ1bmN0aW9uIGNhbGwoZiwgYXJncykge1xuICAgICAgZi5hcHBseSh0aGlzLCBhcmdzKTtcblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIGZ1bmN0aW9uIGNhbGxPbihvYmosIGYsIGFyZ3MpIHtcbiAgICAgIG9ialtmXS5hcHBseShvYmosIFt0aGlzXS5jb25jYXQoYXJncykpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIGZ1bmN0aW9uIGNhbGxJZihib29sLCBmLCBhcmdzKSB7XG4gICAgICBpZiAoIGJvb2wgKSBmLmFwcGx5KHRoaXMsIGFyZ3MpO1xuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgZnVuY3Rpb24gZm9yRWFjaChhLCBmKSB7XG4gICAgICBmb3IgKCB2YXIgaSA9IDAgOyBpIDwgYS5sZW5ndGggOyBpKysgKSB7XG4gICAgICAgIGYuY2FsbCh0aGlzLCBhW2ldLCBpKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIGZ1bmN0aW9uIG91dHB1dElubmVySFRNTChvdXQpIHtcbiAgICAgIHZhciBjcyA9IHRoaXMuY2hpbGROb2RlcztcbiAgICAgIGZvciAoIHZhciBpID0gMCA7IGkgPCBjcy5sZW5ndGggOyBpKysgKSB7XG4gICAgICAgIG91dChjc1tpXSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gb3V0O1xuICAgIH0sXG5cbiAgICBmdW5jdGlvbiBjcmVhdGVPdXRwdXRTdHJlYW0oKSB7XG4gICAgICAvKlxuICAgICAgICBDcmVhdGUgYW4gT3V0cHV0U3RyZWFtLlxuICAgICAgICBTdWl0YWJsZSBmb3IgcHJvdmlkaW5nIHRvIHRoZSBvdXRwdXQoKSBtZXRob2QgZm9yXG4gICAgICAgIHNlcmlhbGl6aW5nIGFuIEVsZW1lbnQgaGllcmFyY2h5LlxuICAgICAgICBDYWxsIHRvU3RyaW5nKCkgb24gdGhlIE91dHB1dFN0cmVhbSB0byBnZXQgb3V0cHV0LlxuICAgICAgKi9cbiAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgIHZhciBidWYgPSBbXTtcbiAgICAgIHZhciBFbGVtZW50ID0gZm9hbS51Mi5FbGVtZW50O1xuICAgICAgdmFyIEVudGl0eSAgPSBzZWxmLkVudGl0eTtcbiAgICAgIHZhciBmID0gZnVuY3Rpb24gdGVtcGxhdGVPdXQoLyogYXJndW1lbnRzICovKSB7XG4gICAgICAgIGZvciAoIHZhciBpID0gMCA7IGkgPCBhcmd1bWVudHMubGVuZ3RoIDsgaSsrICkge1xuICAgICAgICAgIHZhciBvID0gYXJndW1lbnRzW2ldO1xuICAgICAgICAgIGlmICggbyA9PT0gbnVsbCB8fCBvID09PSB1bmRlZmluZWQgKSB7XG4gICAgICAgICAgICAvLyBOT1BcbiAgICAgICAgICB9IGVsc2UgaWYgKCB0eXBlb2YgbyA9PT0gJ3N0cmluZycgKSB7XG4gICAgICAgICAgICBidWYucHVzaChvKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKCB0eXBlb2YgbyA9PT0gJ251bWJlcicgKSB7XG4gICAgICAgICAgICBidWYucHVzaChvKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKCBFbGVtZW50LmlzSW5zdGFuY2UobykgfHwgRW50aXR5LmlzSW5zdGFuY2UobykgKSB7XG4gICAgICAgICAgICBvLm91dHB1dChmKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKCBvID09PSBudWxsIHx8IG8gPT09IHVuZGVmaW5lZCApIHtcbiAgICAgICAgICAgIGJ1Zi5wdXNoKG8pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgZi50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoIGJ1Zi5sZW5ndGggPT09IDAgKSByZXR1cm4gJyc7XG4gICAgICAgIGlmICggYnVmLmxlbmd0aCA+IDEgKSByZXR1cm4gYnVmLmpvaW4oJycpO1xuICAgICAgICByZXR1cm4gYnVmWzBdO1xuICAgICAgfTtcblxuICAgICAgcmV0dXJuIGY7XG4gICAgfSxcblxuICAgIGZ1bmN0aW9uIHdyaXRlKCkge1xuICAgICAgLyogV3JpdGUgRWxlbWVudCB0byBkb2N1bWVudC4gKi9cbiAgICAgIHRoaXMuZG9jdW1lbnQuYm9keS5pbnNlcnRBZGphY2VudEhUTUwoJ2JlZm9yZWVuZCcsIHRoaXMub3V0ZXJIVE1MKTtcbiAgICAgIHRoaXMubG9hZCgpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgICAgcmV0dXJuIHRoaXMuY2xzXy5pZCArICcobm9kZU5hbWU9JyArIHRoaXMubm9kZU5hbWUgKyAnLCBzdGF0ZT0nICsgdGhpcy5zdGF0ZSArICcpJztcbiAgICAgIC8qIENvbnZlcnRzIEVsZW1lbnQgdG8gSFRNTCBTdHJpbmcgd2l0aG91dCB0cmFuc2l0aW9uaW5nIHN0YXRlLiAqL1xuICAgICAgLypcbiAgICAgICAgVE9ETzogcHV0IHRoaXMgc29tZXdoZXJlIHVzZWZ1bCBmb3IgZGVidWdnaW5nXG4gICAgICB2YXIgcyA9IHRoaXMuY3JlYXRlT3V0cHV0U3RyZWFtKCk7XG4gICAgICB0aGlzLm91dHB1dF8ocyk7XG4gICAgICByZXR1cm4gcy50b1N0cmluZygpO1xuICAgICAgKi9cbiAgICB9LFxuXG4gICAgZnVuY3Rpb24gaW5zZXJ0QXRfKGNoaWxkcmVuLCByZWZlcmVuY2UsIGJlZm9yZSkge1xuICAgICAgLy8gKEVsZW1lbnRbXSwgRWxlbWVudCwgQm9vbGVhbilcblxuICAgICAgdmFyIGkgPSB0aGlzLmNoaWxkTm9kZXMuaW5kZXhPZihyZWZlcmVuY2UpO1xuXG4gICAgICBpZiAoIGkgPT09IC0xICkge1xuICAgICAgICB0aGlzLndhcm4oXCJSZWZlcmVuY2Ugbm9kZSBpc24ndCBhIGNoaWxkIG9mIHRoaXMuXCIpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cblxuICAgICAgaWYgKCAhIEFycmF5LmlzQXJyYXkoY2hpbGRyZW4pICkgY2hpbGRyZW4gPSBbIGNoaWxkcmVuIF07XG5cbiAgICAgIHZhciBZID0gdGhpcy5fX3N1YlN1YkNvbnRleHRfXztcbiAgICAgIGNoaWxkcmVuID0gY2hpbGRyZW4ubWFwKGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgZSA9IGUudG9FID8gZS50b0UobnVsbCwgWSkgOiBlO1xuICAgICAgICBlLnBhcmVudE5vZGUgPSB0aGlzO1xuICAgICAgICByZXR1cm4gZTtcbiAgICAgIH0uYmluZCh0aGlzKSk7XG5cbiAgICAgIHZhciBpbmRleCA9IGJlZm9yZSA/IGkgOiAoaSArIDEpO1xuICAgICAgdGhpcy5jaGlsZE5vZGVzLnNwbGljZS5hcHBseSh0aGlzLmNoaWxkTm9kZXMsXG4gICAgICAgICAgWyBpbmRleCwgMCBdLmNvbmNhdChjaGlsZHJlbikpO1xuXG4gICAgICB0aGlzLnN0YXRlLm9uSW5zZXJ0Q2hpbGRyZW4uY2FsbChcbiAgICAgICAgdGhpcyxcbiAgICAgICAgY2hpbGRyZW4sXG4gICAgICAgIHJlZmVyZW5jZSxcbiAgICAgICAgYmVmb3JlID8gJ2JlZm9yZWJlZ2luJyA6ICdhZnRlcmVuZCcpO1xuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgZnVuY3Rpb24gYWRkQ2xhc3NfKG9sZENsYXNzLCBuZXdDbGFzcykge1xuICAgICAgLyogUmVwbGFjZSBvbGRDbGFzcyB3aXRoIG5ld0NsYXNzLiBDYWxsZWQgYnkgY2xzKCkuICovXG4gICAgICBpZiAoIG9sZENsYXNzID09PSBuZXdDbGFzcyApIHJldHVybjtcbiAgICAgIHRoaXMucmVtb3ZlQ2xhc3Mob2xkQ2xhc3MpO1xuICAgICAgaWYgKCBuZXdDbGFzcyApIHtcbiAgICAgICAgdGhpcy5jbGFzc2VzW25ld0NsYXNzXSA9IHRydWU7XG4gICAgICAgIHRoaXMub25TZXRDbGFzcyhuZXdDbGFzcywgdHJ1ZSk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIGZ1bmN0aW9uIHNsb3RBdHRyXyhrZXksIHZhbHVlKSB7XG4gICAgICAvKiBTZXQgYW4gYXR0cmlidXRlIGJhc2VkIG9mZiBvZiBhIGR5bmFtaWMgVmFsdWUuICovXG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICB2YXIgbCA9IGZ1bmN0aW9uKCkgeyBzZWxmLnNldEF0dHJpYnV0ZShrZXksIHZhbHVlLmdldCgpKTsgfTtcbiAgICAgIHZhbHVlLnN1YihsKTtcbiAgICAgIGwoKTtcbiAgICB9LFxuXG4gICAgZnVuY3Rpb24gc2xvdFN0eWxlXyhrZXksIHYpIHtcbiAgICAgIC8qIFNldCBhIENTUyBzdHlsZSBiYXNlZCBvZmYgb2YgYSBkeW5hbWljIFZhbHVlLiAqL1xuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgdmFyIGwgPSBmdW5jdGlvbih2YWx1ZSkgeyBzZWxmLnN0eWxlXyhrZXksIHYuZ2V0KCkpOyB9O1xuICAgICAgdi5zdWIobCk7XG4gICAgICBsKCk7XG4gICAgfSxcblxuICAgIGZ1bmN0aW9uIHN0eWxlXyhrZXksIHZhbHVlKSB7XG4gICAgICAvKiBTZXQgYSBDU1Mgc3R5bGUgYmFzZWQgb2ZmIG9mIGEgbGl0ZXJhbCB2YWx1ZS4gKi9cbiAgICAgIHRoaXMuY3NzW2tleV0gPSB2YWx1ZTtcbiAgICAgIHRoaXMub25TZXRTdHlsZShrZXksIHZhbHVlKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBmdW5jdGlvbiBzbG90RV8oc2xvdCkge1xuICAgICAgLy8gVE9ETzogYWRkIHNhbWUgY29udGV4dCBjYXB0dXJpbmcgYmVodmlvdXIgdG8gb3RoZXIgc2xvdFhYWF8oKSBtZXRob2RzLlxuICAgICAgLypcbiAgICAgICAgUmV0dXJuIGFuIEVsZW1lbnQgb3IgYW4gQXJyYXkgb2YgRWxlbWVudHMgd2hpY2ggYXJlXG4gICAgICAgIHJldHVybmVkIGZyb20gdGhlIHN1cHBsaWVkIGR5bmFtaWMgU2xvdC5cbiAgICAgICAgVGhlIEVsZW1lbnQocykgYXJlIHJlcGxhY2VkIHdoZW4gdGhlIFNsb3QgY2hhbmdlcy5cbiAgICAgICovXG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICB2YXIgY3R4ICA9IHRoaXMuX19zdWJTdWJDb250ZXh0X187XG5cbiAgICAgIGZ1bmN0aW9uIG5leHRFKCkge1xuICAgICAgICAvLyBSdW4gU2xvdCBpbiBzYW1lIHN1YlN1YkNvbnRleHQgdGhhdCBpdCB3YXMgY3JlYXRlZCBpbi5cbiAgICAgICAgdmFyIG9sZEN0eCA9IHNlbGYuX19zdWJTdWJDb250ZXh0X187XG4gICAgICAgIHNlbGYuX19zdWJTdWJDb250ZXh0X18gPSBjdHg7XG4gICAgICAgIHZhciBlID0gc2xvdC5nZXQoKTtcblxuICAgICAgICAvLyBDb252ZXJ0IGUgb3IgZVswXSBpbnRvIGEgU1BBTiBpZiBuZWVkZWQsXG4gICAgICAgIC8vIFNvIHRoYXQgaXQgY2FuIGJlIGxvY2F0ZWQgbGF0ZXIuXG4gICAgICAgIGlmICggZSA9PT0gdW5kZWZpbmVkIHx8IGUgPT09IG51bGwgfHwgZSA9PT0gJycgKSB7XG4gICAgICAgICAgZSA9IHNlbGYuRSgnU1BBTicpO1xuICAgICAgICB9IGVsc2UgaWYgKCBBcnJheS5pc0FycmF5KGUpICkge1xuICAgICAgICAgIGlmICggZS5sZW5ndGggKSB7XG4gICAgICAgICAgICBpZiAoIHR5cGVvZiBlWzBdID09PSAnc3RyaW5nJyApIHtcbiAgICAgICAgICAgICAgZVswXSA9IHNlbGYuRSgnU1BBTicpLmFkZChlWzBdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZSA9IHNlbGYuRSgnU1BBTicpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICggISBmb2FtLnUyLkVsZW1lbnQuaXNJbnN0YW5jZShlKSApIHtcbiAgICAgICAgICBlID0gc2VsZi5FKCdTUEFOJykuYWRkKGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgc2VsZi5fX3N1YlN1YkNvbnRleHRfXyA9IG9sZEN0eDtcblxuICAgICAgICByZXR1cm4gZTtcbiAgICAgIH1cblxuICAgICAgdmFyIGUgPSBuZXh0RSgpO1xuICAgICAgdmFyIGwgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKCBzZWxmLnN0YXRlICE9PSBzZWxmLkxPQURFRCApIHtcbiAgICAgICAgICBzICYmIHMuZGV0YWNoKCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBmaXJzdCA9IEFycmF5LmlzQXJyYXkoZSkgPyBlWzBdIDogZTtcbiAgICAgICAgdmFyIHRtcCA9IHNlbGYuRSgpO1xuICAgICAgICBzZWxmLmluc2VydEJlZm9yZSh0bXAsIGZpcnN0KTtcbiAgICAgICAgaWYgKCBBcnJheS5pc0FycmF5KGUpICkge1xuICAgICAgICAgIGZvciAoIHZhciBpID0gMCA7IGkgPCBlLmxlbmd0aCA7IGkrKyApIHsgZVtpXS5yZW1vdmUoKTsgZVtpXS5kZXRhY2goKTsgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmICggZS5zdGF0ZSA9PT0gZS5MT0FERUQgKSB7IGUucmVtb3ZlKCk7IGUuZGV0YWNoKCk7IH1cbiAgICAgICAgfVxuICAgICAgICB2YXIgZTIgPSBuZXh0RSgpO1xuICAgICAgICBzZWxmLmluc2VydEJlZm9yZShlMiwgdG1wKTtcbiAgICAgICAgdG1wLnJlbW92ZSgpO1xuICAgICAgICBlID0gZTI7XG4gICAgICB9O1xuXG4gICAgICB2YXIgcyA9IHNsb3Quc3ViKHRoaXMuZnJhbWVkKGwpKTtcbiAgICAgIHRoaXMub25EZXRhY2gocyk7XG5cbiAgICAgIHJldHVybiBlO1xuICAgIH0sXG5cbiAgICBmdW5jdGlvbiBhZGRFdmVudExpc3RlbmVyXyh0b3BpYywgbGlzdGVuZXIpIHtcbiAgICAgIHZhciBlbCA9IHRoaXMuZWwoKTtcbiAgICAgIGVsICYmIGVsLmFkZEV2ZW50TGlzdGVuZXIodG9waWMsIGxpc3RlbmVyLCBmYWxzZSk7XG4gICAgfSxcblxuICAgIGZ1bmN0aW9uIHJlbW92ZUV2ZW50TGlzdGVuZXJfKHRvcGljLCBsaXN0ZW5lcikge1xuICAgICAgdGhpcy5lbCgpICYmIHRoaXMuZWwoKS5yZW1vdmVFdmVudExpc3RlbmVyKHRvcGljLCBsaXN0ZW5lcik7XG4gICAgfSxcblxuICAgIGZ1bmN0aW9uIG91dHB1dF8ob3V0KSB7XG4gICAgICAvKiogT3V0cHV0IHRoZSBlbGVtZW50IHdpdGhvdXQgdHJhbnNpdGlvbmluZyB0byB0aGUgT1VUUFVUIHN0YXRlLiAqKi9cbiAgICAgIG91dCgnPCcsIHRoaXMubm9kZU5hbWUpO1xuICAgICAgaWYgKCB0aGlzLmlkICE9PSBudWxsICkgb3V0KCcgaWQ9XCInLCB0aGlzLmlkLCAnXCInKTtcblxuICAgICAgdmFyIGZpcnN0ID0gdHJ1ZTtcbiAgICAgIGlmICggdGhpcy5oYXNPd25Qcm9wZXJ0eSgnY2xhc3NlcycpICkge1xuICAgICAgICB2YXIgY3MgPSB0aGlzLmNsYXNzZXM7XG4gICAgICAgIGZvciAoIHZhciBrZXkgaW4gY3MgKSB7XG4gICAgICAgICAgaWYgKCAhIGNzW2tleV0gKSBjb250aW51ZTtcbiAgICAgICAgICBpZiAoIGZpcnN0ICkge1xuICAgICAgICAgICAgb3V0KCcgY2xhc3M9XCInKTtcbiAgICAgICAgICAgIGZpcnN0ID0gZmFsc2U7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG91dCgnICcpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBvdXQoa2V5KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoICEgZmlyc3QgKSBvdXQoJ1wiJyk7XG4gICAgICB9XG5cbiAgICAgIGlmICggdGhpcy5oYXNPd25Qcm9wZXJ0eSgnY3NzJykgKSB7XG4gICAgICAgIGZpcnN0ID0gdHJ1ZTtcbiAgICAgICAgdmFyIGNzID0gdGhpcy5jc3M7XG4gICAgICAgIGZvciAoIHZhciBrZXkgaW4gY3MgKSB7XG4gICAgICAgICAgdmFyIHZhbHVlID0gY3Nba2V5XTtcblxuICAgICAgICAgIGlmICggZmlyc3QgKSB7XG4gICAgICAgICAgICBvdXQoJyBzdHlsZT1cIicpO1xuICAgICAgICAgICAgZmlyc3QgPSBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgb3V0KGtleSwgJzonLCB2YWx1ZSwgJzsnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoICEgZmlyc3QgKSBvdXQoJ1wiJyk7XG4gICAgICB9XG5cbiAgICAgIGlmICggdGhpcy5oYXNPd25Qcm9wZXJ0eSgnYXR0cmlidXRlcycpICkge1xuICAgICAgICB2YXIgYXMgPSB0aGlzLmF0dHJpYnV0ZXM7XG4gICAgICAgIGZvciAoIHZhciBpID0gMCA7IGkgPCBhcy5sZW5ndGggOyBpKysgKSB7XG4gICAgICAgICAgdmFyIGF0dHIgID0gYXNbaV07XG4gICAgICAgICAgdmFyIG5hbWUgID0gYXR0ci5uYW1lO1xuICAgICAgICAgIHZhciB2YWx1ZSA9IGF0dHIudmFsdWU7XG5cbiAgICAgICAgICBvdXQoJyAnLCBuYW1lKTtcbiAgICAgICAgICBpZiAoIHZhbHVlICE9PSBmYWxzZSApIG91dCgnPVwiJywgZm9hbS5TdHJpbmcuaXNJbnN0YW5jZSh2YWx1ZSkgPyB2YWx1ZS5yZXBsYWNlKC9cIi9nLCAnJnF1b3Q7JykgOiB2YWx1ZSwgJ1wiJyk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKCAhIHRoaXMuSUxMRUdBTF9DTE9TRV9UQUdTW3RoaXMubm9kZU5hbWVdICkge1xuICAgICAgICB2YXIgaGFzQ2hpbGRyZW4gPSB0aGlzLmhhc093blByb3BlcnR5KCdjaGlsZE5vZGVzJykgJiYgdGhpcy5jaGlsZE5vZGVzLmxlbmd0aDtcbiAgICAgICAgaWYgKCBoYXNDaGlsZHJlbiB8fCAhIHRoaXMuT1BUSU9OQUxfQ0xPU0VfVEFHU1t0aGlzLm5vZGVOYW1lXSApIHtcbiAgICAgICAgICBvdXQoJz4nKTtcbiAgICAgICAgICBpZiAoIGhhc0NoaWxkcmVuICkgdGhpcy5vdXRwdXRJbm5lckhUTUwob3V0KTtcbiAgICAgICAgICBvdXQoJzwvJywgdGhpcy5ub2RlTmFtZSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgb3V0KCc+Jyk7XG4gICAgfVxuICBdLFxuXG4gIGxpc3RlbmVyczogW1xuICAgIHtcbiAgICAgIG5hbWU6ICdvbktleWJvYXJkU2hvcnRjdXQnLFxuICAgICAgZG9jdW1lbnRhdGlvbjogZnVuY3Rpb24oKSB7LypcbiAgICAgICAgICBBdXRvbWF0aWMgbWFwcGluZyBvZiBrZXlib2FyZCBldmVudHMgdG8gJCRET0N7cmVmOidBY3Rpb24nfSB0cmlnZ2VyLlxuICAgICAgICAgIFRvIGhhbmRsZSBrZXlib2FyZCBzaG9ydGN1dHMsIGNyZWF0ZSBhbmQgYXR0YWNoICQkRE9De3JlZjonQWN0aW9uJyx1c2VQbHVyYWw6dHJ1ZX1cbiAgICAgICAgICB0byB5b3VyICQkRE9De3JlZjonZm9hbS51aS5WaWV3J30uXG4gICAgICAqL30sXG4gICAgICBjb2RlOiBmdW5jdGlvbihldnQpIHtcbiAgICAgICAgaWYgKCBldnQudHlwZSA9PT0gJ2tleWRvd24nICYmICEgdGhpcy5LRVlQUkVTU19DT0RFU1tldnQud2hpY2hdICkgcmV0dXJuO1xuICAgICAgICB2YXIgYWN0aW9uID0gdGhpcy5rZXlNYXBfW3RoaXMuZXZ0VG9DaGFyQ29kZShldnQpXTtcbiAgICAgICAgaWYgKCBhY3Rpb24gKSB7XG4gICAgICAgICAgYWN0aW9uKCk7XG4gICAgICAgICAgZXZ0LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgZXZ0LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICBdXG59KTtcblxuXG5mb2FtLkNMQVNTKHtcbiAgcGFja2FnZTogJ2ZvYW0udTInLFxuICBuYW1lOiAnVTJDb250ZXh0JyxcblxuICBkb2N1bWVudGF0aW9uOiAnQ29udGV4dCB3aGljaCBpbmNsdWRlcyBVMiBmdW5jdGlvbmFsaXR5LicsXG5cbiAgZXhwb3J0czogW1xuICAgICdFJyxcbiAgICAncmVnaXN0ZXJFbGVtZW50JyxcbiAgICAnZWxlbWVudEZvck5hbWUnXG4gIF0sXG5cbiAgcHJvcGVydGllczogW1xuICAgIHtcbiAgICAgIG5hbWU6ICdlbGVtZW50TWFwJyxcbiAgICAgIGRvY3VtZW50YXRpb246ICdNYXAgb2YgcmVnaXN0ZXJlZCBFbGVtZW50cy4nLFxuICAgICAgZmFjdG9yeTogZnVuY3Rpb24oKSB7IHJldHVybiB7fTsgfVxuICAgIH1cbiAgXSxcblxuICBtZXRob2RzOiBbXG4gICAge1xuICAgICAgY2xhc3M6ICdmb2FtLmNvcmUuQ29udGV4dE1ldGhvZCcsXG4gICAgICBuYW1lOiAnRScsXG4gICAgICBjb2RlOiBmdW5jdGlvbiBFKGN0eCwgb3B0X25vZGVOYW1lKSB7XG4gICAgICAgIHZhciBub2RlTmFtZSA9IChvcHRfbm9kZU5hbWUgfHwgJ2RpdicpLnRvVXBwZXJDYXNlKCk7XG5cbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICBjdHguZWxlbWVudEZvck5hbWUobm9kZU5hbWUpIHx8IGZvYW0udTIuRWxlbWVudCkuXG4gICAgICAgICAgY3JlYXRlKHtub2RlTmFtZTogbm9kZU5hbWV9LCBjdHgpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBmdW5jdGlvbiByZWdpc3RlckVsZW1lbnQoZWxDbGFzcywgb3B0X2VsTmFtZSkge1xuICAgICAgLyogUmVnaXN0ZXIgYSBWaWV3IGNsYXNzIGFnYWluc3QgYW4gYWJzdHJhY3Qgbm9kZSBuYW1lLiAqL1xuICAgICAgdmFyIGtleSA9IG9wdF9lbE5hbWUgfHwgZWxDbGFzcy5uYW1lO1xuICAgICAgdGhpcy5lbGVtZW50TWFwW2tleS50b1VwcGVyQ2FzZSgpXSA9IGVsQ2xhc3M7XG4gICAgfSxcblxuICAgIGZ1bmN0aW9uIGVsZW1lbnRGb3JOYW1lKG5vZGVOYW1lKSB7XG4gICAgICAvKiBGaW5kIGFuIEVsZW1lbnQgQ2xhc3MgZm9yIHRoZSBzcGVjaWZpZWQgbm9kZSBuYW1lLiAqL1xuICAgICAgcmV0dXJuIHRoaXMuZWxlbWVudE1hcFtub2RlTmFtZV07XG4gICAgfVxuICBdXG59KTtcblxuZm9hbS5fX2NvbnRleHRfXyA9IGZvYW0udTIuVTJDb250ZXh0LmNyZWF0ZSgpLl9fc3ViQ29udGV4dF9fO1xuXG5cbmZvYW0uQ0xBU1Moe1xuICByZWZpbmVzOiAnZm9hbS5jb3JlLkZPYmplY3QnLFxuICBtZXRob2RzOiBbXG4gICAgZnVuY3Rpb24gdG9FKGFyZ3MsIFgpIHtcbiAgICAgIHJldHVybiBmb2FtLnUyLlZpZXdTcGVjLmNyZWF0ZVZpZXcoXG4gICAgICAgIHsgY2xhc3M6ICdmb2FtLnUyLkRldGFpbFZpZXcnLCBzaG93QWN0aW9uczogdHJ1ZSwgZGF0YTogdGhpcyB9LFxuICAgICAgICBhcmdzLCB0aGlzLCBYKTtcbiAgICB9XG4gIF1cbn0pO1xuXG5cbmZvYW0uQ0xBU1Moe1xuICByZWZpbmVzOiAnZm9hbS5jb3JlLlNsb3QnLFxuICBtZXRob2RzOiBbXG4gICAgZnVuY3Rpb24gdG9FKCkgeyByZXR1cm4gdGhpczsgfVxuICBdXG59KTtcblxuXG5mb2FtLkNMQVNTKHtcbiAgcmVmaW5lczogJ2ZvYW0uY29yZS5FeHByZXNzaW9uU2xvdCcsXG4gIG1ldGhvZHM6IFtcbiAgICBmdW5jdGlvbiB0b0UoKSB7IHJldHVybiB0aGlzOyB9XG4gIF1cbn0pO1xuXG5cbmZvYW0uQ0xBU1Moe1xuICByZWZpbmVzOiAnZm9hbS5jb3JlLlByb3BlcnR5JyxcblxuICByZXF1aXJlczogW1xuICAgICdmb2FtLnUyLlRleHRGaWVsZCdcbiAgXSxcblxuICBwcm9wZXJ0aWVzOiBbXG4gICAge1xuICAgICAgLy8gSWYgdHJ1ZSwgdGhpcyBwcm9wZXJ0eSBpcyB0cmVhdGVkIGFzIGEgcHNlZG8tVTIgYXR0cmlidXRlLlxuICAgICAgbmFtZTogJ2F0dHJpYnV0ZScsXG4gICAgICB2YWx1ZTogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgIGNsYXNzOiAnZm9hbS51Mi5WaWV3U3BlYycsXG4gICAgICBuYW1lOiAndmlldycsXG4gICAgICB2YWx1ZTogeyBjbGFzczogJ2ZvYW0udTIuVGV4dEZpZWxkJyB9XG4gICAgfSxcbiAgICB7XG4gICAgICBjbGFzczogJ0VudW0nLFxuICAgICAgb2Y6ICdmb2FtLnUyLlZpc2liaWxpdHknLFxuICAgICAgbmFtZTogJ3Zpc2liaWxpdHknLFxuICAgICAgdmFsdWU6ICdSVydcbiAgICB9XG4gIF0sXG5cbiAgbWV0aG9kczogW1xuICAgIGZ1bmN0aW9uIHRvRShhcmdzLCBYKSB7XG4gICAgICB2YXIgZSA9IGZvYW0udTIuVmlld1NwZWMuY3JlYXRlVmlldyh0aGlzLnZpZXcsIGFyZ3MsIHRoaXMsIFgpO1xuXG4gICAgICBlLmZyb21Qcm9wZXJ0eSAmJiBlLmZyb21Qcm9wZXJ0eSh0aGlzKTtcblxuICAgICAgaWYgKCBYLmRhdGEkICYmICEgKCBhcmdzICYmICggYXJncy5kYXRhIHx8IGFyZ3MuZGF0YSQgKSApICkge1xuICAgICAgICBlLmRhdGEkID0gWC5kYXRhJC5kb3QodGhpcy5uYW1lKTtcbiAgICAgIH1cblxuICAgICAgLy8gZSBjb3VsZCBiZSBhIFNsb3QsIHNvIGNoZWNrIGlmIGFkZENsYXNzIGV4aXN0c1xuICAgICAgZS5hZGRDbGFzcyAmJiBlLmFkZENsYXNzKCdwcm9wZXJ0eS0nICsgdGhpcy5uYW1lKTtcblxuICAgICAgcmV0dXJuIGU7XG4gICAgfVxuICBdXG59KTtcblxuXG5mb2FtLkNMQVNTKHtcbiAgcmVmaW5lczogJ2ZvYW0uY29yZS5TdHJpbmcnLFxuICBwcm9wZXJ0aWVzOiBbXG4gICAge1xuICAgICAgY2xhc3M6ICdJbnQnLFxuICAgICAgbmFtZTogJ2Rpc3BsYXlXaWR0aCcsXG4gICAgICBleHByZXNzaW9uOiBmdW5jdGlvbih3aWR0aCkgeyByZXR1cm4gd2lkdGg7IH1cbiAgICB9XG4gIF1cbn0pO1xuXG5cbmZvYW0uQ0xBU1Moe1xuICByZWZpbmVzOiAnZm9hbS5jb3JlLlN0cmluZ0FycmF5JyxcbiAgcHJvcGVydGllczogW1xuICAgIFsgJ3ZpZXcnLCB7IGNsYXNzOiAnZm9hbS51Mi52aWV3LlN0cmluZ0FycmF5VmlldycgfSBdXG4gIF1cbn0pO1xuXG5cbmZvYW0uQ0xBU1Moe1xuICByZWZpbmVzOiAnZm9hbS5jb3JlLkRhdGUnLFxuICByZXF1aXJlczogWyAnZm9hbS51Mi5EYXRlVmlldycgXSxcbiAgcHJvcGVydGllczogW1xuICAgIFsgJ3ZpZXcnLCB7IGNsYXNzOiAnZm9hbS51Mi5EYXRlVmlldycgfSBdXG4gIF1cbn0pO1xuXG5cbmZvYW0uQ0xBU1Moe1xuICByZWZpbmVzOiAnZm9hbS5jb3JlLkRhdGVUaW1lJyxcbiAgcmVxdWlyZXM6IFsgJ2ZvYW0udTIuRGF0ZVRpbWVWaWV3JyBdLFxuICBwcm9wZXJ0aWVzOiBbXG4gICAgWyAndmlldycsIHsgY2xhc3M6ICdmb2FtLnUyLkRhdGVUaW1lVmlldycgfSBdXG4gIF1cbn0pO1xuXG5cbmZvYW0uQ0xBU1Moe1xuICByZWZpbmVzOiAnZm9hbS5jb3JlLlRpbWUnLFxuICByZXF1aXJlczogWyAnZm9hbS51Mi5UaW1lVmlldycgXSxcbiAgcHJvcGVydGllczogW1xuICAgIFsgJ3ZpZXcnLCB7IGNsYXNzOiAnZm9hbS51Mi5UaW1lVmlldycgfSBdXG4gIF1cbn0pO1xuXG5cbmZvYW0uQ0xBU1Moe1xuICByZWZpbmVzOiAnZm9hbS5jb3JlLkZsb2F0JyxcbiAgcmVxdWlyZXM6IFsgJ2ZvYW0udTIuRmxvYXRWaWV3JyBdLFxuICBwcm9wZXJ0aWVzOiBbXG4gICAgWyAnZGlzcGxheVdpZHRoJywgMTIgXSxcbiAgICBbICd2aWV3JywgeyBjbGFzczogJ2ZvYW0udTIuRmxvYXRWaWV3JyB9IF1cbiAgXVxufSk7XG5cblxuZm9hbS5DTEFTUyh7XG4gIHJlZmluZXM6ICdmb2FtLmNvcmUuSW50JyxcbiAgcmVxdWlyZXM6IFsgJ2ZvYW0udTIuSW50VmlldycgXSxcbiAgcHJvcGVydGllczogW1xuICAgIFsgJ2Rpc3BsYXlXaWR0aCcsIDEwIF0sXG4gICAgWyAndmlldycsIHsgY2xhc3M6ICdmb2FtLnUyLkludFZpZXcnIH0gXVxuICBdXG59KTtcblxuXG5mb2FtLkNMQVNTKHtcbiAgcmVmaW5lczogJ2ZvYW0uY29yZS5DdXJyZW5jeScsXG4gIHJlcXVpcmVzOiBbICdmb2FtLnUyLkN1cnJlbmN5VmlldycgXSxcbiAgcHJvcGVydGllczogW1xuICAgIFsgJ2Rpc3BsYXlXaWR0aCcsIDE1IF0sXG4gICAgWyAndmlldycsIHsgY2xhc3M6ICdmb2FtLnUyLkN1cnJlbmN5VmlldycgfSBdXG4gIF1cbn0pO1xuXG5cbmZvYW0uQ0xBU1Moe1xuICByZWZpbmVzOiAnZm9hbS5jb3JlLkJvb2xlYW4nLFxuICByZXF1aXJlczogWyAnZm9hbS51Mi5DaGVja0JveCcgXSxcbiAgcHJvcGVydGllczogW1xuICAgIFsgJ3ZpZXcnLCB7IGNsYXNzOiAnZm9hbS51Mi5DaGVja0JveCcgfSBdLFxuICBdXG59KTtcblxuXG5mb2FtLkNMQVNTKHtcbiAgcmVmaW5lczogJ2ZvYW0uY29yZS5Db2xvcicsXG4gIHByb3BlcnRpZXM6IFtcbiAgICB7XG4gICAgICBuYW1lOiAndmlldycsXG4gICAgICB2YWx1ZToge1xuICAgICAgICBjbGFzczogJ2ZvYW0udTIudmlldy5EdWFsVmlldycsXG4gICAgICAgIHZpZXdhOiAnZm9hbS51Mi5UZXh0RmllbGQnLFxuICAgICAgICB2aWV3YjogeyBjbGFzczogJ2ZvYW0udTIudmlldy5Db2xvclBpY2tlcicsIG9uS2V5OiB0cnVlIH1cbiAgICAgIH1cbiAgICB9XG4gIF1cbn0pO1xuXG5cbmZvYW0uQ0xBU1Moe1xuICByZWZpbmVzOiAnZm9hbS5jb3JlLkZPYmplY3RQcm9wZXJ0eScsXG4gIHByb3BlcnRpZXM6IFtcbiAgICB7XG4gICAgICBuYW1lOiAndmlldycsXG4gICAgICB2YWx1ZTogeyBjbGFzczogJ2ZvYW0udTIuRGV0YWlsVmlldycgfSxcbiAgICB9XG4gIF1cbn0pO1xuXG5cbmZvYW0uQ0xBU1Moe1xuICByZWZpbmVzOiAnZm9hbS5jb3JlLkZPYmplY3RBcnJheScsXG4gIHByb3BlcnRpZXM6IFtcbiAgICB7XG4gICAgICBuYW1lOiAndmlldycsXG4gICAgICB2YWx1ZTogeyBjbGFzczogJ2ZvYW0udTIudmlldy5GT2JqZWN0QXJyYXlWaWV3JyB9LFxuICAgIH1cbiAgXVxufSk7XG5cblxuZm9hbS5DTEFTUyh7XG4gIHJlZmluZXM6ICdmb2FtLmNvcmUuQ2xhc3MnLFxuICBwcm9wZXJ0aWVzOiBbXG4gICAgWyAndmlldycsIHsgY2xhc3M6ICdmb2FtLnUyLkNsYXNzVmlldycgfSBdXG4gIF1cbn0pO1xuXG5cbmZvYW0uQ0xBU1Moe1xuICByZWZpbmVzOiAnZm9hbS5jb3JlLlJlZmVyZW5jZScsXG4gIHByb3BlcnRpZXM6IFtcbiAgICB7XG4gICAgICBuYW1lOiAndmlldycsXG4gICAgICB2YWx1ZToge1xuICAgICAgICBjbGFzczogJ2ZvYW0udTIudmlldy5SZWZlcmVuY2VWaWV3J1xuICAgICAgfVxuICAgIH1cbiAgXVxufSk7XG5cblxuZm9hbS5DTEFTUyh7XG4gIHJlZmluZXM6ICdmb2FtLmNvcmUuRW51bScsXG4gIHByb3BlcnRpZXM6IFtcbiAgICBbICd2aWV3JywgICAgICAgICAgeyBjbGFzczogJ2ZvYW0udTIuRW51bVZpZXcnIH0gXSxcbiAgICBbICd0YWJsZUNlbGxWaWV3JywgZnVuY3Rpb24ob2JqKSB7IHJldHVybiB0aGlzLmdldChvYmopLmxhYmVsOyB9IF1cbiAgXVxufSk7XG5cblxuZm9hbS5DTEFTUyh7XG4gIHBhY2thZ2U6ICdmb2FtLnUyJyxcbiAgbmFtZTogJ0NvbnRyb2xsZXJWaWV3VHJhaXQnLFxuXG4gIGRvY3VtZW50YXRpb246ICdUcmFpdCBmb3IgYWRkaW5nIGEgQ29udHJvbGxlck1vZGUgY29udHJvbGxlck1vZGUgUHJvcGVydHkuJyxcblxuICBleHBvcnRzOiBbICdjb250cm9sbGVyTW9kZScgXSxcblxuICBwcm9wZXJ0aWVzOiBbXG4gICAge1xuICAgICAgY2xhc3M6ICdFbnVtJyxcbiAgICAgIG9mOiAnZm9hbS51Mi5Db250cm9sbGVyTW9kZScsXG4gICAgICBuYW1lOiAnY29udHJvbGxlck1vZGUnXG4gICAgfVxuICBdXG59KTtcblxuXG5mb2FtLkNMQVNTKHtcbiAgcGFja2FnZTogJ2ZvYW0udTInLFxuICBuYW1lOiAnVmlldycsXG4gIGV4dGVuZHM6ICdmb2FtLnUyLkVsZW1lbnQnLFxuXG4gIGRvY3VtZW50YXRpb246IGBcbiAgICBBIFZpZXcgaXMgYW4gRWxlbWVudCB1c2VkIHRvIGRpc3BsYXkgZGF0YS5cbiAgICAvLyBUT0RPOiBTaG91bGQgdGhlIGZvbGxvd2luZyBiZSBwcm9wZXJ0aWVzP1xuICAgIC8qXG4gICAge1xuICAgICAgdHlwZTogJ0Jvb2xlYW4nLFxuICAgICAgbmFtZTogJ3Nob3dWYWxpZGF0aW9uJyxcbiAgICAgIGRvY3VtZW50YXRpb246ICdTZXQgdG8gZmFsc2UgaWYgeW91IHdhbnQgdG8gaWdub3JlIGFueSAnICtcbiAgICAgICAgICAnJCRET0N7cmVmOlwiUHJvcGVydHkudmFsaWRhdGVcIn0gY2FsbHMuIE9uIGJ5IGRlZmF1bHQuJyxcbiAgICAgIGRlZmF1bHRWYWx1ZTogdHJ1ZVxuICAgIH0sXG4gICAge1xuICAgICAgdHlwZTogJ1N0cmluZycsXG4gICAgICBuYW1lOiAndmFsaWRhdGlvbkVycm9yXycsXG4gICAgICBkb2N1bWVudGF0aW9uOiAnVGhlIGFjdHVhbCBlcnJvciBtZXNzYWdlLiBOdWxsIG9yIHRoZSBlbXB0eSBzdHJpbmcgJyArXG4gICAgICAgICAgJ3doZW4gdGhlcmUgaXMgbm8gZXJyb3IuJyxcbiAgICB9XG4gICAgKi9cbiAgYCxcblxuICBleHBvcnRzOiBbICdkYXRhJyBdLFxuXG4gIHByb3BlcnRpZXM6IFtcbiAgICB7XG4gICAgICBjbGFzczogJ0VudW0nLFxuICAgICAgb2Y6ICdmb2FtLnUyLkNvbnRyb2xsZXJNb2RlJyxcbiAgICAgIG5hbWU6ICdjb250cm9sbGVyTW9kZScsXG4gICAgICBmYWN0b3J5OiBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMuX19jb250ZXh0X18uY29udHJvbGxlck1vZGUgfHwgZm9hbS51Mi5Db250cm9sbGVyTW9kZS5DUkVBVEU7IH1cbiAgICB9LFxuICAgIHtcbiAgICAgIG5hbWU6ICdkYXRhJyxcbiAgICAgIGF0dHJpYnV0ZTogdHJ1ZVxuICAgIH0sXG4gICAge1xuICAgICAgY2xhc3M6ICdFbnVtJyxcbiAgICAgIG9mOiAnZm9hbS51Mi5WaXNpYmlsaXR5JyxcbiAgICAgIG5hbWU6ICd2aXNpYmlsaXR5JyxcbiAgICAgIHBvc3RTZXQ6IGZ1bmN0aW9uKCkgeyB0aGlzLnVwZGF0ZU1vZGVfKHRoaXMubW9kZSk7IH0sXG4gICAgICBhdHRyaWJ1dGU6IHRydWUsXG4gICAgICB2YWx1ZTogJ1JXJ1xuICAgIH0sXG4gICAge1xuICAgICAgY2xhc3M6ICdFbnVtJyxcbiAgICAgIG9mOiAnZm9hbS51Mi5EaXNwbGF5TW9kZScsXG4gICAgICBuYW1lOiAnbW9kZScsXG4gICAgICBhdHRyaWJ1dGU6IHRydWUsXG4gICAgICBwb3N0U2V0OiBmdW5jdGlvbihfLCBtb2RlKSB7IHRoaXMudXBkYXRlTW9kZV8obW9kZSk7IH0sXG4gICAgICBleHByZXNzaW9uOiBmdW5jdGlvbih2aXNpYmlsaXR5LCBjb250cm9sbGVyTW9kZSkge1xuICAgICAgICBpZiAoIHZpc2liaWxpdHkgPT09IGZvYW0udTIuVmlzaWJpbGl0eS5STyApIHtcbiAgICAgICAgICByZXR1cm4gZm9hbS51Mi5EaXNwbGF5TW9kZS5STztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICggdmlzaWJpbGl0eSA9PT0gZm9hbS51Mi5WaXNpYmlsaXR5LkRJU0FCTEVEICkge1xuICAgICAgICAgIHJldHVybiBmb2FtLnUyLkRpc3BsYXlNb2RlLkRJU0FCTEVEO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCB2aXNpYmlsaXR5ID09PSBmb2FtLnUyLlZpc2liaWxpdHkuRklOQUwgJiZcbiAgICAgICAgICAgICBjb250cm9sbGVyTW9kZSAhPT0gZm9hbS51Mi5Db250cm9sbGVyTW9kZS5DUkVBVEUgKSB7XG4gICAgICAgICAgcmV0dXJuIGZvYW0udTIuRGlzcGxheU1vZGUuUk87XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY29udHJvbGxlck1vZGUgPT09IGZvYW0udTIuQ29udHJvbGxlck1vZGUuVklFVyA/XG4gICAgICAgICAgZm9hbS51Mi5EaXNwbGF5TW9kZS5STyA6XG4gICAgICAgICAgZm9hbS51Mi5EaXNwbGF5TW9kZS5SVyA7XG4gICAgICB9LFxuICAgICAgYXR0cmlidXRlOiB0cnVlXG4gICAgfVxuICBdLFxuXG4gIG1ldGhvZHM6IFtcbiAgICBmdW5jdGlvbiBpbml0RSgpIHtcbiAgICAgIHRoaXMuU1VQRVIoKTtcbiAgICAgIHRoaXMudXBkYXRlTW9kZV8odGhpcy5tb2RlKTtcbiAgICB9LFxuXG4gICAgZnVuY3Rpb24gdXBkYXRlTW9kZV8oKSB7XG4gICAgICAvLyBUZW1wbGF0ZSBtZXRob2QsIHRvIGJlIGltcGxlbWVudGVkIGluIHN1Yi1tb2RlbHNcbiAgICB9LFxuXG4gICAgZnVuY3Rpb24gZnJvbVByb3BlcnR5KHApIHtcbiAgICAgIHRoaXMudmlzaWJpbGl0eSA9IHAudmlzaWJpbGl0eTtcbiAgICB9XG4gIF1cbn0pO1xuXG5cbmZvYW0uQ0xBU1Moe1xuICBwYWNrYWdlOiAnZm9hbS51MicsXG4gIG5hbWU6ICdDb250cm9sbGVyJyxcbiAgZXh0ZW5kczogJ2ZvYW0udTIuRWxlbWVudCcsXG5cbiAgZG9jdW1lbnRhdGlvbjogJ0EgQ29udHJvbGxlciBpcyBhbiBFbGVtZW50IHdoaWNoIGV4cG9ydHMgaXRzZWxmIGFzIFwiZGF0YVwiLicsXG5cbiAgZXhwb3J0czogWyAnYXMgZGF0YScgXVxufSk7XG5cblxuZm9hbS5DTEFTUyh7XG4gIHJlZmluZXM6ICdmb2FtLmNvcmUuQWN0aW9uJyxcblxuICByZXF1aXJlczogW1xuICAgICdmb2FtLnUyLkFjdGlvblZpZXcnXG4gIF0sXG5cbiAgbWV0aG9kczogW1xuICAgIGZ1bmN0aW9uIHRvRShhcmdzLCBYKSB7XG4gICAgICB2YXIgdmlldyA9IGZvYW0udTIuVmlld1NwZWMuY3JlYXRlVmlldyhcbiAgICAgICAgeyBjbGFzczogJ2ZvYW0udTIuQWN0aW9uVmlldycsIGFjdGlvbjogdGhpcyB9LCBhcmdzLCB0aGlzLCBYKTtcblxuICAgICAgaWYgKCBYLmRhdGEkICYmICEgKCBhcmdzICYmICggYXJncy5kYXRhIHx8IGFyZ3MuZGF0YSQgKSApICkge1xuICAgICAgICB2aWV3LmRhdGEkID0gWC5kYXRhJDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHZpZXc7XG4gICAgfVxuICBdXG59KTtcblxuZm9hbS5DTEFTUyh7XG4gIHBhY2thZ2U6ICdmb2FtLnUyJyxcbiAgbmFtZTogJ1RhYmxlQ29sdW1ucycsXG5cbiAgZG9jdW1lbnRhdGlvbjogJ0F4aW9tIGZvciBzdG9yaW5nIFRhYmxlIENvbHVtbnMgaW5mb3JtYXRpb24gaW4gQ2xhc3MuIFVubGlrZSBtb3N0IEF4aW9tcywgZG9lc25cXCd0IG1vZGlmeSB0aGUgQ2xhc3MsIGJ1dCBpcyBqdXN0IHVzZWQgdG8gc3RvcmUgaW5mb3JtYXRpb24uJyxcblxuICBwcm9wZXJ0aWVzOiBbXG4gICAgWyAnbmFtZScsICd0YWJsZUNvbHVtbnMnIF0sXG4gICAgJ2NvbHVtbnMnXG4gIF1cbn0pO1xuXG5cbmZvYW0uQ0xBU1Moe1xuICBwYWNrYWdlOiAnZm9hbS51MicsXG4gIG5hbWU6ICdTZWFyY2hDb2x1bW5zJyxcblxuICBkb2N1bWVudGF0aW9uOiAnQXhpb20gZm9yIHN0b3JpbmcgVGFibGUgU2VhcmNoIENvbHVtbnMgaW5mb3JtYXRpb24gaW4gQ2xhc3MuIFVubGlrZSBtb3N0IEF4aW9tcywgZG9lc25cXCd0IG1vZGlmeSB0aGUgQ2xhc3MsIGJ1dCBpcyBqdXN0IHVzZWQgdG8gc3RvcmUgaW5mb3JtYXRpb24uJyxcblxuICBwcm9wZXJ0aWVzOiBbXG4gICAgWyAnbmFtZScsICdzZWFyY2hDb2x1bW5zJyBdLFxuICAgICdjb2x1bW5zJ1xuICBdXG59KTtcblxuXG5mb2FtLkNMQVNTKHtcbiAgcmVmaW5lczogJ2ZvYW0uY29yZS5Nb2RlbCcsXG5cbiAgcHJvcGVydGllczogW1xuICAgIHtcbiAgICAgIGNsYXNzOiAnU3RyaW5nJyxcbiAgICAgIG5hbWU6ICdjc3MnLFxuICAgICAgcG9zdFNldDogZnVuY3Rpb24oXywgY29kZSkge1xuICAgICAgICB0aGlzLmF4aW9tc18ucHVzaChmb2FtLnUyLkNTUy5jcmVhdGUoe2NvZGU6IGNvZGV9KSk7XG4gICAgICB9XG4gICAgfSxcbiAgICB7XG4gICAgICBkb2N1bWVudGF0aW9uOiBgXG4gICAgICAgIC8vIFRPRE86IHJlbW92ZSB3aGVuIGFsbCBjb2RlIHBvcnRlZFxuICAgICAgYCxcbiAgICAgIG5hbWU6ICd0YWJsZVByb3BlcnRpZXMnLFxuICAgICAgc2V0dGVyOiBmdW5jdGlvbihfLCBwcykge1xuICAgICAgICBjb25zb2xlLndhcm4oXCJEZXByZWNhdGVkIHVzZSBvZiB0YWJsZVByb3BlcnRpZXMuIFVzZSAndGFibGVDb2x1bW5zJyBpbnN0ZWFkLlwiKTtcbiAgICAgICAgdGhpcy50YWJsZUNvbHVtbnMgPSBwcztcbiAgICAgIH1cbiAgICB9LFxuICAgIHtcbiAgICAgIG5hbWU6ICd0YWJsZUNvbHVtbnMnLFxuICAgICAgcG9zdFNldDogZnVuY3Rpb24oXywgY3MpIHtcbiAgICAgICAgdGhpcy5heGlvbXNfLnB1c2goZm9hbS51Mi5UYWJsZUNvbHVtbnMuY3JlYXRlKHtjb2x1bW5zOiBjc30pKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHtcbiAgICAgIG5hbWU6ICdzZWFyY2hDb2x1bW5zJyxcbiAgICAgIHBvc3RTZXQ6IGZ1bmN0aW9uKF8sIGNzKSB7XG4gICAgICAgIHRoaXMuYXhpb21zXy5wdXNoKGZvYW0udTIuU2VhcmNoQ29sdW1ucy5jcmVhdGUoe2NvbHVtbnM6IGNzfSkpO1xuICAgICAgfVxuICAgIH1cbiAgXVxufSk7XG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBUaGUgRk9BTSBBdXRob3JzLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5mb2FtLkNMQVNTKHtcbiAgcGFja2FnZTogJ2ZvYW0udTInLFxuICBuYW1lOiAnTU5Sb3dGb3JtYXR0ZXInLFxuICBpbXBsZW1lbnRzOiBbICdmb2FtLnUyLlJvd0Zvcm1hdHRlcicgXSxcblxuICBheGlvbXM6IFtcbiAgICBmb2FtLnUyLkNTUy5jcmVhdGUoe1xuICAgICAgY29kZTogZnVuY3Rpb24gQ1NTKCkgey8qXG4gICAgICAgIC5tbi1yb3cge1xuICAgICAgICAgIGhlaWdodDogMTAwJTtcbiAgICAgICAgICBkaXNwbGF5OiBmbGV4O1xuICAgICAgICB9XG4gICAgICAgIC5tbi1yb3cgLnJvdy1pZCB7XG4gICAgICAgICAgZmxleC1ncm93OiAxO1xuICAgICAgICB9XG4gICAgICAgIC5tbi1yb3cgLnJvdy1kYXRhIHtcbiAgICAgICAgICBkaXNwbGF5OiBmbGV4O1xuICAgICAgICAgIGZsZXgtZ3JvdzogMztcbiAgICAgICAgfVxuICAgICAgICAubW4tcm93IC5yb3ctdmFsdWUge1xuICAgICAgICAgIGZsZXgtZ3JvdzogMTtcbiAgICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjZGRkO1xuICAgICAgICAgIGp1c3RpZnktY29udGVudDogY2VudGVyO1xuICAgICAgICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG4gICAgICAgICAgZGlzcGxheTogZmxleDtcbiAgICAgICAgfVxuICAgICAgICAubW4tcm93IC5yb3ctdmFsdWUueWVzIHtcbiAgICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjMGYwO1xuICAgICAgICB9XG4gICAgICAgIC5tbi1yb3cgLnJvdy12YWx1ZS5ubyB7XG4gICAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogI2YwMDtcbiAgICAgICAgfVxuICAgICAgICAubW4tcm93IC5yb3ctdmFsdWUgKiB7XG4gICAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogaW5oZXJpdDtcbiAgICAgICAgfVxuICAgICovfVxuICAgIH0pXG4gIF0sXG5cbiAgbWV0aG9kczogW1xuICAgIGZ1bmN0aW9uIGZvcm1hdChkYXRhKSB7XG4gICAgICAvLyBUT0RPKG1hcmtkaXR0bWVyKTogU2FuaXRpemUgZGF0YSB3aXRoIEhUTUwgbGliIGVzY2FwZVN0cmluZygpLlxuICAgICAgaWYgKCAhIGRhdGEgKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKCdSZW5kZXIgbWlzc2luZyBkYXRhJyk7XG4gICAgICAgIHJldHVybiBgPGRpdiBjbGFzcz1cIm1uLXJvd1wiPjwvZGl2PmA7XG4gICAgICB9XG4gICAgICB2YXIgZGF0YU1hcmt1cCA9ICcnO1xuICAgICAgdmFyIGlubmVyRGF0YSA9IGRhdGEuZGF0YTtcbiAgICAgIGZvciAoIHZhciBpID0gMDsgaSA8IGlubmVyRGF0YS5sZW5ndGg7IGkrKyApIHtcbiAgICAgICAgdmFyIGRhdHVtID0gaW5uZXJEYXRhW2ldO1xuICAgICAgICBkYXRhTWFya3VwICs9IGA8ZGl2IGNsYXNzPVwicm93LXZhbHVlICR7ZGF0dW0gPyAneWVzJyA6ICdubyd9XCI+XG4gICAgICAgICAgJHtkYXR1bSA/ICcmIzEwMDAzOycgOiAnJiMyMTU7J31cbiAgICAgICAgPC9kaXY+YDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBgPGRpdiBjbGFzcz1cIm1uLXJvd1wiPlxuICAgICAgICA8ZGl2IGNsYXNzPVwicm93LWlkXCI+JHtkYXRhLmlkfTwvZGl2PlxuICAgICAgICA8ZGl2IGNsYXNzPVwicm93LWRhdGFcIj5cbiAgICAgICAgICAke2RhdGFNYXJrdXB9XG4gICAgICAgIDwvZGl2PlxuICAgICAgPC9kaXY+YDtcbiAgICB9XG4gIF1cbn0pO1xuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTUgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuZm9hbS5DTEFTUyh7XG4gIHBhY2thZ2U6ICdmb2FtLnUyJyxcbiAgbmFtZTogJ1Byb2dyZXNzVmlldycsXG4gIGV4dGVuZHM6ICdmb2FtLnUyLlZpZXcnLFxuXG4gIGNzczogYFxuICAgIF4ge1xuICAgICAgbWFyZ2luOiAycHggMCAwIDEwcHg7XG4gICAgICBoZWlnaHQ6IDIzcHg7XG4gICAgICB3aWR0aDogMTgzcHg7XG4gICAgfVxuICBgLFxuXG4gIHByb3BlcnRpZXM6IFtcbiAgICBbICdub2RlTmFtZScsICdwcm9ncmVzcycgXVxuICBdLFxuXG4gIG1ldGhvZHM6IFtcbiAgICBmdW5jdGlvbiBpbml0RSgpIHtcbiAgICAgIHRoaXMuXG4gICAgICAgIGFkZENsYXNzKHRoaXMubXlDbGFzcygpKS5cbiAgICAgICAgYXR0cnMoe21heDogMTAwfSkuXG4gICAgICAgIGF0dHJTbG90KCkuZm9sbG93KHRoaXMuZGF0YSQpO1xuICAgIH1cbiAgXVxufSk7XG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxOCBUaGUgRk9BTSBBdXRob3JzLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG4vKiogQGxpY2Vuc2UgQ29weXJpZ2h0IDIwMTcgVGhlIEZPQU0gQXV0aG9ycywgQWxsIFJpZ2h0cyBSZXNlcnZlZC4gKi9cblxuZm9hbS5DTEFTUyh7XG4gIHBhY2thZ2U6ICdmb2FtLnUyJyxcbiAgbmFtZTogJ0xpc3RDcmVhdGVDb250cm9sbGVyJyxcbiAgZXh0ZW5kczogJ2ZvYW0udTIuc3RhY2suU3RhY2tWaWV3JyxcblxuICByZXF1aXJlczogW1xuICAgICdmb2FtLnUyLkRldGFpbFZpZXcnLFxuICAgICdmb2FtLnUyLlRhYmxlVmlldydcbiAgXSxcblxuICBleHBvcnRzOiBbXG4gICAgJ2NyZWF0ZUxhYmVsJyxcbiAgICAnZGFvJyxcbiAgICAnZGF0YSBhcyBzdGFjaycsXG4gICAgJ2RhdGEnLCAvLyBUT0RPOiBvdXRwdXQgYXMgJ3N0YWNrJ1xuICAgICdkZXRhaWxWaWV3JyxcbiAgICAnY3JlYXRlRGV0YWlsVmlldycsXG4gICAgJ2ZhY3RvcnknLFxuICAgICdtZW1lbnRvJyxcbiAgICAnc3VtbWFyeVZpZXcnLFxuICAgICdzaG93QWN0aW9ucydcbiAgXSxcblxuICBwcm9wZXJ0aWVzOiBbXG4gICAgJ2RhbycsXG4gICAge1xuICAgICAgbmFtZTogJ3N1bW1hcnlWaWV3JyxcbiAgICAgIHZhbHVlOiB7IGNsYXNzOiAnZm9hbS51Mi5UYWJsZVZpZXcnIH1cbiAgICB9LFxuICAgIHtcbiAgICAgIG5hbWU6ICdkZXRhaWxWaWV3JyxcbiAgICAgIHZhbHVlOiB7IGNsYXNzOiAnZm9hbS51Mi5EZXRhaWxWaWV3JyB9XG4gICAgfSxcbiAgICB7XG4gICAgICBuYW1lOiAnY3JlYXRlRGV0YWlsVmlldycsXG4gICAgICB2YWx1ZTogeyBjbGFzczogJ2ZvYW0udTIuRGV0YWlsVmlldycgfVxuICAgIH0sXG4gICAge1xuICAgICAgbmFtZTogJ2ZhY3RvcnknLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcy5kYW8ub2YuY3JlYXRlKCk7IH1cbiAgICB9LFxuICAgIHtcbiAgICAgIGNsYXNzOiAnU3RyaW5nJyxcbiAgICAgIG5hbWU6ICdjcmVhdGVMYWJlbCdcbiAgICB9LFxuICAgIFsgJ3Nob3dBY3Rpb25zJywgdHJ1ZSBdLFxuICAgICdtZW1lbnRvJ1xuICBdLFxuXG4gIG1ldGhvZHM6IFtcbiAgICBmdW5jdGlvbiBpbml0RSgpIHtcbiAgICAgIHRoaXMucHVzaCh0aGlzLkxpc3RDb250cm9sbGVyKTtcbiAgICB9LFxuXG4gICAgZnVuY3Rpb24gcHVzaCh2aWV3KSB7XG4gICAgICB0aGlzLmRhdGEucHVzaCh2aWV3LCB0aGlzKTtcbiAgICB9LFxuXG4gICAgZnVuY3Rpb24gYmFjaygpIHtcbiAgICAgIHRoaXMuZGF0YS5iYWNrKCk7XG4gICAgfVxuICBdLFxuXG4gIGFjdGlvbnM6IFtcbiAgICB7XG4gICAgICBuYW1lOiAnY3JlYXRlJyxcbiAgICAgIGNvZGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLmRhdGEucHVzaCh0aGlzLmRldGFpbFZpZXcpO1xuICAgICAgfVxuICAgIH1cbiAgXSxcblxuICBjbGFzc2VzOiBbXG4gICAge1xuICAgICAgbmFtZTogJ0xpc3RDb250cm9sbGVyJyxcbiAgICAgIGV4dGVuZHM6ICdmb2FtLnUyLkVsZW1lbnQnLFxuXG4gICAgICBpbXBvcnRzOiBbXG4gICAgICAgICdjcmVhdGVMYWJlbCcsXG4gICAgICAgICdkYW8nLFxuICAgICAgICAnbWVtZW50bycsXG4gICAgICAgICdzdGFjaycsXG4gICAgICAgICdzdW1tYXJ5VmlldydcbiAgICAgIF0sXG5cbiAgICAgIGV4cG9ydHM6IFsgJ2FzIGRhdGEnIF0sXG5cbiAgICAgIHByb3BlcnRpZXM6IFtcbiAgICAgICAge1xuICAgICAgICAgIG5hbWU6ICdzZWxlY3Rpb24nLFxuICAgICAgICAgIHBvc3RTZXQ6IGZ1bmN0aW9uKG8sIG4pIHtcbiAgICAgICAgICAgIHRoaXMubWVtZW50byA9IG4gPyBuLmlkIDogJyc7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICBdLFxuXG4gICAgICBtZXRob2RzOiBbXG4gICAgICAgIGZ1bmN0aW9uIGluaXRFKCkge1xuICAgICAgICAgIHRoaXMubWVtZW50byQuc3ViKHRoaXMub25NZW1lbnRvQ2hhbmdlKTtcbiAgICAgICAgICB0aGlzLm9uTWVtZW50b0NoYW5nZSgpO1xuXG4gICAgICAgICAgdGhpc1xuICAgICAgICAgICAgLnN0YXJ0KHRoaXMuQ1JFQVRFLCB0aGlzLmNyZWF0ZUxhYmVsICYmIHtsYWJlbDogdGhpcy5jcmVhdGVMYWJlbH0pLnN0eWxlKHtmbG9hdDogJ3JpZ2h0J30pLmVuZCgpXG4gICAgICAgICAgICAudGFnKHRoaXMuc3VtbWFyeVZpZXcsIHtkYXRhOiB0aGlzLmRhbywgc2VsZWN0aW9uJDogdGhpcy5zZWxlY3Rpb24kfSk7XG5cbiAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgICAgdGhpcy5zZWxlY3Rpb24kLnN1YihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGlmICggc2VsZi5zZWxlY3Rpb24gKSB7XG4gICAgICAgICAgICAgIHZhciBzZWxlY3Rpb24gPSBzZWxmLnNlbGVjdGlvbjtcbiAgICAgICAgICAgICAgc2VsZi5zdGFjay5wdXNoKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmb2FtLnUyLkxpc3RDcmVhdGVDb250cm9sbGVyLlZpZXdDb250cm9sbGVyLmNyZWF0ZSh7b2JqOiBzZWxlY3Rpb259LCBzZWxmKTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIF0sXG5cbiAgICAgIGFjdGlvbnM6IFtcbiAgICAgICAgZnVuY3Rpb24gY3JlYXRlKFgpIHtcbiAgICAgICAgICB0aGlzLnN0YWNrLnB1c2goZnVuY3Rpb24oKSB7IHJldHVybiBmb2FtLnUyLkxpc3RDcmVhdGVDb250cm9sbGVyLkNyZWF0ZUNvbnRyb2xsZXIuY3JlYXRlKG51bGwsIFgpOyB9KTtcbiAgICAgICAgfVxuICAgICAgXSxcblxuICAgICAgbGlzdGVuZXJzOiBbXG4gICAgICAgIGZ1bmN0aW9uIG9uTWVtZW50b0NoYW5nZSgpIHtcbiAgICAgICAgICBpZiAoIHRoaXMubWVtZW50byApIHtcbiAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgICAgIHRoaXMuZGFvLmZpbmQodGhpcy5tZW1lbnRvKS50aGVuKGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgICAgICAgc2VsZi5zZWxlY3Rpb24gPSBvYmo7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5zZWxlY3Rpb24gPSBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgXVxuICAgIH0sXG5cbiAgICB7XG4gICAgICBuYW1lOiAnQ3JlYXRlQ29udHJvbGxlcicsXG4gICAgICBleHRlbmRzOiAnZm9hbS51Mi5FbGVtZW50JyxcblxuICAgICAgaW1wb3J0czogWyAnY3JlYXRlRGV0YWlsVmlldycsICdkZXRhaWxWaWV3JywgJ3N0YWNrJywgJ2RhbycsICdmYWN0b3J5JywgJ3Nob3dBY3Rpb25zJyBdLFxuICAgICAgZXhwb3J0czogWyAnYXMgZGF0YScgXSxcblxuICAgICAgcHJvcGVydGllczogW1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6ICdvYmonLFxuICAgICAgICAgICAgZmFjdG9yeTogZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLmZhY3RvcnkoKTsgfVxuICAgICAgICAgIH1cbiAgICAgIF0sXG5cbiAgICAgIG1ldGhvZHM6IFtcbiAgICAgICAgZnVuY3Rpb24gaW5pdEUoKSB7XG4gICAgICAgICAgdmFyIHZpZXcgPSB0aGlzLmNyZWF0ZURldGFpbFZpZXcgPyB0aGlzLmNyZWF0ZURldGFpbFZpZXcgOiB0aGlzLmRldGFpbFZpZXdcbiAgICAgICAgICB0aGlzLnRhZyh2aWV3LCB7ZGF0YTogdGhpcy5vYmp9KVxuICAgICAgICAgIGlmICggdGhpcy5zaG93QWN0aW9ucyApIHRoaXMuYWRkKHRoaXMuQ0FOQ0VMLCB0aGlzLlNBVkUpO1xuICAgICAgICB9XG4gICAgICBdLFxuXG4gICAgICBhY3Rpb25zOiBbXG4gICAgICAgIGZ1bmN0aW9uIGNhbmNlbChYKSB7XG4gICAgICAgICAgdGhpcy5zdGFjay5iYWNrKCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZnVuY3Rpb24gc2F2ZShYKSB7XG4gICAgICAgICAgdGhpcy5kYW8ucHV0KHRoaXMub2JqKTtcbiAgICAgICAgICB0aGlzLnN0YWNrLmJhY2soKTtcbiAgICAgICAgfVxuICAgICAgXVxuICAgIH0sXG5cbiAgICB7XG4gICAgICBuYW1lOiAnVmlld0NvbnRyb2xsZXInLFxuICAgICAgZXh0ZW5kczogJ2ZvYW0udTIuRWxlbWVudCcsXG5cbiAgICAgIGltcG9ydHM6IFsgJ3N0YWNrJywgJ2RldGFpbFZpZXcnLCAnc2hvd0FjdGlvbnMnIF0sXG4gICAgICBleHBvcnRzOiBbICdhcyBkYXRhJyBdLFxuXG4gICAgICBwcm9wZXJ0aWVzOiBbXG4gICAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogJ29iaicsXG4gICAgICAgICAgICBmYWN0b3J5OiBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMuZmFjdG9yeSgpOyB9XG4gICAgICAgICAgfVxuICAgICAgXSxcblxuICAgICAgbWV0aG9kczogW1xuICAgICAgICBmdW5jdGlvbiBpbml0RSgpIHtcbiAgICAgICAgICB0aGlzLnRhZyh0aGlzLmRldGFpbFZpZXcsIHtkYXRhOiB0aGlzLm9iaiwgY29udHJvbGxlck1vZGU6IGZvYW0udTIuQ29udHJvbGxlck1vZGUuVklFV30pXG4gICAgICAgICAgaWYgKCB0aGlzLnNob3dBY3Rpb25zICkgdGhpcy5hZGQodGhpcy5CQUNLKTtcbiAgICAgICAgfVxuICAgICAgXSxcblxuICAgICAgYWN0aW9uczogW1xuICAgICAgICBmdW5jdGlvbiBiYWNrKFgpIHtcbiAgICAgICAgICB0aGlzLnN0YWNrLmJhY2soKTtcbiAgICAgICAgfVxuICAgICAgXVxuICAgIH1cbiAgXVxufSk7XG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBUaGUgRk9BTSBBdXRob3JzLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5mb2FtLkNMQVNTKHtcbiAgcGFja2FnZTogJ2ZvYW0udmVyc2lvbicsXG4gIG5hbWU6ICdWZXJzaW9uVHJhaXQnLFxuXG4gIHByb3BlcnRpZXM6IFtcbiAgICB7XG4gICAgICBjbGFzczogJ0ludCcsXG4gICAgICBuYW1lOiAndmVyc2lvbl8nLFxuICAgICAgdmFsdWU6IC0xXG4gICAgfSxcbiAgICB7XG4gICAgICBjbGFzczogJ0Jvb2xlYW4nLFxuICAgICAgbmFtZTogJ2RlbGV0ZWRfJ1xuICAgIH1cbiAgXVxufSk7XG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBUaGUgRk9BTSBBdXRob3JzLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5mb2FtLkNMQVNTKHtcbiAgcGFja2FnZTogJ2ZvYW0udmVyc2lvbicsXG4gIG5hbWU6ICdWZXJzaW9uZWRDbGFzcycsXG5cbiAgYXhpb21zOiBbXG4gICAgZm9hbS5wYXR0ZXJuLk11bHRpdG9uLmNyZWF0ZSh7IHByb3BlcnR5OiAnb2YnIH0pXG4gIF0sXG5cbiAgcmVxdWlyZXM6IFtcbiAgICAnZm9hbS5jb3JlLk1vZGVsJyxcbiAgXSxcblxuICBwcm9wZXJ0aWVzOiBbXG4gICAge1xuICAgICAgY2xhc3M6ICdDbGFzcycsXG4gICAgICBuYW1lOiAnb2YnLFxuICAgICAgcmVxdWlyZWQ6IHRydWVcbiAgICB9LFxuICAgIHtcbiAgICAgIGNsYXNzOiAnU3RyaW5nJyxcbiAgICAgIG5hbWU6ICdwYWNrYWdlJyxcbiAgICAgIGZhY3Rvcnk6IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcy5vZi5wYWNrYWdlOyB9XG4gICAgfSxcbiAgICB7XG4gICAgICBjbGFzczogJ1N0cmluZycsXG4gICAgICBuYW1lOiAnbmFtZScsXG4gICAgICBmYWN0b3J5OiBmdW5jdGlvbigpIHsgcmV0dXJuIGBWZXJzaW9uZWQke3RoaXMub2YubmFtZX1gOyB9XG4gICAgfSxcbiAgICB7XG4gICAgICBjbGFzczogJ1N0cmluZycsXG4gICAgICBuYW1lOiAnaWQnLFxuICAgICAgZmFjdG9yeTogZnVuY3Rpb24oKSB7IHJldHVybiBgJHt0aGlzLnBhY2thZ2V9LiR7dGhpcy5uYW1lfWA7IH1cbiAgICB9LFxuICAgIHtcbiAgICAgIGNsYXNzOiAnRk9iamVjdFByb3BlcnR5JyxcbiAgICAgIG9mOiAnTW9kZWwnLFxuICAgICAgbmFtZTogJ3ZlcnNpb25lZE1vZGVsJyxcbiAgICAgIGZhY3Rvcnk6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5Nb2RlbC5jcmVhdGUoe1xuICAgICAgICAgIHBhY2thZ2U6IHRoaXMucGFja2FnZSxcbiAgICAgICAgICBuYW1lOiB0aGlzLm5hbWUsXG4gICAgICAgICAgZXh0ZW5kczogdGhpcy5vZi5pZCxcbiAgICAgICAgICBpbXBsZW1lbnRzOiBbICdmb2FtLnZlcnNpb24uVmVyc2lvblRyYWl0JyBdXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0sXG4gICAge1xuICAgICAgbmFtZTogJ3ZlcnNpb25lZENscycsXG4gICAgICBmYWN0b3J5OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYnVpbGRDbGFzc18oKTtcbiAgICAgIH1cbiAgICB9XG4gIF0sXG5cbiAgbWV0aG9kczogW1xuICAgIGZ1bmN0aW9uIGluaXQoKSB7XG4gICAgICB0aGlzLnZhbGlkYXRlKCk7XG4gICAgICB0aGlzLlNVUEVSKCk7XG4gICAgfSxcblxuICAgIGZ1bmN0aW9uIGJ1aWxkQ2xhc3NfKCkge1xuICAgICAgdGhpcy52ZXJzaW9uZWRNb2RlbC52YWxpZGF0ZSgpO1xuICAgICAgdmFyIGNscyA9IHRoaXMudmVyc2lvbmVkTW9kZWwuYnVpbGRDbGFzcygpO1xuICAgICAgY2xzLnZhbGlkYXRlKCk7XG4gICAgICB0aGlzLl9fc3ViQ29udGV4dF9fLnJlZ2lzdGVyKGNscyk7XG4gICAgICBmb2FtLnBhY2thZ2UucmVnaXN0ZXJDbGFzcyhjbHMpO1xuXG4gICAgICByZXR1cm4gdGhpcy52ZXJzaW9uZWRNb2RlbC5idWlsZENsYXNzKCk7XG4gICAgfVxuICBdXG59KTtcbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IFRoZSBGT0FNIEF1dGhvcnMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmZvYW0uQ0xBU1Moe1xuICBwYWNrYWdlOiAnZm9hbS52ZXJzaW9uJyxcbiAgbmFtZTogJ1ZlcnNpb25lZENsYXNzRmFjdG9yeScsXG5cbiAgcmVxdWlyZXM6IFtcbiAgICAnZm9hbS52ZXJzaW9uLlZlcnNpb25UcmFpdCcsXG4gICAgJ2ZvYW0udmVyc2lvbi5WZXJzaW9uZWRDbGFzcydcbiAgXSxcblxuICBtZXRob2RzOiBbXG4gICAgZnVuY3Rpb24gZ2V0KGNscykge1xuICAgICAgcmV0dXJuIHRoaXMuVmVyc2lvblRyYWl0LmlzU3ViQ2xhc3MoY2xzKSA/IGNscyA6XG4gICAgICAgICAgdGhpcy5WZXJzaW9uZWRDbGFzcy5jcmVhdGUoeyBvZjogY2xzIH0pLnZlcnNpb25lZENscztcbiAgICB9XG4gIF1cbn0pO1xuXG5mb2FtLkNMQVNTKHtcbiAgcGFja2FnZTogJ2ZvYW0udmVyc2lvbicsXG4gIG5hbWU6ICdWZXJzaW9uZWRDbGFzc0ZhY3RvcnlTaW5nbGV0b24nLFxuICBleHRlbmRzOiAnZm9hbS52ZXJzaW9uLlZlcnNpb25lZENsYXNzRmFjdG9yeScsXG5cbiAgYXhpb21zOiBbIGZvYW0ucGF0dGVybi5TaW5nbGV0b24uY3JlYXRlKCkgXSxcbn0pO1xuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTYgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuZm9hbS5JTlRFUkZBQ0Uoe1xuICBwYWNrYWdlOiAnZm9hbS5kYW8nLFxuICBuYW1lOiAnU2luaycsXG5cbiAgZG9jdW1lbnRhdGlvbjogJ0ludGVyZmFjZSBmb3IgcmVjZWl2aW5nIGluZm9ybWF0aW9uIHVwZGF0ZXMuIFByaW1hcmlseSB1c2VkIGFzIHRoZSB0YXJnZXQgZm9yIERBTy5zZWxlY3QoKSBjYWxscy4nLFxuXG4gIG1ldGhvZHM6IFtcbiAgICB7XG4gICAgICBuYW1lOiAncHV0JyxcbiAgICAgIHJldHVybnM6ICcnLFxuICAgICAgYXJnczogW1xuICAgICAgICB7XG4gICAgICAgICAgbmFtZTogJ29iaicsXG4gICAgICAgICAgc3dpZnRUeXBlOiAnQW55J1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgbmFtZTogJ3N1YicsXG4gICAgICAgICAgc3dpZnRUeXBlOiAnRGV0YWNoYWJsZScsXG4gICAgICAgIH0sXG4gICAgICBdLFxuICAgIH0sXG4gICAge1xuICAgICAgbmFtZTogJ3JlbW92ZScsXG4gICAgICByZXR1cm5zOiAnJyxcbiAgICAgIGFyZ3M6IFtcbiAgICAgICAge1xuICAgICAgICAgIG5hbWU6ICdvYmonLFxuICAgICAgICAgIHN3aWZ0VHlwZTogJ0FueSdcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIG5hbWU6ICdzdWInLFxuICAgICAgICAgIHN3aWZ0VHlwZTogJ0RldGFjaGFibGUnLFxuICAgICAgICB9LFxuICAgICAgXSxcbiAgICB9LFxuICAgIHtcbiAgICAgIG5hbWU6ICdlb2YnLFxuICAgICAgcmV0dXJuczogJycsXG4gICAgICBhcmdzOiBbXSxcbiAgICB9LFxuICAgIHtcbiAgICAgIG5hbWU6ICdyZXNldCcsXG4gICAgICByZXR1cm5zOiAnJyxcbiAgICAgIGFyZ3M6IFtcbiAgICAgICAge1xuICAgICAgICAgIG5hbWU6ICdzdWInLFxuICAgICAgICAgIHN3aWZ0VHlwZTogJ0RldGFjaGFibGUnLFxuICAgICAgICB9LFxuICAgICAgXSxcbiAgICB9XG4gIF1cbn0pO1xuXG5cbmZvYW0uQ0xBU1Moe1xuICBwYWNrYWdlOiAnZm9hbS5kYW8nLFxuICBuYW1lOiAnUHJveHlTaW5rJyxcbiAgaW1wbGVtZW50czogWyAnZm9hbS5kYW8uU2luaycgXSxcblxuICBkb2N1bWVudGF0aW9uOiAnUHJveHkgZm9yIFNpbmsgaW50ZXJmYWNlLicsXG5cbiAgcHJvcGVydGllczogW1xuICAgIHtcbiAgICAgIGNsYXNzOiAnUHJveHknLFxuICAgICAgb2Y6ICdmb2FtLmRhby5TaW5rJyxcbiAgICAgIG5hbWU6ICdkZWxlZ2F0ZScsXG4gICAgICBmYWN0b3J5OiBmdW5jdGlvbigpIHsgcmV0dXJuIGZvYW0uZGFvLkFycmF5U2luay5jcmVhdGUoKTsgfVxuICAgIH1cbiAgXVxufSk7XG5cblxuZm9hbS5DTEFTUyh7XG4gIHBhY2thZ2U6ICdmb2FtLmRhbycsXG4gIG5hbWU6ICdBYnN0cmFjdFNpbmsnLFxuICBpbXBsZW1lbnRzOiBbICdmb2FtLmRhby5TaW5rJyBdLFxuXG4gIGRvY3VtZW50YXRpb246ICdBYnN0cmFjdCBiYXNlIGNsYXNzIGZvciBpbXBsZW1lbnRpbmcgU2luayBpbnRlcmZhY2UuJyxcblxuICBtZXRob2RzOiBbXG4gICAge1xuICAgICAgbmFtZTogJ3B1dCcsXG4gICAgICBjb2RlOiBmdW5jdGlvbigpIHt9LFxuICAgICAgc3dpZnRDb2RlOiAnLy8gTk9PUCcsXG4gICAgfSxcbiAgICB7XG4gICAgICBuYW1lOiAncmVtb3ZlJyxcbiAgICAgIGNvZGU6IGZ1bmN0aW9uKCkge30sXG4gICAgICBzd2lmdENvZGU6ICcvLyBOT09QJyxcbiAgICB9LFxuICAgIHtcbiAgICAgIG5hbWU6ICdlb2YnLFxuICAgICAgY29kZTogZnVuY3Rpb24oKSB7fSxcbiAgICAgIHN3aWZ0Q29kZTogJy8vIE5PT1AnLFxuICAgIH0sXG4gICAge1xuICAgICAgbmFtZTogJ3Jlc2V0JyxcbiAgICAgIGNvZGU6IGZ1bmN0aW9uKCkge30sXG4gICAgICBzd2lmdENvZGU6ICcvLyBOT09QJyxcbiAgICB9XG4gIF1cbn0pO1xuXG5cbmZvYW0uQ0xBU1Moe1xuICBwYWNrYWdlOiAnZm9hbS5kYW8nLFxuICBuYW1lOiAnUGlwZVNpbmsnLFxuICBleHRlbmRzOiAnZm9hbS5kYW8uUHJveHlTaW5rJyxcbiAgYXhpb21zOiBbXG4gICAge1xuICAgICAgY2xhc3M6ICdmb2FtLmJveC5SZW1vdGUnLFxuICAgICAgY2xpZW50Q2xhc3M6ICdmb2FtLmRhby5DbGllbnRTaW5rJ1xuICAgIH1cbiAgXSxcbiAgcHJvcGVydGllczogW1xuICAgICdkYW8nXG4gIF0sXG4gIG1ldGhvZHM6IFtcbiAgICBmdW5jdGlvbiByZXNldChzdWIpIHtcbiAgICAgIHRoaXMuU1VQRVIoc3ViKTtcbiAgICAgIHRoaXMuZGFvLnNlbGVjdCh0aGlzLmRlbGVnYXRlKTtcbiAgICB9XG4gIF1cbn0pO1xuXG5cbmZvYW0uQ0xBU1Moe1xuICBwYWNrYWdlOiAnZm9hbS5kYW8nLFxuICBuYW1lOiAnUmVzZXRMaXN0ZW5lcicsXG4gIGV4dGVuZHM6ICdmb2FtLmRhby5Qcm94eVNpbmsnLFxuICBkb2N1bWVudGF0aW9uOiAnVHVybnMgYWxsIHNpbmsgZXZlbnRzIGludG8gYSByZXNldCBldmVudC4nLFxuICBtZXRob2RzOiBbXG4gICAge1xuICAgICAgbmFtZTogJ3B1dCcsXG4gICAgICBjb2RlOiBmdW5jdGlvbiBwdXQoXywgc3ViKSB7XG4gICAgICAgIHRoaXMucmVzZXQoc3ViKTtcbiAgICAgIH0sXG4gICAgICBzd2lmdENvZGU6ICdyZXNldChzdWIpJyxcbiAgICB9LFxuICAgIHtcbiAgICAgIG5hbWU6ICdyZW1vdmUnLFxuICAgICAgY29kZTogZnVuY3Rpb24gcmVtb3ZlKF8sIHN1Yikge1xuICAgICAgICB0aGlzLnJlc2V0KHN1Yik7XG4gICAgICB9LFxuICAgICAgc3dpZnRDb2RlOiAncmVzZXQoc3ViKScsXG4gICAgfSxcbiAgXVxufSk7XG5cblxuZm9hbS5DTEFTUyh7XG4gIHBhY2thZ2U6ICdmb2FtLmRhbycsXG4gIG5hbWU6ICdEQU9TbG90JyxcbiAgaW1wbGVtZW50czogWydmb2FtLmNvcmUuU2xvdCddLFxuICBleHRlbmRzOiAnZm9hbS5kYW8uUmVzZXRMaXN0ZW5lcicsXG4gIHByb3BlcnRpZXM6IFtcbiAgICB7XG4gICAgICBuYW1lOiAnZGFvJyxcbiAgICAgIHBvc3RTZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLnN0YXJ0XygpO1xuICAgICAgfVxuICAgIH0sXG4gICAge1xuICAgICAgbmFtZTogJ3NpbmsnLFxuICAgICAgcG9zdFNldDogZnVuY3Rpb24oXywgcykge1xuICAgICAgICB0aGlzLnZhbHVlID0gcztcbiAgICAgICAgdGhpcy5zdGFydF8oKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHtcbiAgICAgIG5hbWU6ICd2YWx1ZSdcbiAgICB9LFxuICAgIHtcbiAgICAgIG5hbWU6ICdzdWJzY3JpcHRpb24nLFxuICAgICAgcG9zdFNldDogZnVuY3Rpb24ob2xkLCBudSkge1xuICAgICAgICBvbGQgJiYgb2xkLmRldGFjaCgpO1xuICAgICAgICB0aGlzLm9uRGV0YWNoKG51KTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHtcbiAgICAgIGNsYXNzOiAnSW50JyxcbiAgICAgIG5hbWU6ICdiYXRjaCcsXG4gICAgICB2YWx1ZTogMFxuICAgIH1cbiAgXSxcblxuICBtZXRob2RzOiBbXG4gICAgZnVuY3Rpb24gc3ViKGwpIHtcbiAgICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID09PSAxID9cbiAgICAgICAgdGhpcy5TVVBFUigncHJvcGVydHlDaGFuZ2UnLCAndmFsdWUnLCBsKSA6XG4gICAgICAgIHRoaXMuU1VQRVIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9LFxuXG4gICAgZnVuY3Rpb24gZ2V0KCkgeyByZXR1cm4gdGhpcy52YWx1ZTsgfSxcblxuICAgIGZ1bmN0aW9uIHNldCgpIHt9LFxuXG4gICAgZnVuY3Rpb24gc3RhcnRfKCkge1xuICAgICAgLy8gRG9uJ3Qgc3RhcnQgdGlsbCBib3RoIHNpbmsgYW5kIGRhbyBhcmUgc2V0LlxuICAgICAgaWYgKCAhIHRoaXMuZGFvIHx8ICEgdGhpcy5zaW5rICkgcmV0dXJuO1xuXG4gICAgICB0aGlzLnN1YnNjcmlwdGlvbiA9IHRoaXMuZGFvLmxpc3Rlbih0aGlzKTtcbiAgICAgIHRoaXMudXBkYXRlKCk7XG4gICAgfSxcblxuICAgIGZ1bmN0aW9uIHJlc2V0KCkge1xuICAgICAgdGhpcy51cGRhdGUoKTtcbiAgICB9XG4gIF0sXG4gIGxpc3RlbmVyczogW1xuICAgIHtcbiAgICAgIG5hbWU6ICd1cGRhdGUnLFxuICAgICAgaXNNZXJnZWQ6IDEwMCxcbiAgICAgIGNvZGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgYmF0Y2ggPSArK3RoaXMuYmF0Y2g7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgdGhpcy5kYW8uc2VsZWN0KHRoaXMuc2luay5jbG9uZSgpKS50aGVuKGZ1bmN0aW9uKHMpIHtcbiAgICAgICAgICBpZiAoIHNlbGYuYmF0Y2ggIT09IGJhdGNoICkgcmV0dXJuO1xuXG4gICAgICAgICAgc2VsZi52YWx1ZSA9IHM7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgXVxufSk7XG5cblxuZm9hbS5DTEFTUyh7XG4gIHBhY2thZ2U6ICdmb2FtLmRhbycsXG4gIG5hbWU6ICdRdWlja1NpbmsnLFxuICBleHRlbmRzOiAnZm9hbS5kYW8uQWJzdHJhY3RTaW5rJyxcblxuICBheGlvbXM6IFtcbiAgICB7XG4gICAgICBjbGFzczogJ2ZvYW0uYm94LlJlbW90ZScsXG4gICAgICBjbGllbnRDbGFzczogJ2ZvYW0uZGFvLkNsaWVudFNpbmsnXG4gICAgfVxuICBdLFxuICBwcm9wZXJ0aWVzOiBbXG4gICAge1xuICAgICAgY2xhc3M6ICdGdW5jdGlvbicsXG4gICAgICBuYW1lOiAncHV0Rm4nXG4gICAgfSxcbiAgICB7XG4gICAgICBjbGFzczogJ0Z1bmN0aW9uJyxcbiAgICAgIG5hbWU6ICdyZW1vdmVGbidcbiAgICB9LFxuICAgIHtcbiAgICAgIGNsYXNzOiAnRnVuY3Rpb24nLFxuICAgICAgbmFtZTogJ2VvZkZuJ1xuICAgIH0sXG4gICAge1xuICAgICAgY2xhc3M6ICdGdW5jdGlvbicsXG4gICAgICBuYW1lOiAncmVzZXRGbidcbiAgICB9XG4gIF0sXG5cbiAgbWV0aG9kczogW1xuICAgIGZ1bmN0aW9uIHB1dCgpIHtcbiAgICAgIHJldHVybiB0aGlzLnB1dEZuICYmIHRoaXMucHV0Rm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9LFxuXG4gICAgZnVuY3Rpb24gcmVtb3ZlKCkge1xuICAgICAgcmV0dXJuIHRoaXMucmVtb3ZlRm4gJiYgdGhpcy5yZW1vdmVGbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH0sXG5cbiAgICBmdW5jdGlvbiBlb2YoKSB7XG4gICAgICByZXR1cm4gdGhpcy5lb2ZGbiAmJiB0aGlzLmVvZkZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfSxcblxuICAgIGZ1bmN0aW9uIHJlc2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMucmVzZXRGbiAmJiB0aGlzLnJlc2V0Rm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gIF1cbn0pO1xuXG5cbmZvYW0uQ0xBU1Moe1xuICBwYWNrYWdlOiAnZm9hbS5kYW8nLFxuICBuYW1lOiAnQW5vbnltb3VzU2luaycsXG4gIGltcGxlbWVudHM6IFsgJ2ZvYW0uZGFvLlNpbmsnIF0sXG5cbiAgYXhpb21zOiBbXG4gICAge1xuICAgICAgY2xhc3M6ICdmb2FtLmJveC5SZW1vdGUnLFxuICAgICAgY2xpZW50Q2xhc3M6ICdmb2FtLmRhby5DbGllbnRTaW5rJ1xuICAgIH1cbiAgXSxcblxuICBwcm9wZXJ0aWVzOiBbICdzaW5rJyBdLFxuXG4gIG1ldGhvZHM6IFtcbiAgICBmdW5jdGlvbiBwdXQob2JqLCBzdWIpIHtcbiAgICAgIHZhciBzID0gdGhpcy5zaW5rO1xuICAgICAgcyAmJiBzLnB1dCAmJiBzLnB1dChvYmosIHN1Yik7XG4gICAgfSxcbiAgICBmdW5jdGlvbiByZW1vdmUob2JqLCBzdWIpIHtcbiAgICAgIHZhciBzID0gdGhpcy5zaW5rO1xuICAgICAgcyAmJiBzLnJlbW92ZSAmJiBzLnJlbW92ZShvYmosIHN1Yik7XG4gICAgfSxcblxuICAgIGZ1bmN0aW9uIGVvZigpIHtcbiAgICAgIHZhciBzID0gdGhpcy5zaW5rO1xuICAgICAgcyAmJiBzLmVvZiAmJiBzLmVvZigpO1xuICAgIH0sXG4gICAgZnVuY3Rpb24gcmVzZXQoc3ViKSB7XG4gICAgICB2YXIgcyA9IHRoaXMuc2luaztcbiAgICAgIHMgJiYgcy5yZXNldCAmJiBzLnJlc2V0KHN1Yik7XG4gICAgfVxuICBdXG59KTtcblxuXG5mb2FtLkNMQVNTKHtcbiAgcGFja2FnZTogJ2ZvYW0uZGFvJyxcbiAgbmFtZTogJ1ByZWRpY2F0ZWRTaW5rJyxcbiAgZXh0ZW5kczogJ2ZvYW0uZGFvLlByb3h5U2luaycsXG5cbiAgcHJvcGVydGllczogW1xuICAgIHtcbiAgICAgIGNsYXNzOiAnRk9iamVjdFByb3BlcnR5JyxcbiAgICAgIG9mOiAnZm9hbS5tbGFuZy5wcmVkaWNhdGUuUHJlZGljYXRlJyxcbiAgICAgIHJlcXVpcmVkOiB0cnVlLFxuICAgICAgbmFtZTogJ3ByZWRpY2F0ZSdcbiAgICB9XG4gIF0sXG5cbiAgbWV0aG9kczogW1xuICAgIHtcbiAgICAgIG5hbWU6ICdwdXQnLFxuICAgICAgY29kZTogZnVuY3Rpb24gcHV0KG9iaiwgc3ViKSB7XG4gICAgICAgIGlmICggdGhpcy5wcmVkaWNhdGUuZihvYmopICkgdGhpcy5kZWxlZ2F0ZS5wdXQob2JqLCBzdWIpO1xuICAgICAgfSxcbiAgICAgIHN3aWZ0Q29kZTogJ2lmIHByZWRpY2F0ZS5mKG9iaikgeyBkZWxlZ2F0ZS5wdXQob2JqLCBzdWIpIH0nXG4gICAgfSxcbiAgICB7XG4gICAgICBuYW1lOiAncmVtb3ZlJyxcbiAgICAgIGNvZGU6IGZ1bmN0aW9uIHJlbW92ZShvYmosIHN1Yikge1xuICAgICAgICBpZiAoIHRoaXMucHJlZGljYXRlLmYob2JqKSApIHRoaXMuZGVsZWdhdGUucmVtb3ZlKG9iaiwgc3ViKTtcbiAgICAgIH0sXG4gICAgICBzd2lmdENvZGU6ICdpZiBwcmVkaWNhdGUuZihvYmopIHsgZGVsZWdhdGUucmVtb3ZlKG9iaiwgc3ViKSB9J1xuICAgIH1cbiAgXVxufSk7XG5cblxuZm9hbS5DTEFTUyh7XG4gIHBhY2thZ2U6ICdmb2FtLmRhbycsXG4gIG5hbWU6ICdMaW1pdGVkU2luaycsXG4gIGV4dGVuZHM6ICdmb2FtLmRhby5Qcm94eVNpbmsnLFxuXG4gIHByb3BlcnRpZXM6IFtcbiAgICB7XG4gICAgICBjbGFzczogJ0xvbmcnLFxuICAgICAgbmFtZTogJ2xpbWl0J1xuICAgIH0sXG4gICAge1xuICAgICAgbmFtZTogJ2NvdW50JyxcbiAgICAgIGNsYXNzOiAnSW50JyxcbiAgICAgIHZhbHVlOiAwXG4gICAgfVxuICBdLFxuXG4gIG1ldGhvZHM6IFtcbiAgICB7XG4gICAgICBuYW1lOiAncHV0JyxcbiAgICAgIGNvZGU6IGZ1bmN0aW9uIHB1dChvYmosIHN1Yikge1xuICAgICAgICBpZiAoIHRoaXMuY291bnQrKyA+PSB0aGlzLmxpbWl0ICkge1xuICAgICAgICAgIHN1YiAmJiBzdWIuZGV0YWNoKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5kZWxlZ2F0ZS5wdXQob2JqLCBzdWIpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgc3dpZnRDb2RlOiBmdW5jdGlvbigpIHsvKlxuY291bnQgKz0gMVxuaWYgY291bnQgPD0gbGltaXQge1xuICBkZWxlZ2F0ZS5wdXQob2JqLCBzdWIpXG59XG4gICAgICAqL31cbiAgICB9LFxuICAgIHtcbiAgICAgIG5hbWU6ICdyZW1vdmUnLFxuICAgICAgY29kZTogZnVuY3Rpb24gcmVtb3ZlKG9iaiwgc3ViKSB7XG4gICAgICAgIGlmICggdGhpcy5jb3VudCsrID49IHRoaXMubGltaXQgKSB7XG4gICAgICAgICAgc3ViICYmIHN1Yi5kZXRhY2goKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmRlbGVnYXRlLnJlbW92ZShvYmosIHN1Yik7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBzd2lmdENvZGU6IGZ1bmN0aW9uKCkgey8qXG5jb3VudCArPSAxXG5pZiBjb3VudCA8PSBsaW1pdCB7XG4gIGRlbGVnYXRlLnJlbW92ZShvYmosIHN1Yilcbn1cbiAgICAgICovfVxuICAgIH1cbiAgXVxufSk7XG5cblxuZm9hbS5DTEFTUyh7XG4gIHBhY2thZ2U6ICdmb2FtLmRhbycsXG4gIG5hbWU6ICdTa2lwU2luaycsXG4gIGV4dGVuZHM6ICdmb2FtLmRhby5Qcm94eVNpbmsnLFxuXG4gIHByb3BlcnRpZXM6IFtcbiAgICB7XG4gICAgICBjbGFzczogJ0xvbmcnLFxuICAgICAgbmFtZTogJ3NraXAnXG4gICAgfSxcbiAgICB7XG4gICAgICBuYW1lOiAnY291bnQnLFxuICAgICAgY2xhc3M6ICdJbnQnLFxuICAgICAgdmFsdWU6IDBcbiAgICB9XG4gIF0sXG5cbiAgbWV0aG9kczogW1xuICAgIHtcbiAgICAgIG5hbWU6ICdwdXQnLFxuICAgICAgY29kZTogZnVuY3Rpb24gcHV0KG9iaiwgc3ViKSB7XG4gICAgICAgIGlmICggdGhpcy5jb3VudCA8IHRoaXMuc2tpcCApIHtcbiAgICAgICAgICB0aGlzLmNvdW50Kys7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5kZWxlZ2F0ZS5wdXQob2JqLCBzdWIpO1xuICAgICAgfSxcbiAgICAgIHN3aWZ0Q29kZTogZnVuY3Rpb24oKSB7LypcbmlmIGNvdW50IDwgc2tpcCB7XG4gIGNvdW50ICs9IDFcbiAgcmV0dXJuXG59XG5kZWxlZ2F0ZS5wdXQob2JqLCBzdWIpXG4gICAgICAqL31cbiAgICB9LFxuICAgIHtcbiAgICAgIG5hbWU6ICdyZW1vdmUnLFxuICAgICAgY29kZTogZnVuY3Rpb24gcmVtb3ZlKG9iaiwgc3ViKSB7XG4gICAgICAgIHRoaXMucmVzZXQoc3ViKTtcbiAgICAgIH0sXG4gICAgICBzd2lmdENvZGU6IGZ1bmN0aW9uKCkgey8qXG5pZiBjb3VudCA8IHNraXAge1xuICBjb3VudCArPSAxXG4gIHJldHVyblxufVxuZGVsZWdhdGUucmVtb3ZlKG9iaiwgc3ViKVxuICAgICAgKi99XG4gICAgfSxcbiAgICB7XG4gICAgICBuYW1lOiAncmVzZXQnLFxuICAgICAgY29kZTogZnVuY3Rpb24oc3ViKSB7XG4gICAgICAgIHRoaXMuY291bnQgPSAwO1xuICAgICAgICB0aGlzLmRlbGVnYXRlLnJlc2V0KHN1Yik7XG4gICAgICB9LFxuICAgICAgc3dpZnRDb2RlOiBmdW5jdGlvbigpIHsvKlxuY291bnQgPSAwO1xuZGVsZWdhdGUucmVzZXQoc3ViKTtcbiAgICAgICovfSxcbiAgICB9XG4gIF1cbn0pO1xuXG5cbmZvYW0uQ0xBU1Moe1xuICBwYWNrYWdlOiAnZm9hbS5kYW8nLFxuICBuYW1lOiAnT3JkZXJlZFNpbmsnLFxuICBleHRlbmRzOiAnZm9hbS5kYW8uUHJveHlTaW5rJyxcblxuICBwcm9wZXJ0aWVzOiBbXG4gICAge1xuICAgICAgY2xhc3M6ICdGT2JqZWN0UHJvcGVydHknLFxuICAgICAgb2Y6ICdmb2FtLm1sYW5nLm9yZGVyLkNvbXBhcmF0b3InLFxuICAgICAgcmVxdWlyZWQ6IHRydWUsXG4gICAgICBuYW1lOiAnY29tcGFyYXRvcidcbiAgICB9LFxuICAgIHtcbiAgICAgIGNsYXNzOiAnTGlzdCcsXG4gICAgICBuYW1lOiAnYXJyYXknLFxuICAgICAgZmFjdG9yeTogZnVuY3Rpb24oKSB7IHJldHVybiBbXTsgfVxuICAgIH1cbiAgXSxcblxuICBtZXRob2RzOiBbXG4gICAge1xuICAgICAgbmFtZTogJ3B1dCcsXG4gICAgICBjb2RlOiBmdW5jdGlvbiBwdXQob2JqLCBzdWIpIHtcbiAgICAgICAgdGhpcy5hcnJheS5wdXNoKG9iaik7XG4gICAgICB9LFxuICAgICAgc3dpZnRDb2RlOiAnYXJyYXkuYXBwZW5kKG9iaiknLFxuICAgIH0sXG4gICAge1xuICAgICAgbmFtZTogJ2VvZicsXG4gICAgICBjb2RlOiBmdW5jdGlvbiBlb2YoKSB7XG4gICAgICAgIHZhciBjb21wYXJhdG9yID0gdGhpcy5jb21wYXJhdG9yO1xuICAgICAgICB0aGlzLmFycmF5LnNvcnQoZnVuY3Rpb24obzEsIG8yKSB7XG4gICAgICAgICAgcmV0dXJuIGNvbXBhcmF0b3IuY29tcGFyZShvMSwgbzIpO1xuICAgICAgICB9KTtcblxuICAgICAgICB2YXIgc3ViID0gZm9hbS5jb3JlLkZPYmplY3QuY3JlYXRlKCk7XG4gICAgICAgIHZhciBkZXRhY2hlZCA9IGZhbHNlO1xuICAgICAgICBzdWIub25EZXRhY2goZnVuY3Rpb24oKSB7IGRldGFjaGVkID0gdHJ1ZTsgfSk7XG4gICAgICAgIGZvciAoIHZhciBpID0gMCA7IGkgPCB0aGlzLmFycmF5Lmxlbmd0aCA7IGkrKyApIHtcbiAgICAgICAgICB0aGlzLmRlbGVnYXRlLnB1dCh0aGlzLmFycmF5W2ldLCBzdWIpO1xuICAgICAgICAgIGlmICggZGV0YWNoZWQgKSBicmVhaztcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHN3aWZ0Q29kZTogZnVuY3Rpb24oKSB7LypcbmFycmF5LnNvcnQoYnk6IHtcbiAgcmV0dXJuIGNvbXBhcmF0b3IuY29tcGFyZSgkMCwgJDEpID09IDBcbn0pO1xuXG52YXIgZGV0YWNoZWQgPSBmYWxzZVxubGV0IHN1YiA9IFN1YnNjcmlwdGlvbiB7IGRldGFjaGVkID0gdHJ1ZSB9XG5mb3Igb2JqIGluIGFycmF5IHtcbiAgZGVsZWdhdGUucHV0KG9iaiBhcyEgRk9iamVjdCwgc3ViKVxuICBpZiBkZXRhY2hlZCB7IGJyZWFrIH1cbn1cbiAgICAgICovfVxuICAgIH0sXG4gICAge1xuICAgICAgbmFtZTogJ3JlbW92ZScsXG4gICAgICBjb2RlOiBmdW5jdGlvbiByZW1vdmUob2JqLCBzdWIpIHtcbiAgICAgICAgLy8gVE9ET1xuICAgICAgfSxcbiAgICAgIHN3aWZ0Q29kZTogJy8vIFRPRE8nLFxuICAgIH0sXG4gIF1cbn0pO1xuXG5cbmZvYW0uQ0xBU1Moe1xuICBwYWNrYWdlOiAnZm9hbS5kYW8nLFxuICBuYW1lOiAnRGVkdXBTaW5rJyxcbiAgZXh0ZW5kczogJ2ZvYW0uZGFvLlByb3h5U2luaycsXG5cbiAgcHJvcGVydGllczogW1xuICAgIHtcbiAgICAgIGNsYXNzOiAnT2JqZWN0JyxcbiAgICAgIC8qKiBAcHJpdmF0ZSAqL1xuICAgICAgbmFtZTogJ3Jlc3VsdHMnLFxuICAgICAgamF2YVR5cGU6ICdqYXZhLnV0aWwuSGFzaFNldCcsXG4gICAgICBoaWRkZW46IHRydWUsXG4gICAgICBmYWN0b3J5OiBmdW5jdGlvbigpIHsgcmV0dXJuIHt9OyB9XG4gICAgfVxuICBdLFxuXG4gIG1ldGhvZHM6IFtcbiAgICB7XG4gICAgICAvKiogSWYgdGhlIG9iamVjdCB0byBiZSBwdXQoKSBoYXMgYWxyZWFkeSBiZWVuIHNlZW4gYnkgdGhpcyBzaW5rLFxuICAgICAgICBpZ25vcmUgaXQgKi9cbiAgICAgIG5hbWU6ICdwdXQnLFxuICAgICAgY29kZTogZnVuY3Rpb24gcHV0KG9iaiwgc3ViKSB7XG4gICAgICAgIGlmICggISB0aGlzLnJlc3VsdHNbb2JqLmlkXSApIHtcbiAgICAgICAgICB0aGlzLnJlc3VsdHNbb2JqLmlkXSA9IHRydWU7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZGVsZWdhdGUucHV0KG9iaiwgc3ViKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgXVxufSk7XG5cblxuZm9hbS5DTEFTUyh7XG4gIHBhY2thZ2U6ICdmb2FtLmRhbycsXG4gIG5hbWU6ICdEZXNjcmliZVNpbmsnLFxuICBpbXBsZW1lbnRzOiBbICdmb2FtLmRhby5TaW5rJyBdLFxuXG4gIGRvY3VtZW50YXRpb246ICdDYWxscyAuZGVzY3JpYmUoKSBvbiBldmVyeSBvYmplY3QuICBVc2VmdWwgZm9yIGRlYnVnZ2luZyB0byBxdWlja2x5IHNlZSB3aGF0IGl0ZW1zIGFyZSBpbiBhIERBTy4nLFxuXG4gIG1ldGhvZHM6IFtcbiAgICBmdW5jdGlvbiBwdXQobykge1xuICAgICAgby5kZXNjcmliZSgpO1xuICAgIH0sXG4gICAgZnVuY3Rpb24gcmVtb3ZlKCkge30sXG4gICAgZnVuY3Rpb24gZW9mKCkge30sXG4gICAgZnVuY3Rpb24gcmVzZXQoKSB7fVxuICBdXG59KTtcblxuXG5mb2FtLkNMQVNTKHtcbiAgcGFja2FnZTogJ2ZvYW0uZGFvJyxcbiAgbmFtZTogJ0ZuU2luaycsXG4gIGltcGxlbWVudHM6IFsgJ2ZvYW0uZGFvLlNpbmsnIF0sXG4gIGRvY3VtZW50YXRpb246ICdDb252ZXJ0cyBhbGwgc2luayBldmVudHMgdG8gY2FsbCB0byBhIHNpbmd1bGFyIGZ1bmN0aW9uLicgK1xuICAgICcgIFVzZWZ1bCBmb3Igc3Vic2NyaWJpbmcgYSBsaXN0ZW5lciBtZXRob2QgdG8gYSBEQU8nLFxuXG4gIGF4aW9tczogW1xuICAgIHtcbiAgICAgIGNsYXNzOiAnZm9hbS5ib3guUmVtb3RlJyxcbiAgICAgIGNsaWVudENsYXNzOiAnZm9hbS5kYW8uQ2xpZW50U2luaydcbiAgICB9XG4gIF0sXG5cbiAgcHJvcGVydGllczogW1xuICAgIHtcbiAgICAgIG5hbWU6ICdmbicsXG4gICAgICBzd2lmdFR5cGU6ICcoKFN0cmluZywgQW55PywgRGV0YWNoYWJsZSkgLT4gVm9pZCknLFxuICAgICAgc3dpZnRSZXF1aXJlc0VzY2FwaW5nOiB0cnVlLFxuICAgIH0sXG4gIF0sXG5cbiAgbWV0aG9kczogW1xuICAgIHtcbiAgICAgIG5hbWU6ICdwdXQnLFxuICAgICAgY29kZTogZnVuY3Rpb24ob2JqLCBzKSB7XG4gICAgICAgIHRoaXMuZm4oJ3B1dCcsIG9iaiwgcyk7XG4gICAgICB9LFxuICAgICAgc3dpZnRDb2RlOiAnZm4oXCJwdXRcIiwgb2JqLCBzdWIpJyxcbiAgICB9LFxuICAgIHtcbiAgICAgIG5hbWU6ICdyZW1vdmUnLFxuICAgICAgY29kZTogZnVuY3Rpb24ob2JqLCBzKSB7XG4gICAgICAgIHRoaXMuZm4oJ3JlbW92ZScsIG9iaiwgcyk7XG4gICAgICB9LFxuICAgICAgc3dpZnRDb2RlOiAnZm4oXCJyZW1vdmVcIiwgb2JqLCBzdWIpJyxcbiAgICB9LFxuICAgIGZ1bmN0aW9uIGVvZigpIHtcbiAgICAgIHRoaXMuZm4oJ2VvZicpO1xuICAgIH0sXG4gICAge1xuICAgICAgbmFtZTogJ3Jlc2V0JyxcbiAgICAgIGNvZGU6IGZ1bmN0aW9uKHMpIHtcbiAgICAgICAgdGhpcy5mbigncmVzZXQnLCBzKTtcbiAgICAgIH0sXG4gICAgICBzd2lmdENvZGU6ICdmbihcInJlc2V0XCIsIG5pbCwgc3ViKScsXG4gICAgfSxcbiAgXVxufSk7XG5cblxuZm9hbS5DTEFTUyh7XG4gIHBhY2thZ2U6ICdmb2FtLmRhbycsXG4gIG5hbWU6ICdGcmFtZWRTaW5rJyxcbiAgZXh0ZW5kczogJ2ZvYW0uZGFvLlByb3h5U2luaycsXG5cbiAgZG9jdW1lbnRhdGlvbjogJ0EgcHJveHkgdGhhdCB3YWl0cyB1bnRpbCB0aGUgbmV4dCBmcmFtZSB0byBmbHVzaCB0aGUgY2FsbHMgdG8gdGhlIGRlbGVnYXRlLicsXG5cbiAgcHJvcGVydGllczogW1xuICAgIHsgY2xhc3M6ICdBcnJheScsIG5hbWU6ICdjYWxscycgfSxcbiAgXSxcblxuICBtZXRob2RzOiBbXG4gICAge1xuICAgICAgbmFtZTogJ3B1dCcsXG4gICAgICBjb2RlOiBmdW5jdGlvbihvYmosIHMpIHtcbiAgICAgICAgdGhpcy5jYWxscy5wdXNoKFsncHV0JywgW29iaiwgc11dKTtcbiAgICAgICAgdGhpcy5mbHVzaENhbGxzKCk7XG4gICAgICB9XG4gICAgfSxcbiAgICB7XG4gICAgICBuYW1lOiAncmVtb3ZlJyxcbiAgICAgIGNvZGU6IGZ1bmN0aW9uKG9iaiwgcykge1xuICAgICAgICB0aGlzLmNhbGxzLnB1c2goWydyZW1vdmUnLCBbb2JqLCBzXV0pO1xuICAgICAgICB0aGlzLmZsdXNoQ2FsbHMoKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHtcbiAgICAgIG5hbWU6ICdlb2YnLFxuICAgICAgY29kZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuY2FsbHMucHVzaChbJ2VvZicsIFtdXSk7XG4gICAgICAgIHRoaXMuZmx1c2hDYWxscygpO1xuICAgICAgfVxuICAgIH0sXG4gICAge1xuICAgICAgbmFtZTogJ3Jlc2V0JyxcbiAgICAgIGNvZGU6IGZ1bmN0aW9uKHMpIHtcbiAgICAgICAgdGhpcy5jYWxscyA9IFtbJ3Jlc2V0JywgW3NdXV07XG4gICAgICAgIHRoaXMuZmx1c2hDYWxscygpO1xuICAgICAgfVxuICAgIH1cbiAgXSxcblxuICBsaXN0ZW5lcnM6IFtcbiAgICB7XG4gICAgICBuYW1lOiAnZmx1c2hDYWxscycsXG4gICAgICBpc01lcmdlZDogMTAwLFxuICAgICAgY29kZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBjYWxscyA9IHRoaXMuY2FsbHM7XG4gICAgICAgIHRoaXMuY2FsbHMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIG87IG8gPSBjYWxsc1tpXTsgaSsrKSB7XG4gICAgICAgICAgdGhpcy5kZWxlZ2F0ZVtvWzBdXS5hcHBseSh0aGlzLmRlbGVnYXRlLCBvWzFdKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gIF1cbn0pO1xuXG5cbmZvYW0uQ0xBU1Moe1xuICBwYWNrYWdlOiAnZm9hbS5kYW8nLFxuICBuYW1lOiAnREFPU2luaycsXG5cbiAgaW1wbGVtZW50czogWyAnZm9hbS5kYW8uU2luaycgXSxcblxuICBwcm9wZXJ0aWVzOiBbXG4gICAgeyBjbGFzczogJ2ZvYW0uZGFvLkRBT1Byb3BlcnR5JywgbmFtZTogJ2RhbycgfSxcbiAgXSxcblxuICBheGlvbXM6IFtcbiAgICB7XG4gICAgICBjbGFzczogJ2ZvYW0uYm94LlJlbW90ZScsXG4gICAgICBjbGllbnRDbGFzczogJ2ZvYW0uZGFvLkNsaWVudFNpbmsnXG4gICAgfVxuICBdLFxuXG4gIG1ldGhvZHM6IFtcbiAgICB7XG4gICAgICBuYW1lOiAncHV0JyxcbiAgICAgIGNvZGU6IGZ1bmN0aW9uKG8pIHtcbiAgICAgICAgdGhpcy5kYW8ucHV0KG8pO1xuICAgICAgfSxcbiAgICAgIGphdmFDb2RlOiBgZ2V0RGFvKCkucHV0KChmb2FtLmNvcmUuRk9iamVjdClvYmopO2AsXG4gICAgICBzd2lmdENvZGU6ICdfID0gdHJ5PyBkYW8/LnB1dChvYmogYXMhIEZPYmplY3QpJyxcbiAgICB9LFxuICAgIHtcbiAgICAgIG5hbWU6ICdyZW1vdmUnLFxuICAgICAgY29kZTogZnVuY3Rpb24obykge1xuICAgICAgICB0aGlzLmRhby5yZW1vdmUobyk7XG4gICAgICB9LFxuICAgICAgamF2YUNvZGU6IGBnZXREYW8oKS5yZW1vdmUoKGZvYW0uY29yZS5GT2JqZWN0KW9iaik7YCxcbiAgICAgIHN3aWZ0Q29kZTogJ18gPSB0cnk/IGRhbz8ucmVtb3ZlKG9iaiBhcyEgRk9iamVjdCknLFxuICAgIH0sXG4gICAge1xuICAgICAgbmFtZTogJ2VvZicsXG4gICAgICBjb2RlOiBmdW5jdGlvbigpIHt9LFxuICAgICAgamF2YUNvZGU6IGBgLFxuICAgICAgc3dpZnRDb2RlOiAnLy8gTk9PUCcsXG4gICAgfSxcbiAgICB7XG4gICAgICBuYW1lOiAncmVzZXQnLFxuICAgICAgY29kZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuZGFvLnJlbW92ZUFsbCgpO1xuICAgICAgfSxcbiAgICAgIGphdmFDb2RlOiBgZ2V0RGFvKCkucmVtb3ZlQWxsKCk7YCxcbiAgICAgIHN3aWZ0Q29kZTogJ18gPSB0cnk/IGRhbz8ucmVtb3ZlQWxsKCknLFxuICAgIH1cbiAgXVxufSk7XG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5mb2FtLklOVEVSRkFDRSh7XG4gIHBhY2thZ2U6ICdmb2FtLmRhbycsXG4gIG5hbWU6ICdEQU8nLFxuXG4gIGRvY3VtZW50YXRpb246ICdEQU8gSW50ZXJmYWNlJyxcblxuICBtZXRob2RzOiBbXG4gICAge1xuICAgICAgbmFtZTogJ3B1dCcsXG4gICAgICByZXR1cm5zOiAnUHJvbWlzZScsXG4gICAgICBzd2lmdFJldHVybnM6ICdGT2JqZWN0PycsXG4gICAgICBzd2lmdFRocm93czogdHJ1ZSxcbiAgICAgIGFyZ3M6IFtcbiAgICAgICAge1xuICAgICAgICAgIG5hbWU6ICdvYmonLFxuICAgICAgICAgIHN3aWZ0VHlwZTogJ0ZPYmplY3QnXG4gICAgICAgIH1cbiAgICAgIF0sXG4gICAgfSxcbiAgICB7XG4gICAgICBuYW1lOiAncHV0XycsXG4gICAgICByZXR1cm5zOiAnUHJvbWlzZScsXG4gICAgICBzd2lmdFJldHVybnM6ICdGT2JqZWN0PycsXG4gICAgICBzd2lmdFRocm93czogdHJ1ZSxcbiAgICAgIGFyZ3M6IFtcbiAgICAgICAge1xuICAgICAgICAgIG5hbWU6ICd4JyxcbiAgICAgICAgICBzd2lmdFR5cGU6ICdDb250ZXh0PydcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIG5hbWU6ICdvYmonLFxuICAgICAgICAgIHN3aWZ0VHlwZTogJ0ZPYmplY3QnXG4gICAgICAgIH1cbiAgICAgIF0sXG4gICAgfSxcbiAgICB7XG4gICAgICBuYW1lOiAncmVtb3ZlJyxcbiAgICAgIHJldHVybnM6ICdQcm9taXNlJyxcbiAgICAgIHN3aWZ0UmV0dXJuczogJ0ZPYmplY3Q/JyxcbiAgICAgIHN3aWZ0VGhyb3dzOiB0cnVlLFxuICAgICAgYXJnczogW1xuICAgICAgICB7XG4gICAgICAgICAgbmFtZTogJ29iaicsXG4gICAgICAgICAgc3dpZnRUeXBlOiAnRk9iamVjdCdcbiAgICAgICAgfVxuICAgICAgXSxcbiAgICB9LFxuICAgIHtcbiAgICAgIG5hbWU6ICdyZW1vdmVfJyxcbiAgICAgIHJldHVybnM6ICdQcm9taXNlJyxcbiAgICAgIHN3aWZ0UmV0dXJuczogJ0ZPYmplY3Q/JyxcbiAgICAgIHN3aWZ0VGhyb3dzOiB0cnVlLFxuICAgICAgYXJnczogW1xuICAgICAgICB7XG4gICAgICAgICAgbmFtZTogJ3gnLFxuICAgICAgICAgIHN3aWZ0VHlwZTogJ0NvbnRleHQ/J1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgbmFtZTogJ29iaicsXG4gICAgICAgICAgc3dpZnRUeXBlOiAnRk9iamVjdCdcbiAgICAgICAgfVxuICAgICAgXSxcbiAgICB9LFxuICAgIHtcbiAgICAgIG5hbWU6ICdmaW5kJyxcbiAgICAgIHJldHVybnM6ICdQcm9taXNlJyxcbiAgICAgIHN3aWZ0UmV0dXJuczogJ0ZPYmplY3Q/JyxcbiAgICAgIHN3aWZ0VGhyb3dzOiB0cnVlLFxuICAgICAgYXJnczogW1xuICAgICAgICB7XG4gICAgICAgICAgbmFtZTogJ2lkJyxcbiAgICAgICAgICBzd2lmdFR5cGU6ICdBbnk/J1xuICAgICAgICB9XG4gICAgICBdLFxuICAgIH0sXG4gICAge1xuICAgICAgbmFtZTogJ2ZpbmRfJyxcbiAgICAgIHJldHVybnM6ICdQcm9taXNlJyxcbiAgICAgIHN3aWZ0UmV0dXJuczogJ0ZPYmplY3Q/JyxcbiAgICAgIHN3aWZ0VGhyb3dzOiB0cnVlLFxuICAgICAgYXJnczogW1xuICAgICAgICB7XG4gICAgICAgICAgbmFtZTogJ3gnLFxuICAgICAgICAgIHN3aWZ0VHlwZTogJ0NvbnRleHQ/J1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgbmFtZTogJ2lkJyxcbiAgICAgICAgICBzd2lmdFR5cGU6ICdBbnk/J1xuICAgICAgICB9XG4gICAgICBdLFxuICAgIH0sXG4gICAge1xuICAgICAgbmFtZTogJ3NlbGVjdCcsXG4gICAgICByZXR1cm5zOiAnUHJvbWlzZScsXG4gICAgICBzd2lmdFJldHVybnM6ICdTaW5rJyxcbiAgICAgIHN3aWZ0VGhyb3dzOiB0cnVlLFxuICAgICAgYXJnczogW1xuICAgICAgICB7XG4gICAgICAgICAgbmFtZTogJ3NpbmsnLFxuICAgICAgICAgIHN3aWZ0VHlwZTogJ1NpbmsnLFxuICAgICAgICB9LFxuICAgICAgXSxcbiAgICB9LFxuICAgIHtcbiAgICAgIG5hbWU6ICdzZWxlY3RfJyxcbiAgICAgIHJldHVybnM6ICdQcm9taXNlJyxcbiAgICAgIHN3aWZ0UmV0dXJuczogJ1NpbmsnLFxuICAgICAgc3dpZnRUaHJvd3M6IHRydWUsXG4gICAgICBhcmdzOiBbXG4gICAgICAgIHtcbiAgICAgICAgICBuYW1lOiAneCcsXG4gICAgICAgICAgc3dpZnRUeXBlOiAnQ29udGV4dD8nXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICBuYW1lOiAnc2luaycsXG4gICAgICAgICAgc3dpZnRUeXBlOiAnU2luaycsXG4gICAgICAgICAgc3dpZnREZWZhdWx0VmFsdWU6ICdBcnJheVNpbmsoKScsXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICBuYW1lOiAnc2tpcCcsXG4gICAgICAgICAgc3dpZnRUeXBlOiAnSW50JyxcbiAgICAgICAgICBzd2lmdERlZmF1bHRWYWx1ZTogJzAnLFxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgbmFtZTogJ2xpbWl0JyxcbiAgICAgICAgICBzd2lmdFR5cGU6ICdJbnQnLFxuICAgICAgICAgIHN3aWZ0RGVmYXVsdFZhbHVlOiAnSW50Lm1heCcsXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICBuYW1lOiAnb3JkZXInLFxuICAgICAgICAgIHN3aWZ0VHlwZTogJ0NvbXBhcmF0b3I/JyxcbiAgICAgICAgICBzd2lmdERlZmF1bHRWYWx1ZTogJ25pbCcsXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICBuYW1lOiAncHJlZGljYXRlJyxcbiAgICAgICAgICBzd2lmdFR5cGU6ICdGb2FtUHJlZGljYXRlPycsXG4gICAgICAgICAgc3dpZnREZWZhdWx0VmFsdWU6ICduaWwnLFxuICAgICAgICB9XG4gICAgICBdLFxuICAgIH0sXG4gICAge1xuICAgICAgbmFtZTogJ3JlbW92ZUFsbCcsXG4gICAgICByZXR1cm5zOiAnJyxcbiAgICAgIHN3aWZ0VGhyb3dzOiB0cnVlLFxuICAgICAgYXJnczogWyBdXG4gICAgfSxcbiAgICB7XG4gICAgICBuYW1lOiAncmVtb3ZlQWxsXycsXG4gICAgICByZXR1cm5zOiAnJyxcbiAgICAgIHN3aWZ0VGhyb3dzOiB0cnVlLFxuICAgICAgYXJnczogW1xuICAgICAgICB7XG4gICAgICAgICAgbmFtZTogJ3gnLFxuICAgICAgICAgIHN3aWZ0VHlwZTogJ0NvbnRleHQ/J1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgbmFtZTogJ3NraXAnLFxuICAgICAgICAgIHN3aWZ0VHlwZTogJ0ludD8nLFxuICAgICAgICAgIHN3aWZ0RGVmYXVsdFZhbHVlOiAnbmlsJyxcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIG5hbWU6ICdsaW1pdCcsXG4gICAgICAgICAgc3dpZnRUeXBlOiAnSW50PycsXG4gICAgICAgICAgc3dpZnREZWZhdWx0VmFsdWU6ICduaWwnLFxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgbmFtZTogJ29yZGVyJyxcbiAgICAgICAgICBzd2lmdFR5cGU6ICdDb21wYXJhdG9yPycsXG4gICAgICAgICAgc3dpZnREZWZhdWx0VmFsdWU6ICduaWwnLFxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgbmFtZTogJ3ByZWRpY2F0ZScsXG4gICAgICAgICAgc3dpZnRUeXBlOiAnRm9hbVByZWRpY2F0ZT8nLFxuICAgICAgICAgIHN3aWZ0RGVmYXVsdFZhbHVlOiAnbmlsJyxcbiAgICAgICAgfVxuICAgICAgXSxcbiAgICB9LFxuICAgIHtcbiAgICAgIG5hbWU6ICdsaXN0ZW4nLFxuICAgICAgcmV0dXJuczogJycsXG4gICAgICBzd2lmdFJldHVybnM6ICdEZXRhY2hhYmxlJyxcbiAgICAgIHN3aWZ0VGhyb3dzOiB0cnVlLFxuICAgICAgYXJnczogW1xuICAgICAgICB7XG4gICAgICAgICAgbmFtZTogJ3NpbmsnLFxuICAgICAgICAgIHN3aWZ0VHlwZTogJ1NpbmsnLFxuICAgICAgICAgIHN3aWZ0RGVmYXVsdFZhbHVlOiAnQXJyYXlTaW5rKCknLFxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgbmFtZTogJ3ByZWRpY2F0ZScsXG4gICAgICAgICAgc3dpZnRUeXBlOiAnRm9hbVByZWRpY2F0ZT8nLFxuICAgICAgICAgIHN3aWZ0RGVmYXVsdFZhbHVlOiAnbmlsJyxcbiAgICAgICAgfVxuICAgICAgXSxcbiAgICB9LFxuICAgIHtcbiAgICAgIG5hbWU6ICdsaXN0ZW5fJyxcbiAgICAgIHJldHVybnM6ICcnLFxuICAgICAgc3dpZnRSZXR1cm5zOiAnRGV0YWNoYWJsZScsXG4gICAgICBzd2lmdFRocm93czogdHJ1ZSxcbiAgICAgIGFyZ3M6IFtcbiAgICAgICAge1xuICAgICAgICAgIG5hbWU6ICd4JyxcbiAgICAgICAgICBzd2lmdFR5cGU6ICdDb250ZXh0PydcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIG5hbWU6ICdzaW5rJyxcbiAgICAgICAgICBzd2lmdFR5cGU6ICdTaW5rJyxcbiAgICAgICAgICBzd2lmdERlZmF1bHRWYWx1ZTogJ0FycmF5U2luaygpJyxcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIG5hbWU6ICdwcmVkaWNhdGUnLFxuICAgICAgICAgIHN3aWZ0VHlwZTogJ0ZvYW1QcmVkaWNhdGU/JyxcbiAgICAgICAgICBzd2lmdERlZmF1bHRWYWx1ZTogJ25pbCcsXG4gICAgICAgIH1cbiAgICAgIF0sXG4gICAgfSxcbiAgICB7XG4gICAgICBuYW1lOiAncGlwZScsIC8vIFRPRE86IHJldHVybiBhIHByb21pc2U/IGRvbid0IHB1dCBwaXBlIGFuZCBsaXN0ZW4gaGVyZT9cbiAgICAgIHJldHVybnM6ICcnLFxuICAgICAgc3dpZnRUaHJvd3M6IHRydWUsXG4gICAgICBhcmdzOiBbXG4gICAgICAgIHtcbiAgICAgICAgICBuYW1lOiAnc2luaycsXG4gICAgICAgICAgc3dpZnRUeXBlOiAnU2luaydcbiAgICAgICAgfVxuICAgICAgXSxcbiAgICB9LFxuICAgIHtcbiAgICAgIG5hbWU6ICdwaXBlXycsIC8vIFRPRE86IHJldHVybiBhIHByb21pc2U/IGRvbid0IHB1dCBwaXBlIGFuZCBsaXN0ZW4gaGVyZT9cbiAgICAgIHJldHVybnM6ICcnLFxuICAgICAgc3dpZnRUaHJvd3M6IHRydWUsXG4gICAgICBhcmdzOiBbXG4gICAgICAgIHtcbiAgICAgICAgICBuYW1lOiAneCcsXG4gICAgICAgICAgc3dpZnRUeXBlOiAnQ29udGV4dD8nXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICBuYW1lOiAnc2luaycsXG4gICAgICAgICAgc3dpZnRUeXBlOiAnU2luaydcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIG5hbWU6ICdwcmVkaWNhdGUnLFxuICAgICAgICAgIHN3aWZ0VHlwZTogJ0ZvYW1QcmVkaWNhdGU/JyxcbiAgICAgICAgICBzd2lmdERlZmF1bHRWYWx1ZTogJ25pbCcsXG4gICAgICAgIH0sXG4gICAgICBdLFxuICAgIH0sXG4gICAge1xuICAgICAgbmFtZTogJ3doZXJlJyxcbiAgICAgIHJldHVybnM6ICdmb2FtLmRhby5EQU8nLFxuICAgICAgc3dpZnRUaHJvd3M6IHRydWUsXG4gICAgICBhcmdzOiBbXG4gICAgICAgIHtcbiAgICAgICAgICBuYW1lOiAncHJlZGljYXRlJyxcbiAgICAgICAgICBzd2lmdFR5cGU6ICdGb2FtUHJlZGljYXRlPycsXG4gICAgICAgICAgc3dpZnREZWZhdWx0VmFsdWU6ICduaWwnLFxuICAgICAgICB9XG4gICAgICBdLFxuICAgIH0sXG4gICAge1xuICAgICAgbmFtZTogJ29yZGVyQnknLFxuICAgICAgcmV0dXJuczogJ2ZvYW0uZGFvLkRBTycsXG4gICAgICBzd2lmdFRocm93czogdHJ1ZSxcbiAgICAgIGFyZ3M6IFtcbiAgICAgICAge1xuICAgICAgICAgIG5hbWU6ICdjb21wYXJhdG9yJyxcbiAgICAgICAgICBzd2lmdFR5cGU6ICdDb21wYXJhdG9yJ1xuICAgICAgICB9XG4gICAgICBdLFxuICAgIH0sXG4gICAge1xuICAgICAgbmFtZTogJ3NraXAnLFxuICAgICAgcmV0dXJuczogJ2ZvYW0uZGFvLkRBTycsXG4gICAgICBzd2lmdFRocm93czogdHJ1ZSxcbiAgICAgIGFyZ3M6IFtcbiAgICAgICAge1xuICAgICAgICAgIG5hbWU6ICdjb3VudCcsXG4gICAgICAgICAgc3dpZnRUeXBlOiAnSW50J1xuICAgICAgICB9XG4gICAgICBdLFxuICAgIH0sXG4gICAge1xuICAgICAgbmFtZTogJ2xpbWl0JyxcbiAgICAgIHJldHVybnM6ICdmb2FtLmRhby5EQU8nLFxuICAgICAgc3dpZnRUaHJvd3M6IHRydWUsXG4gICAgICBhcmdzOiBbXG4gICAgICAgIHtcbiAgICAgICAgICBuYW1lOiAnY291bnQnLFxuICAgICAgICAgIHN3aWZ0VHlwZTogJ0ludCdcbiAgICAgICAgfVxuICAgICAgXSxcbiAgICB9LFxuICAgIHtcbiAgICAgIG5hbWU6ICdpblgnLFxuICAgICAgc3dpZnRTdXBwb3J0OiBmYWxzZSxcbiAgICAgIHJldHVybnM6ICdmb2FtLmRhby5EQU8nLFxuICAgICAgYXJnczogWyAneCcgXVxuICAgIH0sXG4gICAge1xuICAgICAgbmFtZTogJ2NtZCcsXG4gICAgICBzd2lmdFN1cHBvcnQ6IGZhbHNlLFxuICAgICAgcmV0dXJuczogJ29iaicsXG4gICAgICBhcmdzOiBbICdvYmonIF1cbiAgICB9LFxuICAgIHtcbiAgICAgIG5hbWU6ICdjbWRfJyxcbiAgICAgIHN3aWZ0U3VwcG9ydDogZmFsc2UsXG4gICAgICByZXR1cm5zOiAnb2JqJyxcbiAgICAgIGFyZ3M6IFsgJ3gnLCAnb2JqJyBdXG4gICAgfVxuICBdXG59KTtcbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmZvYW0uQ0xBU1Moe1xuICBwYWNrYWdlOiAnZm9hbS5kYW8nLFxuICBuYW1lOiAnUHJveHlEQU8nLFxuICBleHRlbmRzOiAnZm9hbS5kYW8uQWJzdHJhY3REQU8nLFxuXG4gIHJlcXVpcmVzOiBbXG4gICAgJ2ZvYW0uZGFvLk51bGxEQU8nLFxuICAgICdmb2FtLmRhby5Qcm94eUxpc3RlbmVyJyxcbiAgXSxcblxuICBkb2N1bWVudGF0aW9uOiAnUHJveHkgaW1wbGVtZW50YXRpb24gZm9yIHRoZSBEQU8gaW50ZXJmYWNlLicsXG5cbiAgcHJvcGVydGllczogW1xuICAgIHtcbiAgICAgIGNsYXNzOiAnUHJveHknLFxuICAgICAgb2Y6ICdmb2FtLmRhby5EQU8nLFxuICAgICAgbmFtZTogJ2RlbGVnYXRlJyxcbiAgICAgIGZvcndhcmRzOiBbICdwdXRfJywgJ3JlbW92ZV8nLCAnZmluZF8nLCAnc2VsZWN0XycsICdyZW1vdmVBbGxfJywgJ2NtZF8nLCAnbGlzdGVuXycgXSxcbiAgICAgIHRvcGljczogWyAnb24nIF0sIC8vIFRPRE86IFJlbW92ZSB0aGlzIHdoZW4gYWxsIHVzZXJzIG9mIGl0IGFyZSB1cGRhdGVkLlxuICAgICAgZmFjdG9yeTogZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLk51bGxEQU8uY3JlYXRlKCkgfSxcbiAgICAgIHBvc3RTZXQ6IGZ1bmN0aW9uKG9sZCwgbnUpIHtcbiAgICAgICAgaWYgKCBvbGQgKSB0aGlzLm9uLnJlc2V0LnB1YigpO1xuICAgICAgfSxcbiAgICAgIHN3aWZ0RmFjdG9yeTogJ3JldHVybiBOdWxsREFPX2NyZWF0ZSgpJyxcbiAgICAgIHN3aWZ0UG9zdFNldDogYFxuaWYgbGV0IG9sZFZhbHVlID0gb2xkVmFsdWUgYXM/IEFic3RyYWN0REFPIHtcbiAgXyA9IG9sZFZhbHVlLm9uW1wicmVzZXRcIl0ucHViKClcbn1cbiAgICAgIGAsXG4gICAgfSxcbiAgICB7XG4gICAgICBuYW1lOiAnb2YnLFxuICAgICAgZmFjdG9yeTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRlbGVnYXRlLm9mO1xuICAgICAgfSxcbiAgICAgIHN3aWZ0RXhwcmVzc2lvbkFyZ3M6IFsnZGVsZWdhdGUkb2YnXSxcbiAgICAgIHN3aWZ0RXhwcmVzc2lvbjogJ3JldHVybiBkZWxlZ2F0ZSRvZiBhcyEgQ2xhc3NJbmZvJyxcbiAgICAgIGphdmFGYWN0b3J5OiBgcmV0dXJuIGdldERlbGVnYXRlKCkuZ2V0T2YoKTtgLFxuICAgIH1cbiAgXSxcblxuICBtZXRob2RzOiBbXG4gICAge1xuICAgICAgbmFtZTogJ2xpc3RlbicsXG4gICAgICBjb2RlOiBmdW5jdGlvbiBsaXN0ZW4oc2luaykge1xuICAgICAgICBpZiAoICEgZm9hbS5jb3JlLkZPYmplY3QuaXNJbnN0YW5jZShzaW5rKSApIHtcbiAgICAgICAgICBzaW5rID0gZm9hbS5kYW8uQW5vbnltb3VzU2luay5jcmVhdGUoeyBzaW5rOiBzaW5rIH0sIHRoaXMpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGxpc3RlbmVyID0gdGhpcy5Qcm94eUxpc3RlbmVyLmNyZWF0ZSh7XG4gICAgICAgICAgZGVsZWdhdGU6IHNpbmssXG4gICAgICAgICAgZGFvOiB0aGlzXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGxpc3RlbmVyLm9uRGV0YWNoKHRoaXMuc3ViKCdwcm9wZXJ0eUNoYW5nZScsICdkZWxlZ2F0ZScsIGxpc3RlbmVyLnVwZGF0ZSkpO1xuICAgICAgICBsaXN0ZW5lci51cGRhdGUoKTtcblxuICAgICAgICByZXR1cm4gbGlzdGVuZXI7XG4gICAgICB9LFxuICAgICAgc3dpZnRDb2RlOiBgXG5sZXQgbGlzdGVuZXIgPSBQcm94eUxpc3RlbmVyX2NyZWF0ZShbXG4gIFwiZGVsZWdhdGVcIjogc2lua1xuXSlcblxubGlzdGVuZXIub25EZXRhY2gobGlzdGVuZXIuZGFvJC5mb2xsb3coZGVsZWdhdGUkKSlcblxucmV0dXJuIGxpc3RlbmVyXG4gICAgICBgLFxuICAgICAgamF2YUNvZGU6IGBcbi8vIFRPRE86IFN1cHBvcnQgY2hhbmdpbmcgb2YgZGVsZWdhdGVcbnN1cGVyLmxpc3RlbihzaW5rLCBwcmVkaWNhdGUpO1xuYFxuICAgIH1cbiAgXSxcblxuICBheGlvbXM6IFtcbiAgICB7XG4gICAgICBidWlsZEphdmFDbGFzczogZnVuY3Rpb24oY2xzKSB7XG4gICAgICAgIGNscy5leHRyYXMucHVzaChgXG5wdWJsaWMgUHJveHlEQU8oZm9hbS5jb3JlLlggeCwgZm9hbS5kYW8uREFPIGRlbGVnYXRlKSB7XG4gIGZvYW0ubmFub3MubG9nZ2VyLkxvZ2dlciBsb2cgPSAoZm9hbS5uYW5vcy5sb2dnZXIuTG9nZ2VyKXguZ2V0KFwibG9nZ2VyXCIpO1xuICBsb2cud2FybmluZyhcIkRpcmVjdCBjb25zdHJ1Y3RvciB1c2UgaXMgZGVwcmVjYXRlZC4gVXNlIEJ1aWxkZXIgaW5zdGVhZC5cIik7XG4gIHNldFgoeCk7XG4gIHNldERlbGVnYXRlKGRlbGVnYXRlKTtcbn1cbiAgICAgICAgYCk7XG4gICAgICB9LFxuICAgIH0sXG4gIF0sXG59KTtcblxuXG5mb2FtLkNMQVNTKHtcbiAgcGFja2FnZTogJ2ZvYW0uZGFvJyxcbiAgbmFtZTogJ1Byb3h5TGlzdGVuZXInLFxuXG4gIGltcGxlbWVudHM6IFsnZm9hbS5kYW8uU2luayddLFxuXG4gIHByb3BlcnRpZXM6IFtcbiAgICAnYXJncycsXG4gICAge1xuICAgICAgY2xhc3M6ICdQcm94eScsXG4gICAgICBvZjogJ2ZvYW0uZGFvLlNpbmsnLFxuICAgICAgbmFtZTogJ2RlbGVnYXRlJyxcbiAgICB9LFxuICAgIHtcbiAgICAgIG5hbWU6ICdpbm5lclN1YicsXG4gICAgICBzd2lmdFR5cGU6ICdEZXRhY2hhYmxlPycsXG4gICAgICBwb3N0U2V0OiBmdW5jdGlvbihfLCBzKSB7XG4gICAgICAgIGlmIChzKSB0aGlzLm9uRGV0YWNoKHMpO1xuICAgICAgfSxcbiAgICAgIHN3aWZ0UG9zdFNldDogJ2lmIGxldCBzID0gbmV3VmFsdWUgeyBvbkRldGFjaChzKSB9JyxcbiAgICB9LFxuICAgIHtcbiAgICAgIG5hbWU6ICdkYW8nLFxuICAgICAgc3dpZnRUeXBlOiAnREFPPycsXG4gICAgICBzd2lmdFBvc3RTZXQ6IGBcbnNlbGYuaW5uZXJTdWI/LmRldGFjaCgpXG50cnk/IHNlbGYuaW5uZXJTdWIgPSBuZXdWYWx1ZT8ubGlzdGVuKHNlbGYsIGFyZ3MgYXM/IEZvYW1QcmVkaWNhdGUpXG5pZiBvbGRWYWx1ZSAhPSBuaWwge1xuICBzZWxmLnJlc2V0KFN1YnNjcmlwdGlvbihkZXRhY2g6IHt9KSlcbn1cbiAgICAgIGBcbiAgICB9XG4gIF0sXG5cbiAgbWV0aG9kczogW1xuICAgIHtcbiAgICAgIG5hbWU6ICdwdXQnLFxuICAgICAgY29kZTogZnVuY3Rpb24gcHV0KG9iaiwgcykge1xuICAgICAgICB0aGlzLmRlbGVnYXRlLnB1dChvYmosIHRoaXMpO1xuICAgICAgfSxcbiAgICAgIHN3aWZ0Q29kZTogJ2RlbGVnYXRlLnB1dChvYmosIHNlbGYpJyxcbiAgICB9LFxuXG4gICAgZnVuY3Rpb24gb3V0cHV0SlNPTihvdXRwdXR0ZXIpIHtcbiAgICAgIG91dHB1dHRlci5vdXRwdXQodGhpcy5kZWxlZ2F0ZSk7XG4gICAgfSxcblxuICAgIHtcbiAgICAgIG5hbWU6ICdyZW1vdmUnLFxuICAgICAgY29kZTogZnVuY3Rpb24gcmVtb3ZlKG9iaiwgcykge1xuICAgICAgICB0aGlzLmRlbGVnYXRlLnJlbW92ZShvYmosIHRoaXMpO1xuICAgICAgfSxcbiAgICAgIHN3aWZ0Q29kZTogJ2RlbGVnYXRlLnJlbW92ZShvYmosIHNlbGYpJyxcbiAgICB9LFxuXG4gICAge1xuICAgICAgbmFtZTogJ3Jlc2V0JyxcbiAgICAgIGNvZGU6IGZ1bmN0aW9uIHJlc2V0KHMpIHtcbiAgICAgICAgdGhpcy5kZWxlZ2F0ZS5yZXNldCh0aGlzKTtcbiAgICAgIH0sXG4gICAgICBzd2lmdENvZGU6ICdkZWxlZ2F0ZS5yZXNldChzZWxmKScsXG4gICAgfSxcbiAgXSxcbiAgbGlzdGVuZXJzOiBbXG4gICAge1xuICAgICAgbmFtZTogJ3VwZGF0ZScsXG4gICAgICBjb2RlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIG9sZCA9IHRoaXMuaW5uZXJTdWI7XG4gICAgICAgIG9sZCAmJiBvbGQuZGV0YWNoKCk7XG4gICAgICAgIHRoaXMuaW5uZXJTdWIgPSB0aGlzLmRhbyAmJiB0aGlzLmRhby5saXN0ZW5fKHRoaXMuZGFvLl9fY29udGV4dF9fLCB0aGlzKTtcbiAgICAgICAgaWYgKCBvbGQgKSB0aGlzLnJlc2V0KCk7XG4gICAgICB9XG4gICAgfVxuICBdXG59KTtcblxuXG5mb2FtLkNMQVNTKHtcbiAgcGFja2FnZTogJ2ZvYW0uZGFvJyxcbiAgbmFtZTogJ0FycmF5U2luaycsXG4gIGV4dGVuZHM6ICdmb2FtLmRhby5BYnN0cmFjdFNpbmsnLFxuXG4gIGNvbnN0YW50czoge1xuICAgIC8vIER1YWwgdG8gb3V0cHV0SlNPTiBtZXRob2QuXG4gICAgLy9cbiAgICAvLyBUT0RPKG1hcmtkaXR0bWVyKTogVHVybiBpbnRvIHN0YXRpYyBtZXRob2Q6IFwicGFyc2VKU09OXCIgb25jZVxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mb2FtLWZyYW1ld29yay9mb2FtMi9pc3N1ZXMvNjEzIGlzIGZpeGVkLlxuICAgIFBBUlNFX0pTT046IGZ1bmN0aW9uKGpzb24sIG9wdF9jbHMsIG9wdF9jdHgpIHtcbiAgICAgIHZhciBjbHMgPSBqc29uLm9mIHx8IG9wdF9jbHM7XG4gICAgICB2YXIgYXJyYXkgPSBqc29uLmFycmF5O1xuICAgICAgaWYgKCAhIGFycmF5ICkgcmV0dXJuIGZvYW0uZGFvLkFycmF5U2luay5jcmVhdGUoeyBvZjogY2xzIH0sIG9wdF9jdHgpO1xuICAgICAgaWYgKCBmb2FtLnR5cGVPZihjbHMpID09PSBmb2FtLlN0cmluZyApXG4gICAgICAgIGNscyA9ICggb3B0X2N0eCB8fCBmb2FtICkubG9va3VwKGNscyk7XG5cbiAgICAgIHJldHVybiBmb2FtLmRhby5BcnJheVNpbmsuY3JlYXRlKHtcbiAgICAgICAgb2Y6IGNscyxcbiAgICAgICAgYXJyYXk6IGZvYW0uanNvbi5wYXJzZShhcnJheSwgY2xzLCBvcHRfY3R4KVxuICAgICAgfSwgb3B0X2N0eCk7XG4gICAgfVxuICB9LFxuXG4gIHByb3BlcnRpZXM6IFtcbiAgICB7XG4gICAgICBjbGFzczogJ0xpc3QnLFxuICAgICAgbmFtZTogJ2FycmF5JyxcbiAgICAgIGFkYXB0OiBmdW5jdGlvbihvbGQsIG51KSB7XG4gICAgICAgIGlmICggISB0aGlzLm9mICkgcmV0dXJuIG51O1xuICAgICAgICB2YXIgY2xzID0gdGhpcy5vZjtcbiAgICAgICAgZm9yICggdmFyIGkgPSAwOyBpIDwgbnUubGVuZ3RoOyBpKysgKSB7XG4gICAgICAgICAgaWYgKCAhIGNscy5pc0luc3RhbmNlKG51W2ldKSApXG4gICAgICAgICAgICBudVtpXSA9IGNscy5jcmVhdGUobnVbaV0sIHRoaXMuX19zdWJDb250ZXh0X18pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudTtcbiAgICAgIH0sXG4gICAgICBmYWN0b3J5OiBmdW5jdGlvbigpIHsgcmV0dXJuIFtdOyB9LFxuICAgICAgamF2YUZhY3Rvcnk6IGByZXR1cm4gbmV3IGphdmEudXRpbC5BcnJheUxpc3QoKTtgXG4gICAgfSxcbiAgICB7XG4gICAgICBjbGFzczogJ0NsYXNzJyxcbiAgICAgIG5hbWU6ICdvZidcbiAgICB9LFxuICAgIHtcbiAgICAgIG5hbWU6ICdhJyxcbiAgICAgIHRyYW5zaWVudDogdHJ1ZSxcbiAgICAgIGdldHRlcjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMud2FybignVXNlIG9mIGRlcHJlY2F0ZWQgQXJyYXlTaW5rLmEnKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXJyYXk7XG4gICAgICB9XG4gICAgfVxuICBdLFxuXG4gIG1ldGhvZHM6IFtcbiAgICB7XG4gICAgICBuYW1lOiAncHV0JyxcbiAgICAgIGNvZGU6IGZ1bmN0aW9uIHB1dChvLCBzdWIpIHtcbiAgICAgICAgdmFyIGNscyA9IHRoaXMub2Y7XG4gICAgICAgIGlmICggISBjbHMgKSB7XG4gICAgICAgICAgdGhpcy5hcnJheS5wdXNoKG8pO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIGNscy5pc0luc3RhbmNlKG8pIClcbiAgICAgICAgICB0aGlzLmFycmF5LnB1c2gobyk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICB0aGlzLmFycmF5LnB1c2goY2xzLmNyZWF0ZShvLCB0aGlzLl9fc3ViQ29udGV4dF9fKSk7XG4gICAgICB9LFxuICAgICAgc3dpZnRDb2RlOiAnYXJyYXkuYXBwZW5kKG9iaiknLFxuICAgICAgamF2YUNvZGU6ICdpZiAoIGdldEFycmF5KCkgPT0gbnVsbCApIHNldEFycmF5KG5ldyBqYXZhLnV0aWwuQXJyYXlMaXN0KCkpO1xcbidcbiAgICAgICAgICAgICAgICArYGdldEFycmF5KCkuYWRkKG9iaik7YFxuICAgIH0sXG4gICAgZnVuY3Rpb24gb3V0cHV0SlNPTihvdXRwdXR0ZXIpIHtcbiAgICAgIG91dHB1dHRlci5zdGFydCgneycpO1xuICAgICAgdmFyIG91dHB1dENsYXNzTmFtZSA9IG91dHB1dHRlci5vdXRwdXRDbGFzc05hbWVzO1xuICAgICAgaWYgKCBvdXRwdXRDbGFzc05hbWUgKSB7XG4gICAgICAgIG91dHB1dHRlci5ubCgpLmluZGVudCgpLm91dChcbiAgICAgICAgICAgIG91dHB1dHRlci5tYXliZUVzY2FwZUtleSgnY2xhc3MnKSwgJzonLCBvdXRwdXR0ZXIucG9zdENvbG9uU3RyLCAnXCInLFxuICAgICAgICAgICAgdGhpcy5jbHNfLmlkLCAnXCInKTtcbiAgICAgIH1cblxuICAgICAgdmFyIGFycmF5ID0gdGhpcy5hcnJheTtcbiAgICAgIHZhciBvdXRwdXRDb21tYSA9IG91dHB1dENsYXNzTmFtZTtcbiAgICAgIGlmICggdGhpcy5vZiApIHtcbiAgICAgICAgb3V0cHV0dGVyLm91dHB1dFByb3BlcnR5KHRoaXMsIHRoaXMuT0YsIG91dHB1dENvbW1hKTtcbiAgICAgICAgb3V0cHV0Q29tbWEgPSB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKCBhcnJheS5sZW5ndGggPiAwICkge1xuICAgICAgICBpZiAoIG91dHB1dENvbW1hICkgb3V0cHV0dGVyLm91dCgnLCcpO1xuICAgICAgICBvdXRwdXR0ZXIubmwoKS5pbmRlbnQoKS5vdXRwdXRQcm9wZXJ0eU5hbWUodGhpcy5BUlJBWSkuXG4gICAgICAgICAgICBvdXQoJzonLCBvdXRwdXR0ZXIucG9zdENvbG9uU3RyKS5vdXRwdXQoYXJyYXksIHRoaXMub2YpO1xuICAgICAgfVxuICAgICAgb3V0cHV0dGVyLm5sKCkuZW5kKCd9Jyk7XG4gICAgfVxuICBdXG59KTtcblxuXG5mb2FtLkNMQVNTKHtcbiAgcGFja2FnZTogJ2ZvYW0uZGFvJyxcbiAgbmFtZTogJ1Byb21pc2VkREFPJyxcbiAgZXh0ZW5kczogJ2ZvYW0uZGFvLkFic3RyYWN0REFPJyxcblxuICBwcm9wZXJ0aWVzOiBbXG4gICAge1xuICAgICAgY2xhc3M6ICdQcm9taXNlZCcsXG4gICAgICBvZjogJ2ZvYW0uZGFvLkRBTycsXG4gICAgICBtZXRob2RzOiBbICdwdXRfJywgJ3JlbW92ZV8nLCAnZmluZF8nLCAnc2VsZWN0XycsICdyZW1vdmVBbGxfJywgJ2xpc3Rlbl8nLCAnY21kXycgXSxcbiAgICAgIG5hbWU6ICdwcm9taXNlJ1xuICAgIH1cbiAgXVxufSk7XG5cblxuZm9hbS5DTEFTUyh7XG4gIHBhY2thZ2U6ICdmb2FtLmRhbycsXG4gIG5hbWU6ICdMb2NhbFN0b3JhZ2VEQU8nLFxuICBleHRlbmRzOiAnZm9hbS5kYW8uQXJyYXlEQU8nLFxuXG4gIHByb3BlcnRpZXM6IFtcbiAgICB7XG4gICAgICBuYW1lOiAgJ25hbWUnLFxuICAgICAgbGFiZWw6ICdTdG9yZSBOYW1lJyxcbiAgICAgIGNsYXNzOiAgJ2ZvYW0uY29yZS5TdHJpbmcnXG4gICAgfVxuICBdLFxuXG4gIG1ldGhvZHM6IFtcbiAgICBmdW5jdGlvbiBpbml0KCkge1xuICAgICAgdmFyIG9ianMgPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbSh0aGlzLm5hbWUpO1xuICAgICAgaWYgKCBvYmpzICkgdGhpcy5hcnJheSA9IGZvYW0uanNvbi5wYXJzZVN0cmluZyhvYmpzLCB0aGlzKTtcblxuICAgICAgdGhpcy5vbi5wdXQuc3ViKHRoaXMudXBkYXRlZCk7XG4gICAgICB0aGlzLm9uLnJlbW92ZS5zdWIodGhpcy51cGRhdGVkKTtcblxuICAgICAgLy8gVE9ETzogYmFzZSBvbiBhbiBpbmRleGVkIERBT1xuICAgIH1cbiAgXSxcblxuICBsaXN0ZW5lcnM6IFtcbiAgICB7XG4gICAgICBuYW1lOiAndXBkYXRlZCcsXG4gICAgICBpc01lcmdlZDogdHJ1ZSxcbiAgICAgIG1lcmdlRGVsYXk6IDEwMCxcbiAgICAgIGNvZGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbSh0aGlzLm5hbWUsIGZvYW0uanNvbi5zdHJpbmdpZnkodGhpcy5hcnJheSkpO1xuICAgICAgfVxuICAgIH1cbiAgXVxufSk7XG5cblxuZm9hbS5MSUIoe1xuICBuYW1lOiAnZm9hbS5TdHJpbmcnLFxuICBtZXRob2RzOiBbXG4gICAge1xuICAgICAgbmFtZTogJ2Rhb2l6ZScsXG4gICAgICBjb2RlOiBmb2FtLkZ1bmN0aW9uLm1lbW9pemUxKGZ1bmN0aW9uKHN0cikge1xuICAgICAgICAvLyBUdXJucyBTb21lQ2xhc3NOYW1lIGludG8gc29tZUNsYXNzTmFtZURBTyxcbiAgICAgICAgLy8gb2YgcGFja2FnZS5DbGFzc05hbWUgaW50byBwYWNrYWdlLkNsYXNzTmFtZURBT1xuICAgICAgICByZXR1cm4gc3RyLnN1YnN0cmluZygwLCAxKS50b0xvd2VyQ2FzZSgpICsgc3RyLnN1YnN0cmluZygxKSArICdEQU8nO1xuICAgICAgfSlcbiAgICB9XG4gIF1cbn0pO1xuXG5cbmZvYW0uQ0xBU1Moe1xuICBwYWNrYWdlOiAnZm9hbS5kYW8nLFxuICBuYW1lOiAnSW52YWxpZEFyZ3VtZW50RXhjZXB0aW9uJyxcbiAgZXh0ZW5kczogJ2ZvYW0uZGFvLkV4dGVybmFsRXhjZXB0aW9uJyxcblxuICBwcm9wZXJ0aWVzOiBbXG4gICAge1xuICAgICAgY2xhc3M6ICdTdHJpbmcnLFxuICAgICAgbmFtZTogJ21lc3NhZ2UnXG4gICAgfVxuICBdXG59KTtcbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmZvYW0uSU5URVJGQUNFKHtcbiAgcGFja2FnZTogJ2ZvYW0uZGFvJyxcbiAgbmFtZTogJ0RBT0RlY29yYXRvcicsXG5cbiAgbWV0aG9kczogW1xuICAgIHtcbiAgICAgIG5hbWU6ICd3cml0ZScsXG4gICAgICByZXR1cm5zOiAnUHJvbWlzZScsXG4gICAgICBqYXZhUmV0dXJuczogJ2ZvYW0uY29yZS5GT2JqZWN0JyxcbiAgICAgIGFyZ3M6IFtcbiAgICAgICAge1xuICAgICAgICAgIG5hbWU6ICdjb250ZXh0J1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgbmFtZTogJ2RhbydcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIG5hbWU6ICdvYmonLFxuICAgICAgICAgIGphdmFUeXBlOiAnZm9hbS5jb3JlLkZPYmplY3QnXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICBuYW1lOiAnZXhpc3RpbmcnLFxuICAgICAgICAgIGphdmFUeXBlOiAnZm9hbS5jb3JlLkZPYmplY3QnXG4gICAgICAgIH1cbiAgICAgIF1cbiAgICB9LFxuICAgIHtcbiAgICAgIG5hbWU6ICdyZWFkJyxcbiAgICAgIHJldHVybnM6ICdQcm9taXNlJyxcbiAgICAgIGphdmFSZXR1cm5zOiAnZm9hbS5jb3JlLkZPYmplY3QnLFxuICAgICAgYXJnczogW1xuICAgICAgICB7XG4gICAgICAgICAgbmFtZTogJ2NvbnRleHQnXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICBuYW1lOiAnZGFvJ1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgbmFtZTogJ29iaicsXG4gICAgICAgICAgamF2YVR5cGU6ICdmb2FtLmNvcmUuRk9iamVjdCdcbiAgICAgICAgfVxuICAgICAgXVxuICAgIH0sXG4gICAge1xuICAgICAgbmFtZTogJ3JlbW92ZScsXG4gICAgICByZXR1cm5zOiAnUHJvbWlzZScsXG4gICAgICBqYXZhUmV0dXJuczogJ2ZvYW0uY29yZS5GT2JqZWN0JyxcbiAgICAgIGFyZ3M6IFtcbiAgICAgICAge1xuICAgICAgICAgIG5hbWU6ICdjb250ZXh0J1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgbmFtZTogJ2RhbydcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIG5hbWU6ICdvYmonLFxuICAgICAgICAgIGphdmFUeXBlOiAnZm9hbS5jb3JlLkZPYmplY3QnXG4gICAgICAgIH1cbiAgICAgIF1cbiAgICB9XG4gIF1cbn0pO1xuXG5cbmZvYW0uQ0xBU1Moe1xuICBwYWNrYWdlOiAnZm9hbS5kYW8nLFxuICBuYW1lOiAnQWJzdHJhY3REQU9EZWNvcmF0b3InLFxuICBpbXBsZW1lbnRzOiBbJ2ZvYW0uZGFvLkRBT0RlY29yYXRvciddLFxuXG4gIG1ldGhvZHM6IFtcbiAgICBmdW5jdGlvbiB3cml0ZShYLCBkYW8sIG9iaiwgZXhpc3RpbmcpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUob2JqKTtcbiAgICB9LFxuICAgIGZ1bmN0aW9uIHJlYWQoWCwgZGFvLCBvYmopIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUob2JqKTtcbiAgICB9LFxuICAgIGZ1bmN0aW9uIHJlbW92ZShYLCBkYW8sIG9iaikge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShvYmopO1xuICAgIH1cbiAgXVxufSk7XG5cblxuZm9hbS5DTEFTUyh7XG4gIHBhY2thZ2U6ICdmb2FtLmRhbycsXG4gIG5hbWU6ICdDb21wb3VuZERBT0RlY29yYXRvcicsXG5cbiAgaW1wbGVtZW50czogWydmb2FtLmRhby5EQU9EZWNvcmF0b3InXSxcblxuICBwcm9wZXJ0aWVzOiBbXG4gICAge1xuICAgICAgY2xhc3M6ICdBcnJheScsXG4gICAgICBuYW1lOiAnZGVjb3JhdG9ycydcbiAgICB9XG4gIF0sXG5cbiAgbWV0aG9kczogW1xuICAgIGZ1bmN0aW9uIHdyaXRlKFgsIGRhbywgb2JqLCBleGlzdGluZykge1xuICAgICAgdmFyIGkgPSAwO1xuICAgICAgdmFyIGQgPSB0aGlzLmRlY29yYXRvcnM7XG5cbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUob2JqKS50aGVuKGZ1bmN0aW9uIGEob2JqKSB7XG4gICAgICAgIHJldHVybiBkW2ldID8gZFtpKytdLndyaXRlKFgsIGRhbywgb2JqLCBleGlzdGluZykudGhlbihhKSA6IG9iajtcbiAgICAgIH0pO1xuICAgIH0sXG5cbiAgICBmdW5jdGlvbiByZWFkKFgsIGRhbywgb2JqKSB7XG4gICAgICB2YXIgaSA9IDA7XG4gICAgICB2YXIgZCA9IHRoaXMuZGVjb3JhdG9ycztcblxuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShvYmopLnRoZW4oZnVuY3Rpb24gYShvYmopIHtcbiAgICAgICAgcmV0dXJuIGRbaV0gPyBkW2krK10ucmVhZChYLCBkYW8sIG9iaikudGhlbihhKSA6IG9iajtcbiAgICAgIH0pO1xuICAgIH0sXG5cbiAgICBmdW5jdGlvbiByZW1vdmUoWCwgZGFvLCBvYmopIHtcbiAgICAgIHZhciBpID0gMDtcbiAgICAgIHZhciBkID0gdGhpcy5kZWNvcmF0b3JzO1xuXG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKG9iaikudGhlbihmdW5jdGlvbiBhKG9iaikge1xuICAgICAgICByZXR1cm4gZFtpXSA/IGRbaSsrXS5yZW1vdmUoWCwgZGFvLCBvYmopLnRoZW4oYSkgOiBvYmo7XG4gICAgICB9KTtcbiAgICB9XG4gIF1cbn0pO1xuXG5cbmZvYW0uQ0xBU1Moe1xuICBwYWNrYWdlOiAnZm9hbS5kYW8nLFxuICBuYW1lOiAnRGVjb3JhdGVkREFPJyxcbiAgZXh0ZW5kczogJ2ZvYW0uZGFvLlByb3h5REFPJyxcblxuICByZXF1aXJlczogW1xuICAgICdmb2FtLm1sYW5nLnNpbmsuQ291bnQnLFxuICAgICdmb2FtLm1sYW5nLnNpbmsuR3JvdXBCeSdcbiAgXSxcblxuICBwcm9wZXJ0aWVzOiBbXG4gICAge1xuLy8gICAgICBjbGFzczogJ0ZPYmplY3RQcm9wZXJ0eScsXG4vLyAgICAgIG9mOiAnZm9hbS5kYW8uREFPRGVjb3JhdG9yJyxcbiAgICAgIG5hbWU6ICdkZWNvcmF0b3InXG4gICAgfSxcbiAgICB7XG4gICAgICBjbGFzczogJ2ZvYW0uZGFvLkRBT1Byb3BlcnR5JyxcbiAgICAgIG5hbWU6ICdkYW8nLFxuICAgICAgZmFjdG9yeTogZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLmRlbGVnYXRlOyB9XG4gICAgfVxuICBdLFxuXG4gIG1ldGhvZHM6IFtcbiAgICB7XG4gICAgICBuYW1lOiAncHV0XycsXG4gICAgICBjb2RlOiBmdW5jdGlvbih4LCBvYmopIHtcbiAgICAgICAgLy8gVE9ETzogb2JqLmlkIGNhbiBnZW5lcmF0ZSBnYXJiYXNlLCB3b3VsZCBiZVxuICAgICAgICAvLyBzbGlnaHRseSBmYXN0ZXIgaWYgREFPLmZpbmQoKSBjb3VsZCB0YWtlIGFuIG9iamVjdFxuICAgICAgICAvLyBhcyB3ZWxsLlxuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIHJldHVybiAoICggISBvYmouaWQgKSA/IFByb21pc2UucmVzb2x2ZShudWxsKSA6IHRoaXMuZGFvLmZpbmRfKHgsIG9iai5pZCkgKS50aGVuKGZ1bmN0aW9uKGV4aXN0aW5nKSB7XG4gICAgICAgICAgcmV0dXJuIHNlbGYuZGVjb3JhdG9yLndyaXRlKHgsIHNlbGYuZGFvLCBvYmosIGV4aXN0aW5nKTtcbiAgICAgICAgfSkudGhlbihmdW5jdGlvbihvYmopIHtcbiAgICAgICAgICByZXR1cm4gc2VsZi5kZWxlZ2F0ZS5wdXRfKHgsIG9iaik7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICB7XG4gICAgICBuYW1lOiAncmVtb3ZlXycsXG4gICAgICBjb2RlOiBmdW5jdGlvbih4LCBvYmopIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICByZXR1cm4gdGhpcy5kZWNvcmF0b3IucmVtb3ZlKHgsIHNlbGYuZGFvLCBvYmopLnRoZW4oZnVuY3Rpb24ob2JqKSB7XG4gICAgICAgICAgaWYgKCBvYmogKSByZXR1cm4gc2VsZi5kZWxlZ2F0ZS5yZW1vdmVfKHgsIG9iaik7XG4gICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAge1xuICAgICAgbmFtZTogJ2ZpbmRfJyxcbiAgICAgIGNvZGU6IGZ1bmN0aW9uKHgsIGlkKSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgcmV0dXJuIHRoaXMuZGVsZWdhdGUuZmluZF8oeCwgaWQpLnRoZW4oZnVuY3Rpb24ob2JqKSB7XG4gICAgICAgICAgcmV0dXJuIHNlbGYuZGVjb3JhdG9yLnJlYWQoeCwgc2VsZi5kYW8sIG9iaik7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKlxuICAgIFRPRE86IHdvcmtzLCBidXQgaXMgZXhwZW5zaXZlLCBzbyBzaG91bGRuJ3QgYmUgdXNlZCBpZiBkZWNvcmF0b3IucmVhZCBpc24ndCBzZXRcbiAgICBmdW5jdGlvbiBzZWxlY3RfKHgsIHNpbmssIHNraXAsIGxpbWl0LCBvcmRlciwgcHJlZGljYXRlKSB7XG4gICAgICBpZiAoICEgc2luayApIHNpbmsgPSBmb2FtLmRhby5BcnJheVNpbmsuY3JlYXRlKCk7XG4gICAgICAvLyBObyBuZWVkIHRvIGRlY29yYXRlIGlmIHdlJ3JlIGp1c3QgY291bnRpbmcuXG4gICAgICBpZiAoIHRoaXMuQ291bnQuaXNJbnN0YW5jZShzaW5rKSApIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGVsZWdhdGUuc2VsZWN0Xyh4LCBzaW5rLCBza2lwLCBsaW1pdCwgb3JkZXIsIHByZWRpY2F0ZSk7XG4gICAgICB9XG5cbiAgICAgIC8vIFRPRE86IFRoaXMgaXMgdG9vIHNpbXBsaXN0aWMsIGZpeFxuICAgICAgaWYgKCB0aGlzLkdyb3VwQnkuaXNJbnN0YW5jZShzaW5rKSApIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGVsZWdhdGUuc2VsZWN0Xyh4LCBzaW5rLCBza2lwLCBsaW1pdCwgb3JkZXIsIHByZWRpY2F0ZSk7XG4gICAgICB9XG5cbiAgICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICB2YXIgcHMgPSBbXTtcblxuICAgICAgICBzZWxmLmRlbGVnYXRlLnNlbGVjdCh7XG4gICAgICAgICAgcHV0OiBmdW5jdGlvbihvKSB7XG4gICAgICAgICAgICB2YXIgcCA9IHNlbGYuZGVjb3JhdG9yLnJlYWQoeCwgc2VsZi5kYW8sIG8pO1xuICAgICAgICAgICAgcC50aGVuKGZ1bmN0aW9uKG8pIHsgc2luay5wdXQobyk7IH0pXG4gICAgICAgICAgICBwcy5wdXNoKHApO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgZW9mOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICB9XG4gICAgICAgIH0sIHNraXAsIGxpbWl0LCBvcmRlciwgcHJlZGljYXRlKS50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICAgIFByb21pc2UuYWxsKHBzKS50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmVzb2x2ZShzaW5rKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSlcbiAgICAgIH0pO1xuICAgIH1cbiAgICAqL1xuXG4gICAgLy8gVE9ETzogU2VsZWN0L3JlbW92ZUFsbCBzdXBwb3J0LiAgSG93IGRvIHdlIGRvIHNlbGVjdFxuICAgIC8vIHdpdGhvdXQgYnJlYWtpbmcgTURBTyBvcHRpbWl6YXRpb25zP1xuICAgIC8vIHtcbiAgICAvLyAgIG5hbWU6ICdzZWxlY3QnLFxuICAgIC8vICAgY29kZTogZnVuY3Rpb24oKSB7XG4gICAgLy8gICB9XG4gICAgLy8gfSxcbiAgICAvLyB7XG4gICAgLy8gICBuYW1lOiAncmVtb3ZlQWxsJyxcbiAgICAvLyAgIGNvZGU6IGZ1bmN0aW9uKCkge1xuICAgIC8vICAgfVxuICAgIC8vIH1cbiAgXVxufSk7XG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5mb2FtLkNMQVNTKHtcbiAgcGFja2FnZTogJ2ZvYW0uZGFvJyxcbiAgbmFtZTogJ0Fic3RyYWN0REFPJyxcbiAgaW1wbGVtZW50czogWyAnZm9hbS5kYW8uREFPJyBdLFxuICBhYnN0cmFjdDogdHJ1ZSxcblxuICBkb2N1bWVudGF0aW9uOiAnQWJzdHJhY3QgYmFzZSBjbGFzcyBmb3IgaW1wbGVtZW50aW5nIERBT3MuJyxcblxuICByZXF1aXJlczogW1xuICAgICdmb2FtLmRhby5FeHRlcm5hbEV4Y2VwdGlvbicsXG4gICAgJ2ZvYW0uZGFvLkZpbHRlcmVkREFPJyxcbiAgICAnZm9hbS5kYW8uSW50ZXJuYWxFeGNlcHRpb24nLFxuICAgICdmb2FtLmRhby5MaW1pdGVkREFPJyxcbiAgICAnZm9hbS5kYW8uTGltaXRlZFNpbmsnLFxuICAgICdmb2FtLmRhby5PcmRlcmVkREFPJyxcbiAgICAnZm9hbS5kYW8uT3JkZXJlZFNpbmsnLFxuICAgICdmb2FtLmRhby5QaXBlU2luaycsXG4gICAgJ2ZvYW0uZGFvLlByZWRpY2F0ZWRTaW5rJyxcbiAgICAnZm9hbS5kYW8uUHJveHlEQU8nLFxuICAgICdmb2FtLmRhby5SZXNldExpc3RlbmVyJyxcbiAgICAnZm9hbS5kYW8uU2tpcERBTycsXG4gICAgJ2ZvYW0uZGFvLlNraXBTaW5rJ1xuICBdLFxuXG4gIHRvcGljczogW1xuICAgIHtcbiAgICAgIG5hbWU6ICdvbicsXG4gICAgICB0b3BpY3M6IFtcbiAgICAgICAgJ3B1dCcsXG4gICAgICAgICdyZW1vdmUnLFxuICAgICAgICAncmVzZXQnXG4gICAgICBdXG4gICAgfVxuICBdLFxuXG4gIHByb3BlcnRpZXM6IFtcbiAgICB7XG4gICAgICAvKipcbiAgICAgICAgU2V0IHRvIHRoZSBuYW1lIG9yIGNsYXNzIGluc3RhbmNlIG9mIHRoZSB0eXBlIG9mIG9iamVjdCB0aGUgREFPXG4gICAgICAgIHdpbGwgc3RvcmUuXG4gICAgICAqL1xuICAgICAgY2xhc3M6ICdDbGFzcycsXG4gICAgICBqYXZhSW5mb1R5cGU6ICdmb2FtLmNvcmUuQWJzdHJhY3RPYmplY3RQcm9wZXJ0eUluZm8nLFxuICAgICAgamF2YVR5cGU6ICdmb2FtLmNvcmUuQ2xhc3NJbmZvJyxcbiAgICAgIG5hbWU6ICdvZicsXG4gICAgfSxcbiAgICB7XG4gICAgICBqYXZhVHlwZTogJ2ZvYW0uY29yZS5Qcm9wZXJ0eUluZm8nLFxuICAgICAgamF2YUluZm9UeXBlOiAnZm9hbS5jb3JlLkFic3RyYWN0T2JqZWN0UHJvcGVydHlJbmZvJyxcbiAgICAgIHN3aWZ0VHlwZTogJ1Byb3BlcnR5SW5mbycsXG4gICAgICBuYW1lOiAncHJpbWFyeUtleScsXG4gICAgICBzd2lmdEV4cHJlc3Npb25BcmdzOiBbJ29mJ10sXG4gICAgICBzd2lmdEV4cHJlc3Npb246ICdyZXR1cm4gb2YuYXhpb20oYnlOYW1lOiBcImlkXCIpIGFzISBQcm9wZXJ0eUluZm8nLFxuICAgICAgamF2YUZhY3Rvcnk6IGBcbnJldHVybiBnZXRPZigpID09IG51bGwgPyBudWxsIDogKGZvYW0uY29yZS5Qcm9wZXJ0eUluZm8pIGdldE9mKCkuZ2V0QXhpb21CeU5hbWUoXCJpZFwiKTtcbiAgICAgIGAsXG4gICAgfSxcbiAgXSxcblxuICBtZXRob2RzOiBbXG4gICAge1xuICAgICAgLyoqXG4gICAgICAgIFJldHVybnMgYSBmaWx0ZXJlZCBEQU8gdGhhdCBvbmx5IHJldHVybnMgb2JqZWN0cyB3aGljaCBtYXRjaCB0aGVcbiAgICAgICAgZ2l2ZW4gcHJlZGljYXRlLlxuICAgICAgKi9cbiAgICAgIG5hbWU6ICdpblgnLFxuICAgICAgY29kZTogZnVuY3Rpb24oeCkge1xuICAgICAgICByZXR1cm4gdGhpcy5Qcm94eURBTy5jcmVhdGUoe2RlbGVnYXRlOiB0aGlzfSwgeCk7XG4gICAgICB9LFxuICAgICAgamF2YUNvZGU6IGByZXR1cm4gbmV3IFByb3h5REFPLkJ1aWxkZXIoeCkuc2V0RGVsZWdhdGUodGhpcykuYnVpbGQoKTtgLFxuICAgIH0sXG5cbiAgICB7XG4gICAgICAvKipcbiAgICAgICAgUmV0dXJucyBhIGZpbHRlcmVkIERBTyB0aGF0IG9ubHkgcmV0dXJucyBvYmplY3RzIHdoaWNoIG1hdGNoIHRoZVxuICAgICAgICBnaXZlbiBwcmVkaWNhdGUuXG4gICAgICAqL1xuICAgICAgbmFtZTogJ3doZXJlJyxcbiAgICAgIGNvZGU6IGZ1bmN0aW9uIHdoZXJlKHApIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuRmlsdGVyZWREQU8uY3JlYXRlKHtcbiAgICAgICAgICBkZWxlZ2F0ZTogdGhpcyxcbiAgICAgICAgICBwcmVkaWNhdGU6IHBcbiAgICAgICAgfSk7XG4gICAgICB9LFxuICAgICAgc3dpZnRDb2RlOiBmdW5jdGlvbigpIHsvKlxuICAgICAgICByZXR1cm4gRmlsdGVyZWREQU9fY3JlYXRlKFtcbiAgICAgICAgICBcImRlbGVnYXRlXCI6IHNlbGYsXG4gICAgICAgICAgXCJwcmVkaWNhdGVcIjogcHJlZGljYXRlLFxuICAgICAgICBdKTtcbiAgICAgICovfSxcbiAgICAgIGphdmFDb2RlOiBgXG5yZXR1cm4gbmV3IEZpbHRlcmVkREFPKHByZWRpY2F0ZSwgdGhpcyk7XG4gICAgICBgLFxuICAgIH0sXG5cbiAgICB7XG4gICAgICAvKipcbiAgICAgICAgUmV0dXJucyBhIGZpbHRlcmVkIERBTyB0aGF0IG9yZGVycyBzZWxlY3QoKSBieSB0aGUgZ2l2ZW5cbiAgICAgICAgb3JkZXJpbmcuXG4gICAgICAqL1xuICAgICAgbmFtZTogJ29yZGVyQnknLFxuICAgICAgY29kZTogZnVuY3Rpb24gb3JkZXJCeSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuT3JkZXJlZERBTy5jcmVhdGUoe1xuICAgICAgICAgIGRlbGVnYXRlOiB0aGlzLFxuICAgICAgICAgIGNvbXBhcmF0b3I6IGZvYW0uY29tcGFyZS50b0NvbXBhcmUoQXJyYXkuZnJvbShhcmd1bWVudHMpKVxuICAgICAgICB9KTtcbiAgICAgIH0sXG4gICAgICBqYXZhQ29kZTogYFxucmV0dXJuIG5ldyBPcmRlcmVkREFPKGNvbXBhcmF0b3IsIHRoaXMpO1xuICAgICAgYCxcbiAgICB9LFxuXG4gICAge1xuICAgICAgLyoqXG4gICAgICAgIFJldHVybnMgYSBmaWx0ZXJlZCBEQU8gdGhhdCBza2lwcyB0aGUgZ2l2ZW4gbnVtYmVyIG9mIGl0ZW1zXG4gICAgICAgIG9uIGEgc2VsZWN0KClcbiAgICAgICovXG4gICAgICBuYW1lOiAnc2tpcCcsXG4gICAgICBjb2RlOiBmdW5jdGlvbiBza2lwKC8qIE51bWJlciAqLyBzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLlNraXBEQU8uY3JlYXRlKHtcbiAgICAgICAgICBkZWxlZ2F0ZTogdGhpcyxcbiAgICAgICAgICBza2lwXzogc1xuICAgICAgICB9KTtcbiAgICAgIH0sXG4gICAgICBzd2lmdENvZGU6IGZ1bmN0aW9uKCkgey8qXG5yZXR1cm4gU2tpcERBT19jcmVhdGUoW1xuICBcImRlbGVnYXRlXCI6IHNlbGYsXG4gIFwic2tpcF9cIjogY291bnQsXG5dKVxuICAgICAgKi99LFxuICAgICAgamF2YUNvZGU6IGBcbnJldHVybiBuZXcgU2tpcERBTyhjb3VudCwgdGhpcyk7XG4gICAgICBgLFxuICAgIH0sXG5cbiAgICB7XG4gICAgICAvKipcbiAgICAgICAgUmV0dXJucyBhIGZpbHRlcmVkIERBTyB0aGF0IHN0b3BzIHByb2R1Y2luZyBpdGVtcyBhZnRlciB0aGVcbiAgICAgICAgZ2l2ZW4gY291bnQgb24gYSBzZWxlY3QoKS5cbiAgICAgICovXG4gICAgICBuYW1lOiAnbGltaXQnLFxuICAgICAgY29kZTogZnVuY3Rpb24gbGltaXQoLyogTnVtYmVyICovIGwpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuTGltaXRlZERBTy5jcmVhdGUoe1xuICAgICAgICAgIGRlbGVnYXRlOiB0aGlzLFxuICAgICAgICAgIGxpbWl0XzogbFxuICAgICAgICB9KTtcbiAgICAgIH0sXG4gICAgICBzd2lmdENvZGU6IGZ1bmN0aW9uKCkgey8qXG5yZXR1cm4gTGltaXRlZERBT19jcmVhdGUoW1xuICBcImRlbGVnYXRlXCI6IHNlbGYsXG4gIFwibGltaXRfXCI6IGNvdW50LFxuXSlcbiAgICAgICovfSxcbiAgICAgIGphdmFDb2RlOiBgXG5yZXR1cm4gbmV3IExpbWl0ZWREQU8oY291bnQsIHRoaXMpO1xuICAgICAgYCxcbiAgICB9LFxuXG4gICAge1xuICAgICAgbmFtZTogJ3B1dCcsXG4gICAgICBjb2RlOiBmdW5jdGlvbihvYmopIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucHV0Xyh0aGlzLl9fY29udGV4dF9fLCBvYmopO1xuICAgICAgfSxcbiAgICAgIHN3aWZ0Q29kZTogJ3JldHVybiB0cnkgcHV0XyhfX2NvbnRleHRfXywgb2JqKScsXG4gICAgICBqYXZhQ29kZTogYHJldHVybiB0aGlzLnB1dF8odGhpcy5nZXRYKCksIG9iaik7YCxcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICBTZWxlY3RzIHRoZSBjb250ZW50cyBvZiB0aGlzIERBTyBpbnRvIGEgc2luaywgdGhlbiBsaXN0ZW5zIHRvIGtlZXBcbiAgICAgIHRoZSBzaW5rIHVwIHRvIGRhdGUuIFJldHVybnMgYSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2l0aCB0aGUgc3Vic2NyaXB0aW9uLlxuICAgICAgVE9ETzogVGhpcyB3aWxsIHByb2JhYmx5IG1pc3MgZXZlbnRzIHRoYXQgaGFwcGVuIGR1cmluZyB0aGUgc2VsZWN0IGJ1dCBiZWZvcmUgdGhlXG4gICAgICBsaXN0ZW4gY2FsbC4gIFdlIHNob3VsZCBjaGVjayBpZiB0aGlzIGlzIHRoZSBjYXNlIGFuZCBmaXggaXQgaWYgc28uXG4gICAgKi9cbiAgICB7XG4gICAgICBuYW1lOiAncGlwZScsXG4gICAgICBjb2RlOiBmdW5jdGlvbihzaW5rKSB7Ly8sIHNraXAsIGxpbWl0LCBvcmRlciwgcHJlZGljYXRlKSB7XG4gICAgICAgIHRoaXMucGlwZV8odGhpcy5fX2NvbnRleHRfXywgc2luaywgdW5kZWZpbmVkKTtcbiAgICAgIH0sXG4gICAgICBzd2lmdENvZGU6ICdyZXR1cm4gdHJ5IHBpcGVfKF9fY29udGV4dF9fLCBzaW5rKScsXG4gICAgICBqYXZhQ29kZTogYHRoaXMucGlwZV8odGhpcy5nZXRYKCksIHNpbmspO2AsXG4gICAgfSxcblxuICAgIHtcbiAgICAgIG5hbWU6ICdwaXBlXycsXG4gICAgICBjb2RlOiBmdW5jdGlvbih4LCBzaW5rLCBwcmVkaWNhdGUpIHtcbiAgICAgICAgdmFyIGRhbyA9IHRoaXM7XG5cbiAgICAgICAgdmFyIHNpbmsgPSB0aGlzLlBpcGVTaW5rLmNyZWF0ZSh7XG4gICAgICAgICAgZGVsZWdhdGU6IHNpbmssXG4gICAgICAgICAgZGFvOiB0aGlzXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHZhciBzdWIgPSB0aGlzLmxpc3RlbihzaW5rKTsgLy8sIHNraXAsIGxpbWl0LCBvcmRlciwgcHJlZGljYXRlKTtcbiAgICAgICAgc2luay5yZXNldCgpO1xuXG4gICAgICAgIHJldHVybiBzdWI7XG4gICAgICB9LFxuICAgICAgamF2YUNvZGU6IGBcbnRocm93IG5ldyBVbnN1cHBvcnRlZE9wZXJhdGlvbkV4Y2VwdGlvbigpO1xuICAgICAgYCxcbiAgICB9LFxuXG4gICAge1xuICAgICAgbmFtZTogJ2xpc3RlbicsXG4gICAgICBjb2RlOiBmdW5jdGlvbihzaW5rKSB7XG4gICAgICAgIGlmICggISBmb2FtLmNvcmUuRk9iamVjdC5pc0luc3RhbmNlKHNpbmspICkge1xuICAgICAgICAgIHNpbmsgPSBmb2FtLmRhby5Bbm9ueW1vdXNTaW5rLmNyZWF0ZSh7IHNpbms6IHNpbmsgfSwgdGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMubGlzdGVuXyh0aGlzLl9fY29udGV4dF9fLCBzaW5rLCB1bmRlZmluZWQpO1xuICAgICAgfSxcbiAgICAgIHN3aWZ0Q29kZTogJ3JldHVybiB0cnkgbGlzdGVuXyhfX2NvbnRleHRfXywgc2luayknLFxuICAgICAgamF2YUNvZGU6IGB0aGlzLmxpc3Rlbl8odGhpcy5nZXRYKCksIHNpbmssIHByZWRpY2F0ZSk7YCxcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICBLZWVwcyB0aGUgZ2l2ZW4gc2luayB1cCB0byBkYXRlIHdpdGggY2hhbmdlcyB0byB0aGlzIERBTy5cbiAgICAqL1xuICAgIHtcbiAgICAgIG5hbWU6ICdsaXN0ZW5fJyxcbiAgICAgIGNvZGU6IGZ1bmN0aW9uKHgsIHNpbmssIHByZWRpY2F0ZSkge1xuICAgICAgICB2YXIgbXlTaW5rID0gdGhpcy5kZWNvcmF0ZUxpc3RlbmVyXyhzaW5rLCBwcmVkaWNhdGUpO1xuXG4gICAgICAgIHZhciBzdWIgPSBmb2FtLmNvcmUuRk9iamVjdC5jcmVhdGUoKTtcblxuICAgICAgICBzdWIub25EZXRhY2godGhpcy5vbi5zdWIoZnVuY3Rpb24ocywgb24sIGUsIG9iaikge1xuICAgICAgICAgIHN3aXRjaChlKSB7XG4gICAgICAgICAgICBjYXNlICdwdXQnOlxuICAgICAgICAgICAgICBteVNpbmsucHV0KG9iaiwgc3ViKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdyZW1vdmUnOlxuICAgICAgICAgICAgICBteVNpbmsucmVtb3ZlKG9iaiwgc3ViKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdyZXNldCc6XG4gICAgICAgICAgICAgIG15U2luay5yZXNldChzdWIpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH0pKTtcblxuICAgICAgICByZXR1cm4gc3ViO1xuICAgICAgfSxcbiAgICAgIHN3aWZ0Q29kZTogZnVuY3Rpb24oKSB7LypcbmxldCBteVNpbmsgPSBkZWNvcmF0ZUxpc3RlbmVyXyhzaW5rLCBwcmVkaWNhdGUpXG5yZXR1cm4gb24uc3ViKGxpc3RlbmVyOiB7IChzdWI6IFN1YnNjcmlwdGlvbiwgYXJnczogW0FueT9dKSAtPiBWb2lkIGluXG4gIGd1YXJkIGxldCB0b3BpYyA9IGFyZ3NbMV0gYXM/IFN0cmluZyBlbHNlIHsgcmV0dXJuIH1cbiAgc3dpdGNoIHRvcGljIHtcbiAgICBjYXNlIFwicHV0XCI6XG4gICAgICBteVNpbmsucHV0KGFyZ3MubGFzdCBhcyEgRk9iamVjdCwgc3ViKVxuICAgICAgYnJlYWtcbiAgICBjYXNlIFwicmVtb3ZlXCI6XG4gICAgICBteVNpbmsucmVtb3ZlKGFyZ3MubGFzdCBhcyEgRk9iamVjdCwgc3ViKVxuICAgICAgYnJlYWtcbiAgICBjYXNlIFwicmVzZXRcIjpcbiAgICAgIG15U2luay5yZXNldChzdWIpXG4gICAgICBicmVha1xuICAgIGRlZmF1bHQ6XG4gICAgICBicmVha1xuICB9XG59KVxuICAgICAgKi99LFxuICAgICAgamF2YUNvZGU6IGBcbnNpbmsgPSBkZWNvcmF0ZUxpc3RlbmVyXyhzaW5rLCBwcmVkaWNhdGUpO1xubGlzdGVuZXJzXy5hZGQobmV3IERBT0xpc3RlbmVyKHNpbmssIGxpc3RlbmVyc18pKTtcbiAgICAgIGAsXG4gICAgfSxcblxuICAgIHtcbiAgICAgIG5hbWU6ICdkZWNvcmF0ZUxpc3RlbmVyXycsXG4gICAgICBzd2lmdFJldHVybnM6ICdTaW5rJyxcbiAgICAgIGphdmFSZXR1cm5zOiAnU2luaycsXG4gICAgICBhcmdzOiBbXG4gICAgICAgIHtcbiAgICAgICAgICBuYW1lOiAnc2luaycsXG4gICAgICAgICAgc3dpZnRUeXBlOiAnU2luaycsXG4gICAgICAgICAgamF2YVR5cGU6ICdTaW5rJyxcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIG5hbWU6ICdwcmVkaWNhdGUnLFxuICAgICAgICAgIHN3aWZ0VHlwZTogJ0ZvYW1QcmVkaWNhdGU/JyxcbiAgICAgICAgICBqYXZhVHlwZTogJ2ZvYW0ubWxhbmcucHJlZGljYXRlLlByZWRpY2F0ZScsXG4gICAgICAgIH0sXG4gICAgICBdLFxuICAgICAgY29kZTogZnVuY3Rpb24gZGVjb3JhdGVMaXN0ZW5lcl8oc2luaywgcHJlZGljYXRlKSB7XG4gICAgICAgIGlmICggcHJlZGljYXRlICkge1xuICAgICAgICAgIHJldHVybiB0aGlzLlJlc2V0TGlzdGVuZXIuY3JlYXRlKHsgZGVsZWdhdGU6IHNpbmsgfSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gc2luaztcbiAgICAgIH0sXG4gICAgICBzd2lmdENvZGU6IGZ1bmN0aW9uKCkgey8qXG4vLyBUT0RPOiBUaGVyZSBhcmUgcHJvYmFibHkgb3B0aW1pemF0aW9ucyB3ZSBjYW4gbWFrZSBoZXJlXG4vLyBidXQgZXZlcnkgdGltZSBJIHRyeSBpdCBjb21lcyBvdXQgYnJva2VuLiAgU28gZm9yIHRoZSB0aW1lIGJlaW5nLFxuLy8gaWYgeW91IGhhdmUgYW55IHNvcnQgb2Ygc2tpcC9saW1pdC9vcmRlci9wcmVkaWNhdGUgd2Ugd2lsbCBqdXN0XG4vLyBpc3N1ZSByZXNldCBldmVudHMgZm9yIGV2ZXJ5dGhpbmcuXG5pZiBwcmVkaWNhdGUgIT0gbmlsIHtcbiAgcmV0dXJuIHNlbGYuUmVzZXRMaXN0ZW5lcl9jcmVhdGUoW1wiZGVsZWdhdGVcIjogc2lua10pXG59XG5yZXR1cm4gc2lua1xuICAgICAgKi99LFxuICAgICAgamF2YUNvZGU6IGBcbmlmICggcHJlZGljYXRlICE9IG51bGwgKSB7XG4gIHNpbmsgPSBuZXcgUHJlZGljYXRlZFNpbmsocHJlZGljYXRlLCBzaW5rKTtcbn1cblxucmV0dXJuIHNpbms7XG4gICAgICBgLFxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgIFVzZWQgYnkgREFPIGltcGxlbWVudGF0aW9ucyB0byBhcHBseSBmaWx0ZXJzIHRvIGEgc2luaywgb2Z0ZW4gaW4gYVxuICAgICAgc2VsZWN0KCkgb3IgcmVtb3ZlQWxsKCkgaW1wbGVtZW50YXRpb24uXG4gICAgICBAcHJpdmF0ZVxuICAgICovXG4gICAge1xuICAgICAgbmFtZTogJ2RlY29yYXRlU2lua18nLFxuICAgICAgc3dpZnRSZXR1cm5zOiAnU2luaycsXG4gICAgICBqYXZhUmV0dXJuczogJ2ZvYW0uZGFvLlNpbmsnLFxuICAgICAgYXJnczogW1xuICAgICAgICB7XG4gICAgICAgICAgbmFtZTogJ3NpbmsnLFxuICAgICAgICAgIHN3aWZ0VHlwZTogJ1NpbmsnLFxuICAgICAgICAgIGphdmFUeXBlOiAnZm9hbS5kYW8uU2luaycsXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICBuYW1lOiAnc2tpcCcsXG4gICAgICAgICAgc3dpZnRUeXBlOiAnSW50PycsXG4gICAgICAgICAgamF2YVR5cGU6ICdsb25nJyxcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIG5hbWU6ICdsaW1pdCcsXG4gICAgICAgICAgc3dpZnRUeXBlOiAnSW50PycsXG4gICAgICAgICAgamF2YVR5cGU6ICdsb25nJyxcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIG5hbWU6ICdvcmRlcicsXG4gICAgICAgICAgc3dpZnRUeXBlOiAnQ29tcGFyYXRvcj8nLFxuICAgICAgICAgIGphdmFUeXBlOiAnZm9hbS5tbGFuZy5vcmRlci5Db21wYXJhdG9yJyxcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIG5hbWU6ICdwcmVkaWNhdGUnLFxuICAgICAgICAgIHN3aWZ0VHlwZTogJ0ZvYW1QcmVkaWNhdGU/JyxcbiAgICAgICAgICBqYXZhVHlwZTogJ2ZvYW0ubWxhbmcucHJlZGljYXRlLlByZWRpY2F0ZScsXG4gICAgICAgIH0sXG4gICAgICBdLFxuICAgICAgY29kZTogZnVuY3Rpb24gZGVjb3JhdGVTaW5rXyhzaW5rLCBza2lwLCBsaW1pdCwgb3JkZXIsIHByZWRpY2F0ZSkge1xuICAgICAgICBpZiAoIGxpbWl0ICE9IHVuZGVmaW5lZCApIHtcbiAgICAgICAgICBzaW5rID0gdGhpcy5MaW1pdGVkU2luay5jcmVhdGUoe1xuICAgICAgICAgICAgbGltaXQ6IGxpbWl0LFxuICAgICAgICAgICAgZGVsZWdhdGU6IHNpbmtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICggc2tpcCAhPSB1bmRlZmluZWQgKSB7XG4gICAgICAgICAgc2luayA9IHRoaXMuU2tpcFNpbmsuY3JlYXRlKHtcbiAgICAgICAgICAgIHNraXA6IHNraXAsXG4gICAgICAgICAgICBkZWxlZ2F0ZTogc2lua1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCBvcmRlciAhPSB1bmRlZmluZWQgKSB7XG4gICAgICAgICAgc2luayA9IHRoaXMuT3JkZXJlZFNpbmsuY3JlYXRlKHtcbiAgICAgICAgICAgIGNvbXBhcmF0b3I6IG9yZGVyLFxuICAgICAgICAgICAgZGVsZWdhdGU6IHNpbmtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICggcHJlZGljYXRlICE9IHVuZGVmaW5lZCApIHtcbiAgICAgICAgICBzaW5rID0gdGhpcy5QcmVkaWNhdGVkU2luay5jcmVhdGUoe1xuICAgICAgICAgICAgcHJlZGljYXRlOiBwcmVkaWNhdGUucGFydGlhbEV2YWwgP1xuICAgICAgICAgICAgICBwcmVkaWNhdGUucGFydGlhbEV2YWwoKSA6XG4gICAgICAgICAgICAgIHByZWRpY2F0ZSxcbiAgICAgICAgICAgIGRlbGVnYXRlOiBzaW5rXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gc2luaztcbiAgICAgIH0sXG4gICAgICBzd2lmdENvZGU6IGZ1bmN0aW9uKCkgey8qXG52YXIgc2luayA9IHNpbmtcbmlmIGxpbWl0ICE9IG5pbCB7XG4gIHNpbmsgPSBMaW1pdGVkU2lua19jcmVhdGUoW1xuICAgIFwibGltaXRcIjogbGltaXQsXG4gICAgXCJkZWxlZ2F0ZVwiOiBzaW5rXG4gIF0pXG59XG5pZiBza2lwICE9IG5pbCB7XG4gIHNpbmsgPSBTa2lwU2lua19jcmVhdGUoW1xuICAgIFwic2tpcFwiOiBza2lwLFxuICAgIFwiZGVsZWdhdGVcIjogc2lua1xuICBdKVxufVxuaWYgb3JkZXIgIT0gbmlsIHtcbiAgc2luayA9IE9yZGVyZWRTaW5rX2NyZWF0ZShbXG4gICAgXCJjb21wYXJhdG9yXCI6IG9yZGVyLFxuICAgIFwiZGVsZWdhdGVcIjogc2luayxcbiAgXSlcbn1cbmlmIHByZWRpY2F0ZSAhPSBuaWwge1xuICBzaW5rID0gUHJlZGljYXRlZFNpbmtfY3JlYXRlKFtcbiAgICBcInByZWRpY2F0ZVwiOiBwcmVkaWNhdGUsXG4gICAgXCJkZWxlZ2F0ZVwiOiBzaW5rLFxuICBdKVxufVxucmV0dXJuIHNpbmtcbiAgICAgICovfSxcbiAgICAgIGphdmFDb2RlOiBgXG5yZXR1cm4gZGVjb3JhdGVTaW5rKGdldFgoKSwgc2luaywgc2tpcCwgbGltaXQsIG9yZGVyLCBwcmVkaWNhdGUpO1xuICAgICAgYCxcbiAgICB9LFxuXG4gICAge1xuICAgICAgbmFtZTogJ3JlbW92ZScsXG4gICAgICBjb2RlOiBmdW5jdGlvbiByZW1vdmUob2JqKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlbW92ZV8odGhpcy5fX2NvbnRleHRfXywgb2JqKTtcbiAgICAgIH0sXG4gICAgICBzd2lmdENvZGU6ICdyZXR1cm4gdHJ5IHJlbW92ZV8oX19jb250ZXh0X18sIG9iaiknLFxuICAgICAgamF2YUNvZGU6IGByZXR1cm4gdGhpcy5yZW1vdmVfKHRoaXMuZ2V0WCgpLCBvYmopO2AsXG4gICAgfSxcblxuICAgIHtcbiAgICAgIG5hbWU6ICdyZW1vdmVBbGwnLFxuICAgICAgY29kZTogZnVuY3Rpb24gcmVtb3ZlQWxsKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZW1vdmVBbGxfKHRoaXMuX19jb250ZXh0X18sIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCk7XG4gICAgICB9LFxuICAgICAgc3dpZnRDb2RlOiAncmV0dXJuIHRyeSByZW1vdmVBbGxfKF9fY29udGV4dF9fKScsXG4gICAgICBqYXZhQ29kZTogYFxudGhpcy5yZW1vdmVBbGxfKHRoaXMuZ2V0WCgpLCAwLCB0aGlzLk1BWF9TQUZFX0lOVEVHRVIsIG51bGwsIG51bGwpO1xuICAgICAgYCxcbiAgICB9LFxuXG4gICAgZnVuY3Rpb24gY29tcGFyZVRvKG90aGVyKSB7XG4gICAgICBpZiAoICEgb3RoZXIgKSByZXR1cm4gMTtcbiAgICAgIHJldHVybiB0aGlzID09PSBvdGhlciA/IDAgOiBmb2FtLnV0aWwuY29tcGFyZSh0aGlzLiRVSUQsIG90aGVyLiRVSUQpO1xuICAgIH0sXG5cbiAgICBmdW5jdGlvbiBwcmVwYXJlU2lua18oc2luaykge1xuICAgICAgaWYgKCAhIHNpbmsgKSByZXR1cm4gZm9hbS5kYW8uQXJyYXlTaW5rLmNyZWF0ZSgpO1xuXG4gICAgICBpZiAoIGZvYW0uRnVuY3Rpb24uaXNJbnN0YW5jZShzaW5rKSApXG4gICAgICAgIHNpbmsgPSB7XG4gICAgICAgICAgcHV0OiBzaW5rLFxuICAgICAgICAgIGVvZjogZnVuY3Rpb24oKSB7fVxuICAgICAgICB9O1xuICAgICAgZWxzZSBpZiAoIHNpbmsgPT0gY29uc29sZSB8fCBzaW5rID09IGNvbnNvbGUubG9nIClcbiAgICAgICAgc2luayA9IHtcbiAgICAgICAgICBwdXQ6IGZ1bmN0aW9uKG8pIHsgY29uc29sZS5sb2cobywgZm9hbS5qc29uLlByZXR0eS5zdHJpbmdpZnkobykpOyB9LFxuICAgICAgICAgIGVvZjogZnVuY3Rpb24oKSB7fVxuICAgICAgICB9O1xuICAgICAgZWxzZSBpZiAoIHNpbmsgPT0gZ2xvYmFsLmRvY3VtZW50IClcbiAgICAgICAgc2luayA9IHtcbiAgICAgICAgICBwdXQ6IGZ1bmN0aW9uKG8pIHsgZm9hbS51Mi5EZXRhaWxWaWV3LmNyZWF0ZSh7ZGF0YTogb30pLndyaXRlKGRvY3VtZW50KTsgfSxcbiAgICAgICAgICBlb2Y6IGZ1bmN0aW9uKCkge31cbiAgICAgICAgfTtcblxuICAgICAgaWYgKCAhIGZvYW0uY29yZS5GT2JqZWN0LmlzSW5zdGFuY2Uoc2luaykgKSB7XG4gICAgICAgIHNpbmsgPSBmb2FtLmRhby5Bbm9ueW1vdXNTaW5rLmNyZWF0ZSh7IHNpbms6IHNpbmsgfSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzaW5rO1xuICAgIH0sXG5cbiAgICB7XG4gICAgICBuYW1lOiAnc2VsZWN0JyxcbiAgICAgIGNvZGU6IGZ1bmN0aW9uIHNlbGVjdChzaW5rKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNlbGVjdF8odGhpcy5fX2NvbnRleHRfXywgdGhpcy5wcmVwYXJlU2lua18oc2luayksIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCk7XG4gICAgICB9LFxuICAgICAgc3dpZnRDb2RlOiAncmV0dXJuIHRyeSBzZWxlY3RfKF9fY29udGV4dF9fLCBzaW5rKScsXG4gICAgICBqYXZhQ29kZTogYFxuc2luayA9IHByZXBhcmVTaW5rKHNpbmspO1xucmV0dXJuIHRoaXMuc2VsZWN0Xyh0aGlzLmdldFgoKSwgc2luaywgMCwgdGhpcy5NQVhfU0FGRV9JTlRFR0VSLCBudWxsLCBudWxsKTtcbiAgICAgIGAsXG4gICAgfSxcblxuICAgIHtcbiAgICAgIG5hbWU6ICdmaW5kJyxcbiAgICAgIGNvZGU6IGZ1bmN0aW9uIGZpbmQoaWQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmluZF8odGhpcy5fX2NvbnRleHRfXywgaWQpO1xuICAgICAgfSxcbiAgICAgIHN3aWZ0Q29kZTogJ3JldHVybiB0cnkgZmluZF8oX19jb250ZXh0X18sIGlkKScsXG4gICAgICBqYXZhQ29kZTogYFxuLy8gVGVtcG9yYXJ5IHVudGlsIERBTyBzdXBwb3J0cyBmaW5kXyhQcmVkaWNhdGUpIGRpcmVjdGx5XG5pZiAoIGlkIGluc3RhbmNlb2YgZm9hbS5tbGFuZy5wcmVkaWNhdGUuUHJlZGljYXRlICkge1xuICBqYXZhLnV0aWwuTGlzdCBsID0gKChMaXN0U2luaykgdGhpcy53aGVyZSgoZm9hbS5tbGFuZy5wcmVkaWNhdGUuUHJlZGljYXRlKSBpZCkubGltaXQoMSkuc2VsZWN0KG5ldyBMaXN0U2luaygpKSkuZ2V0RGF0YSgpO1xuICByZXR1cm4gbC5zaXplKCkgPT0gMSA/IChmb2FtLmNvcmUuRk9iamVjdCkgbC5nZXQoMCkgOiBudWxsO1xufVxuXG5yZXR1cm4gdGhpcy5maW5kXyh0aGlzLmdldFgoKSwgaWQpO1xuICAgICAgYCxcbiAgICB9LFxuXG4gICAge1xuICAgICAgbmFtZTogJ2NtZF8nLFxuICAgICAgY29kZTogZnVuY3Rpb24gY21kXyh4LCBvYmopIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgIH0sXG4gICAgICBqYXZhQ29kZTogYFxuLy8gVE9ET1xucmV0dXJuIG51bGw7XG4gICAgICBgLFxuICAgIH0sXG5cbiAgICB7XG4gICAgICBuYW1lOiAnY21kJyxcbiAgICAgIGNvZGU6IGZ1bmN0aW9uIGNtZChvYmopIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY21kXyh0aGlzLl9fY29udGV4dF9fLCBvYmopO1xuICAgICAgfSxcbiAgICAgIGphdmFDb2RlOiBgXG5yZXR1cm4gdGhpcy5jbWRfKHRoaXMuZ2V0WCgpLCBvYmopO1xuICAgICAgYCxcbiAgICB9LFxuXG4gICAgLy8gUGxhY2Vob2xkZXIgZnVuY3Rpb25zIHRvIHRoYXQgc2VsZWN0aW5nIGZyb20gREFPIHRvIERBTyB3b3Jrcy5cbiAgICAvKiogQHByaXZhdGUgKi9cbiAgICBmdW5jdGlvbiBlb2YoKSB7fSxcblxuICAgIC8qKiBAcHJpdmF0ZSAqL1xuICAgIGZ1bmN0aW9uIHJlc2V0KCkge30sXG5cbiAgICB7XG4gICAgICBuYW1lOiAncmVtb3ZlQWxsXycsXG4gICAgICBqYXZhQ29kZTogYFxudGhpcy5zZWxlY3RfKHgsIG5ldyBSZW1vdmVTaW5rKHgsIHRoaXMpLCBza2lwLCBsaW1pdCwgb3JkZXIsIHByZWRpY2F0ZSk7XG4gICAgICBgLFxuICAgIH0sXG4gIF0sXG4gIHN0YXRpYzogW1xuICAgIHtcbiAgICAgIG5hbWU6ICdkZWNvcmF0ZVNpbmsnLFxuICAgICAgamF2YVJldHVybnM6ICdmb2FtLmRhby5TaW5rJyxcbiAgICAgIGFyZ3M6IFtcbiAgICAgICAge1xuICAgICAgICAgIG5hbWU6ICd4JyxcbiAgICAgICAgICBqYXZhVHlwZTogJ2ZvYW0uY29yZS5YJyxcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIG5hbWU6ICdzaW5rJyxcbiAgICAgICAgICBqYXZhVHlwZTogJ2ZvYW0uZGFvLlNpbmsnLFxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgbmFtZTogJ3NraXAnLFxuICAgICAgICAgIGphdmFUeXBlOiAnbG9uZycsXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICBuYW1lOiAnbGltaXQnLFxuICAgICAgICAgIGphdmFUeXBlOiAnbG9uZycsXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICBuYW1lOiAnb3JkZXInLFxuICAgICAgICAgIGphdmFUeXBlOiAnZm9hbS5tbGFuZy5vcmRlci5Db21wYXJhdG9yJyxcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIG5hbWU6ICdwcmVkaWNhdGUnLFxuICAgICAgICAgIGphdmFUeXBlOiAnZm9hbS5tbGFuZy5wcmVkaWNhdGUuUHJlZGljYXRlJyxcbiAgICAgICAgfSxcbiAgICAgIF0sXG4gICAgICBqYXZhQ29kZTogYFxuaWYgKCAoIGxpbWl0ID4gMCApICYmICggbGltaXQgPCBBYnN0cmFjdERBTy5NQVhfU0FGRV9JTlRFR0VSICkgKSB7XG4gIHNpbmsgPSBuZXcgTGltaXRlZFNpbmsobGltaXQsIDAsIHNpbmspO1xufVxuXG5pZiAoICggc2tpcCA+IDAgKSAmJiAoIHNraXAgPCBBYnN0cmFjdERBTy5NQVhfU0FGRV9JTlRFR0VSICkgKSB7XG4gIHNpbmsgPSBuZXcgU2tpcFNpbmsoc2tpcCwgMCwgc2luayk7XG59XG5cbmlmICggb3JkZXIgIT0gbnVsbCApIHtcbiAgc2luayA9IG5ldyBPcmRlcmVkU2luayhvcmRlciwgbnVsbCwgc2luayk7XG59XG5cbmlmICggcHJlZGljYXRlICE9IG51bGwgKSB7XG4gIHNpbmsgPSBuZXcgUHJlZGljYXRlZFNpbmsocHJlZGljYXRlLCBzaW5rKTtcbn1cblxucmV0dXJuIHNpbms7XG4gICAgICBgLFxuICAgIH0sXG4gIF0sXG4gIGF4aW9tczogW1xuICAgIHtcbiAgICAgIGJ1aWxkSmF2YUNsYXNzOiBmdW5jdGlvbihjbHMpIHtcbiAgICAgICAgY2xzLmV4dHJhcy5wdXNoKGBcbnB1YmxpYyBmaW5hbCBzdGF0aWMgbG9uZyBNQVhfU0FGRV9JTlRFR0VSID0gOTAwNzE5OTI1NDc0MDk5MWw7XG5cbnB1YmxpYyBPYmplY3QgZ2V0UEsoZm9hbS5jb3JlLkZPYmplY3Qgb2JqKSB7XG4gIHJldHVybiBnZXRQcmltYXJ5S2V5KCkuZ2V0KG9iaik7XG59XG5cbnByb3RlY3RlZCBjbGFzcyBEQU9MaXN0ZW5lciBpbXBsZW1lbnRzIGZvYW0uY29yZS5EZXRhY2hhYmxlIHtcbiAgcHJvdGVjdGVkIFNpbmsgc2luaztcbiAgcHJvdGVjdGVkIGphdmEudXRpbC5Db2xsZWN0aW9uIGxpc3RlbmVycztcblxuICBwdWJsaWMgREFPTGlzdGVuZXIoU2luayBzaW5rLCBqYXZhLnV0aWwuQ29sbGVjdGlvbiBsaXN0ZW5lcnMpIHtcbiAgICB0aGlzLnNpbmsgPSBzaW5rO1xuICAgIHRoaXMubGlzdGVuZXJzID0gbGlzdGVuZXJzO1xuICB9XG5cbiAgcHVibGljIHZvaWQgZGV0YWNoKCkge1xuICAgIGxpc3RlbmVycy5yZW1vdmUodGhpcyk7XG4gIH1cblxuICBwdWJsaWMgdm9pZCBwdXQoZm9hbS5jb3JlLkZPYmplY3Qgb2JqKSB7XG4gICAgdHJ5IHtcbiAgICAgIHNpbmsucHV0KG9iaiwgdGhpcyk7XG4gICAgfSBjYXRjaCAoamF2YS5sYW5nLkV4Y2VwdGlvbiBlKSB7XG4gICAgICBkZXRhY2goKTtcbiAgICB9XG4gIH1cblxuICBwdWJsaWMgdm9pZCByZW1vdmUoZm9hbS5jb3JlLkZPYmplY3Qgb2JqKSB7XG4gICAgdHJ5IHtcbiAgICAgIHNpbmsucmVtb3ZlKG9iaiwgdGhpcyk7XG4gICAgfSBjYXRjaCAoamF2YS5sYW5nLkV4Y2VwdGlvbiBlKSB7XG4gICAgICBkZXRhY2goKTtcbiAgICB9XG4gIH1cblxuICBwdWJsaWMgdm9pZCByZXNldCgpIHtcbiAgICB0cnkge1xuICAgICAgc2luay5yZXNldCh0aGlzKTtcbiAgICB9IGNhdGNoIChqYXZhLmxhbmcuRXhjZXB0aW9uIGUpIHtcbiAgICAgIGRldGFjaCgpO1xuICAgIH1cbiAgfVxufVxuXG5wcm90ZWN0ZWQgamF2YS51dGlsLkxpc3Q8REFPTGlzdGVuZXI+IGxpc3RlbmVyc18gPSBuZXcgamF2YS51dGlsLmNvbmN1cnJlbnQuQ29weU9uV3JpdGVBcnJheUxpc3Q8REFPTGlzdGVuZXI+KCk7XG5cbnByb3RlY3RlZCB2b2lkIG9uUHV0KGZvYW0uY29yZS5GT2JqZWN0IG9iaikge1xuICBqYXZhLnV0aWwuSXRlcmF0b3I8REFPTGlzdGVuZXI+IGl0ZXIgPSBsaXN0ZW5lcnNfLml0ZXJhdG9yKCk7XG5cbiAgd2hpbGUgKCBpdGVyLmhhc05leHQoKSApIHtcbiAgICBEQU9MaXN0ZW5lciBzID0gaXRlci5uZXh0KCk7XG4gICAgcy5wdXQob2JqKTtcbiAgfVxufVxuXG5wcm90ZWN0ZWQgdm9pZCBvblJlbW92ZShmb2FtLmNvcmUuRk9iamVjdCBvYmopIHtcbiAgamF2YS51dGlsLkl0ZXJhdG9yPERBT0xpc3RlbmVyPiBpdGVyID0gbGlzdGVuZXJzXy5pdGVyYXRvcigpO1xuXG4gIHdoaWxlICggaXRlci5oYXNOZXh0KCkgKSB7XG4gICAgREFPTGlzdGVuZXIgcyA9IGl0ZXIubmV4dCgpO1xuICAgIHMucmVtb3ZlKG9iaik7XG4gIH1cbn1cblxucHJvdGVjdGVkIHZvaWQgb25SZXNldCgpIHtcbiAgamF2YS51dGlsLkl0ZXJhdG9yPERBT0xpc3RlbmVyPiBpdGVyID0gbGlzdGVuZXJzXy5pdGVyYXRvcigpO1xuXG4gIHdoaWxlICggaXRlci5oYXNOZXh0KCkgKSB7XG4gICAgREFPTGlzdGVuZXIgcyA9IGl0ZXIubmV4dCgpO1xuICAgIHMucmVzZXQoKTtcbiAgfVxufVxuXG5wcm90ZWN0ZWQgU2luayBwcmVwYXJlU2luayhTaW5rIHMpIHtcbiAgcmV0dXJuIHMgPT0gbnVsbCA/IG5ldyBMaXN0U2luaygpIDogcztcbn1cblxucHVibGljIFNpbmsgc2VsZWN0KCkge1xuICByZXR1cm4gc2VsZWN0KG51bGwpO1xufVxuXG5wdWJsaWMgc3RhdGljIFNpbmsgZGVjb3JhdGVEZWR1cFNpbmtfKFNpbmsgc2luaykge1xuICBzaW5rID0gbmV3IERlZHVwU2luayhuZXcgamF2YS51dGlsLkhhc2hTZXQoKSwgc2luayk7XG4gIHJldHVybiBzaW5rO1xufVxuICAgICAgICBgKTtcbiAgICAgIH0sXG4gICAgfSxcbiAgXSxcbn0pO1xuXG5cbmZvYW0uQ0xBU1Moe1xuICBwYWNrYWdlOiAnZm9hbS5kYW8nLFxuICBuYW1lOiAnSW50ZXJuYWxFeGNlcHRpb24nLFxuICBpbXBsZW1lbnRzOiBbJ2ZvYW0uY29yZS5FeGNlcHRpb24nXVxufSk7XG5cblxuZm9hbS5DTEFTUyh7XG4gIHBhY2thZ2U6ICdmb2FtLmRhbycsXG4gIG5hbWU6ICdFeHRlcm5hbEV4Y2VwdGlvbicsXG4gIGltcGxlbWVudHM6IFsnZm9hbS5jb3JlLkV4Y2VwdGlvbiddXG59KVxuXG5cbmZvYW0uQ0xBU1Moe1xuICBwYWNrYWdlOiAnZm9hbS5kYW8nLFxuICBuYW1lOiAnRmlsdGVyZWREQU8nLFxuICBleHRlbmRzOiAnZm9hbS5kYW8uQWJzdHJhY3REQU8nLFxuXG4gIHJlcXVpcmVzOiBbXG4gICAgJ2ZvYW0ubWxhbmcucHJlZGljYXRlLkFuZCdcbiAgXSxcblxuICBwcm9wZXJ0aWVzOiBbXG4gICAge1xuICAgICAgLy8gVE9ETzogRk9iamVjdFByb3BlcnR5IG9mIFByZWRpY2F0ZS4gRG9pbmcgdGhpcyBjdXJyZW50bHkgYnJlYWtzIGphdmEuXG4gICAgICBzd2lmdFR5cGU6ICdGb2FtUHJlZGljYXRlJyxcbiAgICAgIG5hbWU6ICdwcmVkaWNhdGUnLFxuICAgICAgcmVxdWlyZWQ6IHRydWVcbiAgICB9LFxuICAgIHtcbiAgICAgIG5hbWU6ICdvZicsXG4gICAgICBmYWN0b3J5OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGVsZWdhdGUub2Y7XG4gICAgICB9LFxuICAgICAgc3dpZnRFeHByZXNzaW9uQXJnczogWydkZWxlZ2F0ZSRvZiddLFxuICAgICAgc3dpZnRFeHByZXNzaW9uOiAncmV0dXJuIGRlbGVnYXRlJG9mIGFzISBDbGFzc0luZm8nLFxuICAgIH0sXG4gICAge1xuICAgICAgY2xhc3M6ICdQcm94eScsXG4gICAgICBvZjogJ2ZvYW0uZGFvLkRBTycsXG4gICAgICBuYW1lOiAnZGVsZWdhdGUnLFxuICAgICAgdG9waWNzOiBbICdvbicgXSwgLy8gVE9ETzogUmVtb3ZlIHRoaXMgd2hlbiBhbGwgdXNlcnMgb2YgaXQgYXJlIHVwZGF0ZWQuXG4gICAgICBmb3J3YXJkczogWyAncHV0XycsICdyZW1vdmVfJywgJ2ZpbmRfJywgJ3NlbGVjdF8nLCAncmVtb3ZlQWxsXycsICdjbWRfJyBdXG4gICAgfVxuICBdLFxuXG4gIG1ldGhvZHM6IFtcbiAgICBmdW5jdGlvbiBmaW5kXyh4LCBrZXkpIHtcbiAgICAgIHZhciBwcmVkaWNhdGUgPSB0aGlzLnByZWRpY2F0ZTtcbiAgICAgIHJldHVybiB0aGlzLmRlbGVnYXRlLmZpbmRfKHgsIGtleSkudGhlbihmdW5jdGlvbihvKSB7XG4gICAgICAgIHJldHVybiBwcmVkaWNhdGUuZihvKSA/IG8gOiBudWxsO1xuICAgICAgfSk7XG4gICAgfSxcblxuICAgIHtcbiAgICAgIG5hbWU6ICdzZWxlY3RfJyxcbiAgICAgIGNvZGU6IGZ1bmN0aW9uKHgsIHNpbmssIHNraXAsIGxpbWl0LCBvcmRlciwgcHJlZGljYXRlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRlbGVnYXRlLnNlbGVjdF8oXG4gICAgICAgICAgeCwgc2luaywgc2tpcCwgbGltaXQsIG9yZGVyLFxuICAgICAgICAgIHByZWRpY2F0ZSA/XG4gICAgICAgICAgICB0aGlzLkFuZC5jcmVhdGUoeyBhcmdzOiBbdGhpcy5wcmVkaWNhdGUsIHByZWRpY2F0ZV0gfSkgOlxuICAgICAgICAgICAgdGhpcy5wcmVkaWNhdGUpO1xuICAgICAgfSxcbiAgICAgIHN3aWZ0Q29kZTogZnVuY3Rpb24oKSB7LypcbnJldHVybiB0cnkgZGVsZWdhdGUuc2VsZWN0XyhcbiAgeCwgc2luaywgc2tpcCwgbGltaXQsIG9yZGVyLFxuICBwcmVkaWNhdGUgIT0gbmlsID9cbiAgICBBbmRfY3JlYXRlKFtcImFyZ3NcIjogW3NlbGYucHJlZGljYXRlLCBwcmVkaWNhdGUhXSBdKSA6XG4gICAgc2VsZi5wcmVkaWNhdGUpXG4gICAgICAqL30sXG4gICAgfSxcblxuICAgIGZ1bmN0aW9uIHJlbW92ZUFsbF8oeCwgc2tpcCwgbGltaXQsIG9yZGVyLCBwcmVkaWNhdGUpIHtcbiAgICAgIHJldHVybiB0aGlzLmRlbGVnYXRlLnJlbW92ZUFsbF8oXG4gICAgICAgIHgsIHNraXAsIGxpbWl0LCBvcmRlcixcbiAgICAgICAgcHJlZGljYXRlID9cbiAgICAgICAgICB0aGlzLkFuZC5jcmVhdGUoeyBhcmdzOiBbdGhpcy5wcmVkaWNhdGUsIHByZWRpY2F0ZV0gfSkgOlxuICAgICAgICAgIHRoaXMucHJlZGljYXRlKTtcbiAgICB9LFxuXG4gICAge1xuICAgICAgbmFtZTogJ2xpc3Rlbl8nLFxuICAgICAgY29kZTogZnVuY3Rpb24gbGlzdGVuXyh4LCBzaW5rLCBwcmVkaWNhdGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGVsZWdhdGUubGlzdGVuXyhcbiAgICAgICAgICB4LCBzaW5rLFxuICAgICAgICAgIHByZWRpY2F0ZSA/XG4gICAgICAgICAgICB0aGlzLkFuZC5jcmVhdGUoeyBhcmdzOiBbdGhpcy5wcmVkaWNhdGUsIHByZWRpY2F0ZV0gfSkgOlxuICAgICAgICAgICAgdGhpcy5wcmVkaWNhdGUpO1xuICAgICAgfSxcbiAgICAgIHN3aWZ0Q29kZTogYFxucmV0dXJuIHRyeSBkZWxlZ2F0ZS5saXN0ZW5fKFxuICB4LCBzaW5rLFxuICBwcmVkaWNhdGUgIT0gbmlsID9cbiAgICBBbmRfY3JlYXRlKFtcImFyZ3NcIjogW3NlbGYucHJlZGljYXRlLCBwcmVkaWNhdGVdXSkgOlxuICAgIHByZWRpY2F0ZSlcbiAgICAgIGAsXG4gICAgfSxcbiAgXVxufSk7XG5cblxuZm9hbS5DTEFTUyh7XG4gIHBhY2thZ2U6ICdmb2FtLmRhbycsXG4gIG5hbWU6ICdPcmRlcmVkREFPJyxcbiAgZXh0ZW5kczogJ2ZvYW0uZGFvLlByb3h5REFPJyxcblxuICBwcm9wZXJ0aWVzOiBbXG4gICAge1xuICAgICAgbmFtZTogJ2NvbXBhcmF0b3InXG4gICAgfVxuICBdLFxuXG4gIG1ldGhvZHM6IFtcbiAgICBmdW5jdGlvbiBzZWxlY3RfKHgsIHNpbmssIHNraXAsIGxpbWl0LCBvcmRlciwgcHJlZGljYXRlKSB7XG4gICAgICByZXR1cm4gdGhpcy5kZWxlZ2F0ZS5zZWxlY3RfKHgsIHNpbmssIHNraXAsIGxpbWl0LCBvcmRlciB8fCB0aGlzLmNvbXBhcmF0b3IsIHByZWRpY2F0ZSk7XG4gICAgfSxcbiAgICBmdW5jdGlvbiByZW1vdmVBbGxfKHgsIHNraXAsIGxpbWl0LCBvcmRlciwgcHJlZGljYXRlKSB7XG4gICAgICByZXR1cm4gdGhpcy5kZWxlZ2F0ZS5yZW1vdmVBbGxfKHgsIHNraXAsIGxpbWl0LCBvcmRlciB8fCB0aGlzLmNvbXBhcmF0b3IsIHByZWRpY2F0ZSk7XG4gICAgfVxuICBdXG59KTtcblxuXG5mb2FtLkNMQVNTKHtcbiAgcGFja2FnZTogJ2ZvYW0uZGFvJyxcbiAgbmFtZTogJ1NraXBEQU8nLFxuICBleHRlbmRzOiAnZm9hbS5kYW8uUHJveHlEQU8nLFxuXG4gIHByb3BlcnRpZXM6IFtcbiAgICB7XG4gICAgICBjbGFzczogJ0ludCcsXG4gICAgICBuYW1lOiAnc2tpcF8nLFxuICAgIH1cbiAgXSxcblxuICBtZXRob2RzOiBbXG4gICAge1xuICAgICAgbmFtZTogJ3NlbGVjdF8nLFxuICAgICAgY29kZTogZnVuY3Rpb24gc2VsZWN0Xyh4LCBzaW5rLCBza2lwLCBsaW1pdCwgb3JkZXIsIHByZWRpY2F0ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5kZWxlZ2F0ZS5zZWxlY3RfKHgsIHNpbmssIHRoaXMuc2tpcF8sIGxpbWl0LCBvcmRlciwgcHJlZGljYXRlKTtcbiAgICAgIH0sXG4gICAgICBzd2lmdENvZGU6IGZ1bmN0aW9uKCkgey8qXG5yZXR1cm4gdHJ5IGRlbGVnYXRlLnNlbGVjdF8oeCwgc2luaywgc2tpcF8sIGxpbWl0LCBvcmRlciwgcHJlZGljYXRlKVxuICAgICAgKi99LFxuICAgIH0sXG4gICAgZnVuY3Rpb24gcmVtb3ZlQWxsXyh4LCBza2lwLCBsaW1pdCwgb3JkZXIsIHByZWRpY2F0ZSkge1xuICAgICAgcmV0dXJuIHRoaXMuZGVsZWdhdGUucmVtb3ZlQWxsXyh4LCB0aGlzLnNraXBfLCBsaW1pdCwgb3JkZXIsIHByZWRpY2F0ZSk7XG4gICAgfVxuICBdXG59KTtcblxuXG5mb2FtLkNMQVNTKHtcbiAgcGFja2FnZTogJ2ZvYW0uZGFvJyxcbiAgbmFtZTogJ0xpbWl0ZWREQU8nLFxuICBleHRlbmRzOiAnZm9hbS5kYW8uUHJveHlEQU8nLFxuXG4gIHByb3BlcnRpZXM6IFtcbiAgICB7XG4gICAgICBjbGFzczogJ0ludCcsXG4gICAgICBuYW1lOiAnbGltaXRfJ1xuICAgIH1cbiAgXSxcblxuICBtZXRob2RzOiBbXG4gICAge1xuICAgICAgbmFtZTogJ3NlbGVjdF8nLFxuICAgICAgY29kZTogZnVuY3Rpb24gc2VsZWN0Xyh4LCBzaW5rLCBza2lwLCBsaW1pdCwgb3JkZXIsIHByZWRpY2F0ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5kZWxlZ2F0ZS5zZWxlY3RfKFxuICAgICAgICAgIHgsIHNpbmssIHNraXAsXG4gICAgICAgICAgbGltaXQgIT09IHVuZGVmaW5lZCA/IE1hdGgubWluKHRoaXMubGltaXRfLCBsaW1pdCkgOiB0aGlzLmxpbWl0XyxcbiAgICAgICAgICBvcmRlciwgcHJlZGljYXRlKTtcbiAgICAgIH0sXG4gICAgICBzd2lmdENvZGU6IGZ1bmN0aW9uKCkgey8qXG5yZXR1cm4gdHJ5IGRlbGVnYXRlLnNlbGVjdF8oXG4gICAgeCwgc2luaywgc2tpcCxcbiAgICBtaW4obGltaXRfLCBsaW1pdCksXG4gICAgb3JkZXIsIHByZWRpY2F0ZSk7XG4gICAgICAqL30sXG4gICAgfSxcblxuICAgIGZ1bmN0aW9uIHJlbW92ZUFsbF8oeCwgc2tpcCwgbGltaXQsIG9yZGVyLCBwcmVkaWNhdGUpIHtcbiAgICAgIHJldHVybiB0aGlzLmRlbGVnYXRlLnJlbW92ZUFsbF8oXG4gICAgICAgIHgsIHNraXAsXG4gICAgICAgIGxpbWl0ICE9PSB1bmRlZmluZWQgPyBNYXRoLm1pbih0aGlzLmxpbWl0XywgbGltaXQpIDogdGhpcy5saW1pdF8sXG4gICAgICAgIG9yZGVyLCBwcmVkaWNhdGUpO1xuICAgIH1cbiAgXVxufSk7XG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5mb2FtLkNMQVNTKHtcbiAgcGFja2FnZTogJ2ZvYW0uZGFvJyxcbiAgbmFtZTogJ0RBT1Byb3BlcnR5JyxcbiAgZXh0ZW5kczogJ0ZPYmplY3RQcm9wZXJ0eScsXG5cbiAgZG9jdW1lbnRhdGlvbjogJ1Byb3BlcnR5IGZvciBzdG9yaW5nIGEgcmVmZXJlbmNlIHRvIGEgREFPLicsXG5cbiAgcmVxdWlyZXM6IFsgJ2ZvYW0uZGFvLlByb3h5REFPJyBdLFxuXG4gIHByb3BlcnRpZXM6IFtcbiAgICB7XG4gICAgICBuYW1lOiAndmlldycsXG4gICAgICB2YWx1ZToge2NsYXNzOiAnZm9hbS5jb21pY3MuSW5saW5lQnJvd3NlclZpZXcnfSxcbiAgICB9LFxuICAgIFsnb2YnLCAnZm9hbS5kYW8uREFPJ11cbiAgXSxcblxuICBtZXRob2RzOiBbXG4gICAgZnVuY3Rpb24gaW5zdGFsbEluUHJvdG8ocHJvdG8pIHtcbiAgICAgIHRoaXMuU1VQRVIocHJvdG8pO1xuXG4gICAgICB2YXIgbmFtZSA9IHRoaXMubmFtZTtcbiAgICAgIHZhciBwcm9wID0gdGhpcztcblxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb3RvLCBuYW1lICsgJyRwcm94eScsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiBkYW9Qcm94eUdldHRlcigpIHtcbiAgICAgICAgICB2YXIgcHJveHkgPSBwcm9wLlByb3h5REFPLmNyZWF0ZSh7ZGVsZWdhdGU6IHRoaXNbbmFtZV19KTtcbiAgICAgICAgICB0aGlzW25hbWUgKyAnJHByb3h5J10gPSBwcm94eTtcblxuICAgICAgICAgIHRoaXMuc3ViKCdwcm9wZXJ0eUNoYW5nZScsIG5hbWUsIGZ1bmN0aW9uKF8sIF9fLCBfX18sIHMpIHtcbiAgICAgICAgICAgIHByb3h5LmRlbGVnYXRlID0gcy5nZXQoKTtcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIHJldHVybiBwcm94eTtcbiAgICAgICAgfSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICB9KTtcbiAgICB9XG4gIF1cbn0pO1xuLyoqXG4gICogQGxpY2Vuc2VcbiAgKiBDb3B5cmlnaHQgMjAxNyBUaGUgRk9BTSBBdXRob3JzLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICAqL1xuXG5mb2FtLklOVEVSRkFDRSh7XG4gIHBhY2thZ2U6ICdmb2FtLmRhbycsXG4gIG5hbWU6ICdTUUxTdGF0ZW1lbnQnLFxuXG4gIG1ldGhvZHM6IFtcbiAgICB7XG4gICAgICBuYW1lOiAnY3JlYXRlU3RhdGVtZW50JyxcbiAgICAgIGphdmFSZXR1cm5zOiAnU3RyaW5nJ1xuICAgIH0sXG4gICAge1xuICAgICAgbmFtZTogJ3ByZXBhcmVTdGF0ZW1lbnQnLFxuICAgICAgamF2YVJldHVybnM6ICd2b2lkJyxcbiAgICAgIGphdmFUaHJvd3M6IFsnamF2YS5zcWwuU1FMRXhjZXB0aW9uJ10sXG4gICAgICBhcmdzOiBbXG4gICAgICAgIHtcbiAgICAgICAgICBuYW1lOiAnc3RtdCcsXG4gICAgICAgICAgamF2YVR5cGU6ICdmb2FtLmRhby5wZy5JbmRleGVkUHJlcGFyZWRTdGF0ZW1lbnQnXG4gICAgICAgIH1cbiAgICAgIF1cbiAgICB9XG4gIF1cbn0pOy8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IFRoZSBGT0FNIEF1dGhvcnMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqL1xuXG5mb2FtLklOVEVSRkFDRSh7XG4gIHBhY2thZ2U6ICdmb2FtLm1sYW5nLm9yZGVyJyxcbiAgbmFtZTogJ0NvbXBhcmF0b3InLFxuXG4gIGRvY3VtZW50YXRpb246ICdJbnRlcmZhY2UgZm9yIGNvbXBhcmluZyB0d28gdmFsdWVzOiAtMTogbzEgPCBvMiwgMDogbzEgPT0gbzIsIDE6IG8xID4gbzIuJyxcblxuICBtZXRob2RzOiBbXG4gICAge1xuICAgICAgbmFtZTogJ2NvbXBhcmUnLFxuICAgICAgc3dpZnRSZXR1cm5zOiAnSW50JyxcbiAgICAgIGFyZ3M6IFtcbiAgICAgICAgJ28xJyxcbiAgICAgICAgJ28yJ1xuICAgICAgXVxuICAgIH0sXG4gICAge1xuICAgICAgbmFtZTogJ3RvSW5kZXgnLFxuICAgICAgYXJnczogW1xuICAgICAgICAndGFpbCdcbiAgICAgIF1cbiAgICB9LFxuICAgIHtcbiAgICAgIC8vIFRPRE86IHdoeSBpcyB0aGlzIGhlcmU/XG4gICAgICAvKiogUmV0dXJucyByZW1hbmluZyBvcmRlcmluZyB3aXRob3V0IHRoaXMgZmlyc3Qgb25lLCB3aGljaCBtYXkgYmUgdGhlXG4gICAgICAgIG9ubHkgb25lLiAqL1xuICAgICAgbmFtZTogJ29yZGVyVGFpbCdcbiAgICB9LFxuICAgIHtcbiAgICAgIC8vIFRPRE86IHdoeSBpcyB0aGlzIGhlcmU/XG4gICAgICAvKiogVGhlIHByb3BlcnR5LCBpZiBhbnksIHNvcnRlZCBieSB0aGlzIG9yZGVyaW5nLiAqL1xuICAgICAgbmFtZTogJ29yZGVyUHJpbWFyeVByb3BlcnR5J1xuICAgIH0sXG4gICAge1xuICAgICAgLy8gVE9ETzogd2h5IGlzIHRoaXMgaGVyZT9cbiAgICAgIC8qKiBSZXR1cm5zIDEgb3IgLTEgZm9yIGFzY2VuZGluZy9kZXNjZW5kaW5nICovXG4gICAgICBuYW1lOiAnb3JkZXJEaXJlY3Rpb24nXG4gICAgfVxuICBdXG59KTtcbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IFRoZSBGT0FNIEF1dGhvcnMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqL1xuXG4vLyBUT0RPKGJyYWRlbik6IFBvcnQgdGhlIHBhcnRpYWxFdmFsKCkgY29kZSBvdmVyIGhlcmUuXG5cbmZvYW0uQ0xBU1Moe1xuICBwYWNrYWdlOiAnZm9hbS5tbGFuZy5zaW5rJyxcbiAgbmFtZTogJ0NvdW50JyxcbiAgZXh0ZW5kczogJ2ZvYW0uZGFvLkFic3RyYWN0U2luaycsXG4gIGltcGxlbWVudHM6IFsgJ2ZvYW0uY29yZS5TZXJpYWxpemFibGUnIF0sXG5cbiAgZG9jdW1lbnRhdGlvbjogJ1Npbmsgd2hpY2ggY291bnRzIG51bWJlciBvZiBvYmplY3RzIHB1dCgpLicsXG5cbiAgcHJvcGVydGllczogW1xuICAgIHtcbiAgICAgIGNsYXNzOiAnTG9uZycsXG4gICAgICBuYW1lOiAndmFsdWUnXG4gICAgfVxuICBdLFxuXG4gIG1ldGhvZHM6IFtcbiAgICB7XG4gICAgICBuYW1lOiAncHV0JyxcbiAgICAgIGNvZGU6IGZ1bmN0aW9uKCkgeyB0aGlzLnZhbHVlKysgfSxcbiAgICAgIHN3aWZ0Q29kZTogJ3ZhbHVlKz0xJyxcbiAgICB9LFxuICAgIHtcbiAgICAgIG5hbWU6ICdyZW1vdmUnLFxuICAgICAgY29kZTogZnVuY3Rpb24oKSB7IHRoaXMudmFsdWUtLSB9LFxuICAgICAgc3dpZnRDb2RlOiAndmFsdWUtPTEnLFxuICAgIH0sXG4gICAge1xuICAgICAgbmFtZTogJ3Jlc2V0JyxcbiAgICAgIGNvZGU6IGZ1bmN0aW9uKCkgeyB0aGlzLnZhbHVlID0gMCB9LFxuICAgICAgc3dpZnRDb2RlOiAndmFsdWUgPSAwJyxcbiAgICB9LFxuICAgIGZ1bmN0aW9uIHRvU3RyaW5nKCkgeyByZXR1cm4gJ0NPVU5UKCknOyB9XG4gIF1cbn0pO1xuXG5cbmZvYW0uQ0xBU1Moe1xuICBwYWNrYWdlOiAnZm9hbS5tbGFuZy5zaW5rJyxcbiAgbmFtZTogJ051bGxTaW5rJyxcbiAgZXh0ZW5kczogJ2ZvYW0uZGFvLkFic3RyYWN0U2luaycsXG4gIGltcGxlbWVudHM6IFsnZm9hbS5jb3JlLlNlcmlhbGl6YWJsZSddLFxuXG4gIGRvY3VtZW50YXRpb246ICdOdWxsIFBhdHRlcm4gKGRvLW5vdGhpbmcpIFNpbmsuJyxcblxuICBheGlvbXM6IFtcbiAgICBmb2FtLnBhdHRlcm4uU2luZ2xldG9uLmNyZWF0ZSgpXG4gIF1cbn0pO1xuXG5cbmZvYW0uSU5URVJGQUNFKHtcbiAgcGFja2FnZTogJ2ZvYW0ubWxhbmcnLFxuICBuYW1lOiAnRicsXG5cbiAgZG9jdW1lbnRhdGlvbjogJ0YgaW50ZXJmYWNlOiBmKG9iaikgLT4gdmFsLicsXG5cbiAgbWV0aG9kczogW1xuICAgIHtcbiAgICAgIG5hbWU6ICdmJyxcbiAgICAgIGFyZ3M6IFtcbiAgICAgICAgJ29iaidcbiAgICAgIF0sXG4gICAgICBzd2lmdFJldHVybnM6ICdBbnk/JyxcbiAgICB9XG4gIF1cbn0pO1xuXG4vLyBJbnZlc3RpZ2F0ZTogSWYgd2UgdXNlIFwiZXh0ZW5kczogJ2ZvYW0ubWxhbmcuRidcIiBpdCBnZW5lcmF0ZXMgdGhlIGNvbnRlbnQgcHJvcGVybHkgZm9yIGJvdGggRiBhbmQgRXhwci5cbi8vIEJ1dCB3ZSBoYXZlIHRoZSBDb25zdGFudCB0aGF0IGV4dGVuZHMgdGhlIEFic3RyYWN0RXhwciB0aGF0IGltcGxlbWVudHMgRXhwciBhbmQgaW4gdGhpcyBjYXNlLCB0aGUgZiBtZXRob2Rcbi8vICh0aGF0IGNvbWVzIGZyb20gdGhlIEYpIGludGVyZmFjZSBpcyBcImxvc2luZ1wiIGl0cyB0eXBlIGFuZCByZXR1cm5pbmcgdm9pZCBpbnN0ZWFkIG9mIHJldHVybmluZyB0aGUgc2FtZSBkZWZpbmVkXG4vLyBvbiB0aGUgaW50ZXJmYWNlIGFzIGl0IHNob3VsZC5cbmZvYW0uSU5URVJGQUNFKHtcbiAgcGFja2FnZTogJ2ZvYW0ubWxhbmcnLFxuICBuYW1lOiAnRXhwcicsXG4gIGltcGxlbWVudHM6IFsgJ2ZvYW0ubWxhbmcuRicgXSxcblxuICBkb2N1bWVudGF0aW9uOiAnRXhwciBpbnRlcmZhY2UgZXh0ZW5kcyBGIGludGVyZmFjZTogcGFydGlhbEV2YWwgLT4gRXhwci4nLFxuXG4gIG1ldGhvZHM6IFtcbiAgICB7XG4gICAgICBuYW1lOiAncGFydGlhbEV2YWwnXG4gICAgfVxuICBdXG59KTtcblxuXG5mb2FtLkNMQVNTKHtcbiAgcGFja2FnZTogJ2ZvYW0ubWxhbmcnLFxuICBuYW1lOiAnRXhwclByb3BlcnR5JyxcbiAgZXh0ZW5kczogJ0ZPYmplY3RQcm9wZXJ0eScsXG5cbiAgZG9jdW1lbnRhdGlvbjogJ1Byb3BlcnR5IGZvciBFeHByIHZhbHVlcy4nLFxuXG4gIHByb3BlcnRpZXM6IFtcbiAgICB7XG4gICAgICBuYW1lOiAnYWRhcHQnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uKF8sIG8sIHApIHsgcmV0dXJuIHAuYWRhcHRWYWx1ZShvKTsgfVxuICAgIH0sXG4gIF0sXG5cbiAgbWV0aG9kczogW1xuICAgIGZ1bmN0aW9uIGFkYXB0VmFsdWUobykge1xuICAgICAgaWYgKCBvID09PSBudWxsICkgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZm9hbS5tbGFuZy5Db25zdGFudC5jcmVhdGUoeyB2YWx1ZTogbnVsbCB9KTtcbiAgICAgIGlmICggISBvLmYgJiYgdHlwZW9mIG8gPT09ICdmdW5jdGlvbicgKSAgICAgcmV0dXJuIGZvYW0ubWxhbmcucHJlZGljYXRlLkZ1bmMuY3JlYXRlKHsgZm46IG8gfSk7XG4gICAgICBpZiAoIHR5cGVvZiBvICE9PSAnb2JqZWN0JyApICAgICAgICAgICAgICAgIHJldHVybiBmb2FtLm1sYW5nLkNvbnN0YW50LmNyZWF0ZSh7IHZhbHVlOiBvIH0pO1xuICAgICAgaWYgKCBvIGluc3RhbmNlb2YgRGF0ZSApICAgICAgICAgICAgICAgICAgICByZXR1cm4gZm9hbS5tbGFuZy5Db25zdGFudC5jcmVhdGUoeyB2YWx1ZTogbyB9KTtcbiAgICAgIGlmICggQXJyYXkuaXNBcnJheShvKSApICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZvYW0ubWxhbmcuQ29uc3RhbnQuY3JlYXRlKHsgdmFsdWU6IG8gfSk7XG4gICAgICBpZiAoIGZvYW0uY29yZS5BYnN0cmFjdEVudW0uaXNJbnN0YW5jZShvKSApIHJldHVybiBmb2FtLm1sYW5nLkNvbnN0YW50LmNyZWF0ZSh7IHZhbHVlOiBvIH0pO1xuICAgICAgaWYgKCBmb2FtLmNvcmUuRk9iamVjdC5pc0luc3RhbmNlKG8pICkge1xuICAgICAgICAgICAvLyBUT0RPOiBOb3QgYWxsIG1sYW5nIGV4cHJlc3Npb25zIGFjdHVhbGx5IGltcGxlbWVudCBFeHByXG4gICAgICAgICAgIC8vIHNvIHdlJ3JlIGp1c3QgZ29pbmcgdG8gY2hlY2sgZm9yIG8uZlxuICAgICAgICAgICAvLyAgISBmb2FtLm1sYW5nLkV4cHIuaXNJbnN0YW5jZShvKSApXG4gICAgICAgIGlmICggISBmb2FtLkZ1bmN0aW9uLmlzSW5zdGFuY2Uoby5mKSApICAgICAgcmV0dXJuIGZvYW0ubWxhbmcuQ29uc3RhbnQuY3JlYXRlKHsgdmFsdWU6IG8gfSk7XG4gICAgICAgIHJldHVybiBvO1xuICAgICAgfVxuXG4gICAgICBjb25zb2xlLmVycm9yKCdJbnZhbGlkIGV4cHJlc3Npb24gdmFsdWU6ICcsIG8pO1xuICAgIH1cbiAgXVxufSk7XG5cblxuZm9hbS5DTEFTUyh7XG4gIHBhY2thZ2U6ICdmb2FtLm1sYW5nJyxcbiAgbmFtZTogJ1NpbmtQcm9wZXJ0eScsXG4gIGV4dGVuZHM6ICdGT2JqZWN0UHJvcGVydHknLFxuXG4gIGRvY3VtZW50YXRpb246ICdQcm9wZXJ0eSBmb3IgU2luayB2YWx1ZXMuJ1xufSk7XG5cblxuZm9hbS5JTlRFUkZBQ0Uoe1xuICBwYWNrYWdlOiAnZm9hbS5tbGFuZy5wcmVkaWNhdGUnLFxuICBuYW1lOiAnUHJlZGljYXRlJyxcblxuICAvLyBQcmVkaWNhdGUgaXMgYWxyZWFkeSBhIHRoaW5nIGluIFN3aWZ0IHNvIGF2b2lkIHVzaW5nIHRoYXQgbmFtZS5cbiAgc3dpZnROYW1lOiAnRm9hbVByZWRpY2F0ZScsXG5cbiAgZG9jdW1lbnRhdGlvbjogJ1ByZWRpY2F0ZSBpbnRlcmZhY2U6IGYob2JqKSAtPiBib29sZWFuLicsXG5cbiAgbWV0aG9kczogW1xuICAgIHtcbiAgICAgIG5hbWU6ICdmJyxcbiAgICAgIHN3aWZ0UmV0dXJuczogJ0Jvb2wnLFxuICAgICAgYXJnczogW1xuICAgICAgICAnb2JqJ1xuICAgICAgXVxuICAgIH0sXG4gICAge1xuICAgICAgbmFtZTogJ3BhcnRpYWxFdmFsJyxcbiAgICAgIHJldHVybnM6ICdmb2FtLm1sYW5nLnByZWRpY2F0ZS5QcmVkaWNhdGUnLFxuICAgIH0sXG4gICAge1xuICAgICAgbmFtZTogJ3RvSW5kZXgnLFxuICAgICAgYXJnczogW1xuICAgICAgICAndGFpbCdcbiAgICAgIF1cbiAgICB9LFxuICAgIHtcbiAgICAgIG5hbWU6ICd0b0Rpc2p1bmN0aXZlTm9ybWFsRm9ybScsXG4gICAgICByZXR1cm5zOiAnZm9hbS5tbGFuZy5wcmVkaWNhdGUuUHJlZGljYXRlJyxcbiAgICB9XG4gIF1cbn0pO1xuXG5cbmZvYW0uQ0xBU1Moe1xuICBwYWNrYWdlOiAnZm9hbS5tbGFuZy5wcmVkaWNhdGUnLFxuICBuYW1lOiAnUHJlZGljYXRlUHJvcGVydHknLFxuICBleHRlbmRzOiAnRk9iamVjdFByb3BlcnR5JyxcblxuICBkb2N1bWVudGF0aW9uOiAnUHJvcGVydHkgZm9yIFByZWRpY2F0ZSB2YWx1ZXMuJyxcblxuICBwcm9wZXJ0aWVzOiBbXG4gICAgWydvZicsICdmb2FtLm1sYW5nLnByZWRpY2F0ZS5QcmVkaWNhdGUnXSxcbiAgICB7XG4gICAgICBuYW1lOiAnYWRhcHQnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uKF8sIG8pIHtcbiAgICAgICAgaWYgKCAhIG8uZiAmJiB0eXBlb2YgbyA9PT0gXCJmdW5jdGlvblwiICkgcmV0dXJuIGZvYW0ubWxhbmcucHJlZGljYXRlLkZ1bmMuY3JlYXRlKHsgZm46IG8gfSk7XG4gICAgICAgIHJldHVybiBvO1xuICAgICAgfVxuICAgIH1cbiAgXVxufSk7XG5cblxuZm9hbS5DTEFTUyh7XG4gIHBhY2thZ2U6ICdmb2FtLm1sYW5nLnByZWRpY2F0ZScsXG4gIG5hbWU6ICdQcmVkaWNhdGVBcnJheScsXG4gIGV4dGVuZHM6ICdGT2JqZWN0QXJyYXknLFxuXG4gIGRvY3VtZW50YXRpb246ICdQcm9wZXJ0eSBmb3Igc3RvcmluZyBhcnJheXMgb2YgUHJlZGljYXRlcy4nLFxuXG4gIHByb3BlcnRpZXM6IFtcbiAgICB7XG4gICAgICBuYW1lOiAnb2YnLFxuICAgICAgdmFsdWU6ICdmb2FtLm1sYW5nLnByZWRpY2F0ZS5QcmVkaWNhdGUnXG4gICAgfSxcbiAgICB7XG4gICAgICBuYW1lOiAnYWRhcHRBcnJheUVsZW1lbnQnLFxuICAgICAgLy8gVE9ETz86IE1ha2UgaW50byBhIG11bHRpLW1ldGhvZD9cbiAgICAgIHZhbHVlOiBmdW5jdGlvbihvKSB7XG4gICAgICAgIGlmICggbyA9PT0gbnVsbCApIHJldHVybiBmb2FtLm1sYW5nLkNvbnN0YW50LmNyZWF0ZSh7IHZhbHVlOiBvIH0pO1xuICAgICAgICBpZiAoICEgby5mICYmIHR5cGVvZiBvID09PSBcImZ1bmN0aW9uXCIgKSByZXR1cm4gZm9hbS5tbGFuZy5wcmVkaWNhdGUuRnVuYy5jcmVhdGUoeyBmbjogbyB9KTtcbiAgICAgICAgaWYgKCB0eXBlb2YgbyAhPT0gXCJvYmplY3RcIiApIHJldHVybiBmb2FtLm1sYW5nLkNvbnN0YW50LmNyZWF0ZSh7IHZhbHVlOiBvIH0pO1xuICAgICAgICBpZiAoIEFycmF5LmlzQXJyYXkobykgKSByZXR1cm4gZm9hbS5tbGFuZy5Db25zdGFudC5jcmVhdGUoeyB2YWx1ZTogbyB9KTtcbiAgICAgICAgaWYgKCBvID09PSB0cnVlICkgcmV0dXJuIGZvYW0ubWxhbmcucHJlZGljYXRlLlRydWUuY3JlYXRlKCk7XG4gICAgICAgIGlmICggbyA9PT0gZmFsc2UgKSByZXR1cm4gZm9hbS5tbGFuZy5wcmVkaWNhdGUuRmFsc2UuY3JlYXRlKCk7XG4gICAgICAgIGlmICggZm9hbS5jb3JlLkZPYmplY3QuaXNJbnN0YW5jZShvKSApIHJldHVybiBvO1xuICAgICAgICBjb25zb2xlLmVycm9yKCdJbnZhbGlkIGV4cHJlc3Npb24gdmFsdWU6ICcsIG8pO1xuICAgICAgfVxuICAgIH1cbiAgXVxufSk7XG5cblxuZm9hbS5DTEFTUyh7XG4gIHBhY2thZ2U6ICdmb2FtLm1sYW5nLnByZWRpY2F0ZScsXG4gIG5hbWU6ICdBYnN0cmFjdFByZWRpY2F0ZScsXG4gIGFic3RyYWN0OiB0cnVlLFxuICBpbXBsZW1lbnRzOiBbICdmb2FtLm1sYW5nLnByZWRpY2F0ZS5QcmVkaWNhdGUnIF0sXG5cbiAgZG9jdW1lbnRhdGlvbjogJ0Fic3RyYWN0IFByZWRpY2F0ZSBiYXNlLWNsYXNzLicsXG5cbiAgbWV0aG9kczogW1xuICAgIHtcbiAgICAgIG5hbWU6ICd0b0luZGV4JyxcbiAgICAgIGNvZGU6IGZ1bmN0aW9uKCkgeyB9LFxuICAgICAgc3dpZnRDb2RlOiAncmV0dXJuJyxcbiAgICB9LFxuXG4gICAge1xuICAgICAgbmFtZTogJ3RvRGlzanVuY3RpdmVOb3JtYWxGb3JtJyxcbiAgICAgIGNvZGU6IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcyB9LFxuICAgICAgc3dpZnRDb2RlOiAncmV0dXJuIHNlbGYnLFxuICAgIH0sXG5cbiAgICB7XG4gICAgICBuYW1lOiAncGFydGlhbEV2YWwnLFxuICAgICAgY29kZTogZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzIH0sXG4gICAgICBzd2lmdENvZGU6ICdyZXR1cm4gc2VsZicsXG4gICAgfSxcblxuICAgIGZ1bmN0aW9uIHJlZHVjZUFuZChvdGhlcikge1xuICAgICAgcmV0dXJuIGZvYW0udXRpbC5lcXVhbHModGhpcywgb3RoZXIpID8gdGhpcyA6IG51bGw7XG4gICAgfSxcblxuICAgIGZ1bmN0aW9uIHJlZHVjZU9yKG90aGVyKSB7XG4gICAgICByZXR1cm4gZm9hbS51dGlsLmVxdWFscyh0aGlzLCBvdGhlcikgPyB0aGlzIDogbnVsbDtcbiAgICB9LFxuXG4gICAgZnVuY3Rpb24gdG9TdHJpbmcoKSB7IHJldHVybiB0aGlzLmNsc18ubmFtZTsgfVxuICBdXG59KTtcblxuXG5mb2FtLkNMQVNTKHtcbiAgcGFja2FnZTogJ2ZvYW0ubWxhbmcnLFxuICBuYW1lOiAnQWJzdHJhY3RFeHByJyxcbiAgYWJzdHJhY3Q6IHRydWUsXG4gIGltcGxlbWVudHM6IFsgJ2ZvYW0ubWxhbmcuRXhwcicgXSxcblxuICBkb2N1bWVudGF0aW9uOiAnQWJzdHJhY3QgRXhwciBiYXNlLWNsYXNzLicsXG5cbiAgbWV0aG9kczogW1xuICAgIGZ1bmN0aW9uIHBhcnRpYWxFdmFsKCkgeyByZXR1cm4gdGhpczsgfVxuICBdXG59KTtcblxuXG5mb2FtLkNMQVNTKHtcbiAgcGFja2FnZTogJ2ZvYW0ubWxhbmcucHJlZGljYXRlJyxcbiAgbmFtZTogJ1RydWUnLFxuICBleHRlbmRzOiAnZm9hbS5tbGFuZy5wcmVkaWNhdGUuQWJzdHJhY3RQcmVkaWNhdGUnLFxuICBpbXBsZW1lbnRzOiBbICdmb2FtLmNvcmUuU2VyaWFsaXphYmxlJyBdLFxuXG4gIGRvY3VtZW50YXRpb246ICdFeHByZXNzaW9uIHdoaWNoIGFsd2F5cyByZXR1cm5zIHRydWUuJyxcblxuICBheGlvbXM6IFsgZm9hbS5wYXR0ZXJuLlNpbmdsZXRvbi5jcmVhdGUoKSBdLFxuXG4gIG1ldGhvZHM6IFtcbiAgICB7XG4gICAgICBuYW1lOiAnZicsXG4gICAgICBjb2RlOiBmdW5jdGlvbigpIHsgcmV0dXJuIHRydWU7IH0sXG4gICAgICBzd2lmdENvZGU6ICdyZXR1cm4gdHJ1ZScsXG4gICAgfSxcbiAgXVxufSk7XG5cblxuZm9hbS5DTEFTUyh7XG4gIHBhY2thZ2U6ICdmb2FtLm1sYW5nLnByZWRpY2F0ZScsXG4gIG5hbWU6ICdGYWxzZScsXG4gIGV4dGVuZHM6ICdmb2FtLm1sYW5nLnByZWRpY2F0ZS5BYnN0cmFjdFByZWRpY2F0ZScsXG4gIGltcGxlbWVudHM6IFsnZm9hbS5jb3JlLlNlcmlhbGl6YWJsZSddLFxuXG4gIGRvY3VtZW50YXRpb246ICdFeHByZXNzaW9uIHdoaWNoIGFsd2F5cyByZXR1cm5zIGZhbHNlLicsXG5cbiAgYXhpb21zOiBbIGZvYW0ucGF0dGVybi5TaW5nbGV0b24uY3JlYXRlKCkgXSxcblxuICBtZXRob2RzOiBbXG4gICAgZnVuY3Rpb24gZigpIHsgcmV0dXJuIGZhbHNlOyB9XG4gIF1cbn0pO1xuXG5cbmZvYW0uQ0xBU1Moe1xuICBwYWNrYWdlOiAnZm9hbS5tbGFuZy5wcmVkaWNhdGUnLFxuICBuYW1lOiAnVW5hcnknLFxuICBleHRlbmRzOiAnZm9hbS5tbGFuZy5wcmVkaWNhdGUuQWJzdHJhY3RQcmVkaWNhdGUnLFxuICBhYnN0cmFjdDogdHJ1ZSxcblxuICBkb2N1bWVudGF0aW9uOiAnQWJzdHJhY3QgVW5hcnkgKHNpbmdsZS1hcmd1bWVudCkgUHJlZGljYXRlIGJhc2UtY2xhc3MuJyxcblxuICBwcm9wZXJ0aWVzOiBbXG4gICAge1xuICAgICAgY2xhc3M6ICdmb2FtLm1sYW5nLkV4cHJQcm9wZXJ0eScsXG4gICAgICBuYW1lOiAnYXJnMSdcbiAgICB9XG4gIF0sXG5cbiAgbWV0aG9kczogW1xuICAgIGZ1bmN0aW9uIHRvSW5kZXgodGFpbCkge1xuICAgICAgcmV0dXJuIHRoaXMuYXJnMSAmJiB0aGlzLmFyZzEudG9JbmRleCh0YWlsKTtcbiAgICB9LFxuXG4gICAgZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgICByZXR1cm4gZm9hbS5TdHJpbmcuY29uc3RhbnRpemUodGhpcy5jbHNfLm5hbWUpICtcbiAgICAgICAgICAnKCcgKyB0aGlzLmFyZzEudG9TdHJpbmcoKSArICcpJztcbiAgICB9XG4gIF1cbn0pO1xuXG5cbmZvYW0uQ0xBU1Moe1xuICBwYWNrYWdlOiAnZm9hbS5tbGFuZy5wcmVkaWNhdGUnLFxuICBuYW1lOiAnQmluYXJ5JyxcbiAgZXh0ZW5kczogJ2ZvYW0ubWxhbmcucHJlZGljYXRlLkFic3RyYWN0UHJlZGljYXRlJyxcbiAgYWJzdHJhY3Q6IHRydWUsXG5cbiAgZG9jdW1lbnRhdGlvbjogJ0Fic3RyYWN0IEJpbmFyeSAodHdvLWFyZ3VtZW50KSBQcmVkaWNhdGUgYmFzZS1jbGFzcy4nLFxuXG4gIHByb3BlcnRpZXM6IFtcbiAgICB7XG4gICAgICBjbGFzczogJ2ZvYW0ubWxhbmcuRXhwclByb3BlcnR5JyxcbiAgICAgIG5hbWU6ICdhcmcxJ1xuICAgIH0sXG4gICAge1xuICAgICAgY2xhc3M6ICdmb2FtLm1sYW5nLkV4cHJQcm9wZXJ0eScsXG4gICAgICBuYW1lOiAnYXJnMicsXG4gICAgICBhZGFwdDogZnVuY3Rpb24ob2xkLCBudSwgcHJvcCkge1xuICAgICAgICB2YXIgdmFsdWUgPSBwcm9wLmFkYXB0VmFsdWUobnUpO1xuICAgICAgICB2YXIgYXJnMSA9IHRoaXMuYXJnMTtcbiAgICAgICAgaWYgKCBmb2FtLm1sYW5nLkNvbnN0YW50LmlzSW5zdGFuY2UodmFsdWUpICYmIGFyZzEgJiYgYXJnMS5hZGFwdCApXG4gICAgICAgICAgdmFsdWUudmFsdWUgPSB0aGlzLmFyZzEuYWRhcHQuY2FsbChudWxsLCBvbGQsIHZhbHVlLnZhbHVlLCBhcmcxKTtcblxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9XG4gICAgfVxuICBdLFxuXG4gIG1ldGhvZHM6IFtcbiAgICBmdW5jdGlvbiB0b0luZGV4KHRhaWwpIHtcbiAgICAgIHJldHVybiB0aGlzLmFyZzEgJiYgdGhpcy5hcmcxLnRvSW5kZXgodGFpbCk7XG4gICAgfSxcblxuICAgIGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgICAgcmV0dXJuIGZvYW0uU3RyaW5nLmNvbnN0YW50aXplKHRoaXMuY2xzXy5uYW1lKSArICcoJyArXG4gICAgICAgICAgdGhpcy5hcmcxLnRvU3RyaW5nKCkgKyAnLCAnICtcbiAgICAgICAgICB0aGlzLmFyZzIudG9TdHJpbmcoKSArICcpJztcbiAgICB9XG4gIF1cbn0pO1xuXG5cbmZvYW0uQ0xBU1Moe1xuICBwYWNrYWdlOiAnZm9hbS5tbGFuZy5wcmVkaWNhdGUnLFxuICBuYW1lOiAnTmFyeScsXG4gIGV4dGVuZHM6ICdmb2FtLm1sYW5nLnByZWRpY2F0ZS5BYnN0cmFjdFByZWRpY2F0ZScsXG4gIGFic3RyYWN0OiB0cnVlLFxuXG4gIGRvY3VtZW50YXRpb246ICdBYnN0cmFjdCBuLWFyeSAobWFueS1hcmd1bWVudCkgUHJlZGljYXRlIGJhc2UtY2xhc3MuJyxcblxuICBwcm9wZXJ0aWVzOiBbXG4gICAge1xuICAgICAgY2xhc3M6ICdmb2FtLm1sYW5nLnByZWRpY2F0ZS5QcmVkaWNhdGVBcnJheScsXG4gICAgICBuYW1lOiAnYXJncydcbiAgICB9XG4gIF0sXG5cbiAgbWV0aG9kczogW1xuICAgIGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgICAgdmFyIHMgPSBmb2FtLlN0cmluZy5jb25zdGFudGl6ZSh0aGlzLmNsc18ubmFtZSkgKyAnKCc7XG4gICAgICBmb3IgKCB2YXIgaSA9IDAgOyBpIDwgdGhpcy5hcmdzLmxlbmd0aCA7IGkrKyApIHtcbiAgICAgICAgdmFyIGEgPSB0aGlzLmFyZ3NbaV07XG4gICAgICAgIHMgKz0gYS50b1N0cmluZygpO1xuICAgICAgICBpZiAoIGkgPCB0aGlzLmFyZ3MubGVuZ3RoIC0gMSApIHMgKz0gJywgJztcbiAgICAgIH1cbiAgICAgIHJldHVybiBzICsgJyknO1xuICAgIH0sXG4gICAgZnVuY3Rpb24gcmVkdWNlXyhhcmdzLCBzaG9ydENpcmN1aXQsIG1ldGhvZE5hbWUpIHtcbiAgICAgIGZvciAoIHZhciBpID0gMDsgaSA8IGFyZ3MubGVuZ3RoIC0gMTsgaSsrICkge1xuICAgICAgICBmb3IgKCB2YXIgaiA9IGkgKyAxOyBqIDwgYXJncy5sZW5ndGg7IGorKyApIHtcbiAgICAgICAgICBpZiAoIGFyZ3NbaV1bbWV0aG9kTmFtZV0gKSB7XG4gICAgICAgICAgICB2YXIgbmV3QXJnID0gYXJnc1tpXVttZXRob2ROYW1lXShhcmdzW2pdKTtcbiAgICAgICAgICAgIGlmICggbmV3QXJnICkge1xuICAgICAgICAgICAgICBpZiAoIG5ld0FyZyA9PT0gc2hvcnRDaXJjdWl0ICkgcmV0dXJuIHNob3J0Q2lyY3VpdDtcbiAgICAgICAgICAgICAgYXJnc1tpXSA9IG5ld0FyZztcbiAgICAgICAgICAgICAgYXJncy5zcGxpY2UoaiwgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gYXJncztcbiAgICB9XG4gIF1cbn0pO1xuXG5cbmZvYW0uQ0xBU1Moe1xuICBwYWNrYWdlOiAnZm9hbS5tbGFuZy5wcmVkaWNhdGUnLFxuICBuYW1lOiAnT3InLFxuICBleHRlbmRzOiAnZm9hbS5tbGFuZy5wcmVkaWNhdGUuTmFyeScsXG4gIGltcGxlbWVudHM6IFsgJ2ZvYW0uY29yZS5TZXJpYWxpemFibGUnIF0sXG5cbiAgZG9jdW1lbnRhdGlvbjogJ0xvZ2ljYWwgT3Igbi1hcnkgUHJlZGljYXRlLicsXG5cbiAgcmVxdWlyZXM6IFtcbiAgICAnZm9hbS5tbGFuZy5wcmVkaWNhdGUuRmFsc2UnLFxuICAgICdmb2FtLm1sYW5nLnByZWRpY2F0ZS5UcnVlJ1xuICBdLFxuXG4gIG1ldGhvZHM6IFtcbiAgICB7XG4gICAgICBuYW1lOiAnZicsXG4gICAgICBjb2RlOiBmdW5jdGlvbiBmKG8pIHtcbiAgICAgICAgZm9yICggdmFyIGkgPSAwIDsgaSA8IHRoaXMuYXJncy5sZW5ndGggOyBpKysgKSB7XG4gICAgICAgICAgaWYgKCB0aGlzLmFyZ3NbaV0uZihvKSApIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH0sXG4gICAgICBzd2lmdENvZGU6IGBcbmZvciBhcmcgaW4gYXJncyB7XG4gIGlmIGFyZy5mKG9iaikgeyByZXR1cm4gdHJ1ZSB9XG59XG5yZXR1cm4gZmFsc2VcbiAgICAgIGAsXG4gICAgfSxcblxuICAgIGZ1bmN0aW9uIHBhcnRpYWxFdmFsKCkge1xuICAgICAgdmFyIG5ld0FyZ3MgPSBbXTtcbiAgICAgIHZhciB1cGRhdGVkID0gZmFsc2U7XG5cbiAgICAgIHZhciBUUlVFICA9IHRoaXMuVHJ1ZS5jcmVhdGUoKTtcbiAgICAgIHZhciBGQUxTRSA9IHRoaXMuRmFsc2UuY3JlYXRlKCk7XG5cbiAgICAgIGZvciAoIHZhciBpID0gMCA7IGkgPCB0aGlzLmFyZ3MubGVuZ3RoIDsgaSsrICkge1xuICAgICAgICB2YXIgYSAgICA9IHRoaXMuYXJnc1tpXTtcbiAgICAgICAgdmFyIG5ld0EgPSB0aGlzLmFyZ3NbaV0ucGFydGlhbEV2YWwoKTtcblxuICAgICAgICBpZiAoIG5ld0EgPT09IFRSVUUgKSByZXR1cm4gVFJVRTtcblxuICAgICAgICBpZiAoIHRoaXMuY2xzXy5pc0luc3RhbmNlKG5ld0EpICkge1xuICAgICAgICAgIC8vIEluLWxpbmUgbmVzdGVkIE9SIGNsYXVzZXNcbiAgICAgICAgICBmb3IgKCB2YXIgaiA9IDAgOyBqIDwgbmV3QS5hcmdzLmxlbmd0aCA7IGorKyApIHtcbiAgICAgICAgICAgIG5ld0FyZ3MucHVzaChuZXdBLmFyZ3Nbal0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICB1cGRhdGVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBpZiAoIG5ld0EgIT09IEZBTFNFICkge1xuICAgICAgICAgICAgbmV3QXJncy5wdXNoKG5ld0EpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIGEgIT09IG5ld0EgKSB1cGRhdGVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB0aGlzLnJlZHVjZV8obmV3QXJncywgRkFMU0UsICdyZWR1Y2VBbmQnKTtcblxuICAgICAgaWYgKCBuZXdBcmdzLmxlbmd0aCA9PT0gMCApIHJldHVybiBGQUxTRTtcbiAgICAgIGlmICggbmV3QXJncy5sZW5ndGggPT09IDEgKSByZXR1cm4gbmV3QXJnc1swXTtcblxuICAgICAgcmV0dXJuIHVwZGF0ZWQgPyB0aGlzLmNsc18uY3JlYXRlKHsgYXJnczogbmV3QXJncyB9KSA6IHRoaXM7XG4gICAgfSxcblxuICAgIGZ1bmN0aW9uIHRvSW5kZXgodGFpbCkgeyB9LFxuXG4gICAgZnVuY3Rpb24gdG9EaXNqdW5jdGl2ZU5vcm1hbEZvcm0oKSB7XG4gICAgICAvLyBUT0RPOiBtZW1vaXphdGlvbiBhcm91bmQgdGhpcyBwcm9jZXNzP1xuICAgICAgLy8gRE5GIG91ciBhcmdzLCBub3RlIGlmIGFueXRoaW5nIGNoYW5nZXNcbiAgICAgIHZhciBvbGRBcmdzID0gdGhpcy5hcmdzO1xuICAgICAgdmFyIG5ld0FyZ3MgPSBbXTtcbiAgICAgIHZhciBjaGFuZ2VkID0gZmFsc2U7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9sZEFyZ3MubGVuZ3RoOyBpKysgKSB7XG4gICAgICAgIHZhciBhID0gb2xkQXJnc1tpXS50b0Rpc2p1bmN0aXZlTm9ybWFsRm9ybSgpO1xuICAgICAgICBpZiAoIGEgIT09IG9sZEFyZ3NbaV0gKSBjaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgbmV3QXJnc1tpXSA9IGE7XG4gICAgICB9XG5cbiAgICAgIC8vIHBhcnRpYWxFdmFsIHdpbGwgdGFrZSBjYXJlIG9mIG5lc3RlZCBPUnNcbiAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgIGlmICggY2hhbmdlZCApIHtcbiAgICAgICAgc2VsZiA9IHRoaXMuY2xvbmUoKTtcbiAgICAgICAgc2VsZi5hcmdzID0gbmV3QXJncztcbiAgICAgICAgc2VsZiA9IHNlbGYucGFydGlhbEV2YWwoKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfVxuICBdXG59KTtcblxuXG5mb2FtLkNMQVNTKHtcbiAgcGFja2FnZTogJ2ZvYW0ubWxhbmcucHJlZGljYXRlJyxcbiAgbmFtZTogJ0FuZCcsXG4gIGV4dGVuZHM6ICdmb2FtLm1sYW5nLnByZWRpY2F0ZS5OYXJ5JyxcbiAgaW1wbGVtZW50czogWydmb2FtLmNvcmUuU2VyaWFsaXphYmxlJ10sXG5cbiAgZG9jdW1lbnRhdGlvbjogJ0xvZ2ljYWwgQW5kIG4tYXJ5IFByZWRpY2F0ZS4nLFxuXG4gIHJlcXVpcmVzOiBbXG4gICAgJ2ZvYW0ubWxhbmcucHJlZGljYXRlLk9yJ1xuICBdLFxuXG4gIG1ldGhvZHM6IFtcbiAgICB7XG4gICAgICBuYW1lOiAnZicsXG4gICAgICBjb2RlOiBmdW5jdGlvbihvKSB7XG4gICAgICAgIGZvciAoIHZhciBpID0gMCA7IGkgPCB0aGlzLmFyZ3MubGVuZ3RoIDsgaSsrICkge1xuICAgICAgICAgIGlmICggISB0aGlzLmFyZ3NbaV0uZihvKSApIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH0sXG4gICAgICBzd2lmdENvZGU6IGZ1bmN0aW9uKCkgey8qXG5mb3IgYXJnIGluIGFyZ3Mge1xuICBpZiAhYXJnLmYob2JqKSB7IHJldHVybiBmYWxzZSB9XG59XG5yZXR1cm4gdHJ1ZVxuICAgICAgKi99LFxuICAgIH0sXG5cbiAgICBmdW5jdGlvbiBwYXJ0aWFsRXZhbCgpIHtcbiAgICAgIHZhciBuZXdBcmdzID0gW107XG4gICAgICB2YXIgdXBkYXRlZCA9IGZhbHNlO1xuXG4gICAgICB2YXIgRkFMU0UgPSBmb2FtLm1sYW5nLnByZWRpY2F0ZS5GYWxzZS5jcmVhdGUoKTtcbiAgICAgIHZhciBUUlVFID0gZm9hbS5tbGFuZy5wcmVkaWNhdGUuVHJ1ZS5jcmVhdGUoKTtcblxuICAgICAgZm9yICggdmFyIGkgPSAwOyBpIDwgdGhpcy5hcmdzLmxlbmd0aDsgaSsrICkge1xuICAgICAgICB2YXIgYSAgICA9IHRoaXMuYXJnc1tpXTtcbiAgICAgICAgdmFyIG5ld0EgPSB0aGlzLmFyZ3NbaV0ucGFydGlhbEV2YWwoKTtcblxuICAgICAgICBpZiAoIG5ld0EgPT09IEZBTFNFICkgcmV0dXJuIEZBTFNFO1xuXG4gICAgICAgIGlmICggdGhpcy5jbHNfLmlzSW5zdGFuY2UobmV3QSkgKSB7XG4gICAgICAgICAgLy8gSW4tbGluZSBuZXN0ZWQgQU5EIGNsYXVzZXNcbiAgICAgICAgICBmb3IgKCB2YXIgaiA9IDAgOyBqIDwgbmV3QS5hcmdzLmxlbmd0aCA7IGorKyApIHtcbiAgICAgICAgICAgIG5ld0FyZ3MucHVzaChuZXdBLmFyZ3Nbal0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICB1cGRhdGVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBpZiAoIG5ld0EgPT09IFRSVUUgKSB7XG4gICAgICAgICAgICB1cGRhdGVkID0gdHJ1ZTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbmV3QXJncy5wdXNoKG5ld0EpO1xuICAgICAgICAgICAgaWYgKCBhICE9PSBuZXdBICkgdXBkYXRlZCA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHRoaXMucmVkdWNlXyhuZXdBcmdzLCBUUlVFLCAncmVkdWNlT3InKTtcblxuICAgICAgaWYgKCBuZXdBcmdzLmxlbmd0aCA9PT0gMCApIHJldHVybiBUUlVFO1xuICAgICAgaWYgKCBuZXdBcmdzLmxlbmd0aCA9PT0gMSApIHJldHVybiBuZXdBcmdzWzBdO1xuXG4gICAgICByZXR1cm4gdXBkYXRlZCA/IHRoaXMuY2xzXy5jcmVhdGUoeyBhcmdzOiBuZXdBcmdzIH0pIDogdGhpcztcbiAgICB9LFxuXG4gICAgZnVuY3Rpb24gdG9JbmRleCh0YWlsLCBkZXB0aCkge1xuICAgICAgLyoqIEJ1aWxkcyB0aGUgaWRlYWwgaW5kZXggZm9yIHRoaXMgcHJlZGljYXRlLiBUaGUgaW5kZXhlcyB3aWxsIGJlIGNoYWluZWRcbiAgICAgICAgICBpbiBvcmRlciBvZiBpbmRleCB1bmlxdWVuZXNzIChwdXQgdGhlIG1vc3QgaW5kZXhhYmxlIGZpcnN0KTpcbiAgICAgICAgICBUaGlzIHByZXZlbnRzIGRyb3BwaW5nIHRvIHNjYW4gbW9kZSB0b28gZWFybHksIGFuZCByZXN0cmljdHNcbiAgICAgICAgICB0aGUgcmVtYW5pbmcgc2V0IG1vcmUgcXVpY2tseS5cbiAgICAgICAgICAgaS5lLiBFUSwgSU4sLi4uIENPTlRBSU5TLCAuLi4gTFQsIEdULi4uXG4gICAgICAgIEBwYXJhbSBkZXB0aCB7bnVtYmVyfSBUaGUgbWF4aW11bSBudW1iZXIgb2Ygc3ViLWluZGV4ZXMgdG8gY2hhaW4uXG4gICAgICAqL1xuICAgICAgZGVwdGggPSBkZXB0aCB8fCA5OTtcblxuICAgICAgaWYgKCBkZXB0aCA9PT0gMSApIHtcbiAgICAgICAgLy8gZ2VuZXJhdGUgaW5kZXhlcywgZmluZCBjb3N0cywgdXNlIHRoZSBmYXN0ZXN0XG4gICAgICAgIHZhciBiZXN0Q29zdCA9IE51bWJlci5NQVhfVkFMVUU7XG4gICAgICAgIHZhciBiZXN0SW5kZXg7XG4gICAgICAgIHZhciBhcmdzID0gdGhpcy5hcmdzO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3MubGVuZ3RoOyBpKysgKSB7XG4gICAgICAgICAgdmFyIGFyZyA9IGFyZ3NbaV07XG4gICAgICAgICAgdmFyIGlkeCA9IGFyZy50b0luZGV4KHRhaWwpO1xuICAgICAgICAgIGlmICggISBpZHggKSBjb250aW51ZTtcblxuICAgICAgICAgIHZhciBpZHhDb3N0ID0gTWF0aC5mbG9vcihpZHguZXN0aW1hdGUoXG4gICAgICAgICAgICAgMTAwMCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBhcmcpKTtcblxuICAgICAgICAgIGlmICggYmVzdENvc3QgPiBpZHhDb3N0ICkge1xuICAgICAgICAgICAgYmVzdEluZGV4ID0gaWR4O1xuICAgICAgICAgICAgYmVzdENvc3QgPSBpZHhDb3N0O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYmVzdEluZGV4O1xuXG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBnZW5lcmF0ZSBpbmRleGVzLCBzb3J0IGJ5IGVzdGltYXRlLCBjaGFpbiBhcyByZXF1ZXN0ZWRcbiAgICAgICAgdmFyIHNvcnRlZEFyZ3MgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICB2YXIgY29zdHMgPSBbXTtcbiAgICAgICAgdmFyIGFyZ3MgPSB0aGlzLmFyZ3M7XG4gICAgICAgIHZhciBkdXBlcyA9IHt9OyAvLyBhdm9pZCBkdXBsaWNhdGUgaW5kZXhlc1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3MubGVuZ3RoOyBpKysgKSB7XG4gICAgICAgICAgdmFyIGFyZyA9IGFyZ3NbaV07XG4gICAgICAgICAgdmFyIGlkeCA9IGFyZy50b0luZGV4KHRhaWwpO1xuICAgICAgICAgIGlmICggISBpZHggKSBjb250aW51ZTtcblxuICAgICAgICAgIC8vIGR1cGxpY2F0ZSBjaGVja1xuICAgICAgICAgIHZhciBpZHhTdHJpbmcgPSBpZHgudG9TdHJpbmcoKTtcbiAgICAgICAgICBpZiAoIGR1cGVzW2lkeFN0cmluZ10gKSBjb250aW51ZTtcbiAgICAgICAgICBkdXBlc1tpZHhTdHJpbmddID0gdHJ1ZTtcblxuICAgICAgICAgIHZhciBpZHhDb3N0ID0gTWF0aC5mbG9vcihpZHguZXN0aW1hdGUoXG4gICAgICAgICAgICAgMTAwMCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBhcmcpKTtcbiAgICAgICAgICAvLyBtYWtlIHVuaXF1ZSB3aXRoIGEgc29tZSBleHRyYSBkaWdpdHNcbiAgICAgICAgICB2YXIgY29zdEtleSA9IGlkeENvc3QgKyBpIC8gMTAwMC4wO1xuICAgICAgICAgIHNvcnRlZEFyZ3NbY29zdEtleV0gPSBhcmc7XG4gICAgICAgICAgY29zdHMucHVzaChjb3N0S2V5KTtcbiAgICAgICAgfVxuICAgICAgICBjb3N0cyA9IGNvc3RzLnNvcnQoZm9hbS5OdW1iZXIuY29tcGFyZSk7XG5cbiAgICAgICAgLy8gU29ydCwgYnVpbGQgbGlzdCB1cCBzdGFydGluZyBhdCB0aGUgZW5kIChtb3N0IGV4cGVuc2l2ZVxuICAgICAgICAvLyAgIHdpbGwgZW5kIHVwIGRlZXBlc3QgaW4gdGhlIGluZGV4KVxuICAgICAgICB2YXIgdGFpbFJldCA9IHRhaWw7XG4gICAgICAgIHZhciBjaGFpbkRlcHRoID0gTWF0aC5taW4oY29zdHMubGVuZ3RoIC0gMSwgZGVwdGggLSAxKTtcbiAgICAgICAgZm9yICggdmFyIGkgPSBjaGFpbkRlcHRoOyBpID49IDA7IGktLSApIHtcbiAgICAgICAgICB2YXIgYXJnID0gc29ydGVkQXJnc1tjb3N0c1tpXV07XG4gICAgICAgICAgLy9hc3NlcnQoYXJnIGlzIGEgcHJlZGljYXRlKVxuICAgICAgICAgIHRhaWxSZXQgPSBhcmcudG9JbmRleCh0YWlsUmV0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0YWlsUmV0O1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBmdW5jdGlvbiB0b0Rpc2p1bmN0aXZlTm9ybWFsRm9ybSgpIHtcbiAgICAgIC8vIGZvciBlYWNoIG5lc3RlZCBPUiwgbXVsdGlwbHk6XG4gICAgICAvLyBBTkQoYSxiLE9SKGMsZCksT1IoZSxmKSkgLT4gT1IoYWJjZSxhYmNmLGFiZGUsYWJkZilcblxuICAgICAgdmFyIGFuZEFyZ3MgPSBbXTtcbiAgICAgIHZhciBvckFyZ3MgID0gW107XG4gICAgICB2YXIgb2xkQXJncyA9IHRoaXMuYXJncztcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb2xkQXJncy5sZW5ndGg7IGkrKyApIHtcbiAgICAgICAgdmFyIGEgPSBvbGRBcmdzW2ldLnRvRGlzanVuY3RpdmVOb3JtYWxGb3JtKCk7XG4gICAgICAgIGlmICggdGhpcy5Pci5pc0luc3RhbmNlKGEpICkge1xuICAgICAgICAgIG9yQXJncy5wdXNoKGEpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGFuZEFyZ3MucHVzaChhKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoIG9yQXJncy5sZW5ndGggPiAwICkge1xuICAgICAgICB2YXIgbmV3QW5kR3JvdXBzID0gW107XG4gICAgICAgIC8vIEdlbmVyYXRlIGV2ZXJ5IGNvbWJpbmF0aW9uIG9mIHRoZSBhcmd1bWVudHMgb2YgdGhlIE9SIGNsYXVzZXNcbiAgICAgICAgLy8gb3JBcmdzT2Zmc2V0c1tnXSByZXByZXNlbnRzIHRoZSBhcnJheSBpbmRleCB3ZSBhcmUgbG9va2lnIGF0XG4gICAgICAgIC8vIGluIG9yQXJnc1tnXS5hcmdzW29mZnNldF1cbiAgICAgICAgdmFyIG9yQXJnc09mZnNldHMgPSBuZXcgQXJyYXkob3JBcmdzLmxlbmd0aCkuZmlsbCgwKTtcbiAgICAgICAgdmFyIGFjdGl2ZSA9IHRydWU7XG4gICAgICAgIHZhciBpZHggPSBvckFyZ3NPZmZzZXRzLmxlbmd0aCAtIDE7XG4gICAgICAgIG9yQXJnc09mZnNldHNbaWR4XSA9IC0xOyAvLyBjb21wZW5zYXRlIGZvciBpbnRpYWwgKytvckFyZ3NPZmZzZXRzW2lkeF1cbiAgICAgICAgd2hpbGUgKCBhY3RpdmUgKSB7XG4gICAgICAgICAgd2hpbGUgKCArK29yQXJnc09mZnNldHNbaWR4XSA+PSBvckFyZ3NbaWR4XS5hcmdzLmxlbmd0aCApIHtcbiAgICAgICAgICAgIC8vIHJlc2V0IGFycmF5IGluZGV4IGNvdW50LCBjYXJyeSB0aGUgb25lXG4gICAgICAgICAgICBpZiAoIGlkeCA9PT0gMCApIHsgYWN0aXZlID0gZmFsc2U7IGJyZWFrOyB9XG4gICAgICAgICAgICBvckFyZ3NPZmZzZXRzW2lkeF0gPSAwO1xuICAgICAgICAgICAgaWR4LS07XG4gICAgICAgICAgfVxuICAgICAgICAgIGlkeCA9IG9yQXJnc09mZnNldHMubGVuZ3RoIC0gMTtcbiAgICAgICAgICBpZiAoICEgYWN0aXZlICkgYnJlYWs7XG5cbiAgICAgICAgICAvLyBmb3IgdGhlIGxhc3QgZ3JvdXAgaXRlcmF0ZWQsIHJlYWQgYmFjayB1cCB0aGUgaW5kZXhlc1xuICAgICAgICAgIC8vIHRvIGdldCB0aGUgcmVzdWx0IHNldFxuICAgICAgICAgIHZhciBuZXdBbmRBcmdzID0gW107XG4gICAgICAgICAgZm9yICggdmFyIGogPSBvckFyZ3NPZmZzZXRzLmxlbmd0aCAtIDE7IGogPj0gMDsgai0tICkge1xuICAgICAgICAgICAgbmV3QW5kQXJncy5wdXNoKG9yQXJnc1tqXS5hcmdzW29yQXJnc09mZnNldHNbal1dKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgbmV3QW5kQXJncyA9IG5ld0FuZEFyZ3MuY29uY2F0KGFuZEFyZ3MpO1xuXG4gICAgICAgICAgbmV3QW5kR3JvdXBzLnB1c2goXG4gICAgICAgICAgICB0aGlzLmNsc18uY3JlYXRlKHsgYXJnczogbmV3QW5kQXJncyB9KVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuT3IuY3JlYXRlKHsgYXJnczogbmV3QW5kR3JvdXBzIH0pLnBhcnRpYWxFdmFsKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBubyBPUiBhcmdzLCBubyBETkYgdHJhbnNmb3JtIG5lZWRlZFxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICB9XG4gIF1cbn0pO1xuXG5cbmZvYW0uQ0xBU1Moe1xuICBwYWNrYWdlOiAnZm9hbS5tbGFuZy5wcmVkaWNhdGUnLFxuICBuYW1lOiAnQ29udGFpbnMnLFxuICBleHRlbmRzOiAnZm9hbS5tbGFuZy5wcmVkaWNhdGUuQmluYXJ5JyxcbiAgaW1wbGVtZW50czogWyAnZm9hbS5jb3JlLlNlcmlhbGl6YWJsZScgXSxcblxuICBkb2N1bWVudGF0aW9uOiAnUHJlZGljYXRlIHJldHVybnMgdHJ1ZSBpZmYgc2Vjb25kIGFyZyBmb3VuZCBpbiBmaXJzdCBhcnJheSBhcmd1bWVudC4nLFxuXG4gIG1ldGhvZHM6IFtcbiAgICB7XG4gICAgICBuYW1lOiAnZicsXG4gICAgICBjb2RlOiBmdW5jdGlvbihvKSB7XG4gICAgICAgIHZhciBhcmcxID0gdGhpcy5hcmcxLmYobyk7XG4gICAgICAgIHZhciBhcmcyID0gdGhpcy5hcmcyLmYobyk7XG4gICAgICAgIGlmICggQXJyYXkuaXNBcnJheShhcmcxKSApIHtcbiAgICAgICAgICByZXR1cm4gYXJnMS5zb21lKGZ1bmN0aW9uKGEpIHtcbiAgICAgICAgICAgIHJldHVybiBhLmluZGV4T2YoYXJnMikgIT09IC0xO1xuICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFyZzEgPyBhcmcxLmluZGV4T2YoYXJnMikgIT09IC0xIDogZmFsc2U7ICAgICAgfVxuICAgIH1cbiAgXVxufSk7XG5cblxuZm9hbS5DTEFTUyh7XG4gIHBhY2thZ2U6ICdmb2FtLm1sYW5nLnByZWRpY2F0ZScsXG4gIG5hbWU6ICdDb250YWluc0lDJyxcbiAgZXh0ZW5kczogJ2ZvYW0ubWxhbmcucHJlZGljYXRlLkJpbmFyeScsXG4gIGltcGxlbWVudHM6IFsgJ2ZvYW0uY29yZS5TZXJpYWxpemFibGUnIF0sXG5cbiAgZG9jdW1lbnRhdGlvbjogJ1ByZWRpY2F0ZSByZXR1cm5zIHRydWUgaWZmIHNlY29uZCBhcmcgZm91bmQgaW4gZmlyc3QgYXJyYXkgYXJndW1lbnQsIGlnbm9yaW5nIGNhc2UuJyxcblxuICBtZXRob2RzOiBbXG4gICAgZnVuY3Rpb24gZihvKSB7XG4gICAgICB2YXIgYXJnMSA9IHRoaXMuYXJnMS5mKG8pO1xuICAgICAgdmFyIGFyZzIgPSB0aGlzLmFyZzIuZihvKS50b1VwcGVyQ2FzZSgpO1xuICAgICAgaWYgKCBBcnJheS5pc0FycmF5KGFyZzEpICkge1xuICAgICAgICByZXR1cm4gYXJnMS5zb21lKGZ1bmN0aW9uKGEpIHtcbiAgICAgICAgICByZXR1cm4gYS50b1VwcGVyQ2FzZSgpLmluZGV4T2YoYXJnMikgIT09IC0xO1xuICAgICAgICB9KVxuICAgICAgfVxuICAgICAgcmV0dXJuIGFyZzEgPyBhcmcxLnRvVXBwZXJDYXNlKCkuaW5kZXhPZihhcmcyKSAhPT0gLTEgOiBmYWxzZTtcbiAgICB9LFxuICBdXG59KTtcblxuXG5mb2FtLkNMQVNTKHtcbiAgcGFja2FnZTogJ2ZvYW0ubWxhbmcucHJlZGljYXRlJyxcbiAgbmFtZTogJ1N0YXJ0c1dpdGgnLFxuICBleHRlbmRzOiAnZm9hbS5tbGFuZy5wcmVkaWNhdGUuQmluYXJ5JyxcbiAgaW1wbGVtZW50czogWyAnZm9hbS5jb3JlLlNlcmlhbGl6YWJsZScgXSxcblxuICBkb2N1bWVudGF0aW9uOiAnUHJlZGljYXRlIHJldHVybnMgdHJ1ZSBpZmYgYXJnMSBzdGFydHMgd2l0aCBhcmcyIG9yIGlmIGFyZzEgaXMgYW4gYXJyYXksIGlmIGFuIGVsZW1lbnQgc3RhcnRzIHdpdGggYXJnMi4nLFxuXG4gIG1ldGhvZHM6IFtcbiAgICB7XG4gICAgICBuYW1lOiAnZicsXG4gICAgICBjb2RlOiBmdW5jdGlvbihvKSB7XG4gICAgICAgIHZhciBhcmcxID0gdGhpcy5hcmcxLmYobyk7XG4gICAgICAgIHZhciBhcmcyID0gdGhpcy5hcmcyLmYobyk7XG5cbiAgICAgICAgaWYgKCBBcnJheS5pc0FycmF5KGFyZzEpICkge1xuICAgICAgICAgIHJldHVybiBhcmcxLnNvbWUoZnVuY3Rpb24oYXJnKSB7XG4gICAgICAgICAgICByZXR1cm4gYXJnLnN0YXJ0c1dpdGgoYXJnMik7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYXJnMS5zdGFydHNXaXRoKGFyZzIpO1xuICAgICAgfVxuICAgIH1cbiAgXVxufSk7XG5cblxuZm9hbS5DTEFTUyh7XG4gIHBhY2thZ2U6ICdmb2FtLm1sYW5nLnByZWRpY2F0ZScsXG4gIG5hbWU6ICdTdGFydHNXaXRoSUMnLFxuICBleHRlbmRzOiAnZm9hbS5tbGFuZy5wcmVkaWNhdGUuQmluYXJ5JyxcbiAgaW1wbGVtZW50czogWydmb2FtLmNvcmUuU2VyaWFsaXphYmxlJ10sXG5cbiAgZG9jdW1lbnRhdGlvbjogJ1ByZWRpY2F0ZSByZXR1cm5zIHRydWUgaWZmIGFyZzEgc3RhcnRzIHdpdGggYXJnMiBvciBpZiBhcmcxIGlzIGFuIGFycmF5LCBpZiBhbiBlbGVtZW50IHN0YXJ0cyB3aXRoIGFyZzIsIGlnbm9yaW5nIGNhc2UuJyxcblxuICBtZXRob2RzOiBbXG4gICAge1xuICAgICAgbmFtZTogJ2YnLFxuICAgICAgY29kZTogZnVuY3Rpb24gZihvKSB7XG4gICAgICAgIHZhciBhcmcxID0gdGhpcy5hcmcxLmYobyk7XG4gICAgICAgIHZhciBhcmcyID0gdGhpcy5hcmcyLmYobyk7XG5cbiAgICAgICAgaWYgKCBBcnJheS5pc0FycmF5KGFyZzEpICkge1xuICAgICAgICAgIHJldHVybiBhcmcxLnNvbWUoZnVuY3Rpb24oYXJnKSB7XG4gICAgICAgICAgICByZXR1cm4gZm9hbS5TdHJpbmcuc3RhcnRzV2l0aElDKGFyZywgYXJnMik7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZm9hbS5TdHJpbmcuc3RhcnRzV2l0aElDKGFyZzEsIGFyZzIpO1xuICAgICAgfVxuICAgIH1cbiAgXVxufSk7XG5cblxuZm9hbS5DTEFTUyh7XG4gIHBhY2thZ2U6ICdmb2FtLm1sYW5nLnByZWRpY2F0ZScsXG4gIG5hbWU6ICdFbmRzV2l0aCcsXG4gIGV4dGVuZHM6ICdmb2FtLm1sYW5nLnByZWRpY2F0ZS5CaW5hcnknLFxuICBpbXBsZW1lbnRzOiBbICdmb2FtLmNvcmUuU2VyaWFsaXphYmxlJyBdLFxuXG4gIGRvY3VtZW50YXRpb246ICdQcmVkaWNhdGUgcmV0dXJucyB0cnVlIGlmZiBhcmcxIGVuZHMgd2l0aCBhcmcyIG9yIGlmIGFyZzEgaXMgYW4gYXJyYXksIGlmIGFuIGVsZW1lbnQgc3RhcnRzIHdpdGggYXJnMi4nLFxuXG4gIG1ldGhvZHM6IFtcbiAgICB7XG4gICAgICBuYW1lOiAnZicsXG4gICAgICBjb2RlOiBmdW5jdGlvbihvKSB7XG4gICAgICAgIHZhciBhcmcxID0gdGhpcy5hcmcxLmYobyk7XG4gICAgICAgIHZhciBhcmcyID0gdGhpcy5hcmcyLmYobyk7XG5cbiAgICAgICAgaWYgKCBBcnJheS5pc0FycmF5KGFyZzEpICkge1xuICAgICAgICAgIHJldHVybiBhcmcxLnNvbWUoZnVuY3Rpb24oYXJnKSB7XG4gICAgICAgICAgICByZXR1cm4gYXJnLmVuZHNXaXRoKGFyZzIpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGFyZzEuZW5kc1dpdGgoYXJnMik7XG4gICAgICB9XG4gICAgfVxuICBdXG59KTtcblxuXG5mb2FtLkNMQVNTKHtcbiAgcGFja2FnZTogJ2ZvYW0ubWxhbmcucHJlZGljYXRlJyxcbiAgbmFtZTogJ0FycmF5QmluYXJ5JyxcbiAgZXh0ZW5kczogJ2ZvYW0ubWxhbmcucHJlZGljYXRlLkJpbmFyeScsXG4gIGFic3RyYWN0OiB0cnVlLFxuXG4gIGRvY3VtZW50YXRpb246ICdCaW5hcnkgcHJlZGljYXRlIHRoYXQgYWNjZXB0cyBhbiBhcnJheSBpbiBcImFyZzJcIi4nLFxuXG4gIHByb3BlcnRpZXM6IFtcbiAgICB7XG4gICAgICBuYW1lOiAnYXJnMicsXG4gICAgICBwb3N0U2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy52YWx1ZVNldF8gPSBudWxsO1xuICAgICAgfSxcbiAgICAgIGFkYXB0OiBmdW5jdGlvbihvbGQsIG51LCBwcm9wKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IHByb3AuYWRhcHRWYWx1ZShudSk7XG4gICAgICAgIHZhciBhcmcxID0gdGhpcy5hcmcxO1xuXG4gICAgICAgIC8vIEFkYXB0IGNvbnN0YW50IGFycmF5IGVsZW1lbnRzIHdoZW46XG4gICAgICAgIC8vICgxKSBWYWx1ZSBpcyBhIGNvbnN0YW50IChhcnJheSk7XG4gICAgICAgIC8vICgyKSBWYWx1ZSBpcyB0cnV0aHkgKGVtcHR5IGFycmF5cyBjYW4gYmUgc2VyaWFsaXplZCBhcyB1bmRlZmluZWQpO1xuICAgICAgICAvLyAoMykgQXJnMSBoYXMgYW4gYWRhcHQoKS5cbiAgICAgICAgaWYgKCBmb2FtLm1sYW5nLkNvbnN0YW50LmlzSW5zdGFuY2UodmFsdWUpICYmIHZhbHVlLnZhbHVlICYmXG4gICAgICAgICAgICAgYXJnMSAmJiBhcmcxLmFkYXB0ICkge1xuICAgICAgICAgIHZhciBhcnJheVZhbHVlID0gdmFsdWUudmFsdWU7XG4gICAgICAgICAgZm9yICggdmFyIGkgPSAwOyBpIDwgYXJyYXlWYWx1ZS5sZW5ndGg7IGkrKyApIHtcbiAgICAgICAgICAgIGFycmF5VmFsdWVbaV0gPSBhcmcxLmFkYXB0LmNhbGwobnVsbCwgb2xkICYmIG9sZFtpXSwgYXJyYXlWYWx1ZVtpXSwgYXJnMSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfVxuICAgIH0sXG4gICAge1xuICAgICAgLy8gVE9ETzogc2ltcGxlciB0byBtYWtlIGFuIGV4cHJlc3Npb25cbiAgICAgIG5hbWU6ICd2YWx1ZVNldF8nXG4gICAgfVxuICBdXG59KTtcblxuXG5mb2FtLkNMQVNTKHtcbiAgcGFja2FnZTogJ2ZvYW0ubWxhbmcucHJlZGljYXRlJyxcbiAgbmFtZTogJ0luJyxcbiAgZXh0ZW5kczogJ2ZvYW0ubWxhbmcucHJlZGljYXRlLkFycmF5QmluYXJ5JyxcbiAgaW1wbGVtZW50czogW1xuICAgICdmb2FtLmNvcmUuU2VyaWFsaXphYmxlJyxcbiAgICB7IHBhdGg6ICdmb2FtLm1sYW5nLkV4cHJlc3Npb25zJywgamF2YTogZmFsc2UgfVxuICBdLFxuXG4gIGRvY3VtZW50YXRpb246ICdQcmVkaWNhdGUgcmV0dXJucyB0cnVlIGlmZiBhcmcxIGlzIGEgc3Vic3RyaW5nIG9mIGFyZzIsIG9yIGlmIGFyZzIgaXMgYW4gYXJyYXksIGFyZzEgaXMgYW4gZWxlbWVudCBvZiBhcmcyLicsXG5cbiAgcmVxdWlyZXM6IFsgJ2ZvYW0ubWxhbmcuQ29uc3RhbnQnIF0sXG5cbiAgcHJvcGVydGllczogW1xuICAgIHtcbiAgICAgIG5hbWU6ICdhcmcxJyxcbiAgICAgIHBvc3RTZXQ6IGZ1bmN0aW9uKG9sZCwgbnUpIHtcbiAgICAgICAgLy8gdGhpcyBpcyBzbGlnaHRseSBzbG93ZXIgd2hlbiBhbiBleHByZXNzaW9uIG9uIHVwcGVyQ2FzZV9cbiAgICAgICAgdGhpcy51cHBlckNhc2VfID0gbnUgJiYgZm9hbS5jb3JlLkVudW0uaXNJbnN0YW5jZShudSk7XG4gICAgICB9XG4gICAgfSxcbiAgICB7XG4gICAgICBuYW1lOiAndXBwZXJDYXNlXycsXG4gICAgfVxuICBdLFxuXG4gIG1ldGhvZHM6IFtcbiAgICBmdW5jdGlvbiBmKG8pIHtcbiAgICAgIHZhciBsaHMgPSB0aGlzLmFyZzEuZihvKTtcbiAgICAgIHZhciByaHMgPSB0aGlzLmFyZzIuZihvKTtcblxuICAgICAgaWYgKCAhIHJocyApIHJldHVybiBmYWxzZTtcblxuICAgICAgZm9yICggdmFyIGkgPSAwIDsgaSA8IHJocy5sZW5ndGggOyBpKysgKSB7XG4gICAgICAgIHZhciB2ID0gcmhzW2ldO1xuXG4gICAgICAgIGlmICggZm9hbS5TdHJpbmcuaXNJbnN0YW5jZSh2KSAmJiB0aGlzLnVwcGVyQ2FzZV8gKSB2ID0gdi50b1VwcGVyQ2FzZSgpO1xuICAgICAgICBpZiAoIGZvYW0udXRpbC5lcXVhbHMobGhzLCB2KSApIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuXG4gICAgICAvLyBUT0RPOiBUaGlzIGlzIG5vdCBhIHN1ZmZpY2llbnQgZW5vdWdoIGNoZWNrIGZvciB2YWx1ZVNldF8uXG4gICAgICAvLyBXZSBjYW4gaGF2ZSBjb25zdGFudHMgdGhhdCBjb250YWluIG90aGVyIEZPYmplY3RzLCBpblxuICAgICAgLy8gcGFydGljdWxhciB3aXRoIG11bHRpIHBhcnQgaWQgc3VwcG9ydC5TbyB0aGlzIGNvZGUgcGF0aCBpc1xuICAgICAgLy8gZGlzYWJsZWQgZm9yIG5vdy5cblxuXG4gICAgICAvLyBJZiBhcmcyIGlzIGEgY29uc3RhbnQgYXJyYXksIHdlIHVzZSB2YWx1ZVNldCBmb3IgaXQuXG4gICAgICBpZiAoIHRoaXMuQ29uc3RhbnQuaXNJbnN0YW5jZSh0aGlzLmFyZzIpICkge1xuICAgICAgICBpZiAoICEgdGhpcy52YWx1ZVNldF8gKSB7XG4gICAgICAgICAgdmFyIHNldCA9IHt9O1xuICAgICAgICAgIGZvciAoIHZhciBpID0gMCA7IGkgPCByaHMubGVuZ3RoIDsgaSsrICkge1xuICAgICAgICAgICAgdmFyIHMgPSByaHNbaV07XG4gICAgICAgICAgICBpZiAoIHRoaXMudXBwZXJDYXNlXyApIHMgPSBzLnRvVXBwZXJDYXNlKCk7XG4gICAgICAgICAgICBzZXRbc10gPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLnZhbHVlU2V0XyA9IHNldDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAhISB0aGlzLnZhbHVlU2V0X1tsaHNdO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmhzID8gcmhzLmluZGV4T2YobGhzKSAhPT0gLTEgOiBmYWxzZTtcbiAgICB9LFxuICAgIGZ1bmN0aW9uIHBhcnRpYWxFdmFsKCkge1xuICAgICAgaWYgKCAhIHRoaXMuQ29uc3RhbnQuaXNJbnN0YW5jZSh0aGlzLmFyZzIpICkgcmV0dXJuIHRoaXM7XG5cbiAgICAgIHJldHVybiAoICEgdGhpcy5hcmcyLnZhbHVlICkgfHwgdGhpcy5hcmcyLnZhbHVlLmxlbmd0aCA9PT0gMCA/XG4gICAgICAgICAgdGhpcy5GQUxTRSA6IHRoaXM7XG4gICAgfVxuICBdXG59KTtcblxuXG5mb2FtLkNMQVNTKHtcbiAgcGFja2FnZTogJ2ZvYW0ubWxhbmcucHJlZGljYXRlJyxcbiAgbmFtZTogJ0luSUMnLFxuICBleHRlbmRzOiAnZm9hbS5tbGFuZy5wcmVkaWNhdGUuQXJyYXlCaW5hcnknLFxuICBpbXBsZW1lbnRzOiBbICdmb2FtLmNvcmUuU2VyaWFsaXphYmxlJyBdLFxuXG4gIGRvY3VtZW50YXRpb246ICdQcmVkaWNhdGUgcmV0dXJucyB0cnVlIGlmZiBhcmcxIGlzIGEgc3Vic3RyaW5nIG9mIGFyZzIsIG9yIGlmIGFyZzIgaXMgYW4gYXJyYXksIGlzIGFuIGVsZW1lbnQgb2YgYXJnMiwgY2FzZSBpbnNlbnNpdGl2ZS4nLFxuXG4gIG1ldGhvZHM6IFtcbiAgICBmdW5jdGlvbiBmKG8pIHtcbiAgICAgIHZhciBsaHMgPSB0aGlzLmFyZzEuZihvKTtcbiAgICAgIHZhciByaHMgPSB0aGlzLmFyZzIuZihvKTtcblxuICAgICAgaWYgKCBsaHMudG9VcHBlckNhc2UgKSBsaHMgPSBsaHMudG9VcHBlckNhc2UoKTtcblxuICAgICAgLy8gSWYgYXJnMiBpcyBhIGNvbnN0YW50IGFycmF5LCB3ZSB1c2UgdmFsdWVTZXQgZm9yIGl0LlxuICAgICAgaWYgKCBmb2FtLm1sYW5nLkNvbnN0YW50LmlzSW5zdGFuY2UodGhpcy5hcmcyKSApIHtcbiAgICAgICAgaWYgKCAhIHRoaXMudmFsdWVTZXRfICkge1xuICAgICAgICAgIHZhciBzZXQgPSB7fTtcbiAgICAgICAgICBmb3IgKCB2YXIgaSA9IDAgOyBpIDwgcmhzLmxlbmd0aCA7IGkrKyApIHtcbiAgICAgICAgICAgIHNldFtyaHNbaV0udG9VcHBlckNhc2UoKV0gPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLnZhbHVlU2V0XyA9IHNldDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAhISB0aGlzLnZhbHVlU2V0X1tsaHNdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKCAhIHJocyApIHJldHVybiBmYWxzZTtcbiAgICAgICAgcmV0dXJuIHJocy50b1VwcGVyQ2FzZSgpLmluZGV4T2YobGhzKSAhPT0gLTE7XG4gICAgICB9XG4gICAgfVxuICBdXG59KTtcblxuXG5mb2FtLkNMQVNTKHtcbiAgcGFja2FnZTogJ2ZvYW0ubWxhbmcnLFxuICBuYW1lOiAnQ29uc3RhbnQnLFxuICBleHRlbmRzOiAnZm9hbS5tbGFuZy5BYnN0cmFjdEV4cHInLFxuICBpbXBsZW1lbnRzOiBbICdmb2FtLmNvcmUuU2VyaWFsaXphYmxlJyBdLFxuXG4gIGRvY3VtZW50YXRpb246ICdBbiBFeHByZXNzaW9uIHdoaWNoIGFsd2F5cyByZXR1cm5zIHRoZSBzYW1lIGNvbnN0YW50IHZhbHVlLicsXG5cbiAgcHJvcGVydGllczogW1xuICAgIHtcbiAgICAgIGNsYXNzOiAnT2JqZWN0JyxcbiAgICAgIG5hbWU6ICd2YWx1ZScsXG4gICAgICBhZGFwdDogZnVuY3Rpb24oXywgbnUpIHtcbiAgICAgICAgLy8gRGVhbCB3aXRoIGVtcHR5IGFycmF5cyB0aGF0IHNlcmlhbGl6ZSBhcyB1bmRlZmluZWQuXG4gICAgICAgIHJldHVybiBmb2FtLlVuZGVmaW5lZC5pc0luc3RhbmNlKG51KSA/IFtdIDogbnU7XG4gICAgICB9LFxuICAgIH1cbiAgXSxcblxuICBtZXRob2RzOiBbXG4gICAge1xuICAgICAgbmFtZTogJ2YnLFxuICAgICAgY29kZTogZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLnZhbHVlOyB9LFxuICAgICAgc3dpZnRDb2RlOiBgcmV0dXJuIHZhbHVlYCxcbiAgICB9LFxuXG4gICAgZnVuY3Rpb24gdG9TdHJpbmdfKHgpIHtcbiAgICAgIHJldHVybiB0eXBlb2YgeCA9PT0gJ251bWJlcicgPyAnJyArIHggOlxuICAgICAgICB0eXBlb2YgeCA9PT0gJ3N0cmluZycgPyAnXCInICsgeCArICdcIicgOlxuICAgICAgICBBcnJheS5pc0FycmF5KHgpID8gJ1snICsgeC5tYXAodGhpcy50b1N0cmluZ18uYmluZCh0aGlzKSkuam9pbignLCAnKSArICddJyA6XG4gICAgICAgIHgudG9TdHJpbmcgPyB4LnRvU3RyaW5nKCkgOlxuICAgICAgICB4O1xuICAgIH0sXG5cbiAgICBmdW5jdGlvbiB0b1N0cmluZygpIHsgcmV0dXJuIHRoaXMudG9TdHJpbmdfKHRoaXMudmFsdWUpOyB9LFxuXG4gICAgLy8gVE9ETyhhZGFtdnkpOiBSZS1lbmFibGUgd2hlbiB3ZSBjYW4gcGFyc2UgdGhpcyBpbiBqYXZhIG1vcmUgY29ycmVjdGx5LlxuICAgIGZ1bmN0aW9uIHh4b3V0cHV0SlNPTihvcykge1xuICAgICAgb3Mub3V0cHV0KHRoaXMudmFsdWUpO1xuICAgIH1cbiAgXVxufSk7XG5cbmZvYW0uQ0xBU1Moe1xuICBwYWNrYWdlOiAnZm9hbS5tbGFuZycsXG4gIG5hbWU6ICdBcnJheUNvbnN0YW50JyxcbiAgZXh0ZW5kczogJ2ZvYW0ubWxhbmcuQWJzdHJhY3RFeHByJyxcbiAgaW1wbGVtZW50czogWyAnZm9hbS5jb3JlLlNlcmlhbGl6YWJsZSddLFxuXG4gIHByb3BlcnRpZXM6IFtcbiAgICB7XG4gICAgICBjbGFzczogJ0FycmF5JyxcbiAgICAgIG5hbWU6ICd2YWx1ZSdcbiAgICB9XG4gIF0sXG5cbiAgbWV0aG9kczogW1xuICAgIGZ1bmN0aW9uIGYoKSB7IHJldHVybiB0aGlzLnZhbHVlOyB9LFxuXG4gICAgZnVuY3Rpb24gdG9TdHJpbmdfKHgpIHtcbiAgICAgIHJldHVybiBBcnJheS5pc0FycmF5KHgpID8gJ1snICsgeC5tYXAodGhpcy50b1N0cmluZ18uYmluZCh0aGlzKSkuam9pbignLCAnKSArICddJyA6XG4gICAgICAgIHgudG9TdHJpbmcgPyB4LnRvU3RyaW5nIDpcbiAgICAgICAgeDtcbiAgICB9LFxuXG4gICAgZnVuY3Rpb24gdG9TdHJpbmcoKSB7IHJldHVybiB0aGlzLnRvU3RyaW5nXyh0aGlzLnZhbHVlKTsgfVxuICBdXG59KTtcblxuXG5mb2FtLkNMQVNTKHtcbiAgcGFja2FnZTogJ2ZvYW0ubWxhbmcucHJlZGljYXRlJyxcbiAgbmFtZTogJ0Z1bmMnLFxuICBleHRlbmRzOiAnZm9hbS5tbGFuZy5wcmVkaWNhdGUuQWJzdHJhY3RQcmVkaWNhdGUnLFxuXG4gIGRvY3VtZW50YXRpb246ICdBIGZ1bmN0aW9uIHRvIFByZWRpY2F0ZSBhZGFwdGVyLicsXG5cbiAgLy8gVE9ETzogcmVuYW1lIEZ1bmN0aW9uUHJlZGljYXRlXG5cbiAgcHJvcGVydGllczogW1xuICAgIHtcbiAgICAgIC8qKiBUaGUgZnVuY3Rpb24gdG8gYXBwbHkgdG8gb2JqZWN0cyBwYXNzZWQgdG8gdGhpcyBleHByZXNzaW9uICovXG4gICAgICBuYW1lOiAnZm4nXG4gICAgfVxuICBdLFxuXG4gIG1ldGhvZHM6IFtcbiAgICBmdW5jdGlvbiBmKG8pIHsgcmV0dXJuIHRoaXMuZm4obyk7IH0sXG4gICAgZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgICByZXR1cm4gJ0ZVTkMoJyArIGZuLnRvU3RyaW5nKCkgKyAnKSc7XG4gICAgfVxuICBdXG59KTtcblxuXG4vKiogQmluYXJ5IGV4cHJlc3Npb24gZm9yIGVxdWFsaXR5IG9mIHR3byBhcmd1bWVudHMuICovXG5mb2FtLkNMQVNTKHtcbiAgcGFja2FnZTogJ2ZvYW0ubWxhbmcucHJlZGljYXRlJyxcbiAgbmFtZTogJ0VxJyxcbiAgZXh0ZW5kczogJ2ZvYW0ubWxhbmcucHJlZGljYXRlLkJpbmFyeScsXG5cbiAgaW1wbGVtZW50czogWyAnZm9hbS5jb3JlLlNlcmlhbGl6YWJsZScgXSxcblxuICBkb2N1bWVudGF0aW9uOiAnQmluYXJ5IFByZWRpY2F0ZSByZXR1cm5zIHRydWUgaWZmIGFyZzEgRVFVQUxTIGFyZzIuJyxcblxuICBtZXRob2RzOiBbXG4gICAge1xuICAgICAgbmFtZTogJ2YnLFxuICAgICAgY29kZTogZnVuY3Rpb24obykge1xuICAgICAgICB2YXIgdjEgPSB0aGlzLmFyZzEuZihvKTtcbiAgICAgICAgdmFyIHYyID0gdGhpcy5hcmcyLmYobyk7XG5cbiAgICAgICAgLy8gRmlyc3QgY2hlY2sgaXMgc28gdGhhdCBFUShDbGFzcy5QUk9QRVJUWSwgbnVsbCB8IHVuZGVmaW5lZCkgd29ya3MuXG4gICAgICAgIHJldHVybiAoIHYxID09PSB1bmRlZmluZWQgJiYgdjIgPT09IG51bGwgKSB8fCBmb2FtLnV0aWwuZXF1YWxzKHYxLCB2Mik7XG4gICAgICB9LFxuICAgICAgc3dpZnRDb2RlOiBgXG5sZXQgdjEgPSAoYXJnMSBhcyEgRXhwcikuZihvYmopXG5sZXQgdjIgPSAoYXJnMiBhcyEgRXhwcikuZihvYmopXG5yZXR1cm4gRk9BTV91dGlscy5lcXVhbHModjEsIHYyKVxuICAgICAgYCxcbiAgICB9LFxuXG4gICAgZnVuY3Rpb24gcmVkdWNlQW5kKG90aGVyKSB7XG4gICAgICB2YXIgbXlBcmcxICAgICAgICAgICA9IHRoaXMuYXJnMTtcbiAgICAgIHZhciBteUFyZzIgICAgICAgICAgID0gdGhpcy5hcmcyO1xuICAgICAgdmFyIG90aGVyQXJnMSAgICAgICAgPSBvdGhlci5hcmcxO1xuICAgICAgdmFyIG90aGVyQXJnMiAgICAgICAgPSBvdGhlci5hcmcyO1xuICAgICAgdmFyIGlzQ29uc3QgICAgICAgICAgPSBmb2FtLm1sYW5nLkNvbnN0YW50LmlzSW5zdGFuY2UuYmluZChmb2FtLm1sYW5nLkNvbnN0YW50KTtcbiAgICAgIHZhciBteUFyZzFJc0NvbnN0ICAgID0gaXNDb25zdChteUFyZzEpO1xuICAgICAgdmFyIG15QXJnMklzQ29uc3QgICAgPSBpc0NvbnN0KG15QXJnMik7XG4gICAgICB2YXIgb3RoZXJBcmcxSXNDb25zdCA9IGlzQ29uc3Qob3RoZXJBcmcxKTtcbiAgICAgIHZhciBvdGhlckFyZzJJc0NvbnN0ID0gaXNDb25zdChvdGhlckFyZzIpO1xuXG4gICAgICAvLyBSZXF1aXJlIG9uZSBjb25zdCwgb25lIG5vbi1jb25zdCBpbiB0aGlzIGFuZCBvdGhlci5cbiAgICAgIGlmICggbXlBcmcxSXNDb25zdCA9PT0gbXlBcmcySXNDb25zdCB8fCBvdGhlckFyZzFJc0NvbnN0ID09PSBvdGhlckFyZzJJc0NvbnN0IClcbiAgICAgICAgcmV0dXJuIHRoaXMuU1VQRVIob3RoZXIpO1xuXG4gICAgICAvLyBSZXF1aXJlIHNhbWUgZXhwci5cbiAgICAgIHZhciBteUV4cHIgICAgPSBteUFyZzFJc0NvbnN0ID8gbXlBcmcyIDogbXlBcmcxO1xuICAgICAgdmFyIG90aGVyRXhwciA9IG90aGVyQXJnMUlzQ29uc3QgPyBvdGhlckFyZzIgOiBvdGhlckFyZzE7XG4gICAgICB2YXIgZXF1YWxzICAgID0gZm9hbS51dGlsLmVxdWFscztcblxuICAgICAgaWYgKCAhIGVxdWFscyhteUV4cHIsIG90aGVyRXhwcikgKSByZXR1cm4gdGhpcy5TVVBFUihvdGhlcik7XG5cbiAgICAgIC8vIFJlZHVjZSB0byBGQUxTRSB3aGVuIGNvbnN0cyBhcmUgbm90IGVxdWFsLlxuICAgICAgdmFyIG15Q29uc3QgICAgPSBteUFyZzFJc0NvbnN0ICAgID8gbXlBcmcxICAgIDogbXlBcmcyO1xuICAgICAgdmFyIG90aGVyQ29uc3QgPSBvdGhlckFyZzFJc0NvbnN0ID8gb3RoZXJBcmcxIDogb3RoZXJBcmcyO1xuXG4gICAgICByZXR1cm4gZXF1YWxzKG15Q29uc3QsIG90aGVyQ29uc3QpID8gdGhpcy5TVVBFUihvdGhlcikgOiB0aGlzLkZBTFNFO1xuICAgIH1cbiAgXVxufSk7XG5cblxuLyoqIEJpbmFyeSBleHByZXNzaW9uIGZvciBpbmVxdWFsaXR5IG9mIHR3byBhcmd1bWVudHMuICovXG5mb2FtLkNMQVNTKHtcbiAgcGFja2FnZTogJ2ZvYW0ubWxhbmcucHJlZGljYXRlJyxcbiAgbmFtZTogJ05lcScsXG4gIGV4dGVuZHM6ICdmb2FtLm1sYW5nLnByZWRpY2F0ZS5CaW5hcnknLFxuICBpbXBsZW1lbnRzOiBbICdmb2FtLmNvcmUuU2VyaWFsaXphYmxlJyBdLFxuXG4gIGRvY3VtZW50YXRpb246ICdCaW5hcnkgUHJlZGljYXRlIHJldHVybnMgdHJ1ZSBpZmYgYXJnMSBkb2VzIE5PVCBFUVVBTCBhcmcyLicsXG5cbiAgbWV0aG9kczogW1xuICAgIHtcbiAgICAgIG5hbWU6ICdmJyxcbiAgICAgIGNvZGU6IGZ1bmN0aW9uKG8pIHtcbiAgICAgICAgcmV0dXJuICEgZm9hbS51dGlsLmVxdWFscyh0aGlzLmFyZzEuZihvKSwgdGhpcy5hcmcyLmYobykpO1xuICAgICAgfVxuICAgIH1cbiAgXVxufSk7XG5cblxuLyoqIEJpbmFyeSBleHByZXNzaW9uIGZvciBcInN0cmljdGx5IGxlc3MgdGhhblwiLiAqL1xuZm9hbS5DTEFTUyh7XG4gIHBhY2thZ2U6ICdmb2FtLm1sYW5nLnByZWRpY2F0ZScsXG4gIG5hbWU6ICdMdCcsXG4gIGV4dGVuZHM6ICdmb2FtLm1sYW5nLnByZWRpY2F0ZS5CaW5hcnknLFxuICBpbXBsZW1lbnRzOiBbICdmb2FtLmNvcmUuU2VyaWFsaXphYmxlJyBdLFxuXG4gIGRvY3VtZW50YXRpb246ICdCaW5hcnkgUHJlZGljYXRlIHJldHVybnMgdHJ1ZSBpZmYgYXJnMSBpcyBMRVNTIFRIQU4gYXJnMi4nLFxuXG4gIG1ldGhvZHM6IFtcbiAgICB7XG4gICAgICBuYW1lOiAnZicsXG4gICAgICBjb2RlOiBmdW5jdGlvbihvKSB7XG4gICAgICAgIHJldHVybiBmb2FtLnV0aWwuY29tcGFyZSh0aGlzLmFyZzEuZihvKSwgdGhpcy5hcmcyLmYobykpIDwgMDtcbiAgICAgIH1cbiAgICB9XG4gIF1cbn0pO1xuXG5cbi8qKiBCaW5hcnkgZXhwcmVzc2lvbiBmb3IgXCJsZXNzIHRoYW4gb3IgZXF1YWwgdG9cIi4gKi9cbmZvYW0uQ0xBU1Moe1xuICBwYWNrYWdlOiAnZm9hbS5tbGFuZy5wcmVkaWNhdGUnLFxuICBuYW1lOiAnTHRlJyxcbiAgZXh0ZW5kczogJ2ZvYW0ubWxhbmcucHJlZGljYXRlLkJpbmFyeScsXG4gIGltcGxlbWVudHM6IFsgJ2ZvYW0uY29yZS5TZXJpYWxpemFibGUnIF0sXG5cbiAgZG9jdW1lbnRhdGlvbjogJ0JpbmFyeSBQcmVkaWNhdGUgcmV0dXJucyB0cnVlIGlmZiBhcmcxIGlzIExFU1MgVEhBTiBvciBFUVVBTCB0byBhcmcyLicsXG5cbiAgbWV0aG9kczogW1xuICAgIHtcbiAgICAgIG5hbWU6ICdmJyxcbiAgICAgIGNvZGU6IGZ1bmN0aW9uKG8pIHtcbiAgICAgICAgcmV0dXJuIGZvYW0udXRpbC5jb21wYXJlKHRoaXMuYXJnMS5mKG8pLCB0aGlzLmFyZzIuZihvKSkgPD0gMDtcbiAgICAgIH1cbiAgICB9XG4gIF1cbn0pO1xuXG5cbi8qKiBCaW5hcnkgZXhwcmVzc2lvbiBmb3IgXCJzdHJpY3RseSBncmVhdGVyIHRoYW5cIi4gKi9cbmZvYW0uQ0xBU1Moe1xuICBwYWNrYWdlOiAnZm9hbS5tbGFuZy5wcmVkaWNhdGUnLFxuICBuYW1lOiAnR3QnLFxuICBleHRlbmRzOiAnZm9hbS5tbGFuZy5wcmVkaWNhdGUuQmluYXJ5JyxcbiAgaW1wbGVtZW50czogWyAnZm9hbS5jb3JlLlNlcmlhbGl6YWJsZScgXSxcblxuICBkb2N1bWVudGF0aW9uOiAnQmluYXJ5IFByZWRpY2F0ZSByZXR1cm5zIHRydWUgaWZmIGFyZzEgaXMgR1JFQVRFUiBUSEFOIGFyZzIuJyxcblxuICBtZXRob2RzOiBbXG4gICAge1xuICAgICAgbmFtZTogJ2YnLFxuICAgICAgY29kZTogZnVuY3Rpb24obykge1xuICAgICAgICByZXR1cm4gZm9hbS51dGlsLmNvbXBhcmUodGhpcy5hcmcxLmYobyksIHRoaXMuYXJnMi5mKG8pKSA+IDA7XG4gICAgICB9XG4gICAgfVxuICBdXG59KTtcblxuXG4vKiogQmluYXJ5IGV4cHJlc3Npb24gZm9yIFwiZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvXCIuICovXG5mb2FtLkNMQVNTKHtcbiAgcGFja2FnZTogJ2ZvYW0ubWxhbmcucHJlZGljYXRlJyxcbiAgbmFtZTogJ0d0ZScsXG4gIGV4dGVuZHM6ICdmb2FtLm1sYW5nLnByZWRpY2F0ZS5CaW5hcnknLFxuICBpbXBsZW1lbnRzOiBbICdmb2FtLmNvcmUuU2VyaWFsaXphYmxlJyBdLFxuXG4gIGRvY3VtZW50YXRpb246ICdCaW5hcnkgUHJlZGljYXRlIHJldHVybnMgdHJ1ZSBpZmYgYXJnMSBpcyBHUkVBVEVSIFRIQU4gb3IgRVFVQUwgdG8gYXJnMi4nLFxuXG5cbiAgbWV0aG9kczogW1xuICAgIHtcbiAgICAgIG5hbWU6ICdmJyxcbiAgICAgIGNvZGU6IGZ1bmN0aW9uKG8pIHtcbiAgICAgICAgcmV0dXJuIGZvYW0udXRpbC5jb21wYXJlKHRoaXMuYXJnMS5mKG8pLCB0aGlzLmFyZzIuZihvKSkgPj0gMDtcbiAgICAgIH1cbiAgICB9XG4gIF1cbn0pO1xuXG5cbmZvYW0uQ0xBU1Moe1xuICBwYWNrYWdlOiAnZm9hbS5tbGFuZy5wcmVkaWNhdGUnLFxuICBuYW1lOiAnSGFzJyxcbiAgZXh0ZW5kczogJ2ZvYW0ubWxhbmcucHJlZGljYXRlLlVuYXJ5JyxcbiAgaW1wbGVtZW50czogWyAnZm9hbS5jb3JlLlNlcmlhbGl6YWJsZScgXSxcblxuICBkb2N1bWVudGF0aW9uOiAnVW5hcnkgUHJlZGljYXRlIHRoYXQgcmV0dXJucyB0cnVlIGlmZiB0aGUgZ2l2ZW4gcHJvcGVydHkgaGFzIGEgdmFsdWUgb3RoZXIgdGhhbiBudWxsLCB1bmRlZmluZWQsIFxcJ1xcJywgb3IgW10uJyxcblxuICBtZXRob2RzOiBbXG4gICAgZnVuY3Rpb24gZihvYmopIHtcbiAgICAgIHZhciB2YWx1ZSA9IHRoaXMuYXJnMS5mKG9iaik7XG5cbiAgICAgIHJldHVybiAhIChcbiAgICAgICAgdmFsdWUgPT09IHVuZGVmaW5lZCB8fFxuICAgICAgICB2YWx1ZSA9PT0gbnVsbCAgICAgIHx8XG4gICAgICAgIHZhbHVlID09PSAnJyAgICAgICAgfHxcbiAgICAgICAgKEFycmF5LmlzQXJyYXkodmFsdWUpICYmIHZhbHVlLmxlbmd0aCA9PT0gMCkgKTtcbiAgICB9XG4gIF1cbn0pO1xuXG5cbmZvYW0uQ0xBU1Moe1xuICBwYWNrYWdlOiAnZm9hbS5tbGFuZy5wcmVkaWNhdGUnLFxuICBuYW1lOiAnTm90JyxcbiAgc3dpZnROYW1lOiAnTm90UHJlZCcsXG4gIGV4dGVuZHM6ICdmb2FtLm1sYW5nLnByZWRpY2F0ZS5BYnN0cmFjdFByZWRpY2F0ZScsXG4gIGltcGxlbWVudHM6IFsgJ2ZvYW0uY29yZS5TZXJpYWxpemFibGUnIF0sXG5cbiAgZG9jdW1lbnRhdGlvbjogJ1VuYXJ5IFByZWRpY2F0ZSB3aGljaCBuZWdhdGVzIHRoZSB2YWx1ZSBvZiBpdHMgYXJndW1lbnQuJyxcblxuICBwcm9wZXJ0aWVzOiBbXG4gICAge1xuICAgICAgY2xhc3M6ICdmb2FtLm1sYW5nLnByZWRpY2F0ZS5QcmVkaWNhdGVQcm9wZXJ0eScsXG4gICAgICBuYW1lOiAnYXJnMSdcbiAgICB9XG4gIF0sXG5cbiAgbWV0aG9kczogW1xuICAgIGZ1bmN0aW9uIGYob2JqKSB7IHJldHVybiAhIHRoaXMuYXJnMS5mKG9iaik7IH0sXG5cbiAgICBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICAgIHJldHVybiBmb2FtLlN0cmluZy5jb25zdGFudGl6ZSh0aGlzLmNsc18ubmFtZSkgK1xuICAgICAgICAgICcoJyArIHRoaXMuYXJnMS50b1N0cmluZygpICsgJyknO1xuICAgIH0sXG5cbiAgICAvKlxuICAgICAgVE9ETzogdGhpcyBpc24ndCBwb3J0ZWQgdG8gRk9BTTIgeWV0LlxuICAgIGZ1bmN0aW9uIHBhcnRpYWxFdmFsKCkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB2YXIgbmV3QXJnID0gdGhpcy5hcmcxLnBhcnRpYWxFdmFsKCk7XG5cbiAgICAgIGlmICggbmV3QXJnID09PSBUUlVFICkgcmV0dXJuIEZBTFNFO1xuICAgICAgaWYgKCBuZXdBcmcgPT09IEZBTFNFICkgcmV0dXJuIFRSVUU7XG4gICAgICBpZiAoIE5vdEV4cHIuaXNJbnN0YW5jZShuZXdBcmcpICkgcmV0dXJuIG5ld0FyZy5hcmcxO1xuICAgICAgaWYgKCBFcUV4cHIuaXNJbnN0YW5jZShuZXdBcmcpICApIHJldHVybiBOZXFFeHByLmNyZWF0ZShuZXdBcmcpO1xuICAgICAgaWYgKCBOZXFFeHByLmlzSW5zdGFuY2UobmV3QXJnKSApIHJldHVybiBFcUV4cHIuY3JlYXRlKG5ld0FyZyk7XG4gICAgICBpZiAoIEx0RXhwci5pc0luc3RhbmNlKG5ld0FyZykgICkgcmV0dXJuIEd0ZUV4cHIuY3JlYXRlKG5ld0FyZyk7XG4gICAgICBpZiAoIEd0RXhwci5pc0luc3RhbmNlKG5ld0FyZykgICkgcmV0dXJuIEx0ZUV4cHIuY3JlYXRlKG5ld0FyZyk7XG4gICAgICBpZiAoIEx0ZUV4cHIuaXNJbnN0YW5jZShuZXdBcmcpICkgcmV0dXJuIEd0RXhwci5jcmVhdGUobmV3QXJnKTtcbiAgICAgIGlmICggR3RlRXhwci5pc0luc3RhbmNlKG5ld0FyZykgKSByZXR1cm4gTHRFeHByLmNyZWF0ZShuZXdBcmcpO1xuXG4gICAgICByZXR1cm4gdGhpcy5hcmcxID09PSBuZXdBcmcgPyB0aGlzIDogTk9UKG5ld0FyZyk7XG4gICAgfSovXG4gIF1cbn0pO1xuXG5cbmZvYW0uQ0xBU1Moe1xuICBwYWNrYWdlOiAnZm9hbS5tbGFuZy5wcmVkaWNhdGUnLFxuICBuYW1lOiAnS2V5d29yZCcsXG4gIGV4dGVuZHM6ICdmb2FtLm1sYW5nLnByZWRpY2F0ZS5VbmFyeScsXG4gIGltcGxlbWVudHM6IFsgJ2ZvYW0uY29yZS5TZXJpYWxpemFibGUnIF0sXG5cbiAgZG9jdW1lbnRhdGlvbjogJ1VuYXJ5IFByZWRpY2F0ZSBmb3IgZ2VuZXJpYyBrZXl3b3JkIHNlYXJjaCAoc2VhcmNoaW5nIGFsbCBTdHJpbmcgcHJvcGVydGllcyBmb3IgYXJndW1lbnQgc3Vic3RyaW5nKS4nLFxuXG4gIHJlcXVpcmVzOiBbXG4gICAge1xuICAgICAgbmFtZTogJ1N0cmluZycsXG4gICAgICBwYXRoOiAnZm9hbS5jb3JlLlN0cmluZycsXG4gICAgICBmbGFnczogWydqcyddLFxuICAgIH0sXG4gIF0sXG5cbiAgbWV0aG9kczogW1xuICAgIGZ1bmN0aW9uIGYob2JqKSB7XG4gICAgICB2YXIgYXJnID0gdGhpcy5hcmcxLmYob2JqKTtcbiAgICAgIGlmICggISBhcmcgfHwgdHlwZW9mIGFyZyAhPT0gJ3N0cmluZycgKSByZXR1cm4gZmFsc2U7XG5cbiAgICAgIGFyZyA9IGFyZy50b0xvd2VyQ2FzZSgpO1xuXG4gICAgICB2YXIgcHJvcHMgPSBvYmouY2xzXy5nZXRBeGlvbXNCeUNsYXNzKHRoaXMuU3RyaW5nKTtcbiAgICAgIGZvciAoIHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrICkge1xuICAgICAgICB2YXIgcyA9IHByb3BzW2ldLmYob2JqKTtcbiAgICAgICAgaWYgKCAhIHMgfHwgdHlwZW9mIHMgIT09ICdzdHJpbmcnICkgY29udGludWU7XG4gICAgICAgIGlmICggcy50b0xvd2VyQ2FzZSgpLmluZGV4T2YoYXJnKSA+PSAwICkgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIF1cbn0pO1xuXG5cbi8qKiBNYXAgc2luayB0cmFuc2Zvcm1zIGVhY2ggcHV0IHdpdGggYSBnaXZlbiBtYXBwaW5nIGV4cHJlc3Npb24uICovXG5mb2FtLkNMQVNTKHtcbiAgcGFja2FnZTogJ2ZvYW0ubWxhbmcuc2luaycsXG4gIG5hbWU6ICdNYXAnLFxuICBleHRlbmRzOiAnZm9hbS5kYW8uUHJveHlTaW5rJyxcbiAgYXhpb21zOiBbXG4gICAge1xuICAgICAgLy8gVE9ETzogUmVtb3ZlIHRoaXMgd2hlbiBNQVAgd29ya3MgcHJvcGVybHkgb24gamF2YS4gIGdpdGh1YiBpc3N1ZSAjMTAyMFxuICAgICAgY2xhc3M6ICdmb2FtLmJveC5SZW1vdGUnLFxuICAgICAgY2xpZW50Q2xhc3M6ICdmb2FtLmRhby5DbGllbnRTaW5rJ1xuICAgIH1cbiAgXSxcblxuICBkb2N1bWVudGF0aW9uOiAnU2luayBEZWNvcmF0b3Igd2hpY2ggYXBwbGllcyBhIG1hcCBmdW5jdGlvbiB0byBwdXQoKSB2YWx1ZXMgYmVmb3JlIHBhc3NpbmcgdG8gZGVsZWdhdGUuJyxcblxuICBwcm9wZXJ0aWVzOiBbXG4gICAge1xuICAgICAgY2xhc3M6ICdmb2FtLm1sYW5nLkV4cHJQcm9wZXJ0eScsXG4gICAgICBuYW1lOiAnYXJnMSdcbiAgICB9XG4gIF0sXG5cbiAgbWV0aG9kczogW1xuICAgIGZ1bmN0aW9uIGYobykgeyByZXR1cm4gdGhpcy5hcmcxLmYobyk7IH0sXG5cbiAgICBmdW5jdGlvbiBwdXQobywgc3ViKSB7IHRoaXMuZGVsZWdhdGUucHV0KHRoaXMuZihvKSwgc3ViKTsgfSxcblxuICAgIGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgICAgcmV0dXJuICdNQVAoJyArIHRoaXMuYXJnMS50b1N0cmluZygpICsgJyknO1xuICAgIH1cbiAgXVxufSk7XG5cblxuZm9hbS5DTEFTUyh7XG4gIHBhY2thZ2U6ICdmb2FtLm1sYW5nLmV4cHInLFxuICBuYW1lOiAnTXVsJyxcblxuICBleHRlbmRzOiAnZm9hbS5tbGFuZy5wcmVkaWNhdGUuQmluYXJ5JyxcblxuICBpbXBsZW1lbnRzOiBbXG4gICAgJ2ZvYW0uY29yZS5TZXJpYWxpemFibGUnXG4gIF0sXG5cbiAgZG9jdW1lbnRhdGlvbjogJ011bHRpcGxpY2F0aW9uIEJpbmFyeSBFeHByZXNzaW9uLicsXG5cbiAgbWV0aG9kczogW1xuICAgIGZ1bmN0aW9uIGYobykgeyByZXR1cm4gdGhpcy5hcmcxLmYobykgKiB0aGlzLmFyZzIuZihvKTsgfVxuICBdXG59KTtcblxuXG5mb2FtLkNMQVNTKHtcbiAgcGFja2FnZTogJ2ZvYW0ubWxhbmcuc2luaycsXG4gIG5hbWU6ICdHcm91cEJ5JyxcbiAgZXh0ZW5kczogJ2ZvYW0uZGFvLkFic3RyYWN0U2luaycsXG4gIGltcGxlbWVudHM6IFsgJ2ZvYW0uY29yZS5TZXJpYWxpemFibGUnIF0sXG5cbiAgZG9jdW1lbnRhdGlvbjogJ1Npbmsgd2hpY2ggYmVoYXZlcyBsaWtlIHRoZSBTUUwgZ3JvdXAtYnkgY29tbWFuZC4nLFxuXG4gIC8vIFRPRE86IGl0IG1ha2VzIG5vIHNlbnNlIHRvIG5hbWUgdGhlIGFyZ3VtZW50cyBhcmcxIGFuZCBhcmcyXG4gIC8vIGJlY2F1c2UgdGhpcyBpc24ndCBhbiBleHByZXNzaW9uLCBzbyB0aGV5IHNob3VsZCBiZSBtb3JlIG1lYW5pbmdmdWxcbiAgcHJvcGVydGllczogW1xuICAgIHtcbiAgICAgIGNsYXNzOiAnZm9hbS5tbGFuZy5FeHByUHJvcGVydHknLFxuICAgICAgbmFtZTogJ2FyZzEnXG4gICAgfSxcbiAgICB7XG4gICAgICBjbGFzczogJ2ZvYW0ubWxhbmcuU2lua1Byb3BlcnR5JyxcbiAgICAgIG5hbWU6ICdhcmcyJ1xuICAgIH0sXG4gICAge1xuICAgICAgY2xhc3M6ICdNYXAnLFxuICAgICAgbmFtZTogJ2dyb3VwcycsXG4gICAgICBmYWN0b3J5OiBmdW5jdGlvbigpIHsgcmV0dXJuIHt9OyB9LFxuICAgICAgamF2YUZhY3Rvcnk6ICdyZXR1cm4gbmV3IGphdmEudXRpbC5IYXNoTWFwPE9iamVjdCwgZm9hbS5kYW8uU2luaz4oKTsnXG4gICAgfSxcbiAgICB7XG4gICAgICBjbGFzczogJ0xpc3QnLFxuICAgICAgbmFtZTogJ2dyb3VwS2V5cycsXG4gICAgICBqYXZhRmFjdG9yeTogJ3JldHVybiBuZXcgamF2YS51dGlsLkFycmF5TGlzdCgpOycsXG4gICAgICBmYWN0b3J5OiBmdW5jdGlvbigpIHsgcmV0dXJuIFtdOyB9XG4gICAgfSxcbiAgICB7XG4gICAgICBjbGFzczogJ0Jvb2xlYW4nLFxuICAgICAgbmFtZTogJ3Byb2Nlc3NBcnJheVZhbHVlc0luZGl2aWR1YWxseScsXG4gICAgICBkb2N1bWVudGF0aW9uOiAnSWYgdHJ1ZSwgZWFjaCB2YWx1ZSBvZiBhbiBhcnJheSB3aWxsIGJlIGVudGVyZWQgaW50byBhIHNlcGFyYXRlIGdyb3VwLicsXG4gICAgICBmYWN0b3J5OiBmdW5jdGlvbigpIHtcbiAgICAgICAgLy8gVE9ETzogaXQgd291bGQgYmUgZ29vZCBpZiBpdCBjb3VsZCBhbHNvIGRldGVjdCBSZWxhdGlvbnNoaXBKdW5jdGlvbi5zb3VyY2VJZC90YXJnZXRJZFxuICAgICAgICByZXR1cm4gISBmb2FtLmNvcmUuTXVsdGlQYXJ0SUQuaXNJbnN0YW5jZSh0aGlzLmFyZzEpO1xuICAgICAgfVxuICAgIH1cbiAgXSxcblxuICBtZXRob2RzOiBbXG4gICAgZnVuY3Rpb24gc29ydGVkS2V5cyhvcHRfY29tcGFyYXRvcikge1xuICAgICAgdGhpcy5ncm91cEtleXMuc29ydChvcHRfY29tcGFyYXRvciB8fCB0aGlzLmFyZzEuY29tcGFyZVByb3BlcnR5VmFsdWVzKTtcbiAgICAgIHJldHVybiB0aGlzLmdyb3VwS2V5cztcbiAgICB9LFxuXG4gICAgZnVuY3Rpb24gcHV0SW5Hcm91cF8oc3ViLCBrZXksIG9iaikge1xuICAgICAgdmFyIGdyb3VwID0gdGhpcy5ncm91cHMuaGFzT3duUHJvcGVydHkoa2V5KSAmJiB0aGlzLmdyb3Vwc1trZXldO1xuICAgICAgaWYgKCAhIGdyb3VwICkge1xuICAgICAgICBncm91cCA9IHRoaXMuYXJnMi5jbG9uZSgpO1xuICAgICAgICB0aGlzLmdyb3Vwc1trZXldID0gZ3JvdXA7XG4gICAgICAgIHRoaXMuZ3JvdXBLZXlzLnB1c2goa2V5KTtcbiAgICAgIH1cbiAgICAgIGdyb3VwLnB1dChvYmosIHN1Yik7XG4gICAgfSxcblxuICAgIGZ1bmN0aW9uIHB1dChvYmosIHN1Yikge1xuICAgICAgdmFyIGtleSA9IHRoaXMuYXJnMS5mKG9iaik7XG4gICAgICBpZiAoIHRoaXMucHJvY2Vzc0FycmF5VmFsdWVzSW5kaXZpZHVhbGx5ICYmIEFycmF5LmlzQXJyYXkoa2V5KSApIHtcbiAgICAgICAgaWYgKCBrZXkubGVuZ3RoICkge1xuICAgICAgICAgIGZvciAoIHZhciBpID0gMDsgaSA8IGtleS5sZW5ndGg7IGkrKyApIHtcbiAgICAgICAgICAgIHRoaXMucHV0SW5Hcm91cF8oc3ViLCBrZXlbaV0sIG9iaik7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIFBlcmhhcHMgdGhpcyBzaG91bGQgYmUgYSBrZXkgdmFsdWUgb2YgbnVsbCwgbm90ICcnLCBzaW5jZSAnJyBtaWdodFxuICAgICAgICAgIC8vIGFjdHVhbGx5IGJlIGEgdmFsaWQga2V5LlxuICAgICAgICAgIHRoaXMucHV0SW5Hcm91cF8oc3ViLCAnJywgb2JqKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5wdXRJbkdyb3VwXyhzdWIsIGtleSwgb2JqKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgZnVuY3Rpb24gZW9mKCkgeyB9LFxuXG4gICAgZnVuY3Rpb24gY2xvbmUoKSB7XG4gICAgICAvLyBEb24ndCB1c2UgdGhlIGRlZmF1bHQgY2xvbmUgYmVjYXVzZSB3ZSBkb24ndCB3YW50IHRvIGNvcHkgJ2dyb3VwcycuXG4gICAgICByZXR1cm4gdGhpcy5jbHNfLmNyZWF0ZSh7IGFyZzE6IHRoaXMuYXJnMSwgYXJnMjogdGhpcy5hcmcyIH0pO1xuICAgIH0sXG5cbiAgICBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICAgIHJldHVybiB0aGlzLmdyb3Vwcy50b1N0cmluZygpO1xuICAgIH1cbiAgXVxufSk7XG5cblxuZm9hbS5DTEFTUyh7XG4gIHBhY2thZ2U6ICdmb2FtLm1sYW5nLnNpbmsnLFxuICBuYW1lOiAnVW5pcXVlJyxcbiAgZXh0ZW5kczogJ2ZvYW0uZGFvLlByb3h5U2luaycsXG4gIGltcGxlbWVudHM6IFsgJ2ZvYW0uY29yZS5TZXJpYWxpemFibGUnIF0sXG5cbiAgZG9jdW1lbnRhdGlvbjogJ1NpbmsgZGVjb3JhdG9yIHdoaWNoIG9ubHkgcHV0KClcXCdzIGEgc2luZ2xlIG9iaiBmb3IgZWFjaCB1bmlxdWUgZXhwcmVzc2lvbiB2YWx1ZS4nLFxuXG4gIHByb3BlcnRpZXM6IFtcbiAgICB7XG4gICAgICBjbGFzczogJ2ZvYW0ubWxhbmcuRXhwclByb3BlcnR5JyxcbiAgICAgIG5hbWU6ICdleHByJ1xuICAgIH0sXG4gICAge1xuICAgICAgbmFtZTogJ3ZhbHVlcycsXG4gICAgICBmYWN0b3J5OiBmdW5jdGlvbigpIHsgcmV0dXJuIHt9OyB9XG4gICAgfVxuICBdLFxuXG4gIG1ldGhvZHM6IFtcbiAgICBmdW5jdGlvbiBwdXRJbkdyb3VwXyhrZXksIG9iaikge1xuICAgICAgdmFyIGdyb3VwID0gdGhpcy5ncm91cHMuaGFzT3duUHJvcGVydHkoa2V5KSAmJiB0aGlzLmdyb3Vwc1trZXldO1xuICAgICAgaWYgKCAhIGdyb3VwICkge1xuICAgICAgICBncm91cCA9IHRoaXMuYXJnMi5jbG9uZSgpO1xuICAgICAgICB0aGlzLmdyb3Vwc1trZXldID0gZ3JvdXA7XG4gICAgICAgIHRoaXMuZ3JvdXBLZXlzLnB1c2goa2V5KTtcbiAgICAgIH1cbiAgICAgIGdyb3VwLnB1dChvYmopO1xuICAgIH0sXG5cbiAgICBmdW5jdGlvbiBwdXQob2JqLCBzdWIpIHtcbiAgICAgIHZhciB2YWx1ZSA9IHRoaXMuZXhwci5mKG9iaik7XG4gICAgICBpZiAoIEFycmF5LmlzQXJyYXkodmFsdWUpICkge1xuICAgICAgICB0aHJvdyAnVW5pcXVlIGRvZXNuXFwndCBBcnJheSB2YWx1ZXMuJztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICggISB0aGlzLnZhbHVlcy5oYXNPd25Qcm9wZXJ0eSh2YWx1ZSkgKSB7XG4gICAgICAgICAgdGhpcy52YWx1ZXNbdmFsdWVdID0gb2JqO1xuICAgICAgICAgIHRoaXMuZGVsZWdhdGUucHV0KG9iaik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgZnVuY3Rpb24gZW9mKCkgeyB9LFxuXG4gICAgZnVuY3Rpb24gY2xvbmUoKSB7XG4gICAgICAvLyBEb24ndCB1c2UgdGhlIGRlZmF1bHQgY2xvbmUgYmVjYXVzZSB3ZSBkb24ndCB3YW50IHRvIGNvcHkgJ3VuaXF1ZVZhbHVlcycuXG4gICAgICByZXR1cm4gdGhpcy5jbHNfLmNyZWF0ZSh7IGV4cHI6IHRoaXMuZXhwciwgZGVsZWdhdGU6IHRoaXMuZGVsZWdhdGUgfSk7XG4gICAgfSxcblxuICAgIGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgICAgcmV0dXJuIHRoaXMudW5pcXVlVmFsdWVzLnRvU3RyaW5nKCk7XG4gICAgfVxuICBdXG59KTtcblxuXG5mb2FtLkNMQVNTKHtcbiAgcGFja2FnZTogJ2ZvYW0ubWxhbmcuc2luaycsXG4gIG5hbWU6ICdFeHBsYWluJyxcbiAgZXh0ZW5kczogJ2ZvYW0uZGFvLlByb3h5U2luaycsXG4gIGltcGxlbWVudHM6IFsgJ2ZvYW0uY29yZS5TZXJpYWxpemFibGUnIF0sXG5cbiAgZG9jdW1lbnRhdGlvbjogJ1BzZXVkby1TaW5rIHdoaWNoIG91dHB1dHMgYSBodW1hbi1yZWFkYWJsZSBkZXNjcmlwdGlvbiBvZiBhbiBNREFPXFwncyBleGVjdXRpb24gcGxhbiBmb3IgZXZhbHVhdGluZyBpdC4nLFxuXG4gIHByb3BlcnRpZXM6IFtcbiAgICB7XG4gICAgICBjbGFzczogJ1N0cmluZycsXG4gICAgICBuYW1lOiAgJ3BsYW4nLFxuICAgICAgaGVscDogICdFeGVjdXRpb24gUGxhbidcbiAgICB9XG4gIF0sXG5cbiAgbWV0aG9kczogW1xuICAgIGZ1bmN0aW9uIHRvU3RyaW5nKCkgeyByZXR1cm4gdGhpcy5wbGFuOyB9LFxuICBdXG59KTtcblxuXG5mb2FtLkNMQVNTKHtcbiAgcmVmaW5lczogJ2ZvYW0uY29yZS5Qcm9wZXJ0eScsXG5cbiAgaW1wbGVtZW50czogWyAnZm9hbS5tbGFuZy5vcmRlci5Db21wYXJhdG9yJyBdLFxuXG4gIG1ldGhvZHM6IFtcbiAgICB7XG4gICAgICBuYW1lOiAnb3JkZXJUYWlsJyxcbiAgICAgIGNvZGU6IGZ1bmN0aW9uKCkgeyByZXR1cm47IH1cbiAgICB9LFxuICAgIHtcbiAgICAgIG5hbWU6ICdvcmRlclByaW1hcnlQcm9wZXJ0eScsXG4gICAgICBjb2RlOiBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXM7IH1cbiAgICB9LFxuICAgIHtcbiAgICAgIG5hbWU6ICdvcmRlckRpcmVjdGlvbicsXG4gICAgICBjb2RlOiBmdW5jdGlvbigpIHsgcmV0dXJuIDE7IH1cbiAgICB9XG4gIF1cbn0pO1xuXG5cbmZvYW0uQ0xBU1Moe1xuICBwYWNrYWdlOiAnZm9hbS5tbGFuZy5vcmRlcicsXG4gIG5hbWU6ICdEZXNjJyxcblxuICBpbXBsZW1lbnRzOiBbXG4gICAgJ2ZvYW0ubWxhbmcub3JkZXIuQ29tcGFyYXRvcicsXG4gICAgJ2ZvYW0uY29yZS5TZXJpYWxpemFibGUnXG4gIF0sXG5cbiAgZG9jdW1lbnRhdGlvbjogJ0NvbXBhcmF0b3IgRGVjb3JhdG9yIHdoaWNoIHJldmVyc2VzIGRpcmVjdGlvbiBvZiBjb21wYXJpc29uLiBTaG9ydCBmb3IgXCJkZXNjZW5kaW5nXCIuJyxcblxuICBwcm9wZXJ0aWVzOiBbXG4gICAge1xuICAgICAgY2xhc3M6ICdGT2JqZWN0UHJvcGVydHknLFxuICAgICAgbmFtZTogJ2FyZzEnLFxuICAgICAgb2Y6ICdmb2FtLm1sYW5nLm9yZGVyLkNvbXBhcmF0b3InLFxuICAgICAgYWRhcHQ6IGZ1bmN0aW9uKF8sIGMpIHsgcmV0dXJuIGZvYW0uY29tcGFyZS50b0NvbXBhcmUoYyk7IH1cbiAgICB9XG4gIF0sXG5cbiAgbWV0aG9kczogW1xuICAgIGZ1bmN0aW9uIGNvbXBhcmUobzEsIG8yKSB7XG4gICAgICByZXR1cm4gLTEgKiB0aGlzLmFyZzEuY29tcGFyZShvMSwgbzIpO1xuICAgIH0sXG4gICAgZnVuY3Rpb24gdG9TdHJpbmcoKSB7IHJldHVybiAnREVTQygnICsgdGhpcy5hcmcxLnRvU3RyaW5nKCkgKyAnKSc7IH0sXG4gICAgZnVuY3Rpb24gdG9JbmRleCh0YWlsKSB7IHJldHVybiB0aGlzLmFyZzEgJiYgdGhpcy5hcmcxLnRvSW5kZXgodGFpbCk7IH0sXG4gICAgZnVuY3Rpb24gb3JkZXJUYWlsKCkgeyByZXR1cm47IH0sXG4gICAgZnVuY3Rpb24gb3JkZXJQcmltYXJ5UHJvcGVydHkoKSB7IHJldHVybiB0aGlzLmFyZzE7IH0sXG4gICAgZnVuY3Rpb24gb3JkZXJEaXJlY3Rpb24oKSB7IHJldHVybiAtMSAqIHRoaXMuYXJnMS5vcmRlckRpcmVjdGlvbigpOyB9XG4gIF1cbn0pO1xuXG5cbmZvYW0uQ0xBU1Moe1xuICBwYWNrYWdlOiAnZm9hbS5tbGFuZy5vcmRlcicsXG4gIG5hbWU6ICdUaGVuQnknLFxuXG4gIGltcGxlbWVudHM6IFtcbiAgICAnZm9hbS5tbGFuZy5vcmRlci5Db21wYXJhdG9yJyxcbiAgICAnZm9hbS5jb3JlLlNlcmlhbGl6YWJsZSdcbiAgXSxcblxuICBkb2N1bWVudGF0aW9uOiAnQmluYXJ5IENvbXBhcmF0b3IsIHdoaWNoIHNvcnRzIGZvciBmaXJzdCBDb21wYXJhdG9yLCB0aGVuIHNlY29uZC4nLFxuXG4gIHByb3BlcnRpZXM6IFtcbiAgICB7XG4gICAgICBjbGFzczogJ0ZPYmplY3RQcm9wZXJ0eScsXG4gICAgICBvZjogJ2ZvYW0ubWxhbmcub3JkZXIuQ29tcGFyYXRvcicsXG4gICAgICBhZGFwdDogZnVuY3Rpb24oXywgYSkge1xuICAgICAgICAvLyBUT0RPKGFkYW12eSk6IFdlIHNob3VsZCBmaXggRk9iamVjdFByb3BlcnR5J3MgZGVmYXVsdCBhZGFwdCB3aGVuIHRoZVxuICAgICAgICAvLyBvZiBwYXJhbWV0ZXIgaXMgYW4gaW50ZXJmYWNlIHJhdGhlciB0aGFuIGEgY2xhc3MuXG4gICAgICAgIHJldHVybiBhO1xuICAgICAgfSxcbiAgICAgIG5hbWU6ICdhcmcxJ1xuICAgIH0sXG4gICAge1xuICAgICAgY2xhc3M6ICdGT2JqZWN0UHJvcGVydHknLFxuICAgICAgb2Y6ICdmb2FtLm1sYW5nLm9yZGVyLkNvbXBhcmF0b3InLFxuICAgICAgYWRhcHQ6IGZ1bmN0aW9uKF8sIGEpIHtcbiAgICAgICAgLy8gVE9ETyhhZGFtdnkpOiBXZSBzaG91bGQgZml4IEZPYmplY3RQcm9wZXJ0eSdzIGRlZmF1bHQgYWRhcHQgd2hlbiB0aGVcbiAgICAgICAgLy8gb2YgcGFyYW1ldGVyIGlzIGFuIGludGVyZmFjZSByYXRoZXIgdGhhbiBhIGNsYXNzLlxuICAgICAgICByZXR1cm4gYTtcbiAgICAgIH0sXG4gICAgICBuYW1lOiAnYXJnMidcbiAgICB9LFxuICAgIHtcbiAgICAgIG5hbWU6ICdjb21wYXJlJyxcbiAgICAgIHN3aWZ0U3VwcG9ydDogZmFsc2UsXG4gICAgICB0cmFuc2llbnQ6IHRydWUsXG4gICAgICBkb2N1bWVudGF0aW9uOiAnSXMgYSBwcm9wZXJ0eSBzbyB0aGF0IGl0IGNhbiBiZSBib3VuZCB0byBcInRoaXNcIiBzbyB0aGF0IGl0IHdvcmtzIHdpdGggQXJyYXkuc29ydCgpLicsXG4gICAgICBmYWN0b3J5OiBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMuY29tcGFyZV8uYmluZCh0aGlzKTsgfVxuICAgIH1cbiAgXSxcblxuICBtZXRob2RzOiBbXG4gICAgZnVuY3Rpb24gY29tcGFyZV8obzEsIG8yKSB7XG4gICAgICAvLyBhbiBlcXVhbHMgb2YgYXJnMS5jb21wYXJlIGlzIGZhbHN5LCB3aGljaCB3aWxsIHRoZW4gaGl0IGFyZzJcbiAgICAgIHJldHVybiB0aGlzLmFyZzEuY29tcGFyZShvMSwgbzIpIHx8IHRoaXMuYXJnMi5jb21wYXJlKG8xLCBvMik7XG4gICAgfSxcblxuICAgIGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgICAgcmV0dXJuICdUSEVOX0JZKCcgKyB0aGlzLmFyZzEudG9TdHJpbmcoKSArICcsICcgK1xuICAgICAgICB0aGlzLmFyZzIudG9TdHJpbmcoKSArICcpJztcbiAgICB9LFxuXG4gICAgZnVuY3Rpb24gdG9JbmRleCh0YWlsKSB7XG4gICAgICByZXR1cm4gdGhpcy5hcmcxICYmIHRoaXMuYXJnMiAmJiB0aGlzLmFyZzEudG9JbmRleCh0aGlzLmFyZzIudG9JbmRleCh0YWlsKSk7XG4gICAgfSxcblxuICAgIGZ1bmN0aW9uIG9yZGVyVGFpbCgpIHsgcmV0dXJuIHRoaXMuYXJnMjsgfSxcblxuICAgIGZ1bmN0aW9uIG9yZGVyUHJpbWFyeVByb3BlcnR5KCkgeyByZXR1cm4gdGhpcy5hcmcxLm9yZGVyUHJpbWFyeVByb3BlcnR5KCk7IH0sXG5cbiAgICBmdW5jdGlvbiBvcmRlckRpcmVjdGlvbigpIHsgcmV0dXJuIHRoaXMuYXJnMS5vcmRlckRpcmVjdGlvbigpOyB9XG4gIF1cbn0pO1xuXG5cbmZvYW0uQ0xBU1Moe1xuICBwYWNrYWdlOiAnZm9hbS5tbGFuZy5vcmRlcicsXG4gIG5hbWU6ICdDdXN0b21Db21wYXJhdG9yJyxcbiAgaW1wbGVtZW50czogWyAnZm9hbS5tbGFuZy5vcmRlci5Db21wYXJhdG9yJyBdLFxuXG4gIC8vIFRPRE86IHJlbmFtZSBGdW5jdGlvbkNvbXBhcmF0b3JcblxuICBkb2N1bWVudGF0aW9uOiAnQSBmdW5jdGlvbiB0byBDb21wYXJhdG9yIGFkYXB0ZXIuJyxcblxuICBwcm9wZXJ0aWVzOiBbXG4gICAge1xuICAgICAgY2xhc3M6ICdGdW5jdGlvbicsXG4gICAgICBuYW1lOiAnY29tcGFyZUZuJ1xuICAgIH1cbiAgXSxcblxuICBtZXRob2RzOiBbXG4gICAge1xuICAgICAgbmFtZTogJ2NvbXBhcmUnLFxuICAgICAgY29kZTogZnVuY3Rpb24obzEsIG8yKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbXBhcmVGbihvMSwgbzIpO1xuICAgICAgfVxuICAgIH0sXG4gICAge1xuICAgICAgbmFtZTogJ3RvU3RyaW5nJyxcbiAgICAgIGNvZGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gJ0NVU1RPTV9DT01QQVJFKCcgKyB0aGlzLmNvbXBhcmVGbi50b1N0cmluZygpICsgJyknO1xuICAgICAgfVxuICAgIH0sXG4gICAge1xuICAgICAgbmFtZTogJ29yZGVyVGFpbCcsXG4gICAgICBjb2RlOiBmdW5jdGlvbigpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfVxuICAgIH0sXG4gICAge1xuICAgICAgLyoqIFRPRE86IGFsbG93IHVzZXIgdG8gc2V0IHRoaXMgdG8gbWF0Y2ggdGhlIGdpdmVuIGZ1bmN0aW9uICovXG4gICAgICBuYW1lOiAnb3JkZXJQcmltYXJ5UHJvcGVydHknLFxuICAgICAgY29kZTogZnVuY3Rpb24oKSB7IHJldHVybiB1bmRlZmluZWQ7IH1cbiAgICB9LFxuICAgIHtcbiAgICAgIG5hbWU6ICdvcmRlckRpcmVjdGlvbicsXG4gICAgICBjb2RlOiBmdW5jdGlvbigpIHsgcmV0dXJuIDE7IH1cbiAgICB9XG4gIF1cbn0pO1xuXG5cbmZvYW0uTElCKHtcbiAgbmFtZTogJ2ZvYW0uY29tcGFyZScsXG5cbiAgbWV0aG9kczogW1xuICAgIGZ1bmN0aW9uIGRlc2MoYykge1xuICAgICAgcmV0dXJuIGZvYW0ubWxhbmcub3JkZXIuRGVzYy5jcmVhdGUoeyBhcmcxOiBjIH0pO1xuICAgIH0sXG5cbiAgICBmdW5jdGlvbiB0b0NvbXBhcmUoYykge1xuICAgICAgcmV0dXJuIGZvYW0uQXJyYXkuaXNJbnN0YW5jZShjKSA/IGZvYW0uY29tcGFyZS5jb21wb3VuZChjKSA6XG4gICAgICAgIGZvYW0uRnVuY3Rpb24uaXNJbnN0YW5jZShjKSAgID8gZm9hbS5tbGFuZy5vcmRlci5DdXN0b21Db21wYXJhdG9yLmNyZWF0ZSh7IGNvbXBhcmVGbjogYyB9KSA6XG4gICAgICAgIGMgO1xuICAgIH0sXG5cbiAgICBmdW5jdGlvbiBjb21wb3VuZChhcmdzKSB7XG4gICAgICAvKiBDcmVhdGUgYSBjb21wb3VuZCBjb21wYXJhdG9yIGZyb20gYW4gYXJyYXkgb2YgY29tcGFyYXRvcnMuICovXG4gICAgICB2YXIgY3MgPSBhcmdzLm1hcChmb2FtLmNvbXBhcmUudG9Db21wYXJlKTtcblxuICAgICAgaWYgKCBjcy5sZW5ndGggPT09IDAgKSByZXR1cm47XG4gICAgICBpZiAoIGNzLmxlbmd0aCA9PT0gMSApIHJldHVybiBjc1swXTtcblxuICAgICAgdmFyIFRoZW5CeSA9IGZvYW0ubWxhbmcub3JkZXIuVGhlbkJ5O1xuICAgICAgdmFyIHJldCwgdGFpbDtcblxuICAgICAgcmV0ID0gdGFpbCA9IFRoZW5CeS5jcmVhdGUoe2FyZzE6IGNzWzBdLCBhcmcyOiBjc1sxXX0pO1xuXG4gICAgICBmb3IgKCB2YXIgaSA9IDIgOyBpIDwgY3MubGVuZ3RoIDsgaSsrICkge1xuICAgICAgICB0YWlsID0gdGFpbC5hcmcyID0gVGhlbkJ5LmNyZWF0ZSh7YXJnMTogdGFpbC5hcmcyLCBhcmcyOiBjc1tpXX0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmV0O1xuICAgIH1cbiAgXVxufSk7XG5cblxuZm9hbS5DTEFTUyh7XG4gIHBhY2thZ2U6ICdmb2FtLm1sYW5nLnNpbmsnLFxuICBuYW1lOiAnQWJzdHJhY3RVbmFyeVNpbmsnLFxuICBleHRlbmRzOiAnZm9hbS5kYW8uQWJzdHJhY3RTaW5rJyxcblxuICBpbXBsZW1lbnRzOiBbXG4gICAgJ2ZvYW0uY29yZS5TZXJpYWxpemFibGUnXG4gIF0sXG5cbiAgZG9jdW1lbnRhdGlvbjogJ0FuIEFic3RyYWN0IFNpbmsgYmFzZWNsYXNzIHdoaWNoIHRha2VzIG9ubHkgb25lIGFyZ3VtZW50LicsXG5cbiAgcHJvcGVydGllczogW1xuICAgIHtcbiAgICAgIGNsYXNzOiAnZm9hbS5tbGFuZy5FeHByUHJvcGVydHknLFxuICAgICAgbmFtZTogJ2FyZzEnXG4gICAgfVxuICBdLFxuXG4gIG1ldGhvZHM6IFtcbiAgICBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICAgIHJldHVybiBmb2FtLlN0cmluZy5jb25zdGFudGl6ZSh0aGlzLmNsc18ubmFtZSkgK1xuICAgICAgICAgICcoJyArIHRoaXMuYXJnMS50b1N0cmluZygpICsgJyknO1xuICAgIH1cbiAgXVxufSk7XG5cblxuZm9hbS5DTEFTUyh7XG4gIHBhY2thZ2U6ICdmb2FtLm1sYW5nLnNpbmsnLFxuICBuYW1lOiAnTWF4JyxcbiAgZXh0ZW5kczogJ2ZvYW0ubWxhbmcuc2luay5BYnN0cmFjdFVuYXJ5U2luaycsXG5cbiAgZG9jdW1lbnRhdGlvbjogJ0EgU2luayB3aGljaCByZW1lbWJlcnMgdGhlIG1heGltdW0gdmFsdWUgcHV0KCkuJyxcblxuICBwcm9wZXJ0aWVzOiBbXG4gICAge1xuICAgICAgY2xhc3M6ICdPYmplY3QnLFxuICAgICAgbmFtZTogJ3ZhbHVlJ1xuICAgIH1cbiAgXSxcblxuICBtZXRob2RzOiBbXG4gICAgZnVuY3Rpb24gcHV0KG9iaiwgc3ViKSB7XG4gICAgICBpZiAoICEgdGhpcy5oYXNPd25Qcm9wZXJ0eSgndmFsdWUnKSB8fCBmb2FtLnV0aWwuY29tcGFyZSh0aGlzLnZhbHVlLCB0aGlzLmFyZzEuZihvYmopKSA8IDAgKSB7XG4gICAgICAgIHRoaXMudmFsdWUgPSB0aGlzLmFyZzEuZihvYmopO1xuICAgICAgfVxuICAgIH1cbiAgXVxufSk7XG5cblxuZm9hbS5DTEFTUyh7XG4gIHBhY2thZ2U6ICdmb2FtLm1sYW5nLnNpbmsnLFxuICBuYW1lOiAnTWluJyxcbiAgZXh0ZW5kczogJ2ZvYW0ubWxhbmcuc2luay5BYnN0cmFjdFVuYXJ5U2luaycsXG5cbiAgZG9jdW1lbnRhdGlvbjogJ0EgU2luayB3aGljaCByZW1lbWJlcnMgdGhlIG1pbmltdW0gdmFsdWUgcHV0KCkuJyxcblxuICBwcm9wZXJ0aWVzOiBbXG4gICAge1xuICAgICAgY2xhc3M6ICdPYmplY3QnLFxuICAgICAgbmFtZTogJ3ZhbHVlJ1xuICAgIH1cbiAgXSxcblxuICBtZXRob2RzOiBbXG4gICAgZnVuY3Rpb24gcHV0KG9iaiwgcykge1xuICAgICAgaWYgKCAhIHRoaXMuaGFzT3duUHJvcGVydHkoJ3ZhbHVlJykgfHwgZm9hbS51dGlsLmNvbXBhcmUodGhpcy52YWx1ZSwgdGhpcy5hcmcxLmYob2JqKSApID4gMCkge1xuICAgICAgICB0aGlzLnZhbHVlID0gdGhpcy5hcmcxLmYob2JqKTtcbiAgICAgIH1cbiAgICB9XG4gIF1cbn0pO1xuXG5cbmZvYW0uQ0xBU1Moe1xuICBwYWNrYWdlOiAnZm9hbS5tbGFuZy5zaW5rJyxcbiAgbmFtZTogJ1N1bScsXG4gIGV4dGVuZHM6ICdmb2FtLm1sYW5nLnNpbmsuQWJzdHJhY3RVbmFyeVNpbmsnLFxuXG4gIGRvY3VtZW50YXRpb246ICdBIFNpbmsgd2hpY2ggc3VtcyBwdXQoKSB2YWx1ZXMuJyxcblxuICBwcm9wZXJ0aWVzOiBbXG4gICAge1xuICAgICAgY2xhc3M6ICdmb2FtLm1sYW5nLkV4cHJQcm9wZXJ0eScsXG4gICAgICBuYW1lOiAnYXJnMSdcbiAgICB9LFxuICAgIHtcbiAgICAgIGNsYXNzOiAnRG91YmxlJyxcbiAgICAgIG5hbWU6ICd2YWx1ZScsXG4gICAgICB2YWx1ZTogMFxuICAgIH1cbiAgXSxcblxuICBtZXRob2RzOiBbXG4gICAgZnVuY3Rpb24gcHV0KG9iaiwgc3ViKSB7IHRoaXMudmFsdWUgKz0gdGhpcy5hcmcxLmYob2JqKTsgfVxuICBdXG59KTtcblxuXG5mb2FtLkNMQVNTKHtcbiAgcGFja2FnZTogJ2ZvYW0ubWxhbmcuZXhwcicsXG4gIG5hbWU6ICdEb3QnLFxuICBleHRlbmRzOiAnZm9hbS5tbGFuZy5wcmVkaWNhdGUuQmluYXJ5JyxcbiAgaW1wbGVtZW50czogWyAnZm9hbS5jb3JlLlNlcmlhbGl6YWJsZScgXSxcblxuICBkb2N1bWVudGF0aW9uOiAnQSBCaW5hcnkgUHJlZGljYXRlIHdoaWNoIGFwcGxpZXMgYXJnMi5mKCkgdG8gYXJnMS5mKCkuJyxcblxuICBtZXRob2RzOiBbXG4gICAgZnVuY3Rpb24gZihvKSB7XG4gICAgICByZXR1cm4gdGhpcy5hcmcyLmYodGhpcy5hcmcxLmYobykpO1xuICAgIH0sXG5cbiAgICBmdW5jdGlvbiBjb21wYXJlKG8xLCBvMikge1xuICAgICAgcmV0dXJuIHRoaXMuY29tcGFyZVByb3BlcnR5VmFsdWVzKHRoaXMuZihvMSksIHRoaXMuZihvMikpO1xuICAgIH0sXG5cbiAgICBmdW5jdGlvbiBjb21wYXJlUHJvcGVydHlWYWx1ZXMobzEsIG8yKSB7XG4gICAgICAvKipcbiAgICAgICAgIENvbXBhcmUgcHJvcGVydHkgdmFsdWVzIHVzaW5nIGFyZzIncyBwcm9wZXJ0eSB2YWx1ZSBjb21wYXJhdG9yLlxuICAgICAgICAgVXNlZCBieSBHcm91cEJ5XG4gICAgICAqKi9cbiAgICAgIHJldHVybiB0aGlzLmFyZzIuY29tcGFyZVByb3BlcnR5VmFsdWVzKG8xLCBvMik7XG4gICAgfVxuICBdXG59KTtcblxuXG5mb2FtLkNMQVNTKHtcbiAgcGFja2FnZTogJ2ZvYW0ubWxhbmcnLFxuICBuYW1lOiAnRXhwcmVzc2lvbnMnLFxuXG4gIGRvY3VtZW50YXRpb246ICdDb252ZW5pZW5jZSBtaXgtaW4gZm9yIHJlcXVpcmluZyBhbGwgbWxhbmdzLicsXG5cbiAgcmVxdWlyZXM6IFtcbiAgICAnZm9hbS5tbGFuZy5Db25zdGFudCcsXG4gICAgJ2ZvYW0ubWxhbmcuZXhwci5Eb3QnLFxuICAgICdmb2FtLm1sYW5nLmV4cHIuTXVsJyxcbiAgICAnZm9hbS5tbGFuZy5vcmRlci5EZXNjJyxcbiAgICAnZm9hbS5tbGFuZy5vcmRlci5UaGVuQnknLFxuICAgICdmb2FtLm1sYW5nLnByZWRpY2F0ZS5BbmQnLFxuICAgICdmb2FtLm1sYW5nLnByZWRpY2F0ZS5Db250YWlucycsXG4gICAgJ2ZvYW0ubWxhbmcucHJlZGljYXRlLkNvbnRhaW5zSUMnLFxuICAgICdmb2FtLm1sYW5nLnByZWRpY2F0ZS5FcScsXG4gICAgJ2ZvYW0ubWxhbmcucHJlZGljYXRlLkZhbHNlJyxcbiAgICAnZm9hbS5tbGFuZy5wcmVkaWNhdGUuRnVuYycsXG4gICAgJ2ZvYW0ubWxhbmcucHJlZGljYXRlLkd0JyxcbiAgICAnZm9hbS5tbGFuZy5wcmVkaWNhdGUuR3RlJyxcbiAgICAnZm9hbS5tbGFuZy5wcmVkaWNhdGUuSGFzJyxcbiAgICAnZm9hbS5tbGFuZy5wcmVkaWNhdGUuSW4nLFxuICAgICdmb2FtLm1sYW5nLnByZWRpY2F0ZS5LZXl3b3JkJyxcbiAgICAnZm9hbS5tbGFuZy5wcmVkaWNhdGUuTHQnLFxuICAgICdmb2FtLm1sYW5nLnByZWRpY2F0ZS5MdGUnLFxuICAgICdmb2FtLm1sYW5nLnByZWRpY2F0ZS5OZXEnLFxuICAgICdmb2FtLm1sYW5nLnByZWRpY2F0ZS5Ob3QnLFxuICAgICdmb2FtLm1sYW5nLnByZWRpY2F0ZS5PcicsXG4gICAgJ2ZvYW0ubWxhbmcucHJlZGljYXRlLlN0YXJ0c1dpdGgnLFxuICAgICdmb2FtLm1sYW5nLnByZWRpY2F0ZS5TdGFydHNXaXRoSUMnLFxuICAgICdmb2FtLm1sYW5nLnByZWRpY2F0ZS5FbmRzV2l0aCcsXG4gICAgJ2ZvYW0ubWxhbmcucHJlZGljYXRlLlRydWUnLFxuICAgICdmb2FtLm1sYW5nLnNpbmsuQ291bnQnLFxuICAgICdmb2FtLm1sYW5nLnNpbmsuRXhwbGFpbicsXG4gICAgJ2ZvYW0ubWxhbmcuc2luay5Hcm91cEJ5JyxcbiAgICAnZm9hbS5tbGFuZy5zaW5rLk1hcCcsXG4gICAgJ2ZvYW0ubWxhbmcuc2luay5NYXgnLFxuICAgICdmb2FtLm1sYW5nLnNpbmsuTWluJyxcbiAgICAnZm9hbS5tbGFuZy5zaW5rLlN1bScsXG4gICAgJ2ZvYW0ubWxhbmcuc2luay5VbmlxdWUnXG4gIF0sXG5cbiAgY29uc3RhbnRzOiB7XG4gICAgRkFMU0U6IGZvYW0ubWxhbmcucHJlZGljYXRlLkZhbHNlLmNyZWF0ZSgpLFxuICAgIFRSVUU6IGZvYW0ubWxhbmcucHJlZGljYXRlLlRydWUuY3JlYXRlKClcbiAgfSxcblxuICBtZXRob2RzOiBbXG4gICAgZnVuY3Rpb24gX25hcnlfKG5hbWUsIGFyZ3MpIHtcbiAgICAgIHJldHVybiB0aGlzW25hbWVdLmNyZWF0ZSh7IGFyZ3M6IEFycmF5LmZyb20oYXJncykgfSk7XG4gICAgfSxcblxuICAgIGZ1bmN0aW9uIF91bmFyeV8obmFtZSwgYXJnKSB7XG4gICAgICByZXR1cm4gdGhpc1tuYW1lXS5jcmVhdGUoeyBhcmcxOiBhcmcgfSk7XG4gICAgfSxcblxuICAgIGZ1bmN0aW9uIF9iaW5hcnlfKG5hbWUsIGFyZzEsIGFyZzIpIHtcbiAgICAgIHJldHVybiB0aGlzW25hbWVdLmNyZWF0ZSh7IGFyZzE6IGFyZzEsIGFyZzI6IGFyZzIgfSk7XG4gICAgfSxcblxuICAgIGZ1bmN0aW9uIE9SKCkgeyByZXR1cm4gdGhpcy5fbmFyeV8oXCJPclwiLCBhcmd1bWVudHMpOyB9LFxuICAgIGZ1bmN0aW9uIEFORCgpIHsgcmV0dXJuIHRoaXMuX25hcnlfKFwiQW5kXCIsIGFyZ3VtZW50cyk7IH0sXG4gICAgZnVuY3Rpb24gQ09OVEFJTlMoYSwgYikgeyByZXR1cm4gdGhpcy5fYmluYXJ5XyhcIkNvbnRhaW5zXCIsIGEsIGIpOyB9LFxuICAgIGZ1bmN0aW9uIENPTlRBSU5TX0lDKGEsIGIpIHsgcmV0dXJuIHRoaXMuX2JpbmFyeV8oXCJDb250YWluc0lDXCIsIGEsIGIpOyB9LFxuICAgIGZ1bmN0aW9uIEVRKGEsIGIpIHsgcmV0dXJuIHRoaXMuX2JpbmFyeV8oXCJFcVwiLCBhLCBiKTsgfSxcbiAgICBmdW5jdGlvbiBORVEoYSwgYikgeyByZXR1cm4gdGhpcy5fYmluYXJ5XyhcIk5lcVwiLCBhLCBiKTsgfSxcbiAgICBmdW5jdGlvbiBJTihhLCBiKSB7IHJldHVybiB0aGlzLl9iaW5hcnlfKFwiSW5cIiwgYSwgYik7IH0sXG4gICAgZnVuY3Rpb24gTFQoYSwgYikgeyByZXR1cm4gdGhpcy5fYmluYXJ5XyhcIkx0XCIsIGEsIGIpOyB9LFxuICAgIGZ1bmN0aW9uIEdUKGEsIGIpIHsgcmV0dXJuIHRoaXMuX2JpbmFyeV8oXCJHdFwiLCBhLCBiKTsgfSxcbiAgICBmdW5jdGlvbiBMVEUoYSwgYikgeyByZXR1cm4gdGhpcy5fYmluYXJ5XyhcIkx0ZVwiLCBhLCBiKTsgfSxcbiAgICBmdW5jdGlvbiBHVEUoYSwgYikgeyByZXR1cm4gdGhpcy5fYmluYXJ5XyhcIkd0ZVwiLCBhLCBiKTsgfSxcbiAgICBmdW5jdGlvbiBIQVMoYSkgeyByZXR1cm4gdGhpcy5fdW5hcnlfKFwiSGFzXCIsIGEpOyB9LFxuICAgIGZ1bmN0aW9uIE5PVChhKSB7IHJldHVybiB0aGlzLl91bmFyeV8oXCJOb3RcIiwgYSk7IH0sXG4gICAgZnVuY3Rpb24gS0VZV09SRChhKSB7IHJldHVybiB0aGlzLl91bmFyeV8oXCJLZXl3b3JkXCIsIGEpOyB9LFxuICAgIGZ1bmN0aW9uIFNUQVJUU19XSVRIKGEsIGIpIHsgcmV0dXJuIHRoaXMuX2JpbmFyeV8oXCJTdGFydHNXaXRoXCIsIGEsIGIpOyB9LFxuICAgIGZ1bmN0aW9uIFNUQVJUU19XSVRIX0lDKGEsIGIpIHsgcmV0dXJuIHRoaXMuX2JpbmFyeV8oXCJTdGFydHNXaXRoSUNcIiwgYSwgYik7IH0sXG4gICAgZnVuY3Rpb24gRU5EU19XSVRIKGEsIGIpIHsgcmV0dXJuIHRoaXMuX2JpbmFyeV8oXCJFbmRzV2l0aFwiLCBhLCBiKTsgfSxcbiAgICBmdW5jdGlvbiBGVU5DKGZuKSB7IHJldHVybiB0aGlzLkZ1bmMuY3JlYXRlKHsgZm46IGZuIH0pOyB9LFxuICAgIGZ1bmN0aW9uIERPVChhLCBiKSB7IHJldHVybiB0aGlzLl9iaW5hcnlfKFwiRG90XCIsIGEsIGIpOyB9LFxuICAgIGZ1bmN0aW9uIE1VTChhLCBiKSB7IHJldHVybiB0aGlzLl9iaW5hcnlfKFwiTXVsXCIsIGEsIGIpOyB9LFxuXG4gICAgZnVuY3Rpb24gVU5JUVVFKGV4cHIsIHNpbmspIHsgcmV0dXJuIHRoaXMuVW5pcXVlLmNyZWF0ZSh7IGV4cHI6IGV4cHIsIGRlbGVnYXRlOiBzaW5rIH0pOyB9LFxuICAgIGZ1bmN0aW9uIEdST1VQX0JZKGV4cHIsIHNpbmtQcm90bykgeyByZXR1cm4gdGhpcy5Hcm91cEJ5LmNyZWF0ZSh7IGFyZzE6IGV4cHIsIGFyZzI6IHNpbmtQcm90byB9KTsgfSxcbiAgICBmdW5jdGlvbiBNQVAoZXhwciwgc2luaykgeyByZXR1cm4gdGhpcy5NYXAuY3JlYXRlKHsgYXJnMTogZXhwciwgZGVsZWdhdGU6IHNpbmsgfSk7IH0sXG4gICAgZnVuY3Rpb24gRVhQTEFJTihzaW5rKSB7IHJldHVybiB0aGlzLkV4cGxhaW4uY3JlYXRlKHsgZGVsZWdhdGU6IHNpbmsgfSk7IH0sXG4gICAgZnVuY3Rpb24gQ09VTlQoKSB7IHJldHVybiB0aGlzLkNvdW50LmNyZWF0ZSgpOyB9LFxuICAgIGZ1bmN0aW9uIE1BWChhcmcxKSB7IHJldHVybiB0aGlzLk1heC5jcmVhdGUoeyBhcmcxOiBhcmcxIH0pOyB9LFxuICAgIGZ1bmN0aW9uIE1JTihhcmcxKSB7IHJldHVybiB0aGlzLk1pbi5jcmVhdGUoeyBhcmcxOiBhcmcxIH0pOyB9LFxuICAgIGZ1bmN0aW9uIFNVTShhcmcxKSB7IHJldHVybiB0aGlzLlN1bS5jcmVhdGUoeyBhcmcxOiBhcmcxIH0pOyB9LFxuXG4gICAgZnVuY3Rpb24gREVTQyhhKSB7IHJldHVybiB0aGlzLl91bmFyeV8oXCJEZXNjXCIsIGEpOyB9LFxuICAgIGZ1bmN0aW9uIFRIRU5fQlkoYSwgYikgeyByZXR1cm4gdGhpcy5fYmluYXJ5XyhcIlRoZW5CeVwiLCBhLCBiKTsgfVxuICBdXG59KTtcblxuXG5mb2FtLkNMQVNTKHtcbiAgcGFja2FnZTogJ2ZvYW0ubWxhbmcnLFxuICBuYW1lOiAnRXhwcmVzc2lvbnNTaW5nbGV0b24nLFxuICBleHRlbmRzOiAnZm9hbS5tbGFuZy5FeHByZXNzaW9ucycsXG5cbiAgZG9jdW1lbnRhdGlvbjogJ0EgY29udmVuaWVuY2Ugb2JqZWN0IHdoaWNoIHByb3ZpZGVzIGFjY2VzcyB0byBhbGwgbWxhbmdzLicsXG4gIC8vIFRPRE86IHdoeSBpcyB0aGlzIG5lZWRlZD9cblxuICBheGlvbXM6IFtcbiAgICBmb2FtLnBhdHRlcm4uU2luZ2xldG9uLmNyZWF0ZSgpXG4gIF1cbn0pO1xuXG4vLyBUT0RPKGJyYWRlbik6IFdlIHJlbW92ZWQgRXhwci5waXBlKCkuIFRoYXQgbWF5IHN0aWxsIGJlIHVzZWZ1bCB0byBicmluZyBiYWNrLFxuLy8gcHJvYmFibHkgd2l0aCBhIGRpZmZlcmVudCBuYW1lLiBJdCBkb2Vzbid0IG1lYW4gdGhlIHNhbWUgYXMgREFPLnBpcGUoKS5cbi8vIHJlbW92ZSBlb2YoKVxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTYgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuZm9hbS5DTEFTUyh7XG4gIHBhY2thZ2U6ICdmb2FtLm1sYW5nJyxcbiAgbmFtZTogJ0xhYmVsZWRWYWx1ZScsXG5cbiAgZG9jdW1lbnRhdGlvbjogJ0EgYmFzaWMgbW9kZWwgZm9yIGFueSBpZC1sYWJlbC12YWx1ZSB0cmlwbGUuIFRoaXMgaXMgJyArXG4gICAgICAndXNlZnVsIHdoZW4geW91IG5lZWQgZXNzZW50aWFsbHkgYSBEQU8gb2Ygc3RyaW5ncywgYW5kIG5lZWQgdG8gd3JhcCAnICtcbiAgICAgICd0aG9zZSBzdHJpbmdzIGludG8gYSBtb2RlbGVkIG9iamVjdC4nLFxuXG4gIHByb3BlcnRpZXM6IFtcbiAgICB7XG4gICAgICBuYW1lOiAnaWQnLFxuICAgICAgZXhwcmVzc2lvbjogZnVuY3Rpb24obGFiZWwpIHsgcmV0dXJuIGxhYmVsOyB9XG4gICAgfSxcbiAgICB7XG4gICAgICBjbGFzczogJ1N0cmluZycsXG4gICAgICBuYW1lOiAnbGFiZWwnLFxuICAgICAgcmVxdWlyZWQ6IHRydWVcbiAgICB9LFxuICAgIHtcbiAgICAgIG5hbWU6ICd2YWx1ZSdcbiAgICB9XG4gIF1cbn0pO1xuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTIgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuZm9hbS5DTEFTUyh7XG4gIHBhY2thZ2U6ICdmb2FtLmRhby5pbmRleCcsXG4gIG5hbWU6ICdQbGFuJyxcblxuICBwcm9wZXJ0aWVzOiBbXG4gICAge1xuICAgICAgbmFtZTogJ2Nvc3QnLFxuICAgICAgdmFsdWU6IDBcbiAgICB9XG4gIF0sXG5cbiAgbWV0aG9kczogW1xuICAgIGZ1bmN0aW9uIGV4ZWN1dGUocHJvbWlzZSwgc3RhdGUsIHNpbmssIHNraXAsIGxpbWl0LCBvcmRlciwgcHJlZGljYXRlKSB7fSxcbiAgICBmdW5jdGlvbiB0b1N0cmluZygpIHsgcmV0dXJuIHRoaXMuY2xzXy5uYW1lK1wiKGNvc3Q9XCIrdGhpcy5jb3N0K1wiKVwiOyB9XG4gIF1cbn0pO1xuXG5cbi8qKiBQbGFuIGluZGljYXRpbmcgdGhhdCB0aGVyZSBhcmUgbm8gbWF0Y2hpbmcgcmVjb3Jkcy4gKiovXG5mb2FtLkNMQVNTKHtcbiAgcGFja2FnZTogJ2ZvYW0uZGFvLmluZGV4JyxcbiAgbmFtZTogJ05vdEZvdW5kUGxhbicsXG4gIGV4dGVuZHM6ICdmb2FtLmRhby5pbmRleC5QbGFuJyxcblxuICBheGlvbXM6IFsgZm9hbS5wYXR0ZXJuLlNpbmdsZXRvbi5jcmVhdGUoKSBdLFxuXG4gIHByb3BlcnRpZXM6IFtcbiAgICB7IG5hbWU6ICdjb3N0JywgdmFsdWU6IDAgfVxuICBdLFxuXG4gIG1ldGhvZHM6IFtcbiAgICBmdW5jdGlvbiB0b1N0cmluZygpIHsgcmV0dXJuICduby1tYXRjaChjb3N0PTApJzsgfVxuICBdXG59KTtcblxuXG4vKiogUGxhbiBpbmRpY2F0aW5nIHRoYXQgYW4gaW5kZXggaGFzIG5vIHBsYW4gZm9yIGV4ZWN1dGluZyBhIHF1ZXJ5LiAqKi9cbmZvYW0uQ0xBU1Moe1xuICBwYWNrYWdlOiAnZm9hbS5kYW8uaW5kZXgnLFxuICBuYW1lOiAnTm9QbGFuJyxcbiAgZXh0ZW5kczogJ2ZvYW0uZGFvLmluZGV4LlBsYW4nLFxuXG4gIGF4aW9tczogWyBmb2FtLnBhdHRlcm4uU2luZ2xldG9uLmNyZWF0ZSgpIF0sXG5cbiAgcHJvcGVydGllczogW1xuICAgIHsgbmFtZTogJ2Nvc3QnLCB2YWx1ZTogTnVtYmVyLk1BWF9WQUxVRSB9XG4gIF0sXG5cbiAgbWV0aG9kczogW1xuICAgIGZ1bmN0aW9uIHRvU3RyaW5nKCkgeyByZXR1cm4gJ25vLXBsYW4nOyB9XG4gIF1cbn0pO1xuXG5cbi8qKiBDb252ZW5pZW5jZSB3cmFwcGVyIGZvciBpbmRleGVzIHRoYXQgd2FudCB0byBjcmVhdGUgYSBjbG9zdXJlJ2QgZnVuY3Rpb25cbiAgICBmb3IgZWFjaCBwbGFuIGluc3RhbmNlICovXG5mb2FtLkNMQVNTKHtcbiAgcGFja2FnZTogJ2ZvYW0uZGFvLmluZGV4JyxcbiAgbmFtZTogJ0N1c3RvbVBsYW4nLFxuICBleHRlbmRzOiAnZm9hbS5kYW8uaW5kZXguUGxhbicsXG5cbiAgcHJvcGVydGllczogW1xuICAgIHtcbiAgICAgIGNsYXNzOiAnRnVuY3Rpb24nLFxuICAgICAgbmFtZTogJ2N1c3RvbUV4ZWN1dGUnXG4gICAgfSxcbiAgICB7XG4gICAgICBjbGFzczogJ0Z1bmN0aW9uJyxcbiAgICAgIG5hbWU6ICdjdXN0b21Ub1N0cmluZydcbiAgICB9XG4gIF0sXG5cbiAgbWV0aG9kczogW1xuICAgIGZ1bmN0aW9uIGV4ZWN1dGUocHJvbWlzZSwgc3RhdGUsIHNpbmssIHNraXAsIGxpbWl0LCBvcmRlciwgcHJlZGljYXRlKSB7XG4gICAgICB0aGlzLmN1c3RvbUV4ZWN1dGUuY2FsbChcbiAgICAgICAgICB0aGlzLFxuICAgICAgICAgIHByb21pc2UsXG4gICAgICAgICAgc3RhdGUsXG4gICAgICAgICAgc2luayxcbiAgICAgICAgICBza2lwLFxuICAgICAgICAgIGxpbWl0LFxuICAgICAgICAgIG9yZGVyLFxuICAgICAgICAgIHByZWRpY2F0ZSk7XG4gICAgfSxcblxuICAgIGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgICAgcmV0dXJuIHRoaXMuY3VzdG9tVG9TdHJpbmcuY2FsbCh0aGlzKTtcbiAgICB9XG4gIF1cbn0pO1xuXG5cbmZvYW0uQ0xBU1Moe1xuICBwYWNrYWdlOiAnZm9hbS5kYW8uaW5kZXgnLFxuICBuYW1lOiAnQ291bnRQbGFuJyxcbiAgZXh0ZW5kczogJ2ZvYW0uZGFvLmluZGV4LlBsYW4nLFxuXG4gIHByb3BlcnRpZXM6IFtcbiAgICB7XG4gICAgICBjbGFzczogJ0ludCcsXG4gICAgICBuYW1lOiAnY291bnQnXG4gICAgfVxuICBdLFxuXG4gIG1ldGhvZHM6IFtcbiAgICBmdW5jdGlvbiBleGVjdXRlKHByb21pc2UsIHNpbmsgLyosIHNraXAsIGxpbWl0LCBvcmRlciwgcHJlZGljYXRlKi8pIHtcbiAgICAgIHNpbmsudmFsdWUgKz0gdGhpcy5jb3VudDtcbiAgICB9LFxuXG4gICAgZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgICByZXR1cm4gJ3Nob3J0LWNpcmN1aXQtY291bnQoJyArIHRoaXMuY291bnQgKyAnKSc7XG4gICAgfVxuICBdXG59KTtcblxuXG5mb2FtLkNMQVNTKHtcbiAgcGFja2FnZTogJ2ZvYW0uZGFvLmluZGV4JyxcbiAgbmFtZTogJ0FsdFBsYW4nLFxuICBleHRlbmRzOiAnZm9hbS5kYW8uaW5kZXguUGxhbicsXG5cbiAgcHJvcGVydGllczogW1xuICAgIHtcbiAgICAgIG5hbWU6ICdzdWJQbGFucycsXG4gICAgICBmYWN0b3J5OiBmdW5jdGlvbigpIHsgcmV0dXJuIFtdOyB9LFxuICAgICAgcG9zdFNldDogZnVuY3Rpb24obywgbnUpIHtcbiAgICAgICAgdGhpcy5jb3N0ID0gMTtcbiAgICAgICAgZm9yICggdmFyIGkgPSAwOyBpIDwgbnUubGVuZ3RoOyArK2kgKSB7XG4gICAgICAgICAgdGhpcy5jb3N0ICs9IG51W2ldLmNvc3Q7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgICdwcm9wJ1xuICBdLFxuXG4gIG1ldGhvZHM6IFtcbiAgICBmdW5jdGlvbiBleGVjdXRlKHByb21pc2UsIHNpbmssIHNraXAsIGxpbWl0LCBvcmRlciwgcHJlZGljYXRlKSB7XG4gICAgICB2YXIgc3AgPSB0aGlzLnN1YlBsYW5zO1xuICAgICAgZm9yICggdmFyIGkgPSAwIDsgaSA8IHNwLmxlbmd0aCA7ICsraSkge1xuICAgICAgICBzcFtpXS5leGVjdXRlKHByb21pc2UsIHNpbmssIHNraXAsIGxpbWl0LCBvcmRlciwgcHJlZGljYXRlKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgICByZXR1cm4gKCAhIHRoaXMuc3ViUGxhbnMgfHwgdGhpcy5zdWJQbGFucy5sZW5ndGggPD0gMSApID9cbiAgICAgICAgJ0lOKGtleT0nICsgKCB0aGlzLnByb3AgJiYgdGhpcy5wcm9wLm5hbWUgKSArICcsIGNvc3Q9JyArIHRoaXMuY29zdCArICcsICcgK1xuICAgICAgICAgICcsIHNpemU9JyArICggdGhpcy5zdWJQbGFucyA/IHRoaXMuc3ViUGxhbnMubGVuZ3RoIDogMCApICsgJyknIDpcbiAgICAgICAgJ2xvb2t1cChrZXk9JyArIHRoaXMucHJvcCAmJiB0aGlzLnByb3AubmFtZSArICcsIGNvc3Q9JyArIHRoaXMuY29zdCArICcsICcgK1xuICAgICAgICAgIHRoaXMuc3ViUGxhbnNbMF0udG9TdHJpbmcoKTtcbiAgICB9XG4gIF1cbn0pO1xuXG5cblxuLyoqXG4gIE1lcmdlcyByZXN1bHRzIGZyb20gbXVsdGlwbGUgc3ViLXBsYW5zIGFuZCBkZWR1cGxpY2F0ZXMsIHNvcnRzLCBhbmRcbiAgZmlsdGVycyB0aGUgcmVzdWx0cy5cblxuICBUT0RPOiBhY2NvdW50IGZvciByZXN1bHQgc29ydGluZyBpbiBjb3N0P1xuKi9cbmZvYW0uQ0xBU1Moe1xuICBwYWNrYWdlOiAnZm9hbS5kYW8uaW5kZXgnLFxuICBuYW1lOiAnTWVyZ2VQbGFuJyxcbiAgZXh0ZW5kczogJ2ZvYW0uZGFvLmluZGV4LkFsdFBsYW4nLFxuXG4gIHJlcXVpcmVzOiBbXG4gICAgJ2ZvYW0uZGFvLkRlZHVwU2luaycsXG4gICAgJ2ZvYW0uZGFvLkxpbWl0ZWRTaW5rJyxcbiAgICAnZm9hbS5kYW8uT3JkZXJlZFNpbmsnLFxuICAgICdmb2FtLmRhby5Ta2lwU2luaydcbiAgXSxcblxuICBwcm9wZXJ0aWVzOiBbXG4gICAge1xuICAgICAgY2xhc3M6ICdDbGFzcycsXG4gICAgICBuYW1lOiAnb2YnXG4gICAgfSxcbiAgICAncHJlZGljYXRlcycsXG4gIF0sXG5cbiAgbWV0aG9kczogW1xuICAgIC8qKlxuICAgICAgRXhlY3V0ZXMgc3ViLXBsYW5zLCBsaW1pdGluZyByZXN1bHRzIGZyb20gZWFjaCwgdGhlbiBtZXJnZXMgcmVzdWx0cyxcbiAgICAgIHJlbW92ZXMgZHVwbGljYXRlcywgc29ydHMsIHNraXBzLCBhbmQgbGltaXRzLlxuICAgICovXG4gICAgZnVuY3Rpb24gZXhlY3V0ZShwcm9taXNlLCBzaW5rLCBza2lwLCBsaW1pdCwgb3JkZXIsIHByZWRpY2F0ZSkge1xuICAgICAgaWYgKCBvcmRlciApIHJldHVybiB0aGlzLmV4ZWN1dGVPcmRlcmVkKHByb21pc2UsIHNpbmssIHNraXAsIGxpbWl0LCBvcmRlciwgcHJlZGljYXRlKTtcbiAgICAgIHJldHVybiB0aGlzLmV4ZWN1dGVGYWxsYmFjayhwcm9taXNlLCBzaW5rLCBza2lwLCBsaW1pdCwgb3JkZXIsIHByZWRpY2F0ZSk7XG4gICAgfSxcblxuICAgIGZ1bmN0aW9uIGV4ZWN1dGVPcmRlcmVkKHByb21pc2UsIHNpbmssIHNraXAsIGxpbWl0LCBvcmRlciwgcHJlZGljYXRlKSB7XG4gICAgICAvKipcbiAgICAgICAqIEV4ZWN1dGVzIGEgbWVyZ2Ugd2hlcmUgb3JkZXJpbmcgaXMgc3BlY2lmaWVkLCB0aGVyZWZvcmVcbiAgICAgICAqIHJlc3VsdHMgZnJvbSB0aGUgc3ViUGxhbnMgYXJlIGFsc28gc29ydGVkLCBhbmQgY2FuIGJlIG1lcmdlZFxuICAgICAgICogZWZmaWNpZW50bHkuXG4gICAgICAgKi9cbiAgICAgIGZvYW0uYXNzZXJ0KG9yZGVyICYmIG9yZGVyLmNvbXBhcmUsIFwiT3JkZXIuY29tcGFyZSgpIG11c3QgYmUgc3VwcGxpZWQgaW4gTWVyZ2VQbGFuLmV4ZWN1dGVPcmRlcmVkKClcIik7XG4gICAgICBmb2FtLmFzc2VydCgoICEgdGhpcy5wcmVkaWNhdGVzICkgfHwgKCB0aGlzLnByZWRpY2F0ZXMuc2l6ZSA9PSB0aGlzLnN1YlBsYW5zLnNpemUgKSwgXCJNZXJnZVBsYW4ucHJlZGljYXRlcywgd2hlbiBzcGVjaWZpZWQsIG11c3QgbWF0Y2ggdGhlIG51bWJlciBvZiBzdWJwbGFucy5cIiApO1xuXG4gICAgICAvLyBxdWljayBsaW5rZWQgbGlzdFxuICAgICAgdmFyIE5vZGVQcm90byA9IHsgbmV4dDogbnVsbCwgZGF0YTogbnVsbCB9O1xuXG4gICAgICB2YXIgaGVhZCA9IE9iamVjdC5jcmVhdGUoTm9kZVByb3RvKTtcbiAgICAgIC8vIFRPRE86IHRyYWNrIGxpc3Qgc2l6ZSwgY3V0IG9mZiBpZiBhYm92ZSBza2lwK2xpbWl0XG5cbiAgICAgIHZhciBzcCA9IHRoaXMuc3ViUGxhbnM7XG4gICAgICB2YXIgcHJlZGljYXRlcyA9IHRoaXMucHJlZGljYXRlcztcbiAgICAgIHZhciBzdWJMaW1pdCA9ICggbGltaXQgPyBsaW1pdCArICggc2tpcCA/IHNraXAgOiAwICkgOiB1bmRlZmluZWQgKTtcbiAgICAgIHZhciBwcm9taXNlcyA9IFtdOyAvLyB0cmFjayBhbnkgYXN5bmMgc3VicGxhbnNcbiAgICAgIHZhciBkZWR1cENvbXBhcmUgPSAoIHRoaXMub2YgKSA/IHRoaXMub2YuSUQuY29tcGFyZS5iaW5kKHRoaXMub2YuSUQpIDogZm9hbS51dGlsLmNvbXBhcmU7XG4gICAgICB2YXIgY29tcGFyZSA9IG9yZGVyLmNvbXBhcmUuYmluZChvcmRlcik7XG5cbiAgICAgIC8vIEVhY2ggcGxhbiBpbnNlcnRzIGludG8gdGhlIGxpc3RcbiAgICAgIGZvciAoIHZhciBpID0gMCA7IGkgPCBzcC5sZW5ndGggOyArK2kpIHtcbiAgICAgICAgdmFyIGluc2VydFBsYW5TaW5rO1xuICAgICAgICAoZnVuY3Rpb24oKSB7IC8vIGNhcHR1cmUgbmV3IGluc2VydEFmdGVyIGZvciBlYWNoIHNpbmtcbiAgICAgICAgICAvLyBzZXQgbmV3IGluc2VydCBwb3NpdGlvbiB0byBoZWFkLlxuICAgICAgICAgIC8vIE9ubHkgYnVtcCBpbnNlcnRBZnRlciBmb3J3YXJkIHdoZW4gdGhlIG5leHQgaXRlbSBpcyBzbWFsbGVyLFxuICAgICAgICAgIC8vICAgc2luY2Ugd2UgbmVlZCB0byBzY2FuIGFsbCBlcXVhbCBpdGVtcyBldmVyeSB0aW1lIGEgbmV3IGl0ZW1cbiAgICAgICAgICAvLyAgIGNvbWVzIGluLlxuICAgICAgICAgIC8vIElmIHRoZSBuZXh0IGl0ZW0gaXMgbGFyZ2VyLCB3ZSBpbnNlcnQgYmVmb3JlIGl0XG4gICAgICAgICAgLy8gICBhbmQgbGVhdmUgdGhlIGluc2VydGlvbiBwb2ludCB3aGVyZSBpdCBpcywgc28gdGhlIG5leHRcbiAgICAgICAgICAvLyAgIGl0ZW0gY2FuIGNoZWNrIGlmIGl0IGlzIGVxdWFsIHRvIHRoZSBqdXN0LWluc2VydGVkIGl0ZW0uXG4gICAgICAgICAgdmFyIGluc2VydEFmdGVyID0gaGVhZDtcbiAgICAgICAgICBpbnNlcnRQbGFuU2luayA9IGZvYW0uZGFvLlF1aWNrU2luay5jcmVhdGUoe1xuICAgICAgICAgICAgcHV0Rm46IGZ1bmN0aW9uKG8pIHtcbiAgICAgICAgICAgICAgZnVuY3Rpb24gaW5zZXJ0KCkge1xuICAgICAgICAgICAgICAgIHZhciBudSA9IE9iamVjdC5jcmVhdGUoTm9kZVByb3RvKTtcbiAgICAgICAgICAgICAgICBudS5uZXh0ID0gaW5zZXJ0QWZ0ZXIubmV4dDtcbiAgICAgICAgICAgICAgICBudS5kYXRhID0gbztcbiAgICAgICAgICAgICAgICBpbnNlcnRBZnRlci5uZXh0ID0gbnU7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAvLyBTa2lwIHBhc3QgaXRlbXMgdGhhdCBhcmUgbGVzcyB0aGFuIG91ciBuZXcgaXRlbVxuICAgICAgICAgICAgICB3aGlsZSAoIGluc2VydEFmdGVyLm5leHQgJiZcbiAgICAgICAgICAgICAgICAgICAgICBjb21wYXJlKG8sIGluc2VydEFmdGVyLm5leHQuZGF0YSkgPiAwICkge1xuICAgICAgICAgICAgICAgICBpbnNlcnRBZnRlciA9IGluc2VydEFmdGVyLm5leHQ7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBpZiAoICEgaW5zZXJ0QWZ0ZXIubmV4dCApIHtcbiAgICAgICAgICAgICAgICAvLyBlbmQgb2YgbGlzdCBjYXNlLCBubyBlcXVhbCBpdGVtcywgc28ganVzdCBhcHBlbmRcbiAgICAgICAgICAgICAgICBpbnNlcnQoKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAoIGNvbXBhcmUobywgaW5zZXJ0QWZ0ZXIubmV4dC5kYXRhKSA9PT0gMCApIHtcbiAgICAgICAgICAgICAgICAvLyBlcXVhbCBpdGVtcyBjYXNlLCBjaGVjayBmb3IgZHVwZXNcbiAgICAgICAgICAgICAgICAvLyBzY2FuIHRocm91Z2ggYW55IGl0ZW1zIHRoYXQgYXJlIGVxdWFsLCBkdXBlIGNoZWNrIGVhY2hcbiAgICAgICAgICAgICAgICB2YXIgZHVwZUFmdGVyID0gaW5zZXJ0QWZ0ZXI7XG4gICAgICAgICAgICAgICAgd2hpbGUgKCBkdXBlQWZ0ZXIubmV4dCAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgY29tcGFyZShvLCBkdXBlQWZ0ZXIubmV4dC5kYXRhKSA9PT0gMCApIHtcbiAgICAgICAgICAgICAgICAgIGlmICggZGVkdXBDb21wYXJlKG8sIGR1cGVBZnRlci5uZXh0LmRhdGEpID09PSAwICkge1xuICAgICAgICAgICAgICAgICAgICAvLyBkdXBsaWNhdGUgZm91bmQsIGlnbm9yZSB0aGUgbmV3IGl0ZW1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgZHVwZUFmdGVyID0gZHVwZUFmdGVyLm5leHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIE5vIGR1cGVzIGZvdW5kLCBzbyBpbnNlcnQgYXQgcG9zaXRpb24gZHVwZUFmdGVyXG4gICAgICAgICAgICAgICAgLy8gZHVwZUFmdGVyLm5leHQgaXMgZWl0aGVyIGVuZC1vZi1saXN0IG9yIGEgbGFyZ2VyIGl0ZW1cbiAgICAgICAgICAgICAgICB2YXIgbnUgPSBPYmplY3QuY3JlYXRlKE5vZGVQcm90byk7XG4gICAgICAgICAgICAgICAgbnUubmV4dCA9IGR1cGVBZnRlci5uZXh0O1xuICAgICAgICAgICAgICAgIG51LmRhdGEgPSBvO1xuICAgICAgICAgICAgICAgIGR1cGVBZnRlci5uZXh0ID0gbnU7XG4gICAgICAgICAgICAgICAgZHVwZUFmdGVyID0gbnVsbDtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgIH0gZWxzZSB7IC8vIGNvbXAgPCAwXG4gICAgICAgICAgICAgICAgIC8vIGV4aXN0aW5nLWlzLWdyZWF0ZXItdGhhbi1uZXcgY2FzZSwgaW5zZXJ0IGJlZm9yZSBpdFxuICAgICAgICAgICAgICAgICBpbnNlcnQoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9KSgpO1xuICAgICAgICAvLyByZXN0YXJ0IHRoZSBwcm9taXNlIGNoYWluLCBpZiBhIHByb21pc2UgaXMgYWRkZWQgd2UgY29sbGVjdCBpdFxuICAgICAgICB2YXIgbnVQcm9taXNlUmVmID0gW107XG4gICAgICAgIHNwW2ldLmV4ZWN1dGUoXG4gICAgICAgICAgbnVQcm9taXNlUmVmLFxuICAgICAgICAgIGluc2VydFBsYW5TaW5rLFxuICAgICAgICAgIHVuZGVmaW5lZCxcbiAgICAgICAgICBzdWJMaW1pdCxcbiAgICAgICAgICBvcmRlcixcbiAgICAgICAgICBwcmVkaWNhdGVzID8gcHJlZGljYXRlc1tpXSA6IHByZWRpY2F0ZSAvLyBhcnJheSBtb2RlIChvbmUgcGVyIHN1YnBsYW4pIG9yIHJlcGVhdGVkIHVzZSBvZiBzaW5nbGUgcHJlZGljYXRlXG4gICAgICAgICk7XG4gICAgICAgIGlmICggbnVQcm9taXNlUmVmWzBdICkgcHJvbWlzZXMucHVzaChudVByb21pc2VSZWZbMF0pO1xuICAgICAgfVxuXG4gICAgICAvLyByZXN1bHQgcmVhZGluZyBtYXkgYnkgYXN5bmMsIHNvIGRlZmluZSBpdCBidXQgZG9uJ3QgY2FsbCBpdCB5ZXRcbiAgICAgIHZhciByZXN1bHRTaW5rID0gdGhpcy5kZWNvcmF0ZVNpbmtfKHNpbmssIHNraXAsIGxpbWl0KTtcblxuICAgICAgdmFyIHN1YiA9IGZvYW0uY29yZS5GT2JqZWN0LmNyZWF0ZSgpO1xuICAgICAgdmFyIGRldGFjaGVkID0gZmFsc2U7XG4gICAgICBzdWIub25EZXRhY2goZnVuY3Rpb24oKSB7IGRldGFjaGVkID0gdHJ1ZTsgfSk7XG5cbiAgICAgIGZ1bmN0aW9uIHNjYW5SZXN1bHRzKCkge1xuICAgICAgICAvLyBUaGUgbGlzdCBzdGFydGluZyBhdCBoZWFkIG5vdyBjb250YWlucyB0aGUgcmVzdWx0cyBwbHVzIHBvc3NpYmxlXG4gICAgICAgIC8vICBvdmVyZmxvdyBvZiBza2lwK2xpbWl0XG4gICAgICAgIHZhciBub2RlID0gaGVhZC5uZXh0O1xuICAgICAgICB3aGlsZSAoIG5vZGUgJiYgISBkZXRhY2hlZCApIHtcbiAgICAgICAgICByZXN1bHRTaW5rLnB1dChub2RlLmRhdGEsIHN1Yik7XG4gICAgICAgICAgbm9kZSA9IG5vZGUubmV4dDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBpZiB0aGVyZSBpcyBhbiBhc3luYyBpbmRleCBpbiB0aGUgYWJvdmUsIHdhaXQgZm9yIGl0IHRvIGZpbmlzaFxuICAgICAgLy8gICBiZWZvcmUgcmVhZGluZyBvdXQgdGhlIHJlc3VsdHMuXG4gICAgICBpZiAoIHByb21pc2VzLmxlbmd0aCApIHtcbiAgICAgICAgdmFyIHRoaXNQcm9taXNlID0gUHJvbWlzZS5hbGwocHJvbWlzZXMpLnRoZW4oc2NhblJlc3VsdHMpO1xuICAgICAgICAvLyBpZiBhbiBpbmRleCBhYm92ZSB1cyBpcyBhbHNvIGFzeW5jLCBjaGFpbiBvdXJzZWxmIG9uXG4gICAgICAgIHByb21pc2VbMF0gPSBwcm9taXNlWzBdID8gcHJvbWlzZVswXS50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiB0aGlzUHJvbWlzZTtcbiAgICAgICAgfSkgOiB0aGlzUHJvbWlzZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEluIHRoZSBzeW5jcmhvbm91cyBjYXNlIHdlIGRvbid0IGhhdmUgdG8gd2FpdCBvbiBvdXIgc3VicGxhbnMsXG4gICAgICAgIC8vICBhbmQgY2FuIGlnbm9yZSBwcm9taXNlWzBdIGFzIHNvbWVvbmUgZWxzZSBpcyByZXNwb25zaWJsZSBmb3JcbiAgICAgICAgLy8gIHdhaXRpbmcgb24gaXQgaWYgcHJlc2VudC5cbiAgICAgICAgc2NhblJlc3VsdHMoKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgZnVuY3Rpb24gZXhlY3V0ZUZhbGxiYWNrKHByb21pc2UsIHNpbmssIHNraXAsIGxpbWl0LCBvcmRlciwgcHJlZGljYXRlKSB7XG4gICAgICAgLyoqXG4gICAgICAgICogRXhlY3V0ZXMgYSBtZXJnZSB3aGVyZSBvcmRlcmluZyBpcyB1bmtub3duLCB0aGVyZWZvcmUgbm9cbiAgICAgICAgKiBzb3J0aW5nIGlzIGRvbmUgYW5kIGRlZHVwbGljYXRpb24gbXVzdCBiZSBkb25lIHNlcGFyYXRlbHkuXG4gICAgICAgICovXG4gICAgICAgdmFyIHJlc3VsdFNpbmsgPSB0aGlzLkRlZHVwU2luay5jcmVhdGUoe1xuICAgICAgICAgZGVsZWdhdGU6IHRoaXMuZGVjb3JhdGVTaW5rXyhzaW5rLCBza2lwLCBsaW1pdClcbiAgICAgICB9KTtcblxuICAgICAgIGZvYW0uYXNzZXJ0KCggISB0aGlzLnByZWRpY2F0ZXMgKSB8fCAoIHRoaXMucHJlZGljYXRlcy5zaXplID09IHRoaXMuc3ViUGxhbnMuc2l6ZSApLCBcIk1lcmdlUGxhbi5wcmVkaWNhdGVzLCB3aGVuIHNwZWNpZmllZCwgbXVzdCBtYXRjaCB0aGUgbnVtYmVyIG9mIHN1YnBsYW5zLlwiICk7XG5cbiAgICAgICB2YXIgc3AgPSB0aGlzLnN1YlBsYW5zO1xuICAgICAgIHZhciBwcmVkaWNhdGVzID0gdGhpcy5wcmVkaWNhdGVzO1xuICAgICAgIHZhciBzdWJMaW1pdCA9ICggbGltaXQgPyBsaW1pdCArICggc2tpcCA/IHNraXAgOiAwICkgOiB1bmRlZmluZWQgKTtcblxuICAgICAgIGZvciAoIHZhciBpID0gMCA7IGkgPCBzcC5sZW5ndGggOyArK2kpIHtcbiAgICAgICAgIHNwW2ldLmV4ZWN1dGUoXG4gICAgICAgICAgIHByb21pc2UsXG4gICAgICAgICAgIHJlc3VsdFNpbmssXG4gICAgICAgICAgIHVuZGVmaW5lZCxcbiAgICAgICAgICAgc3ViTGltaXQsXG4gICAgICAgICAgIG9yZGVyLFxuICAgICAgICAgICBwcmVkaWNhdGVzID8gcHJlZGljYXRlc1tpXSA6IHByZWRpY2F0ZSAvLyBhcnJheSBtb2RlIChvbmUgcGVyIHN1YnBsYW4pIG9yIHJlcGVhdGVkIHVzZSBvZiBzaW5nbGUgcHJlZGljYXRlXG4gICAgICAgICApO1xuICAgICAgIH1cbiAgICAgICAvLyBTaW5jZSB0aGlzIGV4ZWN1dGUgZG9lc24ndCBjb2xsZWN0IHJlc3VsdHMgaW50byBhIHRlbXBvcmFyeVxuICAgICAgIC8vIHN0b3JhZ2UgbGlzdCwgd2UgZG9uJ3QgbmVlZCB0byB3b3JyeSBhYm91dCB0aGUgcHJvbWlzZXMuIEFueVxuICAgICAgIC8vIGFzeW5jIHN1YnBsYW5zIHdpbGwgYWRkIHRoZWlyIHByb21pc2Ugb24sIGFuZCB3aGVuIHRoZXkgYXJlXG4gICAgICAgLy8gcmVzb2x2ZWQgdGhlaXIgcmVzdWx0cyB3aWxsIGhhdmUgYWxyZWFkeSBwdXQoKSBzdHJhaWdodCBpbnRvXG4gICAgICAgLy8gdGhlIHJlc3VsdFNpbmsuIE9ubHkgdGhlIE1EQU8gY2FsbGluZyB0aGUgZmlyc3QgZXhlY3V0ZSgpIG5lZWRzXG4gICAgICAgLy8gdG8gcmVzcGVjdCB0aGUgcmVmZXJlbmNlZCBwcm9taXNlIGNoYWluLlxuICAgIH0sXG5cbiAgICBmdW5jdGlvbiBkZWNvcmF0ZVNpbmtfKHNpbmssIHNraXAsIGxpbWl0KSB7XG4gICAgICAvKipcbiAgICAgICAqIFRPRE86IFNoYXJlIHdpdGggQWJzdHJhY3REQU8/IFdlIG5ldmVyIG5lZWQgdG8gdXNlIHByZWRpY2F0ZSBvciBvcmRlclxuICAgICAgICogQHByaXZhdGVcbiAgICAgICAqL1xuICAgICAgaWYgKCBsaW1pdCAhPSB1bmRlZmluZWQgKSB7XG4gICAgICAgIHNpbmsgPSB0aGlzLkxpbWl0ZWRTaW5rLmNyZWF0ZSh7XG4gICAgICAgICAgbGltaXQ6IGxpbWl0LFxuICAgICAgICAgIGRlbGVnYXRlOiBzaW5rXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgaWYgKCBza2lwICE9IHVuZGVmaW5lZCApIHtcbiAgICAgICAgc2luayA9IHRoaXMuU2tpcFNpbmsuY3JlYXRlKHtcbiAgICAgICAgICBza2lwOiBza2lwLFxuICAgICAgICAgIGRlbGVnYXRlOiBzaW5rXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gc2luaztcbiAgICB9LFxuXG4gIF1cbn0pO1xuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTIgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuLyoqXG4gIFRoZSBJbmRleCBpbnRlcmZhY2UgZm9yIGFuIG9yZGVyaW5nLCBmYXN0IGxvb2t1cCwgc2luZ2xlIHZhbHVlLFxuICBpbmRleCBtdWx0aXBsZXhlciwgb3IgYW55IG90aGVyIE1EQU8gc2VsZWN0KCkgYXNzaXN0YW5jZSBjbGFzcy5cblxuICBFYWNoIEluZGV4IHN1YmNsYXNzIGFsc28gZGVmaW5lcyBhbiBJbmRleE5vZGUgY2xhc3MuIEluZGV4IGRlZmluZXNcbiAgdGhlIHN0cnVjdHVyZSBvZiB0aGUgaW5kZXgsIGluY2x1ZGluZyBlc3RpbWF0ZSgpIHRvIGdhdWdlIGl0c1xuICBwcm9iYWJsZSBwZXJmb3JtYW5jZSBmb3IgYSBxdWVyeSwgd2hpbGUgSW5kZXhOb2RlIGltcGxlbWVudHMgdGhlXG4gIGRhdGEgbm9kZXMgdGhhdCBob2xkIHRoZSBpbmRleGVkIGl0ZW1zIGFuZCBwbGFuIGFuZCBleGVjdXRlXG4gIHF1ZXJpZXMuIEZvciBhbnkgcGFydGljdWxhciBvcGVyYXRpb25hbCBJbmRleCwgdGhlcmUgbWF5IGJlXG4gIG1hbnkgSW5kZXhOb2RlIGluc3RhbmNlczpcblxuPHByZT5cbiAgICAgICAgICAgICAgICAgMS0tLS0tLS0tLT4gVHJlZUluZGV4KGlkKVxuICBNREFPOiBBbHRJbmRleCAyLS0tLS0tLS0tPiBUcmVlSW5kZXgocHJvcEEpIC0tLT4gVHJlZUluZGV4KGlkKSAtLS0tLS0tLS0tLS0tPiBWYWx1ZUluZGV4XG4gICAgICAgIHwgMXggQWx0SW5kZXhOb2RlICAgIHwgMXggVHJlZUluZGV4Tm9kZSAgICB8IDE0eCBUcmVlSW5kZXhOb2RlcyAgICAgICAgIHwgKERBTyBzaXplKXggVmFsdWVJbmRleE5vZGVzXG4gICAgICAgICAgICgyIGFsdCBzdWJpbmRleGVzKSAgICAgKDE0IG5vZGVzKSAgICAgICAgICAgICAoZWFjaCBoYXMgMC01IG5vZGVzKVxuPC9wcmU+XG4gIFRoZSBiYXNlIEFsdEluZGV4IGhhcyB0d28gY29tcGxldGUgc3ViaW5kZXhlcyAoZWFjaCBob2xkcyB0aGUgZW50aXJlIERBTykuXG4gIFRoZSBUcmVlSW5kZXggb24gcHJvcGVydHkgQSBoYXMgY3JlYXRlZCBvbmUgVHJlZUluZGV4Tm9kZSwgaG9sZGluZyBvbmUgdHJlZSBvZiAxNCBub2Rlcy5cbiAgRWFjaCB0cmVlIG5vZGUgY29udGFpbnMgYSB0YWlsIGluc3RhbmNlIG9mIHRoZSBuZXh0IGxldmVsIGRvd24sIHRodXNcbiAgdGhlIFRyZWVJbmRleCBvbiBpZCBoYXMgY3JlYXRlZCAxNCBUcmVlSW5kZXhOb2Rlcy4gRWFjaCBvZiB0aG9zZSBjb250YWlucyBzb21lIG51bWJlclxuICBvZiB0cmVlIG5vZGVzLCBlYWNoIGhvbGRpbmcgb25lIHRhaWwgaW5zdGFuY2Ugb2YgdGhlIFZhbHVlSW5kZXggYXQgdGhlIGVuZCBvZiB0aGUgY2hhaW4uXG5cbiovXG5mb2FtLkNMQVNTKHtcbiAgcGFja2FnZTogJ2ZvYW0uZGFvLmluZGV4JyxcbiAgbmFtZTogJ0luZGV4JyxcblxuICBwcm9wZXJ0aWVzOiBbXG4gICAge1xuICAgICAgLyoqXG4gICAgICAgKiBUaGUgY2xhc3MgdHlwZSBvZiB0aGUgZGF0YSBub2RlcyB0aGlzIGluZGV4IGNyZWF0ZXMgd2l0aFxuICAgICAgICogY3JlYXRlTm9kZSgpLiBCeSBkZWZhdWx0IGl0IHdpbGwgYmUgdGhlIEluZGV4IGNsYXNzJyBuYW1lXG4gICAgICAgKiB3aXRoIE5vZGUgYXBwZW5kZWQ6XG4gICAgICAgKiA8cD48Y29kZT5NeUluZGV4ID0+IE15SW5kZXhOb2RlPC9jb2RlPlxuICAgICAgICovXG4gICAgICBjbGFzczogJ0NsYXNzJyxcbiAgICAgIG5hbWU6ICdub2RlQ2xhc3MnLFxuICAgICAgZmFjdG9yeTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNsc18uaWQgKyAnTm9kZSc7XG4gICAgICB9XG4gICAgfVxuICBdLFxuXG4gIG1ldGhvZHM6IFtcbiAgICBmdW5jdGlvbiBlc3RpbWF0ZShzaXplLCBzaW5rLCBza2lwLCBsaW1pdCwgb3JkZXIsIHByZWRpY2F0ZSkge1xuICAgICAgLyoqIEVzdGltYXRlcyB0aGUgcGVyZm9ybWFuY2Ugb2YgdGhpcyBpbmRleCBnaXZlbiB0aGUgbnVtYmVyIG9mIGl0ZW1zXG4gICAgICAgIGl0IHdpbGwgaG9sZCBhbmQgdGhlIHBsYW5uZWQgcGFyYW1ldGVycy4gKi9cbiAgICAgIHJldHVybiBzaXplICogc2l6ZTsgLy8gbl4yIGlzIGEgZ29vZCB3b3JzdC1jYXNlIGVzdGltYXRlIGJ5IGRlZmF1bHRcbiAgICB9LFxuXG4gICAgZnVuY3Rpb24gdG9QcmV0dHlTdHJpbmcoaW5kZW50KSB7XG4gICAgICAvKiogT3V0cHV0IGEgbWluaW1hbCwgaHVtYW4gcmVhZGFibGUsIGluZGVudGVkICgyIHNwYWNlcyBwZXIgbGV2ZWwpXG4gICAgICAgIGRlc2NyaXB0aW9uIG9mIHRoZSBpbmRleCBzdHJ1Y3R1cmUgKi9cbiAgICB9LFxuXG4gICAgZnVuY3Rpb24gY3JlYXRlTm9kZShhcmdzKSB7XG4gICAgICBhcmdzID0gYXJncyB8fCB7fTtcbiAgICAgIGFyZ3MuaW5kZXggPSB0aGlzO1xuICAgICAgcmV0dXJuIHRoaXMubm9kZUNsYXNzLmNyZWF0ZShhcmdzLCB0aGlzKTtcbiAgICB9XG4gIF1cbn0pO1xuXG5cbi8qKlxuICBUaGUgSW5kZXhOb2RlIGludGVyZmFjZSByZXByZXNlbnRzIGEgcGllY2Ugb2YgdGhlIGluZGV4IHRoYXQgYWN0dWFsbHlcbiAgaG9sZHMgZGF0YS4gQSB0cmVlIHdpbGwgY3JlYXRlIGFuIGluZGV4LW5vZGUgZm9yIGVhY2ggdHJlZS1ub2RlLCBzbyBvbmVcbiAgSW5kZXggd2lsbCBtYW5hZ2UgbWFueSBJbmRleE5vZGUgaW5zdGFuY2VzLCBlYWNoIG9wZXJhdGluZyBvbiBwYXJ0IG9mXG4gIHRoZSBkYXRhIGluIHRoZSBEQU8uXG5cbiAgRm9yIGNyZWF0aW9uIHNwZWVkLCBkbyBub3QgcmVxdWlyZSBvciBpbXBvcnQgYW55dGhpbmcgaW4gYSBub2RlIGNsYXNzLlxuICBVc2UgdGhlICdpbmRleCcgcHJvcGVydHkgdG8gYWNjZXNzIHJlcXVpcmVzIGFuZCBpbXBvcnRzIG9uIHRoZVxuICBJbmRleCB0aGF0IGNyZWF0ZWQgdGhlIG5vZGUgaW5zdGFuY2UuXG4qL1xuZm9hbS5DTEFTUyh7XG4gIHBhY2thZ2U6ICdmb2FtLmRhby5pbmRleCcsXG4gIG5hbWU6ICdJbmRleE5vZGUnLFxuXG4gIHByb3BlcnRpZXM6IFtcbiAgICB7XG4gICAgICBjbGFzczogJ1NpbXBsZScsXG4gICAgICBuYW1lOiAnaW5kZXgnXG4gICAgfVxuICBdLFxuXG4gIG1ldGhvZHM6IFtcbiAgICAvKiogQWRkcyBvciB1cGRhdGVzIHRoZSBnaXZlbiB2YWx1ZSBpbiB0aGUgaW5kZXggKi9cbiAgICBmdW5jdGlvbiBwdXQob2JqKSB7fSxcblxuICAgIC8qKiBSZW1vdmVzIHRoZSBnaXZlbiB2YWx1ZSBmcm9tIHRoZSBpbmRleCAqL1xuICAgIGZ1bmN0aW9uIHJlbW92ZShvYmopIHt9LFxuXG4gICAgLyoqIEByZXR1cm4gYSBQbGFuIHRvIGV4ZWN1dGUgYSBzZWxlY3Qgd2l0aCB0aGUgZ2l2ZW4gcGFyYW1ldGVycyAqL1xuICAgIGZ1bmN0aW9uIHBsYW4oc2luaywgc2tpcCwgbGltaXQsIG9yZGVyLCBwcmVkaWNhdGUsIHJvb3QpIHt9LFxuXG4gICAgLyoqIEByZXR1cm4gdGhlIHRhaWwgaW5kZXggaW5zdGFuY2UgZm9yIHRoZSBnaXZlbiBrZXkuICovXG4gICAgZnVuY3Rpb24gZ2V0KGtleSkge30sXG5cbiAgICAvKiogQHJldHVybiB0aGUgaW50ZWdlciBzaXplIG9mIHRoaXMgaW5kZXguICovXG4gICAgZnVuY3Rpb24gc2l6ZSgpIHt9LFxuXG4gICAgLyoqIFNlbGVjdHMgbWF0Y2hpbmcgaXRlbXMgZnJvbSB0aGUgaW5kZXggYW5kIHB1dHMgdGhlbSBpbnRvIHNpbmsuXG4gICAgICAgIGNhY2hlIGFsbG93cyBpbmRleGVzIHRvIHN0b3JlIHF1ZXJ5IHN0YXRlIHRoYXQgaXMgZGlzY2FyZGVkIG9uY2VcbiAgICAgICAgdGhlIHNlbGVjdCgpIGlzIGNvbXBsZXRlLlxuICAgICAgPHA+Tm90ZTogb3JkZXIgY2hlY2tpbmcgaGFzIHJlcGxhY2VkIHNlbGVjdFJldmVyc2UoKS4gICovXG4gICAgZnVuY3Rpb24gc2VsZWN0KHNpbmssIHNraXAsIGxpbWl0LCBvcmRlciwgcHJlZGljYXRlLCBjYWNoZSkgeyB9LFxuXG4gICAgLyoqIEVmZmljaWVudGx5IChpZiBwb3NzaWJsZSkgbG9hZHMgdGhlIGNvbnRlbnRzIG9mIHRoZSBnaXZlbiBEQU8gaW50byB0aGUgaW5kZXggKi9cbiAgICBmdW5jdGlvbiBidWxrTG9hZChkYW8pIHt9XG4gIF1cbn0pO1xuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTYgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuZm9hbS5DTEFTUyh7XG4gIHBhY2thZ2U6ICdmb2FtLmRhby5pbmRleCcsXG4gIG5hbWU6ICdQcm94eUluZGV4JyxcbiAgZXh0ZW5kczogJ2ZvYW0uZGFvLmluZGV4LkluZGV4JyxcblxuICBwcm9wZXJ0aWVzOiBbXG4gICAge1xuICAgICAgbmFtZTogJ2RlbGVnYXRlJyxcbiAgICAgIHJlcXVpcmVkOiB0cnVlLFxuICAgIH1cbiAgXSxcbiAgbWV0aG9kczogW1xuICAgIGZ1bmN0aW9uIGVzdGltYXRlKHNpemUsIHNpbmssIHNraXAsIGxpbWl0LCBvcmRlciwgcHJlZGljYXRlKSB7XG4gICAgICByZXR1cm4gdGhpcy5kZWxlZ2F0ZS5lc3RpbWF0ZShzaXplLCBzaW5rLCBza2lwLCBsaW1pdCwgb3JkZXIsIHByZWRpY2F0ZSk7XG4gICAgfSxcblxuICAgIGZ1bmN0aW9uIHRvUHJldHR5U3RyaW5nKGluZGVudCkge1xuICAgICAgcmV0dXJuIHRoaXMuZGVsZWdhdGUudG9QcmV0dHlTdHJpbmcoaW5kZW50KTtcbiAgICB9LFxuXG4gICAgZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgICByZXR1cm4gJ1snICsgdGhpcy5jbHNfLm5hbWUgKyAnOiAnICsgdGhpcy5kZWxlZ2F0ZS50b1N0cmluZygpICsgJ10nXG4gICAgfVxuICBdXG59KTtcblxuZm9hbS5DTEFTUyh7XG4gIHBhY2thZ2U6ICdmb2FtLmRhby5pbmRleCcsXG4gIG5hbWU6ICdQcm94eUluZGV4Tm9kZScsXG4gIGV4dGVuZHM6ICdmb2FtLmRhby5pbmRleC5JbmRleE5vZGUnLFxuXG4gIHByb3BlcnRpZXM6IFtcbiAgICB7XG4gICAgICBjbGFzczogJ1NpbXBsZScsXG4gICAgICBuYW1lOiAnZGVsZWdhdGUnLFxuICAgIH0sXG4gIF0sXG5cbiAgbWV0aG9kczogW1xuICAgIGZ1bmN0aW9uIGluaXQoKSB7XG4gICAgICB0aGlzLmRlbGVnYXRlID0gdGhpcy5kZWxlZ2F0ZSB8fCB0aGlzLmluZGV4LmRlbGVnYXRlLmNyZWF0ZU5vZGUoKTtcbiAgICB9LFxuXG4gICAgZnVuY3Rpb24gcHV0KG8pIHsgcmV0dXJuIHRoaXMuZGVsZWdhdGUucHV0KG8pOyB9LFxuXG4gICAgZnVuY3Rpb24gcmVtb3ZlKG8pIHsgcmV0dXJuIHRoaXMuZGVsZWdhdGUucmVtb3ZlKG8pOyB9LFxuXG4gICAgZnVuY3Rpb24gcGxhbihzaW5rLCBza2lwLCBsaW1pdCwgb3JkZXIsIHByZWRpY2F0ZSwgcm9vdCkge1xuICAgICAgcmV0dXJuIHRoaXMuZGVsZWdhdGUucGxhbihzaW5rLCBza2lwLCBsaW1pdCwgb3JkZXIsIHByZWRpY2F0ZSwgcm9vdCk7XG4gICAgfSxcblxuICAgIGZ1bmN0aW9uIGdldChrZXkpIHsgcmV0dXJuIHRoaXMuZGVsZWdhdGUuZ2V0KGtleSk7IH0sXG5cbiAgICBmdW5jdGlvbiBzaXplKCkgeyByZXR1cm4gdGhpcy5kZWxlZ2F0ZS5zaXplKCk7IH0sXG5cbiAgICBmdW5jdGlvbiBzZWxlY3Qoc2luaywgc2tpcCwgbGltaXQsIG9yZGVyLCBwcmVkaWNhdGUsIGNhY2hlKSB7XG4gICAgICByZXR1cm4gdGhpcy5kZWxlZ2F0ZS5zZWxlY3Qoc2luaywgc2tpcCwgbGltaXQsIG9yZGVyLCBwcmVkaWNhdGUsIGNhY2hlKTtcbiAgICB9LFxuXG4gICAgZnVuY3Rpb24gYnVsa0xvYWQoZGFvKSB7IHJldHVybiB0aGlzLmRlbGVnYXRlLmJ1bGtMb2FkKGRhbyk7IH0sXG5cbiAgXVxufSk7XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbi8qKlxuICBQcm92aWRlcyBmb3IgaGV0ZXJnZW5pb3VzIGluZGV4ZXMsIHdoZXJlIG5vdCBhbGwgcG90ZW50aWFsIGRlbGVnYXRlc1xuICBvZiB0aGlzIEFsdEluZGV4IGFjdHVhbGx5IGdldCBwb3B1bGF0ZWQgZm9yIGVhY2ggaW5zdGFuY2UuIEVhY2ggaW5zdGFuY2VcbiAgYWx3YXlzIHBvcHVsYXRlcyBhbiBJRCBpbmRleCwgc28gaXQgY2FuIHNlcnZlIHF1ZXJpZXMgZXZlbiBpZiBub1xuICBkZWxlZ2F0ZSBpbmRleGVzIGFyZSBleHBsaWNpdGx5IGFkZGVkLlxuXG4gIEluZGV4OiBBbHRbSUQsIFRyZWVBLCBUcmVlQl1cbiAgSW5kZXhOb2RlczogW2lkLCBhLGJdLCBbaWQsIGFdLCBbaWQsIGJdLCBbaWQsIGFdLCBbaWRdXG4qL1xuZm9hbS5DTEFTUyh7XG4gIHBhY2thZ2U6ICdmb2FtLmRhby5pbmRleCcsXG4gIG5hbWU6ICdBbHRJbmRleCcsXG4gIGV4dGVuZHM6ICdmb2FtLmRhby5pbmRleC5JbmRleCcsXG5cbiAgcmVxdWlyZXM6IFtcbiAgICAnZm9hbS5kYW8uQW5vbnltb3VzU2luaycsXG4gICAgJ2ZvYW0uZGFvLmluZGV4Lk5vUGxhbicsXG4gICAgJ2ZvYW0ubWxhbmcuc2luay5OdWxsU2luaycsXG4gIF0sXG5cbiAgY29uc3RhbnRzOiB7XG4gICAgLyoqIE1heGltdW0gY29zdCBmb3IgYSBwbGFuIHdoaWNoIGlzIGdvb2QgZW5vdWdoIHRvIG5vdCBib3RoZXIgbG9va2luZyBhdCB0aGUgcmVzdC4gKi9cbiAgICBHT09EX0VOT1VHSF9QTEFOOiAxMCAvLyBwdXQgdG8gMTAgb3IgbW9yZSB3aGVuIG5vdCB0ZXN0aW5nXG4gIH0sXG5cbiAgcHJvcGVydGllczogW1xuICAgIHtcbiAgICAgIC8qKiBkZWxlZ2F0ZSBmYWN0b3JpZXMgKi9cbiAgICAgIG5hbWU6ICdkZWxlZ2F0ZXMnLFxuICAgICAgZmFjdG9yeTogZnVuY3Rpb24oKSB7IHJldHVybiBbXTsgfVxuICAgIH0sXG4gICAge1xuICAgICAgLyoqIGZhY3RvcnkgcXVpY2sgbG9va3VwICovXG4gICAgICBuYW1lOiAnZGVsZWdhdGVNYXBfJyxcbiAgICAgIGZhY3Rvcnk6IGZ1bmN0aW9uKCkgeyByZXR1cm4ge307IH1cbiAgICB9LFxuICBdLFxuXG4gIG1ldGhvZHM6IFtcblxuICAgIC8qKiBSZXR1cm5zIHNtYWxsZXN0IGVzdGltYXRlIGZyb20gdGhlIGRlbGVnYXRlcyAqL1xuICAgIGZ1bmN0aW9uIGVzdGltYXRlKHNpemUsIHNpbmssIHNraXAsIGxpbWl0LCBvcmRlciwgcHJlZGljYXRlKSB7XG4gICAgICB2YXIgY29zdCA9IE51bWJlci5NQVhfVkFMVUU7XG4gICAgICBmb3IgKCB2YXIgaSA9IDA7IGkgPCB0aGlzLmRlbGVnYXRlcy5sZW5ndGg7IGkrKyApIHtcbiAgICAgICAgY29zdCA9IE1hdGgubWluKFxuICAgICAgICAgIGNvc3QsXG4gICAgICAgICAgdGhpcy5kZWxlZ2F0ZXNbaV0uZXN0aW1hdGUoXG4gICAgICAgICAgICBzaXplLCBzaW5rLCBza2lwLCBsaW1pdCwgb3JkZXIsIHByZWRpY2F0ZSlcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjb3N0O1xuICAgIH0sXG5cbiAgICBmdW5jdGlvbiB0b1ByZXR0eVN0cmluZyhpbmRlbnQpIHtcbiAgICAgIHZhciByZXQgPSBcIlwiO1xuICAgICAgZm9yICggdmFyIGkgPSAwOyBpIDwgdGhpcy5kZWxlZ2F0ZXMubGVuZ3RoOyBpKysgKSB7XG4gICAgICAgICAgcmV0ICs9IHRoaXMuZGVsZWdhdGVzW2ldLnRvUHJldHR5U3RyaW5nKGluZGVudCArIDEpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJldDtcbiAgICB9LFxuXG4gICAgZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgICByZXR1cm4gJ0FsdChbJyArICh0aGlzLmRlbGVnYXRlcy5qb2luKCcsJykpICsgJ10pJztcbiAgICB9LFxuICBdXG59KTtcblxuZm9hbS5DTEFTUyh7XG4gIHBhY2thZ2U6ICdmb2FtLmRhby5pbmRleCcsXG4gIG5hbWU6ICdBbHRJbmRleE5vZGUnLFxuICBleHRlbmRzOiAnZm9hbS5kYW8uaW5kZXguSW5kZXhOb2RlJyxcblxuICBwcm9wZXJ0aWVzOiBbXG4gICAge1xuICAgICAgLyoqIHRoZSBkZWxlZ2F0ZSBpbnN0YW5jZXMgZm9yIGVhY2ggQWx0IGluc3RhbmNlICovXG4gICAgICBjbGFzczogJ1NpbXBsZScsXG4gICAgICBuYW1lOiAnZGVsZWdhdGVzJ1xuICAgIH0sXG4gIF0sXG5cbiAgbWV0aG9kczogW1xuICAgIGZ1bmN0aW9uIGluaXQoKSB7XG4gICAgICB0aGlzLmRlbGVnYXRlcyA9IHRoaXMuZGVsZWdhdGVzIHx8IFsgdGhpcy5pbmRleC5kZWxlZ2F0ZXNbMF0uY3JlYXRlTm9kZSgpIF07XG4gICAgfSxcblxuICAgIGZ1bmN0aW9uIGFkZEluZGV4KGluZGV4KSB7XG4gICAgICAvLyBjaGVjayBmb3IgZXhpc3RpbmcgZmFjdG9yeVxuICAgICAgdmFyIGRmbWFwID0gdGhpcy5pbmRleC5kZWxlZ2F0ZU1hcF87XG4gICAgICB2YXIgaW5kZXhLZXkgPSBpbmRleC50b1N0cmluZygpO1xuICAgICAgaWYgKCAhIGRmbWFwW2luZGV4S2V5XSApIHtcbiAgICAgICAgdGhpcy5pbmRleC5kZWxlZ2F0ZXMucHVzaChpbmRleCk7XG4gICAgICAgIGRmbWFwW2luZGV4S2V5XSA9IGluZGV4O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gZW5zdXJlIGFsbCB0YWlscyBhcmUgdXNpbmcgdGhlIHNhbWUgZmFjdG9yeSBpbnN0YW5jZVxuICAgICAgICBpbmRleCA9IGRmbWFwW2luZGV4S2V5XTtcbiAgICAgIH1cblxuICAgICAgdmFyIG5ld1N1Ykluc3QgPSBpbmRleC5jcmVhdGVOb2RlKCk7XG4gICAgICB2YXIgd3JhcHBlZCA9IHRoaXMuaW5kZXguQW5vbnltb3VzU2luay5jcmVhdGUoeyBzaW5rOiBuZXdTdWJJbnN0IH0pO1xuICAgICAgdGhpcy5kZWxlZ2F0ZXNbMF0ucGxhbih3cmFwcGVkKS5leGVjdXRlKFtdLCB3cmFwcGVkKTtcbiAgICAgIHRoaXMuZGVsZWdhdGVzLnB1c2gobmV3U3ViSW5zdCk7XG4gICAgfSxcblxuICAgIGZ1bmN0aW9uIGJ1bGtMb2FkKGEpIHtcbiAgICAgIGZvciAoIHZhciBpID0gMCA7IGkgPCB0aGlzLmRlbGVnYXRlcy5sZW5ndGggOyBpKysgKSB7XG4gICAgICAgIHRoaXMuZGVsZWdhdGVzW2ldLmJ1bGtMb2FkKGEpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBmdW5jdGlvbiBnZXQoa2V5KSB7XG4gICAgICByZXR1cm4gdGhpcy5kZWxlZ2F0ZXNbMF0uZ2V0KGtleSk7XG4gICAgfSxcblxuICAgIGZ1bmN0aW9uIHBpY2tEZWxlZ2F0ZShvcmRlciwgY2FjaGUpIHtcbiAgICAgIC8vIE5PVEU6IHRoaXMgYXNzdW1lcyBvbmUgb2YgdGhlIGRlbGVnYXRlcyBpcyBjYXBhYmxlIG9mIG9yZGVyaW5nXG4gICAgICAvLyAgcHJvcGVybHkgZm9yIGEgc2Nhbi4gV2Ugc2hvdWxkIG5vdCBiZSBhc2tlZCBmb3IgYSBzZWxlY3QgdW5sZXNzXG4gICAgICAvLyAgYSBwcmV2aW91cyBlc3RpbWF0ZSBpbmRpY2F0ZWQgb25lIG9mIG91ciBvcHRpb25zIHdhcyBzb3J0ZWQgcHJvcGVybHkuXG4gICAgICAvLyBOT1RFOiB1bmJ1aWx0IHBvcnRpb25zIG9mIHRoZSBpbmRleCB3aWxsIGJlIGJ1aWx0IGltbWVkaWF0ZWx5XG4gICAgICAvLyAgaWYgcGlja2VkIGZvciBvcmRlcmluZy5cbiAgICAgIHZhciBkZWxlZ2F0ZXMgPSB0aGlzLmRlbGVnYXRlcztcbiAgICAgIGlmICggISBvcmRlciApIHJldHVybiBkZWxlZ2F0ZXNbMF07XG5cbiAgICAgIHZhciBjID0gY2FjaGVbdGhpc107XG4gICAgICAvLyBpZiBubyBjYWNoZWQgaW5kZXggZXN0aW1hdGVzLCBnZW5lcmF0ZSBlc3RpbWF0ZXNcbiAgICAgIC8vIGZvciBlYWNoIGZhY3RvcnkgZm9yIHRoaXMgb3JkZXJpbmdcbiAgICAgIGlmICggISBjICkge1xuICAgICAgICB2YXIgbnVsbFNpbmsgPSB0aGlzLmluZGV4Lk51bGxTaW5rLmNyZWF0ZSgpO1xuICAgICAgICB2YXIgZGZzID0gdGhpcy5pbmRleC5kZWxlZ2F0ZXM7XG4gICAgICAgIHZhciBiZXN0RXN0ID0gTnVtYmVyLk1BWF9WQUxVRTtcbiAgICAgICAgLy8gUGljayB0aGUgYmVzdCBmYWN0b3J5IGZvciB0aGUgb3JkZXJpbmcsIGNhY2hlIGl0XG4gICAgICAgIGZvciAoIHZhciBpID0gMDsgaSA8IGRmcy5sZW5ndGg7IGkrKyApIHtcbiAgICAgICAgICB2YXIgZXN0ID0gZGZzW2ldLmVzdGltYXRlKDEwMDAsIG51bGxTaW5rLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgb3JkZXIpO1xuICAgICAgICAgIGlmICggZXN0IDwgYmVzdEVzdCApIHtcbiAgICAgICAgICAgIGMgPSBkZnNbaV07XG4gICAgICAgICAgICBiZXN0RXN0ID0gZXN0O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYWNoZVt0aGlzXSA9IGM7XG4gICAgICB9XG5cbiAgICAgIC8vIGNoZWNrIGlmIHdlIGhhdmUgYSBkZWxlZ2F0ZSBpbnN0YW5jZSBmb3IgdGhlIGJlc3QgZmFjdG9yeVxuICAgICAgZm9yICggdmFyIGkgPSAwOyBpIDwgZGVsZWdhdGVzLmxlbmd0aDsgaSsrICkge1xuICAgICAgICAvLyBpZiB3ZSBkbywgaXQncyB0aGUgYmVzdCBvbmVcbiAgICAgICAgaWYgKCBkZWxlZ2F0ZXNbaV0uaW5kZXggPT09IGMgKSByZXR1cm4gZGVsZWdhdGVzW2ldO1xuICAgICAgfVxuXG4gICAgICAvLyB3ZSBkaWRuJ3QgaGF2ZSB0aGUgcmlnaHQgZGVsZWdhdGUgZ2VuZXJhdGVkLCBzbyBhZGQgYW5kIHBvcHVsYXRlIGl0XG4gICAgICAvLyBhcyBwZXIgYWRkSW5kZXgsIGJ1dCB3ZSBza2lwIGNoZWNraW5nIHRoZSBmYWN0b3J5IGFzIHdlIGtub3cgaXQncyBzdG9yZWRcbiAgICAgIHZhciBuZXdTdWJJbnN0ID0gYy5jcmVhdGVOb2RlKCk7XG4gICAgICB2YXIgd3JhcHBlZCA9IHRoaXMuaW5kZXguQW5vbnltb3VzU2luay5jcmVhdGUoeyBzaW5rOiBuZXdTdWJJbnN0IH0pO1xuICAgICAgdGhpcy5kZWxlZ2F0ZXNbMF0ucGxhbih3cmFwcGVkKS5leGVjdXRlKFtdLCB3cmFwcGVkKTtcbiAgICAgIHRoaXMuZGVsZWdhdGVzLnB1c2gobmV3U3ViSW5zdCk7XG5cbiAgICAgIHJldHVybiBuZXdTdWJJbnN0O1xuICAgIH0sXG5cblxuICAgIGZ1bmN0aW9uIHNlbGVjdChzaW5rLCBza2lwLCBsaW1pdCwgb3JkZXIsIHByZWRpY2F0ZSwgY2FjaGUpIHtcbiAgICAgIC8vIGZpbmQgYW5kIGNhY2hlIHRoZSBjb3JyZWN0IHN1YmluZGV4IHRvIHVzZVxuICAgICAgdGhpcy5waWNrRGVsZWdhdGUob3JkZXIsIGNhY2hlKVxuICAgICAgICAuc2VsZWN0KHNpbmssIHNraXAsIGxpbWl0LCBvcmRlciwgcHJlZGljYXRlLCBjYWNoZSk7XG4gICAgfSxcblxuICAgIGZ1bmN0aW9uIHB1dChuZXdWYWx1ZSkge1xuICAgICAgZm9yICggdmFyIGkgPSAwIDsgaSA8IHRoaXMuZGVsZWdhdGVzLmxlbmd0aCA7IGkrKyApIHtcbiAgICAgICAgdGhpcy5kZWxlZ2F0ZXNbaV0ucHV0KG5ld1ZhbHVlKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgZnVuY3Rpb24gcmVtb3ZlKG9iaikge1xuICAgICAgZm9yICggdmFyIGkgPSAwIDsgaSA8IHRoaXMuZGVsZWdhdGVzLmxlbmd0aCA7IGkrKyApIHtcbiAgICAgICAgdGhpcy5kZWxlZ2F0ZXNbaV0ucmVtb3ZlKG9iaik7XG4gICAgICB9XG4gICAgfSxcblxuICAgIGZ1bmN0aW9uIHBsYW4oc2luaywgc2tpcCwgbGltaXQsIG9yZGVyLCBwcmVkaWNhdGUsIHJvb3QpIHtcbiAgICAgIHZhciBiZXN0UGxhbjtcbiAgICAgIGZvciAoIHZhciBpID0gMCA7IGkgPCB0aGlzLmRlbGVnYXRlcy5sZW5ndGggOyBpKysgKSB7XG4gICAgICAgIHZhciBwID0gdGhpcy5kZWxlZ2F0ZXNbaV0ucGxhbihzaW5rLCBza2lwLCBsaW1pdCwgb3JkZXIsIHByZWRpY2F0ZSwgcm9vdCk7XG4gICAgICAgIGlmICggcC5jb3N0IDw9IHRoaXMuaW5kZXguR09PRF9FTk9VR0hfUExBTiApIHtcbiAgICAgICAgICBiZXN0UGxhbiA9IHA7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCAhIGJlc3RQbGFuIHx8IHAuY29zdCA8IGJlc3RQbGFuLmNvc3QgKSB7XG4gICAgICAgICAgYmVzdFBsYW4gPSBwO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoICEgYmVzdFBsYW4gKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmluZGV4Lk5vUGxhbi5jcmVhdGUoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBiZXN0UGxhbjtcbiAgICB9LFxuXG4gICAgZnVuY3Rpb24gc2l6ZSgpIHsgcmV0dXJuIHRoaXMuZGVsZWdhdGVzWzBdLnNpemUoKTsgfSxcblxuICAgIGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgICAgcmV0dXJuICdBbHQoWycgKyAodGhpcy5pbmRleC5kZWxlZ2F0ZXMuam9pbignLCcpKSArIHRoaXMuc2l6ZSgpICsgJ10pJztcbiAgICB9LFxuICBdXG59KTtcbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDEyIEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbi8qKlxuICBBbiBJbmRleCB3aGljaCBob2xkcyBvbmx5IGEgc2luZ2xlIHZhbHVlLiBUaGlzIGNsYXNzIGFsc28gZnVuY3Rpb25zIGFzIGl0c1xuICBvd24gZXhlY3V0aW9uIFBsYW4sIHNpbmNlIGl0IG9ubHkgaGFzIHRvIHJldHVybiB0aGUgc2luZ2xlIHZhbHVlLlxuKiovXG5mb2FtLkNMQVNTKHtcbiAgcGFja2FnZTogJ2ZvYW0uZGFvLmluZGV4JyxcbiAgbmFtZTogJ1ZhbHVlSW5kZXgnLFxuICBleHRlbmRzOiAnZm9hbS5kYW8uaW5kZXguSW5kZXgnLFxuXG4gIG1ldGhvZHM6IFtcbiAgICBmdW5jdGlvbiBlc3RpbWF0ZShzaXplLCBzaW5rLCBza2lwLCBsaW1pdCwgb3JkZXIsIHByZWRpY2F0ZSkge1xuICAgICAgcmV0dXJuIDE7XG4gICAgfSxcblxuICAgIGZ1bmN0aW9uIHRvUHJldHR5U3RyaW5nKGluZGVudCkge1xuICAgICAgcmV0dXJuICcnO1xuICAgIH1cbiAgXVxufSk7XG5cblxuZm9hbS5DTEFTUyh7XG4gIHBhY2thZ2U6ICdmb2FtLmRhby5pbmRleCcsXG4gIG5hbWU6ICdWYWx1ZUluZGV4Tm9kZScsXG4gIGV4dGVuZHM6ICdmb2FtLmRhby5pbmRleC5JbmRleE5vZGUnLFxuXG4gIGltcGxlbWVudHM6IFsgJ2ZvYW0uZGFvLmluZGV4LlBsYW4nIF0sXG5cbiAgcHJvcGVydGllczogW1xuICAgIHsgY2xhc3M6ICdTaW1wbGUnLCBuYW1lOiAndmFsdWUnIH0sXG4gICAgeyBjbGFzczogJ1NpbXBsZScsIG5hbWU6ICdjb3N0JyB9XG4gIF0sXG5cbiAgbWV0aG9kczogW1xuICAgIC8vIGZyb20gcGxhblxuICAgIGZ1bmN0aW9uIGV4ZWN1dGUocHJvbWlzZSwgc2luaywgc2tpcCwgbGltaXQsIG9yZGVyLCBwcmVkaWNhdGUpIHtcbiAgICAgIC8qKiBOb3RlIHRoYXQgdGhpcyB3aWxsIHB1dCh1bmRlZmluZWQpIGlmIHlvdSByZW1vdmUoKSB0aGUgaXRlbSBidXRcbiAgICAgICAgbGVhdmUgdGhpcyBWYWx1ZUluZGV4IGludGFjdC4gVXNhZ2VzIG9mIFZhbHVlSW5kZXggc2hvdWxkIGNsZWFuIHVwXG4gICAgICAgIHRoZSBWYWx1ZUluZGV4IGl0c2VsZiB3aGVuIHRoZSB2YWx1ZSBpcyByZW1vdmVkLiAqL1xuICAgICAgdGhpcy5zZWxlY3Qoc2luaywgc2tpcCwgbGltaXQsIG9yZGVyLCBwcmVkaWNhdGUpO1xuICAgIH0sXG5cbiAgICBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICAgIHJldHVybiAnVmFsdWVJbmRleF9QbGFuKGNvc3Q9MSwgdmFsdWU6JyArIHRoaXMudmFsdWUgKyAnKSc7XG4gICAgfSxcblxuICAgIC8vIGZyb20gSW5kZXhcbiAgICBmdW5jdGlvbiBwdXQocykgeyB0aGlzLnZhbHVlID0gczsgfSxcbiAgICBmdW5jdGlvbiByZW1vdmUoKSB7IHRoaXMudmFsdWUgPSB1bmRlZmluZWQ7IH0sXG4gICAgZnVuY3Rpb24gZ2V0KCkgeyByZXR1cm4gdGhpcy52YWx1ZTsgfSxcbiAgICBmdW5jdGlvbiBzaXplKCkgeyByZXR1cm4gdHlwZW9mIHRoaXMudmFsdWUgPT09ICd1bmRlZmluZWQnID8gMCA6IDE7IH0sXG4gICAgZnVuY3Rpb24gcGxhbigpIHsgdGhpcy5jb3N0ID0gMTsgcmV0dXJuIHRoaXM7IH0sXG5cbiAgICBmdW5jdGlvbiBzZWxlY3Qoc2luaywgc2tpcCwgbGltaXQsIG9yZGVyLCBwcmVkaWNhdGUsIGNhY2hlKSB7XG4gICAgICBpZiAoIHByZWRpY2F0ZSAmJiAhIHByZWRpY2F0ZS5mKHRoaXMudmFsdWUpICkgcmV0dXJuO1xuICAgICAgaWYgKCBza2lwICYmIHNraXBbMF0tLSA+IDAgKSByZXR1cm47XG4gICAgICBpZiAoIGxpbWl0ICYmIGxpbWl0WzBdLS0gPD0gMCApIHJldHVybjtcbiAgICAgIHNpbmsucHV0KHRoaXMudmFsdWUpO1xuICAgIH0sXG4gIF1cbn0pO1xuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTIgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuLyoqXG4gIFJlcHJlc2VudHMgb25lIG5vZGUncyBzdGF0ZSBpbiBhIGJpbmFyeSB0cmVlLiBFYWNoIHRyZWUgb3BlcmF0aW9uXG4gIGNhbiByZWJhbGFuY2UgdGhlIHN1YnRyZWUgb3IgY3JlYXRlIGEgbmV3IG5vZGUsIHNvIHRob3NlIG1ldGhvZHNcbiAgcmV0dXJuIGEgdHJlZSBub2RlIHJlZmVyZW5jZSB0byByZXBsYWNlIHRoZSBvbmUgY2FsbGVkLiBJdCBtYXkgYmUgdGhlXG4gIHNhbWUgbm9kZSwgYSBkaWZmZXJlbnQgZXhpc3Rpbmcgbm9kZSwgb3IgYSBuZXcgbm9kZS5cbiAgPHA+XG4gIDxjb2RlPlxuICAgIC8vIHJlcGxhY2Ugcy5yaWdodCB3aXRoIHJlc3VsdCBvZiBvcGVyYXRpb25zIG9uIHMucmlnaHRcbiAgICBzLnJpZ2h0ID0gcy5yaWdodC5tYXliZUNsb25lKGxvY2tlZCkuc3BsaXQobG9ja2VkKTtcbiAgPC9jb2RlPlxuKi9cbmZvYW0uQ0xBU1Moe1xuICBwYWNrYWdlOiAnZm9hbS5kYW8uaW5kZXgnLFxuICBuYW1lOiAnVHJlZU5vZGUnLFxuXG4gIHByb3BlcnRpZXM6IFtcbiAgICAvLyBwZXIgbm9kZSBwcm9wZXJ0aWVzXG4gICAgeyBjbGFzczogJ1NpbXBsZScsIG5hbWU6ICdrZXknICAgfSxcbiAgICB7IGNsYXNzOiAnU2ltcGxlJywgbmFtZTogJ3ZhbHVlJyB9LFxuICAgIHsgY2xhc3M6ICdTaW1wbGUnLCBuYW1lOiAnc2l6ZScgIH0sXG4gICAgeyBjbGFzczogJ1NpbXBsZScsIG5hbWU6ICdsZXZlbCcgfSxcbiAgICB7IGNsYXNzOiAnU2ltcGxlJywgbmFtZTogJ2xlZnQnICB9LFxuICAgIHsgY2xhc3M6ICdTaW1wbGUnLCBuYW1lOiAncmlnaHQnIH1cbiAgXSxcblxuICBtZXRob2RzOiBbXG5cbiAgICAvKipcbiAgICAgICBDbG9uZSBpcyBvbmx5IG5lZWRlZCBpZiBhIHNlbGVjdCgpIGlzIGFjdGl2ZSBpbiB0aGUgdHJlZSBhdCB0aGVcbiAgICAgICBzYW1lIHRpbWUgd2UgYXJlIHVwZGF0aW5nIGl0LlxuICAgICovXG4gICAgZnVuY3Rpb24gbWF5YmVDbG9uZShsb2NrZWQpIHtcbiAgICAgIHJldHVybiBsb2NrZWQgPyB0aGlzLmNsb25lKCkgOiB0aGlzO1xuICAgIH0sXG5cbiAgICBmdW5jdGlvbiBjbG9uZSgpIHtcbiAgICAgIHZhciBjID0gdGhpcy5jbHNfLmNyZWF0ZSgpO1xuICAgICAgYy5rZXkgICA9IHRoaXMua2V5O1xuICAgICAgYy52YWx1ZSA9IHRoaXMudmFsdWU7XG4gICAgICBjLnNpemUgID0gdGhpcy5zaXplO1xuICAgICAgYy5sZXZlbCA9IHRoaXMubGV2ZWw7XG4gICAgICBjLmxlZnQgID0gdGhpcy5sZWZ0O1xuICAgICAgYy5yaWdodCA9IHRoaXMucmlnaHQ7XG4gICAgICByZXR1cm4gYztcbiAgICB9LFxuXG4gICAgZnVuY3Rpb24gdXBkYXRlU2l6ZSgpIHtcbiAgICAgIHRoaXMuc2l6ZSA9IHRoaXMubGVmdC5zaXplICsgdGhpcy5yaWdodC5zaXplICsgdGhpcy52YWx1ZS5zaXplKCk7XG4gICAgfSxcblxuICAgIC8qKiBAcmV0dXJuIEFub3RoZXIgbm9kZSByZXByZXNlbnRpbmcgdGhlIHJlYmFsYW5jZWQgQUEgdHJlZS4gKi9cbiAgICBmdW5jdGlvbiBza2V3KGxvY2tlZCkge1xuICAgICAgaWYgKCB0aGlzLmxlZnQubGV2ZWwgPT09IHRoaXMubGV2ZWwgKSB7XG4gICAgICAgIC8vIFN3YXAgdGhlIHBvaW50ZXJzIG9mIGhvcml6b250YWwgbGVmdCBsaW5rcy5cbiAgICAgICAgdmFyIGwgPSB0aGlzLmxlZnQubWF5YmVDbG9uZShsb2NrZWQpO1xuXG4gICAgICAgIHRoaXMubGVmdCA9IGwucmlnaHQ7XG4gICAgICAgIGwucmlnaHQgPSB0aGlzO1xuXG4gICAgICAgIHRoaXMudXBkYXRlU2l6ZSgpO1xuICAgICAgICBsLnVwZGF0ZVNpemUoKTtcblxuICAgICAgICByZXR1cm4gbDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKiBAcmV0dXJuIGEgbm9kZSByZXByZXNlbnRpbmcgdGhlIHJlYmFsYW5jZWQgQUEgdHJlZS4gKi9cbiAgICBmdW5jdGlvbiBzcGxpdChsb2NrZWQpIHtcbiAgICAgIGlmIChcbiAgICAgICAgICB0aGlzLnJpZ2h0LmxldmVsICAgICAgICYmXG4gICAgICAgICAgdGhpcy5yaWdodC5yaWdodC5sZXZlbCAmJlxuICAgICAgICAgIHRoaXMubGV2ZWwgPT09IHRoaXMucmlnaHQucmlnaHQubGV2ZWxcbiAgICAgICkge1xuICAgICAgICAvLyBXZSBoYXZlIHR3byBob3Jpem9udGFsIHJpZ2h0IGxpbmtzLlxuICAgICAgICAvLyBUYWtlIHRoZSBtaWRkbGUgbm9kZSwgZWxldmF0ZSBpdCwgYW5kIHJldHVybiBpdC5cbiAgICAgICAgdmFyIHIgPSB0aGlzLnJpZ2h0Lm1heWJlQ2xvbmUobG9ja2VkKTtcblxuICAgICAgICB0aGlzLnJpZ2h0ID0gci5sZWZ0O1xuICAgICAgICByLmxlZnQgPSB0aGlzO1xuICAgICAgICByLmxldmVsKys7XG5cbiAgICAgICAgdGhpcy51cGRhdGVTaXplKCk7XG4gICAgICAgIHIudXBkYXRlU2l6ZSgpO1xuXG4gICAgICAgIHJldHVybiByO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgZnVuY3Rpb24gcHJlZGVjZXNzb3IoKSB7XG4gICAgICBpZiAoICEgdGhpcy5sZWZ0LmxldmVsICkgcmV0dXJuIHRoaXM7XG4gICAgICBmb3IgKCB2YXIgcyA9IHRoaXMubGVmdCA7IHMucmlnaHQubGV2ZWwgOyBzID0gcy5yaWdodCApIHt9XG4gICAgICByZXR1cm4gcztcbiAgICB9LFxuXG4gICAgZnVuY3Rpb24gc3VjY2Vzc29yKCkge1xuICAgICAgaWYgKCAhIHRoaXMucmlnaHQubGV2ZWwgKSByZXR1cm4gdGhpcztcbiAgICAgIGZvciAoIHZhciBzID0gdGhpcy5yaWdodCA7IHMubGVmdC5sZXZlbCA7IHMgPSBzLmxlZnQgKSB7fVxuICAgICAgcmV0dXJuIHM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAgIFJlbW92ZXMgbGlua3MgdGhhdCBza2lwIGxldmVscy5cbiAgICAgICBAcmV0dXJuIHRoZSB0cmVlIHdpdGggaXRzIGxldmVsIGRlY3JlYXNlZC5cbiAgICAqL1xuICAgIGZ1bmN0aW9uIGRlY3JlYXNlTGV2ZWwobG9ja2VkKSB7XG4gICAgICB2YXIgZXhwZWN0ZWRMZXZlbCA9IE1hdGgubWluKFxuICAgICAgICAgIHRoaXMubGVmdC5sZXZlbCAgPyB0aGlzLmxlZnQubGV2ZWwgIDogMCxcbiAgICAgICAgICB0aGlzLnJpZ2h0LmxldmVsID8gdGhpcy5yaWdodC5sZXZlbCA6IDApICsgMTtcblxuICAgICAgaWYgKCBleHBlY3RlZExldmVsIDwgdGhpcy5sZXZlbCApIHtcbiAgICAgICAgdGhpcy5sZXZlbCA9IGV4cGVjdGVkTGV2ZWw7XG4gICAgICAgIGlmICggdGhpcy5yaWdodC5sZXZlbCAmJiBleHBlY3RlZExldmVsIDwgdGhpcy5yaWdodC5sZXZlbCApIHtcbiAgICAgICAgICB0aGlzLnJpZ2h0ID0gdGhpcy5yaWdodC5tYXliZUNsb25lKGxvY2tlZCk7XG4gICAgICAgICAgdGhpcy5yaWdodC5sZXZlbCA9IGV4cGVjdGVkTGV2ZWw7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKiBleHRyYWN0cyB0aGUgdmFsdWUgd2l0aCB0aGUgZ2l2ZW4ga2V5IGZyb20gdGhlIGluZGV4ICovXG4gICAgZnVuY3Rpb24gZ2V0KGtleSwgY29tcGFyZSkge1xuICAgICAgdmFyIHIgPSBjb21wYXJlKHRoaXMua2V5LCBrZXkpO1xuXG4gICAgICBpZiAoIHIgPT09IDAgKSByZXR1cm4gdGhpcy52YWx1ZTsgLy8gVE9ETy4uLiB0YWlsLmdldCh0aGlzLnZhbHVlKSA/Pz9cblxuICAgICAgcmV0dXJuIHIgPiAwID8gdGhpcy5sZWZ0LmdldChrZXksIGNvbXBhcmUpIDogdGhpcy5yaWdodC5nZXQoa2V5LCBjb21wYXJlKTtcbiAgICB9LFxuXG4gICAgLyoqIHNjYW5zIHRoZSBlbnRpcmUgdHJlZSBhbmQgcmV0dXJucyBhbGwgbWF0Y2hlcyAqL1xuICAgIGZ1bmN0aW9uIGdldEFsbChrZXksIGNvbXBhcmUsIHJldEFycmF5KSB7XG4gICAgICB2YXIgciA9IGNvbXBhcmUodGhpcy5rZXksIGtleSk7XG5cbiAgICAgIGlmICggciA9PT0gMCApIHJldEFycmF5LnB1c2godGhpcy52YWx1ZSk7XG5cbiAgICAgIHRoaXMubGVmdC5nZXRBbGwoa2V5LCBjb21wYXJlLCByZXRBcnJheSk7XG4gICAgICB0aGlzLnJpZ2h0LmdldEFsbChrZXksIGNvbXBhcmUsIHJldEFycmF5KTtcbiAgICB9LFxuXG4gICAgZnVuY3Rpb24gcHV0S2V5VmFsdWUoa2V5LCB2YWx1ZSwgY29tcGFyZSwgZGVkdXAsIGxvY2tlZCkge1xuICAgICAgdmFyIHMgPSB0aGlzLm1heWJlQ2xvbmUobG9ja2VkKTtcblxuICAgICAgdmFyIHIgPSBjb21wYXJlKHMua2V5LCBrZXkpO1xuXG4gICAgICBpZiAoIHIgPT09IDAgKSB7XG4gICAgICAgIGRlZHVwKHZhbHVlLCBzLmtleSk7XG5cbiAgICAgICAgcy5zaXplIC09IHMudmFsdWUuc2l6ZSgpO1xuICAgICAgICBzLnZhbHVlLnB1dCh2YWx1ZSk7XG4gICAgICAgIHMuc2l6ZSArPSBzLnZhbHVlLnNpemUoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBzaWRlID0gciA+IDAgPyAnbGVmdCcgOiAncmlnaHQnO1xuXG4gICAgICAgIGlmICggc1tzaWRlXS5sZXZlbCApIHMuc2l6ZSAtPSBzW3NpZGVdLnNpemU7XG4gICAgICAgIHNbc2lkZV0gPSBzW3NpZGVdLnB1dEtleVZhbHVlKGtleSwgdmFsdWUsIGNvbXBhcmUsIGRlZHVwLCBsb2NrZWQpO1xuICAgICAgICBzLnNpemUgKz0gc1tzaWRlXS5zaXplO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcy5zcGxpdChsb2NrZWQpLnNrZXcobG9ja2VkKTtcbiAgICB9LFxuXG4gICAgZnVuY3Rpb24gcmVtb3ZlS2V5VmFsdWUoa2V5LCB2YWx1ZSwgY29tcGFyZSwgbG9ja2VkLCBudWxsTm9kZSkge1xuICAgICAgdmFyIHMgPSB0aGlzLm1heWJlQ2xvbmUobG9ja2VkKTtcbiAgICAgIHZhciBzaWRlO1xuICAgICAgdmFyIHIgPSBjb21wYXJlKHMua2V5LCBrZXkpO1xuXG4gICAgICBpZiAoIHIgPT09IDAgKSB7XG4gICAgICAgIHMuc2l6ZSAtPSBzLnZhbHVlLnNpemUoKTtcbiAgICAgICAgcy52YWx1ZS5yZW1vdmUodmFsdWUpO1xuXG4gICAgICAgIC8vIElmIHRoZSBzdWItSW5kZXggc3RpbGwgaGFzIHZhbHVlcywgdGhlbiBkb24ndFxuICAgICAgICAvLyBkZWxldGUgdGhpcyBub2RlLlxuICAgICAgICBpZiAoIHMudmFsdWUgJiYgcy52YWx1ZS5zaXplKCkgPiAwICkge1xuICAgICAgICAgIHMuc2l6ZSArPSBzLnZhbHVlLnNpemUoKTtcbiAgICAgICAgICByZXR1cm4gcztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIElmIHdlJ3JlIGEgbGVhZiwgZWFzeSwgb3RoZXJ3aXNlIHJlZHVjZSB0byBsZWFmIGNhc2UuXG4gICAgICAgIGlmICggISBzLmxlZnQubGV2ZWwgJiYgISBzLnJpZ2h0LmxldmVsICkge1xuICAgICAgICAgIHJldHVybiBudWxsTm9kZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHNpZGUgPSBzLmxlZnQubGV2ZWwgPyAnbGVmdCcgOiAncmlnaHQnO1xuXG4gICAgICAgIC8vIFRPRE86IGl0IHdvdWxkIGJlIGZhc3RlciBpZiBzdWNjZXNzb3IgYW5kIHByZWRlY2Vzc29yIGFsc28gZGVsZXRlZFxuICAgICAgICAvLyB0aGUgZW50cnkgYXQgdGhlIHNhbWUgdGltZSBpbiBvcmRlciB0byBwcmV2ZW50IHR3byB0cmF2ZXJzYWxzLlxuICAgICAgICAvLyBCdXQsIHRoaXMgd291bGQgYWxzbyBkdXBsaWNhdGUgdGhlIGRlbGV0ZSBsb2dpYy5cbiAgICAgICAgdmFyIGwgPSBzaWRlID09PSAnbGVmdCcgP1xuICAgICAgICAgICAgcy5wcmVkZWNlc3NvcigpIDpcbiAgICAgICAgICAgIHMuc3VjY2Vzc29yKCkgICA7XG5cbiAgICAgICAgcy5rZXkgPSBsLmtleTtcbiAgICAgICAgcy52YWx1ZSA9IGwudmFsdWU7XG5cbiAgICAgICAgc1tzaWRlXSA9IHNbc2lkZV0ucmVtb3ZlTm9kZShsLmtleSwgY29tcGFyZSwgbG9ja2VkKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNpZGUgPSByID4gMCA/ICdsZWZ0JyA6ICdyaWdodCc7XG5cbiAgICAgICAgcy5zaXplIC09IHNbc2lkZV0uc2l6ZTtcbiAgICAgICAgc1tzaWRlXSA9IHNbc2lkZV0ucmVtb3ZlS2V5VmFsdWUoa2V5LCB2YWx1ZSwgY29tcGFyZSwgbG9ja2VkLCBudWxsTm9kZSk7XG4gICAgICAgIHMuc2l6ZSArPSBzW3NpZGVdLnNpemU7XG4gICAgICB9XG5cbiAgICAgIC8vIFJlYmFsYW5jZSB0aGUgdHJlZS4gRGVjcmVhc2UgdGhlIGxldmVsIG9mIGFsbCBub2RlcyBpbiB0aGlzIGxldmVsIGlmXG4gICAgICAvLyBuZWNlc3NhcnksIGFuZCB0aGVuIHNrZXcgYW5kIHNwbGl0IGFsbCBub2RlcyBpbiB0aGUgbmV3IGxldmVsLlxuICAgICAgcyA9IHMuZGVjcmVhc2VMZXZlbChsb2NrZWQpLnNrZXcobG9ja2VkKTtcbiAgICAgIGlmICggcy5yaWdodC5sZXZlbCApIHtcbiAgICAgICAgcy5yaWdodCA9IHMucmlnaHQubWF5YmVDbG9uZShsb2NrZWQpLnNrZXcobG9ja2VkKTtcbiAgICAgICAgaWYgKCBzLnJpZ2h0LnJpZ2h0LmxldmVsICkge1xuICAgICAgICAgIHMucmlnaHQucmlnaHQgPSBzLnJpZ2h0LnJpZ2h0Lm1heWJlQ2xvbmUobG9ja2VkKS5za2V3KGxvY2tlZCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcyA9IHMuc3BsaXQobG9ja2VkKTtcbiAgICAgIHMucmlnaHQgPSBzLnJpZ2h0Lm1heWJlQ2xvbmUobG9ja2VkKS5zcGxpdChsb2NrZWQpO1xuXG4gICAgICByZXR1cm4gcztcbiAgICB9LFxuXG4gICAgZnVuY3Rpb24gcmVtb3ZlTm9kZShrZXksIGNvbXBhcmUsIGxvY2tlZCkge1xuICAgICAgdmFyIHMgPSB0aGlzLm1heWJlQ2xvbmUobG9ja2VkKTtcblxuICAgICAgdmFyIHIgPSBjb21wYXJlKHMua2V5LCBrZXkpO1xuXG4gICAgICBpZiAoIHIgPT09IDAgKSByZXR1cm4gcy5sZWZ0LmxldmVsID8gcy5sZWZ0IDogcy5yaWdodDtcblxuICAgICAgdmFyIHNpZGUgPSByID4gMCA/ICdsZWZ0JyA6ICdyaWdodCc7XG5cbiAgICAgIHMuc2l6ZSAtPSBzW3NpZGVdLnNpemU7XG4gICAgICBzW3NpZGVdID0gc1tzaWRlXS5yZW1vdmVOb2RlKGtleSwgY29tcGFyZSwgbG9ja2VkKTtcbiAgICAgIHMuc2l6ZSArPSBzW3NpZGVdLnNpemU7XG5cbiAgICAgIHJldHVybiBzO1xuICAgIH0sXG5cblxuICAgIGZ1bmN0aW9uIHNlbGVjdChzaW5rLCBza2lwLCBsaW1pdCwgb3JkZXIsIHByZWRpY2F0ZSwgY2FjaGUpIHtcbiAgICAgIGlmICggbGltaXQgJiYgbGltaXRbMF0gPD0gMCApIHJldHVybjtcblxuICAgICAgaWYgKCBza2lwICYmIHNraXBbMF0gPj0gdGhpcy5zaXplICYmICEgcHJlZGljYXRlICkge1xuICAgICAgICBza2lwWzBdIC09IHRoaXMuc2l6ZTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmxlZnQuc2VsZWN0KHNpbmssIHNraXAsIGxpbWl0LCBvcmRlciwgcHJlZGljYXRlLCBjYWNoZSk7XG5cbiAgICAgIHRoaXMudmFsdWUuc2VsZWN0KHNpbmssIHNraXAsIGxpbWl0LFxuICAgICAgICBvcmRlciAmJiBvcmRlci5vcmRlclRhaWwoKSwgcHJlZGljYXRlLCBjYWNoZSk7XG5cbiAgICAgIHRoaXMucmlnaHQuc2VsZWN0KHNpbmssIHNraXAsIGxpbWl0LCBvcmRlciwgcHJlZGljYXRlLCBjYWNoZSk7XG4gICAgfSxcblxuXG4gICAgZnVuY3Rpb24gc2VsZWN0UmV2ZXJzZShzaW5rLCBza2lwLCBsaW1pdCwgb3JkZXIsIHByZWRpY2F0ZSwgY2FjaGUpIHtcbiAgICAgIGlmICggbGltaXQgJiYgbGltaXRbMF0gPD0gMCApIHJldHVybjtcblxuICAgICAgaWYgKCBza2lwICYmIHNraXBbMF0gPj0gdGhpcy5zaXplICYmICEgcHJlZGljYXRlICkge1xuICAgICAgICAvL2NvbnNvbGUubG9nKCdyZXZlcnNlIHNraXBwaW5nOiAnLCB0aGlzLmtleSk7XG4gICAgICAgIHNraXBbMF0gLT0gdGhpcy5zaXplO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHRoaXMucmlnaHQuc2VsZWN0UmV2ZXJzZShzaW5rLCBza2lwLCBsaW1pdCwgb3JkZXIsIHByZWRpY2F0ZSwgY2FjaGUpO1xuXG4gICAgICAvLyBzZWxlY3QoKSB3aWxsIHBpY2sgcmV2ZXJzZSBvciBub3QgYmFzZWQgb24gb3JkZXJcbiAgICAgIHRoaXMudmFsdWUuc2VsZWN0KHNpbmssIHNraXAsIGxpbWl0LFxuICAgICAgICBvcmRlciAmJiBvcmRlci5vcmRlclRhaWwoKSwgcHJlZGljYXRlLCBjYWNoZSk7XG5cbiAgICAgIHRoaXMubGVmdC5zZWxlY3RSZXZlcnNlKHNpbmssICBza2lwLCBsaW1pdCwgb3JkZXIsIHByZWRpY2F0ZSwgY2FjaGUpO1xuICAgIH0sXG5cbiAgICBmdW5jdGlvbiBndChrZXksIGNvbXBhcmUpIHtcbiAgICAgIHZhciBzID0gdGhpcztcbiAgICAgIHZhciByID0gY29tcGFyZShrZXksIHMua2V5KTtcblxuICAgICAgaWYgKCByIDwgMCApIHtcbiAgICAgICAgdmFyIGwgPSBzLmxlZnQuZ3Qoa2V5LCBjb21wYXJlKTtcbiAgICAgICAgdmFyIGNvcHkgPSBzLmNsb25lKCk7XG4gICAgICAgIGNvcHkuc2l6ZSA9IHMuc2l6ZSAtIHMubGVmdC5zaXplICsgbC5zaXplO1xuICAgICAgICBjb3B5LmxlZnQgPSBsO1xuICAgICAgICByZXR1cm4gY29weTtcbiAgICAgIH1cblxuICAgICAgaWYgKCByID4gMCApIHJldHVybiBzLnJpZ2h0Lmd0KGtleSwgY29tcGFyZSk7XG5cbiAgICAgIHJldHVybiBzLnJpZ2h0O1xuICAgIH0sXG5cbiAgICBmdW5jdGlvbiBndGUoa2V5LCBjb21wYXJlLCBudWxsTm9kZSkge1xuICAgICAgdmFyIHMgPSB0aGlzO1xuICAgICAgdmFyIGNvcHk7XG4gICAgICB2YXIgciA9IGNvbXBhcmUoa2V5LCBzLmtleSk7XG5cbiAgICAgIGlmICggciA8IDAgKSB7XG4gICAgICAgIHZhciBsID0gcy5sZWZ0Lmd0ZShrZXksIGNvbXBhcmUsIG51bGxOb2RlKTtcbiAgICAgICAgY29weSA9IHMuY2xvbmUoKTtcbiAgICAgICAgY29weS5zaXplID0gcy5zaXplIC0gcy5sZWZ0LnNpemUgKyBsLnNpemU7XG4gICAgICAgIGNvcHkubGVmdCA9IGw7XG4gICAgICAgIHJldHVybiBjb3B5O1xuICAgICAgfVxuXG4gICAgICBpZiAoIHIgPiAwICkgcmV0dXJuIHMucmlnaHQuZ3RlKGtleSwgY29tcGFyZSwgbnVsbE5vZGUpO1xuXG4gICAgICBjb3B5ID0gcy5jbG9uZSgpO1xuICAgICAgY29weS5zaXplID0gcy5zaXplIC0gcy5sZWZ0LnNpemU7XG4gICAgICBjb3B5LmxlZnQgPSBudWxsTm9kZTtcbiAgICAgIHJldHVybiBjb3B5O1xuICAgIH0sXG5cbiAgICBmdW5jdGlvbiBsdChrZXksIGNvbXBhcmUpIHtcbiAgICAgIHZhciBzID0gdGhpcztcbiAgICAgIHZhciByID0gY29tcGFyZShrZXksIHMua2V5KTtcblxuICAgICAgaWYgKCByID4gMCApIHtcbiAgICAgICAgdmFyIHJ0ID0gcy5yaWdodC5sdChrZXksIGNvbXBhcmUpO1xuICAgICAgICB2YXIgY29weSA9IHMuY2xvbmUoKTtcbiAgICAgICAgY29weS5zaXplID0gcy5zaXplIC0gcy5yaWdodC5zaXplICsgcnQuc2l6ZTtcbiAgICAgICAgY29weS5yaWdodCA9IHJ0O1xuICAgICAgICByZXR1cm4gY29weTtcbiAgICAgIH1cblxuICAgICAgaWYgKCByIDwgMCApIHJldHVybiBzLmxlZnQubHQoa2V5LCBjb21wYXJlKTtcblxuICAgICAgcmV0dXJuIHMubGVmdDtcbiAgICB9LFxuXG4gICAgZnVuY3Rpb24gbHRlKGtleSwgY29tcGFyZSwgbnVsbE5vZGUpIHtcbiAgICAgIHZhciBzID0gdGhpcztcbiAgICAgIHZhciBjb3B5O1xuICAgICAgdmFyIHIgPSBjb21wYXJlKGtleSwgcy5rZXkpO1xuXG4gICAgICBpZiAoIHIgPiAwICkge1xuICAgICAgICB2YXIgcnQgPSBzLnJpZ2h0Lmx0ZShrZXksIGNvbXBhcmUsIG51bGxOb2RlKTtcbiAgICAgICAgY29weSA9IHMuY2xvbmUoKTtcbiAgICAgICAgY29weS5zaXplID0gcy5zaXplIC0gcy5yaWdodC5zaXplICsgcnQuc2l6ZTtcbiAgICAgICAgY29weS5yaWdodCA9IHJ0O1xuICAgICAgICByZXR1cm4gY29weTtcbiAgICAgIH1cblxuICAgICAgaWYgKCByIDwgMCApIHJldHVybiBzLmxlZnQubHRlKGtleSwgY29tcGFyZSwgbnVsbE5vZGUpO1xuXG4gICAgICBjb3B5ID0gcy5jbG9uZSgpO1xuICAgICAgY29weS5zaXplID0gcy5zaXplIC0gcy5yaWdodC5zaXplO1xuICAgICAgY29weS5yaWdodCA9IG51bGxOb2RlO1xuICAgICAgcmV0dXJuIGNvcHk7XG4gICAgfVxuICBdXG59KTtcblxuXG4vKipcbiAgR3VhcmRzIHRoZSBsZWF2ZXMgb2YgdGhlIHRyZWUuIE9uY2UgaW5zdGFuY2UgaXMgY3JlYXRlZCBwZXIgaW5zdGFuY2Ugb2ZcbiAgVHJlZUluZGV4LCBhbmQgcmVmZXJlbmNlZCBieSBldmVyeSB0cmVlIG5vZGUuIE1vc3Qgb2YgaXRzIG1ldGhvZHMgYXJlXG4gIG5vLW9wcywgY2xlYW5seSB0ZXJtaW5hdGluZyBxdWVyaWVzIGFuZCBvdGhlciB0cmVlIG9wZXJhdGlvbnMuXG4gIDxwPlxuICBOdWxsVHJlZU5vZGUgY292ZXJzIGNyZWF0aW9uIG9mIG5ldyBub2Rlczogd2hlbiBhIHB1dCB2YWx1ZSBoaXRzIHRoZVxuICBudWxsTm9kZSwgYSBuZXcgVHJlZU5vZGUgaXMgcmV0dXJuZWQgYW5kIHRoZSBjYWxsZXIgcmVwbGFjZXMgdGhlXG4gIG51bGxOb2RlIHJlZmVyZW5jZSB3aXRoIHRoZSBuZXcgbm9kZS5cbiovXG5mb2FtLkNMQVNTKHtcbiAgcGFja2FnZTogJ2ZvYW0uZGFvLmluZGV4JyxcbiAgbmFtZTogJ051bGxUcmVlTm9kZScsXG5cbiAgcHJvcGVydGllczogW1xuICAgIHtcbiAgICAgIC8qKlxuICAgICAgICBUaGUgbnVsbE5vZGUgZm9yIGEgZ2l2ZW4gdHJlZSBjcmVhdGVzIGFsbCB0aGUgbmV3IG5vZGVzLCBzbyBpdCBuZWVkc1xuICAgICAgICB0aGUgZmFjdG9yeSBmb3IgdGhlIHRhaWwgaW5kZXggdG8gY3JlYXRlIGluc2lkZSBlYWNoIG5ldyBub2RlLlxuICAgICAgKi9cbiAgICAgIGNsYXNzOiAnU2ltcGxlJyxcbiAgICAgIG5hbWU6ICd0YWlsJ1xuICAgIH0sXG4gICAge1xuICAgICAgLyoqXG4gICAgICAgIFRoZSB0cmVlIG5vZGUgZmFjdG9yeSBpcyB1c2VkIHRvIGNyZWF0ZSBuZXcsIGVtcHR5IHRyZWUgbm9kZXMuIFRoZXlcbiAgICAgICAgd2lsbCBiZSBpbml0aWFsaXplZCB3aXRoIGEgbmV3IHRhaWwgaW5kZXggZnJvbSB0YWlsLlxuICAgICAgKi9cbiAgICAgIGNsYXNzOiAnU2ltcGxlJyxcbiAgICAgIG5hbWU6ICd0cmVlTm9kZSdcbiAgICB9LFxuICAgIHtcbiAgICAgIGNsYXNzOiAnU2ltcGxlJyxcbiAgICAgIG5hbWU6ICdsZWZ0JyxcbiAgICAgIC8vZ2V0dGVyOiBmdW5jdGlvbigpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfVxuICAgIH0sXG4gICAge1xuICAgICAgY2xhc3M6ICdTaW1wbGUnLFxuICAgICAgbmFtZTogJ3JpZ2h0JyxcbiAgICAgIC8vZ2V0dGVyOiBmdW5jdGlvbigpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfVxuICAgIH0sXG4gICAge1xuICAgICAgY2xhc3M6ICdTaW1wbGUnLFxuICAgICAgbmFtZTogJ3NpemUnLFxuICAgICAgLy9nZXR0ZXI6IGZ1bmN0aW9uKCkgeyByZXR1cm4gMDsgfVxuICAgIH0sXG4gICAge1xuICAgICAgY2xhc3M6ICdTaW1wbGUnLFxuICAgICAgbmFtZTogJ2xldmVsJyxcbiAgICAgIC8vZ2V0dGVyOiBmdW5jdGlvbigpIHsgcmV0dXJuIDA7IH1cbiAgICB9XG4gIF0sXG5cbiAgbWV0aG9kczogW1xuICAgIGZ1bmN0aW9uIGluaXQoKSB7XG4gICAgICB0aGlzLmxlZnQgID0gdW5kZWZpbmVkO1xuICAgICAgdGhpcy5yaWdodCA9IHVuZGVmaW5lZDtcbiAgICAgIHRoaXMuc2l6ZSAgPSAwO1xuICAgICAgdGhpcy5sZXZlbCA9IDA7XG4gICAgfSxcblxuICAgIGZ1bmN0aW9uIGNsb25lKCkgICAgICAgICB7IHJldHVybiB0aGlzOyB9LFxuICAgIGZ1bmN0aW9uIG1heWJlQ2xvbmUoKSAgICB7IHJldHVybiB0aGlzOyB9LFxuICAgIGZ1bmN0aW9uIHNrZXcobG9ja2VkKSAgICB7IHJldHVybiB0aGlzOyB9LFxuICAgIGZ1bmN0aW9uIHNwbGl0KGxvY2tlZCkgICB7IHJldHVybiB0aGlzOyB9LFxuICAgIGZ1bmN0aW9uIGRlY3JlYXNlTGV2ZWwoKSB7IHJldHVybiB0aGlzOyB9LFxuICAgIGZ1bmN0aW9uIGdldCgpICAgICAgICAgICB7IHJldHVybiB1bmRlZmluZWQ7IH0sXG4gICAgZnVuY3Rpb24gdXBkYXRlU2l6ZSgpICAgIHsgIH0sXG5cbiAgICAvKiogQWRkIGEgbmV3IHZhbHVlIHRvIHRoZSB0cmVlICovXG4gICAgZnVuY3Rpb24gcHV0S2V5VmFsdWUoa2V5LCB2YWx1ZSkge1xuICAgICAgdmFyIHN1YkluZGV4ID0gdGhpcy50YWlsLmNyZWF0ZU5vZGUoKTtcbiAgICAgIHN1YkluZGV4LnB1dCh2YWx1ZSk7XG4gICAgICB2YXIgbiA9IHRoaXMudHJlZU5vZGUuY3JlYXRlKCk7XG4gICAgICBuLmxlZnQgID0gdGhpcztcbiAgICAgIG4ucmlnaHQgPSB0aGlzO1xuICAgICAgbi5rZXkgICA9IGtleTtcbiAgICAgIG4udmFsdWUgPSBzdWJJbmRleDtcbiAgICAgIG4uc2l6ZSAgPSAxO1xuICAgICAgbi5sZXZlbCA9IDE7XG4gICAgICByZXR1cm4gbjtcbiAgICB9LFxuXG4gICAgZnVuY3Rpb24gcmVtb3ZlS2V5VmFsdWUoKSB7IHJldHVybiB0aGlzOyB9LFxuICAgIGZ1bmN0aW9uIHJlbW92ZU5vZGUoKSAgICAgeyByZXR1cm4gdGhpczsgfSxcbiAgICBmdW5jdGlvbiBzZWxlY3QoKSAgICAgICAgIHsgfSxcbiAgICBmdW5jdGlvbiBzZWxlY3RSZXZlcnNlKCkgIHsgfSxcblxuICAgIGZ1bmN0aW9uIGd0KCkgICB7IHJldHVybiB0aGlzOyB9LFxuICAgIGZ1bmN0aW9uIGd0ZSgpICB7IHJldHVybiB0aGlzOyB9LFxuICAgIGZ1bmN0aW9uIGx0KCkgICB7IHJldHVybiB0aGlzOyB9LFxuICAgIGZ1bmN0aW9uIGx0ZSgpICB7IHJldHVybiB0aGlzOyB9LFxuXG4gICAgZnVuY3Rpb24gZ2V0QWxsKCkgIHsgcmV0dXJuOyB9LFxuXG4gICAgZnVuY3Rpb24gYnVsa0xvYWRfKGEsIHN0YXJ0LCBlbmQsIGtleUV4dHJhY3Rvcikge1xuICAgICAgaWYgKCBlbmQgPCBzdGFydCApIHJldHVybiB0aGlzO1xuXG4gICAgICB2YXIgdHJlZSA9IHRoaXM7XG4gICAgICB2YXIgbSAgICA9IHN0YXJ0ICsgTWF0aC5mbG9vcigoZW5kLXN0YXJ0KzEpIC8gMik7XG4gICAgICB0cmVlID0gdHJlZS5wdXRLZXlWYWx1ZShrZXlFeHRyYWN0b3IoYVttXSksIGFbbV0pO1xuXG4gICAgICB0cmVlLmxlZnQgID0gdHJlZS5sZWZ0LmJ1bGtMb2FkXyhhLCBzdGFydCwgbS0xLCBrZXlFeHRyYWN0b3IpO1xuICAgICAgdHJlZS5yaWdodCA9IHRyZWUucmlnaHQuYnVsa0xvYWRfKGEsIG0rMSwgZW5kLCBrZXlFeHRyYWN0b3IpO1xuICAgICAgdHJlZS5zaXplICs9IHRyZWUubGVmdC5zaXplICsgdHJlZS5yaWdodC5zaXplO1xuXG4gICAgICByZXR1cm4gdHJlZTtcbiAgICB9XG4gIF1cbn0pO1xuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTIgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuZm9hbS5DTEFTUyh7XG4gIHJlZmluZXM6ICdmb2FtLmNvcmUuUHJvcGVydHknLFxuXG4gIHJlcXVpcmVzOiBbXG4gICAgJ2ZvYW0uZGFvLmluZGV4LlRyZWVJbmRleCcsXG4gIF0sXG5cbiAgbWV0aG9kczogW1xuICAgIGZ1bmN0aW9uIHRvSW5kZXgodGFpbCkge1xuICAgICAgLyoqIENyZWF0ZXMgdGhlIGNvcnJlY3QgdHlwZSBvZiBpbmRleCBmb3IgdGhpcyBwcm9wZXJ0eSwgcGFzc2luZyBpbiB0aGVcbiAgICAgICAgICB0YWlsIGZhY3RvcnkgKHN1Yi1pbmRleCkgcHJvdmlkZWQuICovXG4gICAgICByZXR1cm4gdGhpcy5UcmVlSW5kZXguY3JlYXRlKHsgcHJvcDogdGhpcywgdGFpbDogdGFpbCB9KTtcbiAgICB9XG4gIF1cbn0pO1xuXG5cbmZvYW0uQ0xBU1Moe1xuICByZWZpbmVzOiAnZm9hbS5jb3JlLkZPYmplY3RBcnJheScsXG5cbiAgcmVxdWlyZXM6IFtcbiAgICAnZm9hbS5kYW8uaW5kZXguU2V0SW5kZXgnLFxuICBdLFxuXG4gIG1ldGhvZHM6IFtcbiAgICBmdW5jdGlvbiB0b0luZGV4KHRhaWwpIHtcbiAgICAgICByZXR1cm4gdGhpcy5TZXRJbmRleC5jcmVhdGUoeyBwcm9wOiB0aGlzLCB0YWlsOiB0YWlsIH0pO1xuICAgIH1cbiAgXVxufSk7XG5cblxuZm9hbS5DTEFTUyh7XG4gIHJlZmluZXM6ICdmb2FtLmNvcmUuQXhpb21BcnJheScsXG5cbiAgcmVxdWlyZXM6IFtcbiAgICAnZm9hbS5kYW8uaW5kZXguU2V0SW5kZXgnLFxuICBdLFxuXG4gIG1ldGhvZHM6IFtcbiAgICBmdW5jdGlvbiB0b0luZGV4KHRhaWwpIHtcbiAgICAgICByZXR1cm4gdGhpcy5TZXRJbmRleC5jcmVhdGUoeyBwcm9wOiB0aGlzLCB0YWlsOiB0YWlsIH0pO1xuICAgIH1cbiAgXVxufSk7XG5cblxuZm9hbS5DTEFTUyh7XG4gIHJlZmluZXM6ICdmb2FtLmNvcmUuU3RyaW5nQXJyYXknLFxuXG4gIHJlcXVpcmVzOiBbXG4gICAgJ2ZvYW0uZGFvLmluZGV4LlNldEluZGV4JyxcbiAgXSxcblxuICBtZXRob2RzOiBbXG4gICAgZnVuY3Rpb24gdG9JbmRleCh0YWlsKSB7XG4gICAgICAgcmV0dXJuIHRoaXMuU2V0SW5kZXguY3JlYXRlKHsgcHJvcDogdGhpcywgdGFpbDogdGFpbCB9KTtcbiAgICB9XG4gIF1cbn0pO1xuXG5cbi8qKiBBIHRyZWUtYmFzZWQgSW5kZXguIERlZmF1bHRzIHRvIGFuIEFBVHJlZSAoYmFsYW5jZWQgYmluYXJ5IHNlYXJjaCB0cmVlKSAqKi9cbmZvYW0uQ0xBU1Moe1xuICBwYWNrYWdlOiAnZm9hbS5kYW8uaW5kZXgnLFxuICBuYW1lOiAnVHJlZUluZGV4JyxcbiAgZXh0ZW5kczogJ2ZvYW0uZGFvLmluZGV4LkluZGV4JyxcblxuICByZXF1aXJlczogW1xuICAgICdmb2FtLmNvcmUuUHJvcGVydHknLFxuICAgICdmb2FtLmRhby5BcnJheVNpbmsnLFxuICAgICdmb2FtLm1sYW5nLnNpbmsuTnVsbFNpbmsnLFxuICAgICdmb2FtLmRhby5pbmRleC5NZXJnZVBsYW4nLFxuICAgICdmb2FtLmRhby5pbmRleC5Db3VudFBsYW4nLFxuICAgICdmb2FtLmRhby5pbmRleC5DdXN0b21QbGFuJyxcbiAgICAnZm9hbS5kYW8uaW5kZXguTm90Rm91bmRQbGFuJyxcbiAgICAnZm9hbS5kYW8uaW5kZXguTnVsbFRyZWVOb2RlJyxcbiAgICAnZm9hbS5kYW8uaW5kZXguVHJlZU5vZGUnLFxuICAgICdmb2FtLmRhby5pbmRleC5WYWx1ZUluZGV4JyxcbiAgICAnZm9hbS5tbGFuZy5vcmRlci5EZXNjJyxcbiAgICAnZm9hbS5tbGFuZy5vcmRlci5Db21wYXJhdG9yJyxcbiAgICAnZm9hbS5tbGFuZy5vcmRlci5UaGVuQnknLFxuICAgICdmb2FtLm1sYW5nLnByZWRpY2F0ZS5BbmQnLFxuICAgICdmb2FtLm1sYW5nLnByZWRpY2F0ZS5FcScsXG4gICAgJ2ZvYW0ubWxhbmcucHJlZGljYXRlLkZhbHNlJyxcbiAgICAnZm9hbS5tbGFuZy5wcmVkaWNhdGUuR3QnLFxuICAgICdmb2FtLm1sYW5nLnByZWRpY2F0ZS5HdGUnLFxuICAgICdmb2FtLm1sYW5nLnByZWRpY2F0ZS5MdCcsXG4gICAgJ2ZvYW0ubWxhbmcucHJlZGljYXRlLkx0ZScsXG4gICAgJ2ZvYW0ubWxhbmcucHJlZGljYXRlLk9yJyxcbiAgICAnZm9hbS5tbGFuZy5wcmVkaWNhdGUuVHJ1ZScsXG4gICAgJ2ZvYW0ubWxhbmcucHJlZGljYXRlLkluJyxcbiAgICAnZm9hbS5tbGFuZy5wcmVkaWNhdGUuQ29udGFpbnMnLFxuICAgICdmb2FtLm1sYW5nLnByZWRpY2F0ZS5Db250YWluc0lDJyxcbiAgICAnZm9hbS5tbGFuZy5zaW5rLkNvdW50JyxcbiAgICAnZm9hbS5tbGFuZy5zaW5rLkV4cGxhaW4nLFxuICBdLFxuXG4gIGNvbnN0YW50czoge1xuICAgIElTX0VYUFJfTUFUQ0hfRk46IGZ1bmN0aW9uIGlzRXhwck1hdGNoKHByZWRpY2F0ZSwgcHJvcCwgbW9kZWwpIHtcbiAgICAgIHZhciBzZWxmID0gdGhpcy5pbmRleCB8fCB0aGlzO1xuICAgICAgaWYgKCBwcmVkaWNhdGUgJiYgbW9kZWwgJiYgcHJvcCApIHtcbiAgICAgICAgLy8gdXRpbC5lcXVhbHMgY2F0Y2hlcyBQcm9wZXJ0aWVzIHRoYXQgd2VyZSBjbG9uZWQgaWYgdGhlIHByZWRpY2F0ZSBoYXNcbiAgICAgICAgLy8gIGJlZW4gY2xvbmVkLlxuICAgICAgICBpZiAoIG1vZGVsLmlzSW5zdGFuY2UocHJlZGljYXRlKSAmJlxuICAgICAgICAgICAgKCBwcmVkaWNhdGUuYXJnMSA9PT0gcHJvcCB8fCBmb2FtLnV0aWwuZXF1YWxzKHByZWRpY2F0ZS5hcmcxLCBwcm9wKSApXG4gICAgICAgICkge1xuICAgICAgICAgIHZhciBhcmcyID0gcHJlZGljYXRlLmFyZzI7XG4gICAgICAgICAgcHJlZGljYXRlID0gdW5kZWZpbmVkO1xuICAgICAgICAgIHJldHVybiB7IGFyZzI6IGFyZzIsIHByZWRpY2F0ZTogcHJlZGljYXRlIH07XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIHByZWRpY2F0ZS5hcmdzICYmIHNlbGYuQW5kLmlzSW5zdGFuY2UocHJlZGljYXRlKSApIHtcbiAgICAgICAgICBmb3IgKCB2YXIgaSA9IDAgOyBpIDwgcHJlZGljYXRlLmFyZ3MubGVuZ3RoIDsgaSsrICkge1xuICAgICAgICAgICAgdmFyIHEgPSBwcmVkaWNhdGUuYXJnc1tpXTtcbiAgICAgICAgICAgIC8vIFV0aWwuZXF1YWxzIHRvIGNhdGNoIGNsb25lcyBhZ2FpblxuICAgICAgICAgICAgaWYgKCBtb2RlbC5pc0luc3RhbmNlKHEpICYmXG4gICAgICAgICAgICAgICAgKHEuYXJnMSA9PT0gcHJvcCB8fCBmb2FtLnV0aWwuZXF1YWxzKHEuYXJnMSwgcHJvcCkpICkge1xuICAgICAgICAgICAgICBwcmVkaWNhdGUgPSBwcmVkaWNhdGUuY2xvbmUoKTtcbiAgICAgICAgICAgICAgcHJlZGljYXRlLmFyZ3NbaV0gPSBzZWxmLlRydWUuY3JlYXRlKCk7XG4gICAgICAgICAgICAgIHByZWRpY2F0ZSA9IHByZWRpY2F0ZS5wYXJ0aWFsRXZhbCgpO1xuICAgICAgICAgICAgICBpZiAoIHNlbGYuVHJ1ZS5pc0luc3RhbmNlKHByZWRpY2F0ZSkgKSBwcmVkaWNhdGUgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgIHJldHVybiB7IGFyZzI6IHEuYXJnMiwgcHJlZGljYXRlOiBwcmVkaWNhdGUgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICB9LFxuXG4gIHByb3BlcnRpZXM6IFtcbiAgICB7XG4gICAgICBuYW1lOiAncHJvcCcsXG4gICAgICByZXF1aXJlZDogdHJ1ZVxuICAgIH0sXG4gICAge1xuICAgICAgbmFtZTogJ251bGxOb2RlJyxcbiAgICAgIGZhY3Rvcnk6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgbm4gPSB0aGlzLk51bGxUcmVlTm9kZS5jcmVhdGUoe1xuICAgICAgICAgIHRhaWw6IHRoaXMudGFpbCxcbiAgICAgICAgICB0cmVlTm9kZTogdGhpcy50cmVlTm9kZVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIG5uO1xuICAgICAgfVxuICAgIH0sXG4gICAge1xuICAgICAgbmFtZTogJ3RyZWVOb2RlJyxcbiAgICAgIGZhY3Rvcnk6IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcy5UcmVlTm9kZTsgfVxuICAgIH0sXG4gICAge1xuICAgICAgbmFtZTogJ3RhaWwnLFxuICAgICAgcmVxdWlyZWQ6IHRydWVcbiAgICB9XG4gIF0sXG5cbiAgbWV0aG9kczogW1xuICAgIGZ1bmN0aW9uIGluaXQoKSB7XG4gICAgICB0aGlzLmRlZHVwID0gdGhpcy5kZWR1cC5iaW5kKHRoaXMsIHRoaXMucHJvcC5uYW1lKTtcbiAgICB9LFxuXG4gICAgLyoqIFNldCB0aGUgdmFsdWUncyBwcm9wZXJ0eSB0byBiZSB0aGUgc2FtZSBhcyB0aGUga2V5IGluIHRoZSBpbmRleC5cbiAgICAgICAgVGhpcyBzYXZlcyBtZW1vcnkgYnkgc2hhcmluZyBvYmplY3RzLiAqL1xuICAgIGZ1bmN0aW9uIGRlZHVwKHByb3BOYW1lLCBvYmosIHZhbHVlKSB7XG4gICAgICBvYmpbcHJvcE5hbWVdID0gdmFsdWU7XG4gICAgfSxcblxuICAgIGZ1bmN0aW9uIGNvbXBhcmUobzEsIG8yKSB7XG4gICAgICByZXR1cm4gZm9hbS51dGlsLmNvbXBhcmUobzEsIG8yKTtcbiAgICB9LFxuXG4gICAgZnVuY3Rpb24gaXNPcmRlclNlbGVjdGFibGUob3JkZXIpIHtcbiAgICAgIC8vIG5vIG9yZGVyaW5nLCBubyBwcm9ibGVtXG4gICAgICBpZiAoICEgb3JkZXIgKSByZXR1cm4gdHJ1ZTtcblxuICAgICAgLy8gaWYgdGhpcyBpbmRleCBjYW4gc29ydCwgaXQncyB1cCB0byBvdXIgdGFpbCB0byBzdWItc29ydFxuICAgICAgaWYgKCBmb2FtLnV0aWwuZXF1YWxzKG9yZGVyLm9yZGVyUHJpbWFyeVByb3BlcnR5KCksIHRoaXMucHJvcCkgKSB7XG4gICAgICAgIC8vIElmIHRoZSBzdWJlc3RpbWF0ZSBpcyBsZXNzIHRoYW4gc29ydCBjb3N0IChOKmxnKE4pIGZvciBhIGR1bW15IHNpemUgb2YgMTAwMClcbiAgICAgICAgcmV0dXJuIDk5NjUgPlxuICAgICAgICAgIHRoaXMudGFpbC5lc3RpbWF0ZSgxMDAwLCB0aGlzLk51bGxTaW5rLmNyZWF0ZSgpLCAwLCAwLCBvcmRlci5vcmRlclRhaWwoKSlcbiAgICAgIH1cbiAgICAgIC8vIGNhbid0IHVzZSBzZWxlY3QoKSB3aXRoIHRoZSBnaXZlbiBvcmRlcmluZ1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sXG5cbiAgICBmdW5jdGlvbiBlc3RpbWF0ZShzaXplLCBzaW5rLCBza2lwLCBsaW1pdCwgb3JkZXIsIHByZWRpY2F0ZSkge1xuICAgICAgLy8gc21hbGwgc2l6ZXMgZG9uJ3QgbWF0dGVyXG4gICAgICBpZiAoIHNpemUgPD0gMTYgKSByZXR1cm4gTWF0aC5sb2coc2l6ZSkgLyBNYXRoLmxvZygyKTtcblxuICAgICAgLy8gaWYgb25seSBlc3RpbWF0aW5nIGJ5IG9yZGVyaW5nLCBqdXN0IGNoZWNrIGlmIHdlIGNhbiBzY2FuIGl0XG4gICAgICAvLyAgb3RoZXJ3aXNlIHJldHVybiB0aGUgc29ydCBjb3N0LlxuICAgICAgLy8gTk9URTogVGhpcyBpcyBjb25jZXB0dWFsbHkgdGhlIHJpZ2h0IHRoaW5nIHRvIGRvLCBidXQgYWxzbyBoZWxwc1xuICAgICAgLy8gICBzcGVlZCB1cCBpc09yZGVyU2VsZWN0YWJsZSgpIGNhbGxzIG9uIHRoaXM6XG4gICAgICAvLyAgIGEuaXNPcmRlclNlbGVjdGFibGUobykgLT4gYi5lc3RpbWF0ZSguLm8pIC0+IGIuaXNPcmRlclNlbGVjdGFibGUobykgLi4uXG4gICAgICAvLyAgIFdoaWNoIG1ha2VzIGl0IGVmZmljaWVudCBidXQgcmVtb3ZlcyB0aGUgbmVlZCBmb3IgSW5kZXggdG9cbiAgICAgIC8vICAgaGF2ZSBhbiBpc09yZGVyU2VsZWN0YWJsZSgpIG1ldGhvZCBmb3J3YXJkaW5nIGRpcmVjdGx5LlxuICAgICAgaWYgKCBvcmRlciAmJiAhICggcHJlZGljYXRlIHx8IHNraXAgfHwgbGltaXQgKSApIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNPcmRlclNlbGVjdGFibGUob3JkZXIpID8gc2l6ZSA6XG4gICAgICAgICAgc2l6ZSAqIE1hdGgubG9nKHNpemUpIC8gTWF0aC5sb2coMik7XG4gICAgICB9XG5cbiAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgIHByZWRpY2F0ZSA9IHByZWRpY2F0ZSA/IHByZWRpY2F0ZS5jbG9uZSgpIDogbnVsbDtcbiAgICAgIHZhciBwcm9wZXJ0eSA9IHRoaXMucHJvcDtcbiAgICAgIC8vIFRPRE86IHZhbGlkYXRlIHRoaXMgYXNzdW1wdGlvbjpcbiAgICAgIHZhciBub2RlQ291bnQgPSBNYXRoLmZsb29yKHNpemUgKiAwLjI1KTsgLy8gdHJlZSBub2RlIGNvdW50IHdpbGwgYmUgYSBxdWFydGVyIHRoZSB0b3RhbCBpdGVtIGNvdW50XG5cbiAgICAgIHZhciBpc0V4cHJNYXRjaCA9IHRoaXMuSVNfRVhQUl9NQVRDSF9GTi5iaW5kKHRoaXMsIHByZWRpY2F0ZSwgcHJvcGVydHkpO1xuXG4gICAgICB2YXIgdGFpbCA9IHRoaXMudGFpbDtcbiAgICAgIHZhciBzdWJFc3RpbWF0ZSA9ICggdGFpbCApID8gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIE1hdGgubG9nKG5vZGVDb3VudCkgLyBNYXRoLmxvZygyKSArXG4gICAgICAgICAgICB0YWlsLmVzdGltYXRlKHNpemUgLyBub2RlQ291bnQsIHNpbmssIHNraXAsIGxpbWl0LCBvcmRlciwgcHJlZGljYXRlKTtcbiAgICAgICAgfSA6XG4gICAgICAgIGZ1bmN0aW9uKCkgeyByZXR1cm4gTWF0aC5sb2cobm9kZUNvdW50KSAvIE1hdGgubG9nKDIpOyB9O1xuXG4gICAgICB2YXIgZXhwciA9IGlzRXhwck1hdGNoKHRoaXMuSW4pO1xuICAgICAgaWYgKCBleHByICkge1xuICAgICAgICB2YXIgbnVtQ21wID0gZXhwci5hcmcyID8gZXhwci5hcmcyLmYoKS5sZW5ndGggOiAwO1xuICAgICAgICAvLyB0cmVlIGRlcHRoICogbnVtYmVyIG9mIGNvbXBhcmVzXG4gICAgICAgIHJldHVybiBzdWJFc3RpbWF0ZSgpICogbnVtQ21wO1xuICAgICAgfVxuXG4gICAgICBleHByID0gaXNFeHByTWF0Y2godGhpcy5FcSk7XG4gICAgICBpZiAoIGV4cHIgKSB7XG4gICAgICAgIC8vIHRyZWUgZGVwdGhcbiAgICAgICAgcmV0dXJuIHN1YkVzdGltYXRlKCk7XG4gICAgICB9XG5cbiAgICAgIGV4cHIgPSBpc0V4cHJNYXRjaCh0aGlzLkNvbnRhaW5zSUMpO1xuICAgICAgaWYgKCBleHByICkgaWMgPSB0cnVlO1xuICAgICAgZXhwciA9IGV4cHIgfHwgaXNFeHByTWF0Y2godGhpcy5Db250YWlucyk7XG4gICAgICBpZiAoIGV4cHIgKSB7XG4gICAgICAgIC8vIFRPRE86IHRoaXMgaXNuJ3QgcXVpdGUgcmlnaHQuIFRyZWUgZGVwdGggKiBxdWVyeSBzdHJpbmcgbGVuZ3RoP1xuICAgICAgICAvLyBJZiBidWlsZGluZyBhIHRyaWUgdG8gaGVscCB3aXRoIHRoaXMsIGVzdGltYXRlIGJlY29tZXMgZWFzaWVyLlxuICAgICAgICByZXR1cm4gc3ViRXN0aW1hdGUoKSAqIGV4cHIuYXJnMi5mKCkubGVuZ3RoO1xuICAgICAgfVxuXG4gICAgICAvLyBBdCB0aGlzIHBvaW50IHdlIGFyZSBnb2luZyB0byBzY2FuIGFsbCBvciBwYXJ0IG9mIHRoZSB0cmVlXG4gICAgICAvLyAgd2l0aCBzZWxlY3QoKVxuICAgICAgdmFyIGNvc3QgPSBzaXplO1xuXG4gICAgICAvLyBUaGVzZSBjYXNlcyBhcmUganVzdCBzbGlnaHRseSBiZXR0ZXIgc2NhbnMsIGJ1dCB3ZSBjYW4ndCBlc3RpbWF0ZVxuICAgICAgLy8gICBob3cgbXVjaCBiZXR0ZXIuLi4gbWF5YmUgaGFsZlxuICAgICAgaWYgKCBpc0V4cHJNYXRjaCh0aGlzLkd0KSB8fCBpc0V4cHJNYXRjaCh0aGlzLkd0ZSkgfHxcbiAgICAgICAgICBpc0V4cHJNYXRjaCh0aGlzLkx0KSB8fCBpc0V4cHJNYXRjaCh0aGlzLkx0ZSkgKSB7XG4gICAgICAgIGNvc3QgLz0gMjtcbiAgICAgIH1cblxuICAgICAgLy8gT3JkZXJpbmdcbiAgICAgIC8vIGlmIHNvcnRpbmcgcmVxdWlyZWQsIGFkZCB0aGUgc29ydCBjb3N0XG4gICAgICBpZiAoICEgdGhpcy5pc09yZGVyU2VsZWN0YWJsZShvcmRlcikgKSB7XG4gICAgICAgIC8vIHRoaXMgaW5kZXggb3IgYSB0YWlsIGluZGV4IGNhbid0IHNvcnQgdGhpcyBvcmRlcmluZyxcbiAgICAgICAgLy8gbWFudWFsIHNvcnQgcmVxdWlyZWRcbiAgICAgICAgaWYgKCBjb3N0ID4gMCApIGNvc3QgKj0gTWF0aC5sb2coY29zdCkgLyBNYXRoLmxvZygyKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGNvc3Q7XG4gICAgfSxcblxuICAgIGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgICAgcmV0dXJuICdbJyArIHRoaXMuY2xzXy5uYW1lICsgJzogJyArIHRoaXMucHJvcC5uYW1lICsgJyAnICsgdGhpcy50YWlsLnRvU3RyaW5nKCkgKyAnXSc7XG4gICAgfSxcblxuICAgIGZ1bmN0aW9uIHRvUHJldHR5U3RyaW5nKGluZGVudCkge1xuICAgICAgdmFyIHJldCA9ICcnO1xuICAgICAgLy9yZXQgKz0gXCIgIFwiLnJlcGVhdChpbmRlbnQpICsgdGhpcy5jbHNfLm5hbWUgKyBcIiggXCIgKyB0aGlzLnByb3AubmFtZSArIFwiXFxuXCI7XG4gICAgICAvL3JldCArPSB0aGlzLnRhaWwudG9QcmV0dHlTdHJpbmcoaW5kZW50ICsgMSk7XG4gICAgICAvL3JldCArPSBcIiAgXCIucmVwZWF0KGluZGVudCkgKyBcIilcXG5cIjtcbiAgICAgIHZhciB0YWlsID0gdGhpcy50YWlsLnRvUHJldHR5U3RyaW5nKGluZGVudCArIDEpO1xuICAgICAgcmV0ID0gJyAgJy5yZXBlYXQoaW5kZW50KSArIHRoaXMucHJvcC5uYW1lICsgJygnICsgdGhpcy4kVUlEICsgJylcXG4nO1xuICAgICAgaWYgKCB0YWlsLnRyaW0oKS5sZW5ndGggPiAwICkgcmV0ICs9IHRhaWw7XG4gICAgICByZXR1cm4gcmV0O1xuICAgIH1cbiAgXVxufSk7XG5cblxuLyoqIEEgdHJlZS1iYXNlZCBJbmRleC4gRGVmYXVsdHMgdG8gYW4gQUFUcmVlIChiYWxhbmNlZCBiaW5hcnkgc2VhcmNoIHRyZWUpICoqL1xuZm9hbS5DTEFTUyh7XG4gIHBhY2thZ2U6ICdmb2FtLmRhby5pbmRleCcsXG4gIG5hbWU6ICdUcmVlSW5kZXhOb2RlJyxcbiAgZXh0ZW5kczogJ2ZvYW0uZGFvLmluZGV4LkluZGV4Tm9kZScsXG5cbiAgcHJvcGVydGllczogW1xuICAgIHtcbiAgICAgIGNsYXNzOiAnU2ltcGxlJyxcbiAgICAgIG5hbWU6ICdzZWxlY3RDb3VudCcsXG4gICAgfSxcbiAgICB7XG4gICAgICBjbGFzczogJ1NpbXBsZScsXG4gICAgICBuYW1lOiAncm9vdCcsXG4gICAgfVxuICBdLFxuXG4gIG1ldGhvZHM6IFtcbiAgICBmdW5jdGlvbiBpbml0KCkge1xuICAgICAgdGhpcy5yb290ID0gdGhpcy5yb290IHx8IHRoaXMuaW5kZXgubnVsbE5vZGU7XG4gICAgICB0aGlzLnNlbGVjdENvdW50ID0gdGhpcy5zZWxlY3RDb3VudCB8fCAwO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBCdWxrIGxvYWQgYW4gdW5zb3J0ZWQgYXJyYXkgb2Ygb2JqZWN0cy5cbiAgICAgKiBGYXN0ZXIgdGhhbiBsb2FkaW5nIGluZGl2aWR1YWxseSwgYW5kIHByb2R1Y2VzIGEgYmFsYW5jZWQgdHJlZS5cbiAgICAgKiovXG4gICAgZnVuY3Rpb24gYnVsa0xvYWQoYSkge1xuICAgICAgYSA9IGEuYXJyYXkgfHwgYTtcbiAgICAgIHRoaXMucm9vdCA9IHRoaXMuaW5kZXgubnVsbE5vZGU7XG5cbiAgICAgIC8vIE9ubHkgc2FmZSBpZiBjaGlsZHJlbiBhcmVuJ3QgdGhlbXNlbHZlcyB0cmVlc1xuICAgICAgLy8gVE9ETzogc2hvdWxkIHRoaXMgYmUgIVRyZWVJbmRleC5pc0luc3RhbmNlPyBvciBhcmUgd2UgdGFsa2luZyBhbnlcbiAgICAgIC8vIG5vbi1zaW1wbGUgaW5kZXgsIGFuZCBpcyBWYWx1ZUluZGV4IHRoZSBvbmx5IHNpbXBsZSBpbmRleD9cbiAgICAgIC8vIEl0J3MgdGhlIGRlZmF1bHQsIHNvIG9rIGZvciBub3dcbiAgICAgIGlmICggdGhpcy5pbmRleC5WYWx1ZUluZGV4LmlzSW5zdGFuY2UodGhpcy50YWlsKSApIHtcbiAgICAgICAgdmFyIHByb3AgPSB0aGlzLmluZGV4LnByb3A7XG4gICAgICAgIGEuc29ydChwcm9wLmNvbXBhcmUuYmluZChwcm9wKSk7XG4gICAgICAgIHRoaXMucm9vdCA9IHRoaXMucm9vdC5idWxrTG9hZF8oYSwgMCwgYS5sZW5ndGgtMSwgcHJvcC5mKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZvciAoIHZhciBpID0gMCA7IGkgPCBhLmxlbmd0aCA7IGkrKyApIHtcbiAgICAgICAgICB0aGlzLnB1dChhW2ldKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBmdW5jdGlvbiBwdXQobmV3VmFsdWUpIHtcbiAgICAgIHRoaXMucm9vdCA9IHRoaXMucm9vdC5wdXRLZXlWYWx1ZShcbiAgICAgICAgICB0aGlzLmluZGV4LnByb3AuZihuZXdWYWx1ZSksXG4gICAgICAgICAgbmV3VmFsdWUsXG4gICAgICAgICAgdGhpcy5pbmRleC5jb21wYXJlLFxuICAgICAgICAgIHRoaXMuaW5kZXguZGVkdXAsXG4gICAgICAgICAgdGhpcy5zZWxlY3RDb3VudCA+IDApO1xuICAgIH0sXG5cbiAgICBmdW5jdGlvbiByZW1vdmUodmFsdWUpIHtcbiAgICAgIHRoaXMucm9vdCA9IHRoaXMucm9vdC5yZW1vdmVLZXlWYWx1ZShcbiAgICAgICAgICB0aGlzLmluZGV4LnByb3AuZih2YWx1ZSksXG4gICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgdGhpcy5pbmRleC5jb21wYXJlLFxuICAgICAgICAgIHRoaXMuc2VsZWN0Q291bnQgPiAwLFxuICAgICAgICAgIHRoaXMuaW5kZXgubnVsbE5vZGUpO1xuICAgIH0sXG5cbiAgICBmdW5jdGlvbiBnZXQoa2V5KSB7XG4gICAgICAvLyBkb2VzIG5vdCBkZWx2ZSBpbnRvIHN1Yi1pbmRleGVzXG4gICAgICByZXR1cm4gdGhpcy5yb290LmdldChrZXksIHRoaXMuaW5kZXguY29tcGFyZSk7XG4gICAgfSxcblxuICAgIGZ1bmN0aW9uIHNlbGVjdChzaW5rLCBza2lwLCBsaW1pdCwgb3JkZXIsIHByZWRpY2F0ZSwgY2FjaGUpIHtcbiAgICAgIC8vIEFBVHJlZSBub2RlIHdpbGwgZXh0cmFjdCBvcmRlckRpcnMubmV4dCBmb3IgdGhlIHRhaWwgaW5kZXhcbiAgICAgIGlmICggb3JkZXIgJiYgb3JkZXIub3JkZXJEaXJlY3Rpb24oKSA8IDAgKSB7XG4gICAgICAgIHRoaXMucm9vdC5zZWxlY3RSZXZlcnNlKHNpbmssIHNraXAsIGxpbWl0LCBvcmRlciwgcHJlZGljYXRlLCBjYWNoZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnJvb3Quc2VsZWN0KHNpbmssIHNraXAsIGxpbWl0LCBvcmRlciwgcHJlZGljYXRlLCBjYWNoZSk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIGZ1bmN0aW9uIHNpemUoKSB7IHJldHVybiB0aGlzLnJvb3Quc2l6ZTsgfSxcblxuICAgIGZ1bmN0aW9uIHBsYW4oc2luaywgc2tpcCwgbGltaXQsIG9yZGVyLCBwcmVkaWNhdGUsIHJvb3QpIHtcbiAgICAgIHZhciBpbmRleCA9IHRoaXM7XG4gICAgICB2YXIgbSA9IHRoaXMuaW5kZXg7XG5cblxuICAgICAgaWYgKCBtLkZhbHNlLmlzSW5zdGFuY2UocHJlZGljYXRlKSApIHJldHVybiBtLk5vdEZvdW5kUGxhbi5jcmVhdGUoKTtcblxuICAgICAgaWYgKCAhIHByZWRpY2F0ZSAmJiBtLkNvdW50LmlzSW5zdGFuY2Uoc2luaykgKSB7XG4gICAgICAgIHZhciBjb3VudCA9IHRoaXMuc2l6ZSgpO1xuICAgICAgICAvLyAgICAgICAgY29uc29sZS5sb2coJyoqKioqKioqKioqKioqKiogQ09VTlQgU0hPUlQtQ0lSQ1VJVCAqKioqKioqKioqKioqKioqJywgY291bnQsIHRoaXMudG9TdHJpbmcoKSk7XG4gICAgICAgIHJldHVybiBtLkNvdW50UGxhbi5jcmVhdGUoeyBjb3VudDogY291bnQgfSk7XG4gICAgICB9XG5cbiAgICAgIHZhciBwcm9wID0gbS5wcm9wO1xuXG4gICAgICBpZiAoIGZvYW0ubWxhbmcuc2luay5Hcm91cEJ5LmlzSW5zdGFuY2Uoc2luaykgJiYgc2luay5hcmcxID09PSBwcm9wICkge1xuICAgICAgLy8gY29uc29sZS5sb2coJyoqKioqKioqKioqKioqKiogR1JPVVAtQlkgU0hPUlQtQ0lSQ1VJVCAqKioqKioqKioqKioqKioqJyk7XG4gICAgICAvLyBUT0RPOiBhbGxvdyBzaW5rIHRvIHNwbGl0IHVwLCBmb3IgR3JvdXBCeSBwYXNzaW5nIG9uZSBzdWItc2luayB0byBlYWNoIHRyZWUgbm9kZVxuICAgICAgLy8gIGZvciBncm91cGluZy4gQWxsb3cgc2luayB0byBzdWdnZXN0IG9yZGVyLCBpZiBvcmRlciBub3QgZGVmaW5lZFxuICAgICAgLy8gICAgc2luay5zdWJTaW5rKGtleSkgPT4gc2lua1xuICAgICAgLy8gICAgc2luay5kZWZhdWx0T3JkZXIoKSA9PiBDb21wYXJhdG9yXG4gICAgICB9XG5cbiAgICAgIHZhciByZXN1bHQsIHN1YlBsYW4sIGNvc3Q7XG5cbiAgICAgIHZhciBpc0V4cHJNYXRjaCA9IG0uSVNfRVhQUl9NQVRDSF9GTi5iaW5kKHRoaXMsIHByZWRpY2F0ZSwgcHJvcCk7XG5cbiAgICAgIHZhciBleHByID0gaXNFeHByTWF0Y2gobS5Jbik7XG4gICAgICBpZiAoIGV4cHIgKSB7XG4gICAgICAgIHByZWRpY2F0ZSA9IGV4cHIucHJlZGljYXRlO1xuICAgICAgICAvLyBNYXJzaGFsbGVkIGVtcHR5IGFycmF5IG1heSBiZSB1bmRlZmluZWQuXG4gICAgICAgIHZhciBrZXlzID0gZXhwci5hcmcyLmYoKSB8fCBbXTtcbiAgICAgICAgLy8gSnVzdCBzY2FuIGlmIHRoYXQgd291bGQgYmUgZmFzdGVyLlxuICAgICAgICBpZiAoIE1hdGgubG9nKHRoaXMuc2l6ZSgpKSAvIE1hdGgubG9nKDIpICoga2V5cy5sZW5ndGggPCB0aGlzLnNpemUoKSApIHtcbiAgICAgICAgICB2YXIgc3ViUGxhbnMgPSBbXTtcbiAgICAgICAgICBjb3N0ID0gMTtcblxuICAgICAgICAgIGZvciAoIHZhciBpID0gMCA7IGkgPCBrZXlzLmxlbmd0aCA7ICsraSkge1xuICAgICAgICAgICAgcmVzdWx0ID0gdGhpcy5nZXQoa2V5c1tpXSk7XG5cbiAgICAgICAgICAgIGlmICggcmVzdWx0ICkgeyAvLyBUT0RPOiBjb3VsZCByZWZhY3RvciB0aGlzIHN1YmluZGV4IHJlY3Vyc2lvbiBpbnRvIC5wbGFuKClcbiAgICAgICAgICAgICAgc3ViUGxhbiA9IHJlc3VsdC5wbGFuKHNpbmssIHNraXAsIGxpbWl0LCBvcmRlciwgcHJlZGljYXRlLCByb290KTtcblxuICAgICAgICAgICAgICBjb3N0ICs9IHN1YlBsYW4uY29zdDtcbiAgICAgICAgICAgICAgc3ViUGxhbnMucHVzaChzdWJQbGFuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoIHN1YlBsYW5zLmxlbmd0aCA9PT0gMCApIHJldHVybiBtLk5vdEZvdW5kUGxhbi5jcmVhdGUoKTtcblxuICAgICAgICAgIHJldHVybiBtLk1lcmdlUGxhbi5jcmVhdGUoe1xuICAgICAgICAgICAgc3ViUGxhbnM6IHN1YlBsYW5zLFxuICAgICAgICAgICAgcHJvcDogcHJvcFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGV4cHIgPSBpc0V4cHJNYXRjaChtLkVxKTtcbiAgICAgIGlmICggZXhwciApIHtcbiAgICAgICAgcHJlZGljYXRlID0gZXhwci5wcmVkaWNhdGU7XG4gICAgICAgIHZhciBrZXkgPSBleHByLmFyZzIuZigpO1xuICAgICAgICByZXN1bHQgPSB0aGlzLmdldChrZXksIHRoaXMuaW5kZXguY29tcGFyZSk7XG5cbiAgICAgICAgaWYgKCAhIHJlc3VsdCApIHJldHVybiBtLk5vdEZvdW5kUGxhbi5jcmVhdGUoKTtcblxuICAgICAgICBzdWJQbGFuID0gcmVzdWx0LnBsYW4oc2luaywgc2tpcCwgbGltaXQsIG9yZGVyLCBwcmVkaWNhdGUsIHJvb3QpO1xuXG4gICAgICAgIHJldHVybiBzdWJQbGFuO1xuICAgICAgfVxuXG4gICAgICB2YXIgaWMgPSBmYWxzZTtcbiAgICAgIGV4cHIgPSBpc0V4cHJNYXRjaChtLkNvbnRhaW5zSUMpO1xuICAgICAgaWYgKCBleHByICkgaWMgPSB0cnVlO1xuICAgICAgZXhwciA9IGV4cHIgfHwgaXNFeHByTWF0Y2gobS5Db250YWlucyk7XG4gICAgICBpZiAoIGV4cHIgKSB7XG4gICAgICAgIHByZWRpY2F0ZSA9IGV4cHIucHJlZGljYXRlO1xuICAgICAgICB2YXIga2V5ID0gaWMgPyBleHByLmFyZzIuZigpLnRvTG93ZXJDYXNlKCkgOiBleHByLmFyZzIuZigpO1xuXG4gICAgICAgIC8vIFN1YnN0cmluZyBjb21wYXJpc29uIGZ1bmN0aW9uOlxuICAgICAgICAvLyByZXR1cm5zIDAgaWYgbm9kZUtleSBjb250YWlucyBtYXN0ZXJLZXkuXG4gICAgICAgIC8vIHJldHVybnMgLTEgaWYgbm9kZUtleSBpcyBzaG9ydGVyIHRoYW4gbWFzdGVyS2V5XG4gICAgICAgIC8vIHJldHVybnMgMSBpZiBub2RlS2V5IGlzIGxvbmdlciBvciBlcXVhbCBsZW5ndGgsIGJ1dCBkb2VzIG5vdCBjb250YWluIG1hc3RlcktleVxuICAgICAgICB2YXIgY29tcGFyZVN1YnN0cmluZyA9IGZ1bmN0aW9uIGNvbXBhcmVTdWJzdHJpbmcobm9kZUtleSwgbWFzdGVyS2V5KSB7XG4gICAgICAgICAgLy8gbm9kZUtleSBjYW4ndCBjb250YWluIG1hc3RlcktleSBpZiBpdCdzIHRvbyBzaG9ydFxuICAgICAgICAgIGlmICggKCAhIG5vZGVLZXkgKSB8fCAoICEgbm9kZUtleS5pbmRleE9mICkgfHwgKCBub2RlS2V5Lmxlbmd0aCA8IG1hc3RlcktleS5sZW5ndGggKSApIHJldHVybiAtMTtcblxuICAgICAgICAgIGlmICggaWMgKSBub2RlS2V5ID0gbm9kZUtleS50b0xvd2VyQ2FzZSgpOyAvLyBUT0RPOiBoYW5kbGUgY2FzZS1pbnNlbnNpdGl2ZSBiZXR0ZXJcblxuICAgICAgICAgIHJldHVybiBub2RlS2V5LmluZGV4T2YobWFzdGVyS2V5KSA+IC0xID8gMCA6IDE7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgaW5kZXhlcyA9IFtdO1xuICAgICAgICBpZiAoICEga2V5IHx8IGtleS5sZW5ndGggPT09IDAgKSB7XG4gICAgICAgICAgLy8gZXZlcnl0aGluZyBjb250YWlucyAnbm90aGluZydcbiAgICAgICAgICB0aGlzLnJvb3QuZ2V0QWxsKCcnLCBmdW5jdGlvbigpIHsgcmV0dXJuIDA7IH0sIGluZGV4ZXMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMucm9vdC5nZXRBbGwoa2V5LCBjb21wYXJlU3Vic3RyaW5nLCBpbmRleGVzKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgc3ViUGxhbnMgPSBbXTtcbiAgICAgICAgLy8gaXRlcmF0ZSBvdmVyIGFsbCBrZXlzXG4gICAgICAgIGZvciAoIHZhciBpID0gMDsgaSA8IGluZGV4ZXMubGVuZ3RoOyBpKysgKSB7XG4gICAgICAgICAgc3ViUGxhbnMucHVzaChpbmRleGVzW2ldLnBsYW4oc2luaywgc2tpcCwgbGltaXQsIG9yZGVyLCBwcmVkaWNhdGUsIHJvb3QpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBtLk1lcmdlUGxhbi5jcmVhdGUoe1xuICAgICAgICAgIHN1YlBsYW5zOiBzdWJQbGFucyxcbiAgICAgICAgICBwcm9wOiBwcm9wXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICAvLyBSZXN0cmljdCB0aGUgc3VidHJlZSB0byBzZWFyY2ggYXMgbmVjZXNzYXJ5XG4gICAgICB2YXIgc3ViVHJlZSA9IHRoaXMucm9vdDtcblxuICAgICAgZXhwciA9IGlzRXhwck1hdGNoKG0uR3QpO1xuICAgICAgaWYgKCBleHByICkgc3ViVHJlZSA9IHN1YlRyZWUuZ3QoZXhwci5hcmcyLmYoKSwgdGhpcy5pbmRleC5jb21wYXJlKTtcblxuICAgICAgZXhwciA9IGlzRXhwck1hdGNoKG0uR3RlKTtcbiAgICAgIGlmICggZXhwciApIHN1YlRyZWUgPSBzdWJUcmVlLmd0ZShleHByLmFyZzIuZigpLCB0aGlzLmluZGV4LmNvbXBhcmUsIHRoaXMuaW5kZXgubnVsbE5vZGUpO1xuXG4gICAgICBleHByID0gaXNFeHByTWF0Y2gobS5MdCk7XG4gICAgICBpZiAoIGV4cHIgKSBzdWJUcmVlID0gc3ViVHJlZS5sdChleHByLmFyZzIuZigpLCB0aGlzLmluZGV4LmNvbXBhcmUpO1xuXG4gICAgICBleHByID0gaXNFeHByTWF0Y2gobS5MdGUpO1xuICAgICAgaWYgKCBleHByICkgc3ViVHJlZSA9IHN1YlRyZWUubHRlKGV4cHIuYXJnMi5mKCksIHRoaXMuaW5kZXguY29tcGFyZSwgdGhpcy5pbmRleC5udWxsTm9kZSk7XG5cbiAgICAgIGNvc3QgPSBzdWJUcmVlLnNpemU7XG4gICAgICB2YXIgc29ydFJlcXVpcmVkID0gISB0aGlzLmluZGV4LmlzT3JkZXJTZWxlY3RhYmxlKG9yZGVyKTtcbiAgICAgIHZhciByZXZlcnNlU29ydCA9IGZhbHNlO1xuXG4gICAgICB2YXIgc3ViT3JkZXI7XG4gICAgICB2YXIgb3JkZXJEaXJlY3Rpb25zO1xuICAgICAgaWYgKCBvcmRlciAmJiAhIHNvcnRSZXF1aXJlZCApIHtcbiAgICAgICAgLy8gd2UgbWFuYWdlIHRoZSBkaXJlY3Rpb24gb2YgdGhlIGZpcnN0IHNjYW4gZGlyZWN0bHksXG4gICAgICAgIC8vIHRhaWwgaW5kZXhlcyB3aWxsIHVzZSB0aGUgb3JkZXIub3JkZXJUYWlsKClcbiAgICAgICAgaWYgKCBvcmRlci5vcmRlckRpcmVjdGlvbigpIDwgMCApIHJldmVyc2VTb3J0ID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKCAhIHNvcnRSZXF1aXJlZCApIHtcbiAgICAgICAgaWYgKCBza2lwICkgY29zdCAtPSBza2lwO1xuICAgICAgICBpZiAoIGxpbWl0ICkgY29zdCA9IE1hdGgubWluKGNvc3QsIGxpbWl0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGFkZCBzb3J0IGNvc3RcbiAgICAgICAgaWYgKCBjb3N0ICE9PSAwICkgY29zdCAqPSBNYXRoLmxvZyhjb3N0KSAvIE1hdGgubG9nKDIpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbS5DdXN0b21QbGFuLmNyZWF0ZSh7XG4gICAgICAgIGNvc3Q6IGNvc3QsXG4gICAgICAgIGN1c3RvbUV4ZWN1dGU6IGZ1bmN0aW9uKHByb21pc2UsIHNpbmssIHNraXAsIGxpbWl0LCBvcmRlciwgcHJlZGljYXRlKSB7XG4gICAgICAgICAgaWYgKCBzb3J0UmVxdWlyZWQgKSB7XG4gICAgICAgICAgICB2YXIgYXJyU2luayA9IG0uQXJyYXlTaW5rLmNyZWF0ZSgpO1xuICAgICAgICAgICAgaW5kZXguc2VsZWN0Q291bnQrKztcbiAgICAgICAgICAgIHN1YlRyZWUuc2VsZWN0KGFyclNpbmssIG51bGwsIG51bGwsIG51bGwsIHByZWRpY2F0ZSwge30pO1xuICAgICAgICAgICAgaW5kZXguc2VsZWN0Q291bnQtLTtcbiAgICAgICAgICAgIHZhciBhID0gYXJyU2luay5hcnJheTtcbiAgICAgICAgICAgIGEuc29ydChvcmRlci5jb21wYXJlLmJpbmQob3JkZXIpKTtcblxuICAgICAgICAgICAgc2tpcCA9IHNraXAgfHwgMDtcbiAgICAgICAgICAgIGxpbWl0ID0gTnVtYmVyLmlzRmluaXRlKGxpbWl0KSA/IGxpbWl0IDogYS5sZW5ndGg7XG4gICAgICAgICAgICBsaW1pdCArPSBza2lwO1xuICAgICAgICAgICAgbGltaXQgPSBNYXRoLm1pbihhLmxlbmd0aCwgbGltaXQpO1xuXG4gICAgICAgICAgICB2YXIgc3ViID0gZm9hbS5jb3JlLkZPYmplY3QuY3JlYXRlKCk7XG4gICAgICAgICAgICB2YXIgZGV0YWNoZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIHN1Yi5vbkRldGFjaChmdW5jdGlvbigpIHsgZGV0YWNoZWQgPSB0cnVlOyB9KTtcbiAgICAgICAgICAgIGZvciAoIHZhciBpID0gc2tpcDsgaSA8IGxpbWl0OyBpKysgKSB7XG4gICAgICAgICAgICAgIHNpbmsucHV0KGFbaV0sIHN1Yik7XG4gICAgICAgICAgICAgIGlmICggZGV0YWNoZWQgKSBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaW5kZXguc2VsZWN0Q291bnQrKztcbiAgICAgICAgICAgIC8vIE5vdGU6IHBhc3Mgc2tpcCBhbmQgbGltaXQgYnkgcmVmZXJlbmNlLCBhcyB0aGV5IGFyZSBtb2RpZmllZCBpbiBwbGFjZVxuICAgICAgICAgICAgcmV2ZXJzZVNvcnQgP1xuICAgICAgICAgICAgICBzdWJUcmVlLnNlbGVjdFJldmVyc2UoXG4gICAgICAgICAgICAgICAgc2luayxcbiAgICAgICAgICAgICAgICBza2lwICE9IG51bGwgPyBbc2tpcF0gOiBudWxsLFxuICAgICAgICAgICAgICAgIGxpbWl0ICE9IG51bGwgPyBbbGltaXRdIDogbnVsbCxcbiAgICAgICAgICAgICAgICBvcmRlciwgcHJlZGljYXRlLCB7fSkgOiBzdWJUcmVlLnNlbGVjdChcbiAgICAgICAgICAgICAgICAgIHNpbmssXG4gICAgICAgICAgICAgICAgICBza2lwICE9IG51bGwgPyBbc2tpcF0gOiBudWxsLFxuICAgICAgICAgICAgICAgICAgbGltaXQgIT0gbnVsbCA/IFtsaW1pdF0gOiBudWxsLFxuICAgICAgICAgICAgICAgICAgb3JkZXIsIHByZWRpY2F0ZSwge30pIDtcbiAgICAgICAgICAgIGluZGV4LnNlbGVjdENvdW50LS07XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBjdXN0b21Ub1N0cmluZzogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuICdzY2FuKGtleT0nICsgcHJvcC5uYW1lICsgJywgY29zdD0nICsgdGhpcy5jb3N0ICtcbiAgICAgICAgICAgICAgJywgc29ydGluZz0nICsgKCBzb3J0UmVxdWlyZWQgPyBvcmRlci50b1N0cmluZygpIDogJ25vbmUnICkgK1xuICAgICAgICAgICAgICAnLCByZXZlcnNlU2Nhbj0nICsgcmV2ZXJzZVNvcnQgK1xuICAgICAgICAgICAgICAocHJlZGljYXRlICYmIHByZWRpY2F0ZS50b1NRTCA/ICcsIHByZWRpY2F0ZTogJyArIHByZWRpY2F0ZS50b1NRTCgpIDogJycpICtcbiAgICAgICAgICAgICAgJyknO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9LFxuXG4gICAgZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgICByZXR1cm4gJ1RyZWVJbmRleCgnICsgKHRoaXMuaW5kZXggfHwgdGhpcykucHJvcC5uYW1lICsgJywgJyArICh0aGlzLmluZGV4IHx8IHRoaXMpLnRhaWwgKyAnKSc7XG4gICAgfVxuICBdXG59KTtcblxuXG4vKiogQ2FzZS1JbnNlbnNpdGl2ZSBUcmVlSW5kZXggKiovXG5mb2FtLkNMQVNTKHtcbiAgcGFja2FnZTogJ2ZvYW0uZGFvLmluZGV4JyxcbiAgbmFtZTogJ0NJVHJlZUluZGV4JyxcbiAgZXh0ZW5kczogJ2ZvYW0uZGFvLmluZGV4LlRyZWVJbmRleCcsXG59KTtcblxuXG5mb2FtLkNMQVNTKHtcbiAgcGFja2FnZTogJ2ZvYW0uZGFvLmluZGV4JyxcbiAgbmFtZTogJ0NJVHJlZUluZGV4Tm9kZScsXG4gIGV4dGVuZHM6ICdmb2FtLmRhby5pbmRleC5UcmVlSW5kZXhOb2RlJyxcblxuICBtZXRob2RzOiBbXG4gICAgZnVuY3Rpb24gcHV0KG5ld1ZhbHVlKSB7XG4gICAgICB0aGlzLnJvb3QgPSB0aGlzLnJvb3QucHV0S2V5VmFsdWUoXG4gICAgICAgICAgdGhpcy5pbmRleC5wcm9wLmYobmV3VmFsdWUpLnRvTG93ZXJDYXNlKCksXG4gICAgICAgICAgbmV3VmFsdWUsXG4gICAgICAgICAgdGhpcy5pbmRleC5jb21wYXJlLFxuICAgICAgICAgIHRoaXMuaW5kZXguZGVkdXAsXG4gICAgICAgICAgdGhpcy5zZWxlY3RDb3VudCA+IDApO1xuICAgIH0sXG5cbiAgICBmdW5jdGlvbiByZW1vdmUodmFsdWUpIHtcbiAgICAgIHRoaXMucm9vdCA9IHRoaXMucm9vdC5yZW1vdmVLZXlWYWx1ZShcbiAgICAgICAgICB0aGlzLmluZGV4LnByb3AuZih2YWx1ZSkudG9Mb3dlckNhc2UoKSxcbiAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICB0aGlzLmluZGV4LmNvbXBhcmUsXG4gICAgICAgICAgdGhpcy5zZWxlY3RDb3VudCA+IDAsXG4gICAgICAgICAgdGhpcy5pbmRleC5udWxsTm9kZSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIERvIG5vdCBvcHRpbWl6ZSBidWxrbG9hZFxuICAgICAqKi9cbiAgICBmdW5jdGlvbiBidWxrTG9hZChhKSB7XG4gICAgICBhID0gYS5hcnJheSB8fCBhO1xuICAgICAgdGhpcy5yb290ID0gdGhpcy5pbmRleC5udWxsTm9kZTtcbiAgICAgIGZvciAoIHZhciBpID0gMCA7IGkgPCBhLmxlbmd0aCA7IGkrKyApIHtcbiAgICAgICAgdGhpcy5wdXQoYVtpXSk7XG4gICAgICB9XG4gICAgfVxuICBdXG59KTtcblxuXG4vKiogQW4gSW5kZXggZm9yIHN0b3JpbmcgbXVsdGktdmFsdWVkIHByb3BlcnRpZXMuICoqL1xuZm9hbS5DTEFTUyh7XG4gIHBhY2thZ2U6ICdmb2FtLmRhby5pbmRleCcsXG4gIG5hbWU6ICdTZXRJbmRleCcsXG4gIGV4dGVuZHM6ICdmb2FtLmRhby5pbmRleC5UcmVlSW5kZXgnLFxufSk7XG5cblxuZm9hbS5DTEFTUyh7XG4gIHBhY2thZ2U6ICdmb2FtLmRhby5pbmRleCcsXG4gIG5hbWU6ICdTZXRJbmRleE5vZGUnLFxuICBleHRlbmRzOiAnZm9hbS5kYW8uaW5kZXguVHJlZUluZGV4Tm9kZScsXG5cbiAgbWV0aG9kczogW1xuICAgIC8vIFRPRE86IHNlZSBpZiB0aGlzIGNhbiBiZSBkb25lIHNvbWUgb3RoZXIgd2F5XG4gICAgZnVuY3Rpb24gZGVkdXAoKSB7XG4gICAgICAvLyBOT1AsIG5vdCBzYWZlIHRvIGRvIGhlcmVcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRG8gbm90IG9wdGltaXplIGJ1bGtsb2FkIHRvIFNldEluZGV4XG4gICAgICoqL1xuICAgIGZ1bmN0aW9uIGJ1bGtMb2FkKGEpIHtcbiAgICAgIGEgPSBhLmFycmF5IHx8IGE7XG4gICAgICB0aGlzLnJvb3QgPSB0aGlzLmluZGV4Lm51bGxOb2RlO1xuICAgICAgZm9yICggdmFyIGkgPSAwIDsgaSA8IGEubGVuZ3RoIDsgaSsrICkge1xuICAgICAgICB0aGlzLnB1dChhW2ldKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgZnVuY3Rpb24gcHV0KG5ld1ZhbHVlKSB7XG4gICAgICB2YXIgYSA9IHRoaXMuaW5kZXgucHJvcC5mKG5ld1ZhbHVlKTtcblxuICAgICAgaWYgKCBhLmxlbmd0aCApIHtcbiAgICAgICAgZm9yICggdmFyIGkgPSAwIDsgaSA8IGEubGVuZ3RoIDsgaSsrICkge1xuICAgICAgICAgIHRoaXMucm9vdCA9IHRoaXMucm9vdC5wdXRLZXlWYWx1ZShcbiAgICAgICAgICAgICAgYVtpXSxcbiAgICAgICAgICAgICAgbmV3VmFsdWUsXG4gICAgICAgICAgICAgIHRoaXMuaW5kZXguY29tcGFyZSxcbiAgICAgICAgICAgICAgdGhpcy5pbmRleC5kZWR1cCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMucm9vdCA9IHRoaXMucm9vdC5wdXRLZXlWYWx1ZSgnJywgbmV3VmFsdWUsIHRoaXMuaW5kZXguY29tcGFyZSwgdGhpcy5pbmRleC5kZWR1cCk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIGZ1bmN0aW9uIHJlbW92ZSh2YWx1ZSkge1xuICAgICAgdmFyIGEgPSB0aGlzLmluZGV4LnByb3AuZih2YWx1ZSk7XG5cbiAgICAgIGlmICggYS5sZW5ndGggKSB7XG4gICAgICAgIGZvciAoIHZhciBpID0gMCA7IGkgPCBhLmxlbmd0aCA7IGkrKyApIHtcbiAgICAgICAgICB0aGlzLnJvb3QgPSB0aGlzLnJvb3QucmVtb3ZlS2V5VmFsdWUoYVtpXSwgdmFsdWUsIHRoaXMuaW5kZXguY29tcGFyZSwgdGhpcy5pbmRleC5udWxsTm9kZSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMucm9vdCA9IHRoaXMucm9vdC5yZW1vdmVLZXlWYWx1ZSgnJywgdmFsdWUsIHRoaXMuaW5kZXguY29tcGFyZSwgdGhpcy5pbmRleC5udWxsTm9kZSk7XG4gICAgICB9XG4gICAgfVxuICBdXG59KTtcbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cblxuLyoqIEFuIEluZGV4IHdoaWNoIGFkZHMgb3RoZXIgaW5kaWNlcyBhcyBuZWVkZWQuICoqL1xuZm9hbS5DTEFTUyh7XG4gIHBhY2thZ2U6ICdmb2FtLmRhby5pbmRleCcsXG4gIG5hbWU6ICdBdXRvSW5kZXgnLFxuICBleHRlbmRzOiAnZm9hbS5kYW8uaW5kZXguUHJveHlJbmRleCcsXG5cbiAgcmVxdWlyZXM6IFtcbiAgICAnZm9hbS5jb3JlLlByb3BlcnR5JyxcbiAgICAnZm9hbS5kYW8uaW5kZXguTm9QbGFuJyxcbiAgICAnZm9hbS5kYW8uaW5kZXguQ3VzdG9tUGxhbicsXG4gICAgJ2ZvYW0ubWxhbmcucHJlZGljYXRlLkFuZCcsXG4gICAgJ2ZvYW0ubWxhbmcucHJlZGljYXRlLk9yJyxcbiAgICAnZm9hbS5kYW8uaW5kZXguQWx0SW5kZXgnLFxuICAgICdmb2FtLmRhby5pbmRleC5WYWx1ZUluZGV4JyxcbiAgICAnZm9hbS5tbGFuZy5wcmVkaWNhdGUuVHJ1ZScsXG4gICAgJ2ZvYW0ubWxhbmcucHJlZGljYXRlLkZhbHNlJyxcbiAgXSxcblxuICBjb25zdGFudHM6IHtcbiAgICAvKiogTWF4aW11bSBjb3N0IGZvciBhIHBsYW4gd2hpY2ggaXMgZ29vZCBlbm91Z2ggdG8gbm90IGJvdGhlciBsb29raW5nIGF0IHRoZSByZXN0LiAqL1xuICAgIEdPT0RfRU5PVUdIX1BMQU46IDIwXG4gIH0sXG5cbiAgcHJvcGVydGllczogW1xuICAgIHtcbiAgICAgIC8qKiBVc2VkIHRvIGNyZWF0ZSB0aGUgZGVsZWdhdGUgSUQgaW5kZXggZm9yIG5ldyBpbnN0YW5jZXMgb2YgQXV0b0luZGV4ICovXG4gICAgICBuYW1lOiAnaWRJbmRleCcsXG4gICAgICByZXF1aXJlZDogdHJ1ZVxuICAgIH0sXG4gICAge1xuICAgICAgbmFtZTogJ2RlbGVnYXRlJyxcbiAgICAgIGZhY3Rvcnk6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5BbHRJbmRleC5jcmVhdGUoeyBkZWxlZ2F0ZXM6IFsgdGhpcy5pZEluZGV4IF0gfSk7XG4gICAgICB9XG4gICAgfVxuICBdLFxuXG4gIG1ldGhvZHM6IFtcbiAgICBmdW5jdGlvbiBlc3RpbWF0ZShzaXplLCBzaW5rLCBza2lwLCBsaW1pdCwgb3JkZXIsIHByZWRpY2F0ZSkge1xuICAgICAgcmV0dXJuIHRoaXMuZGVsZWdhdGUuZXN0aW1hdGUoc2l6ZSwgc2luaywgc2tpcCwgbGltaXQsIG9yZGVyLCBwcmVkaWNhdGUpO1xuICAgIH0sXG5cbiAgICBmdW5jdGlvbiB0b1ByZXR0eVN0cmluZyhpbmRlbnQpIHtcbiAgICAgIHZhciByZXQgPSAnJztcbiAgICAgIHJldCA9ICcgICcucmVwZWF0KGluZGVudCkgKyAnQXV0bygnICsgdGhpcy4kVUlEICsgJylcXG4nO1xuICAgICAgcmV0ICs9IHRoaXMuZGVsZWdhdGUudG9QcmV0dHlTdHJpbmcoaW5kZW50ICsgMSk7XG4gICAgICByZXR1cm4gcmV0O1xuICAgIH1cblxuICBdXG59KTtcblxuXG5mb2FtLkNMQVNTKHtcbiAgcGFja2FnZTogJ2ZvYW0uZGFvLmluZGV4JyxcbiAgbmFtZTogJ0F1dG9JbmRleE5vZGUnLFxuICBleHRlbmRzOiAnZm9hbS5kYW8uaW5kZXguUHJveHlJbmRleE5vZGUnLFxuXG4gIG1ldGhvZHM6IFtcbiAgICBmdW5jdGlvbiBhZGRQcm9wZXJ0eUluZGV4KHByb3AsIHJvb3QpIHtcbiAgICAgIHRoaXMuYWRkSW5kZXgocHJvcC50b0luZGV4KHRoaXMuaW5kZXguY2xzXy5jcmVhdGUoe1xuICAgICAgICBpZEluZGV4OiB0aGlzLmluZGV4LmlkSW5kZXhcbiAgICAgIH0pKSwgcm9vdCk7XG4gICAgfSxcblxuICAgIGZ1bmN0aW9uIGFkZEluZGV4KGluZGV4LCByb290KSB7XG4gICAgICB0aGlzLmRlbGVnYXRlLmFkZEluZGV4KGluZGV4LCByb290KTtcbiAgICB9LFxuXG4gICAgLy8gVE9ETzogbWxhbmcgY29tcGFyYXRvcnMgc2hvdWxkIHN1cHBvcnQgaW5wdXQgY29sbGVjdGlvbiBmb3JcbiAgICAvLyAgIGluZGV4LWJ1aWxkaW5nIGNhc2VzIGxpa2UgdGhpc1xuICAgIGZ1bmN0aW9uIHBsYW4oc2luaywgc2tpcCwgbGltaXQsIG9yZGVyLCBwcmVkaWNhdGUsIHJvb3QpIHtcbiAgICAgIC8vIE5PVEU6IFVzaW5nIHRoZSBleGlzdGluZyBpbmRleCdzIHBsYW4gYXMgaXRzIGNvc3Qgd2hlbiBjb21wYXJpbmdcbiAgICAgIC8vICBhZ2FpbnN0IGVzdGltYXRlcyBpcyBiYWQuIEFuIG9wdGltaXN0aWMgZXN0aW1hdGUgZnJvbSBhbiBpbmRleFxuICAgICAgLy8gIHdpbGwgY2F1c2UgaXQgdG8gYWx3YXlzIGFwcGVhciBiZXR0ZXIgdGhhbiBpdHMgcmVhbCB3b3JsZFxuICAgICAgLy8gIHBlcmZvcm1hbmNlLCBsZWFkaW5nIEF1dG9JbmRleCB0byBrZWVwIGNyZWF0aW5nIG5ldyBpbnN0YW5jZXNcbiAgICAgIC8vICBvZiB0aGUgb2ZmZW5kaW5nIGluZGV4LiBDb21wYXJpbmcgZXN0aW1hdGVzIHRvIGVzdGltYXRlcyBpcyBtdWNoXG4gICAgICAvLyAgbW9yZSBjb25zaXN0ZW50IGFuZCBhbGxvd3MgZXN0aW1hdGUoKSB0byBiZSBhcmJpdHJhcmlseSBiYWRcbiAgICAgIC8vICBhcyBsb25nIGFzIGl0IGlzIGluZGljYXRpdmUgb2YgcmVsYXRpdmUgcGVyZm9ybWFuY2Ugb2YgZWFjaFxuICAgICAgLy8gIGluZGV4IHR5cGUuXG4gICAgICB2YXIgZXhpc3RpbmdQbGFuID0gdGhpcy5kZWxlZ2F0ZS5wbGFuKHNpbmssIHNraXAsIGxpbWl0LCBvcmRlciwgcHJlZGljYXRlLCByb290KTtcbiAgICAgIHZhciB0aGlzU2l6ZSA9IHRoaXMuc2l6ZSgpO1xuXG4gICAgICAvLyBObyBuZWVkIHRvIHRyeSB0byBhdXRvLWluZGV4IGlmOlxuICAgICAgLy8gIC0gVGhlIGV4aXN0aW5nIHBsYW4gaXMgYmV0dGVyIHRoYW4gc2Nhbm5pbmcgYWxyZWFkeSBUT0RPOiBob3cgbXVjaCBiZXR0ZXI/XG4gICAgICAvLyAgLSBXZSBhcmUgdG9vIHNtYWxsIHRvIG1hdHRlclxuICAgICAgLy8gIC0gVGhlcmUgYXJlIG5vIG9yZGVyL3ByZWRpY2F0ZSBjb25zdHJhaW50cyB0byBvcHRpbWl6ZSBmb3JcbiAgICAgIGlmICggZXhpc3RpbmdQbGFuLmNvc3QgPCB0aGlzU2l6ZSB8fFxuICAgICAgICAgICB0aGlzU2l6ZSA8IHRoaXMuaW5kZXguR09PRF9FTk9VR0hfUExBTiB8fFxuICAgICAgICAgICAhIG9yZGVyICYmXG4gICAgICAgICAgICggISBwcmVkaWNhdGUgfHxcbiAgICAgICAgICAgICB0aGlzLmluZGV4LlRydWUuaXNJbnN0YW5jZShwcmVkaWNhdGUpIHx8XG4gICAgICAgICAgICAgdGhpcy5pbmRleC5GYWxzZS5pc0luc3RhbmNlKHByZWRpY2F0ZSlcbiAgICAgICAgICAgKVxuICAgICAgKSB7XG4gICAgICAgIHJldHVybiBleGlzdGluZ1BsYW47XG4gICAgICB9XG5cbiAgICAgIC8vIGFkZCBhdXRvaW5kZXggb3ZlcmhlYWRcbiAgICAgIGV4aXN0aW5nUGxhbi5jb3N0ICs9IDEwO1xuXG4gICAgICB2YXIgQVJCSVRSQVJZX0lOREVYX0NSRUFURV9GQUNUT1IgPSAxLjU7XG4gICAgICB2YXIgQVJCSVRSQVJZX0lOREVYX0NSRUFURV9DT05TVEFOVCA9IDIwO1xuXG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICB2YXIgbmV3SW5kZXg7XG5cbiAgICAgIHZhciBiZXN0RXN0aW1hdGUgPSB0aGlzLmRlbGVnYXRlLmluZGV4LmVzdGltYXRlKHRoaXMuZGVsZWdhdGUuc2l6ZSgpLCBzaW5rLCBza2lwLCBsaW1pdCwgb3JkZXIsIHByZWRpY2F0ZSk7XG4vL2NvbnNvbGUubG9nKHNlbGYuJFVJRCwgXCJBdXRvRXN0IE9MRDpcIiwgYmVzdEVzdGltYXRlLCB0aGlzLmRlbGVnYXRlLnRvU3RyaW5nKCkuc3Vic3RyaW5nKDAsMjApLCB0aGlzLnNpemUoKSk7XG4gICAgICBpZiAoIGJlc3RFc3RpbWF0ZSA8IHRoaXMuaW5kZXguR09PRF9FTk9VR0hfUExBTiApIHtcbiAgICAgICAgcmV0dXJuIGV4aXN0aW5nUGxhbjtcbiAgICAgIH1cblxuICAgICAgLy8gQmFzZSBwbGFubmVkIGNvc3Qgb24gdGhlIG9sZCBjb3N0IGZvciB0aGUgcGxhbiwgdG8gYXZvaWQgdW5kZXJlc3RpbWF0aW5nIGFuZCBtYWtpbmcgdGhpc1xuICAgICAgLy8gIGluZGV4IGJ1aWxkIGxvb2sgdG9vIGdvb2RcbiAgICAgIHZhciBleGlzdGluZ0VzdGltYXRlID0gYmVzdEVzdGltYXRlO1xuICAgICAgdmFyIGlkSW5kZXggPSB0aGlzLmluZGV4LmlkSW5kZXg7XG5cbiAgICAgIGlmICggcHJlZGljYXRlICkge1xuICAgICAgICB2YXIgY2FuZGlkYXRlID0gcHJlZGljYXRlLnRvSW5kZXgoXG4gICAgICAgICAgdGhpcy5pbmRleC5jbHNfLmNyZWF0ZSh7IGlkSW5kZXg6IGlkSW5kZXggfSksIDEpOyAvLyBkZXB0aCAxXG4gICAgICAgIGlmICggY2FuZGlkYXRlICkge1xuICAgICAgICAgIHZhciBjYW5kaWRhdGVFc3QgPSBjYW5kaWRhdGUuZXN0aW1hdGUodGhpcy5kZWxlZ2F0ZS5zaXplKCksIHNpbmssXG4gICAgICAgICAgICBza2lwLCBsaW1pdCwgb3JkZXIsIHByZWRpY2F0ZSlcbiAgICAgICAgICAgICogQVJCSVRSQVJZX0lOREVYX0NSRUFURV9GQUNUT1JcbiAgICAgICAgICAgICsgQVJCSVRSQVJZX0lOREVYX0NSRUFURV9DT05TVEFOVDtcblxuLy9jb25zb2xlLmxvZyhzZWxmLiRVSUQsIFwiQXV0b0VzdCBQUkQ6XCIsIGNhbmRpZGF0ZUVzdCwgY2FuZGlkYXRlLnRvU3RyaW5nKCkuc3Vic3RyaW5nKDAsMjApKTtcbiAgICAgICAgICAvL1RPRE86IG11c3QgYmVhdCBieSBmYWN0b3Igb2YgWD8gb3IgY29uc3RhbnQ/XG4gICAgICAgICAgaWYgKCBiZXN0RXN0aW1hdGUgPiBjYW5kaWRhdGVFc3QgKSB7XG4gICAgICAgICAgICBuZXdJbmRleCA9IGNhbmRpZGF0ZTtcbiAgICAgICAgICAgIGJlc3RFc3RpbWF0ZSA9IGNhbmRpZGF0ZUVzdDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gIFRoZSBvcmRlciBpbmRleC5lc3RpbWF0ZSBnZXRzIHRoZSBvcmRlciBBTkQgcHJlZGljYXRlLFxuICAgICAgLy8gICBzbyB0aGUgcHJlZGljYXRlIG1pZ2h0IG1ha2UgdGhpcyBpbmRleCB3b3JzZVxuICAgICAgaWYgKCBvcmRlciApIHtcbiAgICAgICAgdmFyIGNhbmRpZGF0ZSA9IG9yZGVyLnRvSW5kZXgoXG4gICAgICAgICAgdGhpcy5pbmRleC5jbHNfLmNyZWF0ZSh7IGlkSW5kZXg6IGlkSW5kZXggfSksIDEpOyAvLyBkZXB0aCAxXG4gICAgICAgIGlmICggY2FuZGlkYXRlICkge1xuICAgICAgICAgIHZhciBjYW5kaWRhdGVFc3QgPSBjYW5kaWRhdGUuZXN0aW1hdGUodGhpcy5kZWxlZ2F0ZS5zaXplKCksIHNpbmssXG4gICAgICAgICAgICBza2lwLCBsaW1pdCwgb3JkZXIsIHByZWRpY2F0ZSlcbiAgICAgICAgICAgICogQVJCSVRSQVJZX0lOREVYX0NSRUFURV9GQUNUT1JcbiAgICAgICAgICAgICsgQVJCSVRSQVJZX0lOREVYX0NSRUFURV9DT05TVEFOVDtcbi8vY29uc29sZS5sb2coc2VsZi4kVUlELCBcIkF1dG9Fc3QgT1JEOlwiLCBjYW5kaWRhdGVFc3QsIGNhbmRpZGF0ZS50b1N0cmluZygpLnN1YnN0cmluZygwLDIwKSk7XG4gICAgICAgICAgaWYgKCBiZXN0RXN0aW1hdGUgPiBjYW5kaWRhdGVFc3QgKSB7XG4gICAgICAgICAgICBuZXdJbmRleCA9IGNhbmRpZGF0ZTtcbiAgICAgICAgICAgIGJlc3RFc3RpbWF0ZSA9IGNhbmRpZGF0ZUVzdDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuXG4gICAgICBpZiAoIG5ld0luZGV4ICkge1xuICAgICAgICAvLyBTaW5jZSBlc3RpbWF0ZXMgYXJlIG9ubHkgdmFsaWQgY29tcGFyZWQgdG8gb3RoZXIgZXN0aW1hdGVzLCBmaW5kIHRoZSByYXRpb1xuICAgICAgICAvLyAgb2Ygb3VyIGV4aXN0aW5nIGluZGV4J3MgZXN0aW1hdGUgdG8gb3VyIG5ldyBlc3RpbWF0ZSwgYW5kIGFwcGx5IHRoYXQgcmF0aW9cbiAgICAgICAgLy8gIHRvIHRoZSBhY3R1YWwgY29zdCBvZiB0aGUgb2xkIHBsYW4gdG8gZGV0ZXJtaW5lIG91ciBuZXcgaW5kZXgncyBhc3N1bWVkIGNvc3QuXG4gICAgICAgIHZhciBleGlzdGluZ1BsYW5Db3N0ID0gZXhpc3RpbmdQbGFuLmNvc3Q7XG4gICAgICAgIHZhciBlc3RpbWF0ZVJhdGlvID0gYmVzdEVzdGltYXRlIC8gZXhpc3RpbmdFc3RpbWF0ZTtcblxuICAgICAgICByZXR1cm4gdGhpcy5pbmRleC5DdXN0b21QbGFuLmNyZWF0ZSh7XG4gICAgICAgICAgY29zdDogZXhpc3RpbmdQbGFuQ29zdCAqIGVzdGltYXRlUmF0aW8sXG4gICAgICAgICAgY3VzdG9tRXhlY3V0ZTogZnVuY3Rpb24gYXV0b0luZGV4QWRkKGFwcm9taXNlLCBhc2luaywgYXNraXAsIGFsaW1pdCwgYW9yZGVyLCBhcHJlZGljYXRlKSB7XG5cbmNvbnNvbGUubG9nKHNlbGYuJFVJRCwgXCJCVUlMRElORyBJTkRFWFwiLCBleGlzdGluZ1BsYW5Db3N0LCBlc3RpbWF0ZVJhdGlvLCB0aGlzLmNvc3QsIHByZWRpY2F0ZSAmJiBwcmVkaWNhdGUudG9TdHJpbmcoKSk7XG4vL2NvbnNvbGUubG9nKG5ld0luZGV4LnRvUHJldHR5U3RyaW5nKDApKTtcbi8vY29uc29sZS5sb2coc2VsZi4kVUlELCBcIlJPT1QgICAgICAgICAgXCIpO1xuLy9jb25zb2xlLmxvZyhyb290LmluZGV4LnRvUHJldHR5U3RyaW5nKDApKTtcblxuICAgICAgICAgICAgc2VsZi5hZGRJbmRleChuZXdJbmRleCwgcm9vdCk7XG4gICAgICAgICAgICAvLyBBdm9pZCBhIHJlY3Vyc2l2ZSBjYWxsIGJ5IGhpdHRpbmcgb3VyIGRlbGVnYXRlLlxuICAgICAgICAgICAgLy8gSXQgc2hvdWxkIHBpY2sgdGhlIG5ldyBvcHRpbWFsIGluZGV4LlxuICAgICAgICAgICAgc2VsZi5kZWxlZ2F0ZVxuICAgICAgICAgICAgICAucGxhbihzaW5rLCBza2lwLCBsaW1pdCwgb3JkZXIsIHByZWRpY2F0ZSwgcm9vdClcbiAgICAgICAgICAgICAgLmV4ZWN1dGUoYXByb21pc2UsIGFzaW5rLCBhc2tpcCwgYWxpbWl0LCBhb3JkZXIsIGFwcmVkaWNhdGUpO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgY3VzdG9tVG9TdHJpbmc6IGZ1bmN0aW9uKCkgeyByZXR1cm4gJ0F1dG9JbmRleEFkZCBjb3N0PScgKyB0aGlzLmNvc3QgKyAnLCAnICsgbmV3SW5kZXguY2xzXy5uYW1lOyB9XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGV4aXN0aW5nUGxhbjtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgICByZXR1cm4gJ0F1dG9JbmRleCgnICsgKHRoaXMuaW5kZXggfHwgdGhpcykuZGVsZWdhdGUudG9TdHJpbmcoKSArICcpJztcbiAgICB9LFxuXG4gIF1cbn0pO1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxMiBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5mb2FtLkNMQVNTKHtcbiAgcGFja2FnZTogJ2ZvYW0uZGFvJyxcbiAgbmFtZTogJ01EQU8nLFxuICBsYWJlbDogJ0luZGV4ZWQgREFPJyxcbiAgZXh0ZW5kczogJ2ZvYW0uZGFvLkFic3RyYWN0REFPJyxcblxuICBkb2N1bWVudGF0aW9uOiAnSW5kZXhlZCBpbi1NZW1vcnkgREFPLicsXG5cbiAgcmVxdWlyZXM6IFtcbiAgICAnZm9hbS5kYW8uQXJyYXlTaW5rJyxcbiAgICAnZm9hbS5kYW8uRXh0ZXJuYWxFeGNlcHRpb24nLFxuICAgICdmb2FtLmRhby5JbnRlcm5hbEV4Y2VwdGlvbicsXG4gICAgJ2ZvYW0uZGFvLkludmFsaWRBcmd1bWVudEV4Y2VwdGlvbicsXG4gICAgJ2ZvYW0uZGFvLmluZGV4LkFsdEluZGV4JyxcbiAgICAnZm9hbS5kYW8uaW5kZXguQXV0b0luZGV4JyxcbiAgICAnZm9hbS5kYW8uaW5kZXguU2V0SW5kZXgnLFxuICAgICdmb2FtLmRhby5pbmRleC5UcmVlSW5kZXgnLFxuICAgICdmb2FtLmRhby5pbmRleC5WYWx1ZUluZGV4JyxcbiAgICAnZm9hbS5tbGFuZy5wcmVkaWNhdGUuRXEnLFxuICAgICdmb2FtLm1sYW5nLnByZWRpY2F0ZS5UcnVlJyxcbiAgICAnZm9hbS5tbGFuZy5wcmVkaWNhdGUuT3InLFxuICAgICdmb2FtLm1sYW5nLnNpbmsuRXhwbGFpbicsXG4gICAgJ2ZvYW0uZGFvLmluZGV4Lk1lcmdlUGxhbidcbiAgXSxcblxuICBwcm9wZXJ0aWVzOiBbXG4gICAge1xuICAgICAgY2xhc3M6ICdDbGFzcycsXG4gICAgICBuYW1lOiAgJ29mJyxcbiAgICAgIHJlcXVpcmVkOiB0cnVlLFxuICAgICAgcG9zdFNldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIGZvYW0uYXNzZXJ0KHRoaXMub2YuSUQsIFwiTURBTy5vZiBtdXN0IGJlIGFzc2lnbmVkIGEgRk9BTSBDbGFzcyBcIiArXG4gICAgICAgICAgXCJ3aXRoIGFuICdpZCcgUHJvcGVydHkgb3IgJ2lkcycgYXJyYXkgc3BlY2lmaWVkLiBNaXNzaW5nIGlkIGluIFwiICtcbiAgICAgICAgICBcImNsYXNzOiBcIiArICggdGhpcy5vZiAmJiB0aGlzLm9mLmlkICkpO1xuICAgICAgfVxuICAgIH0sXG4gICAge1xuICAgICAgY2xhc3M6ICdCb29sZWFuJyxcbiAgICAgIG5hbWU6ICdhdXRvSW5kZXgnXG4gICAgfSxcbiAgICB7XG4gICAgICBuYW1lOiAnaWRJbmRleCcsXG4gICAgICB0cmFuc2llbnQ6IHRydWVcbiAgICB9LFxuICAgIHtcbiAgICAgIC8qKiBUaGUgcm9vdCBJbmRleE5vZGUgb2Ygb3VyIGluZGV4LiAqL1xuICAgICAgbmFtZTogJ2luZGV4JyxcbiAgICAgIHRyYW5zaWVudDogdHJ1ZVxuICAgIH1cbiAgXSxcblxuICBtZXRob2RzOiBbXG4gICAgZnVuY3Rpb24gaW5pdCgpIHtcbiAgICAgIC8vIGFkZHMgdGhlIHByaW1hcnkga2V5KHMpIGFzIGFuIGluZGV4LCBhbmQgc3RvcmVzIGl0IGZvciBmYXN0IGZpbmQoKS5cbiAgICAgIHRoaXMuYWRkUHJvcGVydHlJbmRleCgpO1xuICAgICAgdGhpcy5pZEluZGV4ID0gdGhpcy5pbmRleDtcblxuICAgICAgaWYgKCB0aGlzLmF1dG9JbmRleCApIHtcbiAgICAgICAgdGhpcy5hZGRJbmRleCh0aGlzLkF1dG9JbmRleC5jcmVhdGUoeyBpZEluZGV4OiB0aGlzLmlkSW5kZXguaW5kZXggfSkpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBZGQgYSBub24tdW5pcXVlIGluZGV4XG4gICAgICogYXJnczogb25lIG9yIG1vcmUgcHJvcGVydGllc1xuICAgICAqKi9cbiAgICBmdW5jdGlvbiBhZGRQcm9wZXJ0eUluZGV4KCkge1xuICAgICAgdmFyIHByb3BzID0gQXJyYXkuZnJvbShhcmd1bWVudHMpO1xuXG4gICAgICAvLyBBZGQgSUQgdG8gbWFrZSBlYWNoIHN1cmUgdGhlIG9iamVjdCBpcyB1bmlxdWVseSBpZGVudGlmaWVkXG4gICAgICBwcm9wcy5wdXNoKHRoaXMub2YuSUQpO1xuXG4gICAgICByZXR1cm4gdGhpcy5hZGRVbmlxdWVJbmRleF8uYXBwbHkodGhpcywgcHJvcHMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBZGQgYSB1bmlxdWUgaW5kZXhcbiAgICAgKiBhcmdzOiBvbmUgb3IgbW9yZSBwcm9wZXJ0aWVzXG4gICAgICogQHByaXZhdGVcbiAgICAgKiovXG4gICAgZnVuY3Rpb24gYWRkVW5pcXVlSW5kZXhfKCkge1xuICAgICAgdmFyIGluZGV4ID0gdGhpcy5WYWx1ZUluZGV4LmNyZWF0ZSgpO1xuXG4gICAgICBmb3IgKCB2YXIgaSA9IGFyZ3VtZW50cy5sZW5ndGgtMSA7IGkgPj0gMCA7IGktLSApIHtcbiAgICAgICAgdmFyIHByb3AgPSBhcmd1bWVudHNbaV07XG5cbiAgICAgICAgLy8gUGFzcyBwcmV2aW91cyBpbmRleCBhcyB0aGUgc3ViLWluZGV4IG9mIHRoZSBuZXh0IGxldmVsIHVwLlxuICAgICAgICAvLyAod2UgYXJlIHdvcmtpbmcgZnJvbSBsZWFmLW1vc3QgaW5kZXggdXAgdG8gcm9vdCBpbmRleCBpbiB0aGUgbGlzdClcbiAgICAgICAgaW5kZXggPSBwcm9wLnRvSW5kZXgoaW5kZXgpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5hZGRJbmRleChpbmRleCk7XG4gICAgfSxcblxuICAgIGZ1bmN0aW9uIGFkZEluZGV4KGluZGV4KSB7XG4gICAgICBpZiAoICEgdGhpcy5pbmRleCApIHtcbiAgICAgICAgdGhpcy5pbmRleCA9IGluZGV4LmNyZWF0ZU5vZGUoKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG5cbiAgICAgIC8vIFVwZ3JhZGUgc2luZ2xlIEluZGV4IHRvIGFuIEFsdEluZGV4IGlmIHJlcXVpcmVkLlxuICAgICAgaWYgKCAhIHRoaXMuQWx0SW5kZXguaXNJbnN0YW5jZSh0aGlzLmluZGV4LmluZGV4KSApIHtcbiAgICAgICAgdGhpcy5pbmRleCA9IHRoaXMuQWx0SW5kZXguY3JlYXRlKHtcbiAgICAgICAgICBkZWxlZ2F0ZXM6IFsgdGhpcy5pbmRleC5pbmRleCBdIC8vIGNyZWF0ZSBmYWN0b3J5XG4gICAgICAgIH0pLmNyZWF0ZU5vZGUoe1xuICAgICAgICAgIGRlbGVnYXRlczogWyB0aGlzLmluZGV4IF0gLy8gY3JlYXRlIGFuIGluc3RhbmNlXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmluZGV4LmFkZEluZGV4KGluZGV4LCB0aGlzLmluZGV4KTtcblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEJ1bGsgbG9hZCBkYXRhIGZyb20gYW5vdGhlciBEQU8uXG4gICAgICogQW55IGRhdGEgYWxyZWFkeSBsb2FkZWQgaW50byB0aGlzIERBTyB3aWxsIGJlIGxvc3QuXG4gICAgICogQHBhcmFtIHNpbmsgKG9wdGlvbmFsKSBlb2YgaXMgY2FsbGVkIHdoZW4gbG9hZGluZyBpcyBjb21wbGV0ZS5cbiAgICAgKiovXG4gICAgZnVuY3Rpb24gYnVsa0xvYWQoZGFvKSB7XG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICB2YXIgc2luayA9IHNlbGYuQXJyYXlTaW5rLmNyZWF0ZSgpO1xuICAgICAgcmV0dXJuIGRhby5zZWxlY3Qoc2luaykudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGEgPSBzaW5rLmFycmF5O1xuICAgICAgICBzZWxmLmluZGV4LmJ1bGtMb2FkKGEpO1xuICAgICAgICBmb3IgKCB2YXIgaSA9IDA7IGkgPCBhLmxlbmd0aDsgKytpICkge1xuICAgICAgICAgIHZhciBvYmogPSBhW2ldO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9LFxuXG4gICAgZnVuY3Rpb24gcHV0Xyh4LCBvYmopIHtcbiAgICAgIHZhciBvbGRWYWx1ZSA9IHRoaXMuZmluZFN5bmNfKG9iai5pZCk7XG4gICAgICBpZiAoIG9sZFZhbHVlICkge1xuICAgICAgICB0aGlzLmluZGV4LnJlbW92ZShvbGRWYWx1ZSk7XG4gICAgICB9XG4gICAgICB0aGlzLmluZGV4LnB1dChvYmopO1xuICAgICAgdGhpcy5wdWIoJ29uJywgJ3B1dCcsIG9iaik7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKG9iaik7XG4gICAgfSxcblxuICAgIGZ1bmN0aW9uIGZpbmRfKHgsIG9iak9yS2V5KSB7XG4gICAgICBpZiAoIG9iak9yS2V5ID09PSB1bmRlZmluZWQgKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdCh0aGlzLkludmFsaWRBcmd1bWVudEV4Y2VwdGlvbi5jcmVhdGUoe1xuICAgICAgICAgIG1lc3NhZ2U6ICdcImtleVwiIGNhbm5vdCBiZSB1bmRlZmluZWQvbnVsbCdcbiAgICAgICAgfSkpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRoaXMuZmluZFN5bmNfKFxuICAgICAgICAgIHRoaXMub2YuaXNJbnN0YW5jZShvYmpPcktleSkgPyBvYmpPcktleS5pZCA6IG9iak9yS2V5KSk7XG4gICAgfSxcblxuICAgIC8qKiBpbnRlcm5hbCwgc3luY2hyb25vdXMgdmVyc2lvbiBvZiBmaW5kLCBkb2VzIG5vdCB0aHJvdyAqL1xuICAgIGZ1bmN0aW9uIGZpbmRTeW5jXyhrZXkpIHtcbiAgICAgIHZhciBpbmRleCA9IHRoaXMuaWRJbmRleDtcbiAgICAgIGluZGV4ID0gaW5kZXguZ2V0KGtleSk7XG5cbiAgICAgIGlmICggaW5kZXggJiYgaW5kZXguZ2V0KCkgKSByZXR1cm4gaW5kZXguZ2V0KCk7XG5cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH0sXG5cbiAgICBmdW5jdGlvbiByZW1vdmVfKHgsIG9iaikge1xuICAgICAgaWYgKCAhIG9iaiB8fCBvYmouaWQgPT09IHVuZGVmaW5lZCApIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KHRoaXMuRXh0ZXJuYWxFeGNlcHRpb24uY3JlYXRlKHsgaWQ6ICdub19pZCcgfSkpOyAvLyBUT0RPOiBlcnJcbiAgICAgIH1cblxuICAgICAgdmFyIGlkICAgPSBvYmouaWQ7XG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICAgIHZhciBmb3VuZCA9IHRoaXMuZmluZFN5bmNfKGlkKTtcbiAgICAgIGlmICggZm91bmQgKSB7XG4gICAgICAgIHNlbGYuaW5kZXgucmVtb3ZlKGZvdW5kKTtcbiAgICAgICAgc2VsZi5wdWIoJ29uJywgJ3JlbW92ZScsIGZvdW5kKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgIH0sXG5cbiAgICBmdW5jdGlvbiByZW1vdmVBbGxfKHgsIHNraXAsIGxpbWl0LCBvcmRlciwgcHJlZGljYXRlKSB7XG4gICAgICBpZiAoICEgcHJlZGljYXRlICkgcHJlZGljYXRlID0gdGhpcy5UcnVlLmNyZWF0ZSgpO1xuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgcmV0dXJuIHNlbGYud2hlcmUocHJlZGljYXRlKS5zZWxlY3Qoc2VsZi5BcnJheVNpbmsuY3JlYXRlKCkpLnRoZW4oXG4gICAgICAgIGZ1bmN0aW9uKHNpbmspIHtcbiAgICAgICAgICB2YXIgYSA9IHNpbmsuYXJyYXk7XG4gICAgICAgICAgZm9yICggdmFyIGkgPSAwIDsgaSA8IGEubGVuZ3RoIDsgaSsrICkge1xuICAgICAgICAgICAgc2VsZi5pbmRleC5yZW1vdmUoYVtpXSk7XG4gICAgICAgICAgICBzZWxmLnB1Yignb24nLCAncmVtb3ZlJywgYVtpXSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICAgICAgfVxuICAgICAgKTtcbiAgICB9LFxuXG4gICAgZnVuY3Rpb24gc2VsZWN0Xyh4LCBzaW5rLCBza2lwLCBsaW1pdCwgb3JkZXIsIHByZWRpY2F0ZSkge1xuICAgICAgc2luayA9IHNpbmsgfHwgdGhpcy5BcnJheVNpbmsuY3JlYXRlKCk7XG4gICAgICB2YXIgcGxhbjtcbi8vY29uc29sZS5sb2coXCItLS0tc2VsZWN0XCIpO1xuICAgICAgaWYgKCB0aGlzLkV4cGxhaW4uaXNJbnN0YW5jZShzaW5rKSApIHtcbiAgICAgICAgcGxhbiA9IHRoaXMuaW5kZXgucGxhbihzaW5rLmFyZzEsIHNraXAsIGxpbWl0LCBvcmRlciwgcHJlZGljYXRlLCB0aGlzLmluZGV4KTtcbiAgICAgICAgc2luay5wbGFuID0gJ2Nvc3Q6ICcgKyBwbGFuLmNvc3QgKyAnLCAnICsgcGxhbi50b1N0cmluZygpO1xuICAgICAgICBzaW5rICYmIHNpbmsuZW9mICYmIHNpbmsuZW9mKCk7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoc2luayk7XG4gICAgICB9XG5cbiAgICAgIHByZWRpY2F0ZSA9IHByZWRpY2F0ZSAmJiBwcmVkaWNhdGUudG9EaXNqdW5jdGl2ZU5vcm1hbEZvcm0oKTtcbiAgICAgIGlmICggISBwcmVkaWNhdGUgfHwgISB0aGlzLk9yLmlzSW5zdGFuY2UocHJlZGljYXRlKSApIHtcbiAgICAgICAgcGxhbiA9IHRoaXMuaW5kZXgucGxhbihzaW5rLCBza2lwLCBsaW1pdCwgb3JkZXIsIHByZWRpY2F0ZSwgdGhpcy5pbmRleCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwbGFuID0gdGhpcy5wbGFuRm9yT3Ioc2luaywgc2tpcCwgbGltaXQsIG9yZGVyLCBwcmVkaWNhdGUpO1xuICAgICAgfVxuXG4gICAgICB2YXIgcHJvbWlzZSA9IFtQcm9taXNlLnJlc29sdmUoKV07XG4gICAgICBwbGFuLmV4ZWN1dGUocHJvbWlzZSwgc2luaywgc2tpcCwgbGltaXQsIG9yZGVyLCBwcmVkaWNhdGUpO1xuICAgICAgcmV0dXJuIHByb21pc2VbMF0udGhlbihcbiAgICAgICAgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgc2luayAmJiBzaW5rLmVvZiAmJiBzaW5rLmVvZigpO1xuICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoc2luayk7XG4gICAgICAgIH0sXG4gICAgICAgIGZ1bmN0aW9uKGVycikge1xuICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChlcnIpO1xuICAgICAgICB9XG4gICAgICApO1xuICAgIH0sXG5cbiAgICBmdW5jdGlvbiBwbGFuRm9yT3Ioc2luaywgc2tpcCwgbGltaXQsIG9yZGVyLCBwcmVkaWNhdGUpIHtcbiAgICAgIC8vIGlmIHRoZXJlJ3MgYSBsaW1pdCwgYWRkIHNraXAgdG8gbWFrZSBzdXJlIHdlIGdldCBlbm91Z2ggcmVzdWx0c1xuICAgICAgLy8gICBmcm9tIGVhY2ggc3VicXVlcnkuIE91ciBzaW5rIHdpbGwgdGhyb3cgb3V0IHRoZSBleHRyYSByZXN1bHRzXG4gICAgICAvLyAgIGFmdGVyIHNvcnRpbmcuXG4gICAgICB2YXIgc3ViTGltaXQgPSAoIGxpbWl0ID8gbGltaXQgKyAoIHNraXAgPyBza2lwIDogMCApIDogdW5kZWZpbmVkICk7XG5cbiAgICAgIC8vIFRoaXMgaXMgYW4gaW5zdGFuY2Ugb2YgT1IsIGJyZWFrIHVwIGludG8gc2VwYXJhdGUgcXVlcmllc1xuICAgICAgdmFyIGFyZ3MgID0gcHJlZGljYXRlLmFyZ3M7XG4gICAgICB2YXIgcGxhbnMgPSBbXTtcbiAgICAgIGZvciAoIHZhciBpID0gMCA7IGkgPCBhcmdzLmxlbmd0aCA7IGkrKyApIHtcbiAgICAgICAgLy8gTk9URTogd2UgcGFzcyBzaW5rIGhlcmUsIGJ1dCBpdCdzIG5vdCBnb2luZyB0byBiZSB0aGUgb25lIGV2ZW50dWFsbHlcbiAgICAgICAgLy8gdXNlZC5cbiAgICAgICAgcGxhbnMucHVzaChcbiAgICAgICAgICB0aGlzLmluZGV4LnBsYW4oc2luaywgdW5kZWZpbmVkLCBzdWJMaW1pdCwgb3JkZXIsIGFyZ3NbaV0sIHRoaXMuaW5kZXgpXG4gICAgICAgICk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLk1lcmdlUGxhbi5jcmVhdGUoeyBvZjogdGhpcy5vZiwgc3ViUGxhbnM6IHBsYW5zLCBwcmVkaWNhdGVzOiBhcmdzIH0pO1xuICAgIH0sXG5cbiAgICBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICAgIHJldHVybiAnTURBTygnICsgdGhpcy5jbHNfLm5hbWUgKyAnLCcgKyB0aGlzLmluZGV4ICsgJyknO1xuICAgIH1cbiAgXVxufSk7XG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5mb2FtLkNMQVNTKHtcbiAgcGFja2FnZTogJ2ZvYW0uZGFvJyxcbiAgbmFtZTogJ0FycmF5REFPJyxcbiAgZXh0ZW5kczogJ2ZvYW0uZGFvLkFic3RyYWN0REFPJyxcblxuICBkb2N1bWVudGF0aW9uOiAnREFPIGltcGxlbWVudGF0aW9uIGJhY2tlZCBieSBhbiBhcnJheS4nLFxuXG4gIHJlcXVpcmVzOiBbXG4gICAgJ2ZvYW0uZGFvLkFycmF5U2luaycsXG4gICAgJ2ZvYW0ubWxhbmcucHJlZGljYXRlLlRydWUnXG4gIF0sXG5cbiAgcHJvcGVydGllczogW1xuICAgIHtcbiAgICAgIGNsYXNzOiAnQ2xhc3MnLFxuICAgICAgbmFtZTogJ29mJyxcbiAgICAgIGZhY3Rvcnk6IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoIHRoaXMuYXJyYXkubGVuZ3RoID09PSAwICkgcmV0dXJuIHRoaXMubG9va3VwKCdmb2FtLmNvcmUuRk9iamVjdCcpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICB9LFxuICAgIHtcbiAgICAgIG5hbWU6ICdhcnJheScsXG4gICAgICBmYWN0b3J5OiBmdW5jdGlvbigpIHsgcmV0dXJuIFtdOyB9XG4gICAgfVxuICBdLFxuXG4gIG1ldGhvZHM6IFtcbiAgICBmdW5jdGlvbiBwdXRfKHgsIG9iaikge1xuICAgICAgZm9yICggdmFyIGkgPSAwIDsgaSA8IHRoaXMuYXJyYXkubGVuZ3RoIDsgaSsrICkge1xuICAgICAgICBpZiAoIG9iai5JRC5jb21wYXJlKG9iaiwgdGhpcy5hcnJheVtpXSkgPT09IDAgKSB7XG4gICAgICAgICAgdGhpcy5hcnJheVtpXSA9IG9iajtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoIGkgPT0gdGhpcy5hcnJheS5sZW5ndGggKSB0aGlzLmFycmF5LnB1c2gob2JqKTtcbiAgICAgIHRoaXMub24ucHV0LnB1YihvYmopO1xuXG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKG9iaik7XG4gICAgfSxcblxuICAgIGZ1bmN0aW9uIHJlbW92ZV8oeCwgb2JqKSB7XG4gICAgICBmb3IgKCB2YXIgaSA9IDAgOyBpIDwgdGhpcy5hcnJheS5sZW5ndGggOyBpKysgKSB7XG4gICAgICAgIGlmICggZm9hbS51dGlsLmVxdWFscyhvYmouaWQsIHRoaXMuYXJyYXlbaV0uaWQpICkge1xuICAgICAgICAgIHZhciBvMiA9IHRoaXMuYXJyYXkuc3BsaWNlKGksIDEpWzBdO1xuICAgICAgICAgIHRoaXMub24ucmVtb3ZlLnB1YihvMik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgIH0sXG5cbiAgICBmdW5jdGlvbiBzZWxlY3RfKHgsIHNpbmssIHNraXAsIGxpbWl0LCBvcmRlciwgcHJlZGljYXRlKSB7XG4gICAgICB2YXIgcmVzdWx0U2luayA9IHNpbmsgfHwgdGhpcy5BcnJheVNpbmsuY3JlYXRlKCk7XG5cbiAgICAgIHNpbmsgPSB0aGlzLmRlY29yYXRlU2lua18ocmVzdWx0U2luaywgc2tpcCwgbGltaXQsIG9yZGVyLCBwcmVkaWNhdGUpO1xuXG4gICAgICB2YXIgZGV0YWNoZWQgPSBmYWxzZTtcbiAgICAgIHZhciBzdWIgPSBmb2FtLmNvcmUuRk9iamVjdC5jcmVhdGUoKTtcbiAgICAgIHN1Yi5vbkRldGFjaChmdW5jdGlvbigpIHsgZGV0YWNoZWQgPSB0cnVlOyB9KTtcblxuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGZvciAoIHZhciBpID0gMCA7IGkgPCBzZWxmLmFycmF5Lmxlbmd0aCA7IGkrKyApIHtcbiAgICAgICAgICBpZiAoIGRldGFjaGVkICkgYnJlYWs7XG5cbiAgICAgICAgICBzaW5rLnB1dChzZWxmLmFycmF5W2ldLCBzdWIpO1xuICAgICAgICB9XG5cbiAgICAgICAgc2luay5lb2YoKTtcblxuICAgICAgICByZXNvbHZlKHJlc3VsdFNpbmspO1xuICAgICAgfSk7XG4gICAgfSxcblxuICAgIGZ1bmN0aW9uIHJlbW92ZUFsbF8oeCwgc2tpcCwgbGltaXQsIG9yZGVyLCBwcmVkaWNhdGUpIHtcbiAgICAgIHByZWRpY2F0ZSA9IHByZWRpY2F0ZSB8fCB0aGlzLlRydWUuY3JlYXRlKCk7XG4gICAgICBza2lwID0gc2tpcCB8fCAwO1xuICAgICAgbGltaXQgPSBmb2FtLk51bWJlci5pc0luc3RhbmNlKGxpbWl0KSA/IGxpbWl0IDogTnVtYmVyLk1BWF9WQUxVRTtcblxuICAgICAgZm9yICggdmFyIGkgPSAwOyBpIDwgdGhpcy5hcnJheS5sZW5ndGggJiYgbGltaXQgPiAwOyBpKysgKSB7XG4gICAgICAgIGlmICggcHJlZGljYXRlLmYodGhpcy5hcnJheVtpXSkgKSB7XG4gICAgICAgICAgaWYgKCBza2lwID4gMCApIHtcbiAgICAgICAgICAgIHNraXAtLTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgb2JqID0gdGhpcy5hcnJheS5zcGxpY2UoaSwgMSlbMF07XG4gICAgICAgICAgaS0tO1xuICAgICAgICAgIGxpbWl0LS07XG4gICAgICAgICAgdGhpcy5vbi5yZW1vdmUucHViKG9iaik7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgIH0sXG5cbiAgICBmdW5jdGlvbiBmaW5kXyh4LCBrZXkpIHtcbiAgICAgIHZhciBpZCA9IHRoaXMub2YuaXNJbnN0YW5jZShrZXkpID8ga2V5LmlkIDoga2V5O1xuICAgICAgZm9yICggdmFyIGkgPSAwIDsgaSA8IHRoaXMuYXJyYXkubGVuZ3RoIDsgaSsrICkge1xuICAgICAgICBpZiAoIGZvYW0udXRpbC5lcXVhbHMoaWQsIHRoaXMuYXJyYXlbaV0uaWQpICkge1xuICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodGhpcy5hcnJheVtpXSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShudWxsKTtcbiAgICB9XG4gIF1cbn0pO1xuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTYgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuZm9hbS5DTEFTUyh7XG4gIHBhY2thZ2U6ICdmb2FtLmRhbycsXG4gIG5hbWU6ICdUaW1lc3RhbXBEQU8nLFxuICBleHRlbmRzOiAnZm9hbS5kYW8uUHJveHlEQU8nLFxuXG4gIGRvY3VtZW50YXRpb246ICdEQU8gZGVjb3JhdG9yIHRoYXQgc2V0cyB0aGUgY3VycmVudCB0aW1lIG9uIGVhY2ggcHV0KCkgb2JqZWN0LCBwcm92aWRlZCBub3QgYWxyZWFkeSBzZXQuIEJ5IGRlZmF1bHQsIHRoZSAuaWQgcHJvZXBydHkgaXMgc2V0LicsXG5cbiAgcHJvcGVydGllczogW1xuICAgIHtcbiAgICAgIC8qKlxuICAgICAgICBUaGUgcHJvcGVydHkgb2YgaW5jb21pbmcgb2JqZWN0cyB0byBzZXQuXG4gICAgICAqL1xuICAgICAgY2xhc3M6ICdTdHJpbmcnLFxuICAgICAgbmFtZTogJ3Byb3BlcnR5JyxcbiAgICAgIHZhbHVlOiAnaWQnXG4gICAgfVxuICBdLFxuXG4gIG1ldGhvZHM6IFtcbiAgICAvKiogRm9yIGVhY2ggcHV0KCkgb2JqZWN0LCBzZXQgdGhlIHRpbWVzdGFtcCBpZiAucHJvcGVydHkgaXMgbm90XG4gICAgICBzZXQgZm9yIHRoYXQgb2JqZWN0LiAqL1xuICAgIGZ1bmN0aW9uIHB1dF8oeCwgb2JqKSB7XG4gICAgICBpZiAoICEgb2JqLmhhc093blByb3BlcnR5KHRoaXMucHJvcGVydHkpICkgb2JqW3RoaXMucHJvcGVydHldID0gdGhpcy5uZXh0VGltZXN0YW1wKCk7XG4gICAgICByZXR1cm4gdGhpcy5kZWxlZ2F0ZS5wdXRfKHgsIG9iaik7XG4gICAgfSxcblxuICAgIC8qKiBHZW5lcmF0ZXMgYSB0aW1lc3RhbXAuIE92ZXJyaWRlIHRvIGNoYW5nZSB0aGUgd2F5IHRpbWVzdGFtcHMgYXJlXG4gICAgICBjcmVhdGVkLiAqL1xuICAgIGZ1bmN0aW9uIG5leHRUaW1lc3RhbXAoKSB7XG4gICAgICByZXR1cm4gRGF0ZS5ub3coKTtcbiAgICB9XG4gIF1cbn0pO1xuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgVGhlIEZPQU0gQXV0aG9ycy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuZm9hbS5DTEFTUyh7XG4gIHBhY2thZ2U6ICdmb2FtLmRhbycsXG4gIG5hbWU6ICdBZGFwdGVyREFPJyxcbiAgZXh0ZW5kczogJ2ZvYW0uZGFvLlByb3h5REFPJyxcblxuICBkb2N1bWVudGF0aW9uOiBgREFPIGZvciBhZGFwdGluZyBiZXR3ZWVuIFwib2ZcIiBpbnB1dCB0eXBlIGFuZCBcInRvXCIgZGVsZWdhdGVcbiAgICAgIHR5cGUuIEkuZS4sIGFjY2VwdCBwdXQoPGluc3RhbmNlLW9mLVwib2ZcIj4pLCBhbmRcbiAgICAgIHRoaXMuZGVsZWdhdGUub2YgPT09IHRoaXMudG8uYCxcblxuICByZXF1aXJlczogWyAnZm9hbS5kYW8uQXJyYXlTaW5rJyBdLFxuXG4gIGNsYXNzZXM6IFtcbiAgICB7XG4gICAgICBuYW1lOiAnQWRhcHRlclNpbmsnLFxuICAgICAgZXh0ZW5kczogJ2ZvYW0uZGFvLlByb3h5U2luaycsXG5cbiAgICAgIHByb3BlcnRpZXM6IFtcbiAgICAgICAge1xuICAgICAgICAgIGNsYXNzOiAnRnVuY3Rpb24nLFxuICAgICAgICAgIG5hbWU6ICdhZGFwdCcsXG4gICAgICAgICAgZG9jdW1lbnRhdGlvbjogYFwiYWRhcHQobylcIiBhZGFwdHMgaW5wdXQgdG8gdHlwZSBleHBlY3RlZCBieVxuICAgICAgICAgICAgICBcImRlbGVnYXRlXCIgc2luay5gLFxuICAgICAgICAgIHJlcXVpcmVkOiB0cnVlXG4gICAgICAgIH1cbiAgICAgIF0sXG5cbiAgICAgIG1ldGhvZHM6IFtcbiAgICAgICAgZnVuY3Rpb24gcHV0KG8sIHN1Yikge1xuICAgICAgICAgIHRoaXMuZGVsZWdhdGUucHV0KHRoaXMuYWRhcHQobyksIHN1Yik7XG4gICAgICAgIH0sXG4gICAgICAgIGZ1bmN0aW9uIHJlbW92ZShvLCBzdWIpIHtcbiAgICAgICAgICB0aGlzLmRlbGVnYXRlLnJlbW92ZSh0aGlzLmFkYXB0KG8pLCBzdWIpO1xuICAgICAgICB9XG4gICAgICBdXG4gICAgfVxuICBdLFxuXG4gIHByb3BlcnRpZXM6IFtcbiAgICB7XG4gICAgICBuYW1lOiAnZGVsZWdhdGUnLFxuICAgICAgcG9zdFNldDogZnVuY3Rpb24ob2xkLCBudSkge1xuICAgICAgICBpZiAoICEgbnUgKSByZXR1cm47XG4gICAgICAgIGZvYW0uYXNzZXJ0KFxuICAgICAgICAgICAgbnUub2YgPT09IHRoaXMudG8sXG4gICAgICAgICAgICAnRXhwZWN0IEFkYXB0ZXJEQU8uZGVsZWdhdGUub2YgPT09IEFkYXB0ZXJEQU8udG8nKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHtcbiAgICAgIGNsYXNzOiAnQ2xhc3MnLFxuICAgICAgbmFtZTogJ3RvJyxcbiAgICAgIGRvY3VtZW50YXRpb246ICdcIm9mXCIgb2YgZGVsZWdhdGUuJ1xuICAgIH0sXG4gICAge1xuICAgICAgbmFtZTogJ0Z1bmN0aW9uJyxcbiAgICAgIG5hbWU6ICdhZGFwdFRvRGVsZWdhdGUnLFxuICAgICAgZG9jdW1lbnRhdGlvbjogYEFkYXB0IHRoaXMncyBcIm9mXCIgdHlwZSB0byBcImRlbGVnYXRlXCIncyBcIm9mXCIgdHlwZS5gLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uKGN0eCwgb2JqKSB7XG4gICAgICAgIGlmICggISBvYmogKSByZXR1cm4gb2JqO1xuICAgICAgICBpZiAoICEgdGhpcy5vZi5pc0luc3RhbmNlKG9iaikgKSByZXR1cm4gb2JqO1xuICAgICAgICByZXR1cm4gdGhpcy50by5jcmVhdGUob2JqLCBjdHggfHwgdGhpcy5fX3N1YkNvbnRleHRfXyk7XG4gICAgICB9XG4gICAgfSxcbiAgICB7XG4gICAgICBuYW1lOiAnRnVuY3Rpb24nLFxuICAgICAgbmFtZTogJ2FkYXB0RnJvbURlbGVnYXRlJyxcbiAgICAgIGRvY3VtZW50YXRpb246IGBBZGFwdCBcImRlbGVnYXRlXCIncyBcIm9mXCIgdHlwZSB0aGlzJ3MgXCJvZlwiIHR5cGUuYCxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbihjdHgsIG9iaikge1xuICAgICAgICBpZiAoICEgb2JqICkgcmV0dXJuIG9iajtcbiAgICAgICAgaWYgKCAhIHRoaXMudG8uaXNJbnN0YW5jZShvYmopICkgcmV0dXJuIG9iajtcbiAgICAgICAgcmV0dXJuIHRoaXMub2YuY3JlYXRlKG9iaiwgY3R4IHx8IHRoaXMuX19zdWJDb250ZXh0X18pO1xuICAgICAgfVxuICAgIH0sXG4gICAge1xuICAgICAgbmFtZTogJ0Z1bmN0aW9uJyxcbiAgICAgIG5hbWU6ICdhZGFwdE9yZGVyJyxcbiAgICAgIGRvY3VtZW50YXRpb246ICdBZGFwdCBzZWxlY3QoKSBvcmRlciB0byBvcmRlciB1bmRlcnN0b29kIGJ5IFwiZGVsZWdhdGVcIi4nLFxuICAgICAgLy8gVE9ETyhtYXJrZGl0dG1lcik6IFNtYXJ0ZXIgZGVmYXVsdD9cbiAgICAgIHZhbHVlOiBmdW5jdGlvbihvcmRlcikgeyByZXR1cm4gb3JkZXI7IH1cbiAgICB9LFxuICAgIHtcbiAgICAgIG5hbWU6ICdGdW5jdGlvbicsXG4gICAgICBuYW1lOiAnYWRhcHRQcmVkaWNhdGUnLFxuICAgICAgZG9jdW1lbnRhdGlvbjogYEFkYXB0IHNlbGVjdCgpIHByZWRpY2F0ZSB0byBwcmVkaWNhdGUgdW5kZXJzdG9vZCBieVxuICAgICAgICAgIFwiZGVsZWdhdGVcIi5gLFxuICAgICAgLy8gVE9ETyhtYXJrZGl0dG1lcik6IFNtYXJ0ZXIgZGVmYXVsdD9cbiAgICAgIHZhbHVlOiBmdW5jdGlvbihwcmVkaWNhdGUpIHsgcmV0dXJuIHByZWRpY2F0ZTsgfVxuICAgIH1cbiAgXSxcblxuICBtZXRob2RzOiBbXG4gICAgZnVuY3Rpb24gcHV0XyhjdHgsIG9iaikge1xuICAgICAgcmV0dXJuIHRoaXMuZGVsZWdhdGUucHV0XyhjdHgsIHRoaXMuYWRhcHRUb0RlbGVnYXRlKGN0eCwgb2JqKSkuXG4gICAgICAgIHRoZW4odGhpcy5hZGFwdEZyb21EZWxlZ2F0ZS5iaW5kKHRoaXMsIGN0eCkpO1xuICAgIH0sXG5cbiAgICBmdW5jdGlvbiByZW1vdmVfKGN0eCwgb2JqKSB7XG4gICAgICByZXR1cm4gdGhpcy5kZWxlZ2F0ZS5yZW1vdmVfKGN0eCwgdGhpcy5hZGFwdFRvRGVsZWdhdGUoY3R4LCBvYmopKS5cbiAgICAgICAgdGhlbih0aGlzLmFkYXB0RnJvbURlbGVnYXRlLmJpbmQodGhpcywgY3R4KSk7XG4gICAgfSxcblxuICAgIGZ1bmN0aW9uIGZpbmRfKGN0eCwgb2JqT3JJZCkge1xuICAgICAgcmV0dXJuIHRoaXMuZGVsZWdhdGUuZmluZF8oY3R4LCB0aGlzLmFkYXB0VG9EZWxlZ2F0ZShjdHgsIG9iak9ySWQpKS5cbiAgICAgICAgdGhlbih0aGlzLmFkYXB0RnJvbURlbGVnYXRlLmJpbmQodGhpcywgY3R4KSk7XG4gICAgfSxcblxuICAgIGZ1bmN0aW9uIHNlbGVjdF8oY3R4LCBzaW5rLCBza2lwLCBsaW1pdCwgb3JkZXIsIHByZWRpY2F0ZSkge1xuICAgICAgc2luayA9IHNpbmsgfHwgdGhpcy5BcnJheVNpbmsuY3JlYXRlKCk7XG4gICAgICB2YXIgYWRhcHRlclNpbmsgPSB0aGlzLkFkYXB0ZXJTaW5rLmNyZWF0ZSh7XG4gICAgICAgIGRlbGVnYXRlOiBzaW5rLFxuICAgICAgICBhZGFwdDogdGhpcy5hZGFwdEZyb21EZWxlZ2F0ZS5iaW5kKHRoaXMsIGN0eClcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHRoaXMuZGVsZWdhdGUuc2VsZWN0XyhcbiAgICAgICAgICAgICAgY3R4LCBhZGFwdGVyU2luaywgc2tpcCwgbGltaXQsXG4gICAgICAgICAgICAgIHRoaXMuYWRhcHRPcmRlcihvcmRlciksIHRoaXMuYWRhcHRQcmVkaWNhdGUocHJlZGljYXRlKSkuXG4gICAgICAgICAgdGhlbihmdW5jdGlvbigpIHsgcmV0dXJuIHNpbms7IH0pO1xuICAgIH0sXG5cbiAgICBmdW5jdGlvbiByZW1vdmVBbGxfKGN0eCwgc2tpcCwgbGltaXQsIG9yZGVyLCBwcmVkaWNhdGUpIHtcbiAgICAgIHJldHVybiB0aGlzLmRlbGVnYXRlLnJlbW92ZUFsbF8oXG4gICAgICAgICAgY3R4LCBza2lwLCBsaW1pdCxcbiAgICAgICAgICB0aGlzLmFkYXB0T3JkZXIob3JkZXIpLCB0aGlzLmFkYXB0UHJlZGljYXRlKHByZWRpY2F0ZSkpO1xuICAgIH1cbiAgXVxufSk7XG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5mb2FtLkNMQVNTKHtcbiAgcGFja2FnZTogJ2ZvYW0uZGFvJyxcbiAgbmFtZTogJ0dVSUREQU8nLFxuICBleHRlbmRzOiAnZm9hbS5kYW8uUHJveHlEQU8nLFxuXG4gIGRvY3VtZW50YXRpb246IGZ1bmN0aW9uKCkgey8qXG4gICAgREFPIERlY29yYXRvciB0aGF0IHNldHMgYSBwcm9wZXJ0eSB0byBhIG5ldyByYW5kb20gR1VJRCAoZ2xvYmFsbHkgdW5pcXVlIGlkZW50aWZpZXIpIG9uIHB1dCgpLCB1bmxlc3MgdmFsdWUgYWxyZWFkeSBzZXQuXG4gICAgQnkgZGVmYXVsdCwgdGhlIC5pZCBwcm9wZXJ0eSBpcyB1c2VkLlxuICAgIDxwPlxuICAgIFVzZSBhIGZvYW0uZGFvLkVhc3lEQU8gd2l0aCBndWlkOnRydWUgdG8gYXV0b21hdGljYWxseSBzZXQgR1VJRHMuIFNldFxuICAgIEVhc3lEQU8uc2VxUHJvcGVydHkgdG8gdGhlIGRlc2lyZWQgcHJvcGVydHkgbmFtZSBvciB1c2UgdGhlIGRlZmF1bHRcbiAgICBvZiAnaWQnLlxuICAqL30sXG5cbiAgcHJvcGVydGllczogW1xuICAgIHtcbiAgICAgIC8qKiBUaGUgcHJvcGVydHkgdG8gc2V0IHdpdGggYSByYW5kb20gR1VJRCB2YWx1ZSwgaWYgbm90IGFscmVhZHkgc2V0XG4gICAgICAgIG9uIHB1dCgpIG9iamVjdHMuICovXG4gICAgICBjbGFzczogJ1N0cmluZycsXG4gICAgICBuYW1lOiAncHJvcGVydHknLFxuICAgICAgdmFsdWU6ICdpZCdcbiAgICB9LFxuICAgIHtcbiAgICAgIGphdmFUeXBlOiAnZm9hbS5jb3JlLlByb3BlcnR5SW5mbycsXG4gICAgICBqYXZhSW5mb1R5cGU6ICdmb2FtLmNvcmUuQWJzdHJhY3RPYmplY3RQcm9wZXJ0eUluZm8nLFxuICAgICAgbmFtZTogJ2F4aW9tJyxcbiAgICAgIGphdmFGYWN0b3J5OiBgXG5yZXR1cm4gKGZvYW0uY29yZS5Qcm9wZXJ0eUluZm8pKGdldE9mKCkuZ2V0QXhpb21CeU5hbWUoZ2V0UHJvcGVydHkoKSkpO1xuICAgICAgYCxcbiAgICB9XG4gIF0sXG5cbiAgbWV0aG9kczogW1xuICAgIC8qKiBFbnN1cmVzIGFsbCBvYmplY3RzIHB1dCgpIGluIGhhdmUgYSB1bmlxdWUgaWQgc2V0LlxuICAgICAgQHBhcmFtIG9iaiB0aGUgb2JqZWN0IHRvIHByb2Nlc3MuICovXG4gICAge1xuICAgICAgbmFtZTogJ3B1dF8nLFxuICAgICAgY29kZTogZnVuY3Rpb24gcHV0Xyh4LCBvYmopIHtcbiAgICAgICAgaWYgKCAhIG9iai5oYXNPd25Qcm9wZXJ0eSh0aGlzLnByb3BlcnR5KSApIHtcbiAgICAgICAgICBvYmpbdGhpcy5wcm9wZXJ0eV0gPSBmb2FtLnV1aWQucmFuZG9tR1VJRCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuZGVsZWdhdGUucHV0Xyh4LCBvYmopO1xuICAgICAgfSxcbiAgICAgIGphdmFDb2RlOiBgXG5PYmplY3QgdmFsID0gb2JqLmdldFByb3BlcnR5KGdldFByb3BlcnR5KCkpO1xuXG5pZiAoIFwiXCIuZXF1YWxzKHZhbCkgKSB7XG4gIGdldEF4aW9tKCkuc2V0KG9iaiwgamF2YS51dGlsLlVVSUQucmFuZG9tVVVJRCgpLnRvU3RyaW5nKCkpO1xufVxuXG5yZXR1cm4gZ2V0RGVsZWdhdGUoKS5wdXRfKHgsIG9iaik7XG4gICAgICBgLFxuICAgIH0sXG4gIF0sXG5cbiAgYXhpb21zOiBbXG4gICAge1xuICAgICAgYnVpbGRKYXZhQ2xhc3M6IGZ1bmN0aW9uKGNscykge1xuICAgICAgICBjbHMuZXh0cmFzLnB1c2goYFxucHVibGljIEdVSUREQU8oREFPIGRlbGVnYXRlKSB7XG4gIFN5c3RlbS5lcnIucHJpbnRsbihcIkRpcmVjdCBjb25zdHJ1Y3RvciB1c2UgaXMgZGVwcmVjYXRlZC4gVXNlIEJ1aWxkZXIgaW5zdGVhZC5cIik7XG4gIHNldERlbGVnYXRlKGRlbGVnYXRlKTtcbn1cbiAgICAgICAgYCk7XG4gICAgICB9LFxuICAgIH0sXG4gIF0sXG59KTtcbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmZvYW0uQ0xBU1Moe1xuICBwYWNrYWdlOiAnZm9hbS5kYW8nLFxuICBuYW1lOiAnUmVhZE9ubHlEQU8nLFxuICBleHRlbmRzOiAnZm9hbS5kYW8uUHJveHlEQU8nLFxuICBkb2N1bWVudGF0aW9uOiAnREFPIGRlY29yYXRvciB0aGF0IHRocm93cyBlcnJvcnMgb24gcHV0IGFuZCByZW1vdmUuJyxcbiAgbWV0aG9kczogW1xuICAgIHtcbiAgICAgIG5hbWU6ICdwdXRfJyxcbiAgICAgIGphdmFDb2RlOiBgdGhyb3cgbmV3IFVuc3VwcG9ydGVkT3BlcmF0aW9uRXhjZXB0aW9uKFwiQ2Fubm90IHB1dCBpbnRvIFJlYWRPbmx5REFPXCIpO2AsXG4gICAgICBjb2RlOiBmdW5jdGlvbiBwdXRfKHgsIG9iaikge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KCdDYW5ub3QgcHV0IGludG8gUmVhZE9ubHlEQU8nKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHtcbiAgICAgIG5hbWU6ICdyZW1vdmVfJyxcbiAgICAgIGphdmFDb2RlOiBgdGhyb3cgbmV3IFVuc3VwcG9ydGVkT3BlcmF0aW9uRXhjZXB0aW9uKFwiQ2Fubm90IHJlbW92ZSBmcm9tIFJlYWRPbmx5REFPXCIpO2AsXG4gICAgICBjb2RlOiBmdW5jdGlvbiByZW1vdmVfKHgsIG9iaikge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoJ0Nhbm5vdCByZW1vdmUgZnJvbSBSZWFkT25seURBTycpO1xuICAgICAgfVxuICAgIH0sXG4gICAge1xuICAgICAgbmFtZTogJ3JlbW92ZUFsbF8nLFxuICAgICAgamF2YUNvZGU6IGB0aHJvdyBuZXcgVW5zdXBwb3J0ZWRPcGVyYXRpb25FeGNlcHRpb24oXCJDYW5ub3QgcmVtb3ZlQWxsIGZyb20gUmVhZE9ubHlEQU9cIik7YCxcbiAgICAgIGNvZGU6IGZ1bmN0aW9uIHJlbW92ZUFsbCgpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KCdDYW5ub3QgcmVtb3ZlQWxsIGZyb20gUmVhZE9ubHlEQU8nKTtcbiAgICAgIH1cbiAgICB9XG4gIF1cbn0pO1xuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgVGhlIEZPQU0gQXV0aG9ycy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuZm9hbS5DTEFTUyh7XG4gIHBhY2thZ2U6ICdmb2FtLmRhbycsXG4gIG5hbWU6ICdTdG9yZUFuZEZvcndhcmREQU8nLFxuICBleHRlbmRzOiAnZm9hbS5kYW8uUHJveHlEQU8nLFxuXG4gIGRvY3VtZW50YXRpb246IGBTdG9yZS1hbmQtZm9yd2FyZCAoaS5lLiwgc3RvcmUtYW5kLXJldHJ5KSBmYWlsZWQgREFPXG4gICAgb3BlcmF0aW9ucy4gVXNlZnVsIGZvciBEQU9zIHRoYXQgbWF5IGZsYWtlLCBidXQgZXZlbnR1YWxseSBzdWNjZWVkLmAsXG5cblxuICByZXF1aXJlczogWyAnZm9hbS5kYW8uSW50ZXJuYWxFeGNlcHRpb24nIF0sXG5cbiAgY2xhc3NlczogW1xuICAgIHtcbiAgICAgIG5hbWU6ICdEQU9PcGVyYXRpb24nLFxuXG4gICAgICBwcm9wZXJ0aWVzOiBbXG4gICAgICAgIHtcbiAgICAgICAgICBjbGFzczogJ1N0cmluZycsXG4gICAgICAgICAgZG9jdW1lbnRhdGlvbjogJ0RBTyBtZXRob2QgbmFtZSBhc3NvY2lhdGVkIHdpdGggb3BlcmF0aW9uLicsXG4gICAgICAgICAgbmFtZTogJ21ldGhvZE5hbWUnLFxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgZG9jdW1lbnRhdGlvbjogJ0FyZ3VtZW50cyBvYmplY3QgYXNzb2NpYXRlZCB3aXRoIG9wZXJhdGlvbi4nLFxuICAgICAgICAgIG5hbWU6ICdhcmdzJyxcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIG5hbWU6ICdwcm9taXNlXycsXG4gICAgICAgICAgZmFjdG9yeTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgICAgICB2YXIgcmVzb2x2ZTtcbiAgICAgICAgICAgIHZhciByZWplY3Q7XG4gICAgICAgICAgICB2YXIgcHJvbWlzZSA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlcywgcmVqKSB7XG4gICAgICAgICAgICAgIHJlc29sdmUgPSByZXM7XG4gICAgICAgICAgICAgIHJlamVjdCA9IHJlajtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcHJvbWlzZS5yZXNvbHZlRnVuY3Rpb25fID0gcmVzb2x2ZTtcbiAgICAgICAgICAgIHByb21pc2UucmVqZWN0RnVuY3Rpb25fID0gcmVqZWN0O1xuICAgICAgICAgICAgcmV0dXJuIHByb21pc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgY2xhc3M6ICdGdW5jdGlvbicsXG4gICAgICAgICAgbmFtZTogJ3Jlc29sdmVfJyxcbiAgICAgICAgICBmYWN0b3J5OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnByb21pc2VfLnJlc29sdmVGdW5jdGlvbl87XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgY2xhc3M6ICdGdW5jdGlvbicsXG4gICAgICAgICAgbmFtZTogJ3JlamVjdF8nLFxuICAgICAgICAgIGZhY3Rvcnk6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucHJvbWlzZV8ucmVqZWN0RnVuY3Rpb25fO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgXSxcblxuICAgICAgbWV0aG9kczogW1xuICAgICAgICBmdW5jdGlvbiBnZXRQcm9taXNlKCkgeyByZXR1cm4gdGhpcy5wcm9taXNlXzsgfVxuICAgICAgXSxcblxuICAgICAgbGlzdGVuZXJzOiBbXG4gICAgICAgIGZ1bmN0aW9uIHJlc29sdmUoKSB7IHJldHVybiB0aGlzLnJlc29sdmVfLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH0sXG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdCgpIHsgcmV0dXJuIHRoaXMucmVqZWN0Xy5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9XG4gICAgICBdXG4gICAgfVxuICBdLFxuXG4gIHByb3BlcnRpZXM6IFtcbiAgICB7XG4gICAgICBuYW1lOiAnZGVsZWdhdGUnLFxuICAgICAgcG9zdFNldDogZnVuY3Rpb24ob2xkLCBudSkge1xuICAgICAgICBpZiAoIHRoaXMuaXNGb3J3YXJkaW5nXyApXG4gICAgICAgICAgdGhpcy53YXJuKCdTdG9yZUFuZEZvcndhcmREQU86IERlbGVnYXRlIHdoaWxlIGZsdXNoaW5nIHF1ZXVlIScpO1xuICAgICAgICB0aGlzLmZvcndhcmRfKCk7XG4gICAgICB9XG4gICAgfSxcbiAgICB7XG4gICAgICBjbGFzczogJ0Z1bmN0aW9uJyxcbiAgICAgIGRvY3VtZW50YXRpb246IGBEZXRlcm1pbmUgd2hldGhlciBvciBub3QgYW4gZXJyb3IgaXMgc3VmZmljaWVudGx5IGludGVybmFsXG4gICAgICAgIHRvIHRoZSBEQU8gdGhhdCBpdCdzIHdvcnRoIHJldHJ5aW5nIHRoZSBvcGVyYXRpb24gdGhhdCB5ZWlsZGVkIHRoZVxuICAgICAgICBlcnJvci4gRGVmYXVsdCBpcyB0byByZXRyeSBmb2FtLmRhby5JbnRlcm5hbEV4Y2VwdGlvbiBlcnJvcnMuYCxcbiAgICAgIG5hbWU6ICdzaG91bGRSZXRyeScsXG4gICAgICAvLyBUT0RPKG1hcmtkaXR0bWVyKTogVGhlc2Ugc2hvdWxkIGJlIHN1cHBvcnRlZCBieSBmdW5jdGlvbiBwcm9wZXJ0aWVzLFxuICAgICAgLy8gYnV0IHRoZXkncmUgbm90LlxuICAgICAgLypcbiAgICAgIHJldHVybnM6IHtcbiAgICAgICAgZG9jdW1lbnRhdGlvbjogJ0luZGljYXRvcjogU2hvdWxkIHRoaXMgZXJyb3IgYmUgcmV0cmllZD8nLFxuICAgICAgICB0eXBlTmFtZTogJ0Jvb2xlYW4nLFxuICAgICAgfSxcbiAgICAgIGFyZ3M6IFtcbiAgICAgICAge1xuICAgICAgICAgIGRvY3VtZW50YXRpb246ICdUaGUgZXJyb3IgdGhyb3duIGJ5IHRoZSBkZWxlZ2F0ZSBEQU8uJyxcbiAgICAgICAgICBuYW1lOiAnZXJyb3InLFxuICAgICAgICAgIHR5cGVOYW1lOiAnRXJyb3InLFxuICAgICAgICB9LFxuICAgICAgXSxcbiAgICAgICovXG4gICAgICB2YWx1ZTogZnVuY3Rpb24oZXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuSW50ZXJuYWxFeGNlcHRpb24uaXNJbnN0YW5jZShlcnJvcik7XG4gICAgICB9XG4gICAgfSxcbiAgICB7XG4gICAgICBjbGFzczogJ0ZPYmplY3RBcnJheScsXG4gICAgICBvZjogJ0ZPYmplY3QnLFxuICAgICAgLy8gb2Y6ICdEQU9PcGVyYXRpb24nLFxuICAgICAgZG9jdW1lbnRhdGlvbjogJ1F1ZXVlIGZvciBpbmNvbXBsZXRlIERBTyBvcGVyYXRpb25zLicsXG4gICAgICBuYW1lOiAncV8nLFxuICAgIH0sXG4gICAge1xuICAgICAgY2xhc3M6ICdCb29sZWFuJyxcbiAgICAgIG5hbWU6ICdpc0ZvcndhcmRpbmdfJyxcbiAgICB9LFxuICBdLFxuXG4gIG1ldGhvZHM6IFtcbiAgICBmdW5jdGlvbiBwdXRfKCkgeyByZXR1cm4gdGhpcy5zdG9yZV8oJ3B1dF8nLCBhcmd1bWVudHMpOyB9LFxuICAgIGZ1bmN0aW9uIHJlbW92ZV8oKSB7IHJldHVybiB0aGlzLnN0b3JlXygncmVtb3ZlXycsIGFyZ3VtZW50cyk7IH0sXG4gICAgZnVuY3Rpb24gZmluZF8oKSB7IHJldHVybiB0aGlzLnN0b3JlXygnZmluZF8nLCBhcmd1bWVudHMpOyB9LFxuICAgIGZ1bmN0aW9uIHNlbGVjdF8oKSB7IHJldHVybiB0aGlzLnN0b3JlXygnc2VsZWN0XycsIGFyZ3VtZW50cyk7IH0sXG4gICAgZnVuY3Rpb24gcmVtb3ZlQWxsXygpIHsgcmV0dXJuIHRoaXMuc3RvcmVfKCdyZW1vdmVBbGxfJywgYXJndW1lbnRzKTsgfSxcblxuICAgIGZ1bmN0aW9uIHN0b3JlXyhtZXRob2ROYW1lLCBhcmdzKSB7XG4gICAgICAvLyBTdG9yZSBEQU8gb3BlcmF0aW9ucyBpbiBvcmRlci5cbiAgICAgIHZhciBvcCA9IHRoaXMuREFPT3BlcmF0aW9uLmNyZWF0ZSh7XG4gICAgICAgIG1ldGhvZE5hbWU6IG1ldGhvZE5hbWUsXG4gICAgICAgIGFyZ3M6IGFyZ3MsXG4gICAgICB9KTtcbiAgICAgIHRoaXMucV8ucHVzaChvcCk7XG4gICAgICAvLyBJZiBubyBmb3J3YXJkaW5nIGluIHByb2dyZXNzIHRoZW4gZm9yd2FyZCB0aGlzIG9wIGltbWVkaWF0ZWx5LlxuICAgICAgLy8gT3RoZXJ3aXNlLCBpbi1wcm9ncmVzcyBmb3J3YXJkaW5nIHdpbGwgZ2V0IHRvIGl0IGV2ZW50dWFsbHkuXG4gICAgICBpZiAoICEgdGhpcy5pc0ZvcndhcmRpbmdfICkgdGhpcy5mb3J3YXJkXygpO1xuICAgICAgLy8gUmV0dXJuIFByb21pc2UgYXNzb2NpYXRlZCB3aXRoIGNvbXBsZXRpbmcgb3BlcmF0aW9uLlxuICAgICAgcmV0dXJuIG9wLmdldFByb21pc2UoKTtcbiAgICB9LFxuICAgIGZ1bmN0aW9uIGZvcndhcmRfKCkge1xuICAgICAgLy8gR3VhcmQgYWdhaW5zdCBmbHVzaC10by0obm8gZGVsZWdhdGUpIG9yIGF0dGVtcHQgdG8gZmx1c2ggZW1wdHkgcXVldWUuXG4gICAgICBpZiAoICggISB0aGlzLmRlbGVnYXRlICkgfHwgdGhpcy5xXy5sZW5ndGggPT09IDAgKSB7XG4gICAgICAgIHRoaXMuaXNGb3J3YXJkaW5nXyA9IGZhbHNlO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHRoaXMuaXNGb3J3YXJkaW5nXyA9IHRydWU7XG5cbiAgICAgIHZhciBvcCA9IHRoaXMucV9bMF07XG4gICAgICB0aGlzLmRlbGVnYXRlW29wLm1ldGhvZE5hbWVdLmFwcGx5KHRoaXMuZGVsZWdhdGUsIG9wLmFyZ3MpXG4gICAgICAgICAgLnRoZW4odGhpcy5vbkNvbXBsZXRlLmJpbmQodGhpcywgb3ApKVxuICAgICAgICAgIC5jYXRjaCh0aGlzLm9uRXJyb3IuYmluZCh0aGlzLCBvcCkpO1xuICAgIH1cbiAgXSxcblxuICBsaXN0ZW5lcnM6IFtcbiAgICB7XG4gICAgICBuYW1lOiAnb25RJyxcbiAgICAgIGRvY3VtZW50YXRpb246IGBBdHRlbXB0IHRvIGZvcndhcmQgZmFpbGVkIG9wZXJhdGlvbnMgbm8gbW9yZSBmcmVxdWVudGx5XG4gICAgICAgIHRoYW4gXCJtZXJnZURlbGF5XCJtcy5gLFxuICAgICAgaXNNZXJnZWQ6ICd0cnVlJyxcbiAgICAgIG1lcmdlRGVsYXk6IDIwMDAsXG4gICAgICBjb2RlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5mb3J3YXJkXygpO1xuICAgICAgfVxuICAgIH0sXG4gICAge1xuICAgICAgbmFtZTogJ29uQ29tcGxldGUnLFxuICAgICAgZG9jdW1lbnRhdGlvbjogYE9wZXJhdGlvbiwgXCJvcFwiLCBqdXN0IGNvbXBsZXRlZCBzdWNjZXNzZnVsbHksIHlpZWxkaW5nXG4gICAgICAgIFwicmVzdWx0XCIuIFNpbmNlIG9yZGVyIGlzIHByZXN2ZXJlZCwgXCJvcFwiIGlzIGF0IHRoZSBoZWFkIG9mIFwicV9cIi5cbiAgICAgICAgRGVxdWV1ZSBcIm9wXCIgYW5kIHJlc29sdmUgaXRzIHByb21pc2UuYCxcbiAgICAgIGNvZGU6IGZ1bmN0aW9uKG9wLCByZXN1bHQpIHtcbiAgICAgICAgLy8gRGVxdWV1ZSBhbmQgcmVzb2x2ZSBjb21wbGV0ZWQgb3A7IGF0dGVtcHQgdG8gZm9yd2FyZCBuZXh0IG9wLlxuICAgICAgICB0aGlzLnFfLnNoaWZ0KCk7XG4gICAgICAgIG9wLnJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgdGhpcy5mb3J3YXJkXygpO1xuICAgICAgfVxuICAgIH0sXG4gICAge1xuICAgICAgbmFtZTogJ29uRXJyb3InLFxuICAgICAgZG9jdW1lbnRhdGlvbjogYE9wZXJhdGlvbiwgXCJvcFwiLCBmYWlsZWQsIHlpZWxkaW5nIFwiZXJyb3JcIi4gSWYgaXQgc2hvdWxkIGJlXG4gICAgICAgIHJldHJpZWQsIHRpY2tsZSBtZXJnZWQgbGlzdGVuZXIgXCJvblFcIiB0byBlbnN1cmUgdGhhdCBpdCBpcyB0cmllZCBhZ2FpblxuICAgICAgICBsYXRlci4gT3RoZXJ3aXNlLCBkaXNjYXJkIGl0IGZyb20gXCJxX1wiIGFuZCByZWplY3QgaXRzIHByb21pc2UuYCxcbiAgICAgIGNvZGU6IGZ1bmN0aW9uKG9wLCBlcnJvcikge1xuICAgICAgICAvLyBUcmlnZ2VyIG1lcmdlZCBsaXN0ZW5lciB0byBpbml0aWF0ZSBhbm90aGVyIGZvcndhcmRpbmcgYXR0ZW1wdC5cbiAgICAgICAgaWYgKCB0aGlzLnNob3VsZFJldHJ5KGVycm9yKSApIHtcbiAgICAgICAgICB0aGlzLmlzRm9yd2FyZGluZ18gPSBmYWxzZTtcbiAgICAgICAgICB0aGlzLm9uUSgpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFRocm93biBlcnJvciBub3QgcmV0cnlhYmxlOlxuICAgICAgICAvLyBEZXF1ZXVlIGFuZCByZWplY3Qgb3A7IGF0dGVtcHQgdG8gZm9yd2FyZCBuZXh0IG9wLlxuICAgICAgICB0aGlzLnFfLnNoaWZ0KCk7XG4gICAgICAgIG9wLnJlamVjdChlcnJvcik7XG4gICAgICAgIHRoaXMuZm9yd2FyZF8oKTtcbiAgICAgIH1cbiAgICB9XG4gIF1cbn0pO1xuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTYgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE4IFRoZSBGT0FNIEF1dGhvcnMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqL1xuXG5mb2FtLkNMQVNTKHtcbiAgcGFja2FnZTogJ2ZvYW0uZGFvJyxcbiAgbmFtZTogJ1JlbGF0aW9uc2hpcCcsXG4gIGltcGxlbWVudHM6IFsgeyBwYXRoOiAnZm9hbS5tbGFuZy5FeHByZXNzaW9ucycsIGphdmE6IGZhbHNlIH0gXSxcblxuICBkb2N1bWVudGF0aW9uOiAnQW4gQXhpb20gZm9yIGRlZmluaW5nIFJlbGF0aW9uc2hpcHMgYmV0d2VlbiBtb2RlbHMuJyxcblxuICByZXF1aXJlczogW1xuICAgICdmb2FtLmRhby5SZWxhdGlvbnNoaXBEQU8nLFxuICAgICdmb2FtLmRhby5NYW55VG9NYW55UmVsYXRpb25zaGlwREFPJyxcbiAgICAnZm9hbS5kYW8uUmVhZE9ubHlEQU8nLFxuICAgICdmb2FtLmRhby5PbmVUb01hbnlSZWxhdGlvbnNoaXBQcm9wZXJ0eScsXG4gICAgJ2ZvYW0uZGFvLk1hbnlUb01hbnlSZWxhdGlvbnNoaXBQcm9wZXJ0eSdcbiAgXSxcblxuICBwcm9wZXJ0aWVzOiBbXG4gICAge1xuICAgICAgbmFtZTogJ2lkJyxcbiAgICAgIGhpZGRlbjogdHJ1ZSxcbiAgICAgIHRyYW5zaWVudDogdHJ1ZSxcbiAgICAgIGdldHRlcjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBhY2thZ2UgPyB0aGlzLnBhY2thZ2UgKyAnLicgKyB0aGlzLm5hbWUgOiB0aGlzLm5hbWU7XG4gICAgICB9XG4gICAgfSxcbiAgICB7XG4gICAgICBuYW1lOiAncGFja2FnZScsXG4gICAgICAvLyBEZWZhdWx0IHRvIHNvdXJjZU1vZGVsJ3MgcGFja2FnZSBpZiBub3Qgc3BlY2lmaWVkLlxuICAgICAgZmFjdG9yeTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxvb2t1cCh0aGlzLnNvdXJjZU1vZGVsKS5wYWNrYWdlO1xuICAgICAgfVxuICAgIH0sXG4gICAge1xuICAgICAgbmFtZTogJ25hbWUnLFxuICAgICAgY2xhc3M6ICdTdHJpbmcnLFxuICAgICAgdHJhbnNpZW50OiB0cnVlLFxuICAgICAgaGlkZGVuOiB0cnVlLFxuICAgICAgZ2V0dGVyOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubG9va3VwKHRoaXMuc291cmNlTW9kZWwpLm5hbWUgK1xuICAgICAgICAgIHRoaXMubG9va3VwKHRoaXMudGFyZ2V0TW9kZWwpLm5hbWUgKyAnUmVsYXRpb25zaGlwJztcbiAgICAgIH1cbiAgICB9LFxuICAgICdmb3J3YXJkTmFtZScsXG4gICAge1xuICAgICAgbmFtZTogJ2ludmVyc2VOYW1lJyxcbiAgICAgIGNsYXNzOiAnU3RyaW5nJ1xuICAgIH0sXG4gICAge1xuICAgICAgbmFtZTogJ2NhcmRpbmFsaXR5JyxcbiAgICAgIGFzc2VydFZhbHVlOiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICBmb2FtLmFzc2VydCh2YWx1ZSA9PT0gJzE6KicgfHwgdmFsdWUgPT09ICcqOionLFxuICAgICAgICAgICdTdXBwb3J0ZWQgY2FyZGluYWxpdGllcyBhcmUgMToqIGFuZCAqOionKTtcbiAgICAgIH0sXG4gICAgICB2YWx1ZTogJzE6KidcbiAgICB9LFxuICAgIHtcbiAgICAgIGNsYXNzOiAnU3RyaW5nJyxcbiAgICAgIG5hbWU6ICdzb3VyY2VNb2RlbCdcbiAgICB9LFxuICAgIHtcbiAgICAgIGNsYXNzOiAnU3RyaW5nJyxcbiAgICAgIG5hbWU6ICd0YXJnZXRNb2RlbCdcbiAgICB9LFxuICAgIHtcbiAgICAgIGNsYXNzOiAnU3RyaW5nJyxcbiAgICAgIG5hbWU6ICdqdW5jdGlvbk1vZGVsJyxcbiAgICAgIGV4cHJlc3Npb246IGZ1bmN0aW9uKHNvdXJjZU1vZGVsLCB0YXJnZXRNb2RlbCkge1xuICAgICAgICByZXR1cm4gKCB0aGlzLnBhY2thZ2UgPyB0aGlzLnBhY2thZ2UgKyAnLicgOiAnJyApICsgdGhpcy5sb29rdXAoc291cmNlTW9kZWwpLm5hbWUgKyB0aGlzLmxvb2t1cCh0YXJnZXRNb2RlbCkubmFtZSArICdKdW5jdGlvbic7IH1cbiAgICB9LFxuICAgIHtcbiAgICAgIGNsYXNzOiAnU3RyaW5nJyxcbiAgICAgIG5hbWU6ICdzb3VyY2VEQU9LZXknLFxuICAgICAgZXhwcmVzc2lvbjogZnVuY3Rpb24oc291cmNlTW9kZWwpIHtcbiAgICAgICAgcmV0dXJuIGZvYW0uU3RyaW5nLmRhb2l6ZSh0aGlzLmxvb2t1cChzb3VyY2VNb2RlbCkubmFtZSk7XG4gICAgICB9XG4gICAgfSxcbiAgICB7XG4gICAgICBjbGFzczogJ1N0cmluZycsXG4gICAgICBuYW1lOiAndGFyZ2V0REFPS2V5JyxcbiAgICAgIGV4cHJlc3Npb246IGZ1bmN0aW9uKHRhcmdldE1vZGVsKSB7XG4gICAgICAgIHJldHVybiBmb2FtLlN0cmluZy5kYW9pemUodGhpcy5sb29rdXAodGFyZ2V0TW9kZWwpLm5hbWUpO1xuICAgICAgfVxuICAgIH0sXG4gICAge1xuICAgICAgY2xhc3M6ICdTdHJpbmcnLFxuICAgICAgbmFtZTogJ2p1bmN0aW9uREFPS2V5JyxcbiAgICAgIGV4cHJlc3Npb246IGZ1bmN0aW9uKGp1bmN0aW9uTW9kZWwpIHtcbiAgICAgICAgcmV0dXJuIGZvYW0uU3RyaW5nLmRhb2l6ZSh0aGlzLmxvb2t1cChqdW5jdGlvbk1vZGVsKS5uYW1lKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHtcbiAgICAgIG5hbWU6ICdhZGFwdFRhcmdldCcsXG4gICAgICBmYWN0b3J5OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGludmVyc2VOYW1lID0gdGhpcy5pbnZlcnNlTmFtZTtcblxuICAgICAgICByZXR1cm4gZnVuY3Rpb24oc291cmNlLCB0YXJnZXQpIHtcbiAgICAgICAgICB0YXJnZXRbaW52ZXJzZU5hbWVdID0gc291cmNlLmlkO1xuXG4gICAgICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAge1xuICAgICAgY2xhc3M6ICdCb29sZWFuJyxcbiAgICAgIG5hbWU6ICdvbmVXYXknXG4gICAgfSxcbiAgICB7XG4gICAgICBjbGFzczogJ01hcCcsXG4gICAgICBuYW1lOiAnc291cmNlUHJvcGVydHknXG4gICAgfSxcbiAgICB7XG4gICAgICBjbGFzczogJ01hcCcsXG4gICAgICBuYW1lOiAndGFyZ2V0UHJvcGVydHknXG4gICAgfSxcbiAgICAvKiBGVVRVUkU6XG4gICAge1xuICAgICAgbmFtZTogJ2RlbGV0ZVN0cmF0ZWd5J1xuICAgICAgLy8gcHJldmVudCwgY2FzY2FkZSwgb3JwaGFuXG4gICAgfVxuICAgICovXG4gIF0sXG5cbiAgbWV0aG9kczogW1xuICAgIGZ1bmN0aW9uIGluaXQoKSB7XG4gICAgICB2YXIgc291cmNlUHJvcDtcbiAgICAgIHZhciB0YXJnZXRQcm9wO1xuICAgICAgdmFyIGNhcmRpbmFsaXR5ICAgPSB0aGlzLmNhcmRpbmFsaXR5O1xuICAgICAgdmFyIGZvcndhcmROYW1lICAgPSB0aGlzLmZvcndhcmROYW1lO1xuICAgICAgdmFyIGludmVyc2VOYW1lICAgPSB0aGlzLmludmVyc2VOYW1lO1xuICAgICAgdmFyIHJlbGF0aW9uc2hpcCAgPSB0aGlzO1xuICAgICAgdmFyIHNvdXJjZU1vZGVsICAgPSB0aGlzLnNvdXJjZU1vZGVsO1xuICAgICAgdmFyIHRhcmdldE1vZGVsICAgPSB0aGlzLnRhcmdldE1vZGVsO1xuICAgICAgdmFyIGp1bmN0aW9uTW9kZWwgPSB0aGlzLmp1bmN0aW9uTW9kZWw7XG4gICAgICB2YXIgc291cmNlICAgICAgICA9IHRoaXMubG9va3VwKHNvdXJjZU1vZGVsKTtcbiAgICAgIHZhciB0YXJnZXQgICAgICAgID0gdGhpcy5sb29rdXAodGFyZ2V0TW9kZWwpO1xuICAgICAgdmFyIGp1bmN0aW9uICAgICAgPSB0aGlzLmxvb2t1cChqdW5jdGlvbk1vZGVsLCB0cnVlKTtcbiAgICAgIHZhciBzb3VyY2VEQU9LZXkgID0gdGhpcy5zb3VyY2VEQU9LZXk7XG4gICAgICB2YXIgdGFyZ2V0REFPS2V5ICA9IHRoaXMudGFyZ2V0REFPS2V5O1xuXG4gICAgICAvLyBBZGQgUmVsYXRpb25zaGlwIHRvIGF4aW9tcyBsaXN0cyBmb3IgZWFjaCBtb2RlbCwgZm9yIHJlZmVyZW5jZVxuICAgICAgc291cmNlLmF4aW9tTWFwX1t0aGlzLmlkXSA9IHRoaXM7XG4gICAgICAvLyBDb3VsZCBiZSByZWxhdGVkIHRvIGl0c2VsZiwgc28gYXZvaWQgYWRkaW5nIHR3aWNlXG4gICAgICBpZiAoIHNvdXJjZSAhPT0gdGFyZ2V0ICkgdGFyZ2V0LmF4aW9tTWFwX1t0aGlzLmlkXSA9IHRoaXM7XG5cbiAgICAgIGlmICggY2FyZGluYWxpdHkgPT09ICcxOionICkge1xuICAgICAgICBzb3VyY2VQcm9wID0gZm9hbS5kYW8uT25lVG9NYW55UmVsYXRpb25zaGlwUHJvcGVydHkuY3JlYXRlKHtcbiAgICAgICAgICBuYW1lOiBmb3J3YXJkTmFtZSxcbiAgICAgICAgICB0YXJnZXQ6IHRhcmdldCxcbiAgICAgICAgICB0YXJnZXRQcm9wZXJ0eU5hbWU6IGludmVyc2VOYW1lLFxuICAgICAgICAgIHRhcmdldERBT0tleTogdGFyZ2V0REFPS2V5XG4gICAgICAgIH0pLmNvcHlGcm9tKHRoaXMuc291cmNlUHJvcGVydHkpO1xuXG4gICAgICAgIHRhcmdldFByb3AgPSBmb2FtLmNvcmUuUmVmZXJlbmNlLmNyZWF0ZSh7XG4gICAgICAgICAgbmFtZTogaW52ZXJzZU5hbWUsXG4gICAgICAgICAgb2Y6IHNvdXJjZU1vZGVsLFxuICAgICAgICAgIHRhcmdldERBT0tleTogc291cmNlREFPS2V5XG4gICAgICAgIH0pLmNvcHlGcm9tKHRoaXMudGFyZ2V0UHJvcGVydHkpO1xuICAgICAgfSBlbHNlIHsgLyogY2FyZGluYWxpdHkgPT09ICcqLionICovXG4gICAgICAgIGlmICggISBqdW5jdGlvbiApIHtcbiAgICAgICAgICB2YXIgbmFtZSA9IHRoaXMuanVuY3Rpb25Nb2RlbC5zdWJzdHJpbmcoXG4gICAgICAgICAgICB0aGlzLmp1bmN0aW9uTW9kZWwubGFzdEluZGV4T2YoJy4nKSArIDEpO1xuICAgICAgICAgIHZhciBpZCA9IHRoaXMucGFja2FnZSArICcuJyArIG5hbWU7XG5cbiAgICAgICAgICBmb2FtLkNMQVNTKHtcbiAgICAgICAgICAgIHBhY2thZ2U6IHRoaXMucGFja2FnZSxcbiAgICAgICAgICAgIG5hbWU6IG5hbWUsXG4gICAgICAgICAgICBpZHM6IFsgJ3NvdXJjZUlkJywgJ3RhcmdldElkJyBdLFxuICAgICAgICAgICAgcHJvcGVydGllczogW1xuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgY2xhc3M6ICdSZWZlcmVuY2UnLFxuICAgICAgICAgICAgICAgIG5hbWU6ICdzb3VyY2VJZCcsXG4gICAgICAgICAgICAgICAgc2hvcnROYW1lOiAncycsXG4gICAgICAgICAgICAgICAgb2Y6IHNvdXJjZSxcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGNsYXNzOiAnUmVmZXJlbmNlJyxcbiAgICAgICAgICAgICAgICBuYW1lOiAndGFyZ2V0SWQnLFxuICAgICAgICAgICAgICAgIHNob3J0TmFtZTogJ3QnLFxuICAgICAgICAgICAgICAgIG9mOiB0YXJnZXRcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgXVxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAganVuY3Rpb24gPSB0aGlzLmxvb2t1cCh0aGlzLmp1bmN0aW9uTW9kZWwpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGp1bmN0aW9uREFPS2V5ID0gdGhpcy5qdW5jdGlvbkRBT0tleTtcblxuICAgICAgICBzb3VyY2VQcm9wID0gZm9hbS5kYW8uTWFueVRvTWFueVJlbGF0aW9uc2hpcFByb3BlcnR5LmNyZWF0ZSh7XG4gICAgICAgICAgbmFtZTogZm9yd2FyZE5hbWUsXG4gICAgICAgICAganVuY3Rpb246IGp1bmN0aW9uLFxuICAgICAgICAgIGp1bmN0aW9uREFPS2V5OiBqdW5jdGlvbkRBT0tleSxcbiAgICAgICAgICB0YXJnZXREQU9LZXk6IHRhcmdldERBT0tleSxcbiAgICAgICAgICB0YXJnZXRQcm9wZXJ0eToganVuY3Rpb24uVEFSR0VUX0lELFxuICAgICAgICAgIHNvdXJjZVByb3BlcnR5OiBqdW5jdGlvbi5TT1VSQ0VfSURcbiAgICAgICAgfSkuY29weUZyb20odGhpcy5zb3VyY2VQcm9wZXJ0eSk7XG5cbiAgICAgICAgICAvLyBTYW1lIGFzIHNvdXJjZVByb3AgZXhjZXB0IHdlIHN3YXAgdGFyZ2V0L3NvdXJjZSBzbyB0aGF0IHRoaXMgcmVsYXRpb25zaGlwXG4gICAgICAgICAgLy8gd29ya3MgaW4gdGhlIG9wcG9zaXRlIGRpcmVjdGlvbi5cbiAgICAgICAgdGFyZ2V0UHJvcCA9IGZvYW0uZGFvLk1hbnlUb01hbnlSZWxhdGlvbnNoaXBQcm9wZXJ0eS5jcmVhdGUoe1xuICAgICAgICAgIG5hbWU6IGludmVyc2VOYW1lLFxuICAgICAgICAgIGp1bmN0aW9uOiBqdW5jdGlvbixcbiAgICAgICAgICBqdW5jdGlvbkRBT0tleToganVuY3Rpb25EQU9LZXksXG4gICAgICAgICAgdGFyZ2V0REFPS2V5OiBzb3VyY2VEQU9LZXksXG4gICAgICAgICAgdGFyZ2V0UHJvcGVydHk6IGp1bmN0aW9uLlNPVVJDRV9JRCxcbiAgICAgICAgICBzb3VyY2VQcm9wZXJ0eToganVuY3Rpb24uVEFSR0VUX0lEXG4gICAgICAgIH0pLmNvcHlGcm9tKHRoaXMudGFyZ2V0UHJvcGVydHkpO1xuICAgICAgfVxuXG4gICAgICBzb3VyY2UuaW5zdGFsbEF4aW9tKHNvdXJjZVByb3ApO1xuXG4gICAgICBpZiAoICEgdGhpcy5vbmVXYXkgJiYgISB0YXJnZXQuZ2V0QXhpb21CeU5hbWUodGFyZ2V0UHJvcC5uYW1lKSApIHtcbiAgICAgICAgdGFyZ2V0Lmluc3RhbGxBeGlvbSh0YXJnZXRQcm9wKTtcbiAgICAgIH1cblxuICAgICAgLypcbiAgICAgIGlmICggISB0aGlzLm9uZVdheSApIHtcbiAgICAgICAgc291cmNlUHJvcGVydHkucHJlU2V0ID0gZnVuY3Rpb24oXywgbmV3VmFsdWUpIHtcbiAgICAgICAgICBpZiAoIG5ld1ZhbHVlICkge1xuICAgICAgICAgICAgZm9yICggdmFyIGkgPSAwIDsgaSA8IHNvdXJjZVByb3BzLmxlbmd0aCA7IGkrKyApIHtcbiAgICAgICAgICAgICAgbmV3VmFsdWVbdGFyZ2V0UHJvcHNbaV0ubmFtZV0gPSB0aGlzW3NvdXJjZVByb3BzW2ldXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG5ld1ZhbHVlO1xuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgKi9cbiAgICB9XG4gIF1cbn0pO1xuXG5cbmZvYW0uTElCKHtcbiAgbmFtZTogJ2ZvYW0nLFxuICBtZXRob2RzOiBbXG4gICAgZnVuY3Rpb24gUkVMQVRJT05TSElQKG0sIG9wdF9jdHgpIHtcbiAgICAgIHZhciByID0gZm9hbS5kYW8uUmVsYXRpb25zaGlwLmNyZWF0ZShtLCBvcHRfY3R4KTtcblxuICAgICAgci52YWxpZGF0ZSAmJiByLnZhbGlkYXRlKCk7XG4gICAgICBmb2FtLnBhY2thZ2UucmVnaXN0ZXJDbGFzcyhyKTtcblxuICAgICAgcmV0dXJuIHI7XG4gICAgfVxuICBdXG59KTtcblxuZm9hbS5JTlRFUkZBQ0Uoe1xuICBwYWNrYWdlOiAnZm9hbS5kYW8nLFxuICBuYW1lOiAnTWFueVRvTWFueVJlbGF0aW9uc2hpcCcsXG4gIG1ldGhvZHM6IFtcbiAgICB7XG4gICAgICBuYW1lOiAnYWRkJyxcbiAgICAgIHJldHVybnM6ICdQcm9taXNlJyxcbiAgICAgIGphdmFSZXR1cm5zOiAndm9pZCcsXG4gICAgICBhcmdzOiBbXG4gICAgICAgIHsgbmFtZTogJ3RhcmdldCcsIG9mOiAnZm9hbS5jb3JlLkZPYmplY3QnIH1cbiAgICAgIF1cbiAgICB9LFxuICAgIHtcbiAgICAgIG5hbWU6ICdyZW1vdmUnLFxuICAgICAgcmV0dXJuczogJ1Byb21pc2UnLFxuICAgICAgamF2YVJldHVybnM6ICd2b2lkJyxcbiAgICAgIGFyZ3M6IFtcbiAgICAgICAgeyBuYW1lOiAndGFyZ2V0Jywgb2Y6ICdmb2FtLmNvcmUuRk9iamVjdCcgfVxuICAgICAgXVxuICAgIH0sXG4gICAgLy8gVE9ETzogVGhlc2Ugc2hvdWxkIHJlYWxseSBiZSBwcm9wZXJ0aWVzLlxuICAgIHtcbiAgICAgIG5hbWU6ICdnZXREQU8nLFxuICAgICAgamF2YVJldHVybnM6ICdmb2FtLmRhby5EQU8nXG4gICAgfSxcbiAgICB7XG4gICAgICBuYW1lOiAnZ2V0SnVuY3Rpb25EQU8nLFxuICAgICAgamF2YVJldHVybnM6ICdmb2FtLmRhby5EQU8nXG4gICAgfSxcbiAgICB7XG4gICAgICBuYW1lOiAnZ2V0VGFyZ2V0REFPJyxcbiAgICAgIGphdmFSZXR1cm5zOiAnZm9hbS5kYW8uREFPJ1xuICAgIH0sXG4gIF1cbn0pO1xuXG5mb2FtLkNMQVNTKHtcbiAgcGFja2FnZTogJ2ZvYW0uZGFvJyxcbiAgbmFtZTogJ01hbnlUb01hbnlSZWxhdGlvbnNoaXBJbXBsJyxcbiAgaW1wbGVtZW50czogWyAnZm9hbS5kYW8uTWFueVRvTWFueVJlbGF0aW9uc2hpcCcgXSxcbiAgcHJvcGVydGllczogW1xuICAgIHtcbiAgICAgIGNsYXNzOiAnQ2xhc3MnLFxuICAgICAgbmFtZTogJ2p1bmN0aW9uJyxcbiAgICAgIGhpZGRlbjogdHJ1ZVxuICAgIH0sXG4gICAge1xuICAgICAgY2xhc3M6ICdPYmplY3QnLFxuICAgICAgbmFtZTogJ3NvdXJjZUlkJyxcbiAgICAgIGhpZGRlbjogdHJ1ZVxuICAgIH0sXG4gICAge1xuICAgICAgY2xhc3M6ICdTdHJpbmcnLFxuICAgICAgbmFtZTogJ3RhcmdldERBT0tleScsXG4gICAgICBoaWRkZW46IHRydWVcbiAgICB9LFxuICAgIHtcbiAgICAgIGNsYXNzOiAnU3RyaW5nJyxcbiAgICAgIG5hbWU6ICdqdW5jdGlvbkRBT0tleScsXG4gICAgICBoaWRkZW46IHRydWVcbiAgICB9LFxuICAgIHtcbiAgICAgIGNsYXNzOiAnT2JqZWN0JyxcbiAgICAgIGphdmFUeXBlOiAnZm9hbS5jb3JlLlByb3BlcnR5SW5mbycsXG4gICAgICBuYW1lOiAndGFyZ2V0UHJvcGVydHknLFxuICAgICAgaGlkZGVuOiB0cnVlXG4gICAgfSxcbiAgICB7XG4gICAgICBjbGFzczogJ09iamVjdCcsXG4gICAgICBqYXZhVHlwZTogJ2ZvYW0uY29yZS5Qcm9wZXJ0eUluZm8nLFxuICAgICAgbmFtZTogJ3NvdXJjZVByb3BlcnR5JyxcbiAgICAgIGhpZGRlbjogdHJ1ZVxuICAgIH0sXG4gICAge1xuICAgICAgY2xhc3M6ICdmb2FtLmRhby5EQU9Qcm9wZXJ0eScsXG4gICAgICBuYW1lOiAnZGFvJyxcbiAgICAgIGxhYmVsOiAnJyxcbiAgICAgIC8vIEV4Y2x1ZGUgREFPcyAod2hpY2ggdXNlIG9iamVjdCBpZGVudGl0eSBmb3IgY29tcGFyaXNvbikgZnJvbSBjb21wYXJpc29uXG4gICAgICAvLyBvZiByZWxhdGlvbnNoaXAgaW1wbHMuXG4gICAgICBjb21wYXJlUHJvcGVydHlWYWx1ZXM6IGZ1bmN0aW9uKCkgeyByZXR1cm4gMDsgfSxcbiAgICAgIGZhY3Rvcnk6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gZm9hbS5kYW8uUmVhZE9ubHlEQU8uY3JlYXRlKHtcbiAgICAgICAgICBkZWxlZ2F0ZTogZm9hbS5kYW8uTWFueVRvTWFueVJlbGF0aW9uc2hpcERBTy5jcmVhdGUoe1xuICAgICAgICAgICAgcmVsYXRpb25zaGlwOiB0aGlzLFxuICAgICAgICAgICAgZGVsZWdhdGU6IHRoaXMuX19jb250ZXh0X19bdGhpcy50YXJnZXREQU9LZXldXG4gICAgICAgICAgfSwgdGhpcylcbiAgICAgICAgfSwgdGhpcyk7XG4gICAgICB9LFxuICAgICAgamF2YUZhY3Rvcnk6IGByZXR1cm4gbmV3IGZvYW0uZGFvLlJlYWRPbmx5REFPLkJ1aWxkZXIoZ2V0WCgpKS5cbiAgc2V0RGVsZWdhdGUobmV3IGZvYW0uZGFvLk1hbnlUb01hbnlSZWxhdGlvbnNoaXBEQU8uQnVpbGRlcihnZXRYKCkpLlxuICAgIHNldFJlbGF0aW9uc2hpcCh0aGlzKS5cbiAgICBzZXREZWxlZ2F0ZSgoZm9hbS5kYW8uREFPKWdldFgoKS5nZXQoZ2V0VGFyZ2V0REFPS2V5KCkpKS5cbiAgICBidWlsZCgpKS5cbiAgYnVpbGQoKTtgXG4gICAgfSxcbiAgICB7XG4gICAgICBjbGFzczogJ2ZvYW0uZGFvLkRBT1Byb3BlcnR5JyxcbiAgICAgIG5hbWU6ICdqdW5jdGlvbkRBTycsXG4gICAgICBoaWRkZW46IHRydWUsXG4gICAgICAvLyBFeGNsdWRlIERBT3MgKHdoaWNoIHVzZSBvYmplY3QgaWRlbnRpdHkgZm9yIGNvbXBhcmlzb24pIGZyb20gY29tcGFyaXNvblxuICAgICAgLy8gb2YgcmVsYXRpb25zaGlwIGltcGxzLlxuICAgICAgY29tcGFyZVByb3BlcnR5VmFsdWVzOiBmdW5jdGlvbigpIHsgcmV0dXJuIDA7IH0sXG4gICAgICBmYWN0b3J5OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX19jb250ZXh0X19bdGhpcy5qdW5jdGlvbkRBT0tleV07XG4gICAgICB9LFxuICAgICAgamF2YUZhY3Rvcnk6ICdyZXR1cm4gKGZvYW0uZGFvLkRBTylnZXRYKCkuZ2V0KGdldEp1bmN0aW9uREFPS2V5KCkpOydcbiAgICB9LFxuICAgIHtcbiAgICAgIGNsYXNzOiAnZm9hbS5kYW8uREFPUHJvcGVydHknLFxuICAgICAgbmFtZTogJ3RhcmdldERBTycsXG4gICAgICBoaWRkZW46IHRydWUsXG4gICAgICAvLyBFeGNsdWRlIERBT3MgKHdoaWNoIHVzZSBvYmplY3QgaWRlbnRpdHkgZm9yIGNvbXBhcmlzb24pIGZyb20gY29tcGFyaXNvblxuICAgICAgLy8gb2YgcmVsYXRpb25zaGlwIGltcGxzLlxuICAgICAgY29tcGFyZVByb3BlcnR5VmFsdWVzOiBmdW5jdGlvbigpIHsgcmV0dXJuIDA7IH0sXG4gICAgICBmYWN0b3J5OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX19jb250ZXh0X19bdGhpcy50YXJnZXREQU9LZXldO1xuICAgICAgfSxcbiAgICAgIGphdmFGYWN0b3J5OiAncmV0dXJuIChmb2FtLmRhby5EQU8pZ2V0WCgpLmdldChnZXRUYXJnZXREQU9LZXkoKSk7J1xuICAgIH1cbiAgXSxcbiAgbWV0aG9kczogW1xuICAgIHtcbiAgICAgIG5hbWU6ICdhZGQnLFxuICAgICAgYXJnczogWyB7IG5hbWU6ICd0YXJnZXQnLCBvZjogJ2ZvYW0uY29yZS5GT2JqZWN0JyB9IF0sXG4gICAgICBqYXZhQ29kZTogJ2dldEp1bmN0aW9uREFPKCkucHV0KGNyZWF0ZUp1bmN0aW9uKCgoZm9hbS5jb3JlLklkZW50aWZpYWJsZSl0YXJnZXQpLmdldFByaW1hcnlLZXkoKSkpOycsXG4gICAgICBjb2RlOiBmdW5jdGlvbiBhZGQodGFyZ2V0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmp1bmN0aW9uREFPLnB1dCh0aGlzLmNyZWF0ZUp1bmN0aW9uKHRhcmdldC5pZCkpO1xuICAgICAgfVxuICAgIH0sXG4gICAge1xuICAgICAgbmFtZTogJ3JlbW92ZScsXG4gICAgICBqYXZhQ29kZTogJ2dldEp1bmN0aW9uREFPKCkucHV0KGNyZWF0ZUp1bmN0aW9uKCgoZm9hbS5jb3JlLklkZW50aWZpYWJsZSl0YXJnZXQpLmdldFByaW1hcnlLZXkoKSkpOycsXG4gICAgICBjb2RlOiBmdW5jdGlvbiByZW1vdmUodGFyZ2V0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmp1bmN0aW9uREFPLnJlbW92ZSh0aGlzLmNyZWF0ZUp1bmN0aW9uKHRhcmdldC5pZCkpO1xuICAgICAgfVxuICAgIH0sXG4gICAge1xuICAgICAgbmFtZTogJ2NyZWF0ZUp1bmN0aW9uJyxcbiAgICAgIGFyZ3M6IFsgeyBuYW1lOiAndGFyZ2V0SWQnLCBvZjogJ09iamVjdCcgfSBdLFxuICAgICAgcmV0dXJuczogJ2ZvYW0uY29yZS5GT2JqZWN0JyxcbiAgICAgIGphdmFSZXR1cm5zOiAnZm9hbS5jb3JlLkZPYmplY3QnLFxuICAgICAgY29kZTogZnVuY3Rpb24gY3JlYXRlSnVuY3Rpb24odGFyZ2V0SWQpIHtcbiAgICAgICAgZm9hbS5hc3NlcnQoICggISBmb2FtLlVuZGVmaW5lZC5pc0luc3RhbmNlKHRoaXMuc291cmNlSWQpICkgJiZcbiAgICAgICAgICAgICAgICAgICAgICggISBmb2FtLlVuZGVmaW5lZC5pc0luc3RhbmNlKHRhcmdldElkKSApLFxuICAgICAgICAgICAgICAgICAgICBcIkNhbm5vdCBjcmVhdGUgYW4gYXNzb2NpYXRpb24gd2l0aCBhbiBvYmplY3QgdGhhdCBpc24ndCBzdG9yZWQgaW4gYSBEQU8geWV0LlwiKTtcbiAgICAgICAgdmFyIGp1bmN0aW9uID0gdGhpcy5qdW5jdGlvbi5jcmVhdGUobnVsbCwgdGhpcyk7XG4gICAgICAgIHRoaXMudGFyZ2V0UHJvcGVydHkuc2V0KGp1bmN0aW9uLCB0YXJnZXRJZCk7XG4gICAgICAgIHRoaXMuc291cmNlUHJvcGVydHkuc2V0KGp1bmN0aW9uLCB0aGlzLnNvdXJjZUlkKTtcbiAgICAgICAgcmV0dXJuIGp1bmN0aW9uO1xuICAgICAgfSxcbiAgICAgIGphdmFDb2RlOiBgZm9hbS5jb3JlLkZPYmplY3QganVuY3Rpb24gPSAoZm9hbS5jb3JlLkZPYmplY3QpZ2V0WCgpLmNyZWF0ZShnZXRKdW5jdGlvbigpLmdldE9iakNsYXNzKCkpO1xuZ2V0VGFyZ2V0UHJvcGVydHkoKS5zZXQoanVuY3Rpb24sIHRhcmdldElkKTtcbmdldFNvdXJjZVByb3BlcnR5KCkuc2V0KGp1bmN0aW9uLCBnZXRTb3VyY2VJZCgpKTtcbnJldHVybiBqdW5jdGlvbjtcbmBcbiAgICB9LFxuICAgIHtcbiAgICAgIC8vIFRPRE86IFNob3VsZCB3ZSByZW1vdmUgdGhpcywgb3IgbWF5YmUganVzdCB0aGUgamF2YSBwb3J0aW9uP1xuICAgICAgbmFtZTogJ2dldERBTycsXG4gICAgICByZXR1cm5zOiAnZm9hbS5kYW8uREFPJyxcbiAgICAgIGphdmFDb2RlOiAncmV0dXJuIGdldERhbygpOycsXG4gICAgICBjb2RlOiBmdW5jdGlvbiBnZXREQU8oKSB7IHJldHVybiB0aGlzLmRhbzsgfVxuICAgIH1cbiAgXSxcbiAgYWN0aW9uczogW1xuICAgIHtcbiAgICAgIG5hbWU6ICdhZGRJdGVtJyxcbiAgICAgIGxhYmVsOiAnQWRkJyxcbiAgICAgIGNvZGU6IGZ1bmN0aW9uKHgpIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICB2YXIgZGFvID0geFtzZWxmLnRhcmdldERBT0tleV07XG5cbiAgICAgICAgdmFyIGNvbnRyb2xsZXIgPSBmb2FtLmNvbWljcy5EQU9Db250cm9sbGVyLmNyZWF0ZSh7XG4gICAgICAgICAgY3JlYXRlRW5hYmxlZDogZmFsc2UsXG4gICAgICAgICAgZWRpdEVuYWJsZWQ6IGZhbHNlLFxuICAgICAgICAgIHNlbGVjdEVuYWJsZWQ6IHRydWUsXG4gICAgICAgICAgYWRkRW5hYmxlZDogZmFsc2UsXG4gICAgICAgICAgcmVsYXRpb25zaGlwOiB0aGlzLFxuICAgICAgICAgIGRhdGE6IGRhb1xuICAgICAgICB9LCB4KTtcblxuICAgICAgICBjb250cm9sbGVyLnN1Yignc2VsZWN0JywgZnVuY3Rpb24ocywgXywgaWQpIHtcbiAgICAgICAgICBkYW8uZmluZChpZCkudGhlbihmdW5jdGlvbihvYmopIHsgc2VsZi5hZGQob2JqKTsgfSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHguc3RhY2sucHVzaCh7IGNsYXNzOiAnZm9hbS5jb21pY3MuREFPQ29udHJvbGxlclZpZXcnLCBkYXRhOiBjb250cm9sbGVyIH0pO1xuICAgICAgfVxuICAgIH0sXG4gICAge1xuICAgICAgbmFtZTogJ3JlbW92ZUl0ZW0nLFxuICAgICAgbGFiZWw6ICdSZW1vdmUnLFxuICAgICAgY29kZTogZnVuY3Rpb24oeCkge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIHZhciBkYW8gPSBzZWxmLmRhbztcblxuICAgICAgICB2YXIgY29udHJvbGxlciA9IGZvYW0uY29taWNzLkRBT0NvbnRyb2xsZXIuY3JlYXRlKHtcbiAgICAgICAgICBjcmVhdGVFbmFibGVkOiBmYWxzZSxcbiAgICAgICAgICBlZGl0RW5hYmxlZDogZmFsc2UsXG4gICAgICAgICAgc2VsZWN0RW5hYmxlZDogdHJ1ZSxcbiAgICAgICAgICBhZGRFbmFibGVkOiBmYWxzZSxcbiAgICAgICAgICByZWxhdGlvbnNoaXA6IHRoaXMsXG4gICAgICAgICAgZGF0YTogZGFvXG4gICAgICAgIH0sIHgpO1xuXG4gICAgICAgIGNvbnRyb2xsZXIuc3ViKCdzZWxlY3QnLCBmdW5jdGlvbihzLCBfLCBpZCkge1xuICAgICAgICAgIGRhby5maW5kKGlkKS50aGVuKGZ1bmN0aW9uKG9iaikgeyBzZWxmLnJlbW92ZShvYmopOyB9KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgeC5zdGFjay5wdXNoKHsgY2xhc3M6ICdmb2FtLmNvbWljcy5EQU9Db250cm9sbGVyVmlldycsIGRhdGE6IGNvbnRyb2xsZXIgfSk7XG4gICAgICB9XG4gICAgfVxuICBdXG59KTtcblxuZm9hbS5DTEFTUyh7XG4gIHBhY2thZ2U6ICdmb2FtLmRhbycsXG4gIG5hbWU6ICdPbmVUb01hbnlSZWxhdGlvbnNoaXBQcm9wZXJ0eScsXG4gIGV4dGVuZHM6ICdmb2FtLmRhby5EQU9Qcm9wZXJ0eScsXG4gIHByb3BlcnRpZXM6IFtcbiAgICBbJ3RyYW5zaWVudCcsIHRydWVdLFxuICAgIFsndGFibGVDZWxsRm9ybWF0dGVyJywgbnVsbF0sXG4gICAgWydjbG9uZVByb3BlcnR5JywgZnVuY3Rpb24odmFsdWUsIG1hcCl7fV0sXG4gICAgWydqYXZhQ2xvbmVQcm9wZXJ0eScsICcvL25vb3AnXSxcbiAgICBbJ2phdmFEaWZmUHJvcGVydHknLCAnLy9ub29wJ10sXG4gICAge1xuICAgICAgY2xhc3M6ICdTdHJpbmcnLFxuICAgICAgbmFtZTogJ3RhcmdldFByb3BlcnR5TmFtZScsXG4gICAgICBkb2N1bWVudGF0aW9uOiBcIldlIGRvbid0IGp1c3QgdXNlIHRhcmdldFByb3BlcnR5IGhlcmUgYmVjYXVzZSBhdCB0aGUgdGltZSB0aGF0IHRoaXMgYXhpb20gaXMgY3JlYXRlZCwgdGhlIHRhcmdldCBwcm9wZXJ0eSBtYXkgbm90IGV2ZW4gYmUgaW5zdGFsbGVkIHlldCBvbiB0aGUgdGFyZ2V0LiAgU28gaW5zdGVhZCB3ZSB1c2UgYSBjb21iaW5hdGlvbiBvZiB0YXJnZXRQcm9wZXJ0eU5hbWUgYW5kIHRhcmdldCBjbGFzcyBhbmQgZ2V0IHRoZSBhY3R1YWwgcHJvcGVydHkgd2hlbiBuZWVkZWQuXCJcbiAgICB9LFxuICAgIHtcbiAgICAgIGNsYXNzOiAnQ2xhc3MnLFxuICAgICAgbmFtZTogJ3RhcmdldCdcbiAgICB9LFxuICAgIHtcbiAgICAgIGNsYXNzOiAnU3RyaW5nJyxcbiAgICAgIG5hbWU6ICd0YXJnZXREQU9LZXknXG4gICAgfSxcbiAgICB7XG4gICAgICBuYW1lOiAnZXhwcmVzc2lvbicsXG4gICAgICBmYWN0b3J5OiBmdW5jdGlvbigpIHtcbiAgICAgICAgLy8gQWdhaW4sIGRlbGF5IHJlc29sdmluZyB0aGUgdGFyZ2V0IHByb3BlcnR5IHVudGlsIGFzIGxhdGUgYXNcbiAgICAgICAgLy8gcG9zc2libGUuICBUaGlzIGZhY3RvcnkgZ2V0cyB0cmlnZ2VyZWQgYmVmb3JlIFJFTEFUSU9OU0hJUFxuICAgICAgICAvLyBoYXMgYSBjaGFuY2UgdG8gaW5zdGFsbCB0aGUgdGFyZ2V0IHByb3BlcnR5LlxuICAgICAgICB2YXIgdGFyZ2V0ID0gdGhpcy50YXJnZXQ7XG4gICAgICAgIHZhciB0YXJnZXRQcm9wZXJ0eU5hbWUgPSB0aGlzLnRhcmdldFByb3BlcnR5TmFtZTtcbiAgICAgICAgdmFyIHRhcmdldERBT0tleSA9IHRoaXMudGFyZ2V0REFPS2V5O1xuXG4gICAgICAgIHJldHVybiBmdW5jdGlvbihpZCkge1xuICAgICAgICAgIHJldHVybiBmb2FtLmRhby5SZWxhdGlvbnNoaXBEQU8uY3JlYXRlKHtcbiAgICAgICAgICAgIHNvdXJjZUlkOiBpZCxcbiAgICAgICAgICAgIHRhcmdldFByb3BlcnR5OiB0YXJnZXQuZ2V0QXhpb21CeU5hbWUodGFyZ2V0UHJvcGVydHlOYW1lKSxcbiAgICAgICAgICAgIHRhcmdldERBT0tleTogdGFyZ2V0REFPS2V5XG4gICAgICAgICAgfSwgdGhpcyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIHtcbiAgICAgIG5hbWU6ICdqYXZhRmFjdG9yeScsXG4gICAgICBmYWN0b3J5OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIGByZXR1cm4gbmV3IGZvYW0uZGFvLlJlbGF0aW9uc2hpcERBTy5CdWlsZGVyKGdldFgoKSkuXG4gIHNldFNvdXJjZUlkKGdldElkKCkpLlxuICBzZXRUYXJnZXRQcm9wZXJ0eSgke3RoaXMudGFyZ2V0LmlkfS4ke2ZvYW0uU3RyaW5nLmNvbnN0YW50aXplKHRoaXMudGFyZ2V0UHJvcGVydHlOYW1lKX0pLlxuICBzZXRUYXJnZXREQU9LZXkoXCIke3RoaXMudGFyZ2V0REFPS2V5fVwiKS5cbiAgYnVpbGQoKTtgO1xuICAgICAgfVxuICAgIH1cbiAgXVxufSk7XG5cbmZvYW0uQ0xBU1Moe1xuICBwYWNrYWdlOiAnZm9hbS5kYW8nLFxuICBuYW1lOiAnTWFueVRvTWFueVJlbGF0aW9uc2hpcFByb3BlcnR5JyxcbiAgZXh0ZW5kczogJ2ZvYW0uY29yZS5GT2JqZWN0UHJvcGVydHknLFxuICBwcm9wZXJ0aWVzOiBbXG4gICAgWydvZicsICdmb2FtLmRhby5NYW55VG9NYW55UmVsYXRpb25zaGlwJ10sXG4gICAgWyd0cmFuc2llbnQnLCB0cnVlXSxcbiAgICBbJ3RhYmxlQ2VsbEZvcm1hdHRlcicsIG51bGxdLFxuICAgIFsnY2xvbmVQcm9wZXJ0eScsIGZ1bmN0aW9uKHZhbHVlLCBtYXApIHt9XSxcbiAgICBbJ2phdmFDbG9uZVByb3BlcnR5JywgJy8vbm9vcCddLFxuICAgIFsnamF2YURpZmZQcm9wZXJ0eScsICcvL25vb3AnXSxcbiAgICBbJ3ZpZXcnLCB7IGNsYXNzOiAnZm9hbS51Mi5EZXRhaWxWaWV3Jywgc2hvd0FjdGlvbnM6IHRydWUgfSBdLFxuICAgIHtcbiAgICAgIGNsYXNzOiAnQ2xhc3MnLFxuICAgICAgbmFtZTogJ2p1bmN0aW9uJ1xuICAgIH0sXG4gICAge1xuICAgICAgY2xhc3M6ICdDbGFzcycsXG4gICAgICBuYW1lOiAndGFyZ2V0J1xuICAgIH0sXG4gICAgJ3NvdXJjZVByb3BlcnR5JyxcbiAgICB7XG4gICAgICBjbGFzczogJ1N0cmluZycsXG4gICAgICBuYW1lOiAnanVuY3Rpb25EQU9LZXknXG4gICAgfSxcbiAgICB7XG4gICAgICBjbGFzczogJ1N0cmluZycsXG4gICAgICBuYW1lOiAndGFyZ2V0REFPS2V5J1xuICAgIH0sXG4gICAgJ3RhcmdldFByb3BlcnR5JyxcbiAgICB7XG4gICAgICBuYW1lOiAnZXhwcmVzc2lvbicsXG4gICAgICBmYWN0b3J5OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHNvdXJjZVByb3BlcnR5ID0gdGhpcy5zb3VyY2VQcm9wZXJ0eTtcbiAgICAgICAgdmFyIHRhcmdldFByb3BlcnR5ID0gdGhpcy50YXJnZXRQcm9wZXJ0eTtcbiAgICAgICAgdmFyIHRhcmdldERBT0tleSA9IHRoaXMudGFyZ2V0REFPS2V5O1xuICAgICAgICB2YXIganVuY3Rpb25EQU9LZXkgPSB0aGlzLmp1bmN0aW9uREFPS2V5O1xuICAgICAgICB2YXIganVuY3Rpb24gPSB0aGlzLmp1bmN0aW9uO1xuXG4gICAgICAgIHJldHVybiBmdW5jdGlvbihpZCkge1xuICAgICAgICAgIHJldHVybiBmb2FtLmRhby5NYW55VG9NYW55UmVsYXRpb25zaGlwSW1wbC5jcmVhdGUoe1xuICAgICAgICAgICAgc291cmNlSWQ6IGlkLFxuICAgICAgICAgICAgc291cmNlUHJvcGVydHk6IHNvdXJjZVByb3BlcnR5LFxuICAgICAgICAgICAgdGFyZ2V0UHJvcGVydHk6IHRhcmdldFByb3BlcnR5LFxuICAgICAgICAgICAgdGFyZ2V0REFPS2V5OiB0YXJnZXREQU9LZXksXG4gICAgICAgICAgICBqdW5jdGlvbkRBT0tleToganVuY3Rpb25EQU9LZXksXG4gICAgICAgICAgICBqdW5jdGlvbjoganVuY3Rpb25cbiAgICAgICAgICB9LCB0aGlzKTtcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHtcbiAgICAgIG5hbWU6ICdqYXZhRmFjdG9yeScsXG4gICAgICBmYWN0b3J5OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIGByZXR1cm4gbmV3IGZvYW0uZGFvLk1hbnlUb01hbnlSZWxhdGlvbnNoaXBJbXBsLkJ1aWxkZXIoZ2V0WCgpKS5cbiAgc2V0U291cmNlSWQoZ2V0SWQoKSkuXG4gIHNldFNvdXJjZVByb3BlcnR5KCR7dGhpcy5zb3VyY2VQcm9wZXJ0eS5mb3JDbGFzc199LiR7Zm9hbS5TdHJpbmcuY29uc3RhbnRpemUodGhpcy5zb3VyY2VQcm9wZXJ0eS5uYW1lKX0pLlxuICBzZXRUYXJnZXRQcm9wZXJ0eSgke3RoaXMudGFyZ2V0UHJvcGVydHkuZm9yQ2xhc3NffS4ke2ZvYW0uU3RyaW5nLmNvbnN0YW50aXplKHRoaXMudGFyZ2V0UHJvcGVydHkubmFtZSl9KS5cbiAgc2V0VGFyZ2V0REFPS2V5KFwiJHt0aGlzLnRhcmdldERBT0tleX1cIikuXG4gIHNldEp1bmN0aW9uREFPS2V5KFwiJHt0aGlzLmp1bmN0aW9uREFPS2V5fVwiKS5cbiAgc2V0SnVuY3Rpb24oJHt0aGlzLmp1bmN0aW9uLmlkfS5nZXRPd25DbGFzc0luZm8oKSkuXG4gIGJ1aWxkKCk7XG5gO1xuICAgICAgfVxuICAgIH1cbiAgXVxufSk7XG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTggVGhlIEZPQU0gQXV0aG9ycy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICovXG5cbmZvYW0uQ0xBU1Moe1xuICBwYWNrYWdlOiAnZm9hbS5kYW8nLFxuICBuYW1lOiAnUmVsYXRpb25zaGlwREFPJyxcbiAgZXh0ZW5kczogJ2ZvYW0uZGFvLkZpbHRlcmVkREFPJyxcbiAgcmVxdWlyZXM6IFtcbiAgICAnZm9hbS5tbGFuZy5wcmVkaWNhdGUuRXEnXG4gIF0sXG5cbiAgZG9jdW1lbnRhdGlvbjogJ0FkYXB0cyBhIERBTyBiYXNlZCBvbiBhIFJlbGF0aW9uc2hpcC4nLFxuXG4gIHByb3BlcnRpZXM6IFtcbiAgICB7XG4gICAgICBjbGFzczogJ09iamVjdCcsXG4gICAgICBuYW1lOiAnc291cmNlSWQnXG4gICAgfSxcbiAgICB7XG4gICAgICBjbGFzczogJ1N0cmluZycsXG4gICAgICBuYW1lOiAndGFyZ2V0REFPS2V5J1xuICAgIH0sXG4gICAge1xuICAgICAgY2xhc3M6ICdPYmplY3QnLFxuICAgICAgbmFtZTogJ3RhcmdldFByb3BlcnR5JyxcbiAgICAgIGphdmFUeXBlOiAnZm9hbS5jb3JlLlByb3BlcnR5SW5mbydcbiAgICB9LFxuICAgIHtcbiAgICAgIG5hbWU6ICdwcmVkaWNhdGUnLFxuICAgICAgZmFjdG9yeTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLkVxLmNyZWF0ZSh7IGFyZzE6IHRoaXMudGFyZ2V0UHJvcGVydHksIGFyZzI6IHRoaXMuc291cmNlSWQgfSk7XG4gICAgICB9LFxuICAgICAgamF2YUZhY3Rvcnk6ICd0aHJvdyBuZXcgUnVudGltZUV4Y2VwdGlvbihcIlRPRE9cIik7J1xuICAgIH0sXG4gICAge1xuICAgICAgbmFtZTogJ2RlbGVnYXRlJyxcbiAgICAgIGZhY3Rvcnk6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIga2V5ICAgICAgPSB0aGlzLnRhcmdldERBT0tleTtcbiAgICAgICAgdmFyIGRlbGVnYXRlID0gdGhpcy5fX2NvbnRleHRfX1trZXldO1xuXG4gICAgICAgIGZvYW0uYXNzZXJ0KGRlbGVnYXRlLCAnTWlzc2luZyByZWxhdGlvbnNoaXAgREFPOicsIGtleSk7XG5cbiAgICAgICAgcmV0dXJuIGRlbGVnYXRlO1xuICAgICAgfSxcbiAgICAgIGphdmFGYWN0b3J5OiAncmV0dXJuIChmb2FtLmRhby5EQU8pZ2V0WCgpLmdldChnZXRUYXJnZXREQU9LZXkoKSk7J1xuICAgIH1cbiAgXSxcblxuICBtZXRob2RzOiBbXG4gICAge1xuICAgICAgbmFtZTogJ3B1dF8nLFxuICAgICAgamF2YVJldHVybnM6ICdmb2FtLmNvcmUuRk9iamVjdCcsXG4gICAgICBjb2RlOiBmdW5jdGlvbiBwdXRfKHgsIG9iaikge1xuICAgICAgICByZXR1cm4gdGhpcy5TVVBFUih4LCB0aGlzLmFkYXB0VGFyZ2V0KG9iaikpO1xuICAgICAgfSxcbiAgICAgIGphdmFDb2RlOiBgcmV0dXJuIHN1cGVyLnB1dF8oeCwgYWRhcHRUYXJnZXQob2JqKSk7YFxuICAgIH0sXG4gICAge1xuICAgICAgbmFtZTogJ2FkYXB0VGFyZ2V0JyxcbiAgICAgIGphdmFSZXR1cm5zOiAnZm9hbS5jb3JlLkZPYmplY3QnLFxuICAgICAgYXJnczogW1xuICAgICAgICB7XG4gICAgICAgICAgbmFtZTogJ3RhcmdldCcsXG4gICAgICAgICAgamF2YVR5cGU6ICdmb2FtLmNvcmUuRk9iamVjdCdcbiAgICAgICAgfVxuICAgICAgXSxcbiAgICAgIGphdmFDb2RlOmBnZXRUYXJnZXRQcm9wZXJ0eSgpLnNldCh0YXJnZXQsIGdldFNvdXJjZUlkKCkpO1xucmV0dXJuIHRhcmdldDtgLFxuICAgICAgY29kZTogZnVuY3Rpb24odGFyZ2V0KSB7XG4gICAgICAgIHRoaXMudGFyZ2V0UHJvcGVydHkuc2V0KHRhcmdldCwgdGhpcy5zb3VyY2VJZCk7XG4gICAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgICB9XG4gICAgfSxcblxuICAgIGZ1bmN0aW9uIGNsb25lKCkge1xuICAgICAgLy8gUHJldmVudCBjbG9uZWluZ1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICBdXG59KTtcbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxOCBUaGUgRk9BTSBBdXRob3JzLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKi9cblxuZm9hbS5DTEFTUyh7XG4gIHBhY2thZ2U6ICdmb2FtLmRhbycsXG4gIG5hbWU6ICdNYW55VG9NYW55UmVsYXRpb25zaGlwREFPJyxcbiAgZXh0ZW5kczogJ2ZvYW0uZGFvLlByb3h5REFPJyxcblxuICBpbXBsZW1lbnRzOiBbIHsgcGF0aDogJ2ZvYW0ubWxhbmcuRXhwcmVzc2lvbnMnLCBqYXZhOiBmYWxzZSB9IF0sXG5cbiAgZG9jdW1lbnRhdGlvbjogJ0FkYXB0cyBhIERBTyBiYXNlZCBvbiBhICo6KiBSZWxhdGlvbnNoaXAuJyxcblxuICBwcm9wZXJ0aWVzOiBbXG4gICAge1xuICAgICAgY2xhc3M6ICdGT2JqZWN0UHJvcGVydHknLFxuICAgICAgb2Y6ICdmb2FtLmRhby5NYW55VG9NYW55UmVsYXRpb25zaGlwSW1wbCcsXG4gICAgICBuYW1lOiAncmVsYXRpb25zaGlwJ1xuICAgIH1cbiAgXSxcblxuICBtZXRob2RzOiBbXG4gICAge1xuICAgICAgbmFtZTogJ2ZpbmRfJyxcbiAgICAgIGNvZGU6IGZ1bmN0aW9uIGZpbmRfKHgsIGlkKSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgdmFyIGp1bmN0aW9uID0gdGhpcy5yZWxhdGlvbnNoaXAuY3JlYXRlSnVuY3Rpb24oaWQpXG5cbiAgICAgICAgcmV0dXJuIHRoaXMucmVsYXRpb25zaGlwLmp1bmN0aW9uREFPLmZpbmQoanVuY3Rpb24uaWQpLnRoZW4oZnVuY3Rpb24oYSkge1xuICAgICAgICAgIHJldHVybiBhICYmIHNlbGYuZGVsZWdhdGUuZmluZF8oeCwgaWQpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHtcbiAgICAgIG5hbWU6ICdzZWxlY3RfJyxcbiAgICAgIGNvZGU6IGZ1bmN0aW9uIHNlbGVjdF8oeCwgc2luaywgc2tpcCwgbGltaXQsIG9yZGVyLCBwcmVkaWNhdGUpIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgICAgIHJldHVybiB0aGlzLnJlbGF0aW9uc2hpcC5qdW5jdGlvbkRBTy5cbiAgICAgICAgICB3aGVyZShzZWxmLkVRKHRoaXMucmVsYXRpb25zaGlwLnNvdXJjZVByb3BlcnR5LCB0aGlzLnJlbGF0aW9uc2hpcC5zb3VyY2VJZCkpLlxuICAgICAgICAgIHNlbGVjdChzZWxmLk1BUCh0aGlzLnJlbGF0aW9uc2hpcC50YXJnZXRQcm9wZXJ0eSkpLnRoZW4oZnVuY3Rpb24obWFwKSB7XG4gICAgICAgICAgICByZXR1cm4gc2VsZi5kZWxlZ2F0ZS5zZWxlY3RfKHgsIHNpbmssIHNraXAsIGxpbWl0LCBvcmRlciwgc2VsZi5BTkQoXG4gICAgICAgICAgICAgIHByZWRpY2F0ZSB8fCBzZWxmLlRSVUUsXG4gICAgICAgICAgICAgIHNlbGYuSU4oc2VsZi5vZi5JRCwgbWFwLmRlbGVnYXRlLmFycmF5KSkpO1xuICAgICAgICAgIH0pO1xuICAgICAgfSxcbiAgICAgIGphdmFDb2RlOiBgZm9hbS5tbGFuZy5zaW5rLk1hcCBqdW5jdGlvbiA9IChmb2FtLm1sYW5nLnNpbmsuTWFwKWdldFJlbGF0aW9uc2hpcCgpLmdldEp1bmN0aW9uREFPKCkud2hlcmUoXG4gICAgZm9hbS5tbGFuZy5NTGFuZy5FUShnZXRSZWxhdGlvbnNoaXAoKS5nZXRTb3VyY2VQcm9wZXJ0eSgpLCBnZXRSZWxhdGlvbnNoaXAoKS5nZXRTb3VyY2VJZCgpKSkuXG4gIHNlbGVjdChmb2FtLm1sYW5nLk1MYW5nLk1BUChnZXRSZWxhdGlvbnNoaXAoKS5nZXRUYXJnZXRQcm9wZXJ0eSgpLCBuZXcgZm9hbS5kYW8uTGlzdFNpbmsoKSkpO1xuXG4gIHJldHVybiBnZXREZWxlZ2F0ZSgpLndoZXJlKGZvYW0ubWxhbmcuTUxhbmcuSU4oZ2V0UHJpbWFyeUtleSgpLCAoKGZvYW0uZGFvLkxpc3RTaW5rKShqdW5jdGlvbi5nZXREZWxlZ2F0ZSgpKSkuZ2V0RGF0YSgpLnRvQXJyYXkoKSkpLnNlbGVjdF8oXG4gICAgeCwgc2luaywgc2tpcCwgbGltaXQsIG9yZGVyLCBwcmVkaWNhdGUpO2BcbiAgICB9XG4gIF1cbn0pO1xuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgVGhlIEZPQU0gQXV0aG9ycy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuZm9hbS5DTEFTUyh7XG4gIHBhY2thZ2U6ICdmb2FtLmRhby5ncmlkJyxcbiAgbmFtZTogJ01hbnlUb01hbnlHcmlkUmVjb3JkJyxcblxuICBwcm9wZXJ0aWVzOiBbXG4gICAge1xuICAgICAgbmFtZTogJ2lkJyxcbiAgICAgIGdldHRlcjogZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLnRhcmdldC5pZDsgfVxuICAgIH0sXG4gICAge1xuICAgICAgY2xhc3M6ICdGT2JqZWN0UHJvcGVydHknLFxuICAgICAgbmFtZTogJ3RhcmdldCcsXG4gICAgICByZXF1aXJlZDogdHJ1ZVxuICAgIH0sXG4gICAge1xuICAgICAgY2xhc3M6ICdBcnJheScsXG4gICAgICBvZjogJ0Jvb2xlYW4nLFxuICAgICAgbmFtZTogJ2RhdGEnXG4gICAgfVxuICBdXG59KTtcbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IFRoZSBGT0FNIEF1dGhvcnMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmZvYW0uQ0xBU1Moe1xuICBwYWNrYWdlOiAnZm9hbS5kYW8uZ3JpZCcsXG4gIG5hbWU6ICdNYW55VG9NYW55R3JpZERBTycsXG4gIGV4dGVuZHM6ICdmb2FtLmRhby5SZWFkT25seURBTycsXG4gIGltcGxlbWVudHM6IFsgJ2ZvYW0ubWxhbmcuRXhwcmVzc2lvbnMnIF0sXG5cbiAgZG9jdW1lbnRhdGlvbjogYEEgREFPIHRoYXQgZGVsZWdhdGVzIHRvIHRoZSBcInRhcmdldFwiIHNpZGUgb2YgYSBtYW55LXRvLW1hbnlcbiAgICAgIHJlbGF0aW9uc2hpcCwgYW5kIG1haW50YWlucyBhIHJlZmVyZW5jZSB0byBhIFwic291cmNlc1wiIERBTyBvZiBcInNvdXJjZVwiXG4gICAgICBvYmplY3RzLiBUaGlzIERBTyBpcyBcIm9mXCI6XG5cbiAgICAgIHsgdGFyZ2V0LCBkYXRhOiBCb29sZWFuW10oaXMgXCJ0YXJnZXRcIiByZWxhdGVkIHRvIGl0aCBzb3VyY2UpIH0uXG5cbiAgICAgIFRoZSBEQU8gaXMgZGVzaWduZWQgZm9yIGFkYXB0aW5nIHRvIHRhYmxlIHZpZXdzIG9mIGEgcmVsYXRpb25zaGlwIGdyaWQuXG4gICAgICBUaGUgcHJlcHJvY2Vzc2luZyBpcyBpbXBsZW1lbnRlZCBhdCB0aGUgREFPIGxheWVyIHNvIHRoYXQgaXQgY2FuIGVhc2lseVxuICAgICAgcHVzaGVkIG9mZiB0aGUgVUkgdGhyZWFkLmAsXG5cbiAgcmVxdWlyZXM6IFsgJ2ZvYW0uZGFvLkFycmF5U2luaycgXSxcblxuICBpbXBvcnRzOiBbICdyZWxhdGlvbnNoaXAnIF0sXG5cbiAgcHJvcGVydGllczogW1xuICAgIHtcbiAgICAgIG5hbWU6ICdkZWxlZ2F0ZScsXG4gICAgICBmYWN0b3J5OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX19jb250ZXh0X19bdGhpcy5yZWxhdGlvbnNoaXAudGFyZ2V0REFPS2V5XTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHtcbiAgICAgIGNsYXNzOiAnQ2xhc3MnLFxuICAgICAgbmFtZTogJ2p1bmN0aW9uQ2xzJyxcbiAgICAgIGZhY3Rvcnk6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5sb29rdXAodGhpcy5yZWxhdGlvbnNoaXAuanVuY3Rpb25Nb2RlbCk7XG4gICAgICB9XG4gICAgfSxcbiAgICB7XG4gICAgICBjbGFzczogJ2ZvYW0uZGFvLkRBT1Byb3BlcnR5JyxcbiAgICAgIG5hbWU6ICdzb3VyY2VEQU8nLFxuICAgICAgZmFjdG9yeTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9fY29udGV4dF9fW3RoaXMucmVsYXRpb25zaGlwLnNvdXJjZURBT0tleV07XG4gICAgICB9XG4gICAgfSxcbiAgICB7XG4gICAgICBjbGFzczogJ2ZvYW0uZGFvLkRBT1Byb3BlcnR5JyxcbiAgICAgIG5hbWU6ICdqdW5jdGlvbkRBTycsXG4gICAgICBmYWN0b3J5OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX19jb250ZXh0X19bdGhpcy5yZWxhdGlvbnNoaXAuanVuY3Rpb25EQU9LZXldO1xuICAgICAgfVxuICAgIH0sXG4gICAge1xuICAgICAgY2xhc3M6ICdTdHJpbmcnLFxuICAgICAgbmFtZTogJ2dyaWRDbHNJZCcsXG4gICAgICBmYWN0b3J5OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVsYXRpb25zaGlwLmp1bmN0aW9uTW9kZWwgKyAnR3JpZCc7XG4gICAgICB9XG4gICAgfSxcbiAgICB7XG4gICAgICBjbGFzczogJ0NsYXNzJyxcbiAgICAgIG5hbWU6ICdvZicsXG4gICAgICB2YWx1ZTogJ2ZvYW0uZGFvLmdyaWQuTWFueVRvTWFueUdyaWRSZWNvcmQnXG4gICAgfVxuICBdLFxuXG4gIG1ldGhvZHM6IFtcbiAgICBmdW5jdGlvbiBmaW5kXyh4LCBvKSB7XG4gICAgICByZXR1cm4gdGhpcy5kZWxlZ2F0ZS5maW5kXyh4LCBvKS5cbiAgICAgICAgICB0aGVuKHRoaXMuYWRkU291cmNlc1RvVGFyZ2V0LmJpbmQodGhpcywgeCkpO1xuICAgIH0sXG4gICAgZnVuY3Rpb24gc2VsZWN0Xyh4LCBzaW5rLCBza2lwLCBsaW1pdCwgb3JkZXIsIHByZWRpY2F0ZSkge1xuICAgICAgc2luayA9IHNpbmsgfHwgdGhpcy5BcnJheVNpbmsuY3JlYXRlKCk7XG4gICAgICByZXR1cm4gdGhpcy5kZWxlZ2F0ZS5cbiAgICAgICAgICBzZWxlY3RfKHgsIHRoaXMuQXJyYXlTaW5rLmNyZWF0ZSgpLCBza2lwLCBsaW1pdCwgb3JkZXIsIHByZWRpY2F0ZSkuXG4gICAgICAgICAgdGhlbih0aGlzLmFkZFNvdXJjZXNUb1RhcmdldHMuYmluZCh0aGlzLCB4LCBzaW5rKSkuXG4gICAgICAgICAgdGhlbihmdW5jdGlvbigpIHsgc2luayAmJiBzaW5rLmVvZiAmJiBzaW5rLmVvZigpOyByZXR1cm4gc2luazsgfSk7XG4gICAgfVxuICBdLFxuXG4gIGxpc3RlbmVyczogW1xuICAgIGZ1bmN0aW9uIGFkZFNvdXJjZXNUb1RhcmdldCh4LCB0YXJnZXQpIHtcbiAgICAgIHZhciBDbHMgPSB0aGlzLm9mO1xuICAgICAgcmV0dXJuIHRoaXMuc291cmNlREFPLnNlbGVjdCgpLlxuICAgICAgICAgIHRoZW4odGhpcy5nZXREYXRhRm9yVGFyZ2V0LmJpbmQodGhpcywgdGFyZ2V0KSkuXG4gICAgICAgICAgdGhlbihmdW5jdGlvbihkYXRhKSB7XG4gICAgICAgICAgICByZXR1cm4gQ2xzLmNyZWF0ZSh7IHRhcmdldDogdGFyZ2V0LCBkYXRhOiBkYXRhIH0sIHgpO1xuICAgICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICBmdW5jdGlvbiBhZGRTb3VyY2VzVG9UYXJnZXRzKHgsIHNpbmssIGxvY2FsU2luaykge1xuICAgICAgdmFyIHB1dCA9IHNpbmsucHV0LmJpbmQoc2luayk7XG4gICAgICB2YXIgYXJyYXkgPSBsb2NhbFNpbmsuYXJyYXk7XG4gICAgICB2YXIgcHJvbWlzZXMgPSBuZXcgQXJyYXkoYXJyYXkubGVuZ3RoKTtcbiAgICAgIGZvciAoIHZhciBpID0gMDsgaSA8IGFycmF5Lmxlbmd0aDsgaSsrICkge1xuICAgICAgICBwcm9taXNlcy5wdXNoKHRoaXMuYWRkU291cmNlc1RvVGFyZ2V0KHgsIGFycmF5W2ldKS50aGVuKHB1dCkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFByb21pc2UuYWxsKHByb21pc2VzKTtcbiAgICB9LFxuXG4gICAgZnVuY3Rpb24gZ2V0RGF0YUZvclRhcmdldCh0YXJnZXQsIHNpbmspIHtcbiAgICAgIHZhciBzb3VyY2VzID0gc2luay5hcnJheTtcbiAgICAgIHJldHVybiBQcm9taXNlLmFsbChcbiAgICAgICAgICBzb3VyY2VzLm1hcCh0aGlzLmdldERhdHVtRm9yVGFyZ2V0LmJpbmQodGhpcywgdGFyZ2V0KSkpO1xuICAgIH0sXG4gICAgXG4gICAgZnVuY3Rpb24gZ2V0RGF0dW1Gb3JUYXJnZXQodGFyZ2V0LCBzb3VyY2UpIHtcbiAgICAgIHJldHVybiB0aGlzLmp1bmN0aW9uREFPLndoZXJlKHRoaXMuQU5EKFxuICAgICAgICAgIHRoaXMuRVEodGhpcy5qdW5jdGlvbkNscy5TT1VSQ0VfSUQsIHNvdXJjZS5pZCksXG4gICAgICAgICAgdGhpcy5FUSh0aGlzLmp1bmN0aW9uQ2xzLlRBUkdFVF9JRCwgdGFyZ2V0LmlkKSkpLnNlbGVjdCgpLlxuICAgICAgICAgIHRoZW4oZnVuY3Rpb24oYXJyYXlTaW5rKSB7IHJldHVybiAhISBhcnJheVNpbmsuYXJyYXlbMF07IH0pO1xuICAgIH1cbiAgXVxufSk7XG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG4vKipcbiAgTGF6eUNhY2hlREFPIGNhbiBjYWNoZSBzdWNjZXNzZnVsIHJlc3VsdHMgZnJvbSBmaW5kKCkgYW5kIHNlbGVjdCgpIG9uIGl0c1xuICBkZWxlZ2F0ZS4gSXQgb25seSB1cGRhdGVzIGFmdGVyIG5ldyBxdWVyaWVzIGNvbWUgaW4sIGFuZCByZXR1cm5zIGNhY2hlZFxuICByZXN1bHRzIGltbWVkaWF0ZWx5LCBldmVuIGlmIG5ldyByZXN1bHRzIGFycml2ZSBmcm9tIHRoZSBkZWxlZ2F0ZS5cbiAgbGlzdGVuIG9yIHBpcGUgZnJvbSB0aGlzIERBTyB0byBzdGF5IHVwIHRvIGRhdGUuXG4qL1xuZm9hbS5DTEFTUyh7XG4gIHBhY2thZ2U6ICdmb2FtLmRhbycsXG4gIG5hbWU6ICdMYXp5Q2FjaGVEQU8nLFxuICBleHRlbmRzOiAnZm9hbS5kYW8uUHJveHlEQU8nLFxuXG4gIGltcGxlbWVudHM6IFsgJ2ZvYW0ubWxhbmcuRXhwcmVzc2lvbnMnIF0sXG5cbiAgcmVxdWlyZXM6IFtcbiAgICAnZm9hbS5kYW8uQXJyYXlTaW5rJyxcbiAgICAnZm9hbS5kYW8uREFPU2luaydcbiAgXSxcblxuICBjbGFzc2VzOiBbXG4gICAge1xuICAgICAgbmFtZTogJ0FueVNpbmsnLFxuICAgICAgcHJvcGVydGllczogWyB7IGNsYXNzOiAnQm9vbGVhbicsIG5hbWU6ICdoYXNBbnknIH0gXSxcbiAgICAgIG1ldGhvZHM6IFsgZnVuY3Rpb24gcHV0KCkgeyB0aGlzLmhhc0FueSA9IHRydWU7IH0sIGZ1bmN0aW9uIGVvZigpIHt9IF1cbiAgICB9XG4gIF0sXG5cbiAgcHJvcGVydGllczogW1xuICAgIHtcbiAgICAgIC8qKiBTZXQgdG8gdGhlIGRlc2lyZWQgY2FjaGUsIHN1Y2ggYXMgYSBmb2FtLmRhby5NREFPLiAqL1xuICAgICAgbmFtZTogJ2NhY2hlJyxcbiAgICAgIHJlcXVpcmVkOiB0cnVlXG4gICAgfSxcbiAgICB7XG4gICAgICAvKipcbiAgICAgICAgVE9ETzogVGhpcyBpcyBhdHRlbXB0aW5nIHRvIGV4cHJlc3MgYSBsaW5rIGJldHdlZW4gdHdvIG90aGVyIHByb3BlcnRpZXMsXG4gICAgICAgIGFuZCBhIHNpZGUtZWZmZWN0IChzdWJzY3JpcHRpb24pIGlzIHdoYXQgaXMgZGVzaXJlZCwgbm90IGEgdmFsdWUuIEFsc29cbiAgICAgICAgdGhlIGNhY2hlU3luY18gcHJvcCBuZWVkcyB0byBiZSB0aWNrbGVkIHRvIGVuc3VyZSB0aGUgbGluayBleGlzdHMuXG4gICAgICAgIENoYW5nZSB0aGlzIHRvIGRlZmluZSBhbiBleHByZXNzaW9uIHRoYXQgZGVmaW5lcyBhIHJ1bi10aW1lICd0aGluZydcbiAgICAgICAgdG8gYmUgZG9uZSBiZXR3ZWVuIHByb3BlcnRpZXMsIGFuZCBhbGxvd3MgY2xlYW51cCB3aGVuIHJlLWV2YWx1YXRpbmcuXG4gICAgICAgIEBwcml2YXRlXG4gICAgICAqL1xuICAgICAgbmFtZTogJ2NhY2hlU3luY18nLFxuICAgICAgZXhwcmVzc2lvbjogZnVuY3Rpb24oZGVsZWdhdGUsIGNhY2hlKSB7XG4gICAgICAgIHZhciBzID0gdGhpcy5jYWNoZVN5bmNTdWJfID0gZGVsZWdhdGUub24ucmVtb3ZlLnN1YihcbiAgICAgICAgICBmdW5jdGlvbihzdWJfLCBvbl8sIHJlbW92ZV8sIG9iaikge1xuICAgICAgICAgICAgY2FjaGUucmVtb3ZlKG9iaik7XG4gICAgICAgICAgfVxuICAgICAgICApO1xuICAgICAgICByZXR1cm4gcztcbiAgICAgIH1cbiAgICB9LFxuICAgIHtcbiAgICAgIC8qKiBTdG9yZXMgY2xlYW51cCBpbmZvIGZvciB0aGUgY2FjaGUgc3ljaHJvbml6YXRpb24gc3Vic2NyaXB0aW9uLlxuICAgICAgICBAcHJpdmF0ZSAqL1xuICAgICAgbmFtZTogJ2NhY2hlU3luY1N1Yl8nLFxuICAgICAgcG9zdFNldDogZnVuY3Rpb24ob2xkLCBudSkge1xuICAgICAgICBpZiAoIG9sZCAmJiBvbGQuZGV0YWNoICkgb2xkLmRldGFjaCgpO1xuICAgICAgfVxuICAgIH0sXG4gICAge1xuICAgICAgLyoqXG4gICAgICAgIFdoZW4gdHJ1ZSwgbWFrZXMgYSBuZXR3b3JrIGNhbGwgaW4gdGhlIGJhY2tncm91bmQgdG9cbiAgICAgICAgdXBkYXRlIHRoZSByZWNvcmQsIGV2ZW4gb24gYSBjYWNoZSBoaXQuXG4gICAgICAqL1xuICAgICAgY2xhc3M6ICdCb29sZWFuJyxcbiAgICAgIG5hbWU6ICdyZWZyZXNoT25DYWNoZUhpdCcsXG4gICAgICB2YWx1ZTogZmFsc2UsXG4gICAgfSxcbiAgICB7XG4gICAgICAvKipcbiAgICAgICAgV2hldGhlciB0byBwb3B1bGF0ZSB0aGUgY2FjaGUgb24gc2VsZWN0KCkuXG4gICAgICAqL1xuICAgICAgY2xhc3M6ICdCb29sZWFuJyxcbiAgICAgIG5hbWU6ICdjYWNoZU9uU2VsZWN0JyxcbiAgICAgIHZhbHVlOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgLyoqXG4gICAgICAgIFRpbWUgaW4gbWlsbGlzZWNvbmRzIGJlZm9yZSB3ZSBjb25zaWRlciB0aGUgZGVsZWdhdGVcbiAgICAgICAgcmVzdWx0cyB0byBiZSBzdGFsZSBmb3IgYSBwYXJ0aWN1bGFyIHByZWRpY2F0ZSBhbmQgd2lsbCBpc3N1ZSBhIG5ld1xuICAgICAgICBzZWxlY3QuXG4gICAgICAqL1xuICAgICAgY2xhc3M6ICdJbnQnLFxuICAgICAgbmFtZTogJ3N0YWxlVGltZW91dCcsXG4gICAgICB2YWx1ZTogNTAwLFxuICAgICAgLy91bml0czogJ21zJyxcbiAgICB9LFxuICAgIHtcbiAgICAgIC8qKlxuICAgICAgICBUaGUgYWN0aXZlIHByb21pc2VzIGZvciByZW1vdGUgZmluZHMgaW4gcHJvZ3Jlc3MsIGZvciByZS11c2VcbiAgICAgICAgYnkgc3Vic2VxdWVudCBmaW5kcyBtYWRlIGJlZm9yZSB0aGUgcHJldmlvdXMgcmVzb2x2ZXMuXG4gICAgICAgIEBwcml2YXRlXG4gICAgICAqL1xuICAgICAgbmFtZTogJ2ZpbmRzXycsXG4gICAgICBoaWRkZW46IHRydWUsXG4gICAgICB0cmFuc2llbnQ6IHRydWUsXG4gICAgICBmYWN0b3J5OiBmdW5jdGlvbigpIHsgcmV0dXJuIHt9OyB9XG4gICAgfSxcbiAgICB7XG4gICAgICAvKipcbiAgICAgICAgVGhlIGFjdGl2ZSBwcm9taXNlcyBmb3IgcmVtb3RlIHNlbGVjdHMgaW4gcHJvZ3Jlc3MsIGZvciByZS11c2VcbiAgICAgICAgYnkgc3Vic2VxdWVudCBzZWxlY3RzIG1hZGUgYmVmb3JlIHRoZSBwcmV2aW91cyByZXNvbHZlcy5cbiAgICAgICAgQHByaXZhdGVcbiAgICAgICovXG4gICAgICBuYW1lOiAnc2VsZWN0c18nLFxuICAgICAgaGlkZGVuOiB0cnVlLFxuICAgICAgdHJhbnNpZW50OiB0cnVlLFxuICAgICAgZmFjdG9yeTogZnVuY3Rpb24oKSB7IHJldHVybiB7fTsgfVxuICAgIH0sXG4gICAge1xuICAgICAgLyoqXG4gICAgICAgIEdlbmVyYXRlcyBhbiBpbnRlcm5hbCBrZXkgdG8gdW5pcXVlbHkgaWRlbnRpZnkgYSBzZWxlY3QuXG4gICAgICAgIEBwcml2YXRlXG4gICAgICAqL1xuICAgICAgY2xhc3M6ICdGdW5jdGlvbicsXG4gICAgICBuYW1lOiAnc2VsZWN0S2V5JyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbihzaW5rLCBza2lwLCBsaW1pdCwgb3JkZXIsIHByZWRpY2F0ZSAvKnN0cmluZyovKSB7XG4gICAgICAgIHJldHVybiAoIHByZWRpY2F0ZSAmJiBwcmVkaWNhdGUudG9TdHJpbmcoKSApIHx8IFwiXCIgKyBcIixcIiArXG4gICAgICAgICAgbGltaXQgKyBcIixcIiArIHNraXAgKyBcIixcIiArICggb3JkZXIgJiYgb3JkZXIudG9TdHJpbmcoKSApIHx8IFwiXCI7XG4gICAgICB9XG4gICAgfVxuICBdLFxuXG4gIG1ldGhvZHM6IFtcbiAgICAvKiogRW5zdXJlcyByZW1vdmFsIGZyb20gYm90aCBjYWNoZSBhbmQgZGVsZWdhdGUgYmVmb3JlIHJlc29sdmluZy4gKi9cbiAgICBmdW5jdGlvbiByZW1vdmVfKHgsIG9iaikge1xuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgcmV0dXJuIHNlbGYuY2FjaGUucmVtb3ZlXyh4LCBvYmopLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBzZWxmLmRlbGVnYXRlLnJlbW92ZV8oeCwgb2JqKTtcbiAgICAgIH0pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgIEV4cGxpY2l0bHkgdXBkYXRlIGNhY2hlLCBlbHNlIGNhbGxlciB3aWxsIHF1ZXJ5IHN0YWxlIGRhdGEgaWZcbiAgICAgIHRoZSBzdGFsZVRpbWVvdXQgaXMgbGFyZ2VcbiAgICAqL1xuICAgIGZ1bmN0aW9uIHB1dF8oeCwgb2JqKSB7XG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICByZXR1cm4gc2VsZi5kZWxlZ2F0ZS5wdXRfKHgsIG9iaikudGhlbihmdW5jdGlvbihvKSB7XG4gICAgICAgIHJldHVybiBzZWxmLmNhY2hlLnB1dF8oeCwgbyk7XG4gICAgICB9KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICBFeGVjdXRlcyB0aGUgZmluZCBvbiB0aGUgY2FjaGUgZmlyc3QsIGFuZCBpZiBpdCBmYWlscyB0cmlnZ2VycyBhblxuICAgICAgdXBkYXRlIGZyb20gdGhlIGRlbGVnYXRlLlxuICAgICovXG4gICAgZnVuY3Rpb24gZmluZF8oeCwgaWQpIHtcbiAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgIC8vIFRPRE86IEV4cHJlc3MgdGhpcyBiZXR0ZXIuXG4gICAgICAvLyBBc3NpZ25pbmcgdG8gdW51c2VkIHZhcmlhYmxlIHRvIGtlZXAgQ2xvc3VyZSBoYXBweS5cbiAgICAgIHZhciBfID0gc2VsZi5jYWNoZVN5bmNfOyAvLyBlbnN1cmVzIGxpc3RlbmVycyBhcmUgc2V0XG4gICAgICAvLyBUT0RPOiBzdGFsZSB0aW1lb3V0IG9uIGZpbmQ/XG5cbiAgICAgIC8vIENoZWNrIHRoZSBpbi1mbGlnaHQgcmVtb3RlIGZpbmRzX1xuICAgICAgaWYgKCBzZWxmLmZpbmRzX1tpZF0gKSB7XG4gICAgICAgIC8vIEF0dGFjaCBteXNlbGYgaWYgdGhlcmUncyBvbmUgZm9yIHRoaXMgaWQsIHNpbmNlIHRoZSBjYWNoZSBtdXN0XG4gICAgICAgIC8vIGhhdmUgYWxyZWFkeSBmYWlsZWRcbiAgICAgICAgcmV0dXJuIHNlbGYuZmluZHNfW2lkXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFRyeSB0aGUgY2FjaGVcbiAgICAgICAgcmV0dXJuIHNlbGYuY2FjaGUuZmluZF8oeCwgaWQpLnRoZW4oXG5cbiAgICAgICAgICBmdW5jdGlvbiAodmFsKSB7XG4gICAgICAgICAgICAvLyBDYWNoZSBoaXQsIGJ1dCBjcmVhdGUgYmFja2dyb3VuZCByZXF1ZXN0IGlmIHJlcXVpcmVkXG4gICAgICAgICAgICBpZiAoIHZhbCApIHtcbiAgICAgICAgICAgICAgaWYgKCBzZWxmLnJlZnJlc2hPbkNhY2hlSGl0ICkge1xuICAgICAgICAgICAgICAgIC8vIERvbid0IHJlY29yZCBpbiBmaW5kc18sIHNpbmNlIHdlIGRvbid0IHdhbnQgYW55b25lIHdhaXRpbmcgZm9yIGl0XG4gICAgICAgICAgICAgICAgc2VsZi5kZWxlZ2F0ZS5maW5kXyh4LCBpZCkudGhlbihmdW5jdGlvbiAodmFsKSB7XG4gICAgICAgICAgICAgICAgICB2YWwgJiYgc2VsZi5jYWNoZS5wdXRfKHgsIHZhbCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIHZhbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEZhaWxlZCB0byBmaW5kIGluIGNhY2hlLCBzbyB0cnkgcmVtb3RlLlxuICAgICAgICAgICAgLy8gQW5vdGhlciByZXF1ZXN0IG1heSBoYXZlIGNvbWUgaW4gdGhlIG1lYW50aW1lLCBzbyBjaGVjayBhZ2FpbiBmb3JcbiAgICAgICAgICAgIC8vIGFuIGluLWZsaWdodCBmaW5kIGZvciB0aGlzIElELlxuICAgICAgICAgICAgaWYgKCAhIHNlbGYuZmluZHNfW2lkXSApIHtcbiAgICAgICAgICAgICAgc2VsZi5maW5kc19baWRdID0gc2VsZi5kZWxlZ2F0ZS5maW5kXyh4LCBpZCk7XG4gICAgICAgICAgICAgIC8vIHdlIGNyZWF0ZWQgdGhlIHJlbW90ZSByZXF1ZXN0LCBzbyBjbGVhbiB1cCBmaW5kc18gbGF0ZXJcbiAgICAgICAgICAgICAgdmFyIGVycm9ySGFuZGxlciA9IGZ1bmN0aW9uKGVycikge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBzZWxmLmZpbmRzX1tpZF07IC8vIGluIGVycm9yIGNhc2UsIHN0aWxsIGNsZWFuIHVwXG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgIHJldHVybiBzZWxmLmZpbmRzX1tpZF0udGhlbihmdW5jdGlvbiAodmFsKSB7XG4gICAgICAgICAgICAgICAgLy8gb25jZSB0aGUgY2FjaGUgaXMgdXBkYXRlZCwgcmVtb3ZlIHRoaXMgc3RhbGUgcHJvbWlzZVxuICAgICAgICAgICAgICAgIGlmICggISB2YWwgKSB7XG4gICAgICAgICAgICAgICAgICBkZWxldGUgc2VsZi5maW5kc19baWRdO1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHNlbGYuY2FjaGUucHV0Xyh4LCB2YWwpLnRoZW4oZnVuY3Rpb24odmFsKSB7XG4gICAgICAgICAgICAgICAgICBkZWxldGUgc2VsZi5maW5kc19baWRdO1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbDtcbiAgICAgICAgICAgICAgICB9LCBlcnJvckhhbmRsZXIpO1xuICAgICAgICAgICAgICB9LCBlcnJvckhhbmRsZXIpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgLy8gcGlnZ3liYWNrIG9uIGFuIGV4aXN0aW5nIHVwZGF0ZSByZXF1ZXN0LCBjbGVhbnVwIGFscmVhZHkgaGFuZGxlZFxuICAgICAgICAgICAgICByZXR1cm4gc2VsZi5maW5kc19baWRdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICBFeGVjdXRlcyB0aGUgc2VsZWN0IG9uIHRoZSBjYWNoZSBmaXJzdCwgYW5kIGlmIGl0IGZhaWxzIHRyaWdnZXJzIGFuXG4gICAgICB1cGRhdGUgZnJvbSB0aGUgZGVsZWdhdGUuXG4gICAgICA8cD5cbiAgICAgIElmIC5jYWNoZU9uU2VsZWN0IGlzIGZhbHNlLCB0aGUgc2VsZWN0KClcbiAgICAgIGJ5cGFzc2VzIHRoZSBjYWNoZSBhbmQgZ29lcyBkaXJlY3RseSB0byB0aGUgZGVsZWdhdGUuXG4gICAgKi9cbiAgICBmdW5jdGlvbiBzZWxlY3RfKHgsIHNpbmssIHNraXAsIGxpbWl0LCBvcmRlciwgcHJlZGljYXRlKSB7XG4gICAgICBpZiAoICEgdGhpcy5jYWNoZU9uU2VsZWN0ICkge1xuICAgICAgICByZXR1cm4gdGhpcy5TVVBFUih4LCBzaW5rLCBza2lwLCBsaW1pdCwgb3JkZXIsIHByZWRpY2F0ZSk7XG4gICAgICB9XG4gICAgICBzaW5rID0gc2luayB8fCB0aGlzLkFycmF5U2luay5jcmVhdGUoKTtcbiAgICAgIHZhciBrZXkgPSB0aGlzLnNlbGVjdEtleShzaW5rLCBza2lwLCBsaW1pdCwgb3JkZXIsIHByZWRpY2F0ZSk7XG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAvLyBBc3NpZ25pbmcgdG8gdW51c2VkIHZhcmlhYmxlIHRvIGtlZXAgQ2xvc3VyZSBoYXBweS5cbiAgICAgIC8vIFRPRE86IEV4cHJlc3MgdGhpcyBiZXR0ZXIuXG4gICAgICB2YXIgXyA9IHNlbGYuY2FjaGVTeW5jXzsgLy8gRW5zdXJlcyBsaXN0ZW5lcnMgYXJlIHNldC5cblxuICAgICAgLy8gQ2hlY2sgZm9yIG1pc3Npbmcgb3Igc3RhbGUgcmVtb3RlIHJlcXVlc3QuIElmIG5lZWRlZCwgaW1tZWRpYXRlbHlcbiAgICAgIC8vIHN0YXJ0IGEgbmV3IG9uZSB0aGF0IHdpbGwgdHJpZ2dlciBhIHJlc2V0IG9mIHRoaXMgd2hlbiBjb21wbGV0ZS5cbiAgICAgIC8vIFRPRE86IEVudHJpZXMgYXJlIHJldGFpbmVkIGZvciBldmVyeSBxdWVyeSwgbmV2ZXIgZGVsZXRlZC4gSXMgdGhhdCBvaz9cbiAgICAgIHZhciBlbnRyeSA9IHNlbGYuc2VsZWN0c19ba2V5XTtcbiAgICAgIGlmICggISBlbnRyeSB8fCAoIERhdGUubm93KCkgLSBlbnRyeS50aW1lICkgPiBzZWxmLnN0YWxlVGltZW91dCApIHtcbiAgICAgICAgc2VsZi5zZWxlY3RzX1trZXldID0gZW50cnkgPSB7XG4gICAgICAgICAgdGltZTogRGF0ZS5ub3coKSxcbiAgICAgICAgICBwcm9taXNlOlxuICAgICAgICAgICAgc2VsZi5kZWxlZ2F0ZS5zZWxlY3RfKHgsIHNlbGYuREFPU2luay5jcmVhdGUoeyBkYW86IHNlbGYuY2FjaGUgfSksIHNraXAsIGxpbWl0LCBvcmRlciwgcHJlZGljYXRlKVxuICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbihjYWNoZSkge1xuICAgICAgICAgICAgICAgIHNlbGYub25DYWNoZVVwZGF0ZSgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBjYWNoZTtcbiAgICAgICAgICAgICAgfSlcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gcmVhZEZyb21DYWNoZSgpIHtcbiAgICAgICAgcmV0dXJuIHNlbGYuY2FjaGUuc2VsZWN0Xyh4LCBzaW5rLCBza2lwLCBsaW1pdCwgb3JkZXIsIHByZWRpY2F0ZSk7XG4gICAgICB9XG5cbiAgICAgIC8vIElmIGFueXRoaW5nIGV4aXN0cyBpbiB0aGUgY2FjaGUgZm9yIHRoaXMgcXVlcnksIHJldHVybiBpdCAodXBkYXRlc1xuICAgICAgLy8gbWF5IGFycml2ZSBsYXRlciBhbmQgdHJpZ2dlciBhIHJlc2V0IG5vdGlmaWNhdGlvbikuIElmIG5vdGhpbmcsXG4gICAgICAvLyB3YWl0IG9uIHRoZSBwZW5kaW5nIGNhY2hlIHVwZGF0ZS5cbiAgICAgIHJldHVybiBzZWxmLmNhY2hlLnNlbGVjdF8oXG4gICAgICAgICAgeCwgdGhpcy5BbnlTaW5rLmNyZWF0ZSgpLCBza2lwLCAxLCBvcmRlciwgcHJlZGljYXRlKVxuICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbihoYXNBbnkpIHtcbiAgICAgICAgICAgICAgICBpZiAoIGhhc0FueS5oYXNBbnkgKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gcmVhZEZyb21DYWNoZSgpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gZW50cnkucHJvbWlzZS50aGVuKHJlYWRGcm9tQ2FjaGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSk7XG4gICAgfVxuICBdLFxuXG4gIGxpc3RlbmVyczogW1xuICAgIHtcbiAgICAgIC8qIHJlcGxhY2VzIHNlbGYucHViKCdvbicsICdyZXNldCcpIGluIHNlbGVjdCBwcm9taXNlIHNlbGVjdFxuICAgICAgICAgd2hpY2ggd2FzIHRyaWdnZXJpbmcgcmVwZWF0ZWQvY3ljbGljIG9uREFPVXBkYXRlIGluIGNhbGxlciAqL1xuICAgICAgbmFtZTogJ29uQ2FjaGVVcGRhdGUnLFxuICAgICAgaXNNZXJnZWQ6IHRydWUsXG4gICAgICBjb2RlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5wdWIoJ29uJywgJ3Jlc2V0Jyk7XG4gICAgICB9XG4gICAgfVxuICBdXG59KTtcbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbi8qKlxuICBDYWNoaW5nREFPIHdpbGwgZG8gYWxsIHF1ZXJpZXMgZnJvbSBpdHMgZmFzdCBjYWNoZS4gV3JpdGVzXG4gIGFyZSBzZW50IHRocm91Z2ggdG8gdGhlIHNyYyBhbmQgY2FjaGVkIGJlZm9yZSByZXNvbHZpbmcgYW55IHB1dCgpIG9yXG4gIHJlbW92ZSgpLlxuICA8cD5cbiAgWW91IGNhbiB1c2UgYSBmb2FtLmRhby5FYXN5REFPIHdpdGggY2FjaGluZzp0cnVlIHRvIHVzZSBjYWNoaW5nXG4gIGF1dG9tYXRpY2FsbHkgd2l0aCBhbiBpbmRleGVkIE1EQU8gY2FjaGUuXG4gIDxwPlxuICBUaGUgY2FjaGUgbWFpbnRhaW5zIGZ1bGwgY29weSBvZiB0aGUgc3JjLCBidXQgdGhlIHNyYyBpcyBjb25zaWRlcmVkIHRoZVxuICBzb3VyY2Ugb2YgdHJ1dGguXG4qL1xuZm9hbS5DTEFTUyh7XG4gIHBhY2thZ2U6ICdmb2FtLmRhbycsXG4gIG5hbWU6ICdDYWNoaW5nREFPJyxcbiAgZXh0ZW5kczogJ2ZvYW0uZGFvLlByb3h5REFPJyxcblxuICByZXF1aXJlczogW1xuICAgICdmb2FtLmRhby5EQU9TaW5rJyxcbiAgICAnZm9hbS5kYW8uUHJvbWlzZWREQU8nLFxuICAgICdmb2FtLmRhby5RdWlja1NpbmsnLFxuICBdLFxuXG4gIHByb3BlcnRpZXM6IFtcbiAgICB7XG4gICAgICAvKiogVGhlIHNvdXJjZSBEQU8gb24gd2hpY2ggdG8gYWRkIGNhY2hpbmcuIFdyaXRlcyBnbyBzdHJhaWdodFxuICAgICAgICB0byB0aGUgc3JjLCBhbmQgY2FjaGUgaXMgdXBkYXRlZCB0byBtYXRjaC5cbiAgICAgICovXG4gICAgICBjbGFzczogJ2ZvYW0uZGFvLkRBT1Byb3BlcnR5JyxcbiAgICAgIG5hbWU6ICdzcmMnXG4gICAgfSxcbiAgICB7XG4gICAgICAvKiogVGhlIGNhY2hlIHRvIHJlYWQgaXRlbXMgcXVpY2tseS4gQ2FjaGUgY29udGFpbnMgYSBjb21wbGV0ZVxuICAgICAgICBjb3B5IG9mIHNyYy4gKi9cbiAgICAgIG5hbWU6ICdjYWNoZScsXG4gICAgfSxcbiAgICB7XG4gICAgICAvKipcbiAgICAgICAgU2V0IC5jYWNoZSByYXRoZXIgdGhhbiB1c2luZyBkZWxlZ2F0ZSBkaXJlY3RseS5cbiAgICAgICAgUmVhZCBvcGVyYXRpb25zIGFuZCBub3RpZmljYXRpb25zIGdvIHRvIHRoZSBjYWNoZSwgd2FpdGluZ1xuICAgICAgICBmb3IgdGhlIGNhY2hlIHRvIHByZWxvYWQgdGhlIGNvbXBsZXRlIHNyYyBzdGF0ZS4gJ1VuZm9yd2FyZCdcbiAgICAgICAgUHJveHlEQU8ncyBkZWZhdWx0IGZvcndhcmRpbmcgb2YgcHV0L3JlbW92ZS9yZW1vdmVBbGwuXG4gICAgICAgIEBwcml2YXRlXG4gICAgICAqL1xuICAgICAgY2xhc3M6ICdQcm94eScsXG4gICAgICBvZjogJ2ZvYW0uZGFvLkRBTycsXG4gICAgICBuYW1lOiAnZGVsZWdhdGUnLFxuICAgICAgaGlkZGVuOiB0cnVlLFxuICAgICAgdG9waWNzOiBbICdvbicgXSxcbiAgICAgIGZvcndhcmRzOiBbICdmaW5kXycsICdzZWxlY3RfJyBdLFxuICAgICAgZXhwcmVzc2lvbjogZnVuY3Rpb24oc3JjLCBjYWNoZSkge1xuICAgICAgICAvLyBQcmVsb2FkIHNyYyBpbnRvIGNhY2hlLCB0aGVuIHByb3h5IGV2ZXJ5dGhpbmcgdG8gY2FjaGUgdGhhdCB3ZVxuICAgICAgICAvLyBkb24ndCBvdmVycmlkZSBleHBsaWNpdGx5LlxuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIHZhciBjYWNoZUZpbGxlZCA9IGNhY2hlLnJlbW92ZUFsbCgpLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgLy8gRmlyc3QgY2xlYXIgY2FjaGUsIHRoZW4gbG9hZCB0aGUgc3JjIGludG8gdGhlIGNhY2hlXG4gICAgICAgICAgcmV0dXJuIHNyYy5zZWxlY3Qoc2VsZi5EQU9TaW5rLmNyZWF0ZSh7ZGFvOiBjYWNoZX0pKS50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIGNhY2hlO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgLy8gVGhlIFByb21pc2VkREFPIHJlc29sdmVzIGFzIG91ciBkZWxlZ2F0ZSB3aGVuIHRoZSBjYWNoZSBpcyByZWFkeSB0byB1c2VcbiAgICAgICAgcmV0dXJuIHRoaXMuUHJvbWlzZWREQU8uY3JlYXRlKHtcbiAgICAgICAgICBwcm9taXNlOiBjYWNoZUZpbGxlZFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9LFxuICBdLFxuXG4gIG1ldGhvZHM6IFtcbiAgICBmdW5jdGlvbiBpbml0KCkge1xuICAgICAgdGhpcy5TVVBFUigpO1xuXG4gICAgICB2YXIgcHJveHkgPSB0aGlzLnNyYyRwcm94eTtcbiAgICAgIHByb3h5Lmxpc3Rlbih0aGlzLlF1aWNrU2luay5jcmVhdGUoe1xuICAgICAgICBwdXRGbjogdGhpcy5vblNyY1B1dCxcbiAgICAgICAgcmVtb3ZlRm46IHRoaXMub25TcmNSZW1vdmUsXG4gICAgICAgIHJlc2V0Rm46IHRoaXMub25TcmNSZXNldCxcbiAgICAgIH0pKTtcbiAgICB9LFxuXG4gICAgLyoqIFB1dHMgYXJlIHNlbnQgdG8gdGhlIGNhY2hlIGFuZCB0byB0aGUgc291cmNlLCBlbnN1cmluZyBib3RoXG4gICAgICBhcmUgdXAgdG8gZGF0ZS4gKi9cbiAgICBmdW5jdGlvbiBwdXRfKHgsIG8pIHtcbiAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgIC8vIGVuc3VyZSB0aGUgcmV0dXJuZWQgb2JqZWN0IGZyb20gc3JjIGlzIGNhY2hlZC5cbiAgICAgIHJldHVybiBzZWxmLnNyYy5wdXQobykudGhlbihmdW5jdGlvbihzcmNPYmopIHtcbiAgICAgICAgcmV0dXJuIHNlbGYuZGVsZWdhdGUucHV0Xyh4LCBzcmNPYmopO1xuICAgICAgfSlcbiAgICB9LFxuXG4gICAgLyoqIFJlbW92ZXMgYXJlIHNlbnQgdG8gdGhlIGNhY2hlIGFuZCB0byB0aGUgc291cmNlLCBlbnN1cmluZyBib3RoXG4gICAgICBhcmUgdXAgdG8gZGF0ZS4gKi9cbiAgICBmdW5jdGlvbiByZW1vdmVfKHgsIG8pIHtcbiAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgIHJldHVybiBzZWxmLnNyYy5yZW1vdmUobykudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHNlbGYuZGVsZWdhdGUucmVtb3ZlXyh4LCBvKTtcbiAgICAgIH0pXG4gICAgfSxcbiAgIC8qKiByZW1vdmVBbGwgaXMgZXhlY3V0ZWQgb24gdGhlIGNhY2hlIGFuZCB0aGUgc291cmNlLCBlbnN1cmluZyBib3RoXG4gICAgICBhcmUgdXAgdG8gZGF0ZS4gKi9cbiAgICBmdW5jdGlvbiByZW1vdmVBbGxfKHgsIHNraXAsIGxpbWl0LCBvcmRlciwgcHJlZGljYXRlKSB7XG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICByZXR1cm4gc2VsZi5zcmMucmVtb3ZlQWxsXyh4LCBza2lwLCBsaW1pdCwgb3JkZXIsIHByZWRpY2F0ZSkudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHNlbGYuZGVsZWdhdGUucmVtb3ZlQWxsXyh4LCBza2lwLCBsaW1pdCwgb3JkZXIsIHByZWRpY2F0ZSk7XG4gICAgICB9KVxuICAgIH1cbiAgXSxcblxuICBsaXN0ZW5lcnM6IFtcbiAgICAvKiogS2VlcHMgdGhlIGNhY2hlIGluIHN5bmMgd2l0aCBjaGFuZ2VzIGZyb20gdGhlIHNvdXJjZS5cbiAgICAgIEBwcml2YXRlICovXG4gICAgZnVuY3Rpb24gb25TcmNQdXQob2JqKSB7XG4gICAgICB0aGlzLmRlbGVnYXRlLnB1dChvYmopO1xuICAgIH0sXG5cbiAgICAvKiogS2VlcHMgdGhlIGNhY2hlIGluIHN5bmMgd2l0aCBjaGFuZ2VzIGZyb20gdGhlIHNvdXJjZS5cbiAgICAgIEBwcml2YXRlICovXG4gICAgZnVuY3Rpb24gb25TcmNSZW1vdmUob2JqKSB7XG4gICAgICB0aGlzLmRlbGVnYXRlLnJlbW92ZShvYmopO1xuICAgIH0sXG5cbiAgICAvKiogS2VlcHMgdGhlIGNhY2hlIGluIHN5bmMgd2l0aCBjaGFuZ2VzIGZyb20gdGhlIHNvdXJjZS5cbiAgICAgIEBwcml2YXRlICovXG4gICAgZnVuY3Rpb24gb25TcmNSZXNldCgpIHtcbiAgICAgIC8vIFRPRE86IFNob3VsZCB0aGlzIHJlbW92ZUFsbCBmcm9tIHRoZSBjYWNoZT9cbiAgICB9XG4gIF1cbn0pO1xuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTUgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuZm9hbS5DTEFTUyh7XG4gIHBhY2thZ2U6ICdmb2FtLmRhbycsXG4gIG5hbWU6ICdEZUR1cERBTycsXG4gIGV4dGVuZHM6ICdmb2FtLmRhby5Qcm94eURBTycsXG5cbiAgZG9jdW1lbnRhdGlvbjogZnVuY3Rpb24oKSB7LypcbiAgICBEZUR1cERBTyBpcyBhIGRlY29yYXRvciB0aGF0IGludGVybmFsaXplcyBzdHJpbmdzIGluIHB1dCgpIG9iamVjdHMgdG8gc2F2ZSBtZW1vcnkuXG4gICAgVXNlZnVsIGZvciBpbmRleGVkIG9yIGNhY2hlZCBkYXRhLlxuICAgIDxwPlxuICAgIFVzZSBhIGZvYW0uZGFvLkVhc3lEQU8gd2l0aCBkZWR1cDp0cnVlIHRvIGF1dG9tYXRpY2FsbHkgYXBwbHkgZGVkdXBsaWNhdGlvbi5cbiAgKi99LFxuXG4gIG1ldGhvZHM6IFtcbiAgICAvKiogU2NhbiBlYWNoIG9iamVjdCBmb3Igc3RyaW5ncyBhbmQgaW50ZXJuYWxpemUgdGhlbS4gKi9cbiAgICBmdW5jdGlvbiBwdXRfKHgsIG9iaikge1xuICAgICAgdGhpcy5kZWR1cChvYmopO1xuICAgICAgcmV0dXJuIHRoaXMuZGVsZWdhdGUucHV0Xyh4LCBvYmopO1xuICAgIH0sXG5cbiAgICAvKiogSW50ZXJuYWxpemVzIHN0cmluZ3MgaW4gdGhlIGdpdmVuIG9iamVjdC5cbiAgICAgIEBwcml2YXRlICovXG4gICAgZnVuY3Rpb24gZGVkdXAob2JqKSB7XG4gICAgICB2YXIgaW5zdCA9IG9iai5pbnN0YW5jZV87XG4gICAgICBmb3IgKCB2YXIga2V5IGluIGluc3QgKSB7XG4gICAgICAgIHZhciB2YWwgPSBpbnN0W2tleV07XG4gICAgICAgIGlmICggdHlwZW9mIHZhbCA9PT0gJ3N0cmluZycgKSB7XG4gICAgICAgICAgaW5zdFtrZXldID0gZm9hbS5TdHJpbmcuaW50ZXJuKHZhbCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIF1cbn0pO1xuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTUgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuZm9hbS5DTEFTUyh7XG4gIHBhY2thZ2U6ICdmb2FtLmRhbycsXG4gIG5hbWU6ICdMUlVEQU9NYW5hZ2VyJyxcbiAgaW1wbGVtZW50czogWyAnZm9hbS5tbGFuZy5FeHByZXNzaW9ucycgXSxcblxuICBkb2N1bWVudGF0aW9uOiAnTWFuYWdlcyBhIERBT1xcJ3Mgc2l6ZSBieSByZW1vdmluZyBvbGQgaXRlbXMuIENvbW1vbmx5IGFwcGxpZWQgaW5zaWRlIGEgY2FjaGUgdG8gbGltaXQgdGhlIGNhY2hlXFwncyBzaXplLiBJdGVtIGZyZXNobmVzcyBpcyB0cmFja2VkIGluIGEgc2VwYXJhdGUgREFPLicsXG5cbiAgcmVxdWlyZXM6IFsgJ2ZvYW0uZGFvLk1EQU8nIF0sXG5cbiAgY2xhc3NlczogW1xuICAgIHtcbiAgICAgIC8qKiBMaW5rcyBhbiBvYmplY3QgaWQgdG8gYSBsYXN0LWFjY2Vzc2VkIHRpbWVzdGFtcCAqL1xuICAgICAgbmFtZTogJ0xSVUNhY2hlSXRlbScsXG4gICAgICBwcm9wZXJ0aWVzOiBbXG4gICAgICAgIHtcbiAgICAgICAgICBuYW1lOiAnaWQnLFxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgY2xhc3M6ICdJbnQnLFxuICAgICAgICAgIG5hbWU6ICd0aW1lc3RhbXAnXG4gICAgICAgIH1cbiAgICAgIF1cbiAgICB9XG4gIF0sXG5cbiAgcHJvcGVydGllczogW1xuICAgIHtcbiAgICAgIC8qKiBUaGUgbWF4aW11bSBzaXplIHRvIGFsbG93IHRoZSB0YXJnZXQgZGFvIHRvIGJlLiAqL1xuICAgICAgY2xhc3M6ICdJbnQnLFxuICAgICAgbmFtZTogJ21heFNpemUnLFxuICAgICAgdmFsdWU6IDEwMFxuICAgIH0sXG4gICAge1xuICAgICAgLyoqIFRyYWNrcyB0aGUgYWdlIG9mIGl0ZW1zIGluIHRoZSB0YXJnZXQgZGFvLiAqL1xuICAgICAgbmFtZTogJ3RyYWNraW5nREFPJyxcbiAgICAgIGZhY3Rvcnk6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5NREFPLmNyZWF0ZSh7IG9mOiB0aGlzLkxSVUNhY2hlSXRlbSB9KTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHtcbiAgICAgIC8qKiBUaGUgREFPIHRvIG1hbmFnZS4gSXRlbXMgd2lsbCBiZSByZW1vdmVkIGZyb20gdGhpcyBEQU8gYXMgbmVlZGVkLiAqL1xuICAgICAgY2xhc3M6ICdmb2FtLmRhby5EQU9Qcm9wZXJ0eScsXG4gICAgICBuYW1lOiAnZGFvJ1xuICAgIH0sXG4gICAge1xuICAgICAgLyoqIEJ5IHN0YXJ0aW5nIGF0IHRoZSBjdXJyZW50IHRpbWUsIHRoaXMgc2hvdWxkIGFsd2F5cyBiZSBoaWdoZXJcbiAgICAgICAgdGhhbiBwcmV2aW91c2x5IHN0b3JlZCB0aW1lc3RhbXBzLiAob25seSByZWxldmFudCBpZiB0cmFja2luZ0RBT1xuICAgICAgICBpcyBwZXJzaXN0ZWQuKSAqL1xuICAgICAgY2xhc3M6ICdJbnQnLFxuICAgICAgbmFtZTogJ2xhc3RUaW1lVXNlZF8nLFxuICAgICAgZmFjdG9yeTogZnVuY3Rpb24oKSB7IHJldHVybiBEYXRlLm5vdygpOyB9XG4gICAgfVxuICBdLFxuXG4gIG1ldGhvZHM6IFtcbiAgICBmdW5jdGlvbiBpbml0KCkge1xuICAgICAgdGhpcy5TVVBFUigpO1xuXG4gICAgICB2YXIgcHJveHkgPSB0aGlzLmRhbyRwcm94eTtcbiAgICAgIHByb3h5LnN1Yignb24nLCAncHV0JywgICAgdGhpcy5vblB1dCk7XG4gICAgICBwcm94eS5zdWIoJ29uJywgJ3JlbW92ZScsIHRoaXMub25SZW1vdmUpO1xuICAgICAgcHJveHkuc3ViKCdvbicsICdyZXNldCcsICB0aGlzLm9uUmVzZXQpO1xuICAgIH0sXG5cbiAgICAvKiogQ2FsY3VsYXRlcyBhIHRpbWVzdGFtcCB0byB1c2UgaW4gdGhlIHRyYWNraW5nIGRhby4gT3ZlcnJpZGUgdG9cbiAgICAgIHByb3ZpZGUgYSBkaWZmZXJlbnQgdGltZXN0YW1wIGNhbHVsYXRpb24uICovXG4gICAgZnVuY3Rpb24gZ2V0VGltZXN0YW1wKCkge1xuICAgICAgLy8gSnVzdCBpbmNyZW1lbnQgb24gZWFjaCByZXF1ZXN0LlxuICAgICAgcmV0dXJuIHRoaXMubGFzdFRpbWVVc2VkXysrO1xuICAgIH0sXG5cbiAgICBmdW5jdGlvbiBjbGVhbnVwKCkge1xuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgc2VsZi50cmFja2luZ0RBT1xuICAgICAgICAub3JkZXJCeSh0aGlzLkRFU0Moc2VsZi5MUlVDYWNoZUl0ZW0uVElNRVNUQU1QKSlcbiAgICAgICAgLnNraXAoc2VsZi5tYXhTaXplKVxuICAgICAgICAuc2VsZWN0KHtcbiAgICAgICAgICBwdXQ6IGZ1bmN0aW9uKG9iaikge1xuICAgICAgICAgICAgc2VsZi5kYW8ucmVtb3ZlKG9iaik7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gIF0sXG5cbiAgbGlzdGVuZXJzOiBbXG4gICAgLyoqIEFkZHMgdGhlIHB1dCgpIGl0ZW0gdG8gdGhlIHRyYWNraW5nIGRhbywgcnVucyBjbGVhbnVwKCkgdG8gY2hlY2tcbiAgICAgIHRoZSBkYW8gc2l6ZS4gKi9cbiAgICBmdW5jdGlvbiBvblB1dChzLCBvbiwgcHV0LCBvYmopIHtcbiAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgIHRoaXMudHJhY2tpbmdEQU8ucHV0KFxuICAgICAgICB0aGlzLkxSVUNhY2hlSXRlbS5jcmVhdGUoe1xuICAgICAgICAgIGlkOiBvYmouaWQsXG4gICAgICAgICAgdGltZXN0YW1wOiBzZWxmLmdldFRpbWVzdGFtcCgpXG4gICAgICAgIH0pXG4gICAgICApLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgIHNlbGYuY2xlYW51cCgpO1xuICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8qKiBDbGVhcnMgdGhlIHJlbW92ZSgpJ2QgaXRlbSBmcm9tIHRoZSB0cmFja2luZyBkYW8uICovXG4gICAgZnVuY3Rpb24gb25SZW1vdmUocywgb24sIHJlbW92ZSwgb2JqKSB7XG4gICAgICAvLyBlbnN1cmUgdHJhY2tpbmcgREFPIGlzIGNsZWFuZWQgdXBcbiAgICAgIHRoaXMudHJhY2tpbmdEQU8ucmVtb3ZlKG9iaik7XG4gICAgfSxcblxuICAgIC8qKiBPbiByZXNldCwgY2xlYXIgdGhlIHRyYWNraW5nIGRhby4gKi9cbiAgICBmdW5jdGlvbiBvblJlc2V0KHMsIG9uLCByZXNldCwgb2JqKSB7XG4gICAgICB0aGlzLnRyYWNraW5nREFPLnJlbW92ZUFsbChvYmopO1xuICAgIH1cbiAgXVxufSk7XG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNCBUaGUgRk9BTSBBdXRob3JzLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKi9cblxuZm9hbS5DTEFTUyh7XG4gIHBhY2thZ2U6ICdmb2FtLmRhbycsXG4gIG5hbWU6ICdTZXF1ZW5jZU51bWJlckRBTycsXG4gIGV4dGVuZHM6ICdmb2FtLmRhby5Qcm94eURBTycsXG5cbiAgaW1wbGVtZW50czogW1xuICAgICdmb2FtLm1sYW5nLkV4cHJlc3Npb25zJ1xuICBdLFxuXG4gIHJlcXVpcmVzOiBbXG4gICAgJ2ZvYW0uZGFvLkludGVybmFsRXhjZXB0aW9uJ1xuICBdLFxuXG4gIGRvY3VtZW50YXRpb246ICdEQU8gRGVjb3JhdG9yIHdoaWNoIHNldHMgYSBzcGVjaWZpZWQgcHJvcGVydHlcXCdzIHZhbHVlIHdpdGggYW4gYXV0by1pbmNyZW1lbnQgc2VxdWVuY2UgbnVtYmVyIG9uIERBTy5wdXQoKSBpZiB0aGUgdmFsdWUgaXMgc2V0IHRvIHRoZSBkZWZhdWx0IHZhbHVlLicsXG5cbiAgcHJvcGVydGllczogW1xuICAgIHtcbiAgICAgIC8qKiBUaGUgcHJvcGVydHkgdG8gc2V0IHVuaXF1ZWx5LiAqL1xuICAgICAgY2xhc3M6ICdTdHJpbmcnLFxuICAgICAgbmFtZTogJ3Byb3BlcnR5JyxcbiAgICAgIHZhbHVlOiAnaWQnXG4gICAgfSxcbiAgICB7XG4gICAgICBqYXZhVHlwZTogJ2ZvYW0uY29yZS5Qcm9wZXJ0eUluZm8nLFxuICAgICAgamF2YUluZm9UeXBlOiAnZm9hbS5jb3JlLkFic3RyYWN0T2JqZWN0UHJvcGVydHlJbmZvJyxcbiAgICAgIG5hbWU6ICdheGlvbScsXG4gICAgICBqYXZhRmFjdG9yeTogJ3JldHVybiAoZm9hbS5jb3JlLlByb3BlcnR5SW5mbykoZ2V0T2YoKS5nZXRBeGlvbUJ5TmFtZShnZXRQcm9wZXJ0eSgpKSk7J1xuICAgIH0sXG4gICAge1xuICAgICAgLyoqIFRoZSBzdGFydGluZyBzZXF1ZW5jZSB2YWx1ZS4gVGhpcyB3aWxsIGJlIGNhbGNsYXRlZCBmcm9tIHRoZVxuICAgICAgICBleGlzdGluZyBjb250ZW50cyBvZiB0aGUgZGVsZWdhdGUgREFPLCBzbyBpdCBpcyBvbmUgZ3JlYXRlclxuICAgICAgICB0aGFuIHRoZSBtYXhpbXVtIGV4aXN0aW5nIHZhbHVlLiAqL1xuICAgICAgY2xhc3M6ICdMb25nJyxcbiAgICAgIG5hbWU6ICd2YWx1ZScsXG4gICAgICB2YWx1ZTogMVxuICAgIH0sXG4gICAgeyAvKiogUmV0dXJucyBhIHByb21pc2UgdGhhdCBmdWxmaWxscyB3aGVuIHRoZSBtYXhpbXVtIGV4aXN0aW5nIG51bWJlclxuICAgICAgICAgIGhhcyBiZWVuIGZvdW5kIGFuZCBhc3NpZ25lZCB0byB0aGlzLnZhbHVlICovXG4gICAgICBuYW1lOiAnY2FsY0RlbGVnYXRlTWF4XycsXG4gICAgICBoaWRkZW46IHRydWUsXG4gICAgICBleHByZXNzaW9uOiBmdW5jdGlvbihkZWxlZ2F0ZSwgcHJvcGVydHkpIHtcbiAgICAgICAgLy8gVE9ETzogdmFsaWRhdGUgcHJvcGVydHkgc2VsZi5vZltzZWxmLnByb3BlcnR5LnRvVXBwZXJDYXNlKCldXG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgcmV0dXJuIHNlbGYuZGVsZWdhdGUuc2VsZWN0KCAvLyBUT0RPOiBtYWtlIGl0IGEgcGlwZT9cbiAgICAgICAgICBzZWxmLk1BWChzZWxmLnByb3BlcnR5XylcbiAgICAgICAgKS50aGVuKFxuICAgICAgICAgIGZ1bmN0aW9uKG1heCkge1xuICAgICAgICAgICAgaWYgKCBtYXgudmFsdWUgKSBzZWxmLnZhbHVlID0gbWF4LnZhbHVlICsgMTtcbiAgICAgICAgICB9XG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfSxcbiAgICB7XG4gICAgICAvKiogQHByaXZhdGUgKi9cbiAgICAgIG5hbWU6ICdwcm9wZXJ0eV8nLFxuICAgICAgaGlkZGVuOiB0cnVlLFxuICAgICAgZXhwcmVzc2lvbjogZnVuY3Rpb24ocHJvcGVydHksIG9mKSB7XG4gICAgICAgIHZhciBhID0gdGhpcy5vZi5nZXRBeGlvbUJ5TmFtZShwcm9wZXJ0eSk7XG4gICAgICAgIGlmICggISBhICkge1xuICAgICAgICAgIHRocm93IHRoaXMuSW50ZXJuYWxFeGNlcHRpb24uY3JlYXRlKHttZXNzYWdlOlxuICAgICAgICAgICAgICAnU2VxdWVuY2VOdW1iZXJEQU8gc3BlY2lmaWVkIHdpdGggaW52YWxpZCBwcm9wZXJ0eSAnICtcbiAgICAgICAgICAgICAgcHJvcGVydHkgKyAnIGZvciBjbGFzcyAnICsgdGhpcy5vZlxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhO1xuICAgICAgfVxuICAgIH1cbiAgXSxcblxuICBtZXRob2RzOiBbXG4gICAgLyoqIFNldHMgdGhlIHByb3BlcnR5IG9uIHRoZSBnaXZlbiBvYmplY3QgYW5kIGluY3JlbWVudHMgdGhlIG5leHQgdmFsdWUuXG4gICAgICBJZiB0aGUgdW5pcXVlIHN0YXJ0aW5nIHZhbHVlIGhhcyBub3QgZmluaXNoZWQgY2FsY3VsYXRpbmcsIHRoZSByZXR1cm5lZFxuICAgICAgcHJvbWlzZSB3aWxsIG5vdCByZXNvbHZlIHVudGlsIGl0IGlzIHJlYWR5LiAqL1xuICAgIHtcbiAgICAgIG5hbWU6ICdwdXRfJyxcbiAgICAgIGNvZGU6IGZ1bmN0aW9uIHB1dF8oeCwgb2JqKSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FsY0RlbGVnYXRlTWF4Xy50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGlmICggISBvYmouaGFzT3duUHJvcGVydHkoc2VsZi5wcm9wZXJ0eV8ubmFtZSkgKSB7XG4gICAgICAgICAgICBvYmpbc2VsZi5wcm9wZXJ0eV8ubmFtZV0gPSBzZWxmLnZhbHVlKys7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHNlbGYuZGVsZWdhdGUucHV0Xyh4LCBvYmopO1xuICAgICAgICB9KTtcbiAgICAgIH0sXG4gICAgICBqYXZhQ29kZTogYFxuc3luY2hyb25pemVkICh0aGlzKSB7XG4gIGlmICggISBpc1Byb3BlcnR5U2V0KFwidmFsdWVcIikgKSBjYWxjRGVsZWdhdGVNYXhfKCk7XG5cbiAgaWYgKCAhIGdldEF4aW9tKCkuaXNTZXQob2JqKSApIHtcbiAgICBnZXRBeGlvbSgpLnNldChvYmosIGdldFZhbHVlKCkpO1xuICAgIHNldFZhbHVlKGdldFZhbHVlKCkgKyAxKTtcbiAgfVxufVxuXG5yZXR1cm4gZ2V0RGVsZWdhdGUoKS5wdXRfKHgsIG9iaik7XG4gICAgICBgLFxuICAgIH0sXG4gIF0sXG5cbiAgYXhpb21zOiBbXG4gICAge1xuICAgICAgYnVpbGRKYXZhQ2xhc3M6IGZ1bmN0aW9uKGNscykge1xuICAgICAgICBjbHMuZXh0cmFzLnB1c2goYFxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBuZXh0IGxhcmdlc3QgdmFsdWUgaW4gdGhlIHNlcXVlbmNlXG4gKi9cbnByaXZhdGUgdm9pZCBjYWxjRGVsZWdhdGVNYXhfKCkge1xuICBTaW5rIHNpbmsgPSBmb2FtLm1sYW5nLk1MYW5nLk1BWChnZXRBeGlvbSgpKTtcbiAgc2luayA9IGdldERlbGVnYXRlKCkuc2VsZWN0KHNpbmspO1xuICBzZXRWYWx1ZSgobG9uZykgKCAoIChmb2FtLm1sYW5nLnNpbmsuTWF4KSBzaW5rICkuZ2V0VmFsdWUoKSA9PSBudWxsID8gMSA6ICggKE51bWJlcikgKCAoZm9hbS5tbGFuZy5zaW5rLk1heCkgc2luayApLmdldFZhbHVlKCkgKS5sb25nVmFsdWUoKSArIDEuMCApKTtcbn1cblxucHVibGljIFNlcXVlbmNlTnVtYmVyREFPKGZvYW0uZGFvLkRBTyBkZWxlZ2F0ZSkge1xuICBTeXN0ZW0uZXJyLnByaW50bG4oXCJEaXJlY3QgY29uc3RydWN0b3IgdXNlIGlzIGRlcHJlY2F0ZWQuIFVzZSBCdWlsZGVyIGluc3RlYWQuXCIpO1xuICBzZXREZWxlZ2F0ZShkZWxlZ2F0ZSk7XG59XG4gICAgICAgIGApO1xuICAgICAgfSxcbiAgICB9LFxuICBdLFxufSk7XG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5mb2FtLkNMQVNTKHtcbiAgcGFja2FnZTogJ2ZvYW0uZGFvJyxcbiAgbmFtZTogJ0NvbnRleHR1YWxpemluZ0RBTycsXG4gIGV4dGVuZHM6ICdmb2FtLmRhby5Qcm94eURBTycsXG5cbiAgZG9jdW1lbnRhdGlvbjogZnVuY3Rpb24oKSB7LypcbiAgICBDb250ZXh0dWFsaXppbmdEQU8gcmVjcmVhdGVzIG9iamVjdHMgcmV0dXJuZWQgYnkgZmluZCgpLCBnaXZpbmcgdGhlbVxuICAgIGFjY2VzcyB0byB0aGUgZXhwb3J0cyB0aGF0IHRoaXMgQ29udGV4dHVhbGl6aW5nREFPIGhhcyBhY2Nlc3MgdG8uXG4gICAgPHA+XG4gICAgSWYgdXNpbmcgYSBmb2FtLmRhby5FYXN5REFPLCBzZXQgY29udGV4dHVhbGl6ZTp0cnVlIHRvIGF1dG9tYXRpY2FsbHlcbiAgICBjb250ZXh0dWFsaXplIG9iamVjdHMgcmV0dXJuZWQgYnkgZmluZCgpLlxuICAqL30sXG5cbiAgbWV0aG9kczogW1xuICAgIC8qKiBGb3VuZCBvYmplY3RzIGFyZSBjbG9uZWQgaW50byB0aGUgc2FtZSBjb250ZXh0IGFzIHRoaXMgREFPICovXG4gICAge1xuICAgICAgbmFtZTogJ2ZpbmRfJyxcbiAgICAgIGNvZGU6IGZ1bmN0aW9uKHgsIGlkKSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgcmV0dXJuIHNlbGYuZGVsZWdhdGUuZmluZF8oeCwgaWQpLnRoZW4oZnVuY3Rpb24ob2JqKSB7XG4gICAgICAgICAgaWYgKCBvYmogKSByZXR1cm4gb2JqLmNsb25lKHNlbGYpO1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9KTtcbiAgICAgIH0sXG4gICAgICBqYXZhQ29kZTogYGZvYW0uY29yZS5GT2JqZWN0IHJldCA9IHN1cGVyLmZpbmRfKHgsIGlkKTtcbmlmICggcmV0ICE9IG51bGwgKSByZXQuc2V0WCh4KTtcbnJldHVybiByZXQ7YFxuICAgIH1cbiAgXVxufSk7XG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBUaGUgRk9BTSBBdXRob3JzLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG4vLyBUT0RPKG1hcmtkaXR0bWVyKTogZm9hbS5kYW8uSW50ZXJuYWxFeGNlcHRpb24gc2hvdWxkIGJlIHVubmVjZXNzYXJ5IGhlcmU7XG4vLyBtYWtlIHRoaXMgYSBQcm9taXNlZERBTy5cbmZvYW0uQ0xBU1Moe1xuICBwYWNrYWdlOiAnZm9hbS5kYW8nLFxuICBuYW1lOiAnVmVyc2lvbk5vREFPJyxcbiAgZXh0ZW5kczogJ2ZvYW0uZGFvLlByb3h5REFPJyxcbiAgaW1wbGVtZW50czogWyAnZm9hbS5tbGFuZy5FeHByZXNzaW9ucycgXSxcblxuICBkb2N1bWVudGF0aW9uOiBgREFPIGRlY29yYXRvciB0aGF0IGFwcGxpZXMgYW4gaW5jcmVtZW50aW5nIHZlcnNpb24gbnVtYmVyXG4gICAgICB0byBhbGwgb2JqZWN0cyBwdXQoKSBhbmQgcmVtb3ZlKClkLiBJbnN0ZWFkIG9mIGRlbGV0aW5nIG9iamVjdHMgdGhhdFxuICAgICAgYXJlIHJlbW92ZSgpZCwgYSBwbGFjZWhvbGRlciB3aXRoIGEgZGVsZXRlZCBmbGFnIGlzIHB1dCgpIGluIGl0cyBwbGFjZS5cbiAgICAgIFRoaXMgYWxsb3dzIGZvYW0uZGFvLlN5bmNEQU8gY2xpZW50cyB0aGF0IGFyZSBwb2xsaW5nIGEgVmVyc2lvbk5vREFPIHRvXG4gICAgICByZWNpZXZlIGRlbGV0ZXMgZnJvbSBvdGhlciBjbGllbnRzLlxuXG4gICAgICBUaGlzIERBTyBleHBlY3RzIHRvIGJlIFwib2ZcIiBhIGNsYXNzIHRoYXQgaGFzIHRoZSB0cmFpdFxuICAgICAgZm9hbS52ZXJzaW9uLlZlcnNpb25UcmFpdC5cblxuICAgICAgTm90ZSB0aGF0IG1hcmtpbmcgcmVjb3JkcyBhcyBkZWxldGVkIHZpb2xhdGVzIGNlcnRhaW4gZXhwZWN0YWlvbnMgREFPXG4gICAgICBleHBlY3RhdGlvbnMuIEZvciBleGFtcGxlLCByZW1vdmluZyBhbiBvYmplY3QgYW5kIHRoZW4gZmluZGluZyBpdCB3aWxsIG5vdFxuICAgICAgeWllbGQgbnVsbCwgaXQgd2lsbCB5aWVsZCBhIHJlY29yZCBtYXJrZWQgYXMgZGVsZXRlZC5cblxuICAgICAgVGhpcyBEQU8gdGhyb3dzIGFuIEludGVybmFsRXhjZXB0aW9uIHdoZW4gd3JpdGVzIGFyZSBpc3N1ZWQgYmVmb3JlIGl0IGhhc1xuICAgICAgc3luY2hyb25pemVkIGl0cyBkZWxlZ2F0ZS4gVG8gZ2V0IGEgREFPIG9mIHRoaXMgY2xhc3MgdGhhdCBjYW4gYWNjZXB0XG4gICAgICB3cml0ZXMgaW1tZWRpYXRlbHksIGRlY29yYXRlIGl0IHdpdGggYSBTdG9yZUFuZEZvcndhcmREQU8uYCxcblxuICByZXF1aXJlczogW1xuICAgICdmb2FtLmRhby5JbnRlcm5hbEV4Y2VwdGlvbicsXG4gICAgJ2ZvYW0udmVyc2lvbi5WZXJzaW9uVHJhaXQnXG4gIF0sXG5cbiAgcHJvcGVydGllczogW1xuICAgIHtcbiAgICAgIG5hbWU6ICdvZicsXG4gICAgICByZXF1aXJlZDogdHJ1ZVxuICAgIH0sXG4gICAge1xuICAgICAgbmFtZTogJ2RlbGVnYXRlJyxcbiAgICAgIHJlcXVpcmVkOiB0cnVlLFxuICAgICAgZmluYWw6IHRydWVcbiAgICB9LFxuICAgIHtcbiAgICAgIGNsYXNzOiAnSW50JyxcbiAgICAgIG5hbWU6ICd2ZXJzaW9uJyxcbiAgICAgIHZhbHVlOiAxXG4gICAgfSxcbiAgICB7XG4gICAgICBjbGFzczogJ0Jvb2xlYW4nLFxuICAgICAgbmFtZTogJ3JlYWR5XydcbiAgICB9XG4gIF0sXG5cbiAgbWV0aG9kczogW1xuICAgIGZ1bmN0aW9uIGluaXQoKSB7XG4gICAgICB0aGlzLnZhbGlkYXRlKCk7XG4gICAgICB0aGlzLlNVUEVSKCk7XG5cbiAgICAgIC8vIEdldCBsYXJnZXN0IHZlcnNpb24gbnVtYmVyIGluIGRlbGVnYXRlJ3MgcmVjb3Jkcy5cbiAgICAgIHRoaXMuZGVsZWdhdGVcbiAgICAgICAgICAvLyBMaWtlIE1BWCgpLCBidXQgZmFzdGVyIG9uIERBT3MgdGhhdCBjYW4gb3B0aW1pemUgb3JkZXIrbGltaXQuXG4gICAgICAgICAgLm9yZGVyQnkodGhpcy5ERVNDKHRoaXMuVmVyc2lvblRyYWl0LlZFUlNJT05fKSkubGltaXQoMSlcbiAgICAgICAgICAuc2VsZWN0KCkudGhlbihmdW5jdGlvbihzaW5rKSB7XG4gICAgICAgICAgICB2YXIgcHJvcE5hbWUgPSB0aGlzLlZlcnNpb25UcmFpdC5WRVJTSU9OXy5uYW1lO1xuICAgICAgICAgICAgaWYgKCBzaW5rLmFycmF5WzBdICYmIHNpbmsuYXJyYXlbMF1bcHJvcE5hbWVdIClcbiAgICAgICAgICAgICAgdGhpcy52ZXJzaW9uID0gc2luay5hcnJheVswXVtwcm9wTmFtZV0gKyAxO1xuICAgICAgICAgICAgdGhpcy5yZWFkeV8gPSB0cnVlO1xuICAgICAgICAgIH0uYmluZCh0aGlzKSk7XG4gICAgfSxcbiAgICBmdW5jdGlvbiB2YWxpZGF0ZSgpIHtcbiAgICAgIHRoaXMuU1VQRVIoKTtcbiAgICAgIGlmICggISB0aGlzLlZlcnNpb25UcmFpdC5pc1N1YkNsYXNzKHRoaXMub2YpICkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFZlcnNpb25Ob0RBTy5vZiBtdXN0IGhhdmUgdHJhaXRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb2FtLnZlcnNpb24uVmVyc2lvblRyYWl0YCk7XG4gICAgICB9XG4gICAgfSxcbiAgICBmdW5jdGlvbiBwdXRfKHgsIG9iaikge1xuICAgICAgaWYgKCAhIHRoaXMucmVhZHlfIClcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KHRoaXMuSW50ZXJuYWxFeGNlcHRpb24uY3JlYXRlKCkpO1xuXG4gICAgICAvLyBJbmNyZW1lbnQgdmVyc2lvbiBudW1iZXIgYW5kIHB1dCB0byBkZWxlZ2F0ZS5cbiAgICAgIG9ialt0aGlzLlZlcnNpb25UcmFpdC5WRVJTSU9OXy5uYW1lXSA9IHRoaXMudmVyc2lvbjtcbiAgICAgIHRoaXMudmVyc2lvbisrO1xuICAgICAgcmV0dXJuIHRoaXMuZGVsZWdhdGUucHV0Xyh4LCBvYmopO1xuICAgIH0sXG4gICAgZnVuY3Rpb24gcmVtb3ZlXyh4LCBvYmopIHtcbiAgICAgIGlmICggISB0aGlzLnJlYWR5XyApXG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdCh0aGlzLkludGVybmFsRXhjZXB0aW9uLmNyZWF0ZSgpKTtcblxuICAgICAgLy8gSW5jcmVtZW50IHZlcnNpb24gbnVtYmVyIGFuZCBwdXQgZW1wdHkgb2JqZWN0IChleGNlcHQgZm9yIFwiaWRcIlxuICAgICAgLy8gYW5kIFwiZGVsZXRlZCA9IHRydWVcIikgdG8gZGVsZWdhdGUuXG4gICAgICB2YXIgZGVsZXRlZCA9IG9iai5jbG9uZSh4KTtcbiAgICAgIGRlbGV0ZWRbdGhpcy5WZXJzaW9uVHJhaXQuREVMRVRFRF8ubmFtZV0gPSB0cnVlO1xuICAgICAgZGVsZXRlZFt0aGlzLlZlcnNpb25UcmFpdC5WRVJTSU9OXy5uYW1lXSA9IHRoaXMudmVyc2lvbjtcbiAgICAgIHRoaXMudmVyc2lvbisrO1xuICAgICAgcmV0dXJuIHRoaXMuZGVsZWdhdGUucHV0Xyh4LCBkZWxldGVkKTtcbiAgICB9LFxuICAgIGZ1bmN0aW9uIHJlbW92ZUFsbF8oeCwgc2tpcCwgbGltaXQsIG9yZGVyLCBwcmVkaWNhdGUpIHtcbiAgICAgIGlmICggISB0aGlzLnJlYWR5XyApXG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdCh0aGlzLkludGVybmFsRXhjZXB0aW9uLmNyZWF0ZSgpKTtcblxuICAgICAgLy8gU2VsZWN0IHJlbGV2YW50IHJlY29yZHMgYW5kIG1hcmsgZWFjaCBhcyBkZWxldGVkIHZpYSByZW1vdmVfKCkuXG4gICAgICByZXR1cm4gdGhpcy5zZWxlY3RfKHgsIG51bGwsIHNraXAsIGxpbWl0LCBvcmRlciwgcHJlZGljYXRlKS5cbiAgICAgICAgICB0aGVuKGZ1bmN0aW9uKHNpbmspIHtcbiAgICAgICAgICAgIHZhciBhcnJheSA9IHNpbmsuYXJyYXk7XG4gICAgICAgICAgICB2YXIgcHJvbWlzZXMgPSBbXTtcbiAgICAgICAgICAgIGZvciAoIHZhciBpID0gMDsgaSA8IGFycmF5Lmxlbmd0aDsgaSsrICkge1xuICAgICAgICAgICAgICBwcm9taXNlcy5wdXNoKHRoaXMucmVtb3ZlXyh4LCBhcnJheVtpXSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UuYWxsKHByb21pc2VzKTtcbiAgICAgICAgICB9LmJpbmQodGhpcykpO1xuICAgIH1cbiAgXVxufSk7XG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBUaGUgRk9BTSBBdXRob3JzLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5mb2FtLkNMQVNTKHtcbiAgcGFja2FnZTogJ2ZvYW0uZGFvLnN5bmMnLFxuICBuYW1lOiAnU3luY1JlY29yZCcsXG5cbiAgZG9jdW1lbnRhdGlvbjogYFVzZWQgYnkgZm9hbS5kYW8uU3luY0RBTyB0byB0cmFjayBvYmplY3QgdXBkYXRlcyBhbmRcbiAgICAgIGRlbGV0aW9ucy5gLFxuXG4gIHByb3BlcnRpZXM6IFsgJ2lkJyBdXG59KTtcblxuLy8gRGVmaW5lIGZvYW0uZGFvLnN5bmMuVmVyc2lvbmVkU3luY1JlY29yZC5cbmZvYW0ubG9va3VwKCdmb2FtLnZlcnNpb24uVmVyc2lvbmVkQ2xhc3NGYWN0b3J5U2luZ2xldG9uJykuY3JlYXRlKCkuZ2V0KFxuICAgIGZvYW0ubG9va3VwKCdmb2FtLmRhby5zeW5jLlN5bmNSZWNvcmQnKSk7XG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5mb2FtLkNMQVNTKHtcbiAgcGFja2FnZTogJ2ZvYW0uZGFvJyxcbiAgbmFtZTogJ1N5bmNEQU8nLFxuICBleHRlbmRzOiAnZm9hbS5kYW8uUHJveHlEQU8nLFxuXG4gIGRvY3VtZW50YXRpb246IGBTeW5jREFPIHN5bmNocm9uaXplcyBkYXRhIGJldHdlZW4gbXVsdGlwbGUgY2xpZW50cycgb2ZmbGluZVxuICAgICAgY2FjaGVzIGFuZCBhIHNlcnZlci4gV2hlbiBzeW5jcm9uaXppbmcsIGVhY2ggY2xpZW50IHRyYWNrcyB0aGUgbGFzdC1zZWVuXG4gICAgICB2ZXJzaW9uIG9mIGVhY2ggb2JqZWN0LCBvciBpZiB0aGUgb2JqZWN0IHdhcyBkZWxldGVkLiBUaGUgbW9zdCByZWNlbnRcbiAgICAgIHZlcnNpb24gaXMgcmV0YWluZWQuXG5cbiAgICAgIE9iamVjdHMgcHV0IHRvIHRoaXMgREFPIG11c3QgYmUgc3ViY2xhc3NlcyBvZiBmb2FtLnZlcnNpb24uVmVyc2lvblRyYWl0LlxuICAgICAgVGhlIFwidmVyc2lvbl9cIiBwcm9wZXJ0eSB3aWxsIGJlIGF1dG9tYXRpY2FsbHkgYmUgaW5jcmVtZW50ZWQgYXMgY2hhbmdlc1xuICAgICAgYXJlIHB1dCgpIGludG8gdGhlIFN5bmNEQU8uIFRoZSBTeW5jREFPIHdpbGwgZXhwZWN0IHRvIGZpbmQgb2JqZWN0cyBpblxuICAgICAgcmVtb3RlREFPIHRoYXQgaGF2ZSBiZWVuIG1hcmtlZCBhcyBkZWxldGVkOyB0aGlzIGlzIGludGVycHJldGVkIGFzIGFcbiAgICAgIHNpZ25hbCB0byBkZWxldGUgcmVjb3JkcyAoZHVyaW5nIGluaXRpYWwgc3luYyBvciBwb2xsaW5nKS4gRGV0YWlscyBvblxuICAgICAgdmVyc2lvbmVkIGNsYXNzIGdlbmVyYXRpb24sIGFuZCB0aGUgXCJ2ZXJzaW9uX1wiIGFuZCBcImRlbGV0ZWRfXCIgcHJvcGVydGllc1xuICAgICAgYXJlIGluIHRoZSBmb2FtLnZlcnNpb24gcGFja2FnZS5cblxuICAgICAgUmVtb3RlIERBT3MgdGhhdCBpbnRlcmFjdCB3aXRoIFN5bmNEQU8gY2xpZW50cyBzaG91bGQgYmUgZGVjb3JhdGVkIHdpdGhcbiAgICAgIGZvYW0uZGFvLlZlcnNpb25Ob0RBTywgb3Igc2ltaWxhciwgdG8gcHJvdmlzaW9uIG5ldyB2ZXJzaW9uIG51bWJlcnMgZm9yXG4gICAgICByZWNvcmRzIGJlaW5nIHN0b3JlZC5gLFxuXG4gIHJlcXVpcmVzOiBbXG4gICAgJ2ZvYW0uZGFvLkFycmF5U2luaycsXG4gICAgJ2ZvYW0uZGFvLnN5bmMuVmVyc2lvbmVkU3luY1JlY29yZCcsXG4gICAgJ2ZvYW0udmVyc2lvbi5WZXJzaW9uVHJhaXQnXG4gIF0sXG5cbiAgaW1wbGVtZW50czogWyAnZm9hbS5tbGFuZy5FeHByZXNzaW9ucycgXSxcblxuICBpbXBvcnRzOiBbICdzZXRJbnRlcnZhbCcgXSxcblxuICBjbGFzc2VzOiBbXG4gICAge1xuICAgICAgbmFtZTogJ0FkYXB0ZXJTaW5rJyxcbiAgICAgIGV4dGVuZHM6ICdmb2FtLmRhby5Qcm94eVNpbmsnLFxuXG4gICAgICBwcm9wZXJ0aWVzOiBbXG4gICAgICAgIHtcbiAgICAgICAgICBjbGFzczogJ0NsYXNzJyxcbiAgICAgICAgICBuYW1lOiAnb2YnXG4gICAgICAgIH1cbiAgICAgIF0sXG5cbiAgICAgIG1ldGhvZHM6IFtcbiAgICAgICAgZnVuY3Rpb24gcHV0KG8sIHN1Yikge1xuICAgICAgICAgIHRoaXMuZGVsZWdhdGUucHV0KHRoaXMub2YuY3JlYXRlKG8sIHRoaXMuX19zdWJDb250ZXh0X18pLCBzdWIpO1xuICAgICAgICB9XG4gICAgICBdXG4gICAgfVxuICBdLFxuXG4gIHByb3BlcnRpZXM6IFtcbiAgICB7XG4gICAgICBjbGFzczogJ2ZvYW0uZGFvLkRBT1Byb3BlcnR5JyxcbiAgICAgIG5hbWU6ICdyZW1vdGVEQU8nLFxuICAgICAgZG9jdW1lbnRhdGlvbjogJ1RoZSBzaGFyZWQgc2VydmVyIERBTyB0byBzeW5jaHJvbml6ZSB0by4nLFxuICAgICAgdHJhbnNpZW50OiB0cnVlLFxuICAgICAgcmVxdWlyZWQ6IHRydWVcbiAgICB9LFxuICAgIHtcbiAgICAgIG5hbWU6ICdkZWxlZ2F0ZScsXG4gICAgICBkb2N1bWVudGF0aW9uOiAnVGhlIGxvY2FsIGNhY2hlIHRvIHN5bmMgd2l0aCB0aGUgc2VydmVyIERBTy4nXG4gICAgfSxcbiAgICB7XG4gICAgICBjbGFzczogJ2ZvYW0uZGFvLkRBT1Byb3BlcnR5JyxcbiAgICAgIG5hbWU6ICdzeW5jUmVjb3JkREFPJyxcbiAgICAgIGRvY3VtZW50YXRpb246IGBUaGUgREFPIGluIHdoaWNoIHRvIHN0b3JlIFZlcnNpb25lZFN5bmNSZWNvcmRzIGZvciBlYWNoXG4gICAgICAgICAgb2JqZWN0LiBFYWNoIGNsaWVudCB0cmFja3MgdGhlaXIgb3duIHN5bmMgc3RhdGUgaW4gYSBzZXBhcmF0ZVxuICAgICAgICAgIHN5bmNSZWNvcmREQU8uYCxcbiAgICAgIHRyYW5zaWVudDogdHJ1ZSxcbiAgICAgIHJlcXVpcmVkOiB0cnVlXG4gICAgfSxcbiAgICB7XG4gICAgICBuYW1lOiAnb2YnLFxuICAgICAgZG9jdW1lbnRhdGlvbjogJ1RoZSBjbGFzcyBvZiBvYmplY3QgdGhpcyBEQU8gd2lsbCBzdG9yZS4nLFxuICAgICAgcmVxdWlyZWQ6IHRydWUsXG4gICAgICB0cmFuc2llbnQ6IHRydWVcbiAgICB9LFxuICAgIHtcbiAgICAgIGNsYXNzOiAnQm9vbGVhbicsXG4gICAgICBuYW1lOiAncG9sbGluZycsXG4gICAgICBkb2N1bWVudGF0aW9uOiBgSWYgdXNpbmcgYSByZW1vdGUgREFPIHdpdGhvdXQgcHVzaCBjYXBhYmlsaXRpZXMsIHN1Y2ggYXNcbiAgICAgICAgICBhbiBIVFRQIHNlcnZlciwgcG9sbGluZyB3aWxsIHBlcmlvZGljYWxseSBhdHRlbXB0IHRvIHN5bmNocm9uaXplLmAsXG4gICAgICBwb3N0U2V0OiBmdW5jdGlvbihvbGQsIG51KSB7XG4gICAgICAgIHRoaXMuc3luY18gPSBudSA/IHRoaXMucG9sbGluZ1N5bmNfIDogdGhpcy5zeW5jVG9SZW1vdGVfO1xuICAgICAgfVxuICAgIH0sXG4gICAge1xuICAgICAgY2xhc3M6ICdJbnQnLFxuICAgICAgbmFtZTogJ3BvbGxpbmdGcmVxdWVuY3knLFxuICAgICAgZG9jdW1lbnRhdGlvbjogYElmIHVzaW5nIHBvbGxpbmcsIHBvbGxpbmdGcmVxdWVuY3kgd2lsbCBkZXRlcm1pbmUgdGhlXG4gICAgICAgIG51bWJlciBvZiBtaWxsaXNlY29uZHMgdG8gd2FpdCBiZXR3ZWVuIHN5bmNocm9uaXphdGlvbiBhdHRlbXB0cy5gLFxuICAgICAgdmFsdWU6IDEwMDBcbiAgICB9LFxuICAgIHtcbiAgICAgIG5hbWU6ICdzeW5jZWQnLFxuICAgICAgZG9jdW1lbnRhdGlvbjogYEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIGFmdGVyIGFueSBpbi1mbGlnaHRcbiAgICAgICAgICBzeW5jaHJvbml6YXRpb24gcGFzcyBjb21wbGV0ZXMuYCxcbiAgICAgIGZhY3Rvcnk6IGZ1bmN0aW9uKCkgeyByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7IH1cbiAgICB9LFxuICAgIHtcbiAgICAgIG5hbWU6ICdzeW5jUmVjb3JkV3JpdGVTeW5jXycsXG4gICAgICBmYWN0b3J5OiBmdW5jdGlvbigpIHsgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpOyB9XG4gICAgfSxcbiAgICB7XG4gICAgICBjbGFzczogJ0Z1bmN0aW9uJyxcbiAgICAgIG5hbWU6ICdzeW5jXycsXG4gICAgICBkb2N1bWVudGF0aW9uOiBgU2VsZWN0ZWQgc3luYyBzdHJhdGVneTsgZWl0aGVyIHN5bmNUb1JlbW90ZV8oKSBvclxuICAgICAgICAgIHBvbGxpbmdTeW5jXygpLmAsXG4gICAgICBmYWN0b3J5OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucG9sbGluZyA/IHRoaXMucG9sbGluZ1N5bmNfIDogdGhpcy5zeW5jVG9SZW1vdGVfO1xuICAgICAgfVxuICAgIH1cbiAgXSxcblxuICBtZXRob2RzOiBbXG4gICAgZnVuY3Rpb24gaW5pdCgpIHtcbiAgICAgIHRoaXMuU1VQRVIoKTtcblxuICAgICAgdGhpcy52YWxpZGF0ZSgpO1xuXG4gICAgICAvLyBPbmx5IGxpc3RlbiB0byBEQU9zIHRoYXQgc3VwcG9ydCBwdXNoIChpLmUuLCBkbyBub3QgcmVxdWlyZSBwb2xsaW5nKS5cbiAgICAgIGlmICggISB0aGlzLnBvbGxpbmcgKVxuICAgICAgICB0aGlzLnJlbW90ZURBTyRwcm94eS5zdWIoJ29uJywgdGhpcy5vblJlbW90ZVVwZGF0ZSk7XG5cbiAgICAgIC8vIFB1c2ggaW5pdGlhbCBkYXRhIGZyb20gZGVsZWdhdGUuXG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICBzZWxmLnN5bmNlZCA9IHNlbGYuZGVsZWdhdGUuc2VsZWN0KCkuXG4gICAgICAgICAgdGhlbihmdW5jdGlvbihzaW5rKSB7XG4gICAgICAgICAgICB2YXIgbWluVmVyc2lvbk5vID0gMDtcbiAgICAgICAgICAgIHZhciBhcnJheSA9IHNpbmsuYXJyYXk7XG4gICAgICAgICAgICBmb3IgKCB2YXIgaSA9IDA7IGkgPCBhcnJheS5sZW5ndGg7IGkrKyApIHtcbiAgICAgICAgICAgICAgdmFyIHZlcnNpb24gPSBzZWxmLlZlcnNpb25UcmFpdC5WRVJTSU9OXy5mKGFycmF5W2ldKTtcbiAgICAgICAgICAgICAgc2VsZi5zeW5jUmVjb3JkREFPLnB1dChzZWxmLlZlcnNpb25lZFN5bmNSZWNvcmQuY3JlYXRlKHtcbiAgICAgICAgICAgICAgICBpZDogYXJyYXlbaV0uaWQsXG4gICAgICAgICAgICAgICAgdmVyc2lvbl86IHZlcnNpb25cbiAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICBtaW5WZXJzaW9uTm8gPSBNYXRoLm1heChtaW5WZXJzaW9uTm8sIHZlcnNpb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHNlbGYuc3luY0Zyb21SZW1vdGVfKG1pblZlcnNpb25Obyk7XG4gICAgICAgICAgfSk7XG5cbiAgICAgIC8vIFNldHVwIHBvbGxpbmcgYWZ0ZXIgaW5pdGlhbCBzeW5jLlxuICAgICAgaWYgKCAhIHNlbGYucG9sbGluZyApIHJldHVybjtcbiAgICAgIHNlbGYuc3luY2VkLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgIHNlbGYuc2V0SW50ZXJ2YWwoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgc2VsZi5zeW5jKCk7XG4gICAgICAgIH0sIHNlbGYucG9sbGluZ0ZyZXF1ZW5jeSk7XG4gICAgICB9KTtcbiAgICB9LFxuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKCkge1xuICAgICAgdGhpcy5TVVBFUigpO1xuICAgICAgaWYgKCAhIHRoaXMuVmVyc2lvblRyYWl0LmlzU3ViQ2xhc3ModGhpcy5vZikgKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgU3luY0RBTy5vZiBtdXN0IGhhdmUgdHJhaXQgZm9hbS52ZXJzaW9uLlZlcnNpb25UcmFpdGApO1xuICAgICAgfVxuICAgIH0sXG4gICAgZnVuY3Rpb24gc3luYygpIHtcbiAgICAgIC8vIFN5bmMgYWZ0ZXIgYW55IHN5bmMocykgaW4gcHJvZ3Jlc3MgY29tcGxldGUuXG4gICAgICByZXR1cm4gdGhpcy5zeW5jZWQgPSB0aGlzLnN5bmNlZC50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zeW5jXygpO1xuICAgICAgfS5iaW5kKHRoaXMpKTtcbiAgICB9LFxuXG4gICAgLy9cbiAgICAvLyBEQU8gb3ZlcnJpZGVzLlxuICAgIC8vXG5cbiAgICBmdW5jdGlvbiBwdXRfKHgsIG9iaikge1xuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgdmFyIHJldDtcbiAgICAgIHJldHVybiBzZWxmLndpdGhTeW5jUmVjb3JkVHhfKGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gc2VsZi5kZWxlZ2F0ZS5wdXRfKHgsIG9iaikudGhlbihmdW5jdGlvbihvKSB7XG4gICAgICAgICAgcmV0ID0gbztcbiAgICAgICAgICAvLyBVcGRhdGVzIHRoZSBvYmplY3QncyBsYXN0IHNlZW4gaW5mby5cbiAgICAgICAgICByZXR1cm4gc2VsZi5zeW5jUmVjb3JkREFPLnB1dF8oeCwgc2VsZi5WZXJzaW9uZWRTeW5jUmVjb3JkLmNyZWF0ZSh7XG4gICAgICAgICAgICBpZDogby5pZCxcbiAgICAgICAgICAgIHZlcnNpb25fOiAtMVxuICAgICAgICAgIH0pKTtcbiAgICAgICAgfSk7XG4gICAgICB9KS50aGVuKHNlbGYub25Mb2NhbFVwZGF0ZSkudGhlbihmdW5jdGlvbigpIHsgcmV0dXJuIHJldDsgfSk7XG4gICAgfSxcbiAgICBmdW5jdGlvbiByZW1vdmVfKHgsIG9iaikge1xuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgdmFyIHJldDtcbiAgICAgIHJldHVybiBzZWxmLndpdGhTeW5jUmVjb3JkVHhfKGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gc2VsZi5kZWxlZ2F0ZS5yZW1vdmVfKHgsIG9iaikudGhlbihmdW5jdGlvbihvKSB7XG4gICAgICAgICAgcmV0ID0gbztcbiAgICAgICAgICAvLyBNYXJrcyB0aGUgb2JqZWN0IGFzIGRlbGV0ZWQuXG4gICAgICAgICAgc2VsZi5zeW5jUmVjb3JkREFPLnB1dF8oeCwgc2VsZi5WZXJzaW9uZWRTeW5jUmVjb3JkLmNyZWF0ZSh7XG4gICAgICAgICAgICBpZDogb2JqLmlkLFxuICAgICAgICAgICAgZGVsZXRlZF86IHRydWUsXG4gICAgICAgICAgICB2ZXJzaW9uXzogLTFcbiAgICAgICAgICB9KSk7XG4gICAgICAgIH0pO1xuICAgICAgfSkudGhlbihzZWxmLm9uTG9jYWxVcGRhdGUpLnRoZW4oZnVuY3Rpb24oKSB7IHJldHVybiByZXQ7IH0pO1xuICAgIH0sXG4gICAgZnVuY3Rpb24gcmVtb3ZlQWxsXyh4LCBza2lwLCBsaW1pdCwgb3JkZXIsIHByZWRpY2F0ZSkge1xuICAgICAgLy8gTWFya3MgYWxsIHRoZSByZW1vdmVkIG9iamVjdHMnIHN5bmMgcmVjb3JkcyBhcyBkZWxldGVkIHZpYSByZW1vdmVfKCkuXG4gICAgICByZXR1cm4gdGhpcy5kZWxlZ2F0ZS5zZWxlY3RfKHgsIG51bGwsIHNraXAsIGxpbWl0LCBvcmRlciwgcHJlZGljYXRlKS5cbiAgICAgICAgICB0aGVuKGZ1bmN0aW9uKGEpIHtcbiAgICAgICAgICAgIGEgPSBhLmFycmF5O1xuICAgICAgICAgICAgdmFyIHByb21pc2VzID0gW107XG5cbiAgICAgICAgICAgIGZvciAoIHZhciBpID0gMCA7IGkgPCBhLmxlbmd0aCA7IGkrKyApIHtcbiAgICAgICAgICAgICAgcHJvbWlzZXMucHVzaCh0aGlzLnJlbW92ZV8oeCwgYVtpXSkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5hbGwocHJvbWlzZXMpO1xuICAgICAgICAgIH0uYmluZCh0aGlzKSk7XG4gICAgfSxcblxuICAgIC8vXG4gICAgLy8gUHJpdmF0ZSBzeW5jaHJvbml6YXRpb24gZGV0YWlscy5cbiAgICAvL1xuXG4gICAge1xuICAgICAgbmFtZTogJ3B1dEZyb21SZW1vdGVfJyxcbiAgICAgIGRvY3VtZW50YXRpb246ICdQcm9jZXNzIGEgcHV0KCkgdG8gY2FjaGUgZnJvbSByZW1vdGUuJyxcbiAgICAgIGNvZGU6IGZ1bmN0aW9uKG9iaikge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIHZhciByZXQ7XG4gICAgICAgIHJldHVybiBzZWxmLndpdGhTeW5jUmVjb3JkVHhfKGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiBzZWxmLmRlbGVnYXRlLnB1dChvYmopLnRoZW4oZnVuY3Rpb24obykge1xuICAgICAgICAgICAgcmV0ID0gbztcbiAgICAgICAgICAgIHJldHVybiBzZWxmLnN5bmNSZWNvcmREQU8ucHV0KHNlbGYuVmVyc2lvbmVkU3luY1JlY29yZC5jcmVhdGUoe1xuICAgICAgICAgICAgICBpZDogby5pZCxcbiAgICAgICAgICAgICAgdmVyc2lvbl86IHNlbGYuVmVyc2lvblRyYWl0LlZFUlNJT05fLmYobylcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSkudGhlbihmdW5jdGlvbigpIHsgcmV0dXJuIHJldDsgfSk7XG4gICAgICB9XG4gICAgfSxcbiAgICB7XG4gICAgICBuYW1lOiAncmVtb3ZlRnJvbVJlbW90ZV8nLFxuICAgICAgZG9jdW1lbnRhdGlvbjogJ1Byb2Nlc3MgYSByZW1vdmUoKSBvbiBjYWNoZSBmcm9tIHJlbW90ZS4nLFxuICAgICAgY29kZTogZnVuY3Rpb24ob2JqKSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgdmFyIHJldDtcbiAgICAgICAgcmV0dXJuIHNlbGYud2l0aFN5bmNSZWNvcmRUeF8oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIHNlbGYuZGVsZWdhdGUucmVtb3ZlKG9iaikudGhlbihmdW5jdGlvbihvKSB7XG4gICAgICAgICAgICByZXQgPSBvO1xuICAgICAgICAgICAgcmV0dXJuIHNlbGYuc3luY1JlY29yZERBTy5wdXQoc2VsZi5WZXJzaW9uZWRTeW5jUmVjb3JkLmNyZWF0ZSh7XG4gICAgICAgICAgICAgIGlkOiBvYmouaWQsXG4gICAgICAgICAgICAgIHZlcnNpb25fOiBzZWxmLlZlcnNpb25UcmFpdC5WRVJTSU9OXy5mKG9iaiksXG4gICAgICAgICAgICAgIGRlbGV0ZWRfOiB0cnVlXG4gICAgICAgICAgICB9KSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pLnRoZW4oZnVuY3Rpb24oKSB7IHJldHVybiByZXQ7IH0pO1xuICAgICAgfVxuICAgIH0sXG4gICAge1xuICAgICAgbmFtZTogJ3Jlc2V0RnJvbVJlbW90ZV8nLFxuICAgICAgZG9jdW1lbnRhdGlvbjogJ1Byb2Nlc3MgYSByZXNldCBzaWduYWwgb24gY2FjaGUgZnJvbSByZW1vdGUuJyxcbiAgICAgIGNvZGU6IGZ1bmN0aW9uKG9iaikge1xuICAgICAgICAvLyBDbGVhciBzeW5jIHJlY29yZHMgYW5kIGRhdGEgbm90IGFzc29jaWF0ZWQgd2l0aCB1bnN5bmNlZCBkYXRhLCB0aGVuXG4gICAgICAgIC8vIHN5bmMuXG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgdmFyIHJldDtcbiAgICAgICAgcmV0dXJuIHNlbGYud2l0aFN5bmNSZWNvcmRUeF8oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIHNlbGYuc3luY1JlY29yZERBTy5cbiAgICAgICAgICAgICAgd2hlcmUoc2VsZi5HVChzZWxmLlZlcnNpb25lZFN5bmNSZWNvcmQuVkVSU0lPTl8sIC0xKSkuXG4gICAgICAgICAgICAgIHJlbW92ZUFsbCgpLlxuICAgICAgICAgICAgICB0aGVuKHNlbGYuc3luY1JlY29yZERBTy5zZWxlY3QuYmluZChzZWxmLnN5bmNSZWNvcmREQU8pKS5cbiAgICAgICAgICAgICAgdGhlbihmdW5jdGlvbihzaW5rKSB7XG4gICAgICAgICAgICAgICAgdmFyIGlkc1RvS2VlcCA9IHNpbmsuYXJyYXkubWFwKGZ1bmN0aW9uKHN5bmNSZWNvcmQpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBzeW5jUmVjb3JkLmlkO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiBzZWxmLmRlbGVnYXRlLndoZXJlKFxuICAgICAgICAgICAgICAgICAgICBzZWxmLk5PVChzZWxmLklOKHNlbGYub2YuSUQsIGlkc1RvS2VlcCkpKS5cbiAgICAgICAgICAgICAgICAgICAgcmVtb3ZlQWxsKCk7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICB9KS50aGVuKHNlbGYuc3luYy5iaW5kKHNlbGYpKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHtcbiAgICAgIG5hbWU6ICdwb2xsaW5nU3luY18nLFxuICAgICAgZG9jdW1lbnRhdGlvbjogYFBvbGxpbmcgc3luY2hyb25pemF0aW9uIHN0cmF0ZWd5LiBEZXRlcm1pbmUgY3VycmVudFxuICAgICAgICAgIHZlcnNpb24sIHRoZW4gcHVzaCB0byByZW1vdGUsIHRoZW4gcHVsbCB1cGRhdGUgZnJvbSByZW1vdGUuYCxcbiAgICAgIGNvZGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIHZhciBWRVJTSU9OXyA9IHNlbGYuVmVyc2lvbmVkU3luY1JlY29yZC5WRVJTSU9OXztcbiAgICAgICAgcmV0dXJuIHNlbGYuc3luY1JlY29yZERBTy5cbiAgICAgICAgICAgIC8vIExpa2UgTUFYKCksIGJ1dCBmYXN0ZXIgb24gREFPcyB0aGF0IGNhbiBvcHRpbWl6ZSBvcmRlcitsaW1pdC5cbiAgICAgICAgICAgIG9yZGVyQnkoc2VsZi5ERVNDKFZFUlNJT05fKSkubGltaXQoMSkuXG4gICAgICAgICAgICBzZWxlY3QoKS50aGVuKGZ1bmN0aW9uKHNpbmspIHtcbiAgICAgICAgICAgICAgdmFyIG1pblZlcnNpb25ObyA9IHNpbmsuYXJyYXlbMF0gJiYgVkVSU0lPTl8uZihzaW5rLmFycmF5WzBdKSB8fFxuICAgICAgICAgICAgICAgICAgMDtcbiAgICAgICAgICAgICAgcmV0dXJuIHNlbGYuc3luY1RvUmVtb3RlXygpLlxuICAgICAgICAgICAgICAgICAgdGhlbihzZWxmLnN5bmNGcm9tUmVtb3RlXy5iaW5kKHNlbGYsIG1pblZlcnNpb25ObykpO1xuICAgICAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSxcbiAgICB7XG4gICAgICBuYW1lOiAnc3luY1RvUmVtb3RlXycsXG4gICAgICBkb2N1bWVudGF0aW9uOiBgUHVzaCBzeW5jaHJvbml6YXRpb24gc3RyYXRlZ3k6IFB1c2ggZGF0YSBmcm9tIGNhY2ggdG9cbiAgICAgICAgICByZW1vdGU7IHJlbHkgb24gcHVzaGVkIHVwZGF0ZXMgZnJvbSBzZXJ2ZXIuYCxcbiAgICAgIGNvZGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuc3luY1JlY29yZERBTy5cbiAgICAgICAgICB3aGVyZShzZWxmLkVRKHNlbGYuVmVyc2lvbmVkU3luY1JlY29yZC5WRVJTSU9OXywgLTEpKS5cbiAgICAgICAgICBzZWxlY3QoKS50aGVuKGZ1bmN0aW9uKHJlY29yZHMpIHtcbiAgICAgICAgICAgIHJlY29yZHMgPSByZWNvcmRzLmFycmF5O1xuICAgICAgICAgICAgdmFyIHByb21pc2VzID0gW107XG5cbiAgICAgICAgICAgIGZvciAoIHZhciBpID0gMCA7IGkgPCByZWNvcmRzLmxlbmd0aCA7IGkrKyApIHtcbiAgICAgICAgICAgICAgdmFyIHJlY29yZCA9IHJlY29yZHNbaV07XG4gICAgICAgICAgICAgIHZhciBpZCA9IHJlY29yZC5pZDtcbiAgICAgICAgICAgICAgdmFyIGRlbGV0ZWQgPSBzZWxmLlZlcnNpb25lZFN5bmNSZWNvcmQuREVMRVRFRF8uZihyZWNvcmQpO1xuXG4gICAgICAgICAgICAgIGlmICggZGVsZXRlZCApIHtcbiAgICAgICAgICAgICAgICB2YXIgb2JqID0gc2VsZi5vZi5jcmVhdGUodW5kZWZpbmVkLCBzZWxmKTtcbiAgICAgICAgICAgICAgICBvYmouaWQgPSBpZDtcbiAgICAgICAgICAgICAgICB2YXIgcHJvbWlzZSA9IHNlbGYucmVtb3RlREFPLnJlbW92ZShvYmopO1xuXG4gICAgICAgICAgICAgICAgLy8gV2hlbiBub3QgcG9sbGluZywgc2VydmVyIHJlc3VsdCB3aWxsIHByb2Nlc3NlZCB3aGVuXG4gICAgICAgICAgICAgICAgLy8gb25SZW1vdGVVcGRhdGUgbGlzdGVuZXIgaXMgZmlyZWQuXG4gICAgICAgICAgICAgICAgaWYgKCBzZWxmLnBvbGxpbmcgKSB7XG4gICAgICAgICAgICAgICAgICBwcm9taXNlcy5wdXNoKHByb21pc2UudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHByb3BOYW1lID0gc2VsZi5WZXJzaW9uVHJhaXQuVkVSU0lPTl8ubmFtZTtcbiAgICAgICAgICAgICAgICAgICAgLy8gRW5zdXJlIHRoYXQgb2JqIFN5bmNSZWNvcmQgZG9lcyBub3QgcmVtYWluIHF1ZXVlZCAoaS5lLixcbiAgICAgICAgICAgICAgICAgICAgLy8gZG9lcyBub3QgaGF2ZSB2ZXJzaW9uXyA9IC0xKS5cbiAgICAgICAgICAgICAgICAgICAgb2JqW3Byb3BOYW1lXSA9IE1hdGgubWF4KG9ialtwcm9wTmFtZV0sIDApO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2VsZi5yZW1vdmVGcm9tUmVtb3RlXyhvYmopO1xuICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBwcm9taXNlcy5wdXNoKHByb21pc2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBUT0RPKG1hcmtkaXR0bWVyKTogRGVhbCBhcHByb3ByaWF0ZWx5IHdpdGggZmFpbGVkIHVwZGF0ZXMuXG4gICAgICAgICAgICAgICAgcHJvbWlzZXMucHVzaChzZWxmLmRlbGVnYXRlLmZpbmQoaWQpLnRoZW4oZnVuY3Rpb24ob2JqKSB7XG4gICAgICAgICAgICAgICAgICBpZiAoICEgb2JqICkgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgICB2YXIgcmV0ID0gc2VsZi5yZW1vdGVEQU8ucHV0KG9iaik7XG5cbiAgICAgICAgICAgICAgICAgIC8vIFdoZW4gbm90IHBvbGxpbmcsIHNlcnZlciByZXN1bHQgd2lsbCBwcm9jZXNzZWQgd2hlblxuICAgICAgICAgICAgICAgICAgLy8gb25SZW1vdGVVcGRhdGUgbGlzdGVuZXIgaXMgZmlyZWQuXG4gICAgICAgICAgICAgICAgICBpZiAoIHNlbGYucG9sbGluZyApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0ID0gcmV0LnRoZW4oZnVuY3Rpb24obykge1xuICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzZWxmLnB1dEZyb21SZW1vdGVfKG8pO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UuYWxsKHByb21pc2VzKTtcbiAgICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHtcbiAgICAgIG5hbWU6ICdzeW5jRnJvbVJlbW90ZV8nLFxuICAgICAgZG9jdW1lbnRhdGlvbjogYFB1bGwgdXBkYXRlcyBmcm9tIHJlbW90ZTsgdXNlZCBmb3IgaW5pdGlhbCBzeW5jIGFuZFxuICAgICAgICAgIHBvbGxpbmcgc3luYyBzdHJhdGVneS5gLFxuICAgICAgY29kZTogZnVuY3Rpb24obWluVmVyc2lvbk5vKSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgcmV0dXJuIHNlbGYucmVtb3RlREFPLlxuICAgICAgICAgICAgd2hlcmUoc2VsZi5HVChzZWxmLlZlcnNpb25UcmFpdC5WRVJTSU9OXywgbWluVmVyc2lvbk5vKSkuXG4gICAgICAgICAgICBvcmRlckJ5KHNlbGYuVmVyc2lvblRyYWl0LlZFUlNJT05fKS5cbiAgICAgICAgICAgIHNlbGVjdCgpLnRoZW4oZnVuY3Rpb24oc2luaykge1xuICAgICAgICAgICAgICB2YXIgYXJyYXkgPSBzaW5rLmFycmF5O1xuICAgICAgICAgICAgICB2YXIgcHJvbWlzZXMgPSBbXTtcblxuICAgICAgICAgICAgICBmb3IgKCB2YXIgaSA9IDAgOyBpIDwgYXJyYXkubGVuZ3RoIDsgaSsrICkge1xuICAgICAgICAgICAgICAgIGlmICggc2VsZi5WZXJzaW9uVHJhaXQuREVMRVRFRF8uZihhcnJheVtpXSkgKSB7XG4gICAgICAgICAgICAgICAgICBwcm9taXNlcy5wdXNoKHNlbGYucmVtb3ZlRnJvbVJlbW90ZV8oYXJyYXlbaV0pKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgcHJvbWlzZXMucHVzaChzZWxmLnB1dEZyb21SZW1vdGVfKGFycmF5W2ldKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UuYWxsKHByb21pc2VzKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0sXG4gICAge1xuICAgICAgbmFtZTogJ3dpdGhTeW5jUmVjb3JkVHhfJyxcbiAgICAgIGRvY3VtZW50YXRpb246IGBSdW4gYSBjb21wdXRhdGlvbiB0aGF0IHdyaXRlcyB0byBzeW5jUmVjb3JkREFPXG4gICAgICAgICAgdHJhbnNhY3Rpb25hbGx5IHdpdGggcmVzcGVjdCB0byBvdGhlciBzeW5jUmVjb3JkREFPIHdyaXRlcy5gLFxuICAgICAgY29kZTogZnVuY3Rpb24oZikge1xuICAgICAgICByZXR1cm4gdGhpcy5zeW5jUmVjb3JkV3JpdGVTeW5jXyA9IHRoaXMuc3luY1JlY29yZFdyaXRlU3luY18udGhlbihmKTtcbiAgICAgIH1cbiAgICB9XG4gIF0sXG5cbiAgbGlzdGVuZXJzOiBbXG4gICAge1xuICAgICAgbmFtZTogJ29uUmVtb3RlVXBkYXRlJyxcbiAgICAgIGRvY3VtZW50YXRpb246ICdSZXNwb25kIHRvIHB1c2ggZXZlbnQgZnJvbSByZW1vdGUuJyxcbiAgICAgIGNvZGU6IGZ1bmN0aW9uKHMsIG9uLCBldmVudCwgb2JqKSB7XG4gICAgICAgIGlmICggZXZlbnQgPT0gJ3B1dCcgKSB7XG4gICAgICAgICAgaWYgKCB0aGlzLlZlcnNpb25UcmFpdC5ERUxFVEVEXy5mKG9iaikgKSB0aGlzLnJlbW92ZUZyb21SZW1vdGVfKG9iaik7XG4gICAgICAgICAgZWxzZSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnB1dEZyb21SZW1vdGVfKG9iaik7XG4gICAgICAgIH0gZWxzZSBpZiAoIGV2ZW50ID09PSAncmVtb3ZlJyApIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFN5bmNEQU8gcmVjaWV2ZWQgcmVtb3ZlKCkgZXZlbnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBleHBlY3RlZCBwdXQoZGVsZXRlZCktYXMtcmVtb3ZlKClgKTtcbiAgICAgICAgfSBlbHNlIGlmICggZXZlbnQgPT09ICdyZXNldCcgKSB7XG4gICAgICAgICAgdGhpcy5yZXNldEZyb21SZW1vdGVfKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIHtcbiAgICAgIG5hbWU6ICdvbkxvY2FsVXBkYXRlJyxcbiAgICAgIGlzTWVyZ2VkOiB0cnVlLFxuICAgICAgbWVyZ2VEZWxheTogMTAwLFxuICAgICAgY29kZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuc3luYygpO1xuICAgICAgfVxuICAgIH1cbiAgXVxufSk7XG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5mb2FtLkNMQVNTKHtcbiAgcGFja2FnZTogJ2ZvYW0uZGFvJyxcbiAgbmFtZTogJ0Vhc3lEQU8nLFxuICBleHRlbmRzOiAnZm9hbS5kYW8uUHJveHlEQU8nLFxuICBpbXBsZW1lbnRzOiBbICdmb2FtLm1sYW5nLkV4cHJlc3Npb25zJyBdLFxuXG4gIGRvY3VtZW50YXRpb246IGZ1bmN0aW9uKCkgey8qXG4gICAgRmFjYWRlIGZvciBlYXNpbHkgY3JlYXRpbmcgZGVjb3JhdGVkIERBT3MuXG4gICAgPHA+XG4gICAgTW9zdCBEQU9zIGFyZSBtb3N0IGVhc2lseSBjcmVhdGVkIGFuZCBjb25maWd1cmVkIHdpdGggRWFzeURBTy5cbiAgICBTaW1wbHkgcmVxdWlyZSBmb2FtLmRhby5FYXN5REFPIGFuZCBjcmVhdGUoKSB3aXRoIHRoZSBmbGFnc1xuICAgIHRvIGluZGljYXRlIHdoYXQgYmVoYXZpb3IgeW91J3JlIGxvb2tpbmcgZm9yLiBVbmRlciB0aGUgaG9vZCwgRWFzeURBT1xuICAgIHdpbGwgY3JlYXRlIG9uZSBvciBtb3JlIERBTyBpbnN0YW5jZXMgdG8gc2VydmljZSB5b3VyIHJlcXVpcmVtZW50cyBhbmQgdGhlblxuICAqL30sXG5cbiAgcmVxdWlyZXM6IFtcbiAgICAnZm9hbS5ib3guQ29udGV4dCcsXG4gICAgJ2ZvYW0uYm94LkhUVFBCb3gnLFxuICAgICdmb2FtLmJveC5TZXNzaW9uQ2xpZW50Qm94JyxcbiAgICAnZm9hbS5ib3guU29ja2V0Qm94JyxcbiAgICAnZm9hbS5ib3guV2ViU29ja2V0Qm94JyxcbiAgICAnZm9hbS5ib3guVGltZW91dEJveCcsXG4gICAgJ2ZvYW0uYm94LlJldHJ5Qm94JyxcbiAgICAnZm9hbS5kYW8uQ2FjaGluZ0RBTycsXG4gICAgJ2ZvYW0uZGFvLkNvbXBvdW5kREFPRGVjb3JhdG9yJyxcbiAgICAnZm9hbS5kYW8uQ29udGV4dHVhbGl6aW5nREFPJyxcbiAgICAnZm9hbS5kYW8uRGVjb3JhdGVkREFPJyxcbiAgICAnZm9hbS5kYW8uRGVEdXBEQU8nLFxuICAgICdmb2FtLmRhby5HVUlEREFPJyxcbiAgICAnZm9hbS5kYW8uSURCREFPJyxcbiAgICAnZm9hbS5kYW8uSkRBTycsXG4gICAgJ2ZvYW0uZGFvLkxvZ2dpbmdEQU8nLFxuICAgICdmb2FtLmRhby5NREFPJyxcbiAgICAnZm9hbS5kYW8uUHJvbWlzZWREQU8nLFxuICAgICdmb2FtLmRhby5SZXF1ZXN0UmVzcG9uc2VDbGllbnREQU8nLFxuICAgICdmb2FtLmRhby5TZXF1ZW5jZU51bWJlckRBTycsXG4gICAgJ2ZvYW0uZGFvLlN5bmNEQU8nLFxuICAgICdmb2FtLmRhby5UaW1pbmdEQU8nXG4gIF0sXG5cbiAgaW1wb3J0czogWyAnZG9jdW1lbnQnIF0sXG5cbiAgY29uc3RhbnRzOiB7XG4gICAgLy8gQWxpYXNlcyBmb3IgZGFvVHlwZVxuICAgIEFMSUFTRVM6IHtcbiAgICAgIEFSUkFZOiAgJ2ZvYW0uZGFvLkFycmF5REFPJyxcbiAgICAgIENMSUVOVDogJ2ZvYW0uZGFvLlJlcXVlc3RSZXNwb25zZUNsaWVudERBTycsXG4gICAgICBJREI6ICAgICdmb2FtLmRhby5JREJEQU8nLFxuICAgICAgTE9DQUw6ICAnZm9hbS5kYW8uTG9jYWxTdG9yYWdlREFPJyxcbiAgICAgIE1EQU86ICAgJ2ZvYW0uZGFvLk1EQU8nXG4gICAgfVxuICB9LFxuXG4gIHByb3BlcnRpZXM6IFtcbiAgICB7XG4gICAgICAvKiogVGhlIGRldmVsb3Blci1mcmllbmRseSBuYW1lIGZvciB0aGlzIEVhc3lEQU8uICovXG4gICAgICBjbGFzczogJ1N0cmluZycsXG4gICAgICBuYW1lOiAnbmFtZScsXG4gICAgICBmYWN0b3J5OiBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMub2YuaWQ7IH1cbiAgICB9LFxuICAgIHtcbiAgICAgIC8qKiBUaGlzIGlzIHNldCBhdXRvbWF0aWNhbGx5IHdoZW4geW91IGNyZWF0ZSBhbiBFYXN5REFPLlxuICAgICAgICBAcHJpdmF0ZSAqL1xuICAgICAgbmFtZTogJ2RlbGVnYXRlJyxcbiAgICAgIGphdmFGYWN0b3J5OiBgXG5mb2FtLmRhby5EQU8gZGVsZWdhdGUgPSBnZXRJbm5lckRBTygpID09IG51bGwgP1xuICBuZXcgZm9hbS5kYW8uTWFwREFPKGdldFgoKSwgZ2V0T2YoKSkgOlxuICBnZXRJbm5lckRBTygpO1xuXG5pZiAoIGRlbGVnYXRlIGluc3RhbmNlb2YgZm9hbS5kYW8uTURBTyApIHNldE1kYW8oKGZvYW0uZGFvLk1EQU8pZGVsZWdhdGUpO1xuXG5pZiAoIGdldEpvdXJuYWxlZCgpICkge1xuICBkZWxlZ2F0ZSA9IG5ldyBmb2FtLmRhby5KREFPKGdldFgoKSwgZGVsZWdhdGUsIGdldEpvdXJuYWxOYW1lKCkpO1xufVxuXG5pZiAoIGdldEd1aWQoKSAmJiBnZXRTZXFObygpICkge1xuICB0aHJvdyBuZXcgUnVudGltZUV4Y2VwdGlvbihcIkVhc3lEQU8gR1VJRCBhbmQgU2VxTm8gYXJlIG11dHVhbGx5IGV4Y2x1c2l2ZVwiKTtcbn1cblxuaWYgKCBnZXRHdWlkKCkgKSB7XG4gIGRlbGVnYXRlID0gbmV3IGZvYW0uZGFvLkdVSUREQU8uQnVpbGRlcihnZXRYKCkpLnNldERlbGVnYXRlKGRlbGVnYXRlKS5idWlsZCgpO1xufVxuXG5pZiAoIGdldFNlcU5vKCkgKSB7XG4gIGRlbGVnYXRlID0gbmV3IGZvYW0uZGFvLlNlcXVlbmNlTnVtYmVyREFPLkJ1aWxkZXIoZ2V0WCgpKS5cbiAgICBzZXREZWxlZ2F0ZShkZWxlZ2F0ZSkuXG4gICAgc2V0UHJvcGVydHkoZ2V0U2VxUHJvcGVydHlOYW1lKCkpLlxuICAgIGJ1aWxkKCk7XG59XG5cbmlmICggZ2V0Q29udGV4dHVhbGl6ZSgpICkge1xuICBkZWxlZ2F0ZSA9IG5ldyBmb2FtLmRhby5Db250ZXh0dWFsaXppbmdEQU8uQnVpbGRlcihnZXRYKCkpLlxuICAgIHNldERlbGVnYXRlKGRlbGVnYXRlKS5cbiAgICBidWlsZCgpO1xufVxuXG5pZiAoIGdldEF1dGhlbnRpY2F0ZSgpICkge1xuICBkZWxlZ2F0ZSA9IG5ldyBmb2FtLmRhby5BdXRoZW50aWNhdGVkREFPKFxuICAgIGdldE5hbWUoKSxcbiAgICBnZXRBdXRoZW50aWNhdGVSZWFkKCksXG4gICAgZGVsZWdhdGUpO1xufVxuXG5pZiAoIGdldFBtKCkgKSB7XG4gIGRlbGVnYXRlID0gbmV3IGZvYW0uZGFvLlBNREFPKGRlbGVnYXRlKTtcbn1cblxucmV0dXJuIGRlbGVnYXRlO1xuYFxuICAgIH0sXG4gICAge1xuICAgICAgY2xhc3M6ICdPYmplY3QnLFxuICAgICAgamF2YVR5cGU6ICdmb2FtLmRhby5EQU8nLFxuICAgICAgbmFtZTogJ2lubmVyREFPJ1xuICAgIH0sXG4gICAge1xuICAgICAgLyoqIEhhdmUgRWFzeURBTyB1c2UgYSBzZXF1ZW5jZSBudW1iZXIgdG8gaW5kZXggaXRlbXMuIE5vdGUgdGhhdFxuICAgICAgICAuc2VxTm8gYW5kIC5ndWlkIGZlYXR1cmVzIGFyZSBtdXR1YWxseVxuICAgICAgICBleGNsdXNpdmUuICovXG4gICAgICBjbGFzczogJ0Jvb2xlYW4nLFxuICAgICAgbmFtZTogJ3NlcU5vJyxcbiAgICAgIHZhbHVlOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgLyoqIEhhdmUgRWFzeURBTyBnZW5lcmF0ZSBndWlkcyB0byBpbmRleCBpdGVtcy4gTm90ZSB0aGF0IC5zZXFObyBhbmQgLmd1aWQgZmVhdHVyZXMgYXJlIG11dHVhbGx5IGV4Y2x1c2l2ZS4gKi9cbiAgICAgIGNsYXNzOiAnQm9vbGVhbicsXG4gICAgICBuYW1lOiAnZ3VpZCcsXG4gICAgICBsYWJlbDogJ0dVSUQnLFxuICAgICAgdmFsdWU6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICBjbGFzczogJ1N0cmluZycsXG4gICAgICBuYW1lOiAnc2VxUHJvcGVydHlOYW1lJyxcbiAgICAgIHZhbHVlOiAnaWQnXG4gICAgfSxcbiAgICB7XG4gICAgICAvKiogVGhlIHByb3BlcnR5IG9uIHlvdXIgaXRlbXMgdG8gdXNlIHRvIHN0b3JlIHRoZSBzZXF1ZW5jZSBudW1iZXIgb3IgZ3VpZC4gVGhpcyBpcyByZXF1aXJlZCBmb3IgLnNlcU5vIG9yIC5ndWlkIG1vZGUuICovXG4gICAgICBuYW1lOiAnc2VxUHJvcGVydHknLFxuICAgICAgZ2VuZXJhdGVKYXZhOiBmYWxzZSxcbiAgICAgIGNsYXNzOiAnUHJvcGVydHknXG4gICAgfSxcbiAgICB7XG4gICAgICAvKiogRW5hYmxlIGxvY2FsIGluLW1lbW9yeSBjYWNoaW5nIG9mIHRoZSBEQU8uICovXG4gICAgICBjbGFzczogJ0Jvb2xlYW4nLFxuICAgICAgbmFtZTogJ2NhY2hlJyxcbiAgICAgIGdlbmVyYXRlSmF2YTogZmFsc2UsXG4gICAgICB2YWx1ZTogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgIC8qKiBFbmFibGUgc3RhbmRhcmQgYXV0aGVudGljYXRpb24uICovXG4gICAgICBjbGFzczogJ0Jvb2xlYW4nLFxuICAgICAgbmFtZTogJ2F1dGhlbnRpY2F0ZScsXG4gICAgICB2YWx1ZTogdHJ1ZVxuICAgIH0sXG4gICAge1xuICAgICAgLyoqIEVuYWJsZSBzdGFuZGFyZCByZWFkIGF1dGhlbnRpY2F0aW9uLiAqL1xuICAgICAgY2xhc3M6ICdCb29sZWFuJyxcbiAgICAgIG5hbWU6ICdhdXRoZW50aWNhdGVSZWFkJyxcbiAgICAgIHZhbHVlOiB0cnVlXG4gICAgfSxcbiAgICB7XG4gICAgICAvKiogRW5hYmxlIHZhbHVlIGRlLWR1cGxpY2F0aW9uIHRvIHNhdmUgbWVtb3J5IHdoZW4gY2FjaGluZy4gKi9cbiAgICAgIGNsYXNzOiAnQm9vbGVhbicsXG4gICAgICBuYW1lOiAnZGVkdXAnLFxuICAgICAgZ2VuZXJhdGVKYXZhOiBmYWxzZSxcbiAgICAgIHZhbHVlOiBmYWxzZSxcbiAgICB9LFxuICAgIHtcbiAgICAgIC8qKiBLZWVwIGEgaGlzdG9yeSBvZiBhbGwgc3RhdGUgY2hhbmdlcyB0byB0aGUgREFPLiAqL1xuICAgICAgY2xhc3M6ICdCb29sZWFuJyxcbiAgICAgIG5hbWU6ICdqb3VybmFsZWQnLFxuICAgICAgdmFsdWU6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICBjbGFzczogJ1N0cmluZycsXG4gICAgICBuYW1lOiAnam91cm5hbE5hbWUnXG4gICAgfSxcbiAgICB7XG4gICAgICBjbGFzczogJ0ZPYmplY3RQcm9wZXJ0eScsXG4gICAgICBvZjogJ2ZvYW0uZGFvLkpvdXJuYWwnLFxuICAgICAgZ2VuZXJhdGVKYXZhOiBmYWxzZSxcbiAgICAgIG5hbWU6ICdqb3VybmFsJ1xuICAgIH0sXG4gICAge1xuICAgICAgLyoqIEVuYWJsZSBsb2dnaW5nIG9uIHRoZSBEQU8uICovXG4gICAgICBjbGFzczogJ0Jvb2xlYW4nLFxuICAgICAgbmFtZTogJ2xvZ2dpbmcnLFxuICAgICAgdmFsdWU6IGZhbHNlLFxuICAgICAgZ2VuZXJhdGVKYXZhOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgLyoqIEVuYWJsZSB0aW1lIHRyYWNraW5nIGZvciBjb25jdXJyZW50IERBTyBvcGVyYXRpb25zLiAqL1xuICAgICAgY2xhc3M6ICdCb29sZWFuJyxcbiAgICAgIG5hbWU6ICd0aW1pbmcnLFxuICAgICAgZ2VuZXJhdGVKYXZhOiBmYWxzZSxcbiAgICAgIHZhbHVlOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgY2xhc3M6ICdCb29sZWFuJyxcbiAgICAgIG5hbWU6ICdwbScsXG4gICAgICB2YWx1ZTogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgIC8qKiBDb250ZXh0dWFsaXplIG9iamVjdHMgb24gLmZpbmQsIHJlLWNyZWF0aW5nIHRoZW0gd2l0aCB0aGlzIEVhc3lEQU8nc1xuICAgICAgICBleHBvcnRzLCBhcyBpZiB0aGV5IHdlcmUgY2hpbGRyZW4gb2YgdGhpcyBFYXN5REFPLiAqL1xuICAgICAgY2xhc3M6ICdCb29sZWFuJyxcbiAgICAgIG5hbWU6ICdjb250ZXh0dWFsaXplJyxcbiAgICAgIHZhbHVlOiBmYWxzZVxuICAgIH0sXG4vLyAgICAge1xuLy8gICAgICAgY2xhc3M6ICdCb29sZWFuJyxcbi8vICAgICAgIG5hbWU6ICdjbG9uaW5nJyxcbi8vICAgICAgIHZhbHVlOiBmYWxzZSxcbi8vICAgICAgIC8vZG9jdW1lbnRhdGlvbjogXCJUcnVlIHRvIGNsb25lIHJlc3VsdHMgb24gc2VsZWN0XCJcbi8vICAgICB9LFxuICAgIHtcbiAgICAgIC8qKlxuICAgICAgICA8cD5TZWxlY3RzIHRoZSBiYXNpYyBmdW5jdGlvbmFsaXR5IHRoaXMgRWFzeURBTyBzaG91bGQgcHJvdmlkZS5cbiAgICAgICAgWW91IGNhbiBzcGVjaWZ5IGFuIGluc3RhbmNlIG9mIGEgREFPIG1vZGVsIGRlZmluaXRpb24gc3VjaCBhc1xuICAgICAgICBNREFPLCBvciBhIGNvbnN0YW50IGluZGljYXRpbmcgeW91ciByZXF1aXJlbWVudHMuPC9wPlxuICAgICAgICA8cD5DaG9pY2VzIGFyZTo8L3A+XG4gICAgICAgIDx1bD5cbiAgICAgICAgICA8bGk+SURCOiBVc2UgSW5kZXhEQiBmb3Igc3RvcmFnZS48L2xpPlxuICAgICAgICAgIDxsaT5MT0NBTDogVXNlIGxvY2FsIHN0b3JhZ2UuPC9saT5cbiAgICAgICAgICA8bGk+TURBTzogVXNlIG5vbi1wZXJzaXN0ZW50IGluLW1lbW9yeSBzdG9yYWdlLjwvbGk+XG4gICAgICAgIDwvdWw+XG4gICAgICAqL1xuICAgICAgbmFtZTogJ2Rhb1R5cGUnLFxuICAgICAgZ2VuZXJhdGVKYXZhOiBmYWxzZSxcbiAgICAgIHZhbHVlOiAnZm9hbS5kYW8uSURCREFPJ1xuICAgIH0sXG4gICAge1xuICAgICAgY2xhc3M6ICdGT2JqZWN0UHJvcGVydHknLFxuICAgICAgb2Y6ICdmb2FtLmRhby5NREFPJyxcbiAgICAgIG5hbWU6ICdtZGFvJ1xuICAgIH0sXG4gICAge1xuICAgICAgLyoqIEF1dG9tYXRpY2FsbHkgZ2VuZXJhdGUgaW5kZXhlcyBhcyBuZWNlc3NhcnksIGlmIHVzaW5nIGFuIE1EQU8gb3IgY2FjaGUuICovXG4gICAgICBjbGFzczogJ0Jvb2xlYW4nLFxuICAgICAgZ2VuZXJhdGVKYXZhOiBmYWxzZSxcbiAgICAgIG5hbWU6ICdhdXRvSW5kZXgnLFxuICAgICAgdmFsdWU6IGZhbHNlXG4gICAgfSxcbi8vICAgICB7XG4vLyAgICAgICAvKiogQ3JlYXRlcyBhbiBpbnRlcm5hbCBNaWdyYXRpb25EQU8gYW5kIGFwcGxpZXMgdGhlIGdpdmVuIGFycmF5IG9mIE1pZ3JhdGlvblJ1bGUuICovXG4vLyAgICAgICBjbGFzczogJ0ZPYmplY3RBcnJheScsXG4vLyAgICAgICBuYW1lOiAnbWlncmF0aW9uUnVsZXMnLFxuLy8gICAgICAgb2Y6ICdmb2FtLmNvcmUuZGFvLk1pZ3JhdGlvblJ1bGUnLFxuLy8gICAgIH0sXG4gICAge1xuICAgICAgLyoqIFR1cm4gb24gdG8gYWN0aXZhdGUgc3luY2hyb25pemF0aW9uIHdpdGggYSBzZXJ2ZXIuIFNwZWNpZnkgc2VydmVyVXJpXG4gICAgICAgIGFuZCBzeW5jUHJvcGVydHkgYXMgd2VsbC4gKi9cbiAgICAgIGNsYXNzOiAnQm9vbGVhbicsXG4gICAgICBuYW1lOiAnc3luY1dpdGhTZXJ2ZXInLFxuICAgICAgZ2VuZXJhdGVKYXZhOiBmYWxzZSxcbiAgICAgIHZhbHVlOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgLyoqIFR1cm4gb24gdG8gZW5hYmxlIHJlbW90ZSBsaXN0ZW5lciBzdXBwb3J0LiBPbmx5IHVzZWZ1bCB3aXRoIGRhb1R5cGUgPSBDTElFTlQuICovXG4gICAgICBjbGFzczogJ0Jvb2xlYW4nLFxuICAgICAgZ2VuZXJhdGVKYXZhOiBmYWxzZSxcbiAgICAgIG5hbWU6ICdyZW1vdGVMaXN0ZW5lclN1cHBvcnQnLFxuICAgICAgdmFsdWU6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICAvKiogU2V0dGluZyB0byB0cnVlIGFjdGl2YXRlcyBwb2xsaW5nLCBwZXJpb2RpY2FsbHkgY2hlY2tpbmcgaW4gd2l0aFxuICAgICAgICB0aGUgc2VydmVyLiBJZiBzb2NrZXRzIGFyZSB1c2VkLCBwb2xsaW5nIGlzIG9wdGlvbmFsIGFzIHRoZSBzZXJ2ZXJcbiAgICAgICAgY2FuIHB1c2ggY2hhbmdlcyB0byB0aGlzIGNsaWVudC4gKi9cbiAgICAgIGNsYXNzOiAnQm9vbGVhbicsXG4gICAgICBnZW5lcmF0ZUphdmE6IGZhbHNlLFxuICAgICAgbmFtZTogJ3N5bmNQb2xsaW5nJyxcbiAgICAgIHZhbHVlOiB0cnVlXG4gICAgfSxcbiAgICB7XG4gICAgICAvKiogU2V0IHRvIHRydWUgaWYgeW91IGFyZSBydW5uaW5nIHRoaXMgb24gYSBzZXJ2ZXIsIGFuZCBjbGllbnRzIHdpbGxcbiAgICAgICAgc3luY2hyb25pemUgd2l0aCB0aGlzIERBTy4gKi9cbiAgICAgIGNsYXNzOiAnQm9vbGVhbicsXG4gICAgICBnZW5lcmF0ZUphdmE6IGZhbHNlLFxuICAgICAgbmFtZTogJ2lzU2VydmVyJyxcbiAgICAgIHZhbHVlOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgLyoqIFRoZSBwcm9wZXJ0eSB0byBzeW5jaHJvbml6ZSBvbi4gVGhpcyBpcyB0eXBpY2FsbHkgYW4gaW50ZWdlciB2YWx1ZVxuICAgICAgICBpbmRpY2F0aW5nIHRoZSB2ZXJzaW9uIGxhc3Qgc2VlbiBvbiB0aGUgcmVtb3RlLiAqL1xuICAgICAgbmFtZTogJ3N5bmNQcm9wZXJ0eScsXG4gICAgICBnZW5lcmF0ZUphdmE6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICAvKiogRGVzdGluYXRpb24gYWRkcmVzcyBmb3Igc2VydmVyLiAqL1xuICAgICAgbmFtZTogJ3NlcnZlckJveCcsXG4gICAgICBnZW5lcmF0ZUphdmE6IGZhbHNlLFxuICAgICAgZmFjdG9yeTogZnVuY3Rpb24oKSB7XG4gICAgICAgIC8vIFRPRE86IFRoaXMgc2hvdWxkIGNvbWUgZnJvbSB0aGUgc2VydmVyIHZpYSBhIGxvb2t1cCBmcm9tIGEgTmFtZWRCb3guXG4gICAgICAgIHJldHVybiB0aGlzLlNlc3Npb25DbGllbnRCb3guY3JlYXRlKHsgZGVsZWdhdGU6IHRoaXMuUmV0cnlCb3guY3JlYXRlKHsgZGVsZWdhdGU6XG4gICAgICAgICAgdGhpcy5UaW1lb3V0Qm94LmNyZWF0ZSh7IGRlbGVnYXRlOlxuICAgICAgICAgIHRoaXMucmVtb3RlTGlzdGVuZXJTdXBwb3J0ID9cbiAgICAgICAgICAgICAgdGhpcy5XZWJTb2NrZXRCb3guY3JlYXRlKHsgdXJpOiB0aGlzLnNlcnZpY2VOYW1lIH0pIDpcbiAgICAgICAgICAgICAgdGhpcy5IVFRQQm94LmNyZWF0ZSh7IHVybDogdGhpcy5zZXJ2aWNlTmFtZSB9KVxuICAgICAgICB9KX0pfSk7XG4gICAgICB9XG4gICAgfSxcbiAgICB7XG4gICAgICAvKiogU2ltcGxlciBhbHRlcm5hdGl2ZSB0aGFuIHByb3ZpZGluZyBzZXJ2ZXJCb3guICovXG4gICAgICBuYW1lOiAnc2VydmljZU5hbWUnLFxuICAgICAgZ2VuZXJhdGVKYXZhOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgY2xhc3M6ICdGT2JqZWN0QXJyYXknLFxuICAgICAgb2Y6ICdmb2FtLmRhby5EQU9EZWNvcmF0b3InLFxuICAgICAgZ2VuZXJhdGVKYXZhOiBmYWxzZSxcbiAgICAgIG5hbWU6ICdkZWNvcmF0b3JzJ1xuICAgIH0sXG4gICAge1xuICAgICAgbmFtZTogJ3Rlc3REYXRhJyxcbiAgICAgIGdlbmVyYXRlSmF2YTogZmFsc2VcbiAgICB9XG4gIF0sXG5cbiAgbWV0aG9kczogW1xuICAgIGZ1bmN0aW9uIGluaXQoKSB7XG4gICAgICAvKipcbiAgICAgICAgPHA+T24gaW5pdGlhbGl6YXRpb24sIHRoZSBFYXN5REFPIGNyZWF0ZXMgYW4gYXBwcm9wcmlhdGUgY2hhaW4gb2ZcbiAgICAgICAgaW50ZXJuYWwgRWFzeURBTyBpbnN0YW5jZXMgYmFzZWQgb24gdGhlIEVhc3lEQU9cbiAgICAgICAgcHJvcGVydHkgc2V0dGluZ3MuPC9wPlxuICAgICAgICA8cD5UaGlzIHByb2Nlc3MgaXMgdHJhbnNwYXJlbnQgdG8gdGhlIGRldmVsb3BlciwgYW5kIHlvdSBjYW4gdXNlIHlvdXJcbiAgICAgICAgRWFzeURBTyBsaWtlIGFueSBvdGhlciBEQU8uPC9wPlxuICAgICAgKi9cbiAgICAgIHRoaXMuU1VQRVIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblxuICAgICAgdmFyIGRhb1R5cGUgPSB0eXBlb2YgdGhpcy5kYW9UeXBlID09PSAnc3RyaW5nJyA/XG4gICAgICAgIHRoaXMuQUxJQVNFU1t0aGlzLmRhb1R5cGVdIHx8IHRoaXMuZGFvVHlwZSA6XG4gICAgICAgIHRoaXMuZGFvVHlwZTtcblxuICAgICAgdmFyIHBhcmFtcyA9IHsgb2Y6IHRoaXMub2YgfTtcblxuICAgICAgaWYgKCBkYW9UeXBlID09ICdmb2FtLmRhby5SZXF1ZXN0UmVzcG9uc2VDbGllbnREQU8nICkge1xuICAgICAgICBmb2FtLmFzc2VydCh0aGlzLmhhc093blByb3BlcnR5KCdzZXJ2ZXJCb3gnKSB8fCB0aGlzLnNlcnZpY2VOYW1lLCAnRWFzeURBTyBcImNsaWVudFwiIHR5cGUgcmVxdWlyZXMgYSBzZXJ2ZUJveCBvciBzZXJ2aWNlTmFtZScpO1xuXG4gICAgICAgIC8vIFRoZSBSZXF1ZXN0UmVzb25zZUNsaWVudERBTyBnZW5lcmF0ZXMgbGlzdGVuZXIgZXZlbnRzIGxvY2FsbHlcbiAgICAgICAgLy8gYnV0IHdpdGggcmVtb3RlTGlzdGVuZXJTdXBwb3J0LCB0aGlzIGlzbid0IG5lZWRlZCwgc28gc3dpdGNoXG4gICAgICAgIC8vIHRvIHRoZSByZWd1bGFyIENsaWVudERBTyBpbnN0ZWFkLlxuICAgICAgICBpZiAoIHRoaXMucmVtb3RlTGlzdGVuZXJTdXBwb3J0ICkge1xuICAgICAgICAgIGRhb1R5cGUgPSAnZm9hbS5kYW8uQ2xpZW50REFPJztcbiAgICAgICAgfVxuXG4gICAgICAgIHBhcmFtcy5kZWxlZ2F0ZSA9IHRoaXMuc2VydmVyQm94O1xuICAgICAgfVxuXG4gICAgICB2YXIgZGFvTW9kZWwgPSB0eXBlb2YgZGFvVHlwZSA9PT0gJ3N0cmluZycgP1xuICAgICAgICB0aGlzLmxvb2t1cChkYW9UeXBlKSB8fCBnbG9iYWxbZGFvVHlwZV0gOlxuICAgICAgICBkYW9UeXBlO1xuXG4gICAgICBpZiAoICEgZGFvTW9kZWwgKSB7XG4gICAgICAgIHRoaXMud2FybihcbiAgICAgICAgICBcIkVhc3lEQU86IFVua25vd24gREFPIFR5cGUuICBBZGQgJ1wiICsgZGFvVHlwZSArIFwiJyB0byByZXF1aXJlczogbGlzdC5cIlxuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICBpZiAoIHRoaXMubmFtZSAmJiBkYW9Nb2RlbC5nZXRBeGlvbUJ5TmFtZSgnbmFtZScpICkgcGFyYW1zLm5hbWUgPSB0aGlzLm5hbWU7XG4gICAgICBpZiAoIGRhb01vZGVsLmdldEF4aW9tQnlOYW1lKCdhdXRvSW5kZXgnKSApIHBhcmFtcy5hdXRvSW5kZXggPSB0aGlzLmF1dG9JbmRleDtcbiAgICAgIC8vaWYgKCB0aGlzLnNlcU5vIHx8IHRoaXMuZ3VpZCApIHBhcmFtcy5wcm9wZXJ0eSA9IHRoaXMuc2VxUHJvcGVydHk7XG5cbiAgICAgIHZhciBkYW8gPSBkYW9Nb2RlbC5jcmVhdGUocGFyYW1zLCB0aGlzLl9fc3ViQ29udGV4dF9fKTtcblxuICAgICAgLy8gTm90IHVzZWQgYnkgZGVjb3JhdG9ycy5cbiAgICAgIGRlbGV0ZSBwYXJhbXNbJ25hbWUnXTtcblxuICAgICAgaWYgKCB0aGlzLk1EQU8uaXNJbnN0YW5jZShkYW8pICkge1xuICAgICAgICB0aGlzLm1kYW8gPSBkYW87XG4gICAgICAgIGlmICggdGhpcy5kZWR1cCApIGRhbyA9IHRoaXMuRGVEdXBEQU8uY3JlYXRlKHtkZWxlZ2F0ZTogZGFvfSk7XG4gICAgICB9IGVsc2Uge1xuLy8gICAgICAgICBpZiAoIHRoaXMubWlncmF0aW9uUnVsZXMgJiYgdGhpcy5taWdyYXRpb25SdWxlcy5sZW5ndGggKSB7XG4vLyAgICAgICAgICAgZGFvID0gdGhpcy5NaWdyYXRpb25EQU8uY3JlYXRlKHtcbi8vICAgICAgICAgICAgIGRlbGVnYXRlOiBkYW8sXG4vLyAgICAgICAgICAgICBydWxlczogdGhpcy5taWdyYXRpb25SdWxlcyxcbi8vICAgICAgICAgICAgIG5hbWU6IHRoaXMubW9kZWwuaWQgKyBcIl9cIiArIGRhb01vZGVsLmlkICsgXCJfXCIgKyB0aGlzLm5hbWVcbi8vICAgICAgICAgICB9KTtcbi8vICAgICAgICAgfVxuICAgICAgICBpZiAoIHRoaXMuY2FjaGUgKSB7XG4gICAgICAgICAgdGhpcy5tZGFvID0gdGhpcy5NREFPLmNyZWF0ZSh7b2Y6IHBhcmFtcy5vZn0pO1xuICAgICAgICAgIGRhbyA9IHRoaXMuQ2FjaGluZ0RBTy5jcmVhdGUoe1xuICAgICAgICAgICAgY2FjaGU6IHRoaXMuZGVkdXAgP1xuICAgICAgICAgICAgICB0aGlzLm1kYW8gOlxuICAgICAgICAgICAgICB0aGlzLkRlRHVwREFPLmNyZWF0ZSh7ZGVsZWdhdGU6IHRoaXMubWRhb30pLFxuICAgICAgICAgICAgc3JjOiBkYW8sXG4gICAgICAgICAgICBvZjogdGhpcy5tb2RlbH0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICggdGhpcy5qb3VybmFsICkge1xuICAgICAgICBkYW8gPSB0aGlzLkpEQU8uY3JlYXRlKHtcbiAgICAgICAgICBkZWxlZ2F0ZTogZGFvLFxuICAgICAgICAgIGpvdXJuYWw6IHRoaXMuam91cm5hbFxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgaWYgKCB0aGlzLnNlcU5vICYmIHRoaXMuZ3VpZCApIHRocm93IFwiRWFzeURBTyAnc2VxTm8nIGFuZCAnZ3VpZCcgZmVhdHVyZXMgYXJlIG11dHVhbGx5IGV4Y2x1c2l2ZS5cIjtcblxuICAgICAgaWYgKCB0aGlzLnNlcU5vICkge1xuICAgICAgICB2YXIgYXJncyA9IHtfX3Byb3RvX186IHBhcmFtcywgZGVsZWdhdGU6IGRhbywgb2Y6IHRoaXMub2Z9O1xuICAgICAgICBpZiAoIHRoaXMuc2VxUHJvcGVydHkgKSBhcmdzLnByb3BlcnR5ID0gdGhpcy5zZXFQcm9wZXJ0eTtcbiAgICAgICAgZGFvID0gdGhpcy5TZXF1ZW5jZU51bWJlckRBTy5jcmVhdGUoYXJncyk7XG4gICAgICB9XG5cbiAgICAgIGlmICggdGhpcy5ndWlkICkge1xuICAgICAgICB2YXIgYXJncyA9IHtfX3Byb3RvX186IHBhcmFtcywgZGVsZWdhdGU6IGRhbywgb2Y6IHRoaXMub2Z9O1xuICAgICAgICBpZiAoIHRoaXMuc2VxUHJvcGVydHkgKSBhcmdzLnByb3BlcnR5ID0gdGhpcy5zZXFQcm9wZXJ0eTtcbiAgICAgICAgZGFvID0gdGhpcy5HVUlEREFPLmNyZWF0ZShhcmdzKTtcbiAgICAgIH1cblxuICAgICAgdmFyIGNscyA9IHRoaXMub2Y7XG5cbiAgICAgIGlmICggdGhpcy5zeW5jV2l0aFNlcnZlciAmJiB0aGlzLmlzU2VydmVyICkgdGhyb3cgXCJpc1NlcnZlciBhbmQgc3luY1dpdGhTZXJ2ZXIgYXJlIG11dHVhbGx5IGV4Y2x1c2l2ZS5cIjtcblxuICAgICAgaWYgKCB0aGlzLnN5bmNXaXRoU2VydmVyIHx8IHRoaXMuaXNTZXJ2ZXIgKSB7XG4gICAgICAgIGlmICggISB0aGlzLnN5bmNQcm9wZXJ0eSApIHtcbiAgICAgICAgICB0aGlzLnN5bmNQcm9wZXJ0eSA9IGNscy5TWU5DX1BST1BFUlRZO1xuICAgICAgICAgIGlmICggISB0aGlzLnN5bmNQcm9wZXJ0eSApIHtcbiAgICAgICAgICAgIHRocm93IFwiRWFzeURBTyBzeW5jIHdpdGggY2xhc3MgXCIgKyBjbHMuaWQgKyBcIiBpbnZhbGlkLiBTeW5jIHJlcXVpcmVzIGEgc3luYyBwcm9wZXJ0eSBiZSBzZXQsIG9yIGJlIG9mIGEgY2xhc3MgaW5jbHVkaW5nIGEgcHJvcGVydHkgJ3N5bmNfcHJvcGVydHknLlwiO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoIHRoaXMuc3luY1dpdGhTZXJ2ZXIgKSB7XG4gICAgICAgIGZvYW0uYXNzZXJ0KHRoaXMuc2VydmVyQm94LCAnc3luY1dpdGhTZXJ2ZXIgcmVxdWlyZXMgc2VydmVyQm94Jyk7XG5cbiAgICAgICAgZGFvID0gdGhpcy5TeW5jREFPLmNyZWF0ZSh7XG4gICAgICAgICAgcmVtb3RlREFPOiB0aGlzLlJlcXVlc3RSZXNwb25zZUNsaWVudERBTy5jcmVhdGUoe1xuICAgICAgICAgICAgICBuYW1lOiB0aGlzLm5hbWUsXG4gICAgICAgICAgICAgIGRlbGVnYXRlOiB0aGlzLnNlcnZlckJveFxuICAgICAgICAgIH0sIGJveENvbnRleHQpLFxuICAgICAgICAgIHN5bmNQcm9wZXJ0eTogdGhpcy5zeW5jUHJvcGVydHksXG4gICAgICAgICAgZGVsZWdhdGU6IGRhbyxcbiAgICAgICAgICBwb2xsaW5nRnJlcXVlbmN5OiAxMDAwXG4gICAgICAgIH0pO1xuICAgICAgICBkYW8uc3luY1JlY29yZERBTyA9IGZvYW0uZGFvLkVhc3lEQU8uY3JlYXRlKHtcbiAgICAgICAgICBvZjogZGFvLlN5bmNSZWNvcmQsXG4gICAgICAgICAgY2FjaGU6IHRydWUsXG4gICAgICAgICAgZGFvVHlwZTogdGhpcy5kYW9UeXBlLFxuICAgICAgICAgIG5hbWU6IHRoaXMubmFtZSArICdfU3luY1JlY29yZHMnXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4vLyAgICAgICBpZiAoIHRoaXMuaXNTZXJ2ZXIgKSB7XG4vLyAgICAgICAgIGRhbyA9IHRoaXMuVmVyc2lvbk5vREFPLmNyZWF0ZSh7XG4vLyAgICAgICAgICAgZGVsZWdhdGU6IGRhbyxcbi8vICAgICAgICAgICBwcm9wZXJ0eTogdGhpcy5zeW5jUHJvcGVydHksXG4vLyAgICAgICAgICAgdmVyc2lvbjogMlxuLy8gICAgICAgICB9KTtcbi8vICAgICAgIH1cblxuICAgICAgaWYgKCB0aGlzLmNvbnRleHR1YWxpemUgKSB7XG4gICAgICAgIGRhbyA9IHRoaXMuQ29udGV4dHVhbGl6aW5nREFPLmNyZWF0ZSh7ZGVsZWdhdGU6IGRhb30pO1xuICAgICAgfVxuXG4gICAgICBpZiAoIHRoaXMuZGVjb3JhdG9ycy5sZW5ndGggKSB7XG4gICAgICAgIHZhciBkZWNvcmF0ZWQgPSB0aGlzLkRlY29yYXRlZERBTy5jcmVhdGUoe1xuICAgICAgICAgIGRlY29yYXRvcjogdGhpcy5Db21wb3VuZERBT0RlY29yYXRvci5jcmVhdGUoe1xuICAgICAgICAgICAgZGVjb3JhdG9yczogdGhpcy5kZWNvcmF0b3JzXG4gICAgICAgICAgfSksXG4gICAgICAgICAgZGVsZWdhdGU6IGRhb1xuICAgICAgICB9KTtcbiAgICAgICAgZGFvID0gZGVjb3JhdGVkO1xuICAgICAgfVxuXG4gICAgICBpZiAoIHRoaXMudGltaW5nICApIHtcbiAgICAgICAgZGFvID0gdGhpcy5UaW1pbmdEQU8uY3JlYXRlKHsgbmFtZTogdGhpcy5uYW1lICsgJ0RBTycsIGRlbGVnYXRlOiBkYW8gfSk7XG4gICAgICB9XG5cbiAgICAgIGlmICggdGhpcy5sb2dnaW5nICkge1xuICAgICAgICBkYW8gPSB0aGlzLkxvZ2dpbmdEQU8uY3JlYXRlKHsgZGVsZWdhdGU6IGRhbyB9KTtcbiAgICAgIH1cblxuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgICBpZiAoIGRlY29yYXRlZCApIGRlY29yYXRlZC5kYW8gPSBkYW87XG5cbiAgICAgIGlmICggdGhpcy50ZXN0RGF0YSApIHtcbiAgICAgICAgdmFyIGRlbGVnYXRlID0gZGFvO1xuXG4gICAgICAgIGRhbyA9IHRoaXMuUHJvbWlzZWREQU8uY3JlYXRlKHtcbiAgICAgICAgICBwcm9taXNlOiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgIGRlbGVnYXRlLnNlbGVjdChzZWxmLkNPVU5UKCkpLnRoZW4oZnVuY3Rpb24oYykge1xuICAgICAgICAgICAgICAvLyBPbmx5IGxvYWQgdGVzdERhdGEgaWYgREFPIGlzIGVtcHR5XG4gICAgICAgICAgICAgIGlmICggYy52YWx1ZSApIHtcbiAgICAgICAgICAgICAgICByZXNvbHZlKGRlbGVnYXRlKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBzZWxmLmxvZyhcIkxvYWRpbmcgdGVzdCBkYXRhXCIpO1xuICAgICAgICAgICAgICBQcm9taXNlLmFsbChmb2FtLmpzb24ucGFyc2Uoc2VsZi50ZXN0RGF0YSwgc2VsZi5vZiwgc2VsZikubWFwKFxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uKG8pIHsgcmV0dXJuIGRlbGVnYXRlLnB1dChvKTsgfVxuICAgICAgICAgICAgICApKS50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHNlbGYubG9nKFwiTG9hZGVkXCIsIHNlbGYudGVzdERhdGEubGVuZ3RoLCBcInJlY29yZHMuXCIpO1xuICAgICAgICAgICAgICAgIHJlc29sdmUoZGVsZWdhdGUpO1xuICAgICAgICAgICAgICB9LCByZWplY3QpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSlcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuZGVsZWdhdGUgPSBkYW87XG4gICAgfSxcblxuICAgIC8qKiBPbmx5IHJlbGV2YW50IGlmIGNhY2hlIGlzIHRydWUgb3IgaWYgZGFvVHlwZVxuICAgICAgIHdhcyBzZXQgdG8gTURBTywgYnV0IGhhcm1sZXNzIG90aGVyd2lzZS4gR2VuZXJhdGVzIGFuIGluZGV4XG4gICAgICAgZm9yIGEgcXVlcnkgb3ZlciBhbGwgc3BlY2lmaWVkIHByb3BlcnRpZXMgdG9nZXRoZXIuXG4gICAgICAgQHBhcmFtIHZhcl9hcmdzIHNwZWNpZnkgYW55IG51bWJlciBvZiBQcm9wZXJ0aWVzIHRvIGJlIGluZGV4ZWQuXG4gICAgKi9cbiAgICB7XG4gICAgICBuYW1lOiAnYWRkUHJvcGVydHlJbmRleCcsXG4gICAgICByZXR1cm5zOiAnZm9hbS5kYW8uRWFzeURBTycsXG4gICAgICBqYXZhUmV0dXJuczogJ2ZvYW0uZGFvLkVhc3lEQU8nLFxuICAgICAgYXJnczogWyB7IGphdmFUeXBlOiAnZm9hbS5jb3JlLlByb3BlcnR5SW5mbycsIG5hbWU6ICdwcm9wJyB9IF0sXG4gICAgICBjb2RlOiAgICAgZnVuY3Rpb24gYWRkUHJvcGVydHlJbmRleCgpIHtcbiAgICAgICAgdGhpcy5tZGFvICYmIHRoaXMubWRhby5hZGRQcm9wZXJ0eUluZGV4LmFwcGx5KHRoaXMubWRhbywgYXJndW1lbnRzKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9LFxuICAgICAgamF2YUNvZGU6IGBcbmlmICggZ2V0TWRhbygpICE9IG51bGwgKSB7XG4gIGdldE1kYW8oKS5hZGRJbmRleChwcm9wKTtcbn1cbnJldHVybiB0aGlzO1xuYFxuICAgIH0sXG5cbiAgICAvKiogT25seSByZWxldmFudCBpZiBjYWNoZSBpcyB0cnVlIG9yIGlmIGRhb1R5cGVcbiAgICAgIHdhcyBzZXQgdG8gTURBTywgYnV0IGhhcm1sZXNzIG90aGVyd2lzZS4gQWRkcyBhbiBleGlzdGluZyBpbmRleFxuICAgICAgdG8gdGhlIE1EQU8uXG4gICAgICBAcGFyYW0gaW5kZXggVGhlIGluZGV4IHRvIGFkZC5cbiAgICAqL1xuICAgIHtcbiAgICAgIG5hbWU6ICdhZGRJbmRleCcsXG4gICAgICByZXR1cm5zOiAnZm9hbS5kYW8uRWFzeURBTycsXG4gICAgICBqYXZhUmV0dXJuczogJ2ZvYW0uZGFvLkVhc3lEQU8nLFxuICAgICAgYXJnczogWyB7IGphdmFUeXBlOiAnZm9hbS5kYW8uaW5kZXguSW5kZXgnLCBuYW1lOiAnaW5kZXgnIH0gXSxcbiAgICAgIGNvZGU6IGZ1bmN0aW9uIGFkZEluZGV4KGluZGV4KSB7XG4gICAgICAgIHRoaXMubWRhbyAmJiB0aGlzLm1kYW8uYWRkSW5kZXguYXBwbHkodGhpcy5tZGFvLCBhcmd1bWVudHMpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH0sXG4gICAgICBqYXZhQ29kZTogYFxuaWYgKCBnZXRNZGFvKCkgIT0gbnVsbCApIHtcbiAgZ2V0TWRhbygpLmFkZEluZGV4KGluZGV4KTtcbn1cbnJldHVybiB0aGlzO1xuYFxuICAgIH1cbiAgXVxufSk7XG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNSBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5mb2FtLkNMQVNTKHtcbiAgcGFja2FnZTogJ2ZvYW0uZGFvJyxcbiAgbmFtZTogJ05vU2VsZWN0QWxsREFPJyxcbiAgZXh0ZW5kczogJ2ZvYW0uZGFvLlByb3h5REFPJyxcblxuICByZXF1aXJlczogW1xuICAgICdmb2FtLmRhby5BcnJheVNpbmsnLFxuICAgICdmb2FtLm1sYW5nLnByZWRpY2F0ZS5UcnVlJyxcbiAgICAnZm9hbS5tbGFuZy5wcmVkaWNhdGUuRmFsc2UnXG4gIF0sXG5cbiAgZG9jdW1lbnRhdGlvbjogJ0RBTyBEZWNvcmF0b3Igd2hpY2ggcHJldmVudHMgXFwnc2VsZWN0IGFsbFxcJywgaWUuIGEgc2VsZWN0KCkgd2l0aCBubyBxdWVyeSwgbGltaXQsIG9yIHNraXAuJyxcblxuICBtZXRob2RzOiBbXG4gICAgZnVuY3Rpb24gc2VsZWN0Xyh4LCBzaW5rLCBza2lwLCBsaW1pdCwgb3JkZXIsIHByZWRpY2F0ZSkge1xuICAgICAgICBpZiAoIHByZWRpY2F0ZSAmJlxuICAgICAgICAgICAgICggISB0aGlzLlRydWUuaXNJbnN0YW5jZShwcmVkaWNhdGUpICYmXG4gICAgICAgICAgICAgICAhIHRoaXMuRmFsc2UuaXNJbnN0YW5jZShwcmVkaWNhdGUpICkgfHxcbiAgICAgICAgICAoIGZvYW0uTnVtYmVyLmlzSW5zdGFuY2UobGltaXQpICYmIE51bWJlci5pc0Zpbml0ZShsaW1pdCkgJiYgbGltaXQgIT0gMCApIHx8XG4gICAgICAgICAgKCBmb2FtLk51bWJlci5pc0luc3RhbmNlKHNraXApICYmIE51bWJlci5pc0Zpbml0ZShza2lwKSAmJiBza2lwICE9IDAgKSApIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGVsZWdhdGUuc2VsZWN0Xyh4LCBzaW5rLCBza2lwLCBsaW1pdCwgb3JkZXIsIHByZWRpY2F0ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzaW5rICYmIHNpbmsuZW9mKCk7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoc2luayB8fCB0aGlzLkFycmF5U2luay5jcmVhdGUoKSk7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIFRPRE86IHJlbW92ZUFsbD9cbiAgXVxufSk7XG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5mb2FtLkNMQVNTKHtcbiAgcGFja2FnZTogJ2ZvYW0uZGFvJyxcbiAgbmFtZTogJ051bGxEQU8nLFxuICBleHRlbmRzOiAnZm9hbS5kYW8uQWJzdHJhY3REQU8nLFxuXG4gIGRvY3VtZW50YXRpb246ICdBIE51bGwgcGF0dGVybiAoZG8tbm90aGluZykgREFPIGltcGxlbWVudGF0aW9uLicsXG5cbiAgbWV0aG9kczogW1xuICAgIHtcbiAgICAgIG5hbWU6ICdwdXRfJyxcbiAgICAgIGNvZGU6IGZ1bmN0aW9uIHB1dF8oeCwgb2JqKSB7XG4gICAgICAgIHRoaXMucHViKCdvbicsICdwdXQnLCBvYmopO1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKG9iaik7XG4gICAgICB9LFxuICAgICAgc3dpZnRDb2RlOiBgXG5fID0gb25bXCJwdXRcIl0ucHViKFtvYmpdKVxucmV0dXJuIG9ialxuICAgICAgYCxcbiAgICAgIGphdmFDb2RlOiBgXG5vblB1dChvYmopO1xucmV0dXJuIG9iajtcbiAgICAgIGAsXG4gICAgfSxcblxuICAgIHtcbiAgICAgIG5hbWU6ICdyZW1vdmVfJyxcbiAgICAgIGNvZGU6IGZ1bmN0aW9uIHJlbW92ZV8oeCwgb2JqKSB7XG4gICAgICAgIHRoaXMucHViKCdvbicsICdyZW1vdmUnLCBvYmopO1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgICB9LFxuICAgICAgc3dpZnRDb2RlOiBgXG5fID0gb25bXCJyZW1vdmVcIl0ucHViKFtvYmpdKVxucmV0dXJuIG9ialxuICAgICAgYCxcbiAgICAgIGphdmFDb2RlOiBgXG5vblJlbW92ZShvYmopO1xucmV0dXJuIG51bGw7XG4gICAgICBgLFxuICAgIH0sXG5cbiAgICB7XG4gICAgICBuYW1lOiAnZmluZF8nLFxuICAgICAgY29kZTogZnVuY3Rpb24gZmluZF8oeCwgaWQpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShudWxsKTtcbiAgICAgIH0sXG4gICAgICBzd2lmdENvZGU6ICdyZXR1cm4gbmlsJyxcbiAgICAgIGphdmFDb2RlOiAncmV0dXJuIG51bGw7JyxcbiAgICB9LFxuXG4gICAge1xuICAgICAgbmFtZTogJ3NlbGVjdF8nLFxuICAgICAgY29kZTogZnVuY3Rpb24gc2VsZWN0Xyh4LCBzaW5rLCBza2lwLCBsaW1pdCwgb3JkZXIsIHByZWRpY2F0ZSkge1xuICAgICAgICBzaW5rID0gc2luayB8fCBmb2FtLmRhby5BcnJheVNpbmsuY3JlYXRlKCk7XG4gICAgICAgIHNpbmsuZW9mKCk7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoc2luayk7XG4gICAgICB9LFxuICAgICAgc3dpZnRDb2RlOiBgXG5zaW5rLmVvZigpXG5yZXR1cm4gc2lua1xuICAgICAgYCxcbiAgICAgIGphdmFDb2RlOiBgXG5pZiAoIHNpbmsgPT0gbnVsbCApIHtcbiAgc2luayA9IG5ldyBBcnJheVNpbmsoKTtcbn1cbnNpbmsuZW9mKCk7XG5yZXR1cm4gc2luaztcbiAgICAgIGAsXG4gICAgfSxcblxuICAgIHtcbiAgICAgIG5hbWU6ICdyZW1vdmVBbGxfJyxcbiAgICAgIGNvZGU6IGZ1bmN0aW9uIHJlbW92ZUFsbF8oeCwgc2tpcCwgbGltaXQsIG9yZGVyLCBwcmVkaWNhdGUpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgICAgfSxcbiAgICAgIHN3aWZ0Q29kZTogJ3JldHVybicsXG4gICAgICBqYXZhQ29kZTogJy8vIE5PT1AnLFxuICAgIH0sXG4gIF1cbn0pO1xuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTUgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuZm9hbS5DTEFTUyh7XG4gIHBhY2thZ2U6ICdmb2FtLmRhbycsXG4gIG5hbWU6ICdUaW1pbmdEQU8nLFxuICBleHRlbmRzOiAnZm9hbS5kYW8uUHJveHlEQU8nLFxuXG4gIGRvY3VtZW50YXRpb246ICdUaW1lcyBhY2Nlc3MgdG8gdGhlIGRlbGVnYXRlIERBTzsgdXNlZnVsIGZvciBkZWJ1Z2dpbmcgYW5kIHByb2ZpbGluZy4nLFxuXG4gIHByb3BlcnRpZXM6IFtcbiAgICAnbmFtZScsXG4gICAge1xuICAgICAgbmFtZTogJ2lkJyxcbiAgICAgIHZhbHVlOiAwXG4gICAgfSxcbiAgICBbJ2FjdGl2ZU9wcycsIHtwdXQ6IDAsIHJlbW92ZTowLCBmaW5kOiAwLCBzZWxlY3Q6IDB9XSxcbiAgICB7XG4gICAgICAvKiogSGlnaCByZXNvbHV0aW9uIHRpbWUgdmFsdWUgZnVuY3Rpb24gKi9cbiAgICAgIGNsYXNzOiAnRnVuY3Rpb24nLFxuICAgICAgbmFtZTogJ25vdycsXG4gICAgICBmYWN0b3J5OiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKCBnbG9iYWwud2luZG93ICYmIGdsb2JhbC53aW5kb3cucGVyZm9ybWFuY2UgKSB7XG4gICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHdpbmRvdy5wZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoIGdsb2JhbC5wcm9jZXNzICYmIGdsb2JhbC5wcm9jZXNzLmhydGltZSApIHtcbiAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgaHIgPSBnbG9iYWwucHJvY2Vzcy5ocnRpbWUoKTtcbiAgICAgICAgICAgIHJldHVybiAoIGhyWzBdICogMTAwMCApICsgKCBoclsxXSAvIDEwMDAwMDAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkgeyByZXR1cm4gRGF0ZS5ub3coKTsgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICBdLFxuXG4gIG1ldGhvZHM6IFtcbiAgICBmdW5jdGlvbiBzdGFydChvcCkge1xuICAgICAgdmFyIHN0ciA9IHRoaXMubmFtZSArICctJyArIG9wO1xuICAgICAgdmFyIGtleSA9IHRoaXMuYWN0aXZlT3BzW29wXSsrID8gc3RyICsgJy0nICsgKHRoaXMuaWQrKykgOiBzdHI7XG4gICAgICBjb25zb2xlLnRpbWUoa2V5KTtcbiAgICAgIHJldHVybiBba2V5LCBzdHIsIHRoaXMubm93KCksIG9wXTtcbiAgICB9LFxuXG4gICAgZnVuY3Rpb24gZW5kKGFjdCkge1xuICAgICAgdGhpcy5hY3RpdmVPcHNbYWN0WzNdXS0tO1xuICAgICAgdGhpcy5pZC0tO1xuICAgICAgY29uc29sZS50aW1lRW5kKGFjdFswXSk7XG4gICAgICBjb25zb2xlLmxvZygnVGltaW5nOiAnLCBhY3RbMV0sICcgJywgKHRoaXMubm93KCktYWN0WzJdKS50b0ZpeGVkKDMpLCAnIG1zJyk7XG4gICAgfSxcblxuICAgIGZ1bmN0aW9uIHB1dF8oeCwgb2JqKSB7XG4gICAgICB2YXIgYWN0ID0gdGhpcy5zdGFydCgncHV0Jyk7XG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICByZXR1cm4gdGhpcy5TVVBFUih4LCBvYmopLnRoZW4oZnVuY3Rpb24obykgeyBzZWxmLmVuZChhY3QpOyByZXR1cm4gbzsgfSk7XG4gICAgfSxcbiAgICBmdW5jdGlvbiByZW1vdmVfKHgsIG9iaikge1xuICAgICAgdmFyIGFjdCA9IHRoaXMuc3RhcnQoJ3JlbW92ZScpO1xuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgcmV0dXJuIHRoaXMuU1VQRVIoeCwgb2JqKS50aGVuKGZ1bmN0aW9uKCkgeyBzZWxmLmVuZChhY3QpOyB9KTtcbiAgICB9LFxuICAgIGZ1bmN0aW9uIGZpbmRfKHgsIGtleSkge1xuICAgICAgdmFyIGFjdCA9IHRoaXMuc3RhcnQoJ2ZpbmQnKTtcbiAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgIHJldHVybiB0aGlzLlNVUEVSKHgsIGtleSkudGhlbihmdW5jdGlvbihvKSB7IHNlbGYuZW5kKGFjdCk7IHJldHVybiBvOyB9KTtcbiAgICB9LFxuICAgIGZ1bmN0aW9uIHNlbGVjdCgpIHtcbiAgICAgIHZhciBhY3QgPSB0aGlzLnN0YXJ0KCdzZWxlY3QnKTtcbiAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgIHJldHVybiB0aGlzLlNVUEVSLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykudGhlbihmdW5jdGlvbihzKSB7XG4gICAgICAgIHNlbGYuZW5kKGFjdCk7XG4gICAgICAgIHJldHVybiBzO1xuICAgICAgfSlcbiAgICB9XG4gIF1cbn0pO1xuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTUgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuZm9hbS5DTEFTUyh7XG4gIHBhY2thZ2U6ICdmb2FtLmRhbycsXG4gIG5hbWU6ICdMb2dnaW5nREFPJyxcbiAgZXh0ZW5kczogJ2ZvYW0uZGFvLlByb3h5REFPJyxcblxuICBkb2N1bWVudGF0aW9uOiAnREFPIERlY29yYXRvciB3aGljaCBsb2dzIGFjY2VzcyB0byB0aGUgZGVsZWdhdGU7IHVzZWZ1bCBmb3IgZGVidWdnaW5nLicsXG5cbiAgcmVxdWlyZXM6IFsgJ2ZvYW0uZGFvLkFycmF5U2luaycgXSxcblxuICBwcm9wZXJ0aWVzOiBbXG4gICAge1xuICAgICAgbmFtZTogJ25hbWUnLFxuICAgIH0sXG4gICAge1xuICAgICAgbmFtZTogJ2xvZ2dlcicsXG4gICAgICBleHByZXNzaW9uOiBmdW5jdGlvbihuYW1lKSB7XG4gICAgICAgIHJldHVybiBjb25zb2xlLmxvZy5iaW5kKGNvbnNvbGUsIG5hbWUpO1xuICAgICAgfVxuICAgIH0sXG4gICAge1xuICAgICAgY2xhc3M6ICdCb29sZWFuJyxcbiAgICAgIG5hbWU6ICdsb2dSZWFkcycsXG4gICAgICB2YWx1ZTogZmFsc2VcbiAgICB9LFxuICBdLFxuXG4gIG1ldGhvZHM6IFtcbiAgICBmdW5jdGlvbiBwdXRfKHgsIG9iaikge1xuICAgICAgdGhpcy5sb2dnZXIoJ3B1dCcsIG9iaik7XG4gICAgICByZXR1cm4gdGhpcy5TVVBFUih4LCBvYmopO1xuICAgIH0sXG5cbiAgICBmdW5jdGlvbiByZW1vdmVfKHgsIG9iaikge1xuICAgICAgdGhpcy5sb2dnZXIoJ3JlbW92ZScsIG9iaik7XG4gICAgICByZXR1cm4gdGhpcy5TVVBFUih4LCBvYmopO1xuICAgIH0sXG5cbiAgICBmdW5jdGlvbiBzZWxlY3RfKHgsIHNpbmssIHNraXAsIGxpbWl0LCBvcmRlciwgcHJlZGljYXRlKSB7XG4gICAgICB0aGlzLmxvZ2dlcignc2VsZWN0JyxcbiAgICAgICAgICAgICAgICAgICdza2lwJywgc2tpcCxcbiAgICAgICAgICAgICAgICAgICdsaW1pdCcsIGxpbWl0LFxuICAgICAgICAgICAgICAgICAgJ29yZGVyJywgb3JkZXIgJiYgb3JkZXIudG9TdHJpbmcoKSxcbiAgICAgICAgICAgICAgICAgICdwcmVkaWNhdGUnLCBwcmVkaWNhdGUgJiYgcHJlZGljYXRlLnRvU3RyaW5nKCkpO1xuICAgICAgc2luayA9IHNpbmsgfHwgdGhpcy5BcnJheVNpbmsuY3JlYXRlKCk7XG4gICAgICBpZiAoIHRoaXMubG9nUmVhZHMgKSB7XG4gICAgICAgIHZhciBwdXQgPSBzaW5rLnB1dC5iaW5kKHNpbmspO1xuICAgICAgICB2YXIgbmV3U2luayA9IHsgX19wcm90b19fOiBzaW5rIH07XG4gICAgICAgIG5ld1NpbmsucHV0ID0gZnVuY3Rpb24obykge1xuICAgICAgICAgIHRoaXMubG9nZ2VyKCdyZWFkJywgZm9hbS5qc29uLm9iamVjdGlmeShvKSk7XG4gICAgICAgICAgcmV0dXJuIHB1dC5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgICAgICB9LmJpbmQodGhpcyk7XG4gICAgICAgIHJldHVybiB0aGlzLlNVUEVSKHgsIG5ld1NpbmssIHNraXAsIGxpbWl0LCBvcmRlciwgcHJlZGljYXRlKS50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiBzaW5rO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLlNVUEVSKHgsIHNpbmssIHNraXAsIGxpbWl0LCBvcmRlciwgcHJlZGljYXRlKTtcbiAgICB9LFxuXG4gICAgZnVuY3Rpb24gcmVtb3ZlQWxsXyh4LCBzaW5rLCBza2lwLCBsaW1pdCwgb3JkZXIsIHByZWRpY2F0ZSkge1xuICAgICAgdGhpcy5sb2dnZXIoJ3JlbW92ZUFsbCcsIHNraXAsIGxpbWl0LCBvcmRlciwgcHJlZGljYXRlKTtcbiAgICAgIHJldHVybiB0aGlzLlNVUEVSKHgsIHNpbmssIHNraXAsIGxpbWl0LCBvcmRlciwgcHJlZGljYXRlKTtcbiAgICB9LFxuXG4gICAgZnVuY3Rpb24gZmluZF8oeCwgaWQpIHtcbiAgICAgIHRoaXMubG9nZ2VyKCdmaW5kJywgaWQpO1xuICAgICAgcmV0dXJuIHRoaXMuU1VQRVIoeCwgaWQpO1xuICAgIH1cbiAgXVxufSk7XG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxOCBUaGUgRk9BTSBBdXRob3JzLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKi9cblxuZm9hbS5DTEFTUyh7XG4gIHBhY2thZ2U6ICdmb2FtLmRhbycsXG4gIG5hbWU6ICdJREJJbnRlcm5hbEV4Y2VwdGlvbicsXG4gIGV4dGVuZHM6ICdmb2FtLmRhby5JbnRlcm5hbEV4Y2VwdGlvbicsXG5cbiAgLy8gVE9ETzogV2hpY2ggZXJyb3JzIGFyZSBpbnRlcm5hbCAoc3lzdGVtIHByb2JsZW1zKSB2cy4gZXh0ZXJuYWxcbiAgLy8gKGkuZS4gaW52YWxpZCBkYXRhIGZvciBjbG9uZSwgYnV0IHlvdSBjYW4gdHJ5IGFnYWluIHdpdGggZGlmZmVyZW50IGRhdGEpXG4gIHByb3BlcnRpZXM6IFtcbiAgICAnaWQnLFxuICAgICdlcnJvcicsXG4gICAge1xuICAgICAgbmFtZTogJ21lc3NhZ2UnLFxuICAgICAgZXhwcmVzc2lvbjogZnVuY3Rpb24oaWQsIGVycm9yKSB7XG4gICAgICAgIHJldHVybiBcIkluZGV4ZWREQiBFcnJvciBmb3IgXCIgKyBpZCArXG4gICAgICAgICAgKCBlcnJvciA/IFwiOiBcIiArIGVycm9yLnRvU3RyaW5nKCkgOiBcIlwiICk7XG4gICAgICB9XG4gICAgfVxuICBdXG59KTtcbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbi8qXG5UT0RPOlxuLXZlcmlmeSB0aGF0IG11bHRpIHBhcnQga2V5cyB3b3JrIHByb3Blcmx5XG4qL1xuZm9hbS5DTEFTUyh7XG4gIHBhY2thZ2U6ICdmb2FtLmRhbycsXG4gIG5hbWU6ICdJREJEQU8nLFxuICBleHRlbmRzOiAnZm9hbS5kYW8uQWJzdHJhY3REQU8nLFxuXG4gIHJlcXVpcmVzOiBbXG4gICAgJ2ZvYW0uZGFvLkFycmF5U2luaycsXG4gICAgJ2ZvYW0uZGFvLklEQkludGVybmFsRXhjZXB0aW9uJyxcbiAgICAnZm9hbS5tbGFuZy5wcmVkaWNhdGUuVHJ1ZScsXG4gICAgJ2ZvYW0ubWxhbmcucHJlZGljYXRlLkVxJ1xuICBdLFxuXG4gIGltcG9ydHM6IFtcbiAgICAnYXN5bmMnXG4gIF0sXG5cbiAgcHJvcGVydGllczogW1xuICAgIHtcbiAgICAgIG5hbWU6ICdvZicsXG4gICAgICByZXF1aXJlZDogdHJ1ZVxuICAgIH0sXG4gICAge1xuICAgICAgbmFtZTogICduYW1lJyxcbiAgICAgIGxhYmVsOiAnU3RvcmUgTmFtZScsXG4gICAgICBmYWN0b3J5OiBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMub2YuaWQ7IH1cbiAgICB9LFxuICAgIHtcbiAgICAgIG5hbWU6ICdpbmRpY2llcycsXG4gICAgICBmYWN0b3J5OiBmdW5jdGlvbigpIHsgcmV0dXJuIFtdOyB9XG4gICAgfSxcbiAgICB7XG4gICAgICBuYW1lOiAndmVyc2lvbicsXG4gICAgICB2YWx1ZTogMVxuICAgIH0sXG4gICAge1xuICAgICAgLyoqIFRoZSBmdXR1cmUgdGhhdCBob2xkcyB0aGUgb3BlbiBEQi4gQ2FsbCB0aGlzLndpdGhEQi50aGVuKGZ1bmN0aW9uKGRiKSB7IC4uLiB9KTsgKi9cbiAgICAgIG5hbWU6ICd3aXRoREInLFxuICAgICAgZmFjdG9yeTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgdmFyIGluZGV4ZWREQiA9IGdsb2JhbC5pbmRleGVkREIgfHxcbiAgICAgICAgICAgIGdsb2JhbC53ZWJraXRJbmRleGVkREIgICAgICAgICB8fFxuICAgICAgICAgICAgZ2xvYmFsLm1vekluZGV4ZWREQjtcblxuICAgICAgICAgIHZhciByZXF1ZXN0ID0gaW5kZXhlZERCLm9wZW4oXCJGT0FNOlwiICsgc2VsZi5uYW1lLCBzZWxmLnZlcnNpb24pO1xuXG4gICAgICAgICAgcmVxdWVzdC5vbnVwZ3JhZGVuZWVkZWQgPSBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICB2YXIgZGIgPSBlLnRhcmdldC5yZXN1bHQ7XG5cbiAgICAgICAgICAgIC8vIEZVVFVSRTogUHJvdmlkZSBtaWdyYXRpb24gc3VwcG9ydCBoZXJlPyAgT3IganVzdCBoYXZlIHBlb3BsZSBjcmVhdGUgYSBuZXcgZGFvP1xuICAgICAgICAgICAgaWYgKCBkYi5vYmplY3RTdG9yZU5hbWVzLmNvbnRhaW5zKHNlbGYubmFtZSkgKSB7XG4gICAgICAgICAgICAgIGRiLmRlbGV0ZU9iamVjdFN0b3JlKHNlbGYubmFtZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBzdG9yZSA9IGUudGFyZ2V0LnJlc3VsdC5jcmVhdGVPYmplY3RTdG9yZShzZWxmLm5hbWUpO1xuICAgICAgICAgICAgZm9yICggdmFyIGkgPSAwOyBpIDwgc2VsZi5pbmRpY2llcy5sZW5ndGg7IGkrKyApIHtcbiAgICAgICAgICAgICAgc3RvcmUuY3JlYXRlSW5kZXgoXG4gICAgICAgICAgICAgICAgICBzZWxmLmluZGljaWVzW2ldWzBdLFxuICAgICAgICAgICAgICAgICAgc2VsZi5pbmRpY2llc1tpXVswXSxcbiAgICAgICAgICAgICAgICAgIHsgdW5pcXVlOiBzZWxmLmluZGljaWVzW2ldWzFdIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHJlcXVlc3Qub25zdWNjZXNzID0gZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgcmVzb2x2ZShlLnRhcmdldC5yZXN1bHQpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJlcXVlc3Qub25lcnJvciA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICByZWplY3Qoc2VsZi5JREJJbnRlcm5hbEV4Y2VwdGlvbi5jcmVhdGUoeyBpZDogJ29wZW4nLCBlcnJvcjogZSB9KSk7XG4gICAgICAgICAgfTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSxcbiAgXSxcblxuICBtZXRob2RzOiBbXG4gICAgZnVuY3Rpb24gZGVzZXJpYWxpemUoanNvbikge1xuICAgICAgcmV0dXJuIGZvYW0uanNvbi5wYXJzZShqc29uLCB0aGlzLm9mLCB0aGlzLl9fc3ViQ29udGV4dF9fKTtcbiAgICB9LFxuXG4gICAgZnVuY3Rpb24gc2VyaWFsaXplKG9iaikge1xuICAgICAgcmV0dXJuIGZvYW0uanNvbi5TdG9yYWdlLm9iamVjdGlmeShvYmopO1xuICAgIH0sXG4gICAgZnVuY3Rpb24gc2VyaWFsaXplSWQoaWQpIHtcbiAgICAgIHJldHVybiB0aGlzLm9mLklELnRvSlNPTihpZCk7XG4gICAgfSxcblxuICAgIGZ1bmN0aW9uIHdpdGhTdG9yZShtb2RlLCBmbikge1xuICAgICAgcmV0dXJuIHRoaXMud2l0aFN0b3JlXyhtb2RlLCBmbik7XG4gICAgICBpZiAoIG1vZGUgIT09ICdyZWFkd3JpdGUnICkgcmV0dXJuIHRoaXMud2l0aFN0b3JlXyhtb2RlLCBmbik7XG5cbiAgICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgICAgaWYgKCAhIHRoaXMucV8gKSB7XG4gICAgICAgIHZhciBxID0gW2ZuXTtcbiAgICAgICAgdGhpcy5xXyA9IHE7XG4gICAgICAgIHRoaXMuYXN5bmMoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgc2VsZi53aXRoU3RvcmVfKG1vZGUsIGZ1bmN0aW9uKHN0b3JlKSB7XG4gICAgICAgICAgICAvLyBjb25zb2xlLmxvZygncSBsZW5ndGg6ICcsIHEubGVuZ3RoKTtcbiAgICAgICAgICAgIGlmICggc2VsZi5xXyA9PSBxICkgc2VsZi5xXyA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGZvciAoIHZhciBpID0gMCA7IGkgPCBxLmxlbmd0aCA7IGkrKyApIHFbaV0oc3RvcmUpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KSgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5xXy5wdXNoKGZuKTtcbiAgICAgICAgLy8gRGltaW5pc2hpbmcgcmV0dXJucyBhZnRlciAxMDAwMCBwZXIgYmF0Y2hcbiAgICAgICAgaWYgKCB0aGlzLnFfLmxlbmd0aCA9PSAxMDAwMCApIHRoaXMucV8gPSB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgfSxcblxuICAgIGZ1bmN0aW9uIHdpdGhTdG9yZV8obW9kZSwgZm4pIHtcbiAgICAgIC8vIE5PVEU6IExhcmdlIG51bWJlcnMgb2YgaW5zZXJ0aW9ucyBjYW4gYmUgbWFkZVxuICAgICAgLy8gZmFzdGVyIGJ5IGtlZXBpbmcgdGhlIHRyYW5zYWN0aW9uIGJldHdlZW4gcHV0cy5cbiAgICAgIC8vIEJ1dCBkdWUgdG8gUHJvbWlzZXMgYmVpbmcgYXN5bmMsIHRoZSB0cmFuc2FjdGlvblxuICAgICAgLy8gaXMgdXN1YWxseSBjbG9zZWQgYnkgdGhlIG5leHQgcHV0LlxuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgc2VsZi53aXRoREIudGhlbihmdW5jdGlvbiAoZGIpIHtcbiAgICAgICAgdmFyIHR4ID0gZGIudHJhbnNhY3Rpb24oW3NlbGYubmFtZV0sIG1vZGUpO1xuICAgICAgICB2YXIgb3MgPSB0eC5vYmplY3RTdG9yZShzZWxmLm5hbWUpO1xuICAgICAgICBmbi5jYWxsKHNlbGYsIG9zKTtcbiAgICAgIH0pO1xuICAgIH0sXG5cbiAgICBmdW5jdGlvbiBwdXRfKHgsIHZhbHVlKSB7XG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIHNlbGYud2l0aFN0b3JlKFwicmVhZHdyaXRlXCIsIGZ1bmN0aW9uKHN0b3JlKSB7XG4gICAgICAgICAgdmFyIHJlcXVlc3QgPSBzdG9yZS5wdXQoc2VsZi5zZXJpYWxpemUodmFsdWUpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuc2VyaWFsaXplSWQodmFsdWUuaWQpKTtcbiAgICAgICAgICByZXF1ZXN0LnRyYW5zYWN0aW9uLmFkZEV2ZW50TGlzdGVuZXIoXG4gICAgICAgICAgICAnY29tcGxldGUnLFxuICAgICAgICAgICAgZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgICBzZWxmLnB1Yignb24nLCdwdXQnLCB2YWx1ZSk7XG4gICAgICAgICAgICAgIHJlc29sdmUodmFsdWUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgcmVxdWVzdC50cmFuc2FjdGlvbi5hZGRFdmVudExpc3RlbmVyKFxuICAgICAgICAgICAgJ2Vycm9yJyxcbiAgICAgICAgICAgIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgcmVqZWN0KHNlbGYuSURCSW50ZXJuYWxFeGNlcHRpb24uY3JlYXRlKHsgaWQ6IHZhbHVlLmlkLCBlcnJvcjogZSB9KSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9LFxuXG4gICAgZnVuY3Rpb24gZmluZF8oeCwgb2JqKSB7XG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICB2YXIga2V5ID0gdGhpcy5zZXJpYWxpemVJZChvYmouaWQgIT09IHVuZGVmaW5lZCA/IG9iai5pZCA6IG9iaik7XG5cbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgc2VsZi53aXRoU3RvcmUoXCJyZWFkd3JpdGVcIiwgZnVuY3Rpb24oc3RvcmUpIHtcbiAgICAgICAgICB2YXIgcmVxdWVzdCA9IHN0b3JlLmdldChrZXkpO1xuICAgICAgICAgIHJlcXVlc3QudHJhbnNhY3Rpb24uYWRkRXZlbnRMaXN0ZW5lcihcbiAgICAgICAgICAgICdjb21wbGV0ZScsXG4gICAgICAgICAgICBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgaWYgKCFyZXF1ZXN0LnJlc3VsdCkge1xuICAgICAgICAgICAgICAgIHJlc29sdmUobnVsbCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHZhciByZXN1bHQgPSBzZWxmLmRlc2VyaWFsaXplKHJlcXVlc3QucmVzdWx0KTtcbiAgICAgICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgcmVxdWVzdC5vbmVycm9yID0gZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgcmVqZWN0KHNlbGYuSURCSW50ZXJuYWxFeGNlcHRpb24uY3JlYXRlKHsgaWQ6IGtleSwgZXJyb3I6IGUgfSkpO1xuICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfSxcblxuICAgIGZ1bmN0aW9uIHJlbW92ZV8oeCwgb2JqKSB7XG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICB2YXIga2V5ID0gdGhpcy5zZXJpYWxpemVJZChvYmouaWQgIT09IHVuZGVmaW5lZCA/IG9iai5pZCA6IG9iaik7XG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIHNlbGYud2l0aFN0b3JlKFwicmVhZHdyaXRlXCIsIGZ1bmN0aW9uKHN0b3JlKSB7XG4gICAgICAgICAgdmFyIGdldFJlcXVlc3QgPSBzdG9yZS5nZXQoa2V5KTtcbiAgICAgICAgICBnZXRSZXF1ZXN0Lm9uc3VjY2VzcyA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgIGlmICghZ2V0UmVxdWVzdC5yZXN1bHQpIHtcbiAgICAgICAgICAgICAgLy8gbm90IGZvdW5kPyBhcyBnb29kIGFzIHJlbW92ZWQhXG4gICAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGRhdGEgPSBzZWxmLmRlc2VyaWFsaXplKGdldFJlcXVlc3QucmVzdWx0KTtcbiAgICAgICAgICAgIHZhciBkZWxSZXF1ZXN0ID0gc3RvcmUuZGVsZXRlKGtleSk7XG4gICAgICAgICAgICBkZWxSZXF1ZXN0LnRyYW5zYWN0aW9uLmFkZEV2ZW50TGlzdGVuZXIoJ2NvbXBsZXRlJywgZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgICBzZWxmLnB1Yignb24nLCdyZW1vdmUnLCBkYXRhKTtcbiAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGRlbFJlcXVlc3Qub25lcnJvciA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgcmVqZWN0KHNlbGYuSURCSW50ZXJuYWxFeGNlcHRpb24uY3JlYXRlKHsgaWQ6IGtleSwgZXJyb3I6IGUgfSkpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9O1xuICAgICAgICAgIGdldFJlcXVlc3Qub25lcnJvciA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgIHJlamVjdChzZWxmLklEQkludGVybmFsRXhjZXB0aW9uLmNyZWF0ZSh7IGlkOiBrZXksIGVycm9yOiBlIH0pKTtcbiAgICAgICAgICB9O1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH0sXG5cbiAgICBmdW5jdGlvbiByZW1vdmVBbGxfKHgsIHNraXAsIGxpbWl0LCBvcmRlciwgcHJlZGljYXRlKSB7XG4gICAgICB2YXIgcXVlcnkgPSBwcmVkaWNhdGUgfHwgdGhpcy5UcnVlLmNyZWF0ZSgpO1xuXG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICAgIC8vIElmIHRoZSBjYWxsZXIgZG9lc24ndCBjYXJlIHRvIHNlZSB0aGUgb2JqZWN0cyBhcyB0aGV5IGdldCByZW1vdmVkLFxuICAgICAgLy8gdGhlbiBqdXN0IG51a2UgdGhlbSBpbiBvbmUgZ28uXG4gICAgICBpZiAoICEgcHJlZGljYXRlICYmICEgc2VsZi5oYXNMaXN0ZW5lcnMoJ29uJywgJ3JlbW92ZScpICkge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgc2VsZi53aXRoU3RvcmUoJ3JlYWR3cml0ZScsIGZ1bmN0aW9uKHN0b3JlKSB7XG4gICAgICAgICAgICB2YXIgcmVxID0gc3RvcmUuY2xlYXIoKTtcbiAgICAgICAgICAgIHJlcS5vbnN1Y2Nlc3MgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJlcS5vbmVycm9yID0gZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgICByZWplY3Qoc2VsZi5JREJJbnRlcm5hbEV4Y2VwdGlvbi5jcmVhdGUoeyBpZDogJ3JlbW92ZV9hbGwnLCBlcnJvcjogZSB9KSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIHNlbmQgaXRlbXMgdG8gdGhlIHNpbmsgYW5kIHJlbW92ZSBvbmUgYnkgb25lXG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICBzZWxmLndpdGhTdG9yZSgncmVhZHdyaXRlJywgZnVuY3Rpb24oc3RvcmUpIHtcbiAgICAgICAgICAgIHZhciByZXF1ZXN0ID0gc3RvcmUub3BlbkN1cnNvcigpO1xuICAgICAgICAgICAgcmVxdWVzdC5vbnN1Y2Nlc3MgPSBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgIHZhciBjdXJzb3IgPSBlLnRhcmdldC5yZXN1bHQ7XG4gICAgICAgICAgICAgIGlmIChjdXJzb3IpIHtcbiAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBzZWxmLmRlc2VyaWFsaXplKGN1cnNvci52YWx1ZSk7XG4gICAgICAgICAgICAgICAgaWYgKHF1ZXJ5LmYodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgZGVsZXRlUmVxID0gY3Vyc29yLmRlbGV0ZSgpO1xuICAgICAgICAgICAgICAgICAgZGVsZXRlUmVxLmFkZEV2ZW50TGlzdGVuZXIoXG4gICAgICAgICAgICAgICAgICAgICdzdWNjZXNzJyxcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgc2VsZi5wdWIoJ29uJywncmVtb3ZlJywgdmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgIGRlbGV0ZVJlcS5vbmVycm9yID0gZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY3Vyc29yLmNvbnRpbnVlKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXF1ZXN0LnRyYW5zYWN0aW9uLmFkZEV2ZW50TGlzdGVuZXIoJ2NvbXBsZXRlJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmVxdWVzdC5vbmVycm9yID0gZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgICByZWplY3Qoc2VsZi5JREJJbnRlcm5hbEV4Y2VwdGlvbi5jcmVhdGUoeyBpZDogJ3JlbW92ZV9hbGwnLCBlcnJvcjogZSB9KSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgZnVuY3Rpb24gc2VsZWN0Xyh4LCBzaW5rLCBza2lwLCBsaW1pdCwgb3JkZXIsIHByZWRpY2F0ZSkge1xuICAgICAgdmFyIHJlc3VsdFNpbmsgPSBzaW5rIHx8IHRoaXMuQXJyYXlTaW5rLmNyZWF0ZSgpO1xuICAgICAgc2luayA9IHRoaXMuZGVjb3JhdGVTaW5rXyhyZXN1bHRTaW5rLCBza2lwLCBsaW1pdCwgb3JkZXIsIHByZWRpY2F0ZSk7XG5cbiAgICAgIHZhciBzdWIgPSBmb2FtLmNvcmUuRk9iamVjdC5jcmVhdGUoKTtcbiAgICAgIHZhciBkZXRhY2hlZCA9IGZhbHNlO1xuICAgICAgc3ViLm9uRGV0YWNoKGZ1bmN0aW9uKCkgeyBkZXRhY2hlZCA9IHRydWU7IH0pO1xuXG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgc2VsZi53aXRoU3RvcmUoXCJyZWFkd3JpdGVcIiwgZnVuY3Rpb24oc3RvcmUpIHtcbiAgICAgICAgICB2YXIgdXNlSW5kZXggPSBwcmVkaWNhdGUgJiZcbiAgICAgICAgICAgIHRoaXMuRXEuaXNJbnN0YW5jZShwcmVkaWNhdGUpICYmXG4gICAgICAgICAgICBzdG9yZS5pbmRleE5hbWVzLmNvbnRhaW5zKHByZWRpY2F0ZS5hcmcxLm5hbWUpO1xuXG4gICAgICAgICAgdmFyIHJlcXVlc3QgPSB1c2VJbmRleCA/XG4gICAgICAgICAgICBzdG9yZS5pbmRleChwcmVkaWNhdGUuYXJnMS5uYW1lKS5vcGVuQ3Vyc29yKElEQktleVJhbmdlLm9ubHkocHJlZGljYXRlLmFyZzIuZigpKSkgOlxuICAgICAgICAgICAgc3RvcmUub3BlbkN1cnNvcigpIDtcblxuICAgICAgICAgIHJlcXVlc3Qub25zdWNjZXNzID0gZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgdmFyIGN1cnNvciA9IGUudGFyZ2V0LnJlc3VsdDtcbiAgICAgICAgICAgIGlmICggZS50YXJnZXQuZXJyb3IgKSB7XG4gICAgICAgICAgICAgIHJlamVjdChlLnRhcmdldC5lcnJvcik7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCAhIGN1cnNvciB8fCBkZXRhY2hlZCApIHtcbiAgICAgICAgICAgICAgc2luay5lb2YgJiYgc2luay5lb2YoKTtcbiAgICAgICAgICAgICAgcmVzb2x2ZShyZXN1bHRTaW5rKTtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgdmFsdWUgPSBzZWxmLmRlc2VyaWFsaXplKGN1cnNvci52YWx1ZSk7XG4gICAgICAgICAgICBzaW5rLnB1dCh2YWx1ZSwgc3ViKTtcbiAgICAgICAgICAgIGN1cnNvci5jb250aW51ZSgpO1xuICAgICAgICAgIH07XG4gICAgICAgICAgcmVxdWVzdC5vbmVycm9yID0gZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgcmVqZWN0KHNlbGYuSURCSW50ZXJuYWxFeGNlcHRpb24uY3JlYXRlKHsgaWQ6ICdzZWxlY3QnLCBlcnJvcjogZSB9KSk7XG4gICAgICAgICAgfTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9LFxuXG4gICAgZnVuY3Rpb24gYWRkSW5kZXgocHJvcCkge1xuICAgICAgdGhpcy5pbmRpY2llcy5wdXNoKFtwcm9wLm5hbWUsIGZhbHNlXSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIF1cbn0pO1xuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgVGhlIEZPQU0gQXV0aG9ycy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuZm9hbS5FTlVNKHtcbiAgcGFja2FnZTogJ2ZvYW0uZGFvJyxcbiAgbmFtZTogJ0lEQk11dGF0aW9uVHlwZScsXG5cbiAgdmFsdWVzOiBbXG4gICAge1xuICAgICAgbmFtZTogJ1BVVCcsXG4gICAgICBsYWJlbDogJ3B1dCdcbiAgICB9LFxuICAgIHtcbiAgICAgIG5hbWU6ICdSRU1PVkUnLFxuICAgICAgbGFiZWw6ICdyZW1vdmUnXG4gICAgfVxuICBdXG59KTtcblxuZm9hbS5DTEFTUyh7XG4gIHBhY2thZ2U6ICdmb2FtLmRhbycsXG4gIG5hbWU6ICdJREJNdXRhdGlvbicsXG5cbiAgcHJvcGVydGllczogW1xuICAgIHtcbiAgICAgIGNsYXNzOiAnRW51bScsXG4gICAgICBvZjogJ2ZvYW0uZGFvLklEQk11dGF0aW9uVHlwZScsXG4gICAgICBuYW1lOiAndHlwZSdcbiAgICB9LFxuICAgIHtcbiAgICAgIGRvY3VtZW50YXRpb246ICdEYXRhIHRvIGJlIHB1dCBvciByZW1vdmVkLicsXG4gICAgICBuYW1lOiAnZGF0YSdcbiAgICB9LFxuICAgIHtcbiAgICAgIGNsYXNzOiAnRnVuY3Rpb24nLFxuICAgICAgZG9jdW1lbnRhdGlvbjogJ1Jlc29sdmUgZnVuY3Rpb24gZm9yIERBTyBvcGVyYXRpb24gcHJvbWlzZS4nLFxuICAgICAgbmFtZTogJ3Jlc29sdmUnXG4gICAgfSxcbiAgICB7XG4gICAgICBjbGFzczogJ0Z1bmN0aW9uJyxcbiAgICAgIGRvY3VtZW50YXRpb246ICdSZWplY3QgZnVuY3Rpb24gZm9yIERBTyBvcGVyYXRpb24gcHJvbWlzZS4nLFxuICAgICAgbmFtZTogJ3JlamVjdCdcbiAgICB9XG4gIF1cbn0pO1xuXG5mb2FtLkNMQVNTKHtcbiAgcGFja2FnZTogJ2ZvYW0uZGFvJyxcbiAgbmFtZTogJ0JhdGNoTXV0YXRpb25JREJEQU8nLFxuICBleHRlbmRzOiAnZm9hbS5kYW8uSURCREFPJyxcblxuICBkb2N1bWVudGF0aW9uOiBgSW5kZXhlZCBEQiBEQU8gdGhhdCBiYXRjaGVzIHB1dCgpIGFuZCByZW1vdmUoKS4gVGhpcyBpbXByb3Zlc1xuICAgICAgcGVyZm9ybWFuY2UgYnkgZGVjcmVhc2luZyB0aGUgbnVtYmVyIG9mIHRyYW5zYWN0aW9ucyBjcmVhdGVkIGZvciB3cml0ZXMuYCxcblxuICByZXF1aXJlczogW1xuICAgICdmb2FtLmRhby5JREJNdXRhdGlvbicsXG4gICAgJ2ZvYW0uZGFvLklEQk11dGF0aW9uVHlwZSdcbiAgXSxcblxuICBwcm9wZXJ0aWVzOiBbXG4gICAge1xuICAgICAgY2xhc3M6ICdJbnQnLFxuICAgICAgZG9jdW1lbnRhdGlvbjogYE1heGltdW0gbnVtYmVyIG9mIG9wZXJhdGlvbnMgdG8gaW5jbHVkZSBpbiBhIGJhdGNoLmAsXG4gICAgICBuYW1lOiAnYmF0Y2hTaXplJyxcbiAgICAgIHZhbHVlOiAxMDAwXG4gICAgfSxcbiAgICB7XG4gICAgICBjbGFzczogJ0ludCcsXG4gICAgICBkb2N1bWVudGF0aW9uOiBgTWF4aW11bSBudW1iZXIgb2YgaW4tZmxpZ2h0IGJhdGNoZXNcbiAgICAgICAgICAoaS5lLiwgdHJhbnNhY3Rpb25zKS4gRGVmYXVsdCB0byAxIGluIGNhc2UgY2xpZW50cyBleHBlY3Qgc3RyaWN0XG4gICAgICAgICAgb3JkZXJpbmcgb2Ygb3BlcmF0aW9ucy5gLFxuICAgICAgbmFtZTogJ251bUJhdGNoZXMnLFxuICAgICAgdmFsdWU6IDFcbiAgICB9LFxuICAgIHtcbiAgICAgIGNsYXNzOiAnRk9iamVjdEFycmF5JyxcbiAgICAgIG9mOiAnZm9hbS5kYW8uSURCTXV0YXRpb24nLFxuICAgICAgbmFtZTogJ211dGF0aW9uc18nXG4gICAgfSxcbiAgICB7XG4gICAgICBjbGFzczogJ0ludCcsXG4gICAgICBkb2N1bWVudGF0aW9uOiAnTnVtYmVyIG9mIGluLWZsaWdodCB0cmFuc2FjdGlvbnMuJyxcbiAgICAgIG5hbWU6ICdudW1BY3RpdmVUcmFuc2FjdGlvbnNfJ1xuICAgIH1cbiAgXSxcblxuICBtZXRob2RzOiBbXG4gICAgZnVuY3Rpb24gcHV0Xyh4LCBvKSB7XG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIHNlbGYubXV0YXRpb25zXy5wdXNoKHNlbGYuSURCTXV0YXRpb24uY3JlYXRlKHtcbiAgICAgICAgICB0eXBlOiBzZWxmLklEQk11dGF0aW9uVHlwZS5QVVQsXG4gICAgICAgICAgZGF0YTogbyxcbiAgICAgICAgICByZXNvbHZlOiBmdW5jdGlvbihyZXN1bHQpIHtcbiAgICAgICAgICAgIHNlbGYucHViKCdvbicsICdwdXQnLCByZXN1bHQpO1xuICAgICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgcmVqZWN0OiByZWplY3RcbiAgICAgICAgfSkpO1xuICAgICAgICBzZWxmLm9uQmF0Y2hlZE9wZXJhdGlvbigpO1xuICAgICAgfSk7XG4gICAgfSxcbiAgICBmdW5jdGlvbiByZW1vdmVfKHgsIG8pIHtcbiAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgc2VsZi5tdXRhdGlvbnNfLnB1c2goc2VsZi5JREJNdXRhdGlvbi5jcmVhdGUoe1xuICAgICAgICAgIHR5cGU6IHNlbGYuSURCTXV0YXRpb25UeXBlLlJFTU9WRSxcbiAgICAgICAgICBkYXRhOiBvLFxuICAgICAgICAgIHJlc29sdmU6IGZ1bmN0aW9uKGRpZFJlbW92ZSkge1xuICAgICAgICAgICAgaWYgKCBkaWRSZW1vdmUgKSBzZWxmLnB1Yignb24nLCAncmVtb3ZlJywgbyk7XG4gICAgICAgICAgICByZXNvbHZlKG8pO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgcmVqZWN0OiByZWplY3RcbiAgICAgICAgfSkpO1xuICAgICAgICBzZWxmLm9uQmF0Y2hlZE9wZXJhdGlvbigpO1xuICAgICAgfSk7XG4gICAgfSxcbiAgICBmdW5jdGlvbiBiZWdpbkJhdGNoVHJhbnNhY3Rpb24oKSB7XG4gICAgICBpZiAoIHRoaXMubXV0YXRpb25zXy5sZW5ndGggPT09IDAgKSByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG5cbiAgICAgIHZhciBtdXRhdGlvbnMgPSB0aGlzLm11dGF0aW9uc18uc2xpY2UoMCwgdGhpcy5iYXRjaFNpemUpO1xuICAgICAgdGhpcy5tdXRhdGlvbnNfID0gdGhpcy5tdXRhdGlvbnNfLnNsaWNlKHRoaXMuYmF0Y2hTaXplKTtcblxuICAgICAgdGhpcy5udW1BY3RpdmVUcmFuc2FjdGlvbnNfKys7XG5cbiAgICAgIHZhciBkZWxldGVzID0gW107XG4gICAgICBmb3IgKCB2YXIgaSA9IDA7IGkgPCBtdXRhdGlvbnMubGVuZ3RoOyBpKysgKSB7XG4gICAgICAgIGlmICggbXV0YXRpb25zW2ldLnR5cGUgPT09IHRoaXMuSURCTXV0YXRpb25UeXBlLlJFTU9WRSApXG4gICAgICAgIGRlbGV0ZXMucHVzaChtdXRhdGlvbnNbaV0pO1xuICAgICAgfVxuICAgICAgaWYgKCBkZWxldGVzLmxlbmd0aCA9PT0gMCApXG4gICAgICAgIHJldHVybiB0aGlzLm9uR2F0aGVyZWREZWxldGVzKG11dGF0aW9ucywgW10pLlxuICAgICAgICAgICAgdGhlbih0aGlzLm9uVHJhbnNhY3Rpb25Db21wbGV0ZSkuXG4gICAgICAgICAgICBjYXRjaCh0aGlzLm9uVHJhbnNhY3Rpb25FcnJvcik7XG5cbiAgICAgIHZhciBwcm9taXNlcyA9IG5ldyBBcnJheShkZWxldGVzLmxlbmd0aCk7XG4gICAgICBmb3IgKCB2YXIgaSA9IDA7IGkgPCBkZWxldGVzLmxlbmd0aDsgaSsrICkge1xuICAgICAgICBwcm9taXNlc1tpXSA9IHRoaXMuZmluZChkZWxldGVzW2ldKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIFByb21pc2UuYWxsKHByb21pc2VzKS5cbiAgICAgICAgICB0aGVuKHRoaXMub25HYXRoZXJlZERlbGV0ZXMuYmluZCh0aGlzLCBtdXRhdGlvbnMpKS5cbiAgICAgICAgICB0aGVuKHRoaXMub25UcmFuc2FjdGlvbkNvbXBsZXRlKS5cbiAgICAgICAgICBjYXRjaCh0aGlzLm9uVHJhbnNhY3Rpb25FcnJvcik7XG4gICAgfVxuICBdLFxuXG4gIGxpc3RlbmVyczogW1xuICAgIHtcbiAgICAgIG5hbWU6ICdvbkJhdGNoZWRPcGVyYXRpb24nLFxuICAgICAgaXNNZXJnZWQ6IHRydWUsXG4gICAgICBtZXJnZURlbGF5OiAxNTAsXG4gICAgICBjb2RlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgZm9hbS5hc3NlcnQoXG4gICAgICAgICAgICB0aGlzLm11dGF0aW9uc18ubGVuZ3RoID4gMCxcbiAgICAgICAgICAgICdCYXRjaGVkTXV0YXRpb25JREJEQU86IEF0dGVtcHQgdG8gYmF0Y2ggbm8gb3BlcmF0aW9ucycpO1xuXG4gICAgICAgIHZhciBwcm9taXNlcyA9IFtdO1xuICAgICAgICBmb3IgKCB2YXIgaSA9IHRoaXMubnVtQWN0aXZlVHJhbnNhY3Rpb25zXzsgaSA8IHRoaXMubnVtQmF0Y2hlczsgaSsrICkge1xuICAgICAgICAgIHRoaXMuYmVnaW5CYXRjaFRyYW5zYWN0aW9uKCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gUHJvbWlzZS5hbGwocHJvbWlzZXMpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBmdW5jdGlvbiBvbkdhdGhlcmVkRGVsZXRlcyhtdXRhdGlvbnMsIGRlbGV0ZXNGb3VuZCkge1xuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBzZWxmLndpdGhTdG9yZSgncmVhZHdyaXRlJywgZnVuY3Rpb24oc3RvcmUpIHtcbiAgICAgICAgICB2YXIgZGVsZXRlc0kgPSAwO1xuICAgICAgICAgIGZvciAoIHZhciBpID0gMDsgaSA8IG11dGF0aW9ucy5sZW5ndGg7IGkrKyApIHtcbiAgICAgICAgICAgIHZhciBtdXRhdGlvbiA9IG11dGF0aW9uc1tpXTtcbiAgICAgICAgICAgIHZhciBvYmogPSBtdXRhdGlvbi5kYXRhO1xuICAgICAgICAgICAgdmFyIHJlcXVlc3Q7XG4gICAgICAgICAgICBpZiAoIG11dGF0aW9uLnR5cGUgPT09IHNlbGYuSURCTXV0YXRpb25UeXBlLlBVVCApIHtcbiAgICAgICAgICAgICAgcmVxdWVzdCA9IHN0b3JlLnB1dChzZWxmLnNlcmlhbGl6ZShvYmopLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuc2VyaWFsaXplSWQob2JqLmlkKSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBpZiAoIGRlbGV0ZXNGb3VuZFtkZWxldGVzSV0gPT09IG51bGwgKSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlc0krKztcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXF1ZXN0ID0gc3RvcmUuZGVsZXRlKFxuICAgICAgICAgICAgICAgICAgdGhpcy5zZXJpYWxpemVJZChvYmouaWQgIT09IHVuZGVmaW5lZCA/IG9iai5pZCA6IG9iaikpO1xuICAgICAgICAgICAgICBkZWxldGVzSSsrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHJlcXVlc3QudHJhbnNhY3Rpb24uYWRkRXZlbnRMaXN0ZW5lcihcbiAgICAgICAgICAgICAgJ2NvbXBsZXRlJyxcbiAgICAgICAgICAgICAgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdmFyIGRlbGV0ZXNJID0gMDtcbiAgICAgICAgICAgICAgICBmb3IgKCB2YXIgaSA9IDA7IGkgPCBtdXRhdGlvbnMubGVuZ3RoOyBpKysgKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgbXV0YXRpb24gPSBtdXRhdGlvbnNbaV07XG4gICAgICAgICAgICAgICAgICBpZiAoIG11dGF0aW9uLnR5cGUgPT09IHNlbGYuSURCTXV0YXRpb25UeXBlLlBVVCApIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5wdWIoJ29uJywgJ3B1dCcsIG11dGF0aW9uLmRhdGEpO1xuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCBkZWxldGVzRm91bmRbZGVsZXRlc0ldICE9PSBudWxsIClcbiAgICAgICAgICAgICAgICAgICAgICBzZWxmLnB1Yignb24nLCAncmVtb3ZlJywgbXV0YXRpb24uZGF0YSk7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZXNJKys7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBtdXRhdGlvbi5yZXNvbHZlKG11dGF0aW9uLmRhdGEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmVxdWVzdC50cmFuc2FjdGlvbi5hZGRFdmVudExpc3RlbmVyKFxuICAgICAgICAgICAgICAgICdlcnJvcicsXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24oZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgIGZvciAoIHZhciBpID0gMDsgaSA8IG11dGF0aW9ucy5sZW5ndGg7IGkrKyApIHtcbiAgICAgICAgICAgICAgICAgICAgbXV0YXRpb25zW2ldLnJlamVjdChlcnJvcik7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH0sXG4gICAgZnVuY3Rpb24gb25UcmFuc2FjdGlvbkNvbXBsZXRlKCkge1xuICAgICAgdGhpcy5udW1BY3RpdmVUcmFuc2FjdGlvbnNfLS07XG4gICAgfSxcbiAgICBmdW5jdGlvbiBvblRyYW5zYWN0aW9uRXJyb3IoKSB7XG4gICAgICB0aGlzLm51bUFjdGl2ZVRyYW5zYWN0aW9uc18tLTtcbiAgICB9XG4gIF1cbn0pO1xuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuZm9hbS5DTEFTUyh7XG4gIHBhY2thZ2U6ICdmb2FtLmRhbycsXG4gIG5hbWU6ICdSZXN0REFPJyxcbiAgZXh0ZW5kczogJ2ZvYW0uZGFvLkFic3RyYWN0REFPJyxcblxuICBkb2N1bWVudGF0aW9uOiBmdW5jdGlvbigpIHsvKlxuICAgIEEgY2xpZW50LXNpZGUgREFPIGZvciBpbnRlcmFjdGluZyB3aXRoIGEgUkVTVCBlbmRwb2ludC5cblxuICAgIFNpbmtzIGFyZSBtYW5hZ2VkIG9uIHRoZSBjbGllbnQgKGkuZS4sIHNpbmtzIHBhc3NlZCB0b1xuICAgIHNlbGVjdCgpIHdpbGwgbm90IHNlcmlhbGl6ZSB0aGUgc2luayBhbmQgc2VuZCBpdCB0byB0aGVcbiAgICBlbmRwb2ludCBmb3Igc2VydmVyLXNpZGUgbG9naWMgaW1wbGVtZW50YXRpb24pLlxuICAqL30sXG5cbiAgcmVxdWlyZXM6IFtcbiAgICAnZm9hbS5jb3JlLlNlcmlhbGl6YWJsZScsXG4gICAgJ2ZvYW0uZGFvLkFycmF5U2luaycsXG4gICAgJ2ZvYW0uanNvbi5PdXRwdXR0ZXInLFxuICAgICdmb2FtLm5ldC5IVFRQUmVxdWVzdCdcbiAgXSxcblxuICBwcm9wZXJ0aWVzOiBbXG4gICAge1xuICAgICAgY2xhc3M6ICdTdHJpbmcnLFxuICAgICAgbmFtZTogJ2Jhc2VVUkwnLFxuICAgICAgZG9jdW1lbnRhdGlvbjogJ1VSTCBmb3IgbW9zdCByZXN0IGNhbGxzLiBTb21lIGNhbGxzIGFkZCBcIi88c29tZS1pbmZvPlwiLicsXG4gICAgICBmaW5hbDogdHJ1ZSxcbiAgICAgIHJlcXVpcmVkOiB0cnVlXG4gICAgfSxcbiAgICB7XG4gICAgICBjbGFzczogJ0ZPYmplY3RQcm9wZXJ0eScsXG4gICAgICBvZjogJ2ZvYW0uanNvbi5PdXRwdXR0ZXInLFxuICAgICAgbmFtZTogJ291dHB1dHRlcicsXG4gICAgICBmYWN0b3J5OiBmdW5jdGlvbigpIHtcbiAgICAgICAgLy8gTk9URTogQ29uZmlndXJhdGlvbiBtdXN0IGJlIGNvbnNpc3RlbnQgd2l0aCBwYXJzZXIgaW5cbiAgICAgICAgLy8gY29ycmVzcG9uZGluZyBmb2FtLm5ldC5ub2RlLlJlc3REQU9IYW5kbGVyLlxuICAgICAgICByZXR1cm4gdGhpcy5PdXRwdXR0ZXIuY3JlYXRlKHtcbiAgICAgICAgICBwcmV0dHk6IGZhbHNlLFxuICAgICAgICAgIGZvcm1hdERhdGVzQXNOdW1iZXJzOiB0cnVlLFxuICAgICAgICAgIG91dHB1dERlZmF1bHRWYWx1ZXM6IGZhbHNlLFxuICAgICAgICAgIHN0cmljdDogdHJ1ZSxcbiAgICAgICAgICBwcm9wZXJ0eVByZWRpY2F0ZTogZnVuY3Rpb24obywgcCkgeyByZXR1cm4gISBwLm5ldHdvcmtUcmFuc2llbnQ7IH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICBdLFxuXG4gIG1ldGhvZHM6IFtcbiAgICBmdW5jdGlvbiBwdXRfKHgsIG8pIHtcbiAgICAgIC8qKlxuICAgICAgICogUFVUIGJhc2VVUkxcbiAgICAgICAqIDxuZXR3b3JrLWZvYW0tanNvbmlmaWVkIEZPQU0gb2JqZWN0PlxuICAgICAgICovXG4gICAgICByZXR1cm4gdGhpcy5jcmVhdGVSZXF1ZXN0Xyh7XG4gICAgICAgIG1ldGhvZDogJ1BVVCcsXG4gICAgICAgIHVybDogdGhpcy5iYXNlVVJMLFxuICAgICAgICBwYXlsb2FkOiB0aGlzLm91dHB1dHRlci5zdHJpbmdpZnkobylcbiAgICAgIH0pLnNlbmQoKS50aGVuKHRoaXMub25SZXNwb25zZS5iaW5kKHRoaXMsICdwdXQnKSlcbiAgICAgICAgICAudGhlbih0aGlzLm9uUHV0UmVzcG9uc2UpO1xuICAgIH0sXG5cbiAgICBmdW5jdGlvbiByZW1vdmVfKHgsIG8pIHtcbiAgICAgIC8qKlxuICAgICAgICogREVMRVRFIGJhc2VVUkwvPG5ldHdvcmstZm9hbS1qc29uaWZpZWQgRk9BTSBvYmplY3QgaWQ+XG4gICAgICAgKi9cbiAgICAgIHJldHVybiB0aGlzLmNyZWF0ZVJlcXVlc3RfKHtcbiAgICAgICAgbWV0aG9kOiAnREVMRVRFJyxcbiAgICAgICAgdXJsOiB0aGlzLmJhc2VVUkwgKyAnLycgK1xuICAgICAgICAgICAgZW5jb2RlVVJJQ29tcG9uZW50KHRoaXMub3V0cHV0dGVyLnN0cmluZ2lmeShvLmlkKSlcbiAgICAgIH0pLnNlbmQoKS50aGVuKHRoaXMub25SZXNwb25zZS5iaW5kKHRoaXMsICdyZW1vdmUnKSlcbiAgICAgICAgICAudGhlbih0aGlzLm9uUmVtb3ZlUmVzcG9uc2UpO1xuICAgIH0sXG5cbiAgICBmdW5jdGlvbiBmaW5kXyh4LCBrZXkpIHtcbiAgICAgIC8qKlxuICAgICAgICogR0VUIGJhc2VVUkwvPG5ldHdvcmstZm9hbS1qc29uaWZpZWQgRk9BTSBvYmplY3QgaWQ+XG4gICAgICAgKi9cbiAgICAgIHZhciBpZCA9IHRoaXMub2YuaXNJbnN0YW5jZShrZXkpID8ga2V5LmlkIDoga2V5O1xuICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlUmVxdWVzdF8oe1xuICAgICAgICBtZXRob2Q6ICdHRVQnLFxuICAgICAgICB1cmw6IHRoaXMuYmFzZVVSTCArICcvJyArXG4gICAgICAgICAgICBlbmNvZGVVUklDb21wb25lbnQodGhpcy5vdXRwdXR0ZXIuc3RyaW5naWZ5KGlkKSlcbiAgICAgIH0pLnNlbmQoKS50aGVuKHRoaXMub25SZXNwb25zZS5iaW5kKHRoaXMsICdmaW5kJykpXG4gICAgICAgICAgLnRoZW4odGhpcy5vbkZpbmRSZXNwb25zZSk7XG4gICAgfSxcblxuICAgIGZ1bmN0aW9uIHNlbGVjdF8oeCwgc2luaywgc2tpcCwgbGltaXQsIG9yZGVyLCBwcmVkaWNhdGUpIHtcbiAgICAgIC8qKlxuICAgICAgICogR0VUIGJhc2VVUkxcbiAgICAgICAqIHsgc2tpcCwgbGltaXQsIG9yZGVyLCBwcmVkaWNhdGUgfVxuICAgICAgICpcbiAgICAgICAqIEVhY2gga2V5J3MgdmFsdWUgaXMgbmV0d29yay1mb2FtLWpzb25pZmllZC5cbiAgICAgICAqL1xuICAgICAgdmFyIHBheWxvYWQgPSB7fTtcblxuICAgICAgdmFyIG5ldHdvcmtTaW5rID0gdGhpcy5TZXJpYWxpemFibGUuaXNJbnN0YW5jZShzaW5rKSAmJiBzaW5rO1xuICAgICAgaWYgKCBuZXR3b3JrU2luayApXG4gICAgICAgIHBheWxvYWQuc2luayA9IG5ldHdvcmtTaW5rO1xuXG4gICAgICBpZiAoIHR5cGVvZiBza2lwICE9PSAndW5kZWZpbmVkJyApXG4gICAgICAgIHBheWxvYWQuc2tpcCA9IHNraXA7XG4gICAgICBpZiAoIHR5cGVvZiBsaW1pdCAhPT0gJ3VuZGVmaW5lZCcgKVxuICAgICAgICBwYXlsb2FkLmxpbWl0ID0gbGltaXQ7XG4gICAgICBpZiAoIHR5cGVvZiBvcmRlciAhPT0gJ3VuZGVmaW5lZCcgKVxuICAgICAgICBwYXlsb2FkLm9yZGVyID0gb3JkZXI7XG4gICAgICBpZiAoIHR5cGVvZiBwcmVkaWNhdGUgIT09ICd1bmRlZmluZWQnIClcbiAgICAgICAgcGF5bG9hZC5wcmVkaWNhdGUgPSBwcmVkaWNhdGU7XG5cbiAgICAgIHJldHVybiB0aGlzLmNyZWF0ZVJlcXVlc3RfKHtcbiAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgIHVybDogdGhpcy5iYXNlVVJMICsgJzpzZWxlY3QnLFxuICAgICAgICBwYXlsb2FkOiB0aGlzLm91dHB1dHRlci5zdHJpbmdpZnkocGF5bG9hZClcbiAgICAgIH0pLnNlbmQoKS50aGVuKHRoaXMub25SZXNwb25zZS5iaW5kKHRoaXMsICdzZWxlY3QnKSlcbiAgICAgICAgICAudGhlbih0aGlzLm9uU2VsZWN0UmVzcG9uc2UuYmluZChcbiAgICAgICAgICAgICAgdGhpcywgc2luayB8fCB0aGlzLkFycmF5U2luay5jcmVhdGUoKSkpO1xuICAgIH0sXG5cbiAgICBmdW5jdGlvbiByZW1vdmVBbGxfKHgsIHNraXAsIGxpbWl0LCBvcmRlciwgcHJlZGljYXRlKSB7XG4gICAgICAvKipcbiAgICAgICAqIFBPU1QgYmFzZVVSTC9yZW1vdmVBbGxcbiAgICAgICAqIHsgc2tpcCwgbGltaXQsIG9yZGVyLCBwcmVkaWNhdGUgfVxuICAgICAgICpcbiAgICAgICAqIEVhY2gga2V5J3MgdmFsdWUgaXMgbmV0d29yay1mb2FtLWpzb25pZmllZC5cbiAgICAgICAqL1xuICAgICAgdmFyIHBheWxvYWQgPSB7fTtcbiAgICAgIGlmICggdHlwZW9mIHNraXAgICE9PSAndW5kZWZpbmVkJyApIHBheWxvYWQuc2tpcCA9IHNraXA7XG4gICAgICBpZiAoIHR5cGVvZiBsaW1pdCAhPT0gJ3VuZGVmaW5lZCcgKSBwYXlsb2FkLmxpbWl0ID0gbGltaXQ7XG4gICAgICBpZiAoIHR5cGVvZiBvcmRlciAhPT0gJ3VuZGVmaW5lZCcgKSBwYXlsb2FkLm9yZGVyID0gb3JkZXI7XG4gICAgICBpZiAoIHR5cGVvZiBwcmVkaWNhdGUgIT09ICd1bmRlZmluZWQnICkgcGF5bG9hZC5wcmVkaWNhdGUgPSBwcmVkaWNhdGU7XG5cbiAgICAgIHJldHVybiB0aGlzLmNyZWF0ZVJlcXVlc3RfKHtcbiAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgIHVybDogdGhpcy5iYXNlVVJMICsgJzpyZW1vdmVBbGwnLFxuICAgICAgICBwYXlsb2FkOiB0aGlzLm91dHB1dHRlci5zdHJpbmdpZnkocGF5bG9hZClcbiAgICAgIH0pLnNlbmQoKS50aGVuKHRoaXMub25SZXNwb25zZS5iaW5kKHRoaXMsICdyZW1vdmVBbGwnKSlcbiAgICAgICAgICAudGhlbih0aGlzLm9uUmVtb3ZlQWxsUmVzcG9uc2UpO1xuICAgIH0sXG5cbiAgICBmdW5jdGlvbiBjcmVhdGVSZXF1ZXN0XyhvKSB7XG4gICAgICAvLyBEZW1hbmQgdGhhdCByZXF1aXJlZCBwcm9wZXJ0aWVzIGFyZSBzZXQgYmVmb3JlIHVzaW5nIERBTy5cbiAgICAgIHRoaXMudmFsaWRhdGUoKTtcbiAgICAgIC8vIEVhY2ggcmVxdWVzdCBzaG91bGQgZGVmYXVsdCB0byBhIGpzb24gcmVzcG9uc2VUeXBlLlxuICAgICAgcmV0dXJuIHRoaXMuSFRUUFJlcXVlc3QuY3JlYXRlKE9iamVjdC5hc3NpZ24oe3Jlc3BvbnNlVHlwZTogJ2pzb24nfSwgbykpO1xuICAgIH1cbiAgXSxcblxuICBsaXN0ZW5lcnM6IFtcbiAgICBmdW5jdGlvbiBvblJlc3BvbnNlKG5hbWUsIHJlc3BvbnNlKSB7XG4gICAgICBpZiAoIHJlc3BvbnNlLnN0YXR1cyAhPT0gMjAwICkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgJ1VuZXhwZWN0ZWQgJyArIG5hbWUgKyAnIHJlc3BvbnNlIGNvZGUgZnJvbSBSRVNUIERBTyBlbmRwb2ludDogJyArXG4gICAgICAgICAgICByZXNwb25zZS5zdGF0dXMpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3BvbnNlLnBheWxvYWQ7XG4gICAgfSxcblxuICAgIGZ1bmN0aW9uIG9uUHV0UmVzcG9uc2UocGF5bG9hZCkge1xuICAgICAgdmFyIG8gPSBmb2FtLmpzb24ucGFyc2UocGF5bG9hZCk7XG4gICAgICB0aGlzLnB1Yignb24nLCAncHV0Jywgbyk7XG4gICAgICByZXR1cm4gbztcbiAgICB9LFxuXG4gICAgZnVuY3Rpb24gb25SZW1vdmVSZXNwb25zZShwYXlsb2FkKSB7XG4gICAgICB2YXIgbyA9IGZvYW0uanNvbi5wYXJzZShwYXlsb2FkKTtcbiAgICAgIGlmICggbyAhPT0gbnVsbCApIHRoaXMucHViKCdvbicsICdyZW1vdmUnLCBvKTtcbiAgICAgIHJldHVybiBvO1xuICAgIH0sXG5cbiAgICBmdW5jdGlvbiBvbkZpbmRSZXNwb25zZShwYXlsb2FkKSB7XG4gICAgICByZXR1cm4gZm9hbS5qc29uLnBhcnNlKHBheWxvYWQpO1xuICAgIH0sXG5cbiAgICBmdW5jdGlvbiBvblNlbGVjdFJlc3BvbnNlKGxvY2FsU2luaywgcGF5bG9hZCkge1xuICAgICAgdmFyIHdhc1NlcmlhbGl6YWJsZSA9IHRoaXMuU2VyaWFsaXphYmxlLmlzSW5zdGFuY2UobG9jYWxTaW5rKTtcbiAgICAgIHZhciByZW1vdGVTaW5rID0gZm9hbS5qc29uLnBhcnNlKHBheWxvYWQpO1xuXG4gICAgICAvLyBJZiBub3QgcHJveHlpbmcgYSBsb2NhbCB1bnNlcmlhbGl6YWJsZSBzaW5rLCBqdXN0IHJldHVybiB0aGUgcmVtb3RlLlxuICAgICAgaWYgKCB3YXNTZXJpYWxpemFibGUgKSByZXR1cm4gcmVtb3RlU2luaztcblxuICAgICAgdmFyIGFycmF5ID0gcmVtb3RlU2luay5hcnJheTtcbiAgICAgIGlmICggISBhcnJheSApXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgQXJyYXlTaW5rIGZyb20gUkVTVCBlbmRwb2ludCB3aGVuIHByb3h5aW5nIGxvY2FsIHNpbmsnKTtcblxuICAgICAgaWYgKCBsb2NhbFNpbmsucHV0ICkge1xuICAgICAgICB2YXIgc3ViID0gZm9hbS5jb3JlLkZPYmplY3QuY3JlYXRlKCk7XG4gICAgICAgIHZhciBkZXRhY2hlZCA9IGZhbHNlO1xuICAgICAgICBzdWIub25EZXRhY2goZnVuY3Rpb24oKSB7IGRldGFjaGVkID0gdHJ1ZTsgfSk7XG4gICAgICAgIGZvciAoIHZhciBpID0gMDsgaSA8IGFycmF5Lmxlbmd0aDsgaSsrICkge1xuICAgICAgICAgIGxvY2FsU2luay5wdXQoYXJyYXlbaV0sIHN1Yik7XG4gICAgICAgICAgaWYgKCBkZXRhY2hlZCApIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoIGxvY2FsU2luay5lb2YgKSBsb2NhbFNpbmsuZW9mKCk7XG5cbiAgICAgIHJldHVybiBsb2NhbFNpbms7XG4gICAgfSxcblxuICAgIGZ1bmN0aW9uIG9uUmVtb3ZlQWxsUmVzcG9uc2UocGF5bG9hZCkge1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gIF1cbn0pO1xuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgVGhlIEZPQU0gQXV0aG9ycy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICovXG5cbmZvYW0uQ0xBU1Moe1xuICBwYWNrYWdlOiAnZm9hbS5kYW8nLFxuICBuYW1lOiAnRW5hYmxlZEF3YXJlREFPJyxcbiAgZXh0ZW5kczogJ2ZvYW0uZGFvLkZpbHRlcmVkREFPJyxcblxuICBkb2N1bWVudGF0aW9uOiAnRmlsdGVyIG91dCBkaXNhYmxlZCBFbmFibGVkQXdhcmUgb2JqZWN0cy4nLFxuXG4gIGltcGxlbWVudHM6IFtcbiAgICAnZm9hbS5tbGFuZy5FeHByZXNzaW9ucydcbiAgXSxcblxuICByZXF1aXJlczogW1xuICAgICdmb2FtLm5hbm9zLmF1dGguRW5hYmxlZEF3YXJlJ1xuICBdLFxuXG4gIHByb3BlcnRpZXM6IFtcbiAgICB7XG4gICAgICBjbGFzczogJ0ZPYmplY3RQcm9wZXJ0eScsXG4gICAgICBvZjogJ2ZvYW0ubWxhbmcucHJlZGljYXRlLlByZWRpY2F0ZScsXG4gICAgICBuYW1lOiAncHJlZGljYXRlJyxcbiAgICAgIGZhY3Rvcnk6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5FUSh0aGlzLkVuYWJsZWRBd2FyZS5FTkFCTEVELCB0cnVlKTtcbiAgICAgIH0sXG4gICAgICBqYXZhRmFjdG9yeTogJ3JldHVybiBmb2FtLm1sYW5nLk1MYW5nLkVRKEVuYWJsZWRBd2FyZS5FTkFCTEVELCB0cnVlKTsnXG4gICAgfVxuICBdXG59KTtcbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IFRoZSBGT0FNIEF1dGhvcnMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqL1xuXG5mb2FtLkNMQVNTKHtcbiAgcGFja2FnZTogJ2ZvYW0uZGFvJyxcbiAgbmFtZTogJ0xhc3RNb2RpZmllZEF3YXJlREFPJyxcbiAgZXh0ZW5kczogJ2ZvYW0uZGFvLlByb3h5REFPJyxcblxuICBkb2N1bWVudGF0aW9uOiAnU2V0cyBsYXN0TW9kaWZpZWQgdGltZXN0YW1wIG9uIHB1dCgpIG9mIExhc3RNb2RpZmllZEF3YXJlIG9iamVjdHMuJyxcblxuICBqYXZhSW1wb3J0czogW1xuICAgICdmb2FtLm5hbm9zLmF1dGguTGFzdE1vZGlmaWVkQXdhcmUnLFxuICAgICdqYXZhLnV0aWwuQ2FsZW5kYXInLFxuICAgICdqYXZhLnV0aWwuVGltZVpvbmUnXG4gIF0sXG5cbiAgbWV0aG9kczogW1xuICAgIHtcbiAgICAgIG5hbWU6ICdwdXRfJyxcbiAgICAgIGNvZGU6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIHZhbHVlLmxhc3RNb2RpZmllZCA9IG5ldyBEYXRlKCk7XG4gICAgICAgIHJldHVybiBTVVBFUih2YWx1ZSk7XG4gICAgICB9LFxuICAgICAgamF2YUNvZGU6XG5gKChMYXN0TW9kaWZpZWRBd2FyZSkgb2JqKS5zZXRMYXN0TW9kaWZpZWQoQ2FsZW5kYXIuZ2V0SW5zdGFuY2UoVGltZVpvbmUuZ2V0VGltZVpvbmUoXCJVVENcIikpLmdldFRpbWUoKSk7XG5yZXR1cm4gc3VwZXIucHV0Xyh4LCBvYmopO2BcbiAgICB9XG4gIF1cbn0pO1xuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTYgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuZm9hbS5DTEFTUyh7XG4gIHBhY2thZ2U6ICdmb2FtLmRhbycsXG4gIG5hbWU6ICdWYWxpZGF0aW9uREFPRGVjb3JhdG9yJyxcbiAgZXh0ZW5kczogJ2ZvYW0uZGFvLkFic3RyYWN0REFPRGVjb3JhdG9yJyxcbiAgZG9jdW1lbnRhdGlvbjogJ0RBTyBkZWNvcmF0b3IgdGhhdCByZWplY3RzIHB1dHMgb2Ygb2JqZWN0cyB0aGF0IGFyZSBpbnZhbGlkLicsXG4gIG1ldGhvZHM6IFtcbiAgICBmdW5jdGlvbiB3cml0ZShYLCBkYW8sIG9iaiwgZXhpc3RpbmcpIHtcbiAgICAgIGlmICggb2JqLmVycm9yc18gKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChmb2FtLmRhby5WYWxpZGF0aW9uRXhjZXB0aW9uLmNyZWF0ZSh7XG4gICAgICAgICAgZXJyb3JzOiBvYmouZXJyb3JzXyxcbiAgICAgICAgfSkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShvYmopO1xuICAgIH0sXG4gIF1cbn0pO1xuXG5mb2FtLkNMQVNTKHtcbiAgcGFja2FnZTogJ2ZvYW0uZGFvJyxcbiAgbmFtZTogJ1ZhbGlkYXRpb25FeGNlcHRpb24nLFxuICBleHRlbmRzOiAnZm9hbS5kYW8uRXh0ZXJuYWxFeGNlcHRpb24nLFxuICBwcm9wZXJ0aWVzOiBbXG4gICAgJ2Vycm9ycycsXG4gICAge1xuICAgICAgbmFtZTogJ21lc3NhZ2UnLFxuICAgICAgZXhwcmVzc2lvbjogZnVuY3Rpb24oZXJyb3JzKSB7XG4gICAgICAgIHJldHVybiBlcnJvcnMuam9pbignLCAnKTtcbiAgICAgIH0sXG4gICAgfSxcbiAgXSxcbn0pO1xuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTYgVGhlIEZPQU0gQXV0aG9ycy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuZm9hbS5DTEFTUyh7XG4gIHBhY2thZ2U6ICdmb2FtLmRhbycsXG4gIG5hbWU6ICdOb0Rpc2p1bmN0aW9uREFPJyxcbiAgZXh0ZW5kczogJ2ZvYW0uZGFvLlByb3h5REFPJyxcbiAgaW1wbGVtZW50czogWyAnZm9hbS5tbGFuZy5FeHByZXNzaW9ucycgXSxcblxuICBkb2N1bWVudGF0aW9uOiAnREFPIGRlY29yYXRvciBmb3IgREFPcyB0aGF0IGRvIG5vdCBzdXBwb3J0IGRpc2p1bmN0aW9uLicsXG5cbiAgcmVxdWlyZXM6IFtcbiAgICAnZm9hbS5kYW8uREFPU2luaycsXG4gICAgJ2ZvYW0uZGFvLk1EQU8nLFxuICAgICdmb2FtLm1sYW5nLkNvbnN0YW50JyxcbiAgICAnZm9hbS5tbGFuZy5wcmVkaWNhdGUuRXEnLFxuICAgICdmb2FtLm1sYW5nLnByZWRpY2F0ZS5PcidcbiAgXSxcblxuICBtZXRob2RzOiBbXG4gICAgZnVuY3Rpb24gc2VsZWN0Xyh4LCBzaW5rLCBza2lwLCBsaW1pdCwgb3JkZXIsIHByZWRpY2F0ZSkge1xuICAgICAgaWYgKCAhIHByZWRpY2F0ZSApXG4gICAgICAgIHJldHVybiB0aGlzLlNVUEVSKHgsIHNpbmssIHNraXAsIGxpbWl0LCBvcmRlciwgcHJlZGljYXRlKTtcblxuICAgICAgLy8gR2V0IHByZWRpY2F0ZSBpbiByZWR1Y2VkIGZvcm0gb2YgT1IoIC4uLiA8bm8gT1JzIG9yIElOcz4gLi4uICkuXG4gICAgICB2YXIgbmV3UHJlZGljYXRlID0gdGhpcy5pblRvT3JfKHByZWRpY2F0ZSlcbiAgICAgICAgICAudG9EaXNqdW5jdGl2ZU5vcm1hbEZvcm0oKVxuICAgICAgICAgIC5wYXJ0aWFsRXZhbCgpO1xuXG4gICAgICAvLyBEbyBub3QgYm90aGVyIGRpc2p1bmN0aW9uLW9ubHkgREFPcyB3aXRoIHJldHVybmluZyBlbXB0eSBzZXQgb3JcbiAgICAgIC8vIGltcGxlbWVudGluZyBzZWxlY3QoLi4uLCBUUlVFKSA9IHNlbGVjdCguLi4sIDxubyBwcmVkaWNhdGU+KS5cbiAgICAgIGlmICggdGhpcy5GQUxTRS5lcXVhbHMobmV3UHJlZGljYXRlKSApIHtcbiAgICAgICAgc2luay5lb2YgJiYgc2luay5lb2YoKTtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShzaW5rKTtcbiAgICAgIH1cbiAgICAgIGlmICggdGhpcy5UUlVFLmVxdWFscyhuZXdQcmVkaWNhdGUpICkgbmV3UHJlZGljYXRlID0gdW5kZWZpbmVkO1xuXG4gICAgICBpZiAoICEgdGhpcy5Pci5pc0luc3RhbmNlKG5ld1ByZWRpY2F0ZSkgKVxuICAgICAgICByZXR1cm4gdGhpcy5TVVBFUih4LCBzaW5rLCBza2lwLCBsaW1pdCwgb3JkZXIsIG5ld1ByZWRpY2F0ZSk7XG5cbiAgICAgIC8vIFBlcmZvcm0gcXVlcnkgb3ZlciBlYWNoIGFyZyBvZiB0b3AtbGV2ZWwgT1IuXG4gICAgICB2YXIgcHJlZGljYXRlcyA9IG5ld1ByZWRpY2F0ZS5hcmdzO1xuICAgICAgdmFyIGRhbyA9IHRoaXMuTURBTy5jcmVhdGUoeyBvZjogdGhpcy5vZiB9KTtcbiAgICAgIC8vIFRPRE8obWFya2RpdHRtZXIpOiBDcmVhdGUgaW5kaWNlcyBiYXNlZCBvbiBwcmVkaWNhdGUuXG4gICAgICB2YXIgc2hhcmVkU2luayA9IHRoaXMuREFPU2luay5jcmVhdGUoeyBkYW86IGRhbyB9KTtcbiAgICAgIHZhciBwcm9taXNlcyA9IFtdO1xuICAgICAgZm9yICggdmFyIGkgPSAwOyBpIDwgcHJlZGljYXRlcy5sZW5ndGg7IGkrKyApIHtcbiAgICAgICAgcHJvbWlzZXMucHVzaChcbiAgICAgICAgICAgIHRoaXMuU1VQRVIoeCwgc2hhcmVkU2luaywgc2tpcCwgbGltaXQsIG9yZGVyLCBwcmVkaWNhdGVzW2ldKSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBQcm9taXNlLmFsbChwcm9taXNlcykudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgLy8gUGVyZm9ybSBcImFjdHVhbFwiIHF1ZXJ5IG92ZXIgREFPIG9mIG1lcmdlZCByZXN1bHRzLlxuICAgICAgICByZXR1cm4gZGFvLnNlbGVjdF8oeCwgc2luaywgc2tpcCwgbGltaXQsIG9yZGVyLCBwcmVkaWNhdGUpO1xuICAgICAgfSk7XG4gICAgfSxcbiAgICB7XG4gICAgICBuYW1lOiAnaW5Ub09yXycsXG4gICAgICBkb2N1bWVudGF0aW9uOiAnQ29udmVydCBJTigpIG1MYW5ncyBpbiBpbnB1dCB0byBPUihFUSguLi4pLCAuLi4pLicsXG4gICAgICBjb2RlOiBmb2FtLm1tZXRob2Qoe1xuICAgICAgICAnZm9hbS5tbGFuZy5wcmVkaWNhdGUuSW4nOiBmdW5jdGlvbihwcmVkaWNhdGUpIHtcbiAgICAgICAgICBmb2FtLmFzc2VydCh0aGlzLkNvbnN0YW50LmlzSW5zdGFuY2UocHJlZGljYXRlLmFyZzIpLFxuICAgICAgICAgICAgICAgICAgICAgICdOb0Rpc2p1bmN0aW9uREFPIGV4cGVjdHMgY29uc3RhbnQgSU4uYXJnMicpO1xuXG4gICAgICAgICAgdmFyIG9yQXJncyA9IFtdO1xuICAgICAgICAgIHZhciBhcmcyID0gcHJlZGljYXRlLmFyZzIudmFsdWU7XG5cbiAgICAgICAgICBmb3IgKCB2YXIgaSA9IDA7IGkgPCBhcmcyLmxlbmd0aDsgaSsrICkge1xuICAgICAgICAgICAgb3JBcmdzLnB1c2godGhpcy5FcS5jcmVhdGUoe1xuICAgICAgICAgICAgICBhcmcxOiBwcmVkaWNhdGUuYXJnMS5jbG9uZSgpLFxuICAgICAgICAgICAgICBhcmcyOiBhcmcyW2ldXG4gICAgICAgICAgICB9LCBwcmVkaWNhdGUpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHRoaXMuT3IuY3JlYXRlKHsgYXJnczogb3JBcmdzIH0sIHByZWRpY2F0ZSk7XG4gICAgICAgIH0sXG4gICAgICAgICdmb2FtLm1sYW5nLnByZWRpY2F0ZS5CaW5hcnknOiBmdW5jdGlvbihwcmVkaWNhdGUpIHtcbiAgICAgICAgICByZXR1cm4gcHJlZGljYXRlLmNsc18uY3JlYXRlKHtcbiAgICAgICAgICAgIGFyZzE6IHRoaXMuaW5Ub09yXyhwcmVkaWNhdGUuYXJnMSksXG4gICAgICAgICAgICBhcmcyOiB0aGlzLmluVG9Pcl8ocHJlZGljYXRlLmFyZzIpXG4gICAgICAgICAgfSwgcHJlZGljYXRlKTtcbiAgICAgICAgfSxcbiAgICAgICAgJ2ZvYW0ubWxhbmcucHJlZGljYXRlLk5hcnknOiBmdW5jdGlvbihwcmVkaWNhdGUpIHtcbiAgICAgICAgICB2YXIgb2xkQXJncyA9IHByZWRpY2F0ZS5hcmdzO1xuICAgICAgICAgIHZhciBuZXdBcmdzID0gbmV3IEFycmF5KG9sZEFyZ3MubGVuZ3RoKTtcbiAgICAgICAgICBmb3IgKCB2YXIgaSA9IDA7IGkgPCBvbGRBcmdzLmxlbmd0aDsgaSsrICkge1xuICAgICAgICAgICAgbmV3QXJnc1tpXSA9IHRoaXMuaW5Ub09yXyhvbGRBcmdzW2ldKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHByZWRpY2F0ZS5jbHNfLmNyZWF0ZSh7IGFyZ3M6IG5ld0FyZ3MgfSk7XG4gICAgICAgIH0sXG4gICAgICAgICdmb2FtLm1sYW5nLnByZWRpY2F0ZS5BYnN0cmFjdFByZWRpY2F0ZSc6IGZ1bmN0aW9uKHByZWRpY2F0ZSkge1xuICAgICAgICAgIHJldHVybiBwcmVkaWNhdGUuY2xvbmUoKTtcbiAgICAgICAgfSxcbiAgICAgICAgJ2ZvYW0ubWxhbmcuQWJzdHJhY3RFeHByJzogZnVuY3Rpb24oZXhwcikge1xuICAgICAgICAgIHJldHVybiBleHByLmNsb25lKCk7XG4gICAgICAgIH0sXG4gICAgICAgICdmb2FtLmNvcmUuUHJvcGVydHknOiBmdW5jdGlvbihwcm9wZXJ0eSkge1xuICAgICAgICAgIHJldHVybiBwcm9wZXJ0eTtcbiAgICAgICAgfVxuICAgICAgfSwgZnVuY3Rpb24ocHJlZGljYXRlKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVW5yZWNvZ25pemVkIHByZWRpY2F0ZTogJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAoIHByZWRpY2F0ZSAmJiBwcmVkaWNhdGUuY2xzXyAmJiBwcmVkaWNhdGUuY2xzXy5pZCApKTtcbiAgICAgIH0pXG4gICAgfVxuICBdXG59KTtcbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IFRoZSBGT0FNIEF1dGhvcnMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmZvYW0uQ0xBU1Moe1xuICBwYWNrYWdlOiAnZm9hbS5kYW8nLFxuICBuYW1lOiAnTm9OZXFEQU8nLFxuICBleHRlbmRzOiAnZm9hbS5kYW8uUHJveHlEQU8nLFxuXG4gIGRvY3VtZW50YXRpb246ICdEQU8gZGVjb3JhdG9yIGZvciBEQU9zIHRoYXQgZG8gbm90IHN1cHBvcnQgTkVRKCkuJyxcblxuICByZXF1aXJlczogW1xuICAgICdmb2FtLm1sYW5nLnByZWRpY2F0ZS5HdCcsXG4gICAgJ2ZvYW0ubWxhbmcucHJlZGljYXRlLkx0JyxcbiAgICAnZm9hbS5tbGFuZy5wcmVkaWNhdGUuTmVxJyxcbiAgICAnZm9hbS5tbGFuZy5wcmVkaWNhdGUuT3InXG4gIF0sXG5cbiAgbWV0aG9kczogW1xuICAgIGZ1bmN0aW9uIHNlbGVjdF8oeCwgc2luaywgc2tpcCwgbGltaXQsIG9yZGVyLCBwcmVkaWNhdGUpIHtcbiAgICAgIGlmICggISBwcmVkaWNhdGUgKVxuICAgICAgICByZXR1cm4gdGhpcy5TVVBFUih4LCBzaW5rLCBza2lwLCBsaW1pdCwgb3JkZXIsIHByZWRpY2F0ZSk7XG5cbiAgICAgIHJldHVybiB0aGlzLlNVUEVSKHgsIHNpbmssIHNraXAsIGxpbWl0LCBvcmRlcixcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudHJhbnNmb3JtTmVxXyhwcmVkaWNhdGUpKTtcbiAgICB9LFxuICAgIHtcbiAgICAgIG5hbWU6ICd0cmFuc2Zvcm1OZXFfJyxcbiAgICAgIGRvY3VtZW50YXRpb246ICdDb252ZXJ0IE5FUSgpIG1MYW5ncyBpbiBpbnB1dCB0byBPUihMVCgpLCBHVCgpKS4nLFxuICAgICAgY29kZTogZm9hbS5tbWV0aG9kKHtcbiAgICAgICAgJ2ZvYW0ubWxhbmcucHJlZGljYXRlLk5lcSc6IGZ1bmN0aW9uKHByZWRpY2F0ZSkge1xuICAgICAgICAgIHJldHVybiB0aGlzLk9yLmNyZWF0ZSh7XG4gICAgICAgICAgICBhcmdzOiBbXG4gICAgICAgICAgICAgIHRoaXMuTHQuY3JlYXRlKHsgYXJnMTogcHJlZGljYXRlLmFyZzEsIGFyZzI6IHByZWRpY2F0ZS5hcmcyIH0pLFxuICAgICAgICAgICAgICB0aGlzLkd0LmNyZWF0ZSh7IGFyZzE6IHByZWRpY2F0ZS5hcmcxLCBhcmcyOiBwcmVkaWNhdGUuYXJnMiB9KSxcbiAgICAgICAgICAgIF1cbiAgICAgICAgICB9LCBwcmVkaWNhdGUpO1xuICAgICAgICB9LFxuICAgICAgICAnZm9hbS5tbGFuZy5wcmVkaWNhdGUuQmluYXJ5JzogZnVuY3Rpb24ocHJlZGljYXRlKSB7XG4gICAgICAgICAgcmV0dXJuIHByZWRpY2F0ZS5jbHNfLmNyZWF0ZSh7XG4gICAgICAgICAgICBhcmcxOiB0aGlzLnRyYW5zZm9ybU5lcV8ocHJlZGljYXRlLmFyZzEpLFxuICAgICAgICAgICAgYXJnMjogdGhpcy50cmFuc2Zvcm1OZXFfKHByZWRpY2F0ZS5hcmcyKVxuICAgICAgICAgIH0sIHByZWRpY2F0ZSk7XG4gICAgICAgIH0sXG4gICAgICAgICdmb2FtLm1sYW5nLnByZWRpY2F0ZS5OYXJ5JzogZnVuY3Rpb24ocHJlZGljYXRlKSB7XG4gICAgICAgICAgdmFyIG9sZEFyZ3MgPSBwcmVkaWNhdGUuYXJncztcbiAgICAgICAgICB2YXIgbmV3QXJncyA9IG5ldyBBcnJheShvbGRBcmdzLmxlbmd0aCk7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvbGRBcmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBuZXdBcmdzW2ldID0gdGhpcy50cmFuc2Zvcm1OZXFfKG9sZEFyZ3NbaV0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gcHJlZGljYXRlLmNsc18uY3JlYXRlKHsgYXJnczogbmV3QXJncyB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgJ2ZvYW0ubWxhbmcucHJlZGljYXRlLkFic3RyYWN0UHJlZGljYXRlJzogZnVuY3Rpb24ocHJlZGljYXRlKSB7XG4gICAgICAgICAgcmV0dXJuIHByZWRpY2F0ZS5jbG9uZSgpO1xuICAgICAgICB9LFxuICAgICAgICAnZm9hbS5tbGFuZy5BYnN0cmFjdEV4cHInOiBmdW5jdGlvbihleHByKSB7XG4gICAgICAgICAgcmV0dXJuIGV4cHIuY2xvbmUoKTtcbiAgICAgICAgfSxcbiAgICAgICAgJ2ZvYW0uY29yZS5Qcm9wZXJ0eSc6IGZ1bmN0aW9uKHByb3BlcnR5KSB7XG4gICAgICAgICAgcmV0dXJuIHByb3BlcnR5O1xuICAgICAgICB9XG4gICAgICB9LCBmdW5jdGlvbihwcmVkaWNhdGUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbnJlY29nbml6ZWQgcHJlZGljYXRlOiAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgIChwcmVkaWNhdGUgJiYgcHJlZGljYXRlLmNsc18gJiYgcHJlZGljYXRlLmNsc18uaWQpKTtcbiAgICAgIH0pXG4gICAgfVxuICBdXG59KTtcbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmZvYW0uQ0xBU1Moe1xuICBwYWNrYWdlOiAnZm9hbS5wYXJzZScsXG4gIG5hbWU6ICdRdWVyeVBhcnNlcicsXG5cbiAgZG9jdW1lbnRhdGlvbjpcbiAgICAgICdDcmVhdGUgYSBxdWVyeSBzdHJpbmdzIHRvIE1MYW5ncyBwYXJzZXIgZm9yIGEgcGFydGljdWxhciBjbGFzcy4nLFxuXG4gIGF4aW9tczogW1xuICAgIC8vIFJldXNlIHBhcnNlcnMgaWYgY3JlYXRlZCBmb3Igc2FtZSAnb2YnIGNsYXNzLlxuICAgIGZvYW0ucGF0dGVybi5NdWx0aXRvbi5jcmVhdGUoeyBwcm9wZXJ0eTogJ29mJyB9KVxuICBdLFxuXG4gIC8vIFRPRE8oYnJhZGVuKTogU3VwcG9ydCBLRVlXT1JEIHByZWRpY2F0ZXMgYW5kIHF1ZXJpZXMgb24gdGhlbS5cblxuICByZXF1aXJlczogW1xuICAgICdmb2FtLm1sYW5nLnByZWRpY2F0ZS5BbmQnLFxuICAgICdmb2FtLm1sYW5nLnByZWRpY2F0ZS5Db250YWluc0lDJyxcbiAgICAnZm9hbS5tbGFuZy5wcmVkaWNhdGUuRXEnLFxuICAgICdmb2FtLm1sYW5nLnByZWRpY2F0ZS5HdCcsXG4gICAgJ2ZvYW0ubWxhbmcucHJlZGljYXRlLkd0ZScsXG4gICAgJ2ZvYW0ubWxhbmcucHJlZGljYXRlLkhhcycsXG4gICAgJ2ZvYW0ubWxhbmcucHJlZGljYXRlLkluJyxcbiAgICAnZm9hbS5tbGFuZy5wcmVkaWNhdGUuSW5JQycsXG4gICAgJ2ZvYW0ubWxhbmcucHJlZGljYXRlLkx0JyxcbiAgICAnZm9hbS5tbGFuZy5wcmVkaWNhdGUuTHRlJyxcbiAgICAnZm9hbS5tbGFuZy5wcmVkaWNhdGUuTm90JyxcbiAgICAnZm9hbS5tbGFuZy5wcmVkaWNhdGUuT3InLFxuICAgICdmb2FtLm1sYW5nLnByZWRpY2F0ZS5UcnVlJyxcbiAgICAnZm9hbS5wYXJzZS5BbHRlcm5hdGUnLFxuICAgICdmb2FtLnBhcnNlLkltcGVyYXRpdmVHcmFtbWFyJyxcbiAgICAnZm9hbS5wYXJzZS5MaXRlcmFsSUMnLFxuICAgICdmb2FtLnBhcnNlLlBhcnNlcnMnLFxuICAgICdmb2FtLnBhcnNlLlByb3BlcnR5UmVmaW5lbWVudCcsXG4gICAgJ2ZvYW0ucGFyc2UuU3RyaW5nUFN0cmVhbSdcbiAgXSxcblxuICBwcm9wZXJ0aWVzOiBbXG4gICAge1xuICAgICAgY2xhc3M6ICdDbGFzcycsXG4gICAgICBuYW1lOiAnb2YnXG4gICAgfSxcbiAgICAvKiogQW4gb3B0aW9uYWwgaW5wdXQuIElmIHRoaXMgaXMgZGVmaW5lZCwgJ21lJyBpcyBhIGtleXdvcmQgaW4gdGhlIHNlYXJjaFxuICAgICAqIGFuZCBjYW4gYmUgdXNlZCBmb3IgcXVlcmllcyBsaWtlIDx0dD5vd25lcjptZTwvdHQ+LiBOb3RlIHRoYXQgc2luY2VcbiAgICAgKiB0aGVyZSBpcyBleGFjdGx5IG9uZSBwYXJzZXIgaW5zdGFuY2UgcGVyICdvZicgdmFsdWUsIHRoZSB2YWx1ZSBvZiAnbWUnIGlzXG4gICAgICogYWxzbyBzaGFyZWQuXG4gICAgICovXG4gICAge1xuICAgICAgY2xhc3M6ICdTdHJpbmcnLFxuICAgICAgbmFtZTogJ21lJ1xuICAgIH0sXG4gICAge1xuICAgICAgLy8gVGhlIGNvcmUgcXVlcnkgcGFyc2VyLiBOZWVkcyBhIGZpZWxkbmFtZSBzeW1ib2wgYWRkZWQgdG8gZnVuY3Rpb25cbiAgICAgIC8vIHByb3Blcmx5LlxuICAgICAgbmFtZTogJ2Jhc2VHcmFtbWFyXycsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24oYWx0LCBsaXRlcmFsLCBsaXRlcmFsSUMsIG5vdCwgbm90Q2hhcnMsIG9wdGlvbmFsLCByYW5nZSxcbiAgICAgICAgICByZXBlYXQsIHNlcSwgc2VxMSwgc3RyLCBzeW0pIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBTVEFSVDogc3ltKCdxdWVyeScpLFxuICAgICAgICAgIHF1ZXJ5OiBzeW0oJ29yJyksXG5cbiAgICAgICAgICBvcjogcmVwZWF0KHN5bSgnYW5kJyksIGFsdChsaXRlcmFsSUMoJyBPUiAnKSwgbGl0ZXJhbCgnIHwgJykpLCAxKSxcblxuICAgICAgICAgIGFuZDogcmVwZWF0KFxuICAgICAgICAgICAgICBzeW0oJ2V4cHInKSxcbiAgICAgICAgICAgICAgYWx0KGxpdGVyYWxJQygnIEFORCAnKSxcbiAgICAgICAgICAgICAgICAgIG5vdChhbHQobGl0ZXJhbElDKCcgT1InKSwgbGl0ZXJhbCgnIHwnKSksIGxpdGVyYWwoJyAnKSkpLFxuICAgICAgICAgICAgICAxKSxcblxuICAgICAgICAgIGV4cHI6IGFsdChcbiAgICAgICAgICAgICAgc3ltKCdwYXJlbicpLFxuICAgICAgICAgICAgICBzeW0oJ25lZ2F0ZScpLFxuICAgICAgICAgICAgICBzeW0oJ2hhcycpLFxuICAgICAgICAgICAgICBzeW0oJ2lzJyksXG4gICAgICAgICAgICAgIHN5bSgnZXF1YWxzJyksXG4gICAgICAgICAgICAgIHN5bSgnYmVmb3JlJyksXG4gICAgICAgICAgICAgIHN5bSgnYWZ0ZXInKSxcbiAgICAgICAgICAgICAgc3ltKCdpZCcpXG4gICAgICAgICAgKSxcblxuICAgICAgICAgIHBhcmVuOiBzZXExKDEsICcoJywgc3ltKCdxdWVyeScpLCAnKScpLFxuXG4gICAgICAgICAgbmVnYXRlOiBhbHQoXG4gICAgICAgICAgICAgIHNlcShsaXRlcmFsKCctJyksIHN5bSgnZXhwcicpKSxcbiAgICAgICAgICAgICAgc2VxKGxpdGVyYWxJQygnTk9UICcpLCBzeW0oJ2V4cHInKSlcbiAgICAgICAgICApLFxuXG4gICAgICAgICAgaWQ6IHN5bSgnbnVtYmVyJyksXG5cbiAgICAgICAgICBoYXM6IHNlcShsaXRlcmFsSUMoJ2hhczonKSwgc3ltKCdmaWVsZG5hbWUnKSksXG5cbiAgICAgICAgICBpczogc2VxKGxpdGVyYWxJQygnaXM6JyksIHN5bSgnZmllbGRuYW1lJykpLFxuXG4gICAgICAgICAgZXF1YWxzOiBzZXEoc3ltKCdmaWVsZG5hbWUnKSwgYWx0KCc6JywgJz0nKSwgc3ltKCd2YWx1ZUxpc3QnKSksXG5cbiAgICAgICAgICAvLyBUT0RPKGtncik6IE1lcmdlIHdpdGggJ2VxdWFscycuXG4gICAgICAgICAgYmVmb3JlOiBzZXEoc3ltKCdmaWVsZG5hbWUnKSwgYWx0KCc8PScsICc8JywgbGl0ZXJhbElDKCctYmVmb3JlOicpKSxcbiAgICAgICAgICAgICAgc3ltKCd2YWx1ZScpKSxcbiAgICAgICAgICBhZnRlcjogc2VxKHN5bSgnZmllbGRuYW1lJyksIGFsdCgnPj0nLCAnPicsIGxpdGVyYWxJQygnLWFmdGVyOicpKSxcbiAgICAgICAgICAgICAgc3ltKCd2YWx1ZScpKSxcblxuICAgICAgICAgIHZhbHVlOiBhbHQoXG4gICAgICAgICAgICAgIHN5bSgnbWUnKSxcbiAgICAgICAgICAgICAgc3ltKCdkYXRlJyksXG4gICAgICAgICAgICAgIHN5bSgnc3RyaW5nJyksXG4gICAgICAgICAgICAgIHN5bSgnbnVtYmVyJylcbiAgICAgICAgICApLFxuXG4gICAgICAgICAgY29tcG91bmRWYWx1ZTogYWx0KFxuICAgICAgICAgICAgICBzeW0oJ25lZ2F0ZVZhbHVlJyksXG4gICAgICAgICAgICAgIHN5bSgnb3JWYWx1ZScpLFxuICAgICAgICAgICAgICBzeW0oJ2FuZFZhbHVlJylcbiAgICAgICAgICApLFxuXG4gICAgICAgICAgbmVnYXRlVmFsdWU6IHNlcShcbiAgICAgICAgICAgICAgJygnLFxuICAgICAgICAgICAgICBhbHQoJy0nLCBsaXRlcmFsSUMoJ25vdCAnKSksXG4gICAgICAgICAgICAgIHN5bSgndmFsdWUnKSxcbiAgICAgICAgICAgICAgJyknXG4gICAgICAgICAgKSxcblxuICAgICAgICAgIG9yVmFsdWU6IHNlcShcbiAgICAgICAgICAgICAgJygnLFxuICAgICAgICAgICAgICByZXBlYXQoc3ltKCd2YWx1ZScpLCBhbHQoJ3wnLCBsaXRlcmFsSUMoJyBvciAnKSwgJyB8ICcpLCAxKSxcbiAgICAgICAgICAgICAgJyknXG4gICAgICAgICAgKSxcblxuICAgICAgICAgIGFuZFZhbHVlOiBzZXEoXG4gICAgICAgICAgICAgICcoJyxcbiAgICAgICAgICAgICAgcmVwZWF0KHN5bSgndmFsdWUnKSwgYWx0KGxpdGVyYWxJQygnIGFuZCAnKSwgJyAnKSwgMSksXG4gICAgICAgICAgICAgICcpJ1xuICAgICAgICAgICksXG5cbiAgICAgICAgICB2YWx1ZUxpc3Q6IGFsdChzeW0oJ2NvbXBvdW5kVmFsdWUnKSwgcmVwZWF0KHN5bSgndmFsdWUnKSwgJywnLCAxKSksXG5cbiAgICAgICAgICBtZTogc2VxKGxpdGVyYWxJQygnbWUnKSwgbm90KHN5bSgnY2hhcicpKSksXG5cbiAgICAgICAgICBkYXRlOiBhbHQoXG4gICAgICAgICAgICAgIHN5bSgncmFuZ2UgZGF0ZScpLFxuICAgICAgICAgICAgICBzeW0oJ2xpdGVyYWwgZGF0ZScpLFxuICAgICAgICAgICAgICBzeW0oJ3JlbGF0aXZlIGRhdGUnKVxuICAgICAgICAgICksXG5cbiAgICAgICAgICAncmFuZ2UgZGF0ZSc6IHNlcShcbiAgICAgICAgICAgICAgYWx0KHN5bSgnbGl0ZXJhbCBkYXRlJyksIHN5bSgnbnVtYmVyJykpLFxuICAgICAgICAgICAgICAnLi4nLFxuICAgICAgICAgICAgICBhbHQoc3ltKCdsaXRlcmFsIGRhdGUnKSwgc3ltKCdudW1iZXInKSkpLFxuXG4gICAgICAgICAgJ2xpdGVyYWwgZGF0ZSc6IGFsdChcbiAgICAgICAgICAgICAgLy8gWVlZWS1NTS1ERFRISDpNTVxuICAgICAgICAgICAgICBzZXEoc3ltKCdudW1iZXInKSwgJy0nLCBzeW0oJ251bWJlcicpLCAnLScsIHN5bSgnbnVtYmVyJyksICdUJyxcbiAgICAgICAgICAgICAgICAgIHN5bSgnbnVtYmVyJyksICc6Jywgc3ltKCdudW1iZXInKSksXG4gICAgICAgICAgICAgIC8vIFlZWVktTU0tRERUSEhcbiAgICAgICAgICAgICAgc2VxKHN5bSgnbnVtYmVyJyksICctJywgc3ltKCdudW1iZXInKSwgJy0nLCBzeW0oJ251bWJlcicpLCAnVCcsXG4gICAgICAgICAgICAgICAgICBzeW0oJ251bWJlcicpKSxcbiAgICAgICAgICAgICAgLy8gWVlZWS1NTS1ERFxuICAgICAgICAgICAgICBzZXEoc3ltKCdudW1iZXInKSwgJy0nLCBzeW0oJ251bWJlcicpLCAnLScsIHN5bSgnbnVtYmVyJykpLFxuICAgICAgICAgICAgICAvLyBZWVlZLU1NXG4gICAgICAgICAgICAgIHNlcShzeW0oJ251bWJlcicpLCAnLScsIHN5bSgnbnVtYmVyJykpLFxuICAgICAgICAgICAgICAvLyBZWS9NTS9ERFxuICAgICAgICAgICAgICBzZXEoc3ltKCdudW1iZXInKSwgJy8nLCBzeW0oJ251bWJlcicpLCAnLycsIHN5bSgnbnVtYmVyJykpXG4gICAgICAgICAgKSxcblxuICAgICAgICAgICdyZWxhdGl2ZSBkYXRlJzogc2VxKGxpdGVyYWxJQygndG9kYXknKSxcbiAgICAgICAgICAgICAgICBvcHRpb25hbChzZXEoJy0nLCBzeW0oJ251bWJlcicpKSkpLFxuXG4gICAgICAgICAgc3RyaW5nOiBhbHQoc3ltKCd3b3JkJyksIHN5bSgncXVvdGVkIHN0cmluZycpKSxcblxuICAgICAgICAgICdxdW90ZWQgc3RyaW5nJzogc2VxMSgxLCAnXCInLFxuICAgICAgICAgICAgICAgIHJlcGVhdChhbHQobGl0ZXJhbCgnXFxcXFwiJywgJ1wiJyksIG5vdENoYXJzKCdcIicpKSksXG4gICAgICAgICAgICAgICAgJ1wiJyksXG5cbiAgICAgICAgICB3b3JkOiByZXBlYXQoc3ltKCdjaGFyJyksIG51bGwsIDEpLFxuXG4gICAgICAgICAgY2hhcjogYWx0KHJhbmdlKCdhJywgJ3onKSwgcmFuZ2UoJ0EnLCAnWicpLCByYW5nZSgnMCcsICc5JyksICctJywgJ14nLFxuICAgICAgICAgICAgICAnXycsICdAJywgJyUnLCAnLicpLFxuICAgICAgICAgIG51bWJlcjogcmVwZWF0KHJhbmdlKCcwJywgJzknKSwgbnVsbCwgMSlcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHtcbiAgICAgIG5hbWU6ICdncmFtbWFyXycsXG4gICAgICBmYWN0b3J5OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGNscyA9IHRoaXMub2Y7XG4gICAgICAgIHZhciBmaWVsZHMgPSBbXTtcbiAgICAgICAgdmFyIHByb3BlcnRpZXMgPSBjbHMuZ2V0QXhpb21zQnlDbGFzcyhmb2FtLmNvcmUuUHJvcGVydHkpO1xuICAgICAgICBmb3IgKCB2YXIgaSA9IDA7IGkgPCBwcm9wZXJ0aWVzLmxlbmd0aDsgaSsrICkge1xuICAgICAgICAgIHZhciBwcm9wID0gcHJvcGVydGllc1tpXTtcbiAgICAgICAgICBmaWVsZHMucHVzaCh0aGlzLkxpdGVyYWxJQy5jcmVhdGUoe1xuICAgICAgICAgICAgczogcHJvcC5uYW1lLFxuICAgICAgICAgICAgdmFsdWU6IHByb3BcbiAgICAgICAgICB9KSk7XG4gICAgICAgICAgaWYgKCBwcm9wLnNob3J0TmFtZSApIHtcbiAgICAgICAgICAgIGZpZWxkcy5wdXNoKHRoaXMuTGl0ZXJhbElDLmNyZWF0ZSh7XG4gICAgICAgICAgICAgIHM6IHByb3Auc2hvcnROYW1lLFxuICAgICAgICAgICAgICB2YWx1ZTogcHJvcFxuICAgICAgICAgICAgfSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIHByb3AuYWxpYXNlcyApIHtcbiAgICAgICAgICAgIGZvciAoIHZhciBqID0gMDsgaiA8IHByb3AuYWxpYXNlcy5sZW5ndGg7IGorKyApIHtcbiAgICAgICAgICAgICAgZmllbGRzLnB1c2godGhpcy5MaXRlcmFsSUMuY3JlYXRlKHtcbiAgICAgICAgICAgICAgICBzOiBwcm9wLmFsaWFzZXNbal0sXG4gICAgICAgICAgICAgICAgdmFsdWU6IHByb3BcbiAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmaWVsZHMuc29ydChmdW5jdGlvbihhLCBiKSB7XG4gICAgICAgICAgdmFyIGQgPSBiLmxvd2VyLmxlbmd0aCAtIGEubG93ZXIubGVuZ3RoO1xuICAgICAgICAgIGlmICggZCAhPT0gMCApIHJldHVybiBkO1xuICAgICAgICAgIGlmICggYS5sb3dlciA9PT0gYi5sb3dlciApIHJldHVybiAwO1xuICAgICAgICAgIHJldHVybiBhLmxvd2VyIDwgYi5sb3dlciA/IDEgOiAtMTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdmFyIGJhc2UgPSBmb2FtLkZ1bmN0aW9uLndpdGhBcmdzKHRoaXMuYmFzZUdyYW1tYXJfLFxuICAgICAgICAgICAgdGhpcy5QYXJzZXJzLmNyZWF0ZSgpLCB0aGlzKTtcbiAgICAgICAgdmFyIGdyYW1tYXIgPSB7XG4gICAgICAgICAgX19wcm90b19fOiBiYXNlLFxuICAgICAgICAgIGZpZWxkbmFtZTogdGhpcy5BbHRlcm5hdGUuY3JlYXRlKHsgYXJnczogZmllbGRzIH0pXG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gVGhpcyBpcyBhIGNsb3N1cmUgdGhhdCdzIHVzZWQgYnkgc29tZSBvZiB0aGUgYWN0aW9ucyB0aGF0IGZvbGxvdy5cbiAgICAgICAgLy8gSWYgYSBEYXRlLXZhbHVlZCBmaWVsZCBpcyBzZXQgdG8gYSBzaW5nbGUgbnVtYmVyLCBpdCBleHBhbmRzIGludG8gYVxuICAgICAgICAvLyByYW5nZSBzcGFubmluZyB0aGF0IHdob2xlIHllYXIuXG4gICAgICAgIHZhciBtYXliZUNvbnZlcnRZZWFyVG9EYXRlUmFuZ2UgPSBmdW5jdGlvbihwcm9wLCBudW0pIHtcbiAgICAgICAgICB2YXIgaXNEYXRlRmllbGQgPSBmb2FtLmNvcmUuRGF0ZS5pc0luc3RhbmNlKHByb3ApIHx8XG4gICAgICAgICAgICAgIGZvYW0uY29yZS5EYXRlLmlzSW5zdGFuY2UocHJvcCk7XG4gICAgICAgICAgdmFyIGlzRGF0ZVJhbmdlID0gQXJyYXkuaXNBcnJheShudW0pICYmIG51bVswXSBpbnN0YW5jZW9mIERhdGU7XG5cbiAgICAgICAgICBpZiAoIGlzRGF0ZUZpZWxkICYmICEgaXNEYXRlUmFuZ2UgKSB7XG4gICAgICAgICAgICAvLyBDb252ZXJ0IHRoZSBudW1iZXIsIGEgc2luZ2xlIHllYXIsIGludG8gYSBkYXRlLlxuICAgICAgICAgICAgdmFyIHN0YXJ0ID0gbmV3IERhdGUoMCk7IC8vIEphbiAxIDE5NzAsIG1pZG5pZ2h0IFVUQy5cbiAgICAgICAgICAgIHZhciBlbmQgICA9IG5ldyBEYXRlKDApO1xuICAgICAgICAgICAgc3RhcnQuc2V0VVRDRnVsbFllYXIoK251bSk7XG4gICAgICAgICAgICBlbmQuc2V0VVRDRnVsbFllYXIoK251bSArIDEpO1xuICAgICAgICAgICAgcmV0dXJuIFsgc3RhcnQsIGVuZCBdO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbnVtO1xuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBjb21wYWN0VG9TdHJpbmcgPSBmdW5jdGlvbih2KSB7XG4gICAgICAgICAgcmV0dXJuIHYuam9pbignJyk7XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgICAgIC8vIFRPRE86IEZpeCBtZSB0byBqdXN0IGJ1aWxkIHRoZSBvYmplY3QgZGlyZWN0bHkuXG4gICAgICAgIHZhciBhY3Rpb25zID0ge1xuICAgICAgICAgIGlkOiBmdW5jdGlvbih2KSB7XG4gICAgICAgICAgICByZXR1cm4gc2VsZi5FcS5jcmVhdGUoe1xuICAgICAgICAgICAgICBhcmcxOiBjbHMuSUQsXG4gICAgICAgICAgICAgIGFyZzI6IHZcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0sXG5cbiAgICAgICAgICBvcjogZnVuY3Rpb24odikge1xuICAgICAgICAgICAgcmV0dXJuIHNlbGYuT3IuY3JlYXRlKHsgYXJnczogdiB9KTtcbiAgICAgICAgICB9LFxuXG4gICAgICAgICAgYW5kOiBmdW5jdGlvbih2KSB7XG4gICAgICAgICAgICByZXR1cm4gc2VsZi5BbmQuY3JlYXRlKHsgYXJnczogdiB9KTtcbiAgICAgICAgICB9LFxuXG4gICAgICAgICAgbmVnYXRlOiBmdW5jdGlvbih2KSB7XG4gICAgICAgICAgICByZXR1cm4gc2VsZi5Ob3QuY3JlYXRlKHsgYXJnMTogdlsxXSB9KTtcbiAgICAgICAgICB9LFxuXG4gICAgICAgICAgbnVtYmVyOiBmdW5jdGlvbih2KSB7XG4gICAgICAgICAgICByZXR1cm4gcGFyc2VJbnQoY29tcGFjdFRvU3RyaW5nKHYpKTtcbiAgICAgICAgICB9LFxuXG4gICAgICAgICAgbWU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHNlbGYubWUgfHwgJyc7XG4gICAgICAgICAgfSxcblxuICAgICAgICAgIGhhczogZnVuY3Rpb24odikge1xuICAgICAgICAgICAgcmV0dXJuIHNlbGYuSGFzLmNyZWF0ZSh7IGFyZzE6IHZbMV0gfSk7XG4gICAgICAgICAgfSxcblxuICAgICAgICAgIGlzOiBmdW5jdGlvbih2KSB7XG4gICAgICAgICAgICByZXR1cm4gc2VsZi5FcS5jcmVhdGUoe1xuICAgICAgICAgICAgICBhcmcxOiB2WzFdLFxuICAgICAgICAgICAgICBhcmcyOiBzZWxmLlRydWUuY3JlYXRlKClcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0sXG5cbiAgICAgICAgICBiZWZvcmU6IGZ1bmN0aW9uKHYpIHtcbiAgICAgICAgICAgIC8vIElmIHRoZSBwcm9wZXJ0eSAodlswXSkgaXMgYSBEYXRlKFRpbWUpUHJvcGVydHksIGFuZCB0aGUgdmFsdWVcbiAgICAgICAgICAgIC8vICh2WzJdKSBpcyBhIHNpbmdsZSBudW1iZXIsIGV4cGFuZCBpdCBpbnRvIGEgRGF0ZSByYW5nZSBmb3IgdGhhdFxuICAgICAgICAgICAgLy8gd2hvbGUgeWVhci5cbiAgICAgICAgICAgIHZbMl0gPSBtYXliZUNvbnZlcnRZZWFyVG9EYXRlUmFuZ2UodlswXSwgdlsyXSk7XG5cbiAgICAgICAgICAgIC8vIElmIHRoZSB2YWx1ZSAodlsyXSkgaXMgYSBEYXRlIHJhbmdlLCB1c2UgdGhlIGFwcHJvcHJpYXRlIGVuZCBwb2ludC5cbiAgICAgICAgICAgIGlmICggQXJyYXkuaXNBcnJheSh2WzJdKSAmJiB2WzJdWzBdIGluc3RhbmNlb2YgRGF0ZSApIHtcbiAgICAgICAgICAgICAgdlsyXSA9IHZbMV0gPT09ICc8PScgPyB2WzJdWzFdIDogdlsyXVswXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAodlsxXSA9PT0gJzw9JyA/IHNlbGYuTHRlIDogc2VsZi5MdCkuY3JlYXRlKHtcbiAgICAgICAgICAgICAgYXJnMTogdlswXSxcbiAgICAgICAgICAgICAgYXJnMjogdlsyXVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSxcblxuICAgICAgICAgIGFmdGVyOiBmdW5jdGlvbih2KSB7XG4gICAgICAgICAgICAvLyBJZiB0aGUgcHJvcGVydHkgKHZbMF0pIGlzIGEgRGF0ZShUaW1lKVByb3BlcnR5LCBhbmQgdGhlIHZhbHVlXG4gICAgICAgICAgICAvLyAodlsyXSkgaXMgYSBzaW5nbGUgbnVtYmVyLCBleHBhbmQgaXQgaW50byBhIERhdGUgcmFuZ2UgZm9yIHRoYXRcbiAgICAgICAgICAgIC8vIHdob2xlIHllYXIuXG4gICAgICAgICAgICB2WzJdID0gbWF5YmVDb252ZXJ0WWVhclRvRGF0ZVJhbmdlKHZbMF0sIHZbMl0pO1xuXG4gICAgICAgICAgICAvLyBJZiB0aGUgdmFsdWUgKHZbMl0pIGlzIGEgRGF0ZSByYW5nZSwgdXNlIHRoZSBhcHByb3ByaWF0ZSBlbmQgcG9pbnQuXG4gICAgICAgICAgICBpZiAoIEFycmF5LmlzQXJyYXkodlsyXSkgJiYgdlsyXVswXSBpbnN0YW5jZW9mIERhdGUgKSB7XG4gICAgICAgICAgICAgIHZbMl0gPSB2WzFdID09PSAnPj0nID8gdlsyXVswXSA6IHZbMl1bMV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gKHZbMV0gPT09ICc+PScgPyBzZWxmLkd0ZSA6IHNlbGYuR3QpLmNyZWF0ZSh7XG4gICAgICAgICAgICAgIGFyZzE6IHZbMF0sXG4gICAgICAgICAgICAgIGFyZzI6IHZbMl1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0sXG5cbiAgICAgICAgICBlcXVhbHM6IGZ1bmN0aW9uKHYpIHtcbiAgICAgICAgICAgIC8vIHZbMl0sIHRoZSB2YWx1ZXMsIGlzIGFuIGFycmF5LCB3aGljaCBtaWdodCBoYXZlIGFuICdhbmQnLCAnb3InIG9yXG4gICAgICAgICAgICAvLyAnbmVnYXRlZCcgcHJvcGVydHkgb24gaXQuIFRoZSBkZWZhdWx0IGlzICdvcicuIFRoZSBwYXJ0aWFsXG4gICAgICAgICAgICAvLyBldmFsdWF0b3IgZm9yIGV4cHJlc3Npb25zIGNhbiBzaW1wbGlmeSB0aGUgcmVzdWx0aW5nIE1sYW5nIGZ1cnRoZXIuXG4gICAgICAgICAgICB2YXIgcHJvcCA9IHZbMF07XG4gICAgICAgICAgICB2YXIgdmFsdWVzID0gdlsyXTtcbiAgICAgICAgICAgIC8vIEludCBpcyBhY3R1YWxseSB0aGUgcGFyZW50IG9mIEZsb2F0IGFuZCBMb25nLCBzbyB0aGlzIGNhcHR1cmVzIGFsbFxuICAgICAgICAgICAgLy8gbnVtZXJpYyBwcm9wZXJ0aWVzLlxuICAgICAgICAgICAgdmFyIGlzTnVtID0gZm9hbS5jb3JlLkludC5pc0luc3RhbmNlKHByb3ApO1xuICAgICAgICAgICAgdmFyIGlzRmxvYXQgPSBmb2FtLmNvcmUuRmxvYXQuaXNJbnN0YW5jZShwcm9wKTtcblxuICAgICAgICAgICAgdmFyIGlzRGF0ZUZpZWxkID0gZm9hbS5jb3JlLkRhdGUuaXNJbnN0YW5jZShwcm9wKSB8fFxuICAgICAgICAgICAgICAgIGZvYW0uY29yZS5EYXRlVGltZS5pc0luc3RhbmNlKHByb3ApO1xuICAgICAgICAgICAgdmFyIGlzRGF0ZVJhbmdlID0gQXJyYXkuaXNBcnJheSh2YWx1ZXNbMF0pICYmXG4gICAgICAgICAgICAgICAgdmFsdWVzWzBdWzBdIGluc3RhbmNlb2YgRGF0ZTtcblxuICAgICAgICAgICAgaWYgKCBpc0RhdGVGaWVsZCB8fCBpc0RhdGVSYW5nZSApIHtcbiAgICAgICAgICAgICAgaWYgKCAhIGlzRGF0ZVJhbmdlICkge1xuICAgICAgICAgICAgICAgIC8vIENvbnZlcnQgdGhlIHNpbmdsZSBudW1iZXIsIHJlcHJlc2VudGluZyBhIHllYXIsIGludG8gYVxuICAgICAgICAgICAgICAgIC8vIGRhdGUuXG4gICAgICAgICAgICAgICAgdmFyIHN0YXJ0ID0gbmV3IERhdGUoMCk7IC8vIEphbiAxIDE5NzAgYXQgbWlkbmlnaHQgVVRDXG4gICAgICAgICAgICAgICAgdmFyIGVuZCA9IG5ldyBEYXRlKDApO1xuICAgICAgICAgICAgICAgIHN0YXJ0LnNldFVUQ0Z1bGxZZWFyKHZhbHVlc1swXSk7XG4gICAgICAgICAgICAgICAgZW5kLnNldFVUQ0Z1bGxZZWFyKCt2YWx1ZXNbMF0gKyAxKTtcbiAgICAgICAgICAgICAgICB2YWx1ZXMgPSBbIFsgc3RhcnQsIGVuZCBdIF07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIHNlbGYuQW5kLmNyZWF0ZSh7XG4gICAgICAgICAgICAgICAgYXJnczogW1xuICAgICAgICAgICAgICAgICAgc2VsZi5HdGUuY3JlYXRlKHsgYXJnMTogcHJvcCwgYXJnMjogdmFsdWVzWzBdWzBdIH0pLFxuICAgICAgICAgICAgICAgICAgc2VsZi5MdC5jcmVhdGUoeyBhcmcxOiBwcm9wLCBhcmcyOiB2YWx1ZXNbMF1bMV0gfSlcbiAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgZXhwcjtcblxuICAgICAgICAgICAgaWYgKCBpc051bSApIHtcbiAgICAgICAgICAgICAgZm9yICggdmFyIGkgPSAwOyBpIDwgdmFsdWVzLmxlbmd0aDsgaSsrICkge1xuICAgICAgICAgICAgICAgIHZhbHVlc1tpXSA9IGlzRmxvYXQgPyBwYXJzZUZsb2F0KHZhbHVlc1tpXSkgOlxuICAgICAgICAgICAgICAgICAgICBwYXJzZUludCh2YWx1ZXNbaV0pO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgZXhwciA9IHNlbGYuSW4uY3JlYXRlKHsgYXJnMTogcHJvcCwgYXJnMjogdmFsdWVzIH0pO1xuICAgICAgICAgICAgfSBlbHNlIGlmICggZm9hbS5jb3JlLkVudW0uaXNJbnN0YW5jZShwcm9wKSApIHtcbiAgICAgICAgICAgICAgZXhwciA9IHNlbGYuSW4uY3JlYXRlKHsgYXJnMTogcHJvcCwgYXJnMjogdmFsdWVzIH0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgZXhwciA9ICh2WzFdID09PSAnPScpID9cbiAgICAgICAgICAgICAgICAgIHNlbGYuSW5JQy5jcmVhdGUoeyBhcmcxOiBwcm9wLCBhcmcyOiB2YWx1ZXMgfSkgOlxuICAgICAgICAgICAgICAgICAgc2VsZi5Pci5jcmVhdGUoe1xuICAgICAgICAgICAgICAgICAgICBhcmdzOiB2YWx1ZXMubWFwKGZ1bmN0aW9uKHYpIHtcbiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2VsZi5Db250YWluc0lDLmNyZWF0ZSh7IGFyZzE6IHByb3AsIGFyZzI6IHYgfSk7XG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCB2YWx1ZXMubmVnYXRlZCApIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHNlbGYuTm90LmNyZWF0ZSh7IGFyZzE6IGV4cHIgfSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKCB2YWx1ZXMuYW5kICkge1xuICAgICAgICAgICAgICByZXR1cm4gc2VsZi5BbmQuY3JlYXRlKHtcbiAgICAgICAgICAgICAgICBhcmdzOiB2YWx1ZXMubWFwKGZ1bmN0aW9uKHgpIHtcbiAgICAgICAgICAgICAgICAgIGV4cHIuY2xhc3NfLmNyZWF0ZSh7IGFyZzE6IGV4cHIuYXJnMSwgYXJnMjogWyB4IF0gfSk7XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZXR1cm4gZXhwcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuXG4gICAgICAgICAgbmVnYXRlVmFsdWU6IGZ1bmN0aW9uKHYpIHtcbiAgICAgICAgICAgIHYubmVnYXRlZCA9IHRydWU7XG4gICAgICAgICAgICByZXR1cm4gdjtcbiAgICAgICAgICB9LFxuXG4gICAgICAgICAgb3JWYWx1ZTogZnVuY3Rpb24odikge1xuICAgICAgICAgICAgdiA9IHZbMV07XG4gICAgICAgICAgICB2Lm9yID0gdHJ1ZTtcbiAgICAgICAgICAgIHJldHVybiB2O1xuICAgICAgICAgIH0sXG5cbiAgICAgICAgICBhbmRWYWx1ZTogZnVuY3Rpb24odikge1xuICAgICAgICAgICAgdiA9IHZbMV07XG4gICAgICAgICAgICB2LmFuZCA9IHRydWU7XG4gICAgICAgICAgICByZXR1cm4gdjtcbiAgICAgICAgICB9LFxuXG4gICAgICAgICAgLy8gQWxsIGRhdGVzIGFyZSBhY3R1YWxseSB0cmVhdGVkIGFzIHJhbmdlcy4gVGhlc2UgYXJlIGFycmF5cyBvZiBEYXRlXG4gICAgICAgICAgLy8gb2JqZWN0czogW3N0YXJ0LCBlbmRdLiBUaGUgc3RhcnQgaXMgaW5jbHVzaXZlIGFuZCB0aGUgZW5kIGV4Y2x1c2l2ZS5cbiAgICAgICAgICAvLyBVc2luZyB0aGVzZSBvYmplY3RzLCBib3RoIHJhbmdlcyAoZGF0ZToyMDE0LCBkYXRlOjIwMTQtMDUuLjIwMTQtMDYpXG4gICAgICAgICAgLy8gYW5kIG9wZW4tZW5kZWQgcmFuZ2VzIChkYXRlID4gMjAxNC0wMS0wMSkgY2FuIGJlIGNvbXB1dGVkIGhpZ2hlciB1cC5cbiAgICAgICAgICAvLyBEYXRlIGZvcm1hdHM6XG4gICAgICAgICAgLy8gWVlZWS1NTS1ERFRISDpNTSwgWVlZWS1NTS1ERFRISCwgWVlZWS1NTS1ERCwgWVlZWS1NTSwgWVkvTU0vREQsIFlZWVlcbiAgICAgICAgICAnbGl0ZXJhbCBkYXRlJzogZnVuY3Rpb24odikge1xuICAgICAgICAgICAgdmFyIHN0YXJ0O1xuICAgICAgICAgICAgdmFyIGVuZDtcblxuICAgICAgICAgICAgLy8gUHJldmlvdXNseSB3ZSB1c2VkIGp1c3QgbmV3IERhdGUoKSAoaWUuIHJpZ2h0IG5vdykuIFRoYXQgYnJlYWtzXG4gICAgICAgICAgICAvLyB3aGVuIHRoZSBjdXJyZW50IGRhdGUgaXMgZWcuIDMxIGJ1dCB0aGUgcGFyc2VkIGRhdGUgd2FudHMgdG8gYmUgYVxuICAgICAgICAgICAgLy8gc2hvcnRlciBtb250aCAoZWcuIEFwcmlsIHdpdGggMzAgZGF5cykuIFdlIHdvdWxkIHNldCB0aGUgbW9udGggdG9cbiAgICAgICAgICAgIC8vIEFwcmlsLCBidXQgXCJBcHJpbCAzMVwiIGdldHMgY29ycmVjdGVkIHRvIFwiTWF5IDFcIiBhbmQgdGhlbiBvdXJcbiAgICAgICAgICAgIC8vIHBhcnNlZCBkYXRlcyBhcmUgd3JvbmcuXG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgLy8gV2UgZml4IHRoYXQgYnkgdXNpbmcgYSBmaXhlZCBzdGFydGluZyBkYXRlIHRoYXQgd29uJ3QgZ2V0XG4gICAgICAgICAgICAvLyBhZGp1c3RlZCBsaWtlIHRoYXQuXG4gICAgICAgICAgICBzdGFydCA9IG5ldyBEYXRlKDIwMDAsIDAsIDEpO1xuICAgICAgICAgICAgZW5kICAgPSBuZXcgRGF0ZSgyMDAwLCAwLCAxKTtcbiAgICAgICAgICAgIHZhciBvcHMgPSBbICdGdWxsWWVhcicsICdNb250aCcsICdEYXRlJywgJ0hvdXJzJywgJ01pbnV0ZXMnLFxuICAgICAgICAgICAgICAgICdTZWNvbmRzJyBdO1xuICAgICAgICAgICAgdmFyIGRlZmF1bHRzID0gWyAwLCAxLCAxLCAwLCAwLCAwIF07XG4gICAgICAgICAgICBmb3IgKCB2YXIgaSA9IDA7IGkgPCBvcHMubGVuZ3RoOyBpKysgKSB7XG4gICAgICAgICAgICAgIHZhciB4ID0gaSAqIDIgPiB2Lmxlbmd0aCA/IGRlZmF1bHRzW2ldIDogdltpICogMl07XG4gICAgICAgICAgICAgIC8vIEFkanVzdCBmb3IgbW9udGhzIGJlaW5nIDAtYmFzZWQuXG4gICAgICAgICAgICAgIHZhciB2YWwgPSB4IC0gKGkgPT09IDEgPyAxIDogMCk7XG4gICAgICAgICAgICAgIHN0YXJ0WydzZXRVVEMnICsgb3BzW2ldXSh2YWwpO1xuICAgICAgICAgICAgICBlbmRbJ3NldFVUQycgKyBvcHNbaV1dKHZhbCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHN0YXJ0LnNldFVUQ01pbGxpc2Vjb25kcygwKTtcbiAgICAgICAgICAgIGVuZC5zZXRVVENNaWxsaXNlY29uZHMoMCk7XG5cbiAgICAgICAgICAgIC8vIHN0YXJ0IGFuZCBlbmQgYXJlIGN1cnJlbnRseSBjbG9uZXMgb2YgZWFjaCBvdGhlci4gV2UgYnVtcCB0aGUgbGFzdFxuICAgICAgICAgICAgLy8gcG9ydGlvbiBvZiB0aGUgZGF0ZSBhbmQgc2V0IGl0IGluIGVuZC5cbiAgICAgICAgICAgIHZhciBsYXN0ID0gTWF0aC5mbG9vcih2Lmxlbmd0aCAvIDIpO1xuICAgICAgICAgICAgdmFyIG9wID0gJ1VUQycgKyBvcHNbbGFzdF07XG4gICAgICAgICAgICBlbmRbJ3NldCcgKyBvcF0oZW5kWydnZXQnICsgb3BdKCkgKyAxKTtcblxuICAgICAgICAgICAgcmV0dXJuIFsgc3RhcnQsIGVuZCBdO1xuICAgICAgICAgIH0sXG5cbiAgICAgICAgICAncmVsYXRpdmUgZGF0ZSc6IGZ1bmN0aW9uKHYpIHtcbiAgICAgICAgICAgIC8vIFdlIHR1cm4gdGhpcyBpbnRvIGEgRGF0ZSByYW5nZSBmb3IgdGhlIGN1cnJlbnQgZGF5LCBvciBhIGRheSBhIGZld1xuICAgICAgICAgICAgLy8gd2Vla3MgYmVmb3JlLlxuICAgICAgICAgICAgdmFyIGQgPSBuZXcgRGF0ZSgpO1xuICAgICAgICAgICAgdmFyIHllYXIgID0gZC5nZXRGdWxsWWVhcigpO1xuICAgICAgICAgICAgdmFyIG1vbnRoID0gZC5nZXRNb250aCgpO1xuICAgICAgICAgICAgdmFyIGRhdGUgID0gZC5nZXREYXRlKCk7XG4gICAgICAgICAgICBpZiAoIHZbMV0gKSBkYXRlIC09IHZbMV1bMV07XG5cbiAgICAgICAgICAgIHJldHVybiBhY3Rpb25zWydsaXRlcmFsIGRhdGUnXShbIHllYXIsICctJywgbW9udGggKyAxLCAnLScsIGRhdGUgXSk7XG4gICAgICAgICAgfSxcblxuICAgICAgICAgICdyYW5nZSBkYXRlJzogZnVuY3Rpb24odikge1xuICAgICAgICAgICAgLy8gVGhpcyBnaXZlcyB0d28gZGF0ZXMsIGJ1dCBlYWNoIGhhcyBhbHJlYWR5IGJlZW4gY29udmVydGVkIHRvIGFcbiAgICAgICAgICAgIC8vIHJhbmdlLiBTbyB3ZSB0YWtlIHRoZSBzdGFydCBvZiB0aGUgZmlyc3QgYW5kIHRoZSBlbmQgb2YgdGhlIHNlY29uZC5cbiAgICAgICAgICAgIHZhciBzdGFydCA9IEFycmF5LmlzQXJyYXkodlswXSkgPyB2WzBdWzBdIDpcbiAgICAgICAgICAgICAgICB0eXBlb2YgdlswXSA9PT0gJ251bWJlcicgPyBuZXcgRGF0ZSh2WzBdLCAwLCAxKSA6IHZbMF07XG4gICAgICAgICAgICB2YXIgZW5kID0gQXJyYXkuaXNBcnJheSh2WzJdKSA/IHZbMl1bMV0gOlxuICAgICAgICAgICAgICAgIHR5cGVvZiB2WzJdID09PSAnbnVtYmVyJyA/IG5ldyBEYXRlKCt2WzJdICsgMSwgMCwgMSkgOiB2WzJdO1xuICAgICAgICAgICAgcmV0dXJuIFsgc3RhcnQsIGVuZCBdO1xuICAgICAgICAgIH0sXG5cbiAgICAgICAgICAncXVvdGVkIHN0cmluZyc6IGNvbXBhY3RUb1N0cmluZyxcbiAgICAgICAgICB3b3JkOiBjb21wYWN0VG9TdHJpbmdcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgZyA9IHRoaXMuSW1wZXJhdGl2ZUdyYW1tYXIuY3JlYXRlKHtcbiAgICAgICAgICBzeW1ib2xzOiBncmFtbWFyXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGcuYWRkQWN0aW9ucyhhY3Rpb25zKTtcbiAgICAgICAgcmV0dXJuIGc7XG4gICAgICB9XG4gICAgfVxuICBdLFxuXG4gIG1ldGhvZHM6IFtcbiAgICBmdW5jdGlvbiBwYXJzZVN0cmluZyhzdHIsIG9wdF9uYW1lKSB7XG4gICAgICB2YXIgcXVlcnkgPSB0aGlzLmdyYW1tYXJfLnBhcnNlU3RyaW5nKHN0ciwgb3B0X25hbWUpO1xuICAgICAgcmV0dXJuIHF1ZXJ5ICYmIHF1ZXJ5LnBhcnRpYWxFdmFsID8gcXVlcnkucGFydGlhbEV2YWwoKSA6IHF1ZXJ5O1xuICAgIH1cbiAgXVxufSk7XG5cblxuZm9hbS5DTEFTUyh7XG4gIHBhY2thZ2U6ICdmb2FtLnBhcnNlJyxcbiAgbmFtZTogJ1Byb3BlcnR5UmVmaW5lbWVudCcsXG4gIHJlZmluZXM6ICdmb2FtLmNvcmUuUHJvcGVydHknLFxuXG4gIHByb3BlcnRpZXM6IFtcbiAgICB7XG4gICAgICBjbGFzczogJ1N0cmluZ0FycmF5JyxcbiAgICAgIG5hbWU6ICdhbGlhc2VzJ1xuICAgIH1cbiAgXVxufSk7XG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5mb2FtLkNMQVNTKHtcbiAgcGFja2FnZTogJ2ZvYW0ucGh5c2ljcycsXG4gIG5hbWU6ICdQaHlzaWNhbCcsXG5cbiAgZG9jdW1lbnRhdGlvbjogJ0EgUGh5c2ljYWwgb2JqZWN0IGhhcyB2ZWxvY2l0eSBhbmQgbWFzcyBhbmQgbWF5IG9wdGlvbmFsbHkgYmUgc3ViamVjdCB0byBmcmljdGlvbiBhbmQgZ3Jhdml0eS4nLFxuXG4gIGNvbnN0YW50czoge1xuICAgIElORklOSVRFX01BU1M6IDEwMDAwXG4gIH0sXG5cbiAgcHJvcGVydGllczogW1xuICAgIHsgY2xhc3M6ICdGbG9hdCcsIG5hbWU6ICdmcmljdGlvbicgfSxcbiAgICB7IGNsYXNzOiAnRmxvYXQnLCBuYW1lOiAnZ3Jhdml0eScsIHZhbHVlOiAxIH0sXG4gICAgeyBjbGFzczogJ0Zsb2F0JywgbmFtZTogJ3Z4JywgdmFsdWU6IDAgfSxcbiAgICB7IGNsYXNzOiAnRmxvYXQnLCBuYW1lOiAndnknLCB2YWx1ZTogMCB9LFxuICAgIHtcbiAgICAgIGNsYXNzOiAnRmxvYXQnLFxuICAgICAgbmFtZTogJ3ZlbG9jaXR5JyxcbiAgICAgIGdldHRlcjogZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLmRpc3RhbmNlKHRoaXMudngsIHRoaXMudnkpOyB9LFxuICAgICAgc2V0dGVyOiBmdW5jdGlvbih2KSB7IHRoaXMuc2V0VmVsb2NpdHlBbmRBbmdsZSh2LCB0aGlzLmFuZ2xlT2ZWZWxvY2l0eSk7IH1cbiAgICB9LFxuICAgIHtcbiAgICAgIGNsYXNzOiAnRmxvYXQnLFxuICAgICAgbmFtZTogJ2FuZ2xlT2ZWZWxvY2l0eScsXG4gICAgICBnZXR0ZXI6IGZ1bmN0aW9uKCkgeyByZXR1cm4gTWF0aC5hdGFuMih0aGlzLnZ5LCB0aGlzLnZ4KTsgfSxcbiAgICAgIHNldHRlcjogZnVuY3Rpb24oYSkgeyB0aGlzLnNldFZlbG9jaXR5QW5kQW5nbGUodGhpcy52ZWxvY2l0eSwgYSk7IH1cbiAgICB9LFxuICAgIHsgY2xhc3M6ICdGbG9hdCcsIG5hbWU6ICdtYXNzJywgdmFsdWU6IDEgfVxuICBdLFxuXG4gIG1ldGhvZHM6IFtcbiAgICBmdW5jdGlvbiBkaXN0YW5jZShkeCwgZHkpIHtcbiAgICAgIHJldHVybiBNYXRoLnNxcnQoZHgqZHggKyBkeSpkeSk7XG4gICAgfSxcblxuICAgIGZ1bmN0aW9uIGFwcGx5TW9tZW50dW0obSwgYSkge1xuICAgICAgdGhpcy52eCArPSAobSAqIE1hdGguY29zKGEpIC8gdGhpcy5tYXNzKTtcbiAgICAgIHRoaXMudnkgKz0gKG0gKiBNYXRoLnNpbihhKSAvIHRoaXMubWFzcyk7XG4gICAgfSxcblxuICAgIGZ1bmN0aW9uIG1vbWVudHVtQXRBbmdsZShhKSB7XG4gICAgICBpZiAoIHRoaXMubWFzcyA9PT0gdGhpcy5JTkZJTklURV9NQVNTICkgcmV0dXJuIDA7XG4gICAgICB2YXIgdiA9IHRoaXMudmVsb2NpdHlBdEFuZ2xlKGEpO1xuICAgICAgcmV0dXJuIHYgKiB0aGlzLm1hc3M7XG4gICAgfSxcblxuICAgIGZ1bmN0aW9uIHZlbG9jaXR5QXRBbmdsZShhKSB7XG4gICAgICBpZiAoIHRoaXMubWFzcyA9PT0gdGhpcy5JTkZJTklURV9NQVNTICkgcmV0dXJuIDA7XG4gICAgICByZXR1cm4gTWF0aC5jb3MoYS10aGlzLmFuZ2xlT2ZWZWxvY2l0eSkgKiB0aGlzLnZlbG9jaXR5O1xuICAgIH0sXG5cbiAgICBmdW5jdGlvbiBzZXRWZWxvY2l0eUFuZEFuZ2xlKHYsIGEpIHtcbiAgICAgIHRoaXMudnggPSB2ICogTWF0aC5jb3MoYSk7XG4gICAgICB0aGlzLnZ5ID0gdiAqIE1hdGguc2luKGEpO1xuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgZnVuY3Rpb24gZGlzdGFuY2VUbyhvdGhlcikge1xuICAgICAgcmV0dXJuIHRoaXMuZGlzdGFuY2UodGhpcy54LW90aGVyLngsIHRoaXMueS1vdGhlci55KTtcbiAgICB9XG4gIF1cbn0pO1xuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuLyoqIENvbGxpc2lvbiBkZXRlY3Rpb24gbWFuYWdlci4gKiovXG5mb2FtLkNMQVNTKHtcbiAgcGFja2FnZTogJ2ZvYW0ucGh5c2ljcycsXG4gIG5hbWU6ICdDb2xsaWRlcicsXG5cbiAgZG9jdW1lbnRhdGlvbjogJ0FwcGx5IHBoeXNpY3Mgd2hlbiBvYmplY3RzIGNvbGxpZGUuJyxcblxuICB0b3BpY3M6IFsgJ29uVGljaycgXSxcblxuICBwcm9wZXJ0aWVzOiBbXG4gICAge1xuICAgICAgY2xhc3M6ICdCb29sZWFuJyxcbiAgICAgIG5hbWU6ICdib3VuY2VPbldhbGxzJ1xuICAgIH0sXG4gICAge1xuICAgICAgbmFtZTogJ2JvdW5kcycsXG4gICAgICBoaWRkZW46IHRydWVcbiAgICB9LFxuICAgIHtcbiAgICAgIG5hbWU6ICdjaGlsZHJlbicsXG4gICAgICBmYWN0b3J5OiBmdW5jdGlvbigpIHsgcmV0dXJuIFtdOyB9LFxuICAgICAgaGlkZGVuOiB0cnVlXG4gICAgfSxcbiAgICB7XG4gICAgICBjbGFzczogJ0Jvb2xlYW4nLFxuICAgICAgbmFtZTogJ3N0b3BwZWRfJyxcbiAgICAgIHZhbHVlOiB0cnVlLFxuICAgICAgaGlkZGVuOiB0cnVlXG4gICAgfVxuICBdLFxuXG4gIG1ldGhvZHM6IFtcbiAgICBmdW5jdGlvbiB1cGRhdGVDaGlsZChjKSB7XG4gICAgICBpZiAoIHRoaXMuYm91bmNlT25XYWxscyAmJiB0aGlzLmJvdW5kcyApIHtcblxuICAgICAgICBpZiAoIGMubGVmdF8gICA8IHRoaXMuYm91bmRzLnggICAgICApIHsgYy52eCA9ICBNYXRoLmFicyhjLnZ4KTsgYy54Kys7IH1cbiAgICAgICAgaWYgKCBjLnRvcF8gICAgPCB0aGlzLmJvdW5kcy55ICAgICAgKSB7IGMudnkgPSAgTWF0aC5hYnMoYy52eSk7IGMueSsrOyB9XG4gICAgICAgIGlmICggYy5yaWdodF8gID4gdGhpcy5ib3VuZHMud2lkdGggICkgeyBjLnZ4ID0gLU1hdGguYWJzKGMudngpOyBjLngtLTsgfVxuICAgICAgICBpZiAoIGMuYm90dG9tXyA+IHRoaXMuYm91bmRzLmhlaWdodCApIHsgYy52eSA9IC1NYXRoLmFicyhjLnZ5KTsgYy55LS07IH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgZnVuY3Rpb24gdXBkYXRlQ2hpbGRyZW4oKSB7XG4gICAgICB2YXIgY3MgPSB0aGlzLmNoaWxkcmVuO1xuICAgICAgZm9yICggdmFyIGkgPSAwIDsgaSA8IGNzLmxlbmd0aCA7IGkrKyApIHtcbiAgICAgICAgdGhpcy51cGRhdGVDaGlsZChjc1tpXSk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIGZ1bmN0aW9uIGRldGVjdENvbGxpc2lvbnMoKSB7XG4gICAgICAvKiBpbXBsaWNpdCBrLWQtdHJlZSBkaXZpZGUtYW5kLWNvbnF1ZXIgYWxnb3JpdGhtICovXG4gICAgICAgICAgICB0aGlzLmRldGVjdENvbGxpc2lvbnNfKDAsIHRoaXMuY2hpbGRyZW4ubGVuZ3RoLTEsICd4JywgZmFsc2UsICcnKTtcblxuICAgICAgLy8gVE9ETzogcHV0IGJhY2sgYWJvdmUgbGluZSB3aGVuIHByb3Blcmx5IHN1cHBvcnRzIG1peGluZyBjaXJjbGVzIGFuZCBzcXVhcmVzXG4gICAgICAvL3RoaXMuZGV0ZWN0Q29sbGlzaW9uc19fKDAsIHRoaXMuY2hpbGRyZW4ubGVuZ3RoLTEsICd4JywgZmFsc2UsICcnKTtcbiAgICB9LFxuXG4gICAgZnVuY3Rpb24gZGV0ZWN0Q29sbGlzaW9uc19fKHN0YXJ0LCBlbmQpIHtcbiAgICAgIC8qXG4gICAgICAgIFNpbXBsZSBPKG5eMikgYWxnb3JpdGhtLCB1c2VkIGJ5IG1vcmUgY29tcGxleCBhbGdvcml0aG1cbiAgICAgICAgb25jZSBkYXRhIGlzIHBhcnRpdGlvbmVkLlxuICAgICAgKi9cbiAgICAgIHZhciBjcyA9IHRoaXMuY2hpbGRyZW47XG4gICAgICBmb3IgKCB2YXIgaSA9IHN0YXJ0IDsgaSA8PSBlbmQgOyBpKysgKSB7XG4gICAgICAgIHZhciBjMSA9IGNzW2ldO1xuICAgICAgICBmb3IgKCB2YXIgaiA9IGkrMSA7IGogPD0gZW5kIDsgaisrICkge1xuICAgICAgICAgIHZhciBjMiA9IGNzW2pdO1xuICAgICAgICAgIGlmICggYzEuaW50ZXJzZWN0cyAmJiBjMS5pbnRlcnNlY3RzKGMyKSApIHRoaXMuY29sbGlkZShjMSwgYzIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIGZ1bmN0aW9uIGNob29zZVBpdm90KHN0YXJ0LCBlbmQsIGF4aXMpIHtcbiAgICAgIHZhciBwID0gMCwgY3MgPSB0aGlzLmNoaWxkcmVuLCBuID0gZW5kLXN0YXJ0O1xuICAgICAgZm9yICggdmFyIGkgPSBzdGFydCA7IGkgPD0gZW5kIDsgaSsrICkgcCArPSBjc1tpXVtheGlzXSAvIG47XG4gICAgICByZXR1cm4gcDtcbiAgICB9LFxuXG4gICAgLy8gVE9ETzogQWRkIHN1cHBvcnQgZm9yIHJlY3Rhbmd1bGFyIG9iamVjdHNcbiAgICBmdW5jdGlvbiBkZXRlY3RDb2xsaXNpb25zXyhzdGFydCwgZW5kLCBheGlzLCBvbmVEKSB7XG4gICAgICBpZiAoIHN0YXJ0ID49IGVuZCApIHJldHVybjtcblxuICAgICAgdmFyIGNzID0gdGhpcy5jaGlsZHJlbjtcbiAgICAgIHZhciBwaXZvdCA9IHRoaXMuY2hvb3NlUGl2b3Qoc3RhcnQsIGVuZCwgYXhpcyk7XG4gICAgICB2YXIgbmV4dEF4aXMgPSBvbmVEID8gYXhpcyA6IGF4aXMgPT09ICd4JyA/ICd5JyA6ICd4JyA7XG5cbiAgICAgIHZhciBwID0gc3RhcnQ7XG4gICAgICBmb3IgKCB2YXIgaSA9IHN0YXJ0IDsgaSA8PSBlbmQgOyBpKysgKSB7XG4gICAgICAgIHZhciBjID0gY3NbaV07XG4gICAgICAgIGlmICggY1theGlzXSAtIGMucmFkaXVzIDwgcGl2b3QgKSB7XG4gICAgICAgICAgdmFyIHQgPSBjc1twXTtcbiAgICAgICAgICBjc1twXSA9IGM7XG4gICAgICAgICAgY3NbaV0gPSB0O1xuICAgICAgICAgIHArKztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoIHAgPT09IGVuZCArIDEgKSB7XG4gICAgICAgIGlmICggb25lRCApIHtcbiAgICAgICAgICB0aGlzLmRldGVjdENvbGxpc2lvbnNfXyhzdGFydCwgZW5kKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmRldGVjdENvbGxpc2lvbnNfKHN0YXJ0LCBlbmQsIG5leHRBeGlzLCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5kZXRlY3RDb2xsaXNpb25zXyhzdGFydCwgcC0xLCBuZXh0QXhpcywgb25lRCk7XG5cbiAgICAgICAgcC0tO1xuICAgICAgICBmb3IgKCB2YXIgaSA9IHAgOyBpID49IHN0YXJ0IDsgaS0tICkge1xuICAgICAgICAgIHZhciBjID0gY3NbaV07XG4gICAgICAgICAgaWYgKCBjW2F4aXNdICsgYy5yYWRpdXMgPiBwaXZvdCApIHtcbiAgICAgICAgICAgIHZhciB0ID0gY3NbcF07XG4gICAgICAgICAgICBjc1twXSA9IGM7XG4gICAgICAgICAgICBjc1tpXSA9IHQ7XG4gICAgICAgICAgICBwLS07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICggcCA9PT0gc3RhcnQtMSApIHtcbiAgICAgICAgICBpZiAoIG9uZUQgKSB7XG4gICAgICAgICAgICB0aGlzLmRldGVjdENvbGxpc2lvbnNfXyhzdGFydCwgZW5kKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5kZXRlY3RDb2xsaXNpb25zXyhzdGFydCwgZW5kLCBuZXh0QXhpcywgdHJ1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuZGV0ZWN0Q29sbGlzaW9uc18ocCsxLCBlbmQsIG5leHRBeGlzLCBvbmVEKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICAvLyBUT0RPOiBhZGQgc3VwcG9ydCBmb3IgcmVjdGFuZ2xlc1xuICAgIGZ1bmN0aW9uIGNvbGxpZGUoYzEsIGMyKSB7XG4gICAgICBjMS5jb2xsaWRlV2l0aCAmJiBjMS5jb2xsaWRlV2l0aChjMik7XG4gICAgICBjMi5jb2xsaWRlV2l0aCAmJiBjMi5jb2xsaWRlV2l0aChjMSk7XG5cbiAgICAgIGlmICggISBjMS5tYXNzIHx8ICEgYzIubWFzcyApIHJldHVybjtcblxuICAgICAgdmFyIGEgID0gTWF0aC5hdGFuMihjMi55LWMxLnksIGMyLngtYzEueCk7XG4gICAgICB2YXIgbTEgPSAgYzEubW9tZW50dW1BdEFuZ2xlKGEpO1xuICAgICAgdmFyIG0yID0gLWMyLm1vbWVudHVtQXRBbmdsZShhKTtcbiAgICAgIHZhciBtICA9ICggbTEgKyBtMiApLzI7XG5cbiAgICAgIC8vIGVuc3VyZSBhIG1pbmltdW0gYW1vdW50IG9mIG1vbWVudHVtIHNvIHRoYXQgb2JqZWN0cyBkb24ndCBvdmVybGFwXG4gICAgICBpZiAoIG0gPj0gMCApIHtcbiAgICAgICAgbSA9IE1hdGgubWF4KDEsIG0pO1xuICAgICAgICB2YXIgdE1hc3MgPSBjMS5tYXNzICsgYzIubWFzcztcbiAgICAgICAgYzEuYXBwbHlNb21lbnR1bSgtbSAqIGMyLm1hc3MvdE1hc3MsIGEpO1xuICAgICAgICBjMi5hcHBseU1vbWVudHVtKCBtICogYzEubWFzcy90TWFzcywgYSk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8vIGFkZCBvbmUgb3IgbW9yZSBjb21wb25lbnRzIHRvIGJlIG1vbml0b3JlZCBmb3IgY29sbGlzaW9uc1xuICAgIGZ1bmN0aW9uIGFkZCgpIHtcbiAgICAgIGZvciAoIHZhciBpID0gMCA7IGkgPCBhcmd1bWVudHMubGVuZ3RoIDsgaSsrICkge1xuICAgICAgICB0aGlzLmNoaWxkcmVuLnB1c2goYXJndW1lbnRzW2ldKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBmdW5jdGlvbiBmaW5kQ2hpbGRBdCh4LCB5KSB7XG4gICAgICB2YXIgYzIgPSB7IHg6IHgsIHk6IHksIHI6IDEgfTtcblxuICAgICAgdmFyIGNzID0gdGhpcy5jaGlsZHJlbjtcbiAgICAgIC8vIFN0YXJ0IGZyb20gdGhlIGVuZCB0byBmaW5kIHRoZSBjaGlsZCBpbiB0aGUgZm9yZWdyb3VuZFxuICAgICAgZm9yICggdmFyIGkgPSBjcy5sZW5ndGgtMSA7IGkgPj0gMCA7IGktLSApIHtcbiAgICAgICAgdmFyIGMxID0gY3NbaV07XG4gICAgICAgIGlmICggYzEuaW50ZXJzZWN0cyhjMikgKSByZXR1cm4gYzE7XG4gICAgICB9XG4gICAgfSxcblxuICAgIGZ1bmN0aW9uIHNlbGVjdENoaWxkcmVuQXQoeCwgeSkge1xuICAgICAgdmFyIGMyID0geyB4OiB4LCB5OiB5LCByOiAxIH07XG5cbiAgICAgIHZhciBjaGlsZHJlbiA9IFtdO1xuICAgICAgdmFyIGNzID0gdGhpcy5jaGlsZHJlbjtcbiAgICAgIGZvciAoIHZhciBpID0gMCA7IGkgPCBjcy5sZW5ndGggOyBpKysgKSB7XG4gICAgICAgIHZhciBjMSA9IGNzW2ldO1xuICAgICAgICBpZiAoIGMxLmludGVyc2VjdHMoYzIpICkgY2hpbGRyZW4ucHVzaChjMSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gY2hpbGRyZW47XG4gICAgfSxcblxuICAgIGZ1bmN0aW9uIHJlbW92ZSgpIHtcbiAgICAgIGZvciAoIHZhciBpID0gMCA7IGkgPCBhcmd1bWVudHMubGVuZ3RoIDsgaSsrICkge1xuICAgICAgICBmb2FtLkFycmF5LnJlbW92ZSh0aGlzLmNoaWxkcmVuLCBhcmd1bWVudHNbaV0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIGZ1bmN0aW9uIGRldGFjaCgpIHtcbiAgICAgIHRoaXMuc3RvcHBlZF8gPSB0cnVlO1xuICAgICAgdGhpcy5jaGlsZHJlbiA9IFtdO1xuICAgIH1cbiAgXSxcblxuICBhY3Rpb25zOiBbXG4gICAge1xuICAgICAgbmFtZTogJ3N0YXJ0JyxcbiAgICAgIGlzRW5hYmxlZDogZnVuY3Rpb24oc3RvcHBlZF8pIHsgcmV0dXJuIHN0b3BwZWRfOyB9LFxuICAgICAgY29kZTogZnVuY3Rpb24gc3RhcnQoKSB7XG4gICAgICAgIHRoaXMuc3RvcHBlZF8gPSBmYWxzZTtcbiAgICAgICAgdGhpcy50aWNrKCk7XG4gICAgICB9XG4gICAgfSxcbiAgICB7XG4gICAgICBuYW1lOiAnc3RvcCcsXG4gICAgICBpc0VuYWJsZWQ6IGZ1bmN0aW9uKHN0b3BwZWRfKSB7IHJldHVybiAhIHN0b3BwZWRfOyB9LFxuICAgICAgY29kZTogZnVuY3Rpb24gc3RhcnQoKSB7IHRoaXMuc3RvcHBlZF8gPSB0cnVlOyB9XG4gICAgfVxuICBdLFxuXG4gIGxpc3RlbmVyczogW1xuICAgIHtcbiAgICAgIG5hbWU6ICd0aWNrJyxcbiAgICAgIGlzRnJhbWVkOiB0cnVlLFxuICAgICAgY29kZTogZnVuY3Rpb24gdGljaygpIHtcbiAgICAgICAgaWYgKCB0aGlzLnN0b3BwZWRfICkgcmV0dXJuO1xuICAgICAgICB0aGlzLm9uVGljay5wdWIoKTtcbiAgICAgICAgdGhpcy5kZXRlY3RDb2xsaXNpb25zKCk7XG4gICAgICAgIHRoaXMudXBkYXRlQ2hpbGRyZW4oKTtcblxuICAgICAgICB0aGlzLnRpY2soKTtcbiAgICAgIH1cbiAgICB9XG4gIF1cbn0pO1xuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTUgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuZm9hbS5DTEFTUyh7XG4gIHBhY2thZ2U6ICdmb2FtLnBoeXNpY3MnLFxuICBuYW1lOiAnUGh5c2ljc0VuZ2luZScsXG4gIGV4dGVuZHM6ICdmb2FtLnBoeXNpY3MuQ29sbGlkZXInLFxuXG4gIGRvY3VtZW50YXRpb246ICdQaHlzaWNzRW5naW5lIGlzIGEgc3ViLXR5cGUgb2YgQ29sbGlkZXIgd2hpY2ggYWRkcyBzdXBwb3J0IGZvciBmcmljdGlvbiBhbmQgZ3Jhdml0eS4nLFxuXG4gIHByb3BlcnRpZXM6IFtcbiAgICB7XG4gICAgICBjbGFzczogJ0Jvb2xlYW4nLFxuICAgICAgbmFtZTogJ2dyYXZpdHknLFxuICAgICAgdmFsdWU6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICBjbGFzczogJ0Zsb2F0JyxcbiAgICAgIG5hbWU6ICdncmF2aXR5U3RyZW5ndGgnLFxuICAgICAgdmFsdWU6IDFcbiAgICB9XG4gIF0sXG5cbiAgbWV0aG9kczogW1xuICAgIGZ1bmN0aW9uIHVwZGF0ZUNoaWxkKGMpIHtcbiAgICAgIHRoaXMuU1VQRVIoYyk7XG5cbiAgICAgIHZhciBncmF2aXR5ICA9IGMuZ3Jhdml0eTtcbiAgICAgIHZhciBmcmljdGlvbiA9IGMuZnJpY3Rpb247XG5cbiAgICAgIGlmICggZ3Jhdml0eSAmJiB0aGlzLmdyYXZpdHkgKSB7XG4gICAgICAgIGMudnkgKz0gZ3Jhdml0eSAqIHRoaXMuZ3Jhdml0eVN0cmVuZ3RoO1xuICAgICAgfVxuXG4gICAgICBpZiAoIGZyaWN0aW9uICkge1xuICAgICAgICBjLnZ4ID0gTWF0aC5hYnMoYy52eCkgPCAwLjAwMSA/IDAgOiBjLnZ4ICogZnJpY3Rpb247XG4gICAgICAgIGMudnkgPSBNYXRoLmFicyhjLnZ5KSA8IDAuMDAxID8gMCA6IGMudnkgKiBmcmljdGlvbjtcbiAgICAgIH1cblxuICAgICAgLy8gSW5lcnRpYVxuICAgICAgaWYgKCBNYXRoLmFicyhjLnZ4KSA+IDAuMDAxICkgYy54ICs9IGMudng7XG4gICAgICBpZiAoIE1hdGguYWJzKGMudnkpID4gMC4wMDEgKSBjLnkgKz0gYy52eTtcbiAgICB9XG4gIF1cbn0pO1xuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTYgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIENvcHlyaWdodCAyMDE3IFRoZSBGT0FNIEF1dGhvcnMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmZvYW0uQ0xBU1Moe1xuICBwYWNrYWdlOiAnZm9hbS5ibG9iJyxcbiAgbmFtZTogJ0J1ZmZlcicsXG5cbiAgcHJvcGVydGllczogW1xuICAgIHtcbiAgICAgIGNsYXNzOiAnTG9uZycsXG4gICAgICBuYW1lOiAnbGVuZ3RoJ1xuICAgIH0sXG4gICAge1xuICAgICAgbmFtZTogJ2RhdGEnLFxuICAgICAgZmFjdG9yeTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBuZXcgQXJyYXlCdWZmZXIodGhpcy5sZW5ndGgpO1xuICAgICAgfVxuICAgIH1cbiAgXSxcblxuICBtZXRob2RzOiBbXG4gICAgZnVuY3Rpb24gc2xpY2Uoc3RhcnQsIGVuZCkge1xuICAgICAgcmV0dXJuIGZvYW0uYmxvYi5CdWZmZXIuY3JlYXRlKCk7XG4gICAgfVxuICBdXG59KTtcblxuZm9hbS5JTlRFUkZBQ0Uoe1xuICBwYWNrYWdlOiAnZm9hbS5ibG9iJyxcbiAgbmFtZTogJ0Jsb2InLFxuXG4gIGphdmFFeHRlbmRzOiBbICdqYXZhLmlvLkNsb3NlYWJsZScgXSxcblxuICBtZXRob2RzOiBbXG4gICAge1xuICAgICAgbmFtZTogJ3JlYWQnLFxuICAgICAgcmV0dXJuczogJ1Byb21pc2UnLFxuICAgICAgYXJnczogW1xuICAgICAgICB7XG4gICAgICAgICAgbmFtZTogJ2J1ZmZlcicsXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICBjbGFzczogJ0xvbmcnLFxuICAgICAgICAgIHN3aWZ0VHlwZTogJ0ludCcsXG4gICAgICAgICAgbmFtZTogJ29mZnNldCdcbiAgICAgICAgfVxuICAgICAgXVxuICAgIH0sXG4gICAge1xuICAgICAgbmFtZTogJ2dldFNpemUnLFxuICAgICAgcmV0dXJuczogJ0xvbmcnLFxuICAgICAgc3dpZnRSZXR1cm5zOiAnSW50JyxcbiAgICB9XG4gIF1cbn0pO1xuXG5mb2FtLklOVEVSRkFDRSh7XG4gIHBhY2thZ2U6ICdmb2FtLmJsb2InLFxuICBuYW1lOiAnQmxvYlNlcnZpY2UnLFxuXG4gIGRvY3VtZW50YXRpb246ICdCbG9iU2VydmljZSBJbnRlcmZhY2UnLFxuXG4gIG1ldGhvZHM6IFtcbiAgICB7XG4gICAgICBuYW1lOiAncHV0JyxcbiAgICAgIHJldHVybnM6ICdQcm9taXNlJyxcbiAgICAgIGFyZ3M6IFtcbiAgICAgICAge1xuICAgICAgICAgIGNsYXNzOiAnQmxvYicsXG4gICAgICAgICAgbmFtZTogJ2Jsb2InXG4gICAgICAgIH1cbiAgICAgIF1cbiAgICB9LFxuICAgIHtcbiAgICAgIG5hbWU6ICdwdXRfJyxcbiAgICAgIHJldHVybnM6ICdQcm9taXNlJyxcbiAgICAgIGFyZ3M6IFtcbiAgICAgICAge1xuICAgICAgICAgIG5hbWU6ICd4JyxcbiAgICAgICAgICBvZjogJ2ZvYW0uY29yZS5YJ1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgY2xhc3M6ICdCbG9iJyxcbiAgICAgICAgICBuYW1lOiAnYmxvYidcbiAgICAgICAgfVxuICAgICAgXVxuICAgIH0sXG4gICAge1xuICAgICAgbmFtZTogJ2ZpbmQnLFxuICAgICAgcmV0dXJuczogJ1Byb21pc2UnLFxuICAgICAgYXJnczogW1xuICAgICAgICB7XG4gICAgICAgICAgY2xhc3M6ICdTdHJpbmcnLFxuICAgICAgICAgIG5hbWU6ICdpZCdcbiAgICAgICAgfVxuICAgICAgXVxuICAgIH0sXG4gICAge1xuICAgICAgbmFtZTogJ2ZpbmRfJyxcbiAgICAgIHJldHVybnM6ICdQcm9taXNlJyxcbiAgICAgIGFyZ3M6IFtcbiAgICAgICAge1xuICAgICAgICAgIG5hbWU6ICd4JyxcbiAgICAgICAgICBvZjogJ2ZvYW0uY29yZS5YJ1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgY2xhc3M6ICdTdHJpbmcnLFxuICAgICAgICAgIG5hbWU6ICdpZCdcbiAgICAgICAgfVxuICAgICAgXVxuICAgIH0sXG4gICAge1xuICAgICAgbmFtZTogJ3VybEZvcicsXG4gICAgICByZXR1cm5zOiAnU3RyaW5nJyxcbiAgICAgIGFyZ3M6IFtcbiAgICAgICAge1xuICAgICAgICAgIGNsYXNzOiAnQmxvYicsXG4gICAgICAgICAgbmFtZTogJ2Jsb2InXG4gICAgICAgIH1cbiAgICAgIF1cbiAgICB9LFxuICAgIHtcbiAgICAgIG5hbWU6ICd1cmxGb3JfJyxcbiAgICAgIHJldHVybnM6ICdTdHJpbmcnLFxuICAgICAgYXJnczogW1xuICAgICAgICB7XG4gICAgICAgICAgbmFtZTogJ3gnLFxuICAgICAgICAgIG9mOiAnZm9hbS5jb3JlLlgnXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICBjbGFzczogJ0Jsb2InLFxuICAgICAgICAgIG5hbWU6ICdibG9iJ1xuICAgICAgICB9XG4gICAgICBdXG4gICAgfVxuICBdXG59KTtcblxuXG5mb2FtLkNMQVNTKHtcbiAgcGFja2FnZTogJ2ZvYW0uYmxvYicsXG4gIG5hbWU6ICdBYnN0cmFjdEJsb2InLFxuICBhYnN0cmFjdDogdHJ1ZSxcblxuICBpbXBsZW1lbnRzOiBbICdmb2FtLmJsb2IuQmxvYicgXSxcblxuICBtZXRob2RzOiBbXG4gICAgZnVuY3Rpb24gcGlwZSh3cml0ZUZuKSB7XG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICAgIHZhciBvZmZzZXQgPSAwO1xuICAgICAgdmFyIGJ1ZiAgICA9IEJ1ZmZlci5hbGxvYyg4MTkyICogNCk7XG4gICAgICB2YXIgbGltaXQgID0gc2VsZi5zaXplO1xuXG4gICAgICBmdW5jdGlvbiBhKCkge1xuICAgICAgICBpZiAoIG9mZnNldCA+IGxpbWl0ICkge1xuICAgICAgICAgIHRocm93ICdPZmZlc3QgYmV5b25kIGxpbWl0Pyc7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIG9mZnNldCA9PSBsaW1pdCApIHJldHVybjtcblxuICAgICAgICByZXR1cm4gc2VsZi5yZWFkKGJ1Ziwgb2Zmc2V0KS50aGVuKGZ1bmN0aW9uKGJ1ZjIpIHtcbiAgICAgICAgICBvZmZzZXQgKz0gYnVmMi5sZW5ndGg7XG4gICAgICAgICAgcmV0dXJuIHdyaXRlRm4oQnVmZmVyLmZyb20oYnVmMikpO1xuICAgICAgICB9KS50aGVuKGEpO1xuICAgICAgfTtcblxuICAgICAgcmV0dXJuIGEoKTtcbiAgICB9LFxuXG4gICAgZnVuY3Rpb24gc2xpY2Uob2Zmc2V0LCBsZW5ndGgpIHtcbiAgICAgIHJldHVybiBmb2FtLmJsb2IuU3ViQmxvYi5jcmVhdGUoe1xuICAgICAgICBwYXJlbnQ6IHRoaXMsXG4gICAgICAgIG9mZnNldDogb2Zmc2V0LFxuICAgICAgICBzaXplOiBsZW5ndGhcbiAgICAgIH0pO1xuICAgIH1cbiAgXVxufSk7XG5cblxuZm9hbS5DTEFTUyh7XG4gIHBhY2thZ2U6ICdmb2FtLmJsb2InLFxuICBuYW1lOiAnQWJzdHJhY3RCbG9iU2VydmljZScsXG4gIGFic3RyYWN0OiB0cnVlLFxuXG4gIGltcGxlbWVudHM6IFsgJ2ZvYW0uYmxvYi5CbG9iU2VydmljZScgXSxcblxuICByZXF1aXJlczogW1xuICAgICdmb2FtLmJsb2IuUHJveHlCbG9iU2VydmljZSdcbiAgXSxcblxuICBtZXRob2RzOiBbXG4gICAge1xuICAgICAgbmFtZTogJ2luWCcsXG4gICAgICBjb2RlOiBmdW5jdGlvbiAoeCkge1xuICAgICAgICByZXR1cm4gdGhpcy5Qcm94eUJsb2JTZXJ2aWNlLmNyZWF0ZSh7IGRlbGVnYXRlOiB0aGlzIH0sIHgpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBmdW5jdGlvbiBwdXQoYmxvYikge1xuICAgICAgcmV0dXJuIHRoaXMucHV0Xyh0aGlzLl9fY29udGV4dF9fLCBibG9iKTtcbiAgICB9LFxuXG4gICAgZnVuY3Rpb24gZmluZChpZCkge1xuICAgICAgcmV0dXJuIHRoaXMuZmluZF8odGhpcy5fX2NvbnRleHRfXywgaWQpO1xuICAgIH0sXG5cbiAgICBmdW5jdGlvbiB1cmxGb3IoYmxvYikge1xuICAgICAgcmV0dXJuIHRoaXMudXJsRm9yXyh0aGlzLl9fY29udGV4dF9fLCBibG9iKTtcbiAgICB9XG4gIF1cbn0pO1xuXG5cbmZvYW0uQ0xBU1Moe1xuICBwYWNrYWdlOiAnZm9hbS5ibG9iJyxcbiAgbmFtZTogJ1Byb3h5QmxvYicsXG4gIGV4dGVuZHM6ICdmb2FtLmJsb2IuQWJzdHJhY3RCbG9iJyxcblxuICBkb2N1bWVudGF0aW9uOiAnUHJveHkgaW1wbGVtZW50YXRpb24gZm9yIHRoZSBCbG9iIGludGVyZmFjZScsXG5cbiAgcHJvcGVydGllczogW1xuICAgIHtcbiAgICAgIGNsYXNzOiAnUHJveHknLFxuICAgICAgb2Y6ICdmb2FtLmJsb2IuQmxvYicsXG4gICAgICBuYW1lOiAnZGVsZWdhdGUnLFxuICAgICAgZm9yd2FyZHM6IFsgJ3JlYWQnLCAnZ2V0U2l6ZScgXVxuICAgIH1cbiAgXVxufSk7XG5cblxuZm9hbS5DTEFTUyh7XG4gIHBhY2thZ2U6ICdmb2FtLmJsb2InLFxuICBuYW1lOiAnUHJveHlCbG9iU2VydmljZScsXG4gIGV4dGVuZHM6ICdmb2FtLmJsb2IuQWJzdHJhY3RCbG9iU2VydmljZScsXG5cbiAgZG9jdW1lbnRhdGlvbjogJ1Byb3h5IGltcGxlbWVudGF0aW9uIGZvciB0aGUgQmxvYlNlcnZpY2UgaW50ZXJmYWNlJyxcblxuICBwcm9wZXJ0aWVzOiBbXG4gICAge1xuICAgICAgY2xhc3M6ICdQcm94eScsXG4gICAgICBvZjogJ2ZvYW0uYmxvYi5CbG9iU2VydmljZScsXG4gICAgICBuYW1lOiAnZGVsZWdhdGUnLFxuICAgICAgZm9yd2FyZHM6IFsgJ3B1dF8nLCAnZmluZF8nLCAndXJsRm9yXycgXVxuICAgIH1cbiAgXVxufSk7XG5cblxuZm9hbS5DTEFTUyh7XG4gIHBhY2thZ2U6ICdmb2FtLmJsb2InLFxuICBuYW1lOiAnU3ViQmxvYicsXG4gIGV4dGVuZHM6ICdmb2FtLmJsb2IuQWJzdHJhY3RCbG9iJyxcblxuICBwcm9wZXJ0aWVzOiBbXG4gICAge1xuICAgICAgY2xhc3M6ICdCbG9iJyxcbiAgICAgIG5hbWU6ICdwYXJlbnQnLFxuICAgIH0sXG4gICAge1xuICAgICAgY2xhc3M6ICdMb25nJyxcbiAgICAgIG5hbWU6ICdvZmZzZXQnXG4gICAgfSxcbiAgICB7XG4gICAgICBjbGFzczogJ0xvbmcnLFxuICAgICAgbmFtZTogJ3NpemUnLFxuICAgICAgYXNzZXJ0VmFsdWU6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIGZvYW0uYXNzZXJ0KHRoaXMub2Zmc2V0ICsgdmFsdWUgPD0gdGhpcy5wYXJlbnQuc2l6ZSwgJ0Nhbm5vdCBjcmVhdGUgc3ViIGJsb2IgYmV5b25kIGVuZCBvZiBwYXJlbnQuJyk7XG4gICAgICB9XG4gICAgfVxuICBdLFxuXG4gIG1ldGhvZHM6IFtcbiAgICBmdW5jdGlvbiByZWFkKGJ1ZmZlciwgb2Zmc2V0KSB7XG4gICAgICBpZiAoIGJ1ZmZlci5sZW5ndGggPiB0aGlzLnNpemUgLSBvZmZzZXQpIHtcbiAgICAgICAgYnVmZmVyID0gYnVmZmVyLnNsaWNlKDAsIHRoaXMuc2l6ZSAtIG9mZnNldCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLnBhcmVudC5yZWFkKGJ1ZmZlciwgb2Zmc2V0ICsgdGhpcy5vZmZzZXQpO1xuICAgIH0sXG4gICAgZnVuY3Rpb24gc2xpY2Uob2Zmc2V0LCBsZW5ndGgpIHtcbiAgICAgIHJldHVybiBmb2FtLmJsb2IuU3ViQmxvYi5jcmVhdGUoe1xuICAgICAgICBwYXJlbnQ6IHRoaXMucGFyZW50LFxuICAgICAgICBvZmZzZXQ6IHRoaXMub2Zmc2V0ICsgb2Zmc2V0LFxuICAgICAgICBzaXplOiBsZW5ndGhcbiAgICAgIH0pO1xuICAgIH1cbiAgXVxufSk7XG5cblxuZm9hbS5DTEFTUyh7XG4gIHBhY2thZ2U6ICdmb2FtLmJsb2InLFxuICBuYW1lOiAnQmxvYkJsb2InLFxuICBleHRlbmRzOiAnZm9hbS5ibG9iLkFic3RyYWN0QmxvYicsXG5cbiAgcHJvcGVydGllczogW1xuICAgICdibG9iJyxcbiAgICB7XG4gICAgICBuYW1lOiAnc2l6ZScsXG4gICAgICBmYWN0b3J5OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYmxvYi5zaXplO1xuICAgICAgfVxuICAgIH1cbiAgXSxcblxuICBtZXRob2RzOiBbXG4gICAgZnVuY3Rpb24gcmVhZChidWZmZXIsIG9mZnNldCkge1xuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgdmFyIHJlYWRlciA9IG5ldyBGaWxlUmVhZGVyKCk7XG5cbiAgICAgIHZhciBiID0gdGhpcy5ibG9iLnNsaWNlKG9mZnNldCwgb2Zmc2V0ICsgYnVmZmVyLmxlbmd0aCk7XG5cbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgcmVhZGVyLm9ubG9hZCA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICByZXNvbHZlKGUucmVzdWx0KTtcbiAgICAgICAgfTtcblxuICAgICAgICByZWFkZXIub25lcnJvciA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICByZWplY3QoZSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgcmVhZGVyLnJlYWRBc0FycmF5QnVmZmVyKGIpO1xuICAgICAgfSk7XG4gICAgfVxuICBdXG59KTtcblxuXG5mb2FtLkNMQVNTKHtcbiAgcGFja2FnZTogJ2ZvYW0uYmxvYicsXG4gIG5hbWU6ICdJZGVudGlmaWVkQmxvYicsXG4gIGV4dGVuZHM6ICdmb2FtLmJsb2IuUHJveHlCbG9iJyxcblxuICBpbXBvcnRzOiBbXG4gICAgJ2Jsb2JTdG9yZT8nLFxuICAgICdibG9iU2VydmljZSdcbiAgXSxcblxuICBwcm9wZXJ0aWVzOiBbXG4gICAge1xuICAgICAgY2xhc3M6ICdTdHJpbmcnLFxuICAgICAgbmFtZTogJ2lkJ1xuICAgIH0sXG4gICAge1xuICAgICAgbmFtZTogJ2RlbGVnYXRlJyxcbiAgICAgIHRyYW5zaWVudDogdHJ1ZSxcbiAgICAgIGNsb25lUHJvcGVydHk6IGZ1bmN0aW9uKCl7fSxcbiAgICAgIGphdmFDbG9uZVByb3BlcnR5OiAnLy9ub3AnLFxuICAgICAgZmFjdG9yeTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJsb2JTZXJ2aWNlLmZpbmQodGhpcy5pZCk7XG4gICAgICB9LFxuICAgICAgamF2YUZhY3Rvcnk6ICdyZXR1cm4gKChCbG9iU2VydmljZSkgZ2V0QmxvYlN0b3JlKCkpLmZpbmQoZ2V0SWQoKSk7J1xuICAgIH1cbiAgXSxcblxuICBtZXRob2RzOiBbXG4gICAgZnVuY3Rpb24gY29tcGFyZVRvKG90aGVyKSB7XG4gICAgICByZXR1cm4gZm9hbS5ibG9iLklkZW50aWZpZWRCbG9iLmlzSW5zdGFuY2Uob3RoZXIpICYmIG90aGVyLmlkID09IHRoaXMuaWQ7XG4gICAgfSxcblxuICAgIGZ1bmN0aW9uIHJlYWQoYnVmZmVyLCBvZmZzZXQpIHtcbiAgICAgIHJldHVybiB0aGlzLmRlbGVnYXRlLnRoZW4oZnVuY3Rpb24oZCkge1xuICAgICAgICByZXR1cm4gZC5yZWFkKGJ1ZmZlciwgb2Zmc2V0KTtcbiAgICAgIH0pO1xuICAgIH1cbiAgXVxufSk7XG5cblxuZm9hbS5DTEFTUyh7XG4gIHBhY2thZ2U6ICdmb2FtLmNvcmUnLFxuICBuYW1lOiAnQmxvYicsXG4gIGV4dGVuZHM6ICdmb2FtLmNvcmUuRk9iamVjdFByb3BlcnR5JyxcblxuICBwcm9wZXJ0aWVzOiBbXG4gICAgWyAnb2YnLCAnZm9hbS5ibG9iLkJsb2InIF0sXG4gICAgWyAndGFibGVDZWxsVmlldycsIGZ1bmN0aW9uKCkge30gXSxcbiAgICBbICd2aWV3JywgeyBjbGFzczogJ2ZvYW0udTIudmlldy5CbG9iVmlldycgfSBdXG4gIF1cbn0pO1xuXG5cbmZvYW0uQ0xBU1Moe1xuICBwYWNrYWdlOiAnZm9hbS5ibG9iJyxcbiAgbmFtZTogJ0NsaWVudEJsb2InLFxuICBleHRlbmRzOiAnZm9hbS5ibG9iLkFic3RyYWN0QmxvYicsXG5cbiAgcHJvcGVydGllczogW1xuICAgIHtcbiAgICAgIGNsYXNzOiAnU3R1YicsXG4gICAgICBvZjogJ2ZvYW0uYmxvYi5CbG9iJyxcbiAgICAgIG5hbWU6ICdkZWxlZ2F0ZSdcbiAgICB9XG4gIF1cbn0pO1xuXG5cbmZvYW0uQ0xBU1Moe1xuICBwYWNrYWdlOiAnZm9hbS5ibG9iJyxcbiAgbmFtZTogJ0ZkQmxvYicsXG4gIGV4dGVuZHM6ICdmb2FtLmJsb2IuQWJzdHJhY3RCbG9iJyxcblxuICBwcm9wZXJ0aWVzOiBbXG4gICAge1xuICAgICAgbmFtZTogJ2ZkJ1xuICAgIH0sXG4gICAge1xuICAgICAgY2xhc3M6ICdMb25nJyxcbiAgICAgIG5hbWU6ICdzaXplJyxcbiAgICAgIGV4cHJlc3Npb246IGZ1bmN0aW9uKGZkKSB7XG4gICAgICAgIHJldHVybiByZXF1aXJlKCdmcycpLmZzdGF0U3luYyhmZCkuc2l6ZTtcbiAgICAgIH1cbiAgICB9XG4gIF0sXG5cbiAgbWV0aG9kczogW1xuICAgIGZ1bmN0aW9uIHJlYWQoYnVmZmVyLCBpbk9mZnNldCkge1xuICAgICAgaW5PZmZzZXQgPSBpbk9mZnNldCB8fCAwO1xuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgdmFyIG91dE9mZnNldCA9IDA7XG4gICAgICB2YXIgbGVuZ3RoID0gTWF0aC5taW4oYnVmZmVyLmxlbmd0aCwgdGhpcy5zaXplIC0gaW5PZmZzZXQpO1xuXG4gICAgICBpZiAoIGxlbmd0aCA8IGJ1ZmZlci5sZW5ndGggKSBidWZmZXIgPSBidWZmZXIuc2xpY2UoMCwgbGVuZ3RoKTtcblxuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBmdW5jdGlvbiBvblJlYWQoZXJyLCBieXRlc1JlYWQsIGJ1ZmZlcikge1xuICAgICAgICAgIGlmICggZXJyICkge1xuICAgICAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgb3V0T2Zmc2V0ICs9IGJ5dGVzUmVhZDtcbiAgICAgICAgICBpbk9mZnNldCArPSBieXRlc1JlYWQ7XG5cbiAgICAgICAgICBpZiAoIG91dE9mZnNldCA8IGxlbmd0aCApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRG9lcyB0aGlzIGV2ZXIgaGFwcGVuLicpO1xuLy8gICAgICAgICAgICByZXF1aXJlKCdmcycpLnJlYWQoc2VsZi5mZCwgYnVmZmVyLCBvdXRPZmZzZXQsIGxlbmd0aCAtIG91dE9mZnNldCwgaW5PZmZzZXQsIG9uUmVhZCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc29sdmUoYnVmZmVyKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXF1aXJlKCdmcycpLnJlYWQoc2VsZi5mZCwgYnVmZmVyLCBvdXRPZmZzZXQsIGxlbmd0aCAtIG91dE9mZnNldCwgaW5PZmZzZXQsIG9uUmVhZCk7XG4gICAgICB9KTtcbiAgICB9XG4gIF1cbn0pO1xuXG5cbmZvYW0uQ0xBU1Moe1xuICBwYWNrYWdlOiAnZm9hbS5ibG9iJyxcbiAgbmFtZTogJ0Jsb2JTdG9yZScsXG4gIGV4dGVuZHM6ICdmb2FtLmJsb2IuQWJzdHJhY3RCbG9iU2VydmljZScsXG5cbiAgcmVxdWlyZXM6IFtcbiAgICAnZm9hbS5ibG9iLklkZW50aWZpZWRCbG9iJ1xuICBdLFxuXG4gIHByb3BlcnRpZXM6IFtcbiAgICB7XG4gICAgICBjbGFzczogJ1N0cmluZycsXG4gICAgICBuYW1lOiAncm9vdCdcbiAgICB9LFxuICAgIHtcbiAgICAgIGNsYXNzOiAnU3RyaW5nJyxcbiAgICAgIG5hbWU6ICd0bXAnLFxuICAgICAgdHJhbnNpZW50OiB0cnVlLFxuICAgICAgZXhwcmVzc2lvbjogZnVuY3Rpb24ocm9vdCkge1xuICAgICAgICByZXR1cm4gcm9vdCArICcvdG1wJztcbiAgICAgIH1cbiAgICB9LFxuICAgIHtcbiAgICAgIGNsYXNzOiAnU3RyaW5nJyxcbiAgICAgIG5hbWU6ICdzaGEyNTYnLFxuICAgICAgdHJhbnNpZW50OiB0cnVlLFxuICAgICAgZXhwcmVzc2lvbjogZnVuY3Rpb24ocm9vdCkge1xuICAgICAgICByZXR1cm4gcm9vdCArICcvc2hhMjU2JztcbiAgICAgIH1cbiAgICB9LFxuICAgIHtcbiAgICAgIGNsYXNzOiAnQm9vbGVhbicsXG4gICAgICBuYW1lOiAnaXNTZXQnLFxuICAgICAgdmFsdWU6IGZhbHNlLFxuICAgICAgaGlkZGVuOiB0cnVlLFxuICAgICAgdHJhbnNpZW50OiB0cnVlXG4gICAgfVxuICBdLFxuXG4gIG1ldGhvZHM6IFtcbiAgICBmdW5jdGlvbiBzZXR1cCgpIHtcbiAgICAgIGlmICggdGhpcy5pc1NldCApIHJldHVybjtcblxuICAgICAgdmFyIHBhcnNlZCA9IHJlcXVpcmUoJ3BhdGgnKS5wYXJzZSh0aGlzLnJvb3QpO1xuXG4gICAgICBpZiAoICEgcmVxdWlyZSgnZnMnKS5zdGF0U3luYyhwYXJzZWQuZGlyKS5pc0RpcmVjdG9yeSgpICkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IocGFyc2VkLmRpciArICcgaXMgbm90IGEgZGlyZWN0b3J5LicpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmVuc3VyZURpcih0aGlzLnJvb3QpO1xuICAgICAgdGhpcy5lbnN1cmVEaXIodGhpcy50bXApO1xuICAgICAgdGhpcy5lbnN1cmVEaXIodGhpcy5zaGEyNTYpO1xuXG4gICAgICB0aGlzLmlzU2V0ID0gdHJ1ZTtcbiAgICB9LFxuXG4gICAgZnVuY3Rpb24gZW5zdXJlRGlyKHBhdGgpIHtcbiAgICAgIHZhciBzdGF0O1xuXG4gICAgICB0cnkge1xuICAgICAgICBzdGF0ID0gcmVxdWlyZSgnZnMnKS5zdGF0U3luYyhwYXRoKTtcbiAgICAgICAgaWYgKCBzdGF0ICYmIHN0YXQuaXNEaXJlY3RvcnkoKSApIHJldHVybjtcbiAgICAgIH0gY2F0Y2goZSkge1xuICAgICAgICBpZiAoIGUuY29kZSA9PT0gJ0VOT0VOVCcgKSByZXR1cm4gcmVxdWlyZSgnZnMnKS5ta2RpclN5bmMocGF0aCk7XG5cbiAgICAgICAgdGhyb3cgZTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgZnVuY3Rpb24gYWxsb2NhdGVUbXAoKSB7XG4gICAgICB2YXIgZmQ7XG4gICAgICB2YXIgcGF0aDtcbiAgICAgIC8vICAgICAgdmFyIG5hbWUgPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAweEZGRkZGRilcbiAgICAgIHZhciBuYW1lID0gMTtcbiAgICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIGFhYShyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgcGF0aCA9IHNlbGYudG1wICsgcmVxdWlyZSgncGF0aCcpLnNlcCArIChuYW1lKyspO1xuICAgICAgICBmZCA9IHJlcXVpcmUoJ2ZzJykub3BlbihwYXRoLCAnd3gnLCBmdW5jdGlvbiBvbk9wZW4oZXJyLCBmZCkge1xuICAgICAgICAgIGlmICggZXJyICYmIGVyci5jb2RlICE9PSAnRUVYSVNUJyApIHtcbiAgICAgICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICggZXJyICkgYWFhKHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgICAgZWxzZSByZXNvbHZlKHsgcGF0aDogcGF0aCwgZmQ6IGZkfSk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfSxcblxuICAgIGZ1bmN0aW9uIHB1dF8oeCwgb2JqKSB7XG4gICAgICBpZiAoIHRoaXMuSWRlbnRpZmllZEJsb2IuaXNJbnN0YW5jZShvYmopICkge1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnNldHVwKCk7XG4gICAgICAvLyBUaGlzIHByb2Nlc3MgY291bGQgcHJvYmFibHkgYmUgc3BlZCB1cCBhIGJpdCBieVxuICAgICAgLy8gcmVxdWVzdGluZyBjaHVua3Mgb2YgdGhlIGluY29taW5nIGJsb2IgaW4gYWR2YW5jZSxcbiAgICAgIC8vIGN1cnJlbnRseSB3ZSB3YWl0IHVudGlsIHRoZXkncmUgcHV0IGludG8gdGhlIHdyaXRlLXN0cmVhbSdzXG4gICAgICAvLyBidWZmZXIgYmVmb3JlIHJlcXVlc2l0bmcgdGhlIG5leHQgY2h1bmsuXG5cbiAgICAgIHZhciBoYXNoID0gcmVxdWlyZSgnY3J5cHRvJykuY3JlYXRlSGFzaCgnc2hhMjU2Jyk7XG5cbiAgICAgIHZhciBidWZzaXplID0gODE5MjtcbiAgICAgIHZhciBidWZmZXIgPSBCdWZmZXIuYWxsb2MoYnVmc2l6ZSk7XG5cbiAgICAgIHZhciBzaXplID0gb2JqLnNpemVcbiAgICAgIHZhciByZW1haW5pbmcgPSBzaXplO1xuICAgICAgdmFyIG9mZnNldCA9IDA7XG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICAgIHZhciBjaHVua3MgPSBNYXRoLmNlaWwoc2l6ZSAvIGJ1ZnNpemUpO1xuXG4gICAgICBmdW5jdGlvbiBjaHVua09mZnNldChpKSB7XG4gICAgICAgIHJldHVybiBpICogYnVmc2l6ZTtcbiAgICAgIH1cblxuICAgICAgdmFyIHRtcDtcblxuICAgICAgZnVuY3Rpb24gd3JpdGVDaHVuayhjaHVuaykge1xuICAgICAgICByZXR1cm4gb2JqLnJlYWQoYnVmZmVyLCBjaHVua09mZnNldChjaHVuaykpLnRoZW4oZnVuY3Rpb24oYnVmKSB7XG4gICAgICAgICAgaGFzaC51cGRhdGUoYnVmKTtcbiAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICByZXF1aXJlKCdmcycpLndyaXRlKHRtcC5mZCwgYnVmLCAwLCBidWYubGVuZ3RoLCBmdW5jdGlvbiBjYihlcnIsIHdyaXR0ZW4sIGJ1ZmZlcikge1xuICAgICAgICAgICAgICBpZiAoIGVyciApIHtcbiAgICAgICAgICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBpZiAoIHdyaXR0ZW4gIT09IGJ1Zi5sZW5ndGggKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKFwiRGlkbid0IHdyaXRlIGVudGlyZSBjaHVuaywgZG9lcyB0aGlzIGV2ZXIgaGFwcGVuP1wiKTtcbiAgICAgICAgICAgICAgICByZXF1aXJlKCdmcycpLndyaXRlKHRtcC5mZCwgYnVmLnNsaWNlKHdyaXR0ZW4pLCBjYik7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICB2YXIgY2h1bmsgPSAwO1xuICAgICAgcmV0dXJuIHRoaXMuYWxsb2NhdGVUbXAoKS50aGVuKGZ1bmN0aW9uKHRtcGZpbGUpIHtcbiAgICAgICAgdG1wID0gdG1wZmlsZTtcbiAgICAgIH0pLnRoZW4oZnVuY3Rpb24gYSgpIHtcbiAgICAgICAgaWYgKCBjaHVuayA8IGNodW5rcyApIHJldHVybiB3cml0ZUNodW5rKGNodW5rKyspLnRoZW4oYSk7XG4gICAgICB9KS50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgcmVxdWlyZSgnZnMnKS5jbG9zZSh0bXAuZmQsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGRpZ2VzdCA9IGhhc2guZGlnZXN0KCdoZXgnKTtcbiAgICAgICAgICAgIHJlcXVpcmUoJ2ZzJykucmVuYW1lKHRtcC5wYXRoLCBzZWxmLnNoYTI1NiArIHJlcXVpcmUoJ3BhdGgnKS5zZXAgKyBkaWdlc3QsIGZ1bmN0aW9uKGVycikge1xuICAgICAgICAgICAgICBpZiAoIGVyciApIHtcbiAgICAgICAgICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmVzb2x2ZShzZWxmLklkZW50aWZpZWRCbG9iLmNyZWF0ZSh7IGlkOiBkaWdlc3QgfSkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfSxcblxuICAgIGZ1bmN0aW9uIGZpbGVuYW1lKGJsb2IpIHtcbiAgICAgIGlmICggISBmb2FtLmJsb2IuSWRlbnRpZmllZEJsb2IuaXNJbnN0YW5jZShibG9iKSApIHJldHVybiBudWxsO1xuXG4gICAgICB2YXIgcGF0aCA9IHRoaXMuc2hhMjU2ICsgcmVxdWlyZSgncGF0aCcpLnNlcCArIGJsb2IuaWQ7XG4gICAgICB0cnkge1xuICAgICAgICByZXF1aXJlKCdmcycpLnN0YXRTeW5jKHBhdGgpO1xuICAgICAgfSBjYXRjaChlKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcGF0aDtcbiAgICB9LFxuXG4gICAgZnVuY3Rpb24gZmluZF8oeCwgaWQpIHtcbiAgICAgIHRoaXMuc2V0dXAoKTtcbiAgICAgIGlmICggaWQuaW5kZXhPZihyZXF1aXJlKCdwYXRoJykuc2VwKSAhPSAtMSApIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcihcIkludmFsaWQgZmlsZSBuYW1lXCIpKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIHJlcXVpcmUoJ2ZzJykub3BlbihzZWxmLnNoYTI1NiArIHJlcXVpcmUoJ3BhdGgnKS5zZXAgKyBpZCwgXCJyXCIsIGZ1bmN0aW9uKGVyciwgZmQpIHtcbiAgICAgICAgICBpZiAoIGVyciApIHtcbiAgICAgICAgICAgIGlmICggZXJyLmNvZGUgPT0gJ0VOT0VOVCcgKSB7XG4gICAgICAgICAgICAgIHJlc29sdmUobnVsbCk7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIHJlc29sdmUoZm9hbS5ibG9iLkZkQmxvYi5jcmVhdGUoeyBmZDogZmQgfSkpO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH1cbiAgXVxufSk7XG5cblxuZm9hbS5DTEFTUyh7XG4gIHBhY2thZ2U6ICdmb2FtLmJsb2InLFxuICBuYW1lOiAnUmVzdEJsb2JTZXJ2aWNlJyxcbiAgZXh0ZW5kczogJ2ZvYW0uYmxvYi5BYnN0cmFjdEJsb2JTZXJ2aWNlJyxcblxuICBkb2N1bWVudGF0aW9uOiAnSW1wbGVtZW50YXRpb24gb2YgYSBCbG9iU2VydmljZSBhZ2FpbnN0IGEgUkVTVCBpbnRlcmZhY2UuJyxcblxuICByZXF1aXJlczogW1xuICAgICdmb2FtLm5ldC5IVFRQUmVxdWVzdCcsXG4gICAgJ2ZvYW0uYmxvYi5CbG9iQmxvYicsXG4gICAgJ2ZvYW0uYmxvYi5JZGVudGlmaWVkQmxvYidcbiAgXSxcblxuICBwcm9wZXJ0aWVzOiBbXG4gICAge1xuICAgICAgY2xhc3M6ICdTdHJpbmcnLFxuICAgICAgbmFtZTogJ3NlcnZpY2VOYW1lJ1xuICAgIH0sXG4gICAge1xuICAgICAgY2xhc3M6ICdTdHJpbmcnLFxuICAgICAgbmFtZTogJ2FkZHJlc3MnLFxuICAgICAgZmFjdG9yeTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBzZXNzaW9uSWQgPSBsb2NhbFN0b3JhZ2VbJ2RlZmF1bHRTZXNzaW9uJ107XG4gICAgICAgIHZhciB1cmwgPSB3aW5kb3cubG9jYXRpb24ub3JpZ2luICsgJy8nICsgdGhpcy5zZXJ2aWNlTmFtZVxuICAgICAgICAvLyBhdHRhY2ggc2Vzc2lvbiBpZCBpZiBhdmFpbGFibGVcbiAgICAgICAgaWYgKCBzZXNzaW9uSWQgKSB7XG4gICAgICAgICAgdXJsICs9ICc/c2Vzc2lvbklkPScgKyBzZXNzaW9uSWQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVybDtcbiAgICAgIH1cbiAgICB9XG4gIF0sXG5cbiAgbWV0aG9kczogW1xuICAgIGZ1bmN0aW9uIHB1dF8oeCwgYmxvYikge1xuICAgICAgaWYgKCB0aGlzLklkZW50aWZpZWRCbG9iLmlzSW5zdGFuY2UoYmxvYikgKSB7XG4gICAgICAgIC8vIEFscmVhZHkgc3RvcmVkLlxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGJsb2IpO1xuICAgICAgfVxuXG4gICAgICB2YXIgcmVxID0gdGhpcy5IVFRQUmVxdWVzdC5jcmVhdGUoKTtcbiAgICAgIHJlcS5mcm9tVXJsKHRoaXMuYWRkcmVzcyk7XG4gICAgICByZXEubWV0aG9kID0gJ1BVVCc7XG4gICAgICByZXEucGF5bG9hZCA9IGJsb2I7XG5cbiAgICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgICAgcmV0dXJuIHJlcS5zZW5kKCkudGhlbihmdW5jdGlvbihyZXNwKSB7XG4gICAgICAgIHJldHVybiByZXNwLnBheWxvYWQ7XG4gICAgICB9KS50aGVuKGZ1bmN0aW9uKHBheWxvYWQpIHtcbiAgICAgICAgcmV0dXJuIGZvYW0uanNvbi5QYXJzZXIuY3JlYXRlKHsgY3JlYXRpb25Db250ZXh0OiBzZWxmIH0pLnBhcnNlU3RyaW5nKHBheWxvYWQpO1xuICAgICAgfSk7XG4gICAgfSxcblxuICAgIGZ1bmN0aW9uIHVybEZvcl8oeCwgYmxvYikge1xuICAgICAgaWYgKCAhIGZvYW0uYmxvYi5JZGVudGlmaWVkQmxvYi5pc0luc3RhbmNlKGJsb2IpICkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMuYWRkcmVzcyArICcvJyArIGJsb2IuaWQ7XG4gICAgfSxcblxuICAgIGZ1bmN0aW9uIGZpbmRfKHgsIGlkKSB7XG4gICAgICB2YXIgcmVxID0gdGhpcy5IVFRQUmVxdWVzdC5jcmVhdGUoKTtcbiAgICAgIHJlcS5mcm9tVXJsKHRoaXMuYWRkcmVzcyArICcvJyArIGlkKTtcbiAgICAgIHJlcS5tZXRob2QgPSAnR0VUJztcbiAgICAgIHJlcS5yZXNwb25zZVR5cGUgPSAnYmxvYic7XG5cbiAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgIHJldHVybiByZXEuc2VuZCgpLnRoZW4oZnVuY3Rpb24ocmVzcCkge1xuICAgICAgICByZXR1cm4gcmVzcC5wYXlsb2FkO1xuICAgICAgfSkudGhlbihmdW5jdGlvbihibG9iKSB7XG4gICAgICAgIHJldHVybiBzZWxmLkJsb2JCbG9iLmNyZWF0ZSh7XG4gICAgICAgICAgYmxvYjogYmxvYlxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH1cbiAgXVxufSk7XG5cblxuZm9hbS5DTEFTUyh7XG4gIHBhY2thZ2U6ICdmb2FtLmJsb2InLFxuICBuYW1lOiAnQmxvYlNlcnZpY2VEZWNvcmF0b3InLFxuICBleHRlbmRzOiAnZm9hbS5kYW8uQWJzdHJhY3REQU9EZWNvcmF0b3InLFxuXG4gIGltcG9ydHM6IFtcbiAgICAnYmxvYlNlcnZpY2UnXG4gIF0sXG5cbiAgcHJvcGVydGllczogW1xuICAgIHtcbiAgICAgIGNsYXNzOiAnQ2xhc3MnLFxuICAgICAgbmFtZTogJ29mJ1xuICAgIH1cbiAgXSxcblxuICBtZXRob2RzOiBbXG4gICAgZnVuY3Rpb24gd3JpdGUoWCwgZGFvLCBvYmosIGV4aXN0aW5nKSB7XG4gICAgICB2YXIgaSA9IDA7XG4gICAgICB2YXIgcHJvcHMgPSBvYmouY2xzXy5nZXRBeGlvbXNCeUNsYXNzKGZvYW0uY29yZS5CbG9iKTtcbiAgICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpLnRoZW4oZnVuY3Rpb24gYSgpIHtcbiAgICAgICAgdmFyIHByb3AgPSBwcm9wc1tpKytdO1xuXG4gICAgICAgIGlmICggISBwcm9wICkgcmV0dXJuIG9iajtcblxuICAgICAgICB2YXIgYmxvYiA9IHByb3AuZihvYmopO1xuXG4gICAgICAgIGlmICggISBibG9iICkgcmV0dXJuIG9iajtcblxuICAgICAgICByZXR1cm4gc2VsZi5ibG9iU2VydmljZS5wdXQoYmxvYikudGhlbihmdW5jdGlvbihiKSB7XG4gICAgICAgICAgcHJvcC5zZXQob2JqLCBiKTtcbiAgICAgICAgICByZXR1cm4gYSgpO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH1cbiAgXVxufSk7XG5cblxuZm9hbS5DTEFTUyh7XG4gIHBhY2thZ2U6ICdmb2FtLmJsb2InLFxuICBuYW1lOiAnVGVzdEJsb2JTZXJ2aWNlJyxcbiAgZXh0ZW5kczogJ2ZvYW0uYmxvYi5BYnN0cmFjdEJsb2JTZXJ2aWNlJyxcblxuICByZXF1aXJlczogW1xuICAgICdmb2FtLmJsb2IuSWRlbnRpZmllZEJsb2InLFxuICAgICdmb2FtLmJsb2IuQmxvYkJsb2InXG4gIF0sXG5cbiAgcHJvcGVydGllczogW1xuICAgIHtcbiAgICAgIGNsYXNzOiAnTWFwJyxcbiAgICAgIG5hbWU6ICdibG9icydcbiAgICB9LFxuICAgIHtcbiAgICAgIGNsYXNzOiAnSW50JyxcbiAgICAgIG5hbWU6ICduZXh0SWQnLFxuICAgICAgdmFsdWU6IDFcbiAgICB9XG4gIF0sXG5cbiAgbWV0aG9kczogW1xuICAgIGZ1bmN0aW9uIHB1dF8oeCwgZmlsZSkge1xuICAgICAgdmFyIGlkID0gdGhpcy5uZXh0SWQrKztcbiAgICAgIHRoaXMuYmxvYnNbaWRdID0gZmlsZTtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodGhpcy5JZGVudGlmaWVkQmxvYi5jcmVhdGUoeyBpZDogaWQgfSkpO1xuICAgIH0sXG5cbiAgICBmdW5jdGlvbiBmaW5kXyh4LCBpZCkge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh0aGlzLmJsb2JzW2lkXSA/XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuQmxvYkJsb2IuY3JlYXRlKHsgYmxvYjogdGhpcy5ibG9ic1tpZF0gfSkgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICBudWxsKTtcbiAgICB9LFxuXG4gICAgZnVuY3Rpb24gdXJsRm9yXyh4LCBibG9iKSB7XG4gICAgICBpZiAoIHRoaXMuSWRlbnRpZmllZEJsb2IuaXNJbnN0YW5jZShibG9iKSApIHtcbiAgICAgICAgcmV0dXJuIFVSTC5jcmVhdGVPYmplY3RVUkwodGhpcy5ibG9ic1tibG9iLmlkXSk7XG4gICAgICB9IGVsc2UgaWYgKCB0aGlzLkJsb2JCbG9iLmlzSW5zdGFuY2UoYmxvYikgKSB7XG4gICAgICAgIHJldHVybiBVUkwuY3JlYXRlT2JqZWN0VVJMKGJsb2IuYmxvYik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgXVxufSk7XG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5mb2FtLkNMQVNTKHtcbiAgcGFja2FnZTogJ2ZvYW0uZW5jb2RpbmdzJyxcbiAgbmFtZTogJ1VURjgnLFxuXG4gIHByb3BlcnRpZXM6IFtcbiAgICB7XG4gICAgICBuYW1lOiAnY2hhcmNvZGUnXG4gICAgfSxcbiAgICB7XG4gICAgICBjbGFzczogJ0ludCcsXG4gICAgICBuYW1lOiAncmVtYWluaW5nJyxcbiAgICAgIHZhbHVlOiAwXG4gICAgfSxcbiAgICB7XG4gICAgICBjbGFzczogJ1N0cmluZycsXG4gICAgICBuYW1lOiAnc3RyaW5nJ1xuICAgIH1cbiAgXSxcblxuICBtZXRob2RzOiBbXG4gICAgZnVuY3Rpb24gcmVzZXQoKSB7XG4gICAgICB0aGlzLnN0cmluZyA9ICcnO1xuICAgICAgdGhpcy5yZW1haW5pbmcgPSAwO1xuICAgICAgdGhpcy5jaGFyY29kZSA9IG51bGw7XG4gICAgfSxcblxuICAgIGZ1bmN0aW9uIHB1dChieXRlKSB7XG4gICAgICBpZiAoIGJ5dGUgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlciApIHtcbiAgICAgICAgdmFyIGRhdGEgPSBuZXcgVWludDhBcnJheShieXRlKTtcbiAgICAgICAgdGhpcy5wdXQoZGF0YSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKCBieXRlIGluc3RhbmNlb2YgVWludDhBcnJheSApIHtcbiAgICAgICAgZm9yICggdmFyIGkgPSAwIDsgaSA8IGJ5dGUubGVuZ3RoIDsgaSsrICkge1xuICAgICAgICAgIHRoaXMucHV0KGJ5dGVbaV0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuY2hhcmNvZGUgPT0gbnVsbCkge1xuICAgICAgICB0aGlzLmNoYXJjb2RlID0gYnl0ZTtcbiAgICAgICAgaWYgKCEodGhpcy5jaGFyY29kZSAmIDB4ODApKSB7XG4gICAgICAgICAgdGhpcy5yZW1haW5pbmcgPSAwO1xuICAgICAgICAgIHRoaXMuY2hhcmNvZGUgPSAoYnl0ZSAmIDB4N2YpIDw8ICg2ICogdGhpcy5yZW1haW5pbmcpO1xuICAgICAgICB9IGVsc2UgaWYgKCh0aGlzLmNoYXJjb2RlICYgMHhlMCkgPT0gMHhjMCkge1xuICAgICAgICAgIHRoaXMucmVtYWluaW5nID0gMTtcbiAgICAgICAgICB0aGlzLmNoYXJjb2RlID0gKGJ5dGUgJiAweDFmKSA8PCAoNiAqIHRoaXMucmVtYWluaW5nKTtcbiAgICAgICAgfSBlbHNlIGlmICgodGhpcy5jaGFyY29kZSAmIDB4ZjApID09IDB4ZTApIHtcbiAgICAgICAgICB0aGlzLnJlbWFpbmluZyA9IDI7XG4gICAgICAgICAgdGhpcy5jaGFyY29kZSA9IChieXRlICYgMHgwZikgPDwgKDYgKiB0aGlzLnJlbWFpbmluZyk7XG4gICAgICAgIH0gZWxzZSBpZiAoKHRoaXMuY2hhcmNvZGUgJiAweGY4KSA9PSAweGYwKSB7XG4gICAgICAgICAgdGhpcy5yZW1haW5pbmcgPSAzO1xuICAgICAgICAgIHRoaXMuY2hhcmNvZGUgPSAoYnl0ZSAmIDB4MDcpIDw8ICg2ICogdGhpcy5yZW1haW5pbmcpO1xuICAgICAgICB9IGVsc2UgaWYgKCh0aGlzLmNoYXJjb2RlICYgMHhmYykgPT0gMHhmOCkge1xuICAgICAgICAgIHRoaXMucmVtYWluaW5nID0gNDtcbiAgICAgICAgICB0aGlzLmNoYXJjb2RlID0gKGJ5dGUgJiAweDAzKSA8PCAoNiAqIHRoaXMucmVtYWluaW5nKTtcbiAgICAgICAgfSBlbHNlIGlmICgodGhpcy5jaGFyY29kZSAmIDB4ZmUpID09IDB4ZmMpIHtcbiAgICAgICAgICB0aGlzLnJlbWFpbmluZyA9IDU7XG4gICAgICAgICAgdGhpcy5jaGFyY29kZSA9IChieXRlICYgMHgwMSkgPDwgKDYgKiB0aGlzLnJlbWFpbmluZyk7XG4gICAgICAgIH0gZWxzZSB0aHJvdyAnQmFkIGNoYXJjb2RlIHZhbHVlJztcbiAgICAgIH0gZWxzZSBpZiAoIHRoaXMucmVtYWluaW5nID4gMCApIHtcbiAgICAgICAgdGhpcy5yZW1haW5pbmctLTtcbiAgICAgICAgdGhpcy5jaGFyY29kZSB8PSAoYnl0ZSAmIDB4M2YpIDw8ICg2ICogdGhpcy5yZW1haW5pbmcpO1xuICAgICAgfVxuXG4gICAgICBpZiAoIHRoaXMucmVtYWluaW5nID09IDAgKSB7XG4gICAgICAgIHRoaXMuc3RyaW5nICs9IFN0cmluZy5mcm9tQ29kZVBvaW50KHRoaXMuY2hhcmNvZGUpO1xuICAgICAgICB0aGlzLmNoYXJjb2RlID0gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgIH1cbiAgIF1cbn0pO1xuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTggVGhlIEZPQU0gQXV0aG9ycy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuZm9hbS5DTEFTUyh7XG4gIHBhY2thZ2UgOidmb2FtLm5ldCcsXG4gIG5hbWU6ICdOb3RDb25uZWN0ZWRFeGNlcHRpb24nLFxuICBpbXBsZW1lbnRzOiBbICdmb2FtLmNvcmUuRXhjZXB0aW9uJyBdXG59KTtcbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE4IFRoZSBGT0FNIEF1dGhvcnMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKi9cblxuZm9hbS5DTEFTUyh7XG4gIHBhY2thZ2UgOidmb2FtLm5ldCcsXG4gIG5hbWU6ICdDb25uZWN0aW9uRmFpbGVkRXhjZXB0aW9uJyxcbiAgaW1wbGVtZW50czogWyAnZm9hbS5jb3JlLkV4Y2VwdGlvbicgXVxufSk7XG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogQ29weXJpZ2h0IDIwMTcgVGhlIEZPQU0gQXV0aG9ycy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICovXG5cbmZvYW0uQ0xBU1Moe1xuICBwYWNrYWdlOiAnZm9hbS5uZXQud2ViJyxcbiAgbmFtZTogJ1dlYlNvY2tldCcsXG5cbiAgcmVxdWlyZXM6IFtcbiAgICAnZm9hbS5uZXQuTm90Q29ubmVjdGVkRXhjZXB0aW9uJyxcbiAgICAnZm9hbS5uZXQuQ29ubmVjdGlvbkZhaWxlZEV4Y2VwdGlvbidcbiAgXSxcblxuICB0b3BpY3M6IFtcbiAgICAnbWVzc2FnZScsXG4gICAgJ2Nvbm5lY3RlZCcsXG4gICAgJ2Rpc2Nvbm5lY3RlZCdcbiAgXSxcblxuICBwcm9wZXJ0aWVzOiBbXG4gICAge1xuICAgICAgbmFtZTogJ3VyaSdcbiAgICB9LFxuICAgIHtcbiAgICAgIG5hbWU6ICdzb2NrZXQnLFxuICAgICAgdHJhbnNpZW50OiB0cnVlXG4gICAgfVxuICBdLFxuXG4gIG1ldGhvZHM6IFtcbiAgICBmdW5jdGlvbiBzZW5kKG1zZykge1xuICAgICAgLy8gQXBwYXJlbnRseSB5b3UgY2FuJ3QgY2F0Y2ggZXhjZXB0aW9ucyBmcm9tIGNhbGxpbmcgLnNlbmQoKVxuICAgICAgLy8gd2hlbiB0aGUgc29ja2V0IGlzbid0IG9wZW4uICBTbyB3ZSdsbCB0cnkgdG8gcHJlZGljdCBhbiBleGNlcHRpb25cbiAgICAgIC8vIGhhcHBlbmluZyBhbmQgdGhyb3cgZWFybHkuXG4gICAgICAvL1xuICAgICAgLy8gVGhlcmUgY291bGQgYmUgYSByYWNlIGNvbmRpdGlvbiBoZXJlIGlmIHRoZSBzb2NrZXRcbiAgICAgIC8vIGNsb3NlcyBiZXR3ZWVuIG91ciBjaGVjayBhbmQgLnNlbmQoKS5cbiAgICAgIGlmICggdGhpcy5zb2NrZXQucmVhZHlTdGF0ZSAhPT0gdGhpcy5zb2NrZXQuT1BFTiApIHtcbiAgICAgICAgdGhyb3cgdGhpcy5Ob3RDb25uZWN0ZWRFeGNlcHRpb24uY3JlYXRlKCk7XG4gICAgICB9XG4gICAgICB0aGlzLnNvY2tldC5zZW5kKG1zZyk7XG4gICAgfSxcblxuICAgIGZ1bmN0aW9uIGNvbm5lY3QoKSB7XG4gICAgICB2YXIgc29ja2V0ID0gdGhpcy5zb2NrZXQgPSBuZXcgV2ViU29ja2V0KHRoaXMudXJpKTtcbiAgICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBmdW5jdGlvbiBvbkNvbm5lY3QoKSB7XG4gICAgICAgICAgc29ja2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ29wZW4nLCBvbkNvbm5lY3QpO1xuICAgICAgICAgIHJlc29sdmUoc2VsZik7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gb25Db25uZWN0RXJyb3IoZSkge1xuICAgICAgICAgIHNvY2tldC5yZW1vdmVFdmVudExpc3RlbmVyKCdlcnJvcicsIG9uQ29ubmVjdEVycm9yKTtcbiAgICAgICAgICByZWplY3Qoc2VsZi5Db25uZWN0aW9uRmFpbGVkRXhjZXB0aW9uLmNyZWF0ZSgpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHNvY2tldC5hZGRFdmVudExpc3RlbmVyKCdvcGVuJywgb25Db25uZWN0KTtcbiAgICAgICAgc29ja2V0LmFkZEV2ZW50TGlzdGVuZXIoJ2Vycm9yJywgb25Db25uZWN0RXJyb3IpO1xuXG4gICAgICAgIHNvY2tldC5hZGRFdmVudExpc3RlbmVyKCdvcGVuJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgc2VsZi5jb25uZWN0ZWQucHViKCk7XG4gICAgICAgIH0pO1xuICAgICAgICBzb2NrZXQuYWRkRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIHNlbGYub25NZXNzYWdlKTtcbiAgICAgICAgc29ja2V0LmFkZEV2ZW50TGlzdGVuZXIoJ2Nsb3NlJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgc2VsZi5kaXNjb25uZWN0ZWQucHViKCk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfSxcblxuICAgIGZ1bmN0aW9uIGRpc2Nvbm5lY3QoKSB7XG4gICAgICB0aGlzLnNvY2tldCAmJiB0aGlzLnNvY2tldC5jbG9zZSgpO1xuICAgIH1cbiAgXSxcblxuICBsaXN0ZW5lcnM6IFtcbiAgICB7XG4gICAgICBuYW1lOiAnb25NZXNzYWdlJyxcbiAgICAgIGNvZGU6IGZ1bmN0aW9uKG1zZykge1xuICAgICAgICB0aGlzLm1lc3NhZ2UucHViKG1zZy5kYXRhKTtcbiAgICAgIH1cbiAgICB9XG4gIF1cbn0pO1xuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTYgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIENvcHlyaWdodCAyMDE3IFRoZSBGT0FNIEF1dGhvcnMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqL1xuXG5mb2FtLkNMQVNTKHtcbiAgcGFja2FnZTogJ2ZvYW0ubmV0LndlYicsXG4gIG5hbWU6ICdXZWJTb2NrZXRTZXJ2aWNlJyxcblxuICByZXF1aXJlczogW1xuICAgICdmb2FtLmJveC5NZXNzYWdlJyxcbiAgICAnZm9hbS5qc29uLlBhcnNlcicsXG4gICAgJ2ZvYW0ubmV0LndlYi5XZWJTb2NrZXQnLFxuICAgICdmb2FtLmJveC5SYXdXZWJTb2NrZXRCb3gnXG4gIF0sXG5cbiAgaW1wb3J0czogWyAnY3JlYXRpb25Db250ZXh0JyBdLFxuXG4gIHByb3BlcnRpZXM6IFtcbiAgICB7XG4gICAgICBuYW1lOiAnZGVsZWdhdGUnXG4gICAgfSxcbiAgICB7XG4gICAgICBjbGFzczogJ0ZPYmplY3RQcm9wZXJ0eScsXG4gICAgICBvZjogJ2ZvYW0uanNvbi5QYXJzZXInLFxuICAgICAgbmFtZTogJ3BhcnNlcicsXG4gICAgICBmYWN0b3J5OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuUGFyc2VyLmNyZWF0ZSh7XG4gICAgICAgICAgc3RyaWN0OiB0cnVlLFxuICAgICAgICAgIGNyZWF0aW9uQ29udGV4dDogdGhpcy5jcmVhdGlvbkNvbnRleHRcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICBdLFxuXG4gIG1ldGhvZHM6IFtcbiAgICBmdW5jdGlvbiBhZGRTb2NrZXQoc29ja2V0KSB7XG4gICAgICB2YXIgWCA9IHRoaXMuY3JlYXRpb25Db250ZXh0LmNyZWF0ZVN1YkNvbnRleHQoe1xuICAgICAgICByZXR1cm5Cb3g6IHRoaXMuUmF3V2ViU29ja2V0Qm94LmNyZWF0ZSh7IHNvY2tldDogc29ja2V0IH0pXG4gICAgICB9KTtcblxuICAgICAgdmFyIHN1YjEgPSBzb2NrZXQubWVzc2FnZS5zdWIoZnVuY3Rpb24gb25NZXNzYWdlKHMsIF8sIG1zZ1N0cikge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHZhciBtc2cgPSB0aGlzLnBhcnNlci5wYXJzZVN0cmluZyhtc2dTdHIsIFgpO1xuXG4gICAgICAgICAgaWYgKCAhIHRoaXMuTWVzc2FnZS5pc0luc3RhbmNlKG1zZykgKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ0dvdCBub24tbWVzc2FnZScsIG1zZy5jbHNfLmlkKTtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybignICBwYXlsb2FkIHdhczogJywgbXNnU3RyKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aGlzLmRlbGVnYXRlLnNlbmQobXNnKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJXU1MgRXJyb3I6XCIsIGUpO1xuICAgICAgICB9XG4gICAgICB9LmJpbmQodGhpcykpO1xuXG4gICAgICBzb2NrZXQuZGlzY29ubmVjdGVkLnN1YihmdW5jdGlvbihzKSB7XG4gICAgICAgIHMuZGV0YWNoKCk7XG4gICAgICAgIHN1YjEuZGV0YWNoKCk7XG4gICAgICB9KTtcbiAgICB9XG4gIF1cbn0pO1xuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgVGhlIEZPQU0gQXV0aG9ycy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuZm9hbS5DTEFTUyh7XG4gIHBhY2thZ2U6ICdmb2FtLm5ldC53ZWInLFxuICBuYW1lOiAnSFRUUFJlc3BvbnNlJyxcblxuICB0b3BpY3M6IFtcbiAgICAnZGF0YScsXG4gICAgJ2VycicsXG4gICAgJ2VuZCdcbiAgXSxcblxuICBwcm9wZXJ0aWVzOiBbXG4gICAge1xuICAgICAgY2xhc3M6ICdJbnQnLFxuICAgICAgbmFtZTogJ3N0YXR1cydcbiAgICB9LFxuICAgIHtcbiAgICAgIGNsYXNzOiAnU3RyaW5nJyxcbiAgICAgIG5hbWU6ICdyZXNwb25zZVR5cGUnXG4gICAgfSxcbiAgICB7XG4gICAgICBjbGFzczogJ01hcCcsXG4gICAgICBuYW1lOiAnaGVhZGVycydcbiAgICB9LFxuICAgIHtcbiAgICAgIG5hbWU6ICdwYXlsb2FkJyxcbiAgICAgIGZhY3Rvcnk6IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoIHRoaXMuc3RyZWFtaW5nICkge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgc3dpdGNoICggdGhpcy5yZXNwb25zZVR5cGUgKSB7XG4gICAgICAgICAgY2FzZSAndGV4dCc6ICAgICAgICByZXR1cm4gdGhpcy5yZXNwLnRleHQoKTtcbiAgICAgICAgICBjYXNlICdibG9iJzogICAgICAgIHJldHVybiB0aGlzLnJlc3AuYmxvYigpO1xuICAgICAgICAgIGNhc2UgJ2FycmF5YnVmZmVyJzogcmV0dXJuIHRoaXMucmVzcC5hcnJheWJ1ZmZlcigpO1xuICAgICAgICAgIGNhc2UgJ2pzb24nOiAgICAgICAgcmV0dXJuIHRoaXMucmVzcC5qc29uKCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBUT0RPOiByZXNwb25zZVR5cGUgc2hvdWxkIGJlIGFuIGVudW0gYW5kL29yIGhhdmUgdmFsaWRhdGlvblxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vuc3VwcG9ydGVkIHJlc3BvbnNlIHR5cGU6ICcgKyB0aGlzLnJlc3BvbnNlVHlwZSk7XG4gICAgICB9XG4gICAgfSxcbiAgICB7XG4gICAgICBjbGFzczogJ0Jvb2xlYW4nLFxuICAgICAgbmFtZTogJ3N0cmVhbWluZycsXG4gICAgICB2YWx1ZTogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgIGNsYXNzOiAnQm9vbGVhbicsXG4gICAgICBuYW1lOiAnc3VjY2VzcycsXG4gICAgICBleHByZXNzaW9uOiBmdW5jdGlvbihzdGF0dXMpIHtcbiAgICAgICAgcmV0dXJuIHN0YXR1cyA+PSAyMDAgJiYgc3RhdHVzIDw9IDI5OTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHtcbiAgICAgIG5hbWU6ICdyZXNwJyxcbiAgICAgIHBvc3RTZXQ6IGZ1bmN0aW9uKF8sIHIpIHtcbiAgICAgICAgaWYgKCByLmhlYWRlcnMuZW50cmllcyApIHRoaXMuY29weUhlYWRlcnNfKHIpO1xuICAgICAgICBlbHNlICAgICAgICAgICAgICAgICAgICAgdGhpcy5jb3B5SGVhZGVyc0VkZ2VfKHIpO1xuICAgICAgICB0aGlzLnN0YXR1cyA9IHIuc3RhdHVzO1xuICAgICAgfVxuICAgIH1cbiAgXSxcblxuICBtZXRob2RzOiBbXG4gICAgZnVuY3Rpb24gc3RhcnQoKSB7XG4gICAgICB2YXIgcmVhZGVyID0gdGhpcy5yZXNwLmJvZHkuZ2V0UmVhZGVyKCk7XG4gICAgICB0aGlzLnN0cmVhbWluZyA9IHRydWU7XG5cbiAgICAgIHZhciBvbkVycm9yID0gZm9hbS5GdW5jdGlvbi5iaW5kKGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgdGhpcy5lcnIucHViKCk7XG4gICAgICAgIHRoaXMuZW5kLnB1YigpO1xuICAgICAgfSwgdGhpcyk7XG5cbiAgICAgIHZhciBvbkRhdGEgPSBmb2FtLkZ1bmN0aW9uLmJpbmQoZnVuY3Rpb24oZSkge1xuICAgICAgICBpZiAoIGUudmFsdWUgKSB7XG4gICAgICAgICAgdGhpcy5kYXRhLnB1YihlLnZhbHVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICggZS5kb25lIHx8ICEgdGhpcy5zdHJlYW1pbmcpIHtcbiAgICAgICAgICB0aGlzLmVuZC5wdWIoKTtcbiAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVhZGVyLnJlYWQoKS50aGVuKG9uRGF0YSwgb25FcnJvcik7XG4gICAgICB9LCB0aGlzKTtcblxuICAgICAgcmV0dXJuIHJlYWRlci5yZWFkKCkudGhlbihvbkRhdGEsIG9uRXJyb3IpO1xuICAgIH0sXG5cbiAgICBmdW5jdGlvbiBzdG9wKCkge1xuICAgICAgdGhpcy5zdHJlYW1pbmcgPSBmYWxzZTtcbiAgICB9LFxuICAgIGZ1bmN0aW9uIGNvcHlIZWFkZXJzXyhyKSB7XG4gICAgICB2YXIgaXRlcmF0b3IgPSByLmhlYWRlcnMuZW50cmllcygpO1xuICAgICAgdmFyIG5leHQgPSBpdGVyYXRvci5uZXh0KCk7XG4gICAgICB3aGlsZSAoICEgbmV4dC5kb25lICkge1xuICAgICAgICB0aGlzLmhlYWRlcnNbbmV4dC52YWx1ZVswXV0gPSBuZXh0LnZhbHVlWzFdO1xuICAgICAgICBuZXh0ID0gaXRlcmF0b3IubmV4dCgpO1xuICAgICAgfVxuICAgIH0sXG4gICAgZnVuY3Rpb24gY29weUhlYWRlcnNFZGdlXyhyKSB7XG4gICAgICAvLyBEZWFsIHdpdGggaHR0cHM6Ly9kZXZlbG9wZXIubWljcm9zb2Z0LmNvbS9lbi11cy9taWNyb3NvZnQtZWRnZS9wbGF0Zm9ybS9pc3N1ZXMvMTM5Mjg5MDcvXG4gICAgICB2YXIgaGVhZGVycyA9IHRoaXMuaGVhZGVycztcbiAgICAgIHIuaGVhZGVycy5mb3JFYWNoKGZ1bmN0aW9uKHZhbHVlLCBrZXkpIHtcbiAgICAgICAgaGVhZGVyc1trZXldID0gdmFsdWU7XG4gICAgICB9KTtcbiAgICB9XG4gIF1cbn0pO1xuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgVGhlIEZPQU0gQXV0aG9ycy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuZm9hbS5DTEFTUyh7XG4gIHBhY2thZ2U6ICdmb2FtLm5ldC53ZWInLFxuICBuYW1lOiAnSFRUUFJlcXVlc3QnLFxuXG4gIHJlcXVpcmVzOiBbXG4gICAgJ2ZvYW0ubmV0LndlYi5IVFRQUmVzcG9uc2UnLFxuICAgICdmb2FtLmJsb2IuQmxvYicsXG4gICAgJ2ZvYW0uYmxvYi5CbG9iQmxvYidcbiAgXSxcblxuICB0b3BpY3M6IFtcbiAgICAnZGF0YSdcbiAgXSxcblxuICBwcm9wZXJ0aWVzOiBbXG4gICAge1xuICAgICAgY2xhc3M6ICdTdHJpbmcnLFxuICAgICAgbmFtZTogJ2hvc3RuYW1lJ1xuICAgIH0sXG4gICAge1xuICAgICAgY2xhc3M6ICdJbnQnLFxuICAgICAgbmFtZTogJ3BvcnQnXG4gICAgfSxcbiAgICB7XG4gICAgICBjbGFzczogJ1N0cmluZycsXG4gICAgICBuYW1lOiAncHJvdG9jb2wnLFxuICAgICAgcHJlU2V0OiBmdW5jdGlvbihvbGQsIG51KSB7XG4gICAgICAgIHJldHVybiBudS5yZXBsYWNlKCc6JywgJycpO1xuICAgICAgfVxuICAgIH0sXG4gICAge1xuICAgICAgY2xhc3M6ICdTdHJpbmcnLFxuICAgICAgbmFtZTogJ3BhdGgnLFxuICAgICAgcHJlU2V0OiBmdW5jdGlvbihvbGQsIG51KSB7XG4gICAgICAgIGlmICggISBudS5zdGFydHNXaXRoKCcvJykgKSByZXR1cm4gJy8nICsgbnU7XG4gICAgICAgIHJldHVybiBudTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHtcbiAgICAgIGNsYXNzOiAnU3RyaW5nJyxcbiAgICAgIG5hbWU6ICd1cmwnXG4gICAgfSxcbiAgICB7XG4gICAgICBjbGFzczogJ1N0cmluZycsXG4gICAgICBuYW1lOiAnbWV0aG9kJyxcbiAgICAgIHZhbHVlOiAnR0VUJ1xuICAgIH0sXG4gICAge1xuICAgICAgY2xhc3M6ICdNYXAnLFxuICAgICAgbmFtZTogJ2hlYWRlcnMnXG4gICAgfSxcbiAgICB7XG4gICAgICBuYW1lOiAncGF5bG9hZCdcbiAgICB9LFxuICAgIHtcbiAgICAgIC8vIFRPRE86IHZhbGlkYXRlIGFjY2VwdGFibGUgdHlwZXNcbiAgICAgIGNsYXNzOiAnU3RyaW5nJyxcbiAgICAgIG5hbWU6ICdyZXNwb25zZVR5cGUnLFxuICAgICAgdmFsdWU6ICd0ZXh0J1xuICAgIH0sXG4gICAge1xuICAgICAgY2xhc3M6ICdTdHJpbmcnLFxuICAgICAgbmFtZTogJ2NvbnRlbnRUeXBlJyxcbiAgICAgIGZhY3Rvcnk6IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcy5yZXNwb25zZVR5cGU7IH1cbiAgICB9LFxuICAgIHtcbiAgICAgIGNsYXNzOiAnU3RyaW5nJyxcbiAgICAgIG5hbWU6ICdtb2RlJyxcbiAgICAgIHZhbHVlOiAnY29ycydcbiAgICB9XG4gIF0sXG5cbiAgbWV0aG9kczogW1xuICAgIGZ1bmN0aW9uIGZyb21VcmwodXJsKSB7XG4gICAgICB2YXIgdSA9IG5ldyBVUkwodXJsKTtcbiAgICAgIHRoaXMucHJvdG9jb2wgPSB1LnByb3RvY29sLnN1YnN0cmluZygwLCB1LnByb3RvY29sLmxlbmd0aC0xKTtcbiAgICAgIHRoaXMuaG9zdG5hbWUgPSB1Lmhvc3RuYW1lO1xuICAgICAgaWYgKCB1LnBvcnQgKSB0aGlzLnBvcnQgPSB1LnBvcnQ7XG4gICAgICB0aGlzLnBhdGggPSB1LnBhdGhuYW1lICsgdS5zZWFyY2g7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgZnVuY3Rpb24gc2VuZCgpIHtcbiAgICAgIGlmICggdGhpcy51cmwgKSB7XG4gICAgICAgIHRoaXMuZnJvbVVybCh0aGlzLnVybCk7XG4gICAgICB9XG4gICAgICB0aGlzLmFkZENvbnRlbnRIZWFkZXJzKCk7XG5cbiAgICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgICAgdmFyIGhlYWRlcnMgPSBuZXcgSGVhZGVycygpO1xuICAgICAgZm9yICggdmFyIGtleSBpbiB0aGlzLmhlYWRlcnMgKSB7XG4gICAgICAgIGhlYWRlcnMuc2V0KGtleSwgdGhpcy5oZWFkZXJzW2tleV0pO1xuICAgICAgfVxuXG4gICAgICB2YXIgb3B0aW9ucyA9IHtcbiAgICAgICAgbWV0aG9kOiB0aGlzLm1ldGhvZCxcbiAgICAgICAgaGVhZGVyczogaGVhZGVycyxcbiAgICAgICAgbW9kZTogdGhpcy5tb2RlLFxuICAgICAgICByZWRpcmVjdDogXCJmb2xsb3dcIixcbiAgICAgICAgY3JlZGVudGlhbHM6IFwic2FtZS1vcmlnaW5cIlxuICAgICAgfTtcblxuICAgICAgaWYgKCB0aGlzLnBheWxvYWQgKSB7XG4gICAgICAgIGlmICggdGhpcy5CbG9iQmxvYi5pc0luc3RhbmNlKHRoaXMucGF5bG9hZCkgKSB7XG4gICAgICAgICAgb3B0aW9ucy5ib2R5ID0gdGhpcy5wYXlsb2FkLmJsb2I7XG4gICAgICAgIH0gZWxzZSBpZiAoIHRoaXMuQmxvYi5pc0luc3RhbmNlKHRoaXMucGF5bG9hZCkgKSB7XG4gICAgICAgICAgZm9hbS5hc3NlcnQoZmFsc2UsICdUT0RPOiBJbXBsZW1lbnRlZCBzZW5kaW5nIG9mIGZvYW0uYmxvYi5CbG9iIG92ZXIgSFRUUFJlcXVlc3QuJyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb3B0aW9ucy5ib2R5ID0gdGhpcy5wYXlsb2FkO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciByZXF1ZXN0ID0gbmV3IFJlcXVlc3QoXG4gICAgICAgICAgdGhpcy5wcm90b2NvbCArIFwiOi8vXCIgK1xuICAgICAgICAgIHRoaXMuaG9zdG5hbWUgK1xuICAgICAgICAgICggdGhpcy5wb3J0ID8gKCAnOicgKyB0aGlzLnBvcnQgKSA6ICcnICkgK1xuICAgICAgICAgIHRoaXMucGF0aCxcbiAgICAgICAgICBvcHRpb25zKTtcblxuICAgICAgcmV0dXJuIGZldGNoKHJlcXVlc3QpLnRoZW4oZnVuY3Rpb24ocmVzcCkge1xuICAgICAgICB2YXIgcmVzcCA9IHRoaXMuSFRUUFJlc3BvbnNlLmNyZWF0ZSh7XG4gICAgICAgICAgcmVzcDogcmVzcCxcbiAgICAgICAgICByZXNwb25zZVR5cGU6IHRoaXMucmVzcG9uc2VUeXBlXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmICggcmVzcC5zdWNjZXNzICkgcmV0dXJuIHJlc3A7XG5cbiAgICAgICAgLy8gVXNlIFByb21pc2UucmVqZWN0IHNvIGNyYXBweSBkZWJ1Z2dlcnMgZG9uJ3QgcGF1c2UgaGVyZVxuICAgICAgICAvLyB0aHJvdyByZXNwO1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QocmVzcCk7XG4gICAgICB9LmJpbmQodGhpcykpO1xuICAgIH0sXG4gICAgZnVuY3Rpb24gYWRkQ29udGVudEhlYWRlcnMoKSB7XG4gICAgICAvLyBTcGVjaWZ5IENvbnRlbnQtVHlwZSBoZWFkZXIgd2hlbiBpdCBjYW4gYmUgZGVkdWNlZC5cbiAgICAgIGlmICggISB0aGlzLmhlYWRlcnNbJ0NvbnRlbnQtVHlwZSddICkge1xuICAgICAgICBzd2l0Y2ggKCB0aGlzLmNvbnRlbnRUeXBlICkge1xuICAgICAgICAgIGNhc2UgJ3RleHQnOlxuICAgICAgICAgIHRoaXMuaGVhZGVyc1snQ29udGVudC1UeXBlJ10gPSAndGV4dC9wbGFpbic7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnanNvbic6XG4gICAgICAgICAgdGhpcy5oZWFkZXJzWydDb250ZW50LVR5cGUnXSA9ICdhcHBsaWNhdGlvbi9qc29uJztcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gU3BlY2lmeSB0aGlzLmNvbnRlbnRUeXBlIHdoZW4gaXQgY2FuIGJlIGRlZHVjZWQuXG4gICAgICBpZiAoICEgdGhpcy5oZWFkZXJzWydBY2NlcHQnXSApIHtcbiAgICAgICAgc3dpdGNoICggdGhpcy5jb250ZW50VHlwZSApIHtcbiAgICAgICAgICBjYXNlICdqc29uJzpcbiAgICAgICAgICB0aGlzLmhlYWRlcnNbJ0FjY2VwdCddID0gJ2FwcGxpY2F0aW9uL2pzb24nO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICBdXG59KTtcbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IFRoZSBGT0FNIEF1dGhvcnMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cblxuLy8gUmVnaXN0ZXJpbmcgQmFzZUhUVFBSZXF1ZXN0IGZhY2lsaXRhdGVzIGRlY29yYXRpb24gd2hlbiBIVFRQUmVxdWVzdCBoYXMgYmVlblxuLy8gcmUtb3ZlcnJpZGRlbi5cbmZvYW0ucmVnaXN0ZXIoZm9hbS5sb29rdXAoJ2ZvYW0ubmV0LndlYi5IVFRQUmVxdWVzdCcpLFxuICAgICAgICAgICAgICAnZm9hbS5uZXQud2ViLkJhc2VIVFRQUmVxdWVzdCcpO1xuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgVGhlIEZPQU0gQXV0aG9ycy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuZm9hbS5DTEFTUyh7XG4gIHBhY2thZ2U6ICdmb2FtLm5ldC53ZWInLFxuICBuYW1lOiAnRXZlbnRTb3VyY2UnLFxuXG4gIHJlcXVpcmVzOiBbXG4gICAgJ2ZvYW0ucGFyc2UuR3JhbW1hcicsXG4gICAgJ2ZvYW0ubmV0LndlYi5IVFRQUmVxdWVzdCcsXG4gICAgJ2ZvYW0uZW5jb2RpbmdzLlVURjgnXG4gIF0sXG5cbiAgaW1wb3J0czogW1xuICAgICdzZXRUaW1lb3V0JyxcbiAgICAnY2xlYXJUaW1lb3V0J1xuICBdLFxuXG4gIHRvcGljczogW1xuICAgIHtcbiAgICAgIG5hbWU6ICdtZXNzYWdlJ1xuICAgIH1cbiAgXSxcblxuICBwcm9wZXJ0aWVzOiBbXG4gICAge1xuICAgICAgbmFtZTogJ2dyYW1tYXInLFxuICAgICAgZmFjdG9yeTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgcmV0dXJuIHRoaXMuR3JhbW1hci5jcmVhdGUoe1xuICAgICAgICAgIHN5bWJvbHM6IGZ1bmN0aW9uKHJlcGVhdCwgYWx0LCBzeW0sIG5vdENoYXJzLCBzZXEpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIFNUQVJUOiBzeW0oJ2xpbmUnKSxcblxuICAgICAgICAgICAgICBsaW5lOiBhbHQoXG4gICAgICAgICAgICAgICAgc3ltKCdldmVudCcpLFxuICAgICAgICAgICAgICAgIHN5bSgnZGF0YScpKSxcblxuICAgICAgICAgICAgICBldmVudDogc2VxKCdldmVudDogJywgc3ltKCdldmVudCBuYW1lJykpLFxuICAgICAgICAgICAgICAnZXZlbnQgbmFtZSc6IHJlcGVhdChub3RDaGFycygnXFxyXFxuJykpLFxuXG4gICAgICAgICAgICAgIGRhdGE6IHNlcSgnZGF0YTogJywgc3ltKCdkYXRhIHBheWxvYWQnKSksXG4gICAgICAgICAgICAgICdkYXRhIHBheWxvYWQnOiByZXBlYXQobm90Q2hhcnMoJ1xcclxcbicpKVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSkuYWRkQWN0aW9ucyh7XG4gICAgICAgICAgJ2V2ZW50IG5hbWUnOiBmdW5jdGlvbih2KSB7XG4gICAgICAgICAgICBzZWxmLmV2ZW50TmFtZSA9IHYuam9pbignJyk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICAnZGF0YSBwYXlsb2FkJzogZnVuY3Rpb24ocCkge1xuICAgICAgICAgICAgc2VsZi5ldmVudERhdGEgPSBwLmpvaW4oJycpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSxcbiAgICB7XG4gICAgICBjbGFzczogJ1N0cmluZycsXG4gICAgICBuYW1lOiAndXJpJ1xuICAgIH0sXG4gICAge1xuICAgICAgY2xhc3M6ICdCb29sZWFuJyxcbiAgICAgIG5hbWU6ICdydW5uaW5nJyxcbiAgICAgIHZhbHVlOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgbmFtZTogJ3Jlc3AnXG4gICAgfSxcbiAgICB7XG4gICAgICBuYW1lOiAnZGVjb2RlcicsXG4gICAgICBmYWN0b3J5OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuVVRGOC5jcmVhdGUoKVxuICAgICAgfVxuICAgIH0sXG4gICAge1xuICAgICAgbmFtZTogJ3JldHJ5VGltZXInXG4gICAgfSxcbiAgICB7XG4gICAgICBjbGFzczogJ0ludCcsXG4gICAgICBuYW1lOiAnZGVsYXknLFxuICAgICAgcHJlU2V0OiBmdW5jdGlvbihfLCBhKSB7XG4gICAgICAgIGlmICggYSA+IDMwMDAwICkgcmV0dXJuIDMwMDAwO1xuICAgICAgICByZXR1cm4gYTtcbiAgICAgIH0sXG4gICAgICB2YWx1ZTogMVxuICAgIH0sXG4gICAgJ2V2ZW50RGF0YScsXG4gICAgJ2V2ZW50TmFtZSdcbiAgXSxcblxuICBtZXRob2RzOiBbXG4gICAgZnVuY3Rpb24gc3RhcnQoKSB7XG4gICAgICB2YXIgcmVxID0gdGhpcy5IVFRQUmVxdWVzdC5jcmVhdGUoe1xuICAgICAgICBtZXRob2Q6IFwiR0VUXCIsXG4gICAgICAgIHVybDogdGhpcy51cmksXG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAnYWNjZXB0JzogJ3RleHQvZXZlbnQtc3RyZWFtJ1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgdGhpcy5ydW5uaW5nID0gdHJ1ZTtcbiAgICAgIHRoaXMua2VlcEFsaXZlKCk7XG4gICAgICByZXEuc2VuZCgpLnRoZW4oZnVuY3Rpb24ocmVzcCkge1xuICAgICAgICBpZiAoICEgcmVzcC5zdWNjZXNzICkge1xuICAgICAgICAgIHRoaXMub25FcnJvcigpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuY2xlYXJQcm9wZXJ0eSgnZGVjb2RlcicpO1xuICAgICAgICByZXNwLmRhdGEuc3ViKHRoaXMub25EYXRhKTtcbiAgICAgICAgcmVzcC5lbmQuc3ViKHRoaXMub25FcnJvcik7XG4gICAgICAgIHRoaXMucmVzcCA9IHJlc3A7XG4gICAgICAgIHJlc3Auc3RhcnQoKTtcbiAgICAgIH0uYmluZCh0aGlzKSwgdGhpcy5vbkVycm9yKTtcbiAgICB9LFxuXG4gICAgZnVuY3Rpb24ga2VlcEFsaXZlKCkge1xuICAgICAgaWYgKCB0aGlzLnJldHJ5VGltZXIgKSB7XG4gICAgICAgIHRoaXMuY2xlYXJUaW1lb3V0KHRoaXMucmV0cnlUaW1lcik7XG4gICAgICB9XG5cbiAgICAgIHRoaXMucmV0cnlUaW1lciA9IHRoaXMuc2V0VGltZW91dChmb2FtLkZ1bmN0aW9uLmJpbmQoZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMucmV0cnlUaW1lciA9IDA7XG4gICAgICAgIHRoaXMub25FcnJvcigpO1xuICAgICAgfSwgdGhpcyksIDMwMDAwKTtcbiAgICB9LFxuXG4gICAgZnVuY3Rpb24gY2xvc2UoKSB7XG4gICAgICB0aGlzLnJ1bm5pbmcgPSBmYWxzZTtcbiAgICAgIHRoaXMucmVzcC5zdG9wKCk7XG4gICAgfSxcblxuICAgIGZ1bmN0aW9uIGRpc3BhdGNoRXZlbnQoKSB7XG4gICAgICAvLyBLbm93biBwb3NzaWJsZSBldmVudHMgbmFtZXNcbiAgICAgIC8vIHB1dFxuICAgICAgLy8gcGF0Y2hcbiAgICAgIC8vIGtlZXAtYWxpdmVcbiAgICAgIC8vIGNhbmNlbFxuICAgICAgLy8gYXV0aCByZXZva2VkXG5cbiAgICAgIHRoaXMubWVzc2FnZS5wdWIodGhpcy5ldmVudE5hbWUsIHRoaXMuZXZlbnREYXRhKTtcbiAgICAgIHRoaXMuZXZlbnROYW1lID0gbnVsbDtcbiAgICAgIHRoaXMuZXZlbnREYXRhID0gbnVsbDtcbiAgICB9LFxuXG4gICAgZnVuY3Rpb24gcHJvY2Vzc0xpbmUobGluZSkge1xuICAgICAgLy8gVE9ETzogVGhpcyBjYW4gcHJvYmFibHkgYmUgc2ltcGxpZmllZCBieSB1c2luZyBzdGF0ZSBtYWNoaW5lIGJhc2VkXG4gICAgICAvLyBwYXJzZXJzLCBidXQgaW4gdGhlIGludGVyZXN0IG9mIHNhdmluZyB0aW1lIHdlJ3JlIGdvaW5nIHRvIGRvIGl0IGxpbmVcbiAgICAgIC8vIGJ5IGxpbmUgZm9yIG5vdy4gIFNvbWV0aGluZyB3ZSBrbm93IHdvcmtzIGZyb20gcHJldmlvdXMgaW50ZXJhdGlvbnMuXG5cbiAgICAgIGlmICggbGluZS5sZW5ndGggPT0gMCApIHtcbiAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdGhpcy5ncmFtbWFyLnBhcnNlU3RyaW5nKGxpbmUpO1xuICAgIH1cbiAgXSxcblxuICBsaXN0ZW5lcnM6IFtcbiAgICBmdW5jdGlvbiBvbkRhdGEocywgXywgZGF0YSkge1xuICAgICAgdGhpcy5kZWxheSA9IDE7XG4gICAgICB0aGlzLmtlZXBBbGl2ZSgpO1xuXG4gICAgICB0aGlzLmRlY29kZXIucHV0KGRhdGEpO1xuICAgICAgdmFyIHN0cmluZyA9IHRoaXMuZGVjb2Rlci5zdHJpbmc7XG4gICAgICB3aGlsZSAoIHN0cmluZy5pbmRleE9mKCdcXG4nKSAhPSAtMSApIHtcbiAgICAgICAgdmFyIGxpbmUgPSBzdHJpbmcuc3Vic3RyaW5nKDAsIHN0cmluZy5pbmRleE9mKCdcXG4nKSk7XG4gICAgICAgIHRoaXMucHJvY2Vzc0xpbmUobGluZSk7XG4gICAgICAgIHN0cmluZyA9IHN0cmluZy5zdWJzdHJpbmcoc3RyaW5nLmluZGV4T2YoJ1xcbicpICsgMSk7XG4gICAgICB9XG4gICAgICB0aGlzLmRlY29kZXIuc3RyaW5nID0gc3RyaW5nO1xuICAgIH0sXG5cbiAgICBmdW5jdGlvbiBvbkVycm9yKCkge1xuICAgICAgdGhpcy5kZWxheSAqPSAyO1xuICAgICAgdGhpcy5zZXRUaW1lb3V0KHRoaXMub25FbmQsIHRoaXMuZGVsYXkpO1xuICAgIH0sXG5cbiAgICBmdW5jdGlvbiBvbkVuZCgpIHtcbiAgICAgIGlmICggdGhpcy5ydW5uaW5nICkge1xuICAgICAgICB0aGlzLnN0YXJ0KCk7XG4gICAgICB9XG4gICAgfVxuICBdXG59KTtcbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IFRoZSBGT0FNIEF1dGhvcnMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmZvYW0uQ0xBU1Moe1xuICBwYWNrYWdlOiAnZm9hbS5uZXQud2ViJyxcbiAgbmFtZTogJ1hNTEhUVFBSZXF1ZXN0JyxcbiAgZXh0ZW5kczogJ2ZvYW0ubmV0LndlYi5IVFRQUmVxdWVzdCcsXG5cbiAgcmVxdWlyZXM6IFtcbiAgICAnZm9hbS5uZXQud2ViLlhNTEhUVFBSZXNwb25zZSBhcyBIVFRQUmVzcG9uc2UnXG4gIF0sXG5cbiAgbWV0aG9kczogW1xuICAgIGZ1bmN0aW9uIHNlbmQoKSB7XG4gICAgICBpZiAoIHRoaXMudXJsICkge1xuICAgICAgICB0aGlzLmZyb21VcmwodGhpcy51cmwpO1xuICAgICAgfVxuXG4gICAgICB2YXIgeGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG4gICAgICB4aHIub3BlbihcbiAgICAgICAgICB0aGlzLm1ldGhvZCxcbiAgICAgICAgICB0aGlzLnByb3RvY29sICsgXCI6Ly9cIiArXG4gICAgICAgICAgdGhpcy5ob3N0bmFtZSArICggdGhpcy5wb3J0ID8gKCAnOicgKyB0aGlzLnBvcnQgKSA6ICcnICkgK1xuICAgICAgICAgIHRoaXMucGF0aCk7XG4gICAgICB4aHIucmVzcG9uc2VUeXBlID0gdGhpcy5yZXNwb25zZVR5cGU7XG4gICAgICBmb3IgKCB2YXIga2V5IGluIHRoaXMuaGVhZGVycyApIHtcbiAgICAgICAgeGhyLnNldFJlcXVlc3RIZWFkZXIoa2V5LCB0aGlzLmhlYWRlcnNba2V5XSk7XG4gICAgICB9XG5cbiAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgeGhyLmFkZEV2ZW50TGlzdGVuZXIoJ3JlYWR5c3RhdGVjaGFuZ2UnLCBmdW5jdGlvbiBmb28oKSB7XG4gICAgICAgICAgaWYgKCB0aGlzLnJlYWR5U3RhdGUgPT09IHRoaXMuTE9BRElORyB8fFxuICAgICAgICAgICAgICAgdGhpcy5yZWFkeVN0YXRlID09PSB0aGlzLkRPTkUgKSB7XG4gICAgICAgICAgICB0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3JlYWR5c3RhdGVjaGFuZ2UnLCBmb28pO1xuICAgICAgICAgICAgdmFyIHJlc3AgPSBzZWxmLkhUVFBSZXNwb25zZS5jcmVhdGUoe1xuICAgICAgICAgICAgICB4aHI6IHRoaXNcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBpZiAoIHJlc3Auc3VjY2VzcyApIHJlc29sdmUocmVzcCk7XG4gICAgICAgICAgICBlbHNlIHJlamVjdChyZXNwKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB4aHIuc2VuZChzZWxmLnBheWxvYWQpO1xuICAgICAgfSk7XG4gICAgfVxuICBdXG59KTtcbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IFRoZSBGT0FNIEF1dGhvcnMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmZvYW0uQ0xBU1Moe1xuICBwYWNrYWdlOiAnZm9hbS5uZXQud2ViJyxcbiAgbmFtZTogJ1hNTEhUVFBSZXNwb25zZScsXG4gIGV4dGVuZHM6ICdmb2FtLm5ldC53ZWIuSFRUUFJlc3BvbnNlJyxcblxuICBjb25zdGFudHM6IHtcbiAgICBTVFJFQU1JTkdfTElNSVQ6IDEwICogMTAyNCAqIDEwMjRcbiAgfSxcblxuICBwcm9wZXJ0aWVzOiBbXG4gICAge1xuICAgICAgbmFtZTogJ3hocicsXG4gICAgICBwb3N0U2V0OiBmdW5jdGlvbihfLCB4aHIpIHtcbiAgICAgICAgdGhpcy5zdGF0dXMgPSB4aHIuc3RhdHVzO1xuICAgICAgICB2YXIgaGVhZGVycyA9IHhoci5nZXRBbGxSZXNwb25zZUhlYWRlcnMoKS5zcGxpdCgnXFxyXFxuJyk7XG4gICAgICAgIGZvciAoIHZhciBpID0gMCA7IGkgPCBoZWFkZXJzLmxlbmd0aCA7IGkrKyApIHtcbiAgICAgICAgICB2YXIgc2VwID0gaGVhZGVyc1tpXS5pbmRleE9mKCc6Jyk7XG4gICAgICAgICAgdmFyIGtleSA9IGhlYWRlcnNbaV0uc3Vic3RyaW5nKDAsIHNlcCk7XG4gICAgICAgICAgdmFyIHZhbHVlID0gaGVhZGVyc1tpXS5zdWJzdHJpbmcoc2VwKzEpO1xuICAgICAgICAgIHRoaXMuaGVhZGVyc1trZXkudHJpbSgpXSA9IHZhbHVlLnRyaW0oKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJlc3BvbnNlVHlwZSA9IHhoci5yZXNwb25zZVR5cGU7XG4gICAgICB9XG4gICAgfSxcbiAgICB7XG4gICAgICBuYW1lOiAncGF5bG9hZCcsXG4gICAgICBmYWN0b3J5OiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKCB0aGlzLnN0cmVhbWluZyApIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgdmFyIHhociA9IHRoaXMueGhyO1xuXG4gICAgICAgIGlmICggeGhyLnJlYWR5U3RhdGUgPT09IHhoci5ET05FIClcbiAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHhoci5yZXNwb25zZSk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICB4aHIuYWRkRXZlbnRMaXN0ZW5lcigncmVhZHlzdGF0ZWNoYW5nZScsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICBpZiAoIHRoaXMucmVhZHlTdGF0ZSA9PT0gdGhpcy5ET05FIClcbiAgICAgICAgICAgICAgICByZXNvbHZlKHRoaXMucmVzcG9uc2UpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSxcbiAgICB7XG4gICAgICBjbGFzczogJ0ludCcsXG4gICAgICBuYW1lOiAncG9zJyxcbiAgICAgIHZhbHVlOiAwXG4gICAgfVxuICBdLFxuXG4gIG1ldGhvZHM6IFtcbiAgICBmdW5jdGlvbiBzdGFydCgpIHtcbiAgICAgIHRoaXMuc3RyZWFtaW5nID0gdHJ1ZTtcbiAgICAgIHRoaXMueGhyLmFkZEV2ZW50TGlzdGVuZXIoJ2xvYWRlbmQnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5kb25lLnB1YigpO1xuICAgICAgfS5iaW5kKHRoaXMpKTtcblxuICAgICAgdGhpcy54aHIuYWRkRXZlbnRMaXN0ZW5lcigncHJvZ3Jlc3MnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHN1YnN0ciA9IHRoaXMueGhyLnJlc3BvbnNlVGV4dC5zdWJzdHJpbmcodGhpcy5wb3MpO1xuICAgICAgICB0aGlzLnBvcyA9IHRoaXMueGhyLnJlc3BvbnNlVGV4dC5sZW5ndGg7XG4gICAgICAgIHRoaXMuZGF0YS5wdWIoc3Vic3RyKTtcblxuICAgICAgICBpZiAoIHRoaXMucG9zID4gdGhpcy5TVFJFQU1JTkdfTElNSVQgKSB7XG4gICAgICAgICAgdGhpcy54aHIuYWJvcnQoKTtcbiAgICAgICAgfVxuICAgICAgfS5iaW5kKHRoaXMpKTtcbiAgICB9XG4gIF1cbn0pO1xuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgVGhlIEZPQU0gQXV0aG9ycy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuZm9hbS5DTEFTUyh7XG4gIHBhY2thZ2U6ICdmb2FtLm5ldC53ZWInLFxuICBuYW1lOiAnU2FmYXJpRXZlbnRTb3VyY2UnLFxuICBleHRlbmRzOiAnZm9hbS5uZXQud2ViLkV2ZW50U291cmNlJyxcblxuICByZXF1aXJlczogW1xuICAgICdmb2FtLm5ldC53ZWIuWE1MSFRUUFJlcXVlc3QgYXMgSFRUUFJlcXVlc3QnXG4gIF0sXG5cbiAgcHJvcGVydGllczogW1xuICAgIHtcbiAgICAgIGNsYXNzOiAnU3RyaW5nJyxcbiAgICAgIG5hbWU6ICdidWZmZXInXG4gICAgfVxuICBdLFxuXG4gIGxpc3RlbmVyczogW1xuICAgIGZ1bmN0aW9uIG9uRGF0YShzLCBfLCBkYXRhKSB7XG4gICAgICB0aGlzLmRlbGF5ID0gMTtcbiAgICAgIHRoaXMua2VlcEFsaXZlKCk7XG5cbiAgICAgIHRoaXMuYnVmZmVyICs9IGRhdGE7XG4gICAgICB2YXIgc3RyaW5nID0gdGhpcy5idWZmZXI7XG5cbiAgICAgIHdoaWxlICggc3RyaW5nLmluZGV4T2YoJ1xcbicpICE9IC0xICkge1xuICAgICAgICB2YXIgbGluZSA9IHN0cmluZy5zdWJzdHJpbmcoMCwgc3RyaW5nLmluZGV4T2YoJ1xcbicpKTtcbiAgICAgICAgdGhpcy5wcm9jZXNzTGluZShsaW5lKTtcbiAgICAgICAgc3RyaW5nID0gc3RyaW5nLnN1YnN0cmluZyhzdHJpbmcuaW5kZXhPZignXFxuJykgKyAxKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5idWZmZXIgPSBzdHJpbmc7XG4gICAgfVxuICBdXG59KTtcbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmZvYW0uQ0xBU1Moe1xuICBwYWNrYWdlOiAnZm9hbS5tZXNzYWdlcG9ydCcsXG4gIG5hbWU6ICdNZXNzYWdlUG9ydFNlcnZpY2UnLFxuXG4gIHJlcXVpcmVzOiBbXG4gICAgJ2ZvYW0uYm94Lk5hbWVkQm94JyxcbiAgICAnZm9hbS5ib3guUmF3TWVzc2FnZVBvcnRCb3gnLFxuICAgICdmb2FtLmJveC5SZWdpc3RlclNlbGZNZXNzYWdlJyxcbiAgICAnZm9hbS5qc29uLlBhcnNlcidcbiAgXSxcbiAgaW1wb3J0czogW1xuICAgICdjcmVhdGlvbkNvbnRleHQnXG4gIF0sXG5cbiAgdG9waWNzOiBbICdjb25uZWN0JyBdLFxuXG4gIHByb3BlcnRpZXM6IFtcbiAgICB7XG4gICAgICBuYW1lOiAnc291cmNlJyxcbiAgICAgIHBvc3RTZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLnNvdXJjZS5hZGRFdmVudExpc3RlbmVyKCdjb25uZWN0JywgdGhpcy5vbkNvbm5lY3QpO1xuICAgICAgICB0aGlzLnNvdXJjZS5hZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgdGhpcy5vbkNvbm5lY3QpO1xuICAgICAgfVxuICAgIH0sXG4gICAge1xuICAgICAgbmFtZTogJ2RlbGVnYXRlJyxcbiAgICAgIHJlcXVpcmVkOiB0cnVlXG4gICAgfSxcbiAgICB7XG4gICAgICBjbGFzczogJ0ZPYmplY3RQcm9wZXJ0eScsXG4gICAgICBvZjogJ2ZvYW0uanNvbi5QYXJzZXInLFxuICAgICAgbmFtZTogJ3BhcnNlcicsXG4gICAgICBmYWN0b3J5OiBmdW5jdGlvbigpIHtcbiAgICAgICAgLy8gTk9URTogQ29uZmlndXJhdGlvbiBtdXN0IGJlIGNvbnNpc3RlbnQgd2l0aCBvdXRwdXR0ZXJzIGluXG4gICAgICAgIC8vIGZvYW0uYm94Lk1lc3NhZ2VQb3J0Qm94IGFuZCBmb2FtLmJveC5SYXdNZXNhZ2VQb3J0Qm94LlxuICAgICAgICByZXR1cm4gdGhpcy5QYXJzZXIuY3JlYXRlKHtcbiAgICAgICAgICBzdHJpY3Q6IHRydWUsXG4gICAgICAgICAgY3JlYXRpb25Db250ZXh0OiB0aGlzLmNyZWF0aW9uQ29udGV4dFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gIF0sXG5cbiAgbWV0aG9kczogW1xuICAgIGZ1bmN0aW9uIGFkZFBvcnQocCkge1xuICAgICAgcC5vbm1lc3NhZ2UgPSB0aGlzLm9uTWVzc2FnZS5iaW5kKHRoaXMsIHApO1xuICAgIH1cbiAgXSxcblxuICBsaXN0ZW5lcnM6IFtcbiAgICBmdW5jdGlvbiBvbkNvbm5lY3QoZSkge1xuICAgICAgZm9yICggdmFyIGkgPSAwIDsgaSA8IGUucG9ydHMubGVuZ3RoIDsgaSsrICkge1xuICAgICAgICB0aGlzLmFkZFBvcnQoZS5wb3J0c1tpXSk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIGZ1bmN0aW9uIG9uTWVzc2FnZShwb3J0LCBlKSB7XG4gICAgICB2YXIgbXNnID0gdGhpcy5wYXJzZXIucGFyc2VTdHJpbmcoZS5kYXRhKTtcblxuICAgICAgaWYgKCB0aGlzLlJlZ2lzdGVyU2VsZk1lc3NhZ2UuaXNJbnN0YW5jZShtc2cub2JqZWN0KSApIHtcbiAgICAgICAgdmFyIG5hbWVkID0gdGhpcy5OYW1lZEJveC5jcmVhdGUoeyBuYW1lOiBtc2cub2JqZWN0Lm5hbWUgfSk7XG4gICAgICAgIG5hbWVkLmRlbGVnYXRlID0gdGhpcy5SYXdNZXNzYWdlUG9ydEJveC5jcmVhdGUoe1xuICAgICAgICAgIHBvcnQ6IHBvcnRcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuY29ubmVjdC5wdWIobmFtZWQpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHRoaXMuZGVsZWdhdGUgJiYgdGhpcy5kZWxlZ2F0ZS5zZW5kKG1zZyk7XG4gICAgfVxuICBdXG59KTtcbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbi8qXG5UT0RPOlxuLWJldHRlciBzZXJpYWxpemF0aW9uL2Rlc2VyaWFsaXphdGlvblxuLWVycm9yIGhhbmRsaW5nIGlmIGZpcmViYXNlIGNvbnRhaW5zIG1hbGZvcm1lZCBkYXRhLCBzaW5jZSB3ZSdyZSBub3QgdGhlIG9ubHlcbm9uZXMgd2hvIGNhbiB3cml0ZSB0byBpdC5cbi1tdWx0aSBwYXJ0IGtleXNcbiovXG5cbmZvYW0uQ0xBU1Moe1xuICBwYWNrYWdlOiAnY29tLmZpcmViYXNlJyxcbiAgbmFtZTogJ0V4cGVjdGVkT2JqZWN0Tm90Rm91bmQnLFxuICBleHRlbmRzOiAnZm9hbS5kYW8uSW50ZXJuYWxFeGNlcHRpb24nXG59KTtcblxuZm9hbS5DTEFTUyh7XG4gIHBhY2thZ2U6ICdjb20uZmlyZWJhc2UnLFxuICBuYW1lOiAnRmlyZWJhc2VEQU8nLFxuICBleHRlbmRzOiAnZm9hbS5kYW8uQWJzdHJhY3REQU8nLFxuXG4gIHJlcXVpcmVzOiBbXG4gICAgJ2ZvYW0uZGFvLkFycmF5U2luaycsXG4gICAgJ2ZvYW0ubmV0LndlYi5IVFRQUmVxdWVzdCcsXG4gICAgJ2NvbS5maXJlYmFzZS5GaXJlYmFzZUV2ZW50U291cmNlJyxcbiAgICAnZm9hbS5tbGFuZy5wcmVkaWNhdGUuR3QnLFxuICAgICdmb2FtLm1sYW5nLkNvbnN0YW50J1xuICBdLFxuXG4gIHByb3BlcnRpZXM6IFtcbiAgICAnb2YnLFxuICAgICdhcHBwYXRoJyxcbiAgICAnc2VjcmV0JyxcbiAgICAnZXZlbnRTb3VyY2VfJyxcbiAgICB7XG4gICAgICBuYW1lOiAndGltZXN0YW1wUHJvcGVydHknXG4gICAgfSxcbiAgICB7XG4gICAgICBuYW1lOiAnYmFzZXBhdGgnLFxuICAgICAgZXhwcmVzc2lvbjogZnVuY3Rpb24oYXBwcGF0aCwgb2YpIHtcbiAgICAgICAgcmV0dXJuIGFwcHBhdGggKyBvZi5pZC5yZXBsYWNlKC9cXC4vZywgJy8nKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHtcbiAgICAgIGNsYXNzOiAnQm9vbGVhbicsXG4gICAgICBuYW1lOiAnZW5hYmxlU3RyZWFtaW5nJyxcbiAgICAgIHZhbHVlOiB0cnVlXG4gICAgfSxcbiAgICAnc3RhcnRFdmVudHNBdF8nXG4gIF0sXG5cbiAgbWV0aG9kczogW1xuICAgIGZ1bmN0aW9uIHB1dF8oeCwgb2JqKSB7XG4gICAgICB2YXIgcmVxID0gdGhpcy5IVFRQUmVxdWVzdC5jcmVhdGUoKTtcblxuICAgICAgaWYgKCBvYmouaWQgKSB7XG4gICAgICAgIHJlcS5tZXRob2QgPSBcIlBVVFwiO1xuICAgICAgICByZXEudXJsID0gdGhpcy5iYXNlcGF0aFxuICAgICAgICAgICsgXCIvXCJcbiAgICAgICAgICArIGVuY29kZVVSSUNvbXBvbmVudChvYmouaWQpICsgXCIuanNvblwiO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdTZXJ2ZXIgZ2VuZXJhdGVkIElEcyBub3Qgc3VwcG9ydGVkLicpO1xuICAgICAgICAvLyByZXEubWV0aG9kID0gJ1BPU1QnO1xuICAgICAgICAvLyByZXEudXJsID0gdGhpcy5iYXNlcGF0aCArICcuanNvbic7XG4gICAgICB9XG5cbiAgICAgIGlmICggdGhpcy5zZWNyZXQgKSB7XG4gICAgICAgIHJlcS51cmwgKz0gJz9hdXRoPScgKyBlbmNvZGVVUklDb21wb25lbnQodGhpcy5zZWNyZXQpO1xuICAgICAgfVxuXG4gICAgICByZXEucGF5bG9hZCA9IEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgZGF0YTogZm9hbS5qc29uLnN0cmluZ2lmeShvYmopLFxuICAgICAgICBsYXN0VXBkYXRlOiB7XG4gICAgICAgICAgXCIuc3ZcIjogXCJ0aW1lc3RhbXBcIlxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJlcS5oZWFkZXJzWydjb250ZW50LXR5cGUnXSA9ICdhcHBsaWNhdGlvbi9qc29uJztcbiAgICAgIHJlcS5oZWFkZXJzWydhY2NlcHQnXSAgICAgICA9ICdhcHBsaWNhdGlvbi9qc29uJztcblxuICAgICAgcmV0dXJuIHJlcS5zZW5kKCkudGhlbihmdW5jdGlvbihyZXNwKSB7XG4gICAgICAgIHJldHVybiByZXNwLnBheWxvYWQ7XG4gICAgICB9KS50aGVuKGZ1bmN0aW9uKHBheWxvYWQpIHtcbiAgICAgICAgcGF5bG9hZCA9IEpTT04ucGFyc2UocGF5bG9hZCk7XG5cbiAgICAgICAgLy8gICAgICAgIGlmICggb2JqLmlkICkge1xuICAgICAgICB2YXIgbzIgPSBmb2FtLmpzb24ucGFyc2VTdHJpbmcocGF5bG9hZC5kYXRhLCB0aGlzKTtcbiAgICAgICAgICBpZiAoIHRoaXMudGltZXN0YW1wUHJvcGVydHkgKSB7XG4gICAgICAgICAgICB0aGlzLnRpbWVzdGFtcFByb3BlcnR5LnNldChvMiwgcGF5bG9hZC5sYXN0VXBkYXRlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG8yO1xuICAgICAgICAvLyAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gICAgICAgICAgIFNlcnZlciBjcmVhdGVkIGlkXG4gICAgICAgIC8vICAgICAgICB9XG4gICAgICB9LmJpbmQodGhpcyksIGZ1bmN0aW9uKHJlc3ApIHtcbiAgICAgICAgLy8gVE9ETzogSGFuZGxlIHZhcmlvdXMgZXJyb3JzLlxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZm9hbS5kYW8uSW50ZXJuYWxFeGNlcHRpb24uY3JlYXRlKCkpO1xuICAgICAgfSk7XG4gICAgfSxcblxuICAgIGZ1bmN0aW9uIHJlbW92ZV8oeCwgb2JqKSB7XG4gICAgICB2YXIgcmVxID0gdGhpcy5IVFRQUmVxdWVzdC5jcmVhdGUoKTtcbiAgICAgIHJlcS5tZXRob2QgPSAnREVMRVRFJyxcbiAgICAgIHJlcS51cmwgPSB0aGlzLmJhc2VwYXRoICsgXCIvXCIgKyBlbmNvZGVVUklDb21wb25lbnQob2JqLmlkKSArIFwiLmpzb25cIjtcblxuICAgICAgaWYgKCB0aGlzLnNlY3JldCApIHtcbiAgICAgICAgcmVxLnVybCArPSBcIj9hdXRoPVwiICsgZW5jb2RlVVJJQ29tcG9uZW50KHRoaXMuc2VjcmV0KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlcS5zZW5kKCkudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgICAgfSwgZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChmb2FtLmRhby5JbnRlcm5hbEV4Y2VwdGlvbi5jcmVhdGUoKSk7XG4gICAgICB9KTtcbiAgICB9LFxuXG4gICAgZnVuY3Rpb24gZmluZF8oeCwgaWQpIHtcbiAgICAgIHZhciByZXEgPSB0aGlzLkhUVFBSZXF1ZXN0LmNyZWF0ZSgpO1xuICAgICAgcmVxLm1ldGhvZCA9IFwiR0VUXCI7XG4gICAgICByZXEudXJsID0gdGhpcy5iYXNlcGF0aCArIFwiL1wiICsgZW5jb2RlVVJJQ29tcG9uZW50KGlkKSArIFwiLmpzb25cIjtcbiAgICAgIGlmICggdGhpcy5zZWNyZXQgKSB7XG4gICAgICAgIHJlcS51cmwgKz0gXCI/YXV0aD1cIiArIGVuY29kZVVSSUNvbXBvbmVudCh0aGlzLnNlY3JldCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXEuc2VuZCgpLnRoZW4oZnVuY3Rpb24ocmVzcCkge1xuICAgICAgICByZXR1cm4gcmVzcC5wYXlsb2FkO1xuICAgICAgfSkudGhlbihmdW5jdGlvbihkYXRhKSB7XG4gICAgICAgIGlmICggZGF0YSA9PSBcIm51bGxcIiApIHtcbiAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKG51bGwpO1xuICAgICAgICB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgZGF0YSA9IEpTT04ucGFyc2UoZGF0YSk7XG5cbiAgICAgICAgICB2YXIgb2JqID0gZm9hbS5qc29uLnBhcnNlU3RyaW5nKGRhdGEuZGF0YSwgdGhpcyk7XG5cbiAgICAgICAgICBpZiAoIHRoaXMudGltZXN0YW1wUHJvcGVydHkgKSB7XG4gICAgICAgICAgICB0aGlzLnRpbWVzdGFtcFByb3BlcnR5LnNldChvYmosIGRhdGEubGFzdFVwZGF0ZSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIG9iajtcbiAgICAgICAgfSBjYXRjaChlKSB7XG4gICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGZvYW0uZGFvLkludGVybmFsRXhjZXB0aW9uLmNyZWF0ZSgpKTtcbiAgICAgICAgfVxuICAgICAgfS5iaW5kKHRoaXMpKTtcbiAgICB9LFxuXG4gICAgZnVuY3Rpb24gc3RhcnRFdmVudHMoKSB7XG4gICAgICBpZiAoIHRoaXMuZXZlbnRTb3VyY2VfIHx8ICEgdGhpcy5lbmFibGVTdHJlYW1pbmcgKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIHBhcmFtcyA9IFtdO1xuICAgICAgaWYgKCB0aGlzLnNlY3JldCApIHBhcmFtcy5wdXNoKFsnYXV0aCcsIHRoaXMuc2VjcmV0XSk7XG4gICAgICBpZiAoIHRoaXMuc3RhcnRFdmVudHNBdF8gKSB7XG4gICAgICAgIHBhcmFtcy5wdXNoKFsnb3JkZXJCeScsICdcImxhc3RVcGRhdGVcIiddKTtcbiAgICAgICAgcGFyYW1zLnB1c2goWydzdGFydEF0JywgdGhpcy5zdGFydEV2ZW50c0F0X10pO1xuICAgICAgfVxuXG4gICAgICB2YXIgdXJpID0gdGhpcy5iYXNlcGF0aCArICcuanNvbic7XG4gICAgICBpZiAoIHBhcmFtcy5sZW5ndGggKSB7XG4gICAgICAgIHVyaSArPSAnPycgKyBwYXJhbXMubWFwKGZ1bmN0aW9uKHApIHsgcmV0dXJuIHAubWFwKGVuY29kZVVSSUNvbXBvbmVudCkuam9pbignPScpOyB9KS5qb2luKCcmJyk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuZXZlbnRTb3VyY2VfID0gdGhpcy5GaXJlYmFzZUV2ZW50U291cmNlLmNyZWF0ZSh7XG4gICAgICAgIHVyaTogdXJpXG4gICAgICB9KTtcblxuICAgICAgdGhpcy5ldmVudFNvdXJjZV8ucHV0LnN1Yih0aGlzLm9uUHV0KTtcbiAgICAgIHRoaXMuZXZlbnRTb3VyY2VfLnBhdGNoLnN1Yih0aGlzLm9uUGF0Y2gpO1xuICAgICAgdGhpcy5ldmVudFNvdXJjZV8uc3RhcnQoKTtcbiAgICB9LFxuXG4gICAgZnVuY3Rpb24gc3RvcEV2ZW50cygpIHtcbiAgICAgIGlmICggdGhpcy5ldmVudFNvdXJjZV8gKSB7XG4gICAgICAgIHRoaXMuZXZlbnRTb3VyY2VfLmNsb3NlKCk7XG4gICAgICAgIHRoaXMuZXZlbnRTb3VyY2VfLm1lc3NhZ2UucHV0LnVuc3ViKHRoaXMub25QdXQpO1xuICAgICAgICB0aGlzLmV2ZW50U291cmNlXy5tZXNzYWdlLnBhdGNoLnVuc3ViKHRoaXMub25QYXRjaCk7XG4gICAgICAgIHRoaXMuY2xlYXJQcm9wZXJ0eSgnZXZlbnRTb3VyY2VfJyk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIGZ1bmN0aW9uIHNlbGVjdF8oeCwgc2luaywgc2tpcCwgbGltaXQsIG9yZGVyLCBwcmVkaWNhdGUpIHtcbiAgICAgIHZhciByZXEgPSB0aGlzLkhUVFBSZXF1ZXN0LmNyZWF0ZSgpO1xuICAgICAgcmVxLm1ldGhvZCA9IFwiR0VUXCI7XG5cbiAgICAgIHZhciBwYXJhbXMgPSBbXTtcbiAgICAgIGlmICggdGhpcy5zZWNyZXQgKSBwYXJhbXMucHVzaChbJ2F1dGgnLCB0aGlzLnNlY3JldF0pO1xuXG4gICAgICAvLyBFZmZpY2llbnRseSBoYW5kbGUgR1QobGFzdHVwZGF0ZSwgIykgcXVlcmllcy4gIFVzZWQgYnkgdGhlIFN5bmNEQU8gdG8gZ2V0XG4gICAgICAvLyBhbGwgY2hhbmdlcy5cblxuICAgICAgaWYgKCBwcmVkaWNhdGUgJiYgdGhpcy50aW1lc3RhbXBQcm9wZXJ0eSAmJlxuICAgICAgICAgICB0aGlzLkd0LmlzSW5zdGFuY2UocHJlZGljYXRlKSAmJlxuICAgICAgICAgICB0aGlzLkNvbnN0YW50LmlzSW5zdGFuY2UocHJlZGljYXRlLmFyZzIpICYmXG4gICAgICAgICAgIHByZWRpY2F0ZS5hcmcxID09PSB0aGlzLnRpbWVzdGFtcFByb3BlcnR5ICkge1xuXG4gICAgICAgIC8vIFRPRE86IFRoaXMgaXMgYSBoYWNrIHRvIGVuc3VyZSB0aGF0XG4gICAgICAgIGlmICggISB0aGlzLnN0YXJ0RXZlbnRzQXRfICkgIHtcbiAgICAgICAgICB0aGlzLnN0YXJ0RXZlbnRzQXRfID0gcHJlZGljYXRlLmFyZzIuZigpICsgMTtcbiAgICAgICAgICB0aGlzLnN0YXJ0RXZlbnRzKCk7XG4gICAgICAgIH1cblxuICAgICAgICBwYXJhbXMucHVzaChbJ29yZGVyQnknLCAnXCJsYXN0VXBkYXRlXCInXSk7XG4gICAgICAgIHBhcmFtcy5wdXNoKFsnc3RhcnRBdCcsIHByZWRpY2F0ZS5hcmcyLmYoKSArIDFdKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHVybCA9IHRoaXMuYmFzZXBhdGggKyAnLmpzb24nO1xuICAgICAgaWYgKCBwYXJhbXMubGVuZ3RoICkge1xuICAgICAgICB1cmwgKz0gJz8nICsgcGFyYW1zLm1hcChmdW5jdGlvbihwKSB7IHJldHVybiBwLm1hcChlbmNvZGVVUklDb21wb25lbnQpLmpvaW4oJz0nKTsgfSkuam9pbignJicpO1xuICAgICAgfVxuXG4gICAgICByZXEudXJsID0gdXJsO1xuXG4gICAgICB2YXIgcmVzdWx0U2luayA9IHNpbmsgfHwgdGhpcy5BcnJheVNpbmsuY3JlYXRlKCk7XG4gICAgICBzaW5rID0gdGhpcy5kZWNvcmF0ZVNpbmtfKHJlc3VsdFNpbmssIHNraXAsIGxpbWl0LCBvcmRlciwgcHJlZGljYXRlKTtcblxuICAgICAgLy8gVE9ETzogVGhpcyBzaG91bGQgYmUgc3RyZWFtZWQgZm9yIGJldHRlciBoYW5kbGluZyBvZiBsYXJnZSByZXNwb25zZXMuXG4gICAgICByZXR1cm4gcmVxLnNlbmQoKS50aGVuKGZ1bmN0aW9uKHJlc3ApIHtcbiAgICAgICAgaWYgKCAhIHJlc3Auc3VjY2VzcyApIHtcbiAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZm9hbS5kYW8uSW50ZXJuYWxFeGNlcHRpb24uY3JlYXRlKCkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXNwLnBheWxvYWQ7XG4gICAgICB9KS50aGVuKGZ1bmN0aW9uKHBheWxvYWQpIHtcbiAgICAgICAgdmFyIGRhdGEgPSBKU09OLnBhcnNlKHBheWxvYWQpO1xuXG4gICAgICAgIHZhciBkZXRhY2hlZCA9IGZhbHNlO1xuICAgICAgICB2YXIgc3ViID0gZm9hbS5jb3JlLkZPYmplY3QuY3JlYXRlKCk7XG4gICAgICAgIHN1Yi5vbkRldGFjaChmdW5jdGlvbigpIHsgZGV0YWNoZWQgPSB0cnVlOyB9KTtcblxuICAgICAgICBmb3IgKCB2YXIga2V5IGluIGRhdGEgKSB7XG4gICAgICAgICAgaWYgKCBkZXRhY2hlZCApIGJyZWFrO1xuXG4gICAgICAgICAgdmFyIG9iaiA9IGZvYW0uanNvbi5wYXJzZVN0cmluZyhkYXRhW2tleV0uZGF0YSwgdGhpcyk7XG4gICAgICAgICAgaWYgKCB0aGlzLnRpbWVzdGFtcFByb3BlcnR5ICkge1xuICAgICAgICAgICAgdGhpcy50aW1lc3RhbXBQcm9wZXJ0eS5zZXQob2JqLCBkYXRhW2tleV0ubGFzdFVwZGF0ZSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgc2luay5wdXQob2JqLCBzdWIpO1xuICAgICAgICB9XG4gICAgICAgIHNpbmsuZW9mKCk7XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdFNpbms7XG4gICAgICB9LmJpbmQodGhpcyksIGZ1bmN0aW9uKHJlc3ApIHtcbiAgICAgICAgdmFyIGUgPSBmb2FtLmRhby5JbnRlcm5hbEV4Y2VwdGlvbi5jcmVhdGUoKTtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGUpO1xuICAgICAgfSk7XG4gICAgfVxuICBdLFxuXG4gIGxpc3RlbmVyczogW1xuICAgIGZ1bmN0aW9uIG9uUHV0KHMsIF8sIGRhdGEpIHtcbiAgICAgIC8vIFBBVEggaXMgb25lIG9mXG4gICAgICAvLyAvIC0+IG5ldyBvYmplY3RzXG4gICAgICAvLyAva2V5IC0+IG5ldyBvYmplY3RcbiAgICAgIC8vIC9rZXkvZGF0YSAtPiB1cGRhdGVkIG9iamVjdFxuXG4gICAgICB2YXIgcGF0aCA9IGRhdGEucGF0aDtcbiAgICAgIGlmICggcGF0aCA9PSBcIi9cIiApIHtcbiAgICAgICAgLy8gQWxsIGRhdGEgcmVtb3ZlZD9cbiAgICAgICAgaWYgKCBkYXRhLmRhdGEgPT0gbnVsbCApIHtcbiAgICAgICAgICB0aGlzLm9uLnJlc2V0LnB1YigpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoIHZhciBrZXkgaW4gZGF0YS5kYXRhICkge1xuICAgICAgICAgIHZhciBvYmogPSBmb2FtLmpzb24ucGFyc2VTdHJpbmcoZGF0YS5kYXRhW2tleV0uZGF0YSwgdGhpcyk7XG4gICAgICAgICAgaWYgKCB0aGlzLnRpbWVzdGFtcFByb3BlcnR5ICkge1xuICAgICAgICAgICAgdGhpcy50aW1lc3RhbXBQcm9wZXJ0eS5zZXQob2JqLCBkYXRhLmRhdGFba2V5XS5sYXN0VXBkYXRlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5vbi5wdXQucHViKG9iaik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSBlbHNlIGlmICggcGF0aC5sYXN0SW5kZXhPZignLycpID09PSAwICkge1xuICAgICAgICBpZiAoIGRhdGEuZGF0YSA9PSBudWxsICkge1xuICAgICAgICAgIHZhciBvYmogPSB0aGlzLm9mLmNyZWF0ZSgpO1xuICAgICAgICAgIG9iai5pZCA9IHBhdGguc3Vic3RyaW5nKDEpXG4gICAgICAgICAgdGhpcy5vbi5yZW1vdmUucHViKG9iaik7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBvYmogPSBmb2FtLmpzb24ucGFyc2VTdHJpbmcoZGF0YS5kYXRhLmRhdGEsIHRoaXMpO1xuICAgICAgICBpZiAoIHRoaXMudGltZXN0YW1wUHJvcGVydHkgKSB7XG4gICAgICAgICAgdGhpcy50aW1lc3RhbXBQcm9wZXJ0eS5zZXQob2JqLCBkYXRhLmRhdGEubGFzdFVwZGF0ZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5vbi5wdXQucHViKG9iaik7XG4gICAgICB9IGVsc2UgaWYgKCBwYXRoLmluZGV4T2YoJy9kYXRhJykgPT09IHBhdGgubGVuZ3RoIC0gNSApIHtcbiAgICAgICAgLy8gVGhlc2UgbGFzdCB0d28gZXZlbnRzIHNob3VsZG4ndCBoYXBwZW4gdW5sZXNzIHNvbWVib2R5IGlzIGVkaXRpbmdcbiAgICAgICAgLy8gdGhlIHVuZGVybHlpbmcgZmlyZWJhc2UgZGF0YSBieSBoYW5kLlxuXG4gICAgICAgIC8vIERhdGEgb2YgYW4gZXhpc3Rpbmcgcm93IHVwZGF0ZWQuXG4gICAgICAgIGRlYnVnZ2VyO1xuICAgICAgICB2YXIgaWQgPSBwYXRoLnN1YnN0cmluZygxKTtcbiAgICAgICAgaWQgPSBpZC5zdWJzdHJpbmcoMCwgaWQuaW5kZXhPZignLycpKTtcbiAgICAgICAgdGhpcy5maW5kKGlkKS50aGVuKGZ1bmN0aW9uKG9iaikge1xuICAgICAgICAgIGlmICggISBvYmogKSB0aHJvdyBjb20uZmlyZWJhc2UuRXhwZWN0ZWRPYmplY3ROb3RGb3VuZC5jcmVhdGUoKTtcbiAgICAgICAgICB0aGlzLm9uLnB1dC5wdWIob2JqKTtcbiAgICAgICAgfS5iaW5kKHRoaXMpKTtcblxuICAgICAgICAvLyB2YXIgb2JqID0gZm9hbS5qc29uLnBhcnNlU3RyaW5nKGRhdGEuZGF0YSwgdGhpcyk7XG4gICAgICAgIC8vIHRoaXMub24ucHV0LnB1YihvYmopO1xuICAgICAgfSBlbHNlIGlmICggcGF0aC5pbmRleE9mKCcvbGFzdFVwZGF0ZScpID09PSBwYXRoLmxlbmd0aCAtIDExICkge1xuICAgICAgICAvLyBUaW1lc3RhbXAgb2YgYW4gZXhpc3Rpbmcgcm93IHVwZGF0ZWQsIGRvIGFueXRoaW5nP1xuICAgICAgICAvLyBwcmVzdW1hYmx5IGlmIHRoZSBvYmplY3QgaXRzZWxmIGhhc24ndCBiZWVuIHVwZGF0ZWQgd2UgZG9uJ3QgY2FyZVxuICAgICAgICAvLyBpZiBpdCBoYXMgYmVlbiB1cGRhdGVkIHdlIHNob3VsZCBnZXQgYW4gZXZlbnQgZm9yIHRoYXQuXG5cbiAgICAgICAgZGVidWdnZXI7XG4gICAgICAgIHZhciBpZCA9IHBhdGguc3Vic3RyaW5nKDEpO1xuICAgICAgICBpZCA9IGlkLnN1YnN0cmluZygwLCBpZC5pbmRleE9mKCcvJykpO1xuICAgICAgICB0aGlzLmZpbmQoaWQpLnRoZW4oZnVuY3Rpb24ob2JqKSB7XG4gICAgICAgICAgaWYgKCAhIG9iaiApIHRocm93IGNvbS5maXJlYmFzZS5FeHBlY3RlZE9iamVjdE5vdEZvdW5kLmNyZWF0ZSgpO1xuICAgICAgICAgIHRoaXMub24ucHV0LnB1YihvYmopO1xuICAgICAgICB9LmJpbmQodGhpcykpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBmdW5jdGlvbiBvblBhdGNoKHMsIF8sIF9fLCBkYXRhKSB7XG4gICAgICAgICAgLy8gVE9ETzogV2hhdCBkb2VzIGEgcGF0Y2ggZXZlbiBsb29rIGxpa2U/XG4gICAgICBkZWJ1Z2dlcjtcbiAgICB9XG4gIF1cbn0pO1xuXG5cbmZvYW0uQ0xBU1Moe1xuICBwYWNrYWdlOiAnY29tLmZpcmViYXNlJyxcbiAgbmFtZTogJ1NhZmFyaUZpcmViYXNlREFPJyxcbiAgZXh0ZW5kczogJ2NvbS5maXJlYmFzZS5GaXJlYmFzZURBTycsXG5cbiAgcmVxdWlyZXM6IFtcbiAgICAnZm9hbS5uZXQud2ViLlhNTEhUVFBSZXF1ZXN0IGFzIEhUVFBSZXF1ZXN0JyxcbiAgICAnZm9hbS5uZXQud2ViLlNhZmFyaUV2ZW50U291cmNlIGFzIEV2ZW50U291cmNlJ1xuICBdLFxuXG4gIHByb3BlcnRpZXM6IFtcbiAgICBbICdlbmFibGVTdHJlYW1pbmcnLCBmYWxzZSBdXG4gIF1cbn0pO1xuXG5cbmZvYW0uQ0xBU1Moe1xuICBwYWNrYWdlOiAnY29tLmZpcmViYXNlJyxcbiAgbmFtZTogJ0ZpcmViYXNlRXZlbnRTb3VyY2UnLFxuXG4gIHJlcXVpcmVzOiBbXG4gICAgJ2ZvYW0ubmV0LndlYi5FdmVudFNvdXJjZSdcbiAgXSxcblxuICB0b3BpY3M6IFtcbiAgICAncHV0JyxcbiAgICAncGF0Y2gnLFxuICAgICdrZWVwLWFsaXZlJyxcbiAgICAnY2FuY2VsJyxcbiAgICAnYXV0aF9yZXZva2VkJ1xuICBdLFxuXG4gIHByb3BlcnRpZXM6IFtcbiAgICB7XG4gICAgICBuYW1lOiAndXJpJyxcbiAgICAgIHJlcXVpcmVkOiB0cnVlXG4gICAgfSxcbiAgICB7XG4gICAgICBuYW1lOiAnZXZlbnRTb3VyY2UnLFxuICAgICAgcG9zdFNldDogZnVuY3Rpb24ob2xkLCBudSkge1xuICAgICAgICBudS5tZXNzYWdlLnN1Yih0aGlzLm9uTWVzc2FnZSk7XG4gICAgICB9LFxuICAgICAgZmFjdG9yeTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLkV2ZW50U291cmNlLmNyZWF0ZSh7XG4gICAgICAgICAgdXJpOiB0aGlzLnVyaVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHtcbiAgICAgIGNsYXNzOiAnU3RyaW5nJyxcbiAgICAgIG5hbWU6ICdidWZmZXInXG4gICAgfVxuICBdLFxuXG4gIG1ldGhvZHM6IFtcbiAgICBmdW5jdGlvbiBzdGFydCgpIHtcbiAgICAgIHRoaXMuZXZlbnRTb3VyY2Uuc3RhcnQoKTtcbiAgICB9XG4gIF0sXG5cbiAgbGlzdGVuZXJzOiBbXG4gICAgZnVuY3Rpb24gb25NZXNzYWdlKHMsIG1zZywgbmFtZSwgZGF0YSkge1xuICAgICAgc3dpdGNoIChuYW1lKSB7XG4gICAgICBjYXNlICdwdXQnOlxuICAgICAgICB0aGlzLm9uUHV0KG5hbWUsIGRhdGEpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3BhdGNoJzpcbiAgICAgICAgdGhpcy5vblBhdGNoKG5hbWUsIGRhdGEpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2tlZXAtYWxpdmUnOlxuICAgICAgICB0aGlzLm9uS2VlcEFsaXZlKG5hbWUsIGRhdGEpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2NhbmNlbCc6XG4gICAgICAgIHRoaXMub25DYW5jZWwobmFtZSwgZGF0YSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnYXV0aF9yZXZva2VkJzpcbiAgICAgICAgdGhpcy5vbkF1dGhSZXZva2VkKG5hbWUsIGRhdGEpO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRoaXMub25Vbmtub3duKG5hbWUsIGRhdGEpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBmdW5jdGlvbiBvblB1dChuYW1lLCBkYXRhKSB7XG4gICAgICB0aGlzLnB1dC5wdWIoSlNPTi5wYXJzZShkYXRhKSk7XG4gICAgICByZXR1cm47XG5cbiAgICAgIC8vIHRoaXMuYnVmZmVyICs9IGRhdGE7XG4gICAgICAvLyB0cnkge1xuICAgICAgLy8gICB2YXIgcGF5bG9hZCA9IEpTT04ucGFyc2UodGhpcy5idWZmZXIpO1xuICAgICAgLy8gfSBjYXRjaChlKSB7XG4gICAgICAvLyAgIHRoaXMud2FybignRmFpbGVkIHRvIHBhcnNlIHBheWxvYWQsIGFzc3VtaW5nIGl0cyBpbmNvbXBsZXRlLicsIGUsIHRoaXMuYnVmZmVyLmxlbmd0aCk7XG4gICAgICAvLyAgIHJldHVybjtcbiAgICAgIC8vIH1cblxuICAgICAgLy8gdGhpcy5idWZmZXIgPSAnJztcbiAgICAgIC8vIHRoaXMucHV0LnB1YihwYXlsb2FkKTtcbiAgICB9LFxuXG4gICAgZnVuY3Rpb24gb25QYXRjaCgpIHtcbiAgICAgIGRlYnVnZ2VyO1xuICAgIH0sXG5cbiAgICBmdW5jdGlvbiBvbktlZXBBbGl2ZSgpIHtcbiAgICB9LFxuXG4gICAgZnVuY3Rpb24gb25DYW5jZWwoKSB7XG4gICAgfSxcblxuICAgIGZ1bmN0aW9uIG9uVW5rbm93bihuYW1lLCBkYXRhKSB7XG4gICAgICB0aGlzLndhcm4oJ1Vua25vd24gZmlyZWJhc2UgZXZlbnQnLCBuYW1lLCBkYXRhKTtcbiAgICB9XG4gIF1cbn0pO1xuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTYgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuLy8gVE9ETzogZG9jXG5mb2FtLkNMQVNTKHtcbiAgcGFja2FnZTogJ2NvbS5maXJlYmFzZScsXG4gIG5hbWU6ICdDbG91ZE1lc3NhZ2luZycsXG5cbiAgcmVxdWlyZXM6IFtcbiAgICAnZm9hbS5uZXQubm9kZS5IVFRQUmVxdWVzdCcsXG4gIF0sXG5cbiAgcHJvcGVydGllczogW1xuICAgIHtcbiAgICAgIG5hbWU6ICdzZXJ2ZXJLZXknXG4gICAgfVxuICBdLFxuXG4gIG1ldGhvZHM6IFtcbiAgICBmdW5jdGlvbiBzZW5kKGlkLCBwYXlsb2FkLCBjb2xsYXBzZUtleSkge1xuICAgICAgcmV0dXJuIHRoaXMuSFRUUFJlcXVlc3QuY3JlYXRlKHtcbiAgICAgICAgdXJsOiAnaHR0cHM6Ly9mY20uZ29vZ2xlYXBpcy5jb20vZmNtL3NlbmQnLFxuICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgIFwiY29udGVudC10eXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiLFxuICAgICAgICAgIFwiQXV0aG9yaXphdGlvblwiOiBcImtleT1cIiArIHRoaXMuc2VydmVyS2V5XG4gICAgICAgIH0sXG4gICAgICAgIHJlc3BvbnNlVHlwZTogJ2pzb24nLFxuICAgICAgICBwYXlsb2FkOiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgdG86IGlkLFxuICAgICAgICAgIGRhdGE6IHBheWxvYWRcbiAgICAgICAgfSlcbiAgICAgIH0pLnNlbmQoKS50aGVuKGZ1bmN0aW9uKHJlc3ApIHtcbiAgICAgICAgaWYgKCAhIHJlc3Auc3VjY2VzcyApIHtcbiAgICAgICAgICByZXR1cm4gcmVzcC5wYXlsb2FkLnRoZW4oZnVuY3Rpb24ocCkgeyByZXR1cm4gUHJvbWlzZS5yZWplY3QocCk7IH0pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIF1cbn0pO1xuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgVGhlIEZPQU0gQXV0aG9ycy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICovXG5cbmZvYW0uQ0xBU1Moe1xuICBwYWNrYWdlOiAnZm9hbS5jb3JlJyxcbiAgbmFtZTogJ1N0dWJNZXRob2QnLFxuICBleHRlbmRzOiAnTWV0aG9kJyxcblxuICBwcm9wZXJ0aWVzOiBbXG4gICAgJ3JlcGx5UG9saWN5TmFtZScsXG4gICAgJ2JveFByb3BOYW1lJyxcbiAgICB7XG4gICAgICBuYW1lOiAnY29kZScsXG4gICAgICBmYWN0b3J5OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHJldHVybnMgICAgICAgICA9IGZvYW0uU3RyaW5nLmlzSW5zdGFuY2UodGhpcy5yZXR1cm5zKSA/XG4gICAgICAgICAgICB0aGlzLnJldHVybnMgOlxuICAgICAgICAgICAgdGhpcy5yZXR1cm5zICYmIHRoaXMucmV0dXJucy50eXBlTmFtZTtcbiAgICAgICAgdmFyIHJlcGx5UG9saWN5TmFtZSA9IHRoaXMucmVwbHlQb2xpY3lOYW1lO1xuICAgICAgICB2YXIgYm94UHJvcE5hbWUgICAgID0gdGhpcy5ib3hQcm9wTmFtZTtcbiAgICAgICAgdmFyIG5hbWUgICAgICAgICAgICA9IHRoaXMubmFtZTtcblxuICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdmFyIHJldHVybkJveCA9IHRoaXMuUlBDUmV0dXJuQm94LmNyZWF0ZSgpO1xuICAgICAgICAgIHZhciByZXBseUJveCA9IHRoaXMuUmVwbHlCb3guY3JlYXRlKHtkZWxlZ2F0ZTogcmV0dXJuQm94fSk7XG5cbiAgICAgICAgICB2YXIgcmV0ID0gcmV0dXJuQm94LnByb21pc2U7XG5cbiAgICAgICAgICAvLyBBdXRvbWF0aWNhbGx5IHdyYXAgUlBDcyB0aGF0IHJldHVybiBhIFwiUHJvbWlzZWRBYmNcIiBvciBzaW1pbGFyXG4gICAgICAgICAgLy8gVE9ETzogTW92ZSB0aGlzIGludG8gUlBDUmV0dXJuQm94ID9cbiAgICAgICAgICBpZiAoIHJldHVybnMgJiYgcmV0dXJucyAhPT0gJ1Byb21pc2UnICkge1xuICAgICAgICAgICAgcmV0ID0gdGhpcy5sb29rdXAocmV0dXJucykuY3JlYXRlKHsgZGVsZWdhdGU6IHJldCB9KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgbXNnID0gdGhpcy5NZXNzYWdlLmNyZWF0ZSh7XG4gICAgICAgICAgICBvYmplY3Q6IHRoaXMuUlBDTWVzc2FnZS5jcmVhdGUoe1xuICAgICAgICAgICAgICBuYW1lOiBuYW1lLFxuICAgICAgICAgICAgICBhcmdzOiBBcnJheS5mcm9tKGFyZ3VtZW50cylcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICBtc2cuYXR0cmlidXRlcy5yZXBseUJveCA9IHJlcGx5Qm94O1xuXG4gICAgICAgICAgdGhpc1tib3hQcm9wTmFtZV0uc2VuZChtc2cpO1xuXG4gICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XG4gIF1cbn0pO1xuXG5cbmZvYW0uQ0xBU1Moe1xuICBwYWNrYWdlOiAnZm9hbS5jb3JlJyxcbiAgbmFtZTogJ1N0dWJBY3Rpb24nLFxuICBleHRlbmRzOiAnQWN0aW9uJyxcblxuICBwcm9wZXJ0aWVzOiBbXG4gICAgJ3JlcGx5UG9saWN5TmFtZScsXG4gICAgJ2JveFByb3BOYW1lJyxcbiAgICB7XG4gICAgICBuYW1lOiAnc3R1Yk1ldGhvZCcsXG4gICAgICBmYWN0b3J5OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIGZvYW0uY29yZS5TdHViTWV0aG9kLmNyZWF0ZSh7XG4gICAgICAgICAgbmFtZTogdGhpcy5uYW1lLFxuICAgICAgICAgIHJlcGx5UG9saWN5TmFtZTogdGhpcy5yZXBseVBvbGljeU5hbWUsXG4gICAgICAgICAgYm94UHJvcE5hbWU6IHRoaXMuYm94UHJvcE5hbWVcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSxcbiAgICB7XG4gICAgICBuYW1lOiAnY29kZScsXG4gICAgICBmYWN0b3J5OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKGN0eCwgYWN0aW9uKSB7XG4gICAgICAgICAgYWN0aW9uLnN0dWJNZXRob2QuY29kZS5jYWxsKHRoaXMpO1xuICAgICAgICB9O1xuICAgICAgfVxuICAgIH1cbiAgXSxcbiAgbWV0aG9kczogW1xuICAgIGZ1bmN0aW9uIGluc3RhbGxJblByb3RvKHByb3RvKSB7XG4gICAgICBwcm90b1t0aGlzLm5hbWVdID0gdGhpcy5zdHViTWV0aG9kLmNvZGU7XG4gICAgfVxuICBdXG59KTtcblxuXG5mb2FtLkNMQVNTKHtcbiAgcGFja2FnZTogJ2ZvYW0uY29yZScsXG4gIG5hbWU6ICdTdHViJyxcbiAgZXh0ZW5kczogJ1Byb3BlcnR5JyxcblxuICBwcm9wZXJ0aWVzOiBbXG4gICAgJ29mJyxcbiAgICB7XG4gICAgICBuYW1lOiAncmVwbHlQb2xpY3lOYW1lJyxcbiAgICAgIGV4cHJlc3Npb246IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIG5hbWUgKyAnUmVwbHlQb2xpY3knXG4gICAgICB9XG4gICAgfSxcbiAgICB7XG4gICAgICBjbGFzczogJ1N0cmluZ0FycmF5JyxcbiAgICAgIG5hbWU6ICdtZXRob2RzJyxcbiAgICAgIGZhY3Rvcnk6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbnVsbDsgfVxuICAgIH0sXG4gICAge1xuICAgICAgbmFtZTogJ21ldGhvZHNfJyxcbiAgICAgIGV4cHJlc3Npb246IGZ1bmN0aW9uKG9mLCBuYW1lLCBtZXRob2RzLCByZXBseVBvbGljeU5hbWUpIHtcbiAgICAgICAgdmFyIGNscyA9IHRoaXMubG9va3VwKG9mKTtcblxuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgIG1ldGhvZHMgP1xuICAgICAgICAgICAgbWV0aG9kcy5tYXAoZnVuY3Rpb24obSkgeyByZXR1cm4gY2xzLmdldEF4aW9tQnlOYW1lKG0pOyB9KSA6XG4gICAgICAgICAgY2xzLmdldEF4aW9tc0J5Q2xhc3MoZm9hbS5jb3JlLk1ldGhvZCkuZmlsdGVyKGZ1bmN0aW9uIChtKSB7IHJldHVybiBjbHMuaGFzT3duQXhpb20obS5uYW1lKTsgfSkgKS5cbiAgICAgICAgICBtYXAoZnVuY3Rpb24obSkge1xuICAgICAgICAgICAgdmFyIHJldHVybnMgPSBmb2FtLlN0cmluZy5pc0luc3RhbmNlKG0ucmV0dXJucykgPyBtLnJldHVybnMgOlxuICAgICAgICAgICAgICAgIG0ucmV0dXJucyAmJiBtLnJldHVybnMudHlwZU5hbWU7XG4gICAgICAgICAgICBpZiAoIHJldHVybnMgJiYgcmV0dXJucyAhPT0gJ1Byb21pc2UnICkge1xuICAgICAgICAgICAgICB2YXIgaWQgPSByZXR1cm5zLnNwbGl0KCcuJyk7XG4gICAgICAgICAgICAgIGlkW2lkLmxlbmd0aCAtIDFdID0gJ1Byb21pc2VkJyArIGlkW2lkLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgICByZXR1cm5zID0gaWQuam9pbignLicpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gZm9hbS5jb3JlLlN0dWJNZXRob2QuY3JlYXRlKHtcbiAgICAgICAgICAgICAgbmFtZTogbS5uYW1lLFxuICAgICAgICAgICAgICByZXBseVBvbGljeU5hbWU6IHJlcGx5UG9saWN5TmFtZSxcbiAgICAgICAgICAgICAgYm94UHJvcE5hbWU6IG5hbWUsXG4gICAgICAgICAgICAgIHN3aWZ0UmV0dXJuczogbS5zd2lmdFJldHVybnMsXG4gICAgICAgICAgICAgIGFyZ3M6IG0uYXJncyxcbiAgICAgICAgICAgICAgcmV0dXJuczogcmV0dXJuc1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSxcbiAgICB7XG4gICAgICBjbGFzczogJ1N0cmluZ0FycmF5JyxcbiAgICAgIG5hbWU6ICdub3RpZmljYXRpb25zJyxcbiAgICAgIGZhY3Rvcnk6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbnVsbDsgfVxuICAgIH0sXG4gICAge1xuICAgICAgbmFtZTogJ25vdGlmaWNhdGlvbnNfJyxcbiAgICAgIGV4cHJlc3Npb246IGZ1bmN0aW9uKG9mLCBuYW1lLCBub3RpZmljYXRpb25zKSB7XG4gICAgICAgIHZhciBjbHMgPSB0aGlzLmxvb2t1cChvZik7XG5cbiAgICAgICAgcmV0dXJuIG5vdGlmaWNhdGlvbnMgJiYgbm90aWZpY2F0aW9ucy5cbiAgICAgICAgICBtYXAoZnVuY3Rpb24obSkgeyByZXR1cm4gY2xzLmdldEF4aW9tQnlOYW1lKG0pOyB9KS5cbiAgICAgICAgICBtYXAoZnVuY3Rpb24obSkge1xuICAgICAgICAgICAgcmV0dXJuIGZvYW0uY29yZS5TdHViTm90aWZpY2F0aW9uLmNyZWF0ZSh7XG4gICAgICAgICAgICAgIG5hbWU6IG0ubmFtZSxcbiAgICAgICAgICAgICAgYm94UHJvcE5hbWU6IG5hbWUsXG4gICAgICAgICAgICAgIGFyZ3M6IG0uYXJnc1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSxcbiAgICB7XG4gICAgICBjbGFzczogJ1N0cmluZ0FycmF5JyxcbiAgICAgIG5hbWU6ICdhY3Rpb25zJyxcbiAgICAgIGZhY3Rvcnk6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbnVsbDsgfVxuICAgIH0sXG4gICAge1xuICAgICAgbmFtZTogJ2FjdGlvbnNfJyxcbiAgICAgIGV4cHJlc3Npb246IGZ1bmN0aW9uKG9mLCBuYW1lLCBhY3Rpb25zLCByZXBseVBvbGljeU5hbWUpIHtcbiAgICAgICAgdmFyIGNscyA9IHRoaXMubG9va3VwKG9mKTtcblxuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgIGFjdGlvbnMgPyBhY3Rpb25zLm1hcChmdW5jdGlvbihhKSB7IHJldHVybiBjbHMuZ2V0QXhpb21CeU5hbWUoYSk7IH0pIDpcbiAgICAgICAgICBjbHMuZ2V0QXhpb21zQnlDbGFzcyhmb2FtLmNvcmUuQWN0aW9uKS5maWx0ZXIoZnVuY3Rpb24obSkgeyByZXR1cm4gY2xzLmhhc093bkF4aW9tKG0ubmFtZSk7IH0pICkuXG4gICAgICAgICAgbWFwKGZ1bmN0aW9uKG0pIHtcbiAgICAgICAgICAgIHJldHVybiBmb2FtLmNvcmUuU3R1YkFjdGlvbi5jcmVhdGUoe1xuICAgICAgICAgICAgICBuYW1lOiBtLm5hbWUsXG4gICAgICAgICAgICAgIGlzRW5hYmxlZDogbS5pc0VuYWJsZWQsXG4gICAgICAgICAgICAgIHJlcGx5UG9saWN5TmFtZTogcmVwbHlQb2xpY3lOYW1lLFxuICAgICAgICAgICAgICBib3hQcm9wTmFtZTogbmFtZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSxcbiAgICBbJ2phdmFUeXBlJywgICAgICdmb2FtLmJveC5Cb3gnXSxcbiAgICBbJ2phdmFJbmZvVHlwZScsICdmb2FtLmNvcmUuQWJzdHJhY3RGT2JqZWN0UHJvcGVydHlJbmZvJ11cbiAgXSxcblxuICBtZXRob2RzOiBbXG4gICAgZnVuY3Rpb24gaW5zdGFsbEluQ2xhc3MoY2xzKSB7XG4gICAgICB2YXIgbW9kZWwgPSB0aGlzLmxvb2t1cCh0aGlzLm9mKTtcbiAgICAgIHZhciBwcm9wTmFtZSA9IHRoaXMubmFtZTtcblxuICAgICAgY2xzLmluc3RhbGxBeGlvbShmb2FtLmNvcmUuT2JqZWN0LmNyZWF0ZSh7XG4gICAgICAgIG5hbWU6IHRoaXMucmVwbHlQb2xpY3lOYW1lLFxuICAgICAgICBqYXZhVHlwZTogJ2ZvYW0uYm94LkJveFNlcnZpY2UnLFxuICAgICAgICBoaWRkZW46IHRydWVcbiAgICAgIH0pKTtcblxuICAgICAgY2xzLmluc3RhbGxBeGlvbXModGhpcy5tZXRob2RzXyk7XG4gICAgICBjbHMuaW5zdGFsbEF4aW9tcyh0aGlzLm5vdGlmaWNhdGlvbnNfKTtcbiAgICAgIGNscy5pbnN0YWxsQXhpb21zKHRoaXMuYWN0aW9uc18pO1xuXG4gICAgICBjbHMuaW5zdGFsbEF4aW9tcyhbXG4gICAgICAgICdmb2FtLmJveC5SUENSZXR1cm5Cb3gnLFxuICAgICAgICAnZm9hbS5ib3guUmVwbHlCb3gnLFxuICAgICAgICAnZm9hbS5ib3guUlBDTWVzc2FnZScsXG4gICAgICAgICdmb2FtLmJveC5NZXNzYWdlJ1xuICAgICAgXS5tYXAoZnVuY3Rpb24ocykge1xuICAgICAgICB2YXIgcGF0aCA9IHMuc3BsaXQoJy4nKTtcbiAgICAgICAgcmV0dXJuIGZvYW0uY29yZS5SZXF1aXJlcy5jcmVhdGUoe1xuICAgICAgICAgIHBhdGg6IHMsXG4gICAgICAgICAgbmFtZTogcGF0aFtwYXRoLmxlbmd0aCAtIDFdXG4gICAgICAgIH0pO1xuICAgICAgfSkpO1xuXG4gICAgICBjbHMuaW5zdGFsbEF4aW9tKGZvYW0uY29yZS5JbXBvcnQuY3JlYXRlKHtcbiAgICAgICAga2V5OiAncmVnaXN0cnknLFxuICAgICAgICBuYW1lOiAncmVnaXN0cnknLFxuICAgICAgICBqYXZhVHlwZTogJ2ZvYW0uYm94LkJveFJlZ2lzdHJ5JyxcbiAgICAgIH0pKTtcbiAgICB9XG4gIF1cbn0pO1xuXG5cbmZvYW0uQ0xBU1Moe1xuICBwYWNrYWdlOiAnZm9hbS5jb3JlJyxcbiAgbmFtZTogJ1N0dWJDbGFzcycsXG5cbiAgYXhpb21zOiBbXG4gICAgZm9hbS5wYXR0ZXJuLk11bHRpdG9uLmNyZWF0ZSh7IHByb3BlcnR5OiAnb2YnIH0pXG4gIF0sXG5cbiAgcmVxdWlyZXM6IFtcbiAgICAnZm9hbS5jb3JlLk1vZGVsJyxcbiAgXSxcblxuICBwcm9wZXJ0aWVzOiBbXG4gICAge1xuICAgICAgY2xhc3M6ICdDbGFzcycsXG4gICAgICBuYW1lOiAnb2YnLFxuICAgICAgcmVxdWlyZWQ6IHRydWVcbiAgICB9LFxuICAgIHtcbiAgICAgIGNsYXNzOiAnU3RyaW5nJyxcbiAgICAgIG5hbWU6ICdwYWNrYWdlJyxcbiAgICAgIGZhY3Rvcnk6IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcy5vZi5wYWNrYWdlOyB9XG4gICAgfSxcbiAgICB7XG4gICAgICBjbGFzczogJ1N0cmluZycsXG4gICAgICBuYW1lOiAnbmFtZScsXG4gICAgICBmYWN0b3J5OiBmdW5jdGlvbigpIHsgcmV0dXJuIGAke3RoaXMub2YubmFtZX1TdHViYDsgfVxuICAgIH0sXG4gICAge1xuICAgICAgY2xhc3M6ICdTdHJpbmcnLFxuICAgICAgbmFtZTogJ2lkJyxcbiAgICAgIGZhY3Rvcnk6IGZ1bmN0aW9uKCkgeyByZXR1cm4gYCR7dGhpcy5wYWNrYWdlfS4ke3RoaXMubmFtZX1gOyB9XG4gICAgfSxcbiAgICB7XG4gICAgICBjbGFzczogJ0ZPYmplY3RQcm9wZXJ0eScsXG4gICAgICBvZjogJ01vZGVsJyxcbiAgICAgIG5hbWU6ICdzdHViTW9kZWwnLFxuICAgICAgZmFjdG9yeTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLk1vZGVsLmNyZWF0ZSh7XG4gICAgICAgICAgcGFja2FnZTogdGhpcy5wYWNrYWdlLFxuICAgICAgICAgIG5hbWU6IHRoaXMubmFtZSxcbiAgICAgICAgICBpbXBsZW1lbnRzOiBbdGhpcy5vZi5pZF0sXG5cbiAgICAgICAgICBwcm9wZXJ0aWVzOiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIGNsYXNzOiAnU3R1YicsXG4gICAgICAgICAgICAgIG9mOiB0aGlzLm9mLmlkLFxuICAgICAgICAgICAgICBuYW1lOiAnZGVsZWdhdGUnXG4gICAgICAgICAgICB9XG4gICAgICAgICAgXVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHtcbiAgICAgIG5hbWU6ICdzdHViQ2xzJyxcbiAgICAgIGZhY3Rvcnk6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5idWlsZENsYXNzXygpO1xuICAgICAgfVxuICAgIH1cbiAgXSxcblxuICBtZXRob2RzOiBbXG4gICAgZnVuY3Rpb24gaW5pdCgpIHtcbiAgICAgIHRoaXMudmFsaWRhdGUoKTtcbiAgICAgIHRoaXMuU1VQRVIoKTtcbiAgICB9LFxuICAgIGZ1bmN0aW9uIGJ1aWxkQ2xhc3NfKCkge1xuICAgICAgdGhpcy5zdHViTW9kZWwudmFsaWRhdGUoKTtcbiAgICAgIHZhciBjbHMgPSB0aGlzLnN0dWJNb2RlbC5idWlsZENsYXNzKCk7XG4gICAgICBjbHMudmFsaWRhdGUoKTtcbiAgICAgIHRoaXMuX19zdWJDb250ZXh0X18ucmVnaXN0ZXIoY2xzKTtcbiAgICAgIGZvYW0ucGFja2FnZS5yZWdpc3RlckNsYXNzKGNscyk7XG5cbiAgICAgIHJldHVybiB0aGlzLnN0dWJNb2RlbC5idWlsZENsYXNzKCk7XG4gICAgfVxuICBdXG59KTtcblxuZm9hbS5DTEFTUyh7XG4gIHBhY2thZ2U6ICdmb2FtLmNvcmUnLFxuICBuYW1lOiAnU3R1Yk5vdGlmaWNhdGlvbicsXG4gIGRvY3VtZW50YXRpb246IFwiU2ltaWxhciB0byBhIFN0dWJNZXRob2QgYnV0IGRvZXNuJ3QgcmVnaXN0ZXIgYSByZXBseSBib3guICBVc2VmdWwgd2hlbiB5b3UgZG9uJ3QgY2FyZSB3aGV0aGVyIHRoZSBtZXRob2QgZXZhbHVhdGVzIHN1Y2Nlc3NmdWxseSBvbiB0aGUgdGFyZ2V0IGJ1dCBqdXN0IHdhbnQgdG8gc2VuZCBhIG5vdGlmaWNhdGlvbiB0byB0aGUgdGFyZ2V0LlwiLFxuICBleHRlbmRzOiAnTWV0aG9kJyxcblxuICBwcm9wZXJ0aWVzOiBbXG4gICAgJ2JveFByb3BOYW1lJyxcbiAgICB7XG4gICAgICBuYW1lOiAnY29kZScsXG4gICAgICBmYWN0b3J5OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGJveFByb3BOYW1lID0gdGhpcy5ib3hQcm9wTmFtZTtcbiAgICAgICAgdmFyIG5hbWUgICAgICAgID0gdGhpcy5uYW1lO1xuXG4gICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgICB2YXIgbXNnID0gdGhpcy5NZXNzYWdlLmNyZWF0ZSh7XG4gICAgICAgICAgICBvYmplY3Q6IHRoaXMuUlBDTWVzc2FnZS5jcmVhdGUoe1xuICAgICAgICAgICAgICBuYW1lOiBuYW1lLFxuICAgICAgICAgICAgICBhcmdzOiBBcnJheS5mcm9tKGFyZ3VtZW50cylcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICB0aGlzW2JveFByb3BOYW1lXS5zZW5kKG1zZyk7XG5cbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuICBdXG59KTtcblxuZm9hbS5DTEFTUyh7XG4gIHBhY2thZ2U6ICdmb2FtLmNvcmUnLFxuICBuYW1lOiAnU3R1YkZhY3RvcnknLFxuXG4gIHJlcXVpcmVzOiBbICdmb2FtLmNvcmUuU3R1YkNsYXNzJyBdLFxuXG4gIG1ldGhvZHM6IFtcbiAgICBmdW5jdGlvbiBnZXQoY2xzKSB7XG4gICAgICByZXR1cm4gdGhpcy5TdHViQ2xhc3MuY3JlYXRlKHsgb2Y6IGNscyB9KS5zdHViQ2xzO1xuICAgIH1cbiAgXVxufSk7XG5cblxuZm9hbS5DTEFTUyh7XG4gIHBhY2thZ2U6ICdmb2FtLmNvcmUnLFxuICBuYW1lOiAnU3R1YkZhY3RvcnlTaW5nbGV0b24nLFxuICBleHRlbmRzOiAnZm9hbS5jb3JlLlN0dWJGYWN0b3J5JyxcblxuICBheGlvbXM6IFsgZm9hbS5wYXR0ZXJuLlNpbmdsZXRvbi5jcmVhdGUoKSBdLFxufSk7XG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBUaGUgRk9BTSBBdXRob3JzLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5mb2FtLklOVEVSRkFDRSh7XG4gIHBhY2thZ2U6ICdmb2FtLmJveCcsXG4gIG5hbWU6ICdCb3gnLFxuXG4gIG1ldGhvZHM6IFtcbiAgICB7XG4gICAgICBuYW1lOiAnc2VuZCcsXG4gICAgICBhcmdzOiBbXG4gICAgICAgIHtcbiAgICAgICAgICBuYW1lOiAnbXNnJyxcbiAgICAgICAgICBzd2lmdFR5cGU6ICdNZXNzYWdlJ1xuICAgICAgICB9XG4gICAgICBdLFxuICAgICAgc3dpZnRUaHJvd3M6IHRydWUsXG4gICAgfSxcbiAgXVxufSk7XG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxOCBUaGUgRk9BTSBBdXRob3JzLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICovXG5cbmZvYW0uQ0xBU1Moe1xuICBwYWNrYWdlOiAnZm9hbS5ib3gnLFxuICBuYW1lOiAnQW5vbnltb3VzQm94JyxcbiAgaW1wbGVtZW50czogWydmb2FtLmJveC5Cb3gnXSxcbiAgcHJvcGVydGllczogW1xuICAgIHtcbiAgICAgIGNsYXNzOiAnRnVuY3Rpb24nLFxuICAgICAgbmFtZTogJ2YnXG4gICAgfVxuICBdLFxuICBtZXRob2RzOiBbXG4gICAgZnVuY3Rpb24gc2VuZChtKSB7XG4gICAgICB0aGlzLmYobSk7XG4gICAgfVxuICBdXG59KTtcbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IFRoZSBGT0FNIEF1dGhvcnMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqL1xuXG5mb2FtLkNMQVNTKHtcbiAgcGFja2FnZTogJ2ZvYW0uYm94JyxcbiAgbmFtZTogJ1JlbW90ZUV4Y2VwdGlvbicsXG4gIGltcGxlbWVudHM6IFsnZm9hbS5jb3JlLkV4Y2VwdGlvbiddLFxuICBwcm9wZXJ0aWVzOiBbXG4gICAge1xuICAgICAgY2xhc3M6ICdTdHJpbmcnLFxuICAgICAgbmFtZTogJ2lkJ1xuICAgIH0sXG4gICAge1xuICAgICAgY2xhc3M6ICdTdHJpbmcnLFxuICAgICAgbmFtZTogJ21lc3NhZ2UnXG4gICAgfVxuICBdLFxuXG4gIG1ldGhvZHM6IFtcbiAgICB7XG4gICAgICBuYW1lOiAndG9TdHJpbmcnLFxuICAgICAgamF2YVJldHVybnM6ICdTdHJpbmcnLFxuICAgICAgamF2YUNvZGU6ICdyZXR1cm4gZ2V0TWVzc2FnZSgpOydcbiAgICB9XG4gIF1cbn0pO1xuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgVGhlIEZPQU0gQXV0aG9ycy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuZm9hbS5JTlRFUkZBQ0Uoe1xuICBwYWNrYWdlOiAnZm9hbS5ib3gnLFxuICBuYW1lOiAnU2tlbGV0b24nLFxuICBleHRlbmRzOiAnZm9hbS5ib3guQm94JyxcbiAgZG9jdW1lbnRhdGlvbjogJ1NrZWxldG9uIG1hcmtlciBpbnRlcmZhY2UuJyxcblxuICBtZXRob2RzOiBbXG4gICAge1xuICAgICAgbmFtZTogJ3NldERlbGVnYXRlT2JqZWN0JyxcbiAgICAgIGFyZ3M6IFtcbiAgICAgICAge1xuICAgICAgICAgIG5hbWU6ICdvYmonLFxuICAgICAgICAgIGphdmFUeXBlOiAnT2JqZWN0J1xuICAgICAgICB9XG4gICAgICBdXG4gICAgfVxuICBdXG59KTtcbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IFRoZSBGT0FNIEF1dGhvcnMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmZvYW0uQ0xBU1Moe1xuICBwYWNrYWdlOiAnZm9hbS5ib3gnLFxuICBuYW1lOiAnUHJvbWlzZWRCb3gnLFxuICBpbXBsZW1lbnRzOiBbICdmb2FtLmJveC5Cb3gnIF0sXG5cbiAgcHJvcGVydGllczogW1xuICAgIHtcbiAgICAgIGNsYXNzOiAnUHJvbWlzZWQnLFxuICAgICAgb2Y6ICdmb2FtLmJveC5Cb3gnLFxuICAgICAgdHJhbnNpZW50OiB0cnVlLFxuICAgICAgbmFtZTogJ2RlbGVnYXRlJ1xuICAgIH1cbiAgXVxufSk7XG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBUaGUgRk9BTSBBdXRob3JzLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5mb2FtLkNMQVNTKHtcbiAgcGFja2FnZTogJ2ZvYW0uYm94JyxcbiAgbmFtZTogJ1Byb3h5Qm94JyxcbiAgaW1wbGVtZW50czogWyAnZm9hbS5ib3guQm94JyBdLFxuXG4gIHByb3BlcnRpZXM6IFtcbiAgICB7XG4gICAgICBjbGFzczogJ1Byb3h5JyxcbiAgICAgIG9mOiAnZm9hbS5ib3guQm94JyxcbiAgICAgIG5hbWU6ICdkZWxlZ2F0ZSdcbiAgICB9XG4gIF1cbn0pO1xuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgVGhlIEZPQU0gQXV0aG9ycy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuZm9hbS5DTEFTUyh7XG4gIHBhY2thZ2U6ICdmb2FtLmJveCcsXG4gIG5hbWU6ICdNZXNzYWdlJyxcblxuICBwcm9wZXJ0aWVzOiBbXG4gICAge1xuICAgICAgY2xhc3M6ICdNYXAnLFxuICAgICAgbmFtZTogJ2F0dHJpYnV0ZXMnLFxuICAgICAgamF2YUZhY3Rvcnk6ICdyZXR1cm4gbmV3IGphdmEudXRpbC5IYXNoTWFwKCk7J1xuICAgIH0sXG4gICAge1xuICAgICAgY2xhc3M6ICdPYmplY3QnLFxuICAgICAgbmFtZTogJ29iamVjdCdcbiAgICB9LFxuICAgIHtcbiAgICAgIGNsYXNzOiAnTWFwJyxcbiAgICAgIHRyYW5zaWVudDogdHJ1ZSxcbiAgICAgIG5hbWU6ICdsb2NhbEF0dHJpYnV0ZXMnLFxuICAgICAgamF2YUZhY3Rvcnk6ICdyZXR1cm4gbmV3IGphdmEudXRpbC5IYXNoTWFwKCk7J1xuICAgIH1cbiAgXSxcblxuICBtZXRob2RzOiBbXG4gICAge1xuICAgICAgbmFtZTogJ3JlcGx5V2l0aEV4Y2VwdGlvbicsXG4gICAgICBqYXZhUmV0dXJuczogJ3ZvaWQnLFxuICAgICAgYXJnczogW1xuICAgICAgICB7IG5hbWU6ICd0JywgamF2YVR5cGU6ICdUaHJvd2FibGUnIH1cbiAgICAgIF0sXG4gICAgICBqYXZhQ29kZTogYFxuICAgICAgICBCb3ggcmVwbHlCb3ggPSAoQm94KSBnZXRBdHRyaWJ1dGVzKCkuZ2V0KFwicmVwbHlCb3hcIik7XG5cbiAgICAgICAgaWYgKCByZXBseUJveCA9PSBudWxsICkgcmV0dXJuO1xuXG4gICAgICAgIFJlbW90ZUV4Y2VwdGlvbiB3cmFwcGVyID0gbmV3IFJlbW90ZUV4Y2VwdGlvbigpO1xuICAgICAgICB3cmFwcGVyLnNldElkKHQuZ2V0Q2xhc3MoKS5nZXROYW1lKCkpO1xuICAgICAgICB3cmFwcGVyLnNldE1lc3NhZ2UodC5nZXRNZXNzYWdlKCkpO1xuXG4gICAgICAgIFJQQ0Vycm9yTWVzc2FnZSByZXBseSA9IG5ldyBSUENFcnJvck1lc3NhZ2UoKTtcbiAgICAgICAgcmVwbHkuc2V0RGF0YSh3cmFwcGVyKTtcblxuICAgICAgICBNZXNzYWdlIHJlcGx5TWVzc2FnZSA9IG5ldyBNZXNzYWdlKCk7XG4gICAgICAgIHJlcGx5TWVzc2FnZS5zZXRPYmplY3QocmVwbHkpO1xuXG4gICAgICAgIHJlcGx5Qm94LnNlbmQocmVwbHlNZXNzYWdlKTtcbiAgICAgIGBcbiAgICB9XG4gIF1cbn0pO1xuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgVGhlIEZPQU0gQXV0aG9ycy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuZm9hbS5DTEFTUyh7XG4gIHBhY2thZ2U6ICdmb2FtLmJveCcsXG4gIG5hbWU6ICdTdWJCb3hNZXNzYWdlJyxcbiAgZXh0ZW5kczogJ2ZvYW0uYm94Lk1lc3NhZ2UnLFxuICBwcm9wZXJ0aWVzOiBbXG4gICAge1xuICAgICAgY2xhc3M6ICdTdHJpbmcnLFxuICAgICAgbmFtZTogJ25hbWUnXG4gICAgfVxuICBdXG59KTtcbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IFRoZSBGT0FNIEF1dGhvcnMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmZvYW0uQ0xBU1Moe1xuICBwYWNrYWdlOiAnZm9hbS5ib3gnLFxuICBuYW1lOiAnSGVsbG9NZXNzYWdlJ1xufSk7XG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBUaGUgRk9BTSBBdXRob3JzLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5mb2FtLkNMQVNTKHtcbiAgcGFja2FnZTogJ2ZvYW0uYm94JyxcbiAgbmFtZTogJ1RpbWVvdXRFeGNlcHRpb24nLFxuICBpbXBsZW1lbnRzOiBbJ2ZvYW0uY29yZS5FeGNlcHRpb24nXVxufSk7XG5cbmZvYW0uQ0xBU1Moe1xuICBwYWNrYWdlOiAnZm9hbS5ib3gnLFxuICBuYW1lOiAnVGltZW91dEJveCcsXG4gIC8vICBpbXBsZW1lbnRzOiBbJ2ZvYW0uYm94LkJveCddLFxuICBleHRlbmRzOiAnZm9hbS5ib3guUHJveHlCb3gnLFxuICByZXF1aXJlczogW1xuICAgICdmb2FtLmJveC5UaW1lb3V0RXhjZXB0aW9uJyxcbiAgICAnZm9hbS5ib3guTWVzc2FnZSdcbiAgXSxcbiAgcHJvcGVydGllczogW1xuICAgIHtcbiAgICAgIGNsYXNzOiAnSW50JyxcbiAgICAgIG5hbWU6ICd0aW1lb3V0JyxcbiAgICAgIHZhbHVlOiA1MDAwXG4gICAgfVxuICBdLFxuICBtZXRob2RzOiBbXG4gICAgZnVuY3Rpb24gc2VuZChtc2cpIHtcbiAgICAgIHZhciByZXBseUJveCA9IG1zZy5hdHRyaWJ1dGVzLnJlcGx5Qm94O1xuXG4gICAgICBpZiAoICEgcmVwbHlCb3ggKSB7XG4gICAgICAgIHRoaXMuZGVsZWdhdGUuc2VuZChtc2cpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciB0b29MYXRlID0gZmFsc2U7XG4gICAgICB2YXIgdGltZXIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICB0b29MYXRlID0gdHJ1ZTtcbiAgICAgICAgcmVwbHlCb3guc2VuZCh0aGlzLk1lc3NhZ2UuY3JlYXRlKHtcbiAgICAgICAgICBvYmplY3Q6IHRoaXMuVGltZW91dEV4Y2VwdGlvbi5jcmVhdGUoKVxuICAgICAgICB9KSk7XG4gICAgICB9LmJpbmQodGhpcyksIHRoaXMudGltZW91dCk7XG5cbiAgICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgICAgbXNnLmF0dHJpYnV0ZXMucmVwbHlCb3ggPSB7XG4gICAgICAgIHNlbmQ6IGZ1bmN0aW9uKG1zZykge1xuICAgICAgICAgIGlmICggISB0b29MYXRlICkge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVyKTtcbiAgICAgICAgICAgIHJlcGx5Qm94LnNlbmQobXNnKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBUT0RPOiBJcyBpdCB3aXNlIHRvIGluY3JlYXNlIHRoZSB0aW1lb3V0PyAgU2VlbXNcbiAgICAgICAgICAvLyByZWFzb25hYmxlLCBpZiBvdXIgdGltZW91dCB2YWx1ZSBpcyB0b28gY29uc2VydmF0aXZlIGFuZFxuICAgICAgICAgIC8vIHRoZSBzZXJ2ZXIgaXMganVzdCBzbG93IHdlJ3JlIGJldHRlciB0byB3YWl0IGxvbmdlclxuICAgICAgICAgIC8vIHJhdGhlciB0aGFuIGhpdCBpdCB3aXRoIGFkZGl0aW9uYWwgcmVxdWVzdHMgd2hpbGUgaXRzXG4gICAgICAgICAgLy8gc3RpbGwgcHJvY2Vzc2luZyBvdXIgb2xkIG9uZXMuXG4gICAgICAgICAgc2VsZi50aW1lb3V0ICo9IDI7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIHRoaXMuZGVsZWdhdGUuc2VuZChtc2cpO1xuICAgIH1cbiAgXVxufSk7XG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBUaGUgRk9BTSBBdXRob3JzLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5mb2FtLkNMQVNTKHtcbiAgcGFja2FnZTogJ2ZvYW0uYm94JyxcbiAgbmFtZTogJ0JhY2tvZmZCb3gnLFxuICBleHRlbmRzOiAnZm9hbS5ib3guUHJveHlCb3gnLFxuICBpbXBvcnRzOiBbXG4gICAgJ3NldFRpbWVvdXQnXG4gIF0sXG4gIHByb3BlcnRpZXM6IFtcbiAgICB7XG4gICAgICBjbGFzczogJ0ludCcsXG4gICAgICBuYW1lOiAnZGVsYXknLFxuICAgICAgcHJlU2V0OiBmdW5jdGlvbihfLCBhKSB7XG4gICAgICAgIHJldHVybiBhIDwgdGhpcy5tYXhEZWxheSA/IGEgOiB0aGlzLm1heERlbGF5O1xuICAgICAgfSxcbiAgICAgIHZhbHVlOiAxXG4gICAgfSxcbiAgICB7XG4gICAgICBjbGFzczogJ0ludCcsXG4gICAgICBuYW1lOiAnbWF4RGVsYXknLFxuICAgICAgdmFsdWU6IDIwMDAwXG4gICAgfVxuICBdLFxuICBtZXRob2RzOiBbXG4gICAgZnVuY3Rpb24gc2VuZChtKSB7XG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICB0aGlzLnNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgIHNlbGYuZGVsZWdhdGUuc2VuZChtKTtcbiAgICAgIH0sIHRoaXMuZGVsYXkpO1xuXG4gICAgICB0aGlzLmRlbGF5ICo9IDI7XG4gICAgfVxuICBdXG59KTtcblxuZm9hbS5DTEFTUyh7XG4gIHBhY2thZ2U6ICdmb2FtLmJveCcsXG4gIG5hbWU6ICdSZXRyeVJlcGx5Qm94JyxcbiAgZXh0ZW5kczogJ2ZvYW0uYm94LlByb3h5Qm94JyxcbiAgcmVxdWlyZXM6IFtcbiAgICAnZm9hbS5jb3JlLkV4Y2VwdGlvbidcbiAgXSxcbiAgcHJvcGVydGllczogW1xuICAgIHtcbiAgICAgIG5hbWU6ICdhdHRlbXB0JyxcbiAgICAgIHZhbHVlOiAwXG4gICAgfSxcbiAgICB7XG4gICAgICBuYW1lOiAnbWF4QXR0ZW1wdHMnXG4gICAgfSxcbiAgICB7XG4gICAgICBuYW1lOiAnbWVzc2FnZSdcbiAgICB9LFxuICAgIHtcbiAgICAgIG5hbWU6ICdkZXN0aW5hdGlvbidcbiAgICB9XG4gIF0sXG4gIG1ldGhvZHM6IFtcbiAgICB7XG4gICAgICBuYW1lOiAnc2VuZCcsXG4gICAgICBjb2RlOiBmdW5jdGlvbiBzZW5kKG1zZykge1xuICAgICAgICBpZiAoIHRoaXMuRXhjZXB0aW9uLmlzSW5zdGFuY2UobXNnLm9iamVjdCkgJiZcbiAgICAgICAgICAgICAoIHRoaXMubWF4QXR0ZW1wdHMgPT0gLTEgfHwgdGhpcy5hdHRlbXB0IDwgdGhpcy5tYXhBdHRlbXB0cyApICkge1xuICAgICAgICAgIHRoaXMuYXR0ZW1wdCsrO1xuICAgICAgICAgIHRoaXMuZGVzdGluYXRpb24uc2VuZCh0aGlzLm1lc3NhZ2UpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuZGVsZWdhdGUgJiYgdGhpcy5kZWxlZ2F0ZS5zZW5kKG1zZyk7XG4gICAgICB9XG4gICAgfVxuICBdXG59KTtcblxuZm9hbS5DTEFTUyh7XG4gIHBhY2thZ2U6ICdmb2FtLmJveCcsXG4gIG5hbWU6ICdSZXRyeUJveCcsXG4gIGV4dGVuZHM6ICdmb2FtLmJveC5Qcm94eUJveCcsXG5cbiAgcmVxdWlyZXM6IFtcbiAgICAnZm9hbS5ib3guQmFja29mZkJveCcsXG4gICAgJ2ZvYW0uYm94LlJldHJ5UmVwbHlCb3gnXG4gIF0sXG5cbiAgcHJvcGVydGllczogW1xuICAgICdhdHRlbXB0cycsXG4gICAge1xuICAgICAgbmFtZTogJ21heEF0dGVtcHRzJyxcbiAgICAgIGRvY3VtZW50YXRpb246ICdTZXQgdG8gLTEgdG8gaW5maW5pdGVseSByZXRyeS4nLFxuICAgICAgdmFsdWU6IDNcbiAgICB9XG4gIF0sXG5cbiAgbWV0aG9kczogW1xuICAgIGZ1bmN0aW9uIHNlbmQobXNnKSB7XG4gICAgICB2YXIgcmVwbHlCb3ggPSBtc2cuYXR0cmlidXRlcy5yZXBseUJveDtcblxuICAgICAgaWYgKCByZXBseUJveCApIHtcbiAgICAgICAgdmFyIGNsb25lID0gbXNnLmNsc18uY3JlYXRlKG1zZyk7XG5cbiAgICAgICAgbXNnLmF0dHJpYnV0ZXMucmVwbHlCb3ggPSB0aGlzLlJldHJ5UmVwbHlCb3guY3JlYXRlKHtcbiAgICAgICAgICBkZWxlZ2F0ZTogcmVwbHlCb3gsXG4gICAgICAgICAgbWF4QXR0ZW1wdHM6IHRoaXMubWF4QXR0ZW1wdHMsXG4gICAgICAgICAgbWVzc2FnZTogY2xvbmUsXG4gICAgICAgICAgZGVzdGluYXRpb246IHRoaXMuQmFja29mZkJveC5jcmVhdGUoe1xuICAgICAgICAgICAgZGVsZWdhdGU6IHRoaXMuZGVsZWdhdGVcbiAgICAgICAgICB9KVxuICAgICAgICB9KTtcblxuICAgICAgICBjbG9uZS5hdHRyaWJ1dGVzID0ge307XG4gICAgICAgIGZvciAoIHZhciBrZXkgaW4gbXNnLmF0dHJpYnV0ZXMgKSB7XG4gICAgICAgICAgY2xvbmUuYXR0cmlidXRlc1trZXldID0gbXNnLmF0dHJpYnV0ZXNba2V5XTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB0aGlzLmRlbGVnYXRlLnNlbmQobXNnKTtcbiAgICB9XG4gIF1cbn0pO1xuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgVGhlIEZPQU0gQXV0aG9ycy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuZm9hbS5DTEFTUyh7XG4gIHBhY2thZ2U6ICdmb2FtLmJveCcsXG4gIG5hbWU6ICdTdWJCb3gnLFxuICBleHRlbmRzOiAnZm9hbS5ib3guUHJveHlCb3gnLFxuXG4gIHJlcXVpcmVzOiBbXG4gICAgJ2ZvYW0uYm94LlN1YkJveE1lc3NhZ2UnXG4gIF0sXG5cbiAgcHJvcGVydGllczogW1xuICAgIHtcbiAgICAgIGNsYXNzOiAnU3RyaW5nJyxcbiAgICAgIG5hbWU6ICduYW1lJ1xuICAgIH1cbiAgXSxcblxuICBtZXRob2RzOiBbXG4gICAge1xuICAgICAgbmFtZTogJ3NlbmQnLFxuICAgICAgY29kZTogZnVuY3Rpb24obXNnKSB7XG4gICAgICAgIG1zZy5vYmplY3QgPSB0aGlzLlN1YkJveE1lc3NhZ2UuY3JlYXRlKHtcbiAgICAgICAgICBuYW1lOiB0aGlzLm5hbWUsXG4gICAgICAgICAgb2JqZWN0OiBtc2cub2JqZWN0XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmRlbGVnYXRlLnNlbmQobXNnKTtcbiAgICAgIH0sXG4gICAgICBzd2lmdENvZGU6IGZ1bmN0aW9uKCkgey8qXG5tc2cub2JqZWN0ID0gU3ViQm94TWVzc2FnZV9jcmVhdGUoW1xuICBcIm5hbWVcIjogbmFtZSxcbiAgXCJvYmplY3RcIjogbXNnLm9iamVjdFxuXSlcbnRyeSBkZWxlZ2F0ZS5zZW5kKG1zZyk7XG4gICAgICAqL31cbiAgICB9XG4gIF1cbn0pO1xuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgVGhlIEZPQU0gQXV0aG9ycy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuZm9hbS5DTEFTUyh7XG4gIHBhY2thZ2U6ICdmb2FtLmJveCcsXG4gIG5hbWU6ICdOYW1lQWxyZWFkeVJlZ2lzdGVyZWRFeGNlcHRpb24nLFxuXG4gIHByb3BlcnRpZXM6IFtcbiAgICB7XG4gICAgICBjbGFzczogJ1N0cmluZycsXG4gICAgICBuYW1lOiAnbmFtZSdcbiAgICB9XG4gIF1cbn0pO1xuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgVGhlIEZPQU0gQXV0aG9ycy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuZm9hbS5DTEFTUyh7XG4gIHBhY2thZ2U6ICdmb2FtLmJveCcsXG4gIG5hbWU6ICdOb1N1Y2hOYW1lRXhjZXB0aW9uJyxcbiAgaW1wbGVtZW50czogWydmb2FtLmNvcmUuRXhjZXB0aW9uJ10sXG5cbiAgcHJvcGVydGllczogW1xuICAgIHtcbiAgICAgIGNsYXNzOiAnU3RyaW5nJyxcbiAgICAgIG5hbWU6ICduYW1lJ1xuICAgIH0sXG4gICAge1xuICAgICAgY2xhc3M6ICdTdHJpbmcnLFxuICAgICAgbmFtZTogJ21lc3NhZ2UnLFxuICAgICAgdHJhbnNpZW50OiB0cnVlLFxuICAgICAgZXhwcmVzc2lvbjogZnVuY3Rpb24obmFtZSkge1xuICAgICAgICByZXR1cm4gJ0NvdWxkIG5vdCBmaW5kIHJlZ2lzdHJhdGlvbiBmb3IgJyArIG5hbWU7XG4gICAgICB9LFxuICAgICAgc3dpZnRFeHByZXNzaW9uQXJnczogWyduYW1lJ10sXG4gICAgICBzd2lmdEV4cHJlc3Npb246ICdyZXR1cm4gXCJDb3VsZCBub3QgZmluZCByZWdpc3RyYXRpb24gZm9yIFwiICsgbmFtZScsXG4gICAgfVxuICBdXG59KTtcbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IFRoZSBGT0FNIEF1dGhvcnMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmZvYW0uSU5URVJGQUNFKHtcbiAgcGFja2FnZTogJ2ZvYW0uYm94JyxcbiAgbmFtZTogJ0JveFJlZ2lzdHJ5JyxcbiAgbWV0aG9kczogW1xuICAgIHtcbiAgICAgIG5hbWU6ICdkb0xvb2t1cCcsXG4gICAgICByZXR1cm5zOiAnZm9hbS5ib3guQm94JyxcbiAgICAgIGphdmFSZXR1cm5zOiAnZm9hbS5ib3guQm94JyxcbiAgICAgIHN3aWZ0VGhyb3dzOiB0cnVlLFxuICAgICAgYXJnczogW1xuICAgICAgICB7XG4gICAgICAgICAgbmFtZTogJ25hbWUnLFxuICAgICAgICAgIHN3aWZ0VHlwZTogJ1N0cmluZycsXG4gICAgICAgICAgamF2YVR5cGU6ICdTdHJpbmcnXG4gICAgICAgIH1cbiAgICAgIF1cbiAgICB9LFxuICAgIHtcbiAgICAgIG5hbWU6ICdyZWdpc3RlcicsXG4gICAgICByZXR1cm5zOiAnZm9hbS5ib3guQm94JyxcbiAgICAgIGphdmFSZXR1cm5zOiAnZm9hbS5ib3guQm94JyxcbiAgICAgIGFyZ3M6IFtcbiAgICAgICAge1xuICAgICAgICAgIG5hbWU6ICduYW1lJyxcbiAgICAgICAgICBzd2lmdFR5cGU6ICdTdHJpbmc/JyxcbiAgICAgICAgICBqYXZhVHlwZTogJ1N0cmluZydcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIG5hbWU6ICdzZXJ2aWNlJyxcbiAgICAgICAgICBzd2lmdFR5cGU6ICdCb3hTZXJ2aWNlPycsXG4gICAgICAgICAgamF2YVR5cGU6ICdmb2FtLmJveC5Cb3hTZXJ2aWNlJ1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgbmFtZTogJ2JveCcsXG4gICAgICAgICAgc3dpZnRUeXBlOiAnQm94JyxcbiAgICAgICAgICBqYXZhVHlwZTogJ2ZvYW0uYm94LkJveCdcbiAgICAgICAgfVxuICAgICAgXSxcbiAgICB9LFxuICAgIHtcbiAgICAgIG5hbWU6ICd1bnJlZ2lzdGVyJyxcbiAgICAgIHJldHVybnM6ICcnLFxuICAgICAgamF2YVJldHVybnM6ICd2b2lkJyxcbiAgICAgIGFyZ3M6IFtcbiAgICAgICAge1xuICAgICAgICAgIG5hbWU6ICduYW1lJyxcbiAgICAgICAgICBqYXZhVHlwZTogJ1N0cmluZydcbiAgICAgICAgfVxuICAgICAgXVxuICAgIH1cbiAgXVxufSk7XG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBUaGUgRk9BTSBBdXRob3JzLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5mb2FtLkNMQVNTKHtcbiAgcGFja2FnZTogJ2ZvYW0uYm94JyxcbiAgbmFtZTogJ0xvY2FsQm94UmVnaXN0cnknLFxuICBpbXBsZW1lbnRzOiBbICdmb2FtLmJveC5Cb3hSZWdpc3RyeScgXSxcblxuICByZXF1aXJlczogW1xuICAgICdmb2FtLmJveC5Ob1N1Y2hOYW1lRXhjZXB0aW9uJyxcbiAgICAnZm9hbS5ib3guU3ViQm94J1xuICBdLFxuXG4gIGltcG9ydHM6IFtcbiAgICB7XG4gICAgICBuYW1lOiAnbWUnLFxuICAgICAga2V5OiAnbWUnLFxuICAgICAgamF2YVR5cGU6ICdmb2FtLmJveC5Cb3gnXG4gICAgfVxuICBdLFxuXG4gIHByb3BlcnRpZXM6IFtcbiAgICB7XG4gICAgICBjbGFzczogJ01hcCcsXG4gICAgICBuYW1lOiAncmVnaXN0cnlfJyxcbiAgICAgIGhpZGRlbjogdHJ1ZSxcbiAgICAgIGphdmFGYWN0b3J5OiAncmV0dXJuIG5ldyBqYXZhLnV0aWwuY29uY3VycmVudC5Db25jdXJyZW50SGFzaE1hcCgpOydcbiAgICB9XG4gIF0sXG5cbiAgY2xhc3NlczogW1xuICAgIHtcbiAgICAgIG5hbWU6ICdSZWdpc3RyYXRpb24nLFxuICAgICAgcHJvcGVydGllczogW1xuICAgICAgICB7XG4gICAgICAgICAgY2xhc3M6ICdGT2JqZWN0UHJvcGVydHknLFxuICAgICAgICAgIG9mOiAnZm9hbS5ib3guQm94JyxcbiAgICAgICAgICByZXF1aXJlZDogdHJ1ZSxcbiAgICAgICAgICBuYW1lOiAnZXhwb3J0Qm94J1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgY2xhc3M6ICdGT2JqZWN0UHJvcGVydHknLFxuICAgICAgICAgIG9mOiAnZm9hbS5ib3guQm94JyxcbiAgICAgICAgICByZXF1aXJlZDogdHJ1ZSxcbiAgICAgICAgICBuYW1lOiAnbG9jYWxCb3gnXG4gICAgICAgIH1cbiAgICAgIF1cbiAgICB9XG4gIF0sXG5cbiAgbWV0aG9kczogW1xuICAgIHtcbiAgICAgIG5hbWU6ICdkb0xvb2t1cCcsXG4gICAgICBjb2RlOiBmdW5jdGlvbiBkb0xvb2t1cChuYW1lKSB7XG4gICAgICAgIGlmICggdGhpcy5yZWdpc3RyeV9bbmFtZV0gJiZcbiAgICAgICAgICAgICB0aGlzLnJlZ2lzdHJ5X1tuYW1lXS5leHBvcnRCb3ggKVxuICAgICAgICAgIHJldHVybiB0aGlzLnJlZ2lzdHJ5X1tuYW1lXS5leHBvcnRCb3g7XG5cbiAgICAgICAgdGhyb3cgdGhpcy5Ob1N1Y2hOYW1lRXhjZXB0aW9uLmNyZWF0ZSh7IG5hbWU6IG5hbWUgfSk7XG4gICAgICB9LFxuICAgICAgc3dpZnRDb2RlOiBmdW5jdGlvbigpIHsvKlxuaWYgbGV0IGV4cG9ydEJveCA9IChyZWdpc3RyeV9bbmFtZV0gYXM/IFJlZ2lzdHJhdGlvbik/LmV4cG9ydEJveCB7XG4gIHJldHVybiBleHBvcnRCb3hcbn1cbnRocm93IE5vU3VjaE5hbWVFeGNlcHRpb25fY3JlYXRlKFtcIm5hbWVcIjogbmFtZV0pXG4gICAgICAqL30sXG4gICAgICBqYXZhQ29kZTogYFxuT2JqZWN0IHJlZ2lzdHJhdGlvbiA9IGdldFJlZ2lzdHJ5XygpLmdldChuYW1lKTtcbmlmICggcmVnaXN0cmF0aW9uID09IG51bGwgKSB7XG4gIHRocm93IG5ldyBSdW50aW1lRXhjZXB0aW9uKFwiTm8gc3VjaCBuYW1lXCIpO1xufVxucmV0dXJuICgoUmVnaXN0cmF0aW9uKXJlZ2lzdHJhdGlvbikuZ2V0RXhwb3J0Qm94KCk7XG5gXG4gICAgfSxcbiAgICB7XG4gICAgICBuYW1lOiAncmVnaXN0ZXInLFxuICAgICAgY29kZTogZnVuY3Rpb24obmFtZSwgc2VydmljZSwgbG9jYWxCb3gpIHtcbiAgICAgICAgbmFtZSA9IG5hbWUgfHwgZm9hbS5uZXh0JFVJRCgpO1xuXG4gICAgICAgIHZhciBleHBvcnRCb3ggPSB0aGlzLlN1YkJveC5jcmVhdGUoeyBuYW1lOiBuYW1lLCBkZWxlZ2F0ZTogdGhpcy5tZSB9KTtcbiAgICAgICAgZXhwb3J0Qm94ID0gc2VydmljZSA/IHNlcnZpY2UuY2xpZW50Qm94KGV4cG9ydEJveCkgOiBleHBvcnRCb3g7XG5cbiAgICAgICAgdGhpcy5yZWdpc3RyeV9bbmFtZV0gPSB7XG4gICAgICAgICAgZXhwb3J0Qm94OiBleHBvcnRCb3gsXG4gICAgICAgICAgbG9jYWxCb3g6IHNlcnZpY2UgPyBzZXJ2aWNlLnNlcnZlckJveChsb2NhbEJveCkgOiBsb2NhbEJveFxuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiB0aGlzLnJlZ2lzdHJ5X1tuYW1lXS5leHBvcnRCb3g7XG4gICAgICB9LFxuICAgICAgc3dpZnRTeW5jaHJvbml6ZWQ6IHRydWUsXG4gICAgICBzd2lmdENvZGU6IGZ1bmN0aW9uKCkgey8qXG5sZXQgbmFtZTogU3RyaW5nID0gbmFtZSA/PyBVVUlEKCkudXVpZFN0cmluZ1xuXG52YXIgZXhwb3J0Qm94OiBCb3ggPSBTdWJCb3hfY3JlYXRlKFtcbiAgXCJuYW1lXCI6IG5hbWUsXG4gIFwiZGVsZWdhdGVcIjogbWVcbl0pXG5leHBvcnRCb3ggPSBzZXJ2aWNlPy5jbGllbnRCb3goZXhwb3J0Qm94KSA/PyBleHBvcnRCb3hcblxubGV0IHJlZ2lzdHJhdGlvbiA9IFJlZ2lzdHJhdGlvbl9jcmVhdGUoW1xuICBcImV4cG9ydEJveFwiOiBleHBvcnRCb3gsXG4gIFwibG9jYWxCb3hcIjogc2VydmljZT8uc2VydmVyQm94KGJveCkgPz8gYm94XG5dKVxucmVnaXN0cnlfW25hbWVdID0gcmVnaXN0cmF0aW9uXG5yZXR1cm4gcmVnaXN0cmF0aW9uLmV4cG9ydEJveFxuICAgICAgKi99LFxuICAgICAgamF2YUNvZGU6IGBcbmlmICggbmFtZSA9PSBudWxsICkgbmFtZSA9IEludGVnZXIudG9TdHJpbmcoZm9hbS5ib3guSWRHZW5lcmF0b3IubmV4dElkKCkpO1xuXG5mb2FtLmJveC5TdWJCb3ggZXhwb3J0Qm94ID0gZ2V0WCgpLmNyZWF0ZShmb2FtLmJveC5TdWJCb3guY2xhc3MpO1xuZXhwb3J0Qm94LnNldE5hbWUobmFtZSk7XG5leHBvcnRCb3guc2V0RGVsZWdhdGUoZ2V0TWUoKSk7XG5SZWdpc3RyYXRpb24gcmVnaXN0cmF0aW9uID0gbmV3IFJlZ2lzdHJhdGlvbigpO1xucmVnaXN0cmF0aW9uLnNldFgoZ2V0WCgpKTtcbnJlZ2lzdHJhdGlvbi5zZXRFeHBvcnRCb3goZXhwb3J0Qm94KTtcbnJlZ2lzdHJhdGlvbi5zZXRMb2NhbEJveChib3gpO1xuLy8gVE9ETyhhZGFtdnkpOiBBcHBseSBzZXJ2aWNlIHBvbGljeVxuXG5nZXRSZWdpc3RyeV8oKS5wdXQobmFtZSwgcmVnaXN0cmF0aW9uKTtcbnJldHVybiBleHBvcnRCb3g7XG5gXG4gICAgfSxcbiAgICB7XG4gICAgICBuYW1lOiAndW5yZWdpc3RlcicsXG4gICAgICBjb2RlOiBmdW5jdGlvbihuYW1lKSB7XG4gICAgICAgIGlmICggZm9hbS5ib3guQm94LmlzSW5zdGFuY2UobmFtZSkgKSB7XG4gICAgICAgICAgZm9yICggdmFyIGtleSBpbiB0aGlzLnJlZ2lzdHJ5XyApIHtcbiAgICAgICAgICAgIC8vIFRPRE8obWFya2RpdHRtZXIpOiBTaG91bGQgdGhlcmUgYmUgYSBzcGVjaWFsaXplZCBjb21wYXJlKCkgc2hvdWxkXG4gICAgICAgICAgICAvLyBiZSBpbXBsZW1lbnRlZCBieSBOYW1lZEJveCAodG8gY3V0IG91dCBkZWxlZ2F0ZSkgYW5kXG4gICAgICAgICAgICAvLyBmb2FtLnV0aWwuY29tcGFyZSgpP1xuICAgICAgICAgICAgaWYgKCB0aGlzLnJlZ2lzdHJ5X1trZXldLmV4cG9ydEJveCA9PT0gbmFtZSApIHtcbiAgICAgICAgICAgICAgZGVsZXRlIHRoaXMucmVnaXN0cnlfW2tleV07XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgZGVsZXRlIHRoaXMucmVnaXN0cnlfW25hbWVdO1xuICAgICAgfSxcbiAgICAgIHN3aWZ0U3luY2hyb25pemVkOiB0cnVlLFxuICAgICAgc3dpZnRDb2RlOiBmdW5jdGlvbigpIHsvKlxuaWYgbGV0IG5hbWUgPSBuYW1lIGFzPyBTdHJpbmcge1xuICByZWdpc3RyeV8ucmVtb3ZlVmFsdWUoZm9yS2V5OiBuYW1lKVxufSBlbHNlIGlmIGxldCBuYW1lID0gbmFtZSBhcz8gQW55Q2xhc3Mge1xuICBmb3Iga2V5IGluIHJlZ2lzdHJ5Xy5rZXlzIHtcbiAgICBpZiAoKHJlZ2lzdHJ5X1trZXldIGFzISBSZWdpc3RyYXRpb24pLmV4cG9ydEJveCBhcz8gQW55Q2xhc3MpID09PSBuYW1lIHtcbiAgICAgIHJlZ2lzdHJ5Xy5yZW1vdmVWYWx1ZShmb3JLZXk6IGtleSlcbiAgICAgIHJldHVyblxuICAgIH1cbiAgfVxufVxuICAgICAgKi99LFxuICAgICAgamF2YUNvZGU6IGBcbmdldFJlZ2lzdHJ5XygpLnJlbW92ZShuYW1lKTtcbmBcbiAgICB9XG4gIF1cbn0pO1xuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgVGhlIEZPQU0gQXV0aG9ycy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuZm9hbS5DTEFTUyh7XG4gIHBhY2thZ2U6ICdmb2FtLmJveCcsXG4gIG5hbWU6ICdCb3hSZWdpc3RyeUJveCcsXG4gIGV4dGVuZHM6ICdmb2FtLmJveC5Mb2NhbEJveFJlZ2lzdHJ5JyxcblxuICBpbXBsZW1lbnRzOiBbICdmb2FtLmJveC5Cb3gnIF0sXG5cbiAgcmVxdWlyZXM6IFtcbiAgICAnZm9hbS5ib3guU3ViQm94TWVzc2FnZScsXG4gICAgJ2ZvYW0uYm94Lk1lc3NhZ2UnLFxuICAgICdmb2FtLmJveC5IZWxsb01lc3NhZ2UnLFxuICAgICdmb2FtLmJveC5Ta2VsZXRvbkJveCdcbiAgXSxcblxuICBwcm9wZXJ0aWVzOiBbXG4gICAge1xuICAgICAgY2xhc3M6ICdGT2JqZWN0UHJvcGVydHknLFxuICAgICAgb2Y6ICdmb2FtLmJveC5Cb3gnLFxuICAgICAgbmFtZTogJ3JlZ2lzdHJ5U2tlbGV0b24nLFxuICAgICAgZmFjdG9yeTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLlNrZWxldG9uQm94LmNyZWF0ZSh7IGRhdGE6IHRoaXMgfSk7XG4gICAgICB9LFxuICAgICAgLy8gVE9ETyBjaGVjayBpZiB0aGlzIGxlYWtzLlxuICAgICAgc3dpZnRGYWN0b3J5OiAncmV0dXJuIFNrZWxldG9uQm94X2NyZWF0ZShbXCJkYXRhXCI6IHNlbGZdKScsXG4gICAgICBzd2lmdFBvc3RTZXQ6IGZ1bmN0aW9uKCkgey8qXG5pZiBsZXQgb2xkVmFsdWUgPSBvbGRWYWx1ZSBhcz8gU2tlbGV0b25Cb3gge1xuICBvbGRWYWx1ZS5jbGVhclByb3BlcnR5KFwiZGF0YVwiKVxufVxuICAgICAgKi99LFxuICAgIH1cbiAgXSxcblxuICBtZXRob2RzOiBbXG4gICAge1xuICAgICAgbmFtZTogJ2luaXQnLFxuICAgICAgc3dpZnRDb2RlOiBmdW5jdGlvbigpIHsvKlxuc2VsZi5vbkRldGFjaChTdWJzY3JpcHRpb24oZGV0YWNoOiB7XG4gIGlmIHNlbGYuaGFzT3duUHJvcGVydHkoXCJyZWdpc3RyeVNrZWxldG9uXCIpIHtcbiAgICAoc2VsZi5yZWdpc3RyeVNrZWxldG9uIGFzPyBGT2JqZWN0KT8uY2xlYXJQcm9wZXJ0eShcImRhdGFcIilcbiAgfVxufSkpXG4gICAgICAqL30sXG4gICAgICBjb2RlOiBmdW5jdGlvbigpIHsgdGhpcy5TVVBFUigpIH0sXG4gICAgfSxcbiAgICB7XG4gICAgICBuYW1lOiAnc2VuZCcsXG4gICAgICBzd2lmdENvZGU6IGZ1bmN0aW9uKCkgey8qXG5pZiBsZXQgb2JqZWN0ID0gbXNnLm9iamVjdCBhcz8gU3ViQm94TWVzc2FnZSB7XG4gIGxldCBuYW1lID0gb2JqZWN0Lm5hbWVcblxuICBpZiBsZXQgcmVnID0gcmVnaXN0cnlfW25hbWVdIGFzPyBSZWdpc3RyYXRpb24ge1xuICAgIG1zZy5vYmplY3QgPSBvYmplY3Qub2JqZWN0O1xuICAgIHRyeSByZWcubG9jYWxCb3guc2VuZChtc2cpO1xuICB9IGVsc2Uge1xuICAgIGlmIGxldCBlcnJvckJveCA9IG1zZy5hdHRyaWJ1dGVzW1wiZXJyb3JCb3hcIl0gYXM/IEJveCB7XG4gICAgICB0cnkgZXJyb3JCb3guc2VuZChcbiAgICAgICAgTWVzc2FnZV9jcmVhdGUoW1xuICAgICAgICAgIFwib2JqZWN0XCI6IE5vU3VjaE5hbWVFeGNlcHRpb25fY3JlYXRlKFtcIm5hbWVcIjogbmFtZSBdKVxuICAgICAgICBdKSlcbiAgICB9XG4gIH1cbn0gZWxzZSBpZiBsZXQgXyA9IG1zZy5vYmplY3QgYXM/IEhlbGxvTWVzc2FnZSB7XG59IGVsc2Uge1xuICB0cnkgcmVnaXN0cnlTa2VsZXRvbiEuc2VuZChtc2cpXG59XG4gICAgICAqL30sXG4gICAgICBjb2RlOiBmdW5jdGlvbihtc2cpIHtcbiAgICAgICAgaWYgKCB0aGlzLlN1YkJveE1lc3NhZ2UuaXNJbnN0YW5jZShtc2cub2JqZWN0KSApIHtcbiAgICAgICAgICB2YXIgbmFtZSA9IG1zZy5vYmplY3QubmFtZTtcblxuICAgICAgICAgIGlmICggdGhpcy5yZWdpc3RyeV9bbmFtZV0gJiYgdGhpcy5yZWdpc3RyeV9bbmFtZV0ubG9jYWxCb3ggKSB7XG4gICAgICAgICAgICAvLyBVbnBhY2sgc3ViIGJveCBvYmplY3QuLi4gaXMgdGhpcyByaWdodD9cbiAgICAgICAgICAgIG1zZy5vYmplY3QgPSBtc2cub2JqZWN0Lm9iamVjdDtcbiAgICAgICAgICAgIHRoaXMucmVnaXN0cnlfW25hbWVdLmxvY2FsQm94LnNlbmQobXNnKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKCBtc2cuYXR0cmlidXRlcy5yZXBseUJveCApIHtcbiAgICAgICAgICAgICAgbXNnLmF0dHJpYnV0ZXMucmVwbHlCb3guc2VuZChcbiAgICAgICAgICAgICAgICB0aGlzLk1lc3NhZ2UuY3JlYXRlKHtcbiAgICAgICAgICAgICAgICAgIG9iamVjdDogdGhpcy5Ob1N1Y2hOYW1lRXhjZXB0aW9uLmNyZWF0ZSh7IG5hbWU6IG5hbWUgfSlcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKCB0aGlzLkhlbGxvTWVzc2FnZS5pc0luc3RhbmNlKG1zZy5vYmplY3QpICkge1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMucmVnaXN0cnlTa2VsZXRvbi5zZW5kKG1zZyk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBqYXZhQ29kZTogYFxuT2JqZWN0IG9iaiA9IG1lc3NhZ2UuZ2V0T2JqZWN0KCk7XG5cbmlmICggb2JqIGluc3RhbmNlb2YgZm9hbS5ib3guU3ViQm94TWVzc2FnZSApIHtcbiAgZm9hbS5ib3guU3ViQm94TWVzc2FnZSBzYm0gPSAoZm9hbS5ib3guU3ViQm94TWVzc2FnZSlvYmo7XG4gIFN0cmluZyBuYW1lID0gc2JtLmdldE5hbWUoKTtcblxuICBSZWdpc3RyYXRpb24gZGVzdCA9IChSZWdpc3RyYXRpb24pZ2V0UmVnaXN0cnlfKCkuZ2V0KG5hbWUpO1xuXG4gIGlmICggZGVzdCAhPSBudWxsICkge1xuICAgIG1lc3NhZ2Uuc2V0T2JqZWN0KHNibS5nZXRPYmplY3QoKSk7XG4gICAgZGVzdC5nZXRMb2NhbEJveCgpLnNlbmQobWVzc2FnZSk7XG4gIH0gZWxzZSBpZiAoIG1lc3NhZ2UuZ2V0QXR0cmlidXRlcygpLmNvbnRhaW5zS2V5KFwicmVwbHlCb3hcIikgKSB7XG4gICAgZm9hbS5ib3guQm94IHJlcGx5Qm94ID0gKGZvYW0uYm94LkJveCltZXNzYWdlLmdldEF0dHJpYnV0ZXMoKS5nZXQoXCJyZXBseUJveFwiKTtcbiAgICBmb2FtLmJveC5NZXNzYWdlIGVycm9yTWVzc2FnZSA9IGdldFgoKS5jcmVhdGUoZm9hbS5ib3guTWVzc2FnZS5jbGFzcyk7XG4gICAgZXJyb3JNZXNzYWdlLnNldE9iamVjdChnZXRYKCkuY3JlYXRlKGZvYW0uYm94Lk5vU3VjaE5hbWVFeGNlcHRpb24uY2xhc3MpKTtcblxuICAgIHJlcGx5Qm94LnNlbmQoZXJyb3JNZXNzYWdlKTtcbiAgfVxufVxuYFxuICAgIH1cbiAgXVxufSk7XG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBUaGUgRk9BTSBBdXRob3JzLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG4vLyBUT0RPOiBVc2UgQ29udGV4dEZhY3RvcmllcyB0byBjcmVhdGUgdGhlc2Ugb24gZGVtYW5kLlxuZm9hbS5DTEFTUyh7XG4gIHBhY2thZ2U6ICdmb2FtLmJveCcsXG4gIG5hbWU6ICdDbGllbnRCb3hSZWdpc3RyeScsXG4gIGltcGxlbWVudHM6IFsnZm9hbS5ib3guQm94UmVnaXN0cnknXSxcbiAgcHJvcGVydGllczogW1xuICAgIHtcbiAgICAgIGNsYXNzOiAnU3R1YicsXG4gICAgICBvZjogJ2ZvYW0uYm94LkJveFJlZ2lzdHJ5JyxcbiAgICAgIG5hbWU6ICdkZWxlZ2F0ZSdcbiAgICB9XG4gIF1cbn0pO1xuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgVGhlIEZPQU0gQXV0aG9ycy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuZm9hbS5DTEFTUyh7XG4gIHBhY2thZ2U6ICdmb2FtLmJveCcsXG4gIG5hbWU6ICdQcm9taXNlZEJveFJlZ2lzdHJ5JyxcblxuICBwcm9wZXJ0aWVzOiBbXG4gICAge1xuICAgICAgY2xhc3M6ICdQcm9taXNlZCcsXG4gICAgICBvZjogJ2ZvYW0uYm94LkJveFJlZ2lzdHJ5JyxcbiAgICAgIG5hbWU6ICdkZWxlZ2F0ZSdcbiAgICB9XG4gIF1cbn0pO1xuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgVGhlIEZPQU0gQXV0aG9ycy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuZm9hbS5JTlRFUkZBQ0Uoe1xuICBwYWNrYWdlOiAnZm9hbS5ib3gnLFxuICBuYW1lOiAnUmVnaXN0cnlTZWxlY3RvcicsXG5cbiAgZG9jdW1lbnRhdGlvbjogYEEgZnVuY3Rpb24gdGhhdCBzZWxlY3RzIGEgcmVnaXN0cnkgd2hlcmUgYSBzZXJ2aWNlIHNob3VsZCBiZVxuICAgICAgcmVnaXN0ZXJlZCwgYmFzZWQgb24gdGhlIHJlcXVlc3RlZCBuYW1lLCBzZXJ2aWNlIHBvbGljeSwgYm94LCBhbmQgYW55XG4gICAgICBzdGF0ZSBpbnRlcm5hbCB0byB0aGUgc2VsZWN0b3IuIFJlZ2lzdHJ5U2VsZWN0b3JzIGFyZSB1c2VkIGJ5XG4gICAgICBTZWxlY3RvclJlZ2lzdHJpZXMgdG8gcm91dGUgcmVnaXN0cmF0aW9uIHJlcXVlc3RzLlxuXG4gICAgICBOT1RFOiBTZWxlY3RvclJlZ2lzdHJ5J3MgZGVsZWdhdGlvbiBzdHJhdGVneSBleHBlY3RzIHJlZ2lzdHJpZXMgcmV0dXJuZWRcbiAgICAgIGJ5IGZyb20gUmVnaXN0cnlTZWxlY3RvcnMgdG8gcmVzaWRlIGluIGEgZGlmZmVyZW50IGZvYW0uYm94LkNvbnRleHQgKHdpdGhcbiAgICAgIGEgZGlmZmVyZW50IGZvYW0uYm94LkNvbnRleHQubXluYW1lKSB0aGFuIHRoZSBTZWxlY3RvclJlZ2lzdHJ5LmAsXG5cbiAgbWV0aG9kczogW1xuICAgIGZ1bmN0aW9uIHNlbGVjdChuYW1lLCBzZXJ2aWNlLCBib3gpIHt9XG4gIF1cbn0pO1xuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgVGhlIEZPQU0gQXV0aG9ycy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuZm9hbS5DTEFTUyh7XG4gIHBhY2thZ2U6ICdmb2FtLmJveCcsXG4gIG5hbWU6ICdTZWxlY3RvclJlZ2lzdHJ5JyxcbiAgZXh0ZW5kczogJ2ZvYW0uYm94LkJveFJlZ2lzdHJ5Qm94JyxcblxuICBkb2N1bWVudGF0aW9uOiBgQSByZWdpc3RyeSB0aGF0IHJvdXRlcyByZWdpc3RyYXRpb24gcmVxdWVzdHMgdG8gb3RoZXJcbiAgICAgIHJlZ2lzdHJpZXMgYWNjb3JkaW5nIHRvIGl0cyBcInNlbGVjdG9yXCIuXG5cbiAgICAgIE5PVEU6IFNlbGVjdG9yUmVnaXN0cnkncyBkZWxlZ2F0aW9uIHN0cmF0ZWd5IGV4cGVjdHMgcmVnaXN0cmllcyByZXR1cm5lZFxuICAgICAgYnkgXCJzZWxlY3RvclwiIHRvIHJlc2lkZSBpbiBhIGRpZmZlcmVudCBmb2FtLmJveC5Db250ZXh0ICh3aXRoIGEgZGlmZmVyZW50XG4gICAgICBmb2FtLmJveC5Db250ZXh0Lm15bmFtZSkgdGhhbiB0aGUgU2VsZWN0b3JSZWdpc3RyeS5gLFxuXG4gIHJlcXVpcmVzOiBbICdmb2FtLmJveC5Cb3gnIF0sXG4gIGV4cG9ydHM6IFsgJ2FzIHJlZ2lzdHJ5JyBdLFxuXG4gIGNsYXNzZXM6IFtcbiAgICB7XG4gICAgICBuYW1lOiAnUmVnaXN0cmF0aW9uJyxcblxuICAgICAgZG9jdW1lbnRhdGlvbjogYE1hcHBpbmcgYmV0d2VlbiBhIGRlbGVnYXRlIHJlZ2lzdHJ5IGFuZCBhIGJveCByZXR1cm5lZFxuICAgICAgICAgIGZyb20gcmVnaXN0ZXJpbmcgd2l0aCB0aGUgZGVsZWdhdGUuYCxcblxuICAgICAgcHJvcGVydGllczogW1xuICAgICAgICB7XG4gICAgICAgICAgY2xhc3M6ICdTdHJpbmcnLFxuICAgICAgICAgIG5hbWU6ICduYW1lJyxcbiAgICAgICAgICBkb2N1bWVudGF0aW9uOiBgTmFtZSB1bmRlciB3aGljaCByZWdpc3RyYXRpb24gd2FzIHN0b3JlZCBpblxuICAgICAgICAgICAgICBTZWxlY3RvclJlZ2lzdHJ5LmBcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIGNsYXNzOiAnRk9iamVjdFByb3BlcnR5JyxcbiAgICAgICAgICBvZjogJ2ZvYW0uYm94LkJveFJlZ2lzdHJ5JyxcbiAgICAgICAgICBuYW1lOiAnZGVsZWdhdGVSZWdpc3RyeScsXG4gICAgICAgICAgZG9jdW1lbnRhdGlvbjogYFRoZSByZWdpc3RyeSB0aGF0IFNlbGVjdG9yUmVnaXN0cnkgZGVsZWdhdGVkIHRvIGZvclxuICAgICAgICAgICAgICBtYW5hZ2VkIHJlZ2lzdHJhdGlvbi5gXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICBjbGFzczogJ1N0cmluZycsXG4gICAgICAgICAgbmFtZTogJ2RlbGVnYXRlUmVnaXN0ZXJlZE5hbWUnLFxuICAgICAgICAgIGRvY3VtZW50YXRpb246IGBOYW1lIHVuZGVyIHdoaWNoIHJlZ2lzdHJhdGlvbiB3YXMgc3RvcmVkIGluXG4gICAgICAgICAgICAgIFwiZGVsZWdhdGVSZWdpc3RyeVwiLmBcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIGNsYXNzOiAnRk9iamVjdFByb3BlcnR5JyxcbiAgICAgICAgICBvZjogJ2ZvYW0uYm94LkJveCcsXG4gICAgICAgICAgbmFtZTogJ2RlbGVnYXRlUmVnaXN0ZXJlZEJveCcsXG4gICAgICAgICAgZG9jdW1lbnRhdGlvbjogYEJveCByZXR1cm5lZCBmcm9tIHJlZ2lzdGVyKCkgb24gXCJkZWxlZ2F0ZVJlZ2lzdHJ5XCIuYFxuICAgICAgICB9XG4gICAgICBdXG4gICAgfVxuICBdLFxuXG4gIHByb3BlcnRpZXM6IFtcbiAgICB7XG4gICAgICBjbGFzczogJ0ZPYmplY3RQcm9wZXJ0eScsXG4gICAgICBvZjogJ2ZvYW0uYm94LlJlZ2lzdHJ5U2VsZWN0b3InLFxuICAgICAgbmFtZTogJ3NlbGVjdG9yJyxcbiAgICAgIGRvY3VtZW50YXRpb246IGBBIChwb3RlbnRpYWxseSBzdGF0ZWZ1bCkgZnVuY3Rpb24gdGhhdCBzZWxlY3RzIGEgZGVsZWdhdGVcbiAgICAgICAgICByZWdpc3RyeSBvbiBhIHBlci1yZWdpc3RyYXRpb24tcmVxdWVzdCBiYXNpcy5gLFxuICAgICAgcmVxdWlyZWQ6IHRydWVcbiAgICB9LFxuICAgIHtcbiAgICAgIGNsYXNzOiAnQXJyYXknLFxuICAgICAgLy8gb2Y6ICdSZWdpc3RyYXRpb24nLFxuICAgICAgbmFtZTogJ3NlbGVjdG9yUmVnaXN0cmF0aW9uc18nLFxuICAgICAgZG9jdW1lbnRhdGlvbjogYEFycmF5IG9mIGJpbmRpbmdzOlxuICAgICAgICAgIDxzZWxlY3Rvci1jaG9zZW4tZGVsZWdhdGUsIGJveC1yZXR1cm5lZC1mcm9tLXJlZ2lzdGVyLWluLWRlbGVnYXRlPi5gXG4gICAgfVxuICBdLFxuXG4gIG1ldGhvZHM6IFtcbiAgICBmdW5jdGlvbiByZWdpc3RlcihuYW1lLCBzZXJ2aWNlLCBib3gpIHtcbiAgICAgIG5hbWUgPSBuYW1lIHx8IGZvYW0ubmV4dCRVSUQoKTtcblxuICAgICAgdmFyIGRlbGVnYXRlID0gdGhpcy5zZWxlY3Rvci5zZWxlY3QobmFtZSwgc2VydmljZSwgYm94KTtcblxuICAgICAgdmFyIGRlbGVnYXRlUmVnaXN0ZXJlZE5hbWUgPSBmb2FtLnV1aWQucmFuZG9tR1VJRCgpO1xuICAgICAgdmFyIGRlbGVnYXRlUmVnaXN0ZXJlZEJveCA9IGRlbGVnYXRlLnJlZ2lzdGVyKFxuICAgICAgICAgIGRlbGVnYXRlUmVnaXN0ZXJlZE5hbWUsIG51bGwsIGJveCk7XG5cbiAgICAgIC8vIENyZWF0ZSByZWxheSB0byBkZXNpcmVkIHNlcnZpY2UgbmFtZSwgYnV0IHJldHVybiBib3ggZnJvbSBkZWxlZ2F0ZS5cbiAgICAgIC8vIFRoaXMgY3JlYXRlcyBhIGNvbnNpc3RlbnQgbmFtZXNwYWNlIGZvciBjbGllbnRzIG9mIHRoaXMgcmVnaXN0cnkgd2hpbGVcbiAgICAgIC8vIGFsc28gcmV0dXJuaW5nIE5hbWVkQm94ZXMgdGhhdCByZXNvbHZlIHRvIGRlbGVnYXRlIENvbnRleHQgbmFtZXMuXG4gICAgICB0aGlzLlNVUEVSKG5hbWUsIHNlcnZpY2UsIGRlbGVnYXRlUmVnaXN0ZXJlZEJveCk7XG5cbiAgICAgIHRoaXMuc2VsZWN0b3JSZWdpc3RyYXRpb25zXy5wdXNoKHRoaXMuUmVnaXN0cmF0aW9uLmNyZWF0ZSh7XG4gICAgICAgIG5hbWU6IG5hbWUsXG4gICAgICAgIGRlbGVnYXRlUmVnaXN0cnk6IGRlbGVnYXRlLFxuICAgICAgICBkZWxlZ2F0ZVJlZ2lzdGVyZWROYW1lOiBkZWxlZ2F0ZVJlZ2lzdGVyZWROYW1lLFxuICAgICAgICBkZWxlZ2F0ZVJlZ2lzdGVyZWRCb3g6IGRlbGVnYXRlUmVnaXN0ZXJlZEJveFxuICAgICAgfSkpO1xuXG4gICAgICByZXR1cm4gZGVsZWdhdGVSZWdpc3RlcmVkQm94O1xuICAgIH0sXG4gICAgZnVuY3Rpb24gdW5yZWdpc3RlcihuYW1lT3JCb3gpIHtcbiAgICAgIHZhciBkZWxlZ2F0ZVJlZ2lzdGVyZWRCb3g7XG4gICAgICB2YXIgaW5wdXRJc0JveCA9IHRoaXMuQm94LmlzSW5zdGFuY2UobmFtZU9yQm94KTtcbiAgICAgIGlmICggaW5wdXRJc0JveCApIHtcbiAgICAgICAgZGVsZWdhdGVSZWdpc3RlcmVkQm94ID0gbmFtZU9yQm94O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGVsZWdhdGVSZWdpc3RlcmVkQm94ID0gdGhpcy5yZWdpc3RyeV9bbmFtZU9yQm94XS5sb2NhbEJveDtcblxuICAgICAgICAvLyBXaGVuIG5hbWUgaXMga25vd24sIGRlbGV0ZSBmcm9tIHRoaXMgcmVnaXN0cnkgaW1tZWRpYXRlbHkuXG4gICAgICAgIHRoaXMuU1VQRVIobmFtZU9yQm94KTtcbiAgICAgIH1cblxuICAgICAgdmFyIHJlZ2lzdHJhdGlvbnMgPSB0aGlzLnNlbGVjdG9yUmVnaXN0cmF0aW9uc187XG4gICAgICB2YXIgZGVsZWdhdGVSZWdpc3RyeSA9IG51bGw7XG4gICAgICB2YXIgZGVsZWdhdGVSZWdpc3RlcmVkTmFtZSA9ICcnO1xuICAgICAgZm9yICggdmFyIGkgPSAwOyBpIDwgcmVnaXN0cmF0aW9ucy5sZW5ndGg7IGkrKyApIHtcbiAgICAgICAgaWYgKCByZWdpc3RyYXRpb25zW2ldLmRlbGVnYXRlUmVnaXN0ZXJlZEJveCAhPT0gZGVsZWdhdGVSZWdpc3RlcmVkQm94IClcbiAgICAgICAgICBjb250aW51ZTtcblxuICAgICAgICBkZWxlZ2F0ZVJlZ2lzdHJ5ID0gcmVnaXN0cmF0aW9uc1tpXS5kZWxlZ2F0ZVJlZ2lzdHJ5O1xuICAgICAgICBkZWxlZ2F0ZVJlZ2lzdGVyZWROYW1lID0gcmVnaXN0cmF0aW9uc1tpXS5kZWxlZ2F0ZVJlZ2lzdGVyZWROYW1lO1xuXG4gICAgICAgIC8vIFdoZW4gbmFtZSB3YXMgbm90IHByZXZpb3VzbHkga25vd24sIGRlbGV0ZSBmcm9tIHRoaXMgcmVnaXN0cnkgYWZ0ZXJcbiAgICAgICAgLy8gZmluZGluZyBhc3NvY2lhdGVkIFJlZ2lzdHJhdGlvbi5cbiAgICAgICAgaWYgKCBpbnB1dElzQm94ICkgZGVsZXRlIHRoaXMucmVnaXN0cnlfW3JlZ2lzdHJhdGlvbnNbaV0ubmFtZV07XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBmb2FtLmFzc2VydChkZWxlZ2F0ZVJlZ2lzdHJ5LFxuICAgICAgICAgICAgICAgICAgJ1NlbGVjdG9yUmVnaXN0cnk6IEV4cGVjdGVkIHRvIGZpbmQgZGVsZWdhdGUgcmVnaXN0cnknKTtcblxuICAgICAgZGVsZWdhdGVSZWdpc3RyeS51bnJlZ2lzdGVyKGRlbGVnYXRlUmVnaXN0ZXJlZE5hbWUpO1xuICAgIH1cbiAgXVxufSk7XG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBUaGUgRk9BTSBBdXRob3JzLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5mb2FtLkNMQVNTKHtcbiAgcGFja2FnZTogJ2ZvYW0uYm94JyxcbiAgbmFtZTogJ0Jyb2FkY2FzdFJlZ2lzdHJ5JyxcbiAgZXh0ZW5kczogJ2ZvYW0uYm94LkJveFJlZ2lzdHJ5Qm94JyxcblxuICByZXF1aXJlczogW1xuICAgICdmb2FtLmJveC5Cb3gnLFxuICAgICdmb2FtLmJveC5Sb3VuZFJvYmluQm94J1xuICBdLFxuICBleHBvcnRzOiBbICdhcyByZWdpc3RyeScgXSxcblxuICBjbGFzc2VzOiBbXG4gICAge1xuICAgICAgbmFtZTogJ1JlZ2lzdHJhdGlvbicsXG5cbiAgICAgIGRvY3VtZW50YXRpb246IGBNYXBwaW5nIGJldHdlZW4gcmVnaXN0ZXJlZCBuYW1lcyBhbmQgYm94ZXMgcmV0dXJuZWRcbiAgICAgICAgICBmcm9tIHJlZ2lzdGVyaW5nIHdpdGggdGhlIGRlbGVnYXRlcy5gLFxuXG4gICAgICBwcm9wZXJ0aWVzOiBbXG4gICAgICAgIHtcbiAgICAgICAgICBjbGFzczogJ1N0cmluZycsXG4gICAgICAgICAgbmFtZTogJ25hbWUnLFxuICAgICAgICAgIGRvY3VtZW50YXRpb246IGBOYW1lIHVuZGVyIHdoaWNoIHJlZ2lzdHJhdGlvbiB3YXMgc3RvcmVkIGluXG4gICAgICAgICAgICAgIEJyb2FkY2FzdFJlZ2lzdHJ5LmBcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIGNsYXNzOiAnQXJyYXknLFxuICAgICAgICAgIG9mOiAnU3RyaW5nJyxcbiAgICAgICAgICBuYW1lOiAnZGVsZWdhdGVOYW1lcycsXG4gICAgICAgICAgZG9jdW1lbnRhdGlvbjogYE5hbWUgdW5kZXIgd2hpY2ggcmVnaXN0cmF0aW9uIGRlbGVnYXRlIHNlcnZpY2VzXG4gICAgICAgICAgICAgIGFyZSByZWdpc3RlcmVkLmBcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIGNsYXNzOiAnRk9iamVjdFByb3BlcnR5JyxcbiAgICAgICAgICBvZjogJ2ZvYW0uYm94LkJveCcsXG4gICAgICAgICAgbmFtZTogJ3JlZ2lzdGVyZWRCb3gnLFxuICAgICAgICAgIGRvY3VtZW50YXRpb246IGBCb3ggcmV0dXJuZWQgZnJvbSBCcm9hZGNhc3RSZWdpc3RyeS5yZWdpc3RlcigpIFNVUEVSKClcbiAgICAgICAgICAgICAgaW1wbGVtZW50YXRpb24uYFxuICAgICAgICB9XG4gICAgICBdXG4gICAgfVxuICBdLFxuXG4gIHByb3BlcnRpZXM6IFtcbiAgICB7XG4gICAgICBjbGFzczogJ0FycmF5JyxcbiAgICAgIG9mOiAnZm9hbS5ib3guQm94UmVnaXN0cnlCb3gnLFxuICAgICAgbmFtZTogJ2RlbGVnYXRlcycsXG4gICAgICBkb2N1bWVudGF0aW9uOiAnRGVsZWdhdGVzIHRoYXQgcmVjaWV2ZSByZWdpc3RlcigpL3VucmVnaXN0ZXIoKSBjYWxscy4nLFxuICAgIH0sXG4gICAge1xuICAgICAgY2xhc3M6ICdGT2JqZWN0UHJvcGVydHknLFxuICAgICAgb2Y6ICdmb2FtLmJveC5NdWx0aURlbGVnYXRlQm94JyxcbiAgICAgIG5hbWU6ICdkaXNwYXRjaEJveFByb3RvdHlwZScsXG4gICAgICBkb2N1bWVudGF0aW9uOiBgUHJvdG90eXBlIHRoYXQgaXMgY2xvbmUoKWQgdG8gcHJvZHVjZSBhIGJveCB0aGF0XG4gICAgICAgICAgZW5jYXBzdWxhdGVzIGRpc3BhdGNoIHRvIHNlcnZpY2VzIHJlZ2lzdGVyZWQgaW4gXCJkZWxlZ2F0ZXNcIi5gLFxuICAgICAgZmFjdG9yeTogZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLlJvdW5kUm9iaW5Cb3guY3JlYXRlKCk7IH1cbiAgICB9LFxuICAgIHtcbiAgICAgIGNsYXNzOiAnQXJyYXknLFxuICAgICAgLy8gb2Y6ICdSZWdpc3RyYXRpb24nLFxuICAgICAgbmFtZTogJ3JlZ2lzdHJhdGlvbnNfJyxcbiAgICAgIGRvY3VtZW50YXRpb246IGBBcnJheSBvZiBSZWdpc3RyYXRpb24gYmluZGluZ3MgdXNlZCB0byBjb29yZGluYXRlXG4gICAgICAgICAgdW5yZWdpc3RlcigpIGFtb25nIHNlbGYgYW5kIGRlbGVnYXRlcy5gXG4gICAgfVxuICBdLFxuXG4gIG1ldGhvZHM6IFtcbiAgICBmdW5jdGlvbiByZWdpc3RlcihuYW1lLCBzZXJ2aWNlLCBib3gpIHtcbiAgICAgIHZhciBkZWxlZ2F0ZXMgPSB0aGlzLmRlbGVnYXRlcztcbiAgICAgIHZhciBkaXNwYXRjaERlbGVnYXRlcyA9IG5ldyBBcnJheShkZWxlZ2F0ZXMubGVuZ3RoKTtcbiAgICAgIHZhciBkaXNwYXRjaERlbGVnYXRlTmFtZXMgPSBuZXcgQXJyYXkoZGVsZWdhdGVzLmxlbmd0aCk7XG4gICAgICBmb3IgKCB2YXIgaSA9IDA7IGkgPCBkZWxlZ2F0ZXMubGVuZ3RoOyBpKysgKSB7XG4gICAgICAgIHZhciBkZWxlZ2F0ZU5hbWUgPSBkaXNwYXRjaERlbGVnYXRlTmFtZXNbaV0gPSBmb2FtLnV1aWQucmFuZG9tR1VJRCgpO1xuICAgICAgICBkaXNwYXRjaERlbGVnYXRlc1tpXSA9IGRlbGVnYXRlc1tpXS5yZWdpc3RlcihkZWxlZ2F0ZU5hbWUsIG51bGwsIGJveCk7XG4gICAgICB9XG4gICAgICB2YXIgZGlzcGF0Y2hCb3ggPSB0aGlzLmRpc3BhdGNoQm94UHJvdG90eXBlLmNsb25lKHRoaXMpO1xuICAgICAgZGlzcGF0Y2hCb3guZGVsZWdhdGVzID0gZGlzcGF0Y2hEZWxlZ2F0ZXM7XG5cbiAgICAgIHZhciByZXQgPSB0aGlzLlNVUEVSKG5hbWUsIHNlcnZpY2UsIGRpc3BhdGNoQm94KTtcbiAgICAgIHRoaXMucmVnaXN0cmF0aW9uc18ucHVzaCh0aGlzLlJlZ2lzdHJhdGlvbi5jcmVhdGUoe1xuICAgICAgICBuYW1lOiBuYW1lLFxuICAgICAgICBkZWxlZ2F0ZU5hbWVzOiBkaXNwYXRjaERlbGVnYXRlTmFtZXMsXG4gICAgICAgIHJlZ2lzdGVyZWRCb3g6IHJldFxuICAgICAgfSkpO1xuXG4gICAgICByZXR1cm4gcmV0O1xuICAgIH0sXG4gICAgZnVuY3Rpb24gdW5yZWdpc3RlcihuYW1lT3JCb3gpIHtcbiAgICAgIHZhciByZWdpc3RlcmVkQm94O1xuICAgICAgdmFyIGlucHV0SXNCb3ggPSB0aGlzLkJveC5pc0luc3RhbmNlKG5hbWVPckJveCk7XG4gICAgICBpZiAoIGlucHV0SXNCb3ggKSB7XG4gICAgICAgIHJlZ2lzdGVyZWRCb3ggPSBuYW1lT3JCb3g7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZWdpc3RlcmVkQm94ID0gdGhpcy5yZWdpc3RyeV9bbmFtZU9yQm94XS5leHBvcnRCb3g7XG4gICAgICAgIC8vIFdoZW4gbmFtZSBpcyBrbm93biwgdW5yZWdpc3RlciBpdC5cbiAgICAgICAgdGhpcy5TVVBFUihuYW1lT3JCb3gpO1xuICAgICAgfVxuXG4gICAgICB2YXIgcmVnaXN0cmF0aW9uO1xuICAgICAgdmFyIHJlZ2lzdHJhdGlvbnMgPSB0aGlzLnJlZ2lzdHJhdGlvbnNfO1xuICAgICAgZm9yICggdmFyIGkgPSAwOyBpIDwgcmVnaXN0cmF0aW9ucy5sZW5ndGg7IGkrKyApIHtcbiAgICAgICAgaWYgKCByZWdpc3RyYXRpb25zW2ldLnJlZ2lzdGVyZWRCb3ggIT09IHJlZ2lzdGVyZWRCb3ggKVxuICAgICAgICAgIGNvbnRpbnVlO1xuXG4gICAgICAgIC8vIFdoZW4gbmFtZSB3YXMgcHJldmlvdXNseSB1bmtub3duLCByZW1vdmUgZnJvbSByZWdpc3RyeV8gbm93IHRoYXRcbiAgICAgICAgLy8gaXQgaXMga25vd24uXG4gICAgICAgIGlmICggaW5wdXRJc0JveCApIGRlbGV0ZSB0aGlzLnJlZ2lzdHJ5X1tyZWdpc3RyYXRpb25zW2ldLm5hbWVdO1xuXG4gICAgICAgIHJlZ2lzdHJhdGlvbiA9IHJlZ2lzdHJhdGlvbnNbaV07XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBmb2FtLmFzc2VydChyZWdpc3RyYXRpb24sXG4gICAgICAgICAgICAgICAgICAnQnJvYWRjYXN0UmVnaXN0cnkgZXhwZWN0cyB0byBmaW5kIHJlZ2lzdHJhdGlvbicpO1xuXG4gICAgICB2YXIgZGVsZWdhdGVzID0gdGhpcy5kZWxlZ2F0ZXM7XG4gICAgICBmb3IgKCB2YXIgaSA9IDA7IGkgPCBkZWxlZ2F0ZXMubGVuZ3RoOyBpKysgKSB7XG4gICAgICAgIGRlbGVnYXRlc1tpXS51bnJlZ2lzdGVyKHJlZ2lzdHJhdGlvbi5kZWxlZ2F0ZU5hbWVzW2ldKTtcbiAgICAgIH1cbiAgICB9XG4gIF1cbn0pO1xuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgVGhlIEZPQU0gQXV0aG9ycy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuZm9hbS5DTEFTUyh7XG4gIHBhY2thZ2U6ICdmb2FtLmJveCcsXG4gIG5hbWU6ICdMb29rdXBCb3gnLFxuICBleHRlbmRzOiAnZm9hbS5ib3guUHJveHlCb3gnLFxuXG4gIHJlcXVpcmVzOiBbXG4gICAgJ2ZvYW0uYm94LkNsaWVudEJveFJlZ2lzdHJ5JyxcbiAgICAnZm9hbS5ib3guQW5vbnltb3VzQm94J1xuICBdLFxuXG4gIHByb3BlcnRpZXM6IFtcbiAgICB7XG4gICAgICBjbGFzczogJ1N0cmluZycsXG4gICAgICBuYW1lOiAnbmFtZSdcbiAgICB9LFxuICAgIHtcbiAgICAgIG5hbWU6ICdwYXJlbnRCb3gnXG4gICAgfSxcbiAgICB7XG4gICAgICBjbGFzczogJ0ZPYmplY3RQcm9wZXJ0eScsXG4gICAgICBvZjogJ2ZvYW0uYm94LkJveFJlZ2lzdHJ5JyxcbiAgICAgIG5hbWU6ICdyZWdpc3RyeScsXG4gICAgICB0cmFuc2llbnQ6IHRydWUsXG4gICAgICBmYWN0b3J5OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuQ2xpZW50Qm94UmVnaXN0cnkuY3JlYXRlKHtcbiAgICAgICAgICBkZWxlZ2F0ZTogdGhpcy5wYXJlbnRCb3hcbiAgICAgICAgfSk7XG4gICAgICB9LFxuICAgICAgc3dpZnRGYWN0b3J5OiBmdW5jdGlvbigpIHsvKlxucmV0dXJuIENsaWVudEJveFJlZ2lzdHJ5X2NyZWF0ZShbXG4gIFwiZGVsZWdhdGVcIjogcGFyZW50Qm94XG5dKVxuICAgICAgKi99XG4gICAgfSxcbiAgICB7XG4gICAgICBuYW1lOiAnZGVsZWdhdGUnLFxuICAgICAgdHJhbnNpZW50OiB0cnVlLFxuICAgICAgZmFjdG9yeTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlZ2lzdHJ5LmRvTG9va3VwKHRoaXMubmFtZSk7XG4gICAgICB9LFxuICAgICAgc3dpZnRGYWN0b3J5OiAncmV0dXJuIHRyeSEgcmVnaXN0cnkhLmRvTG9va3VwKG5hbWUpJyxcbiAgICB9XG4gIF0sXG4gIG1ldGhvZHM6IFtcbiAgICBmdW5jdGlvbiBzZW5kKG1zZykge1xuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgdmFyIHJlcGx5Qm94ID0gbXNnLmF0dHJpYnV0ZXMucmVwbHlCb3g7XG5cbiAgICAgIG1zZy5hdHRyaWJ1dGVzLnJlcGx5Qm94ID0gdGhpcy5Bbm9ueW1vdXNCb3guY3JlYXRlKHtcbiAgICAgICAgZjogZnVuY3Rpb24obSkge1xuICAgICAgICAgIGlmICggZm9hbS5jb3JlLkV4Y2VwdGlvbi5pc0luc3RhbmNlKG0ub2JqZWN0KSApIHtcbiAgICAgICAgICAgIHNlbGYuZGVsZWdhdGUgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJlcGx5Qm94ICYmIHJlcGx5Qm94LnNlbmQobSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICB0aGlzLmRlbGVnYXRlLnNlbmQobXNnKTtcbiAgICB9XG4gIF1cbn0pO1xuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgVGhlIEZPQU0gQXV0aG9ycy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuZm9hbS5DTEFTUyh7XG4gIHBhY2thZ2U6ICdmb2FtLmJveCcsXG4gIG5hbWU6ICdOYW1lZEJveCcsXG4gIGV4dGVuZHM6ICdmb2FtLmJveC5Qcm94eUJveCcsXG5cbiAgcmVxdWlyZXM6IFtcbiAgICAnZm9hbS5ib3guTG9va3VwQm94JyxcbiAgXSxcblxuICBheGlvbXM6IFtcbiAgICBmb2FtLnBhdHRlcm4uTXVsdGl0b24uY3JlYXRlKHsgcHJvcGVydHk6ICduYW1lJyB9KVxuICBdLFxuXG4gIHByb3BlcnRpZXM6IFtcbiAgICB7XG4gICAgICBjbGFzczogJ1N0cmluZycsXG4gICAgICBuYW1lOiAnbmFtZSdcbiAgICB9LFxuICAgIHtcbiAgICAgIG5hbWU6ICdkZWxlZ2F0ZScsXG4gICAgICB0cmFuc2llbnQ6IHRydWUsXG4gICAgICBmYWN0b3J5OiBmdW5jdGlvbigpIHtcbiAgICAgICAgLy8gUmV0cnlCb3goTG9va3VwQm94KG5hbWUsIE5hbWVkQm94KHN1Yk5hbWUpKSlcbiAgICAgICAgLy8gVE9ETyBBZGQgcmV0cnkgYm94XG4gICAgICAgIHJldHVybiB0aGlzLkxvb2t1cEJveC5jcmVhdGUoe1xuICAgICAgICAgIG5hbWU6IHRoaXMuZ2V0QmFzZU5hbWUoKSxcbiAgICAgICAgICBwYXJlbnRCb3g6IHRoaXMuZ2V0UGFyZW50Qm94KClcbiAgICAgICAgfSk7XG4gICAgICB9LFxuICAgICAgc3dpZnRGYWN0b3J5OiBmdW5jdGlvbigpIHsvKlxucmV0dXJuIHNlbGYuTG9va3VwQm94X2NyZWF0ZShbXG4gIFwibmFtZVwiOiBzZWxmLmdldEJhc2VOYW1lKCksXG4gIFwicGFyZW50Qm94XCI6IHNlbGYuZ2V0UGFyZW50Qm94KClcbl0pXG4gICAgICAqL31cbiAgICB9XG4gIF0sXG5cbiAgbWV0aG9kczogW1xuICAgIHtcbiAgICAgIG5hbWU6ICdnZXRQYXJlbnRCb3gnLFxuICAgICAgcmV0dXJuczogJ2ZvYW0uYm94LkJveCcsXG4gICAgICBjb2RlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xzXy5jcmVhdGUoe1xuICAgICAgICAgIG5hbWU6IHRoaXMubmFtZS5zdWJzdHJpbmcoMCwgdGhpcy5uYW1lLmxhc3RJbmRleE9mKCcvJykpXG4gICAgICAgIH0sIHRoaXMpO1xuICAgICAgfSxcbiAgICAgIHN3aWZ0Q29kZTogZnVuY3Rpb24oKSB7LypcbnZhciBuYW1lID0gXCJcIlxuaWYgbGV0IGluZGV4ID0gc2VsZi5uYW1lLnJhbmdlKG9mOiBcIi9cIiwgb3B0aW9uczogLmJhY2t3YXJkcyk/Lmxvd2VyQm91bmQge1xuICBuYW1lID0gU3RyaW5nKHNlbGYubmFtZVsuLjxpbmRleF0pXG59XG5yZXR1cm4gb3duQ2xhc3NJbmZvKCkuY3JlYXRlKGFyZ3M6IFtcbiAgXCJuYW1lXCI6IG5hbWVcbl0sIHg6IF9fc3ViQ29udGV4dF9fKSBhcyEgQm94XG4gICAgICAqL30sXG4gICAgfSxcbiAgICB7XG4gICAgICBuYW1lOiAnZ2V0QmFzZU5hbWUnLFxuICAgICAgcmV0dXJuczogJ1N0cmluZycsXG4gICAgICBjb2RlOiBmdW5jdGlvbiBnZXRCYXNlTmFtZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubmFtZS5zdWJzdHJpbmcodGhpcy5uYW1lLmxhc3RJbmRleE9mKCcvJykgKyAxKTtcbiAgICAgIH0sXG4gICAgICBzd2lmdENvZGU6IGZ1bmN0aW9uIGdldEJhc2VOYW1lKCkgey8qXG5pZiBsZXQgaW5kZXggPSBuYW1lLnJhbmdlKG9mOiBcIi9cIiwgb3B0aW9uczogLmJhY2t3YXJkcyk/Lmxvd2VyQm91bmQge1xuICByZXR1cm4gU3RyaW5nKG5hbWVbbmFtZS5pbmRleChhZnRlcjogaW5kZXgpLi48bmFtZS5lbmRJbmRleF0pXG59XG5yZXR1cm4gXCJcIlxuICAgICAgKi99LFxuICAgIH0sXG4gIF1cbn0pO1xuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgVGhlIEZPQU0gQXV0aG9ycy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuZm9hbS5DTEFTUyh7XG4gIHBhY2thZ2U6ICdmb2FtLmJveCcsXG4gIG5hbWU6ICdSZXBseUJveCcsXG4gIGV4dGVuZHM6ICdmb2FtLmJveC5Qcm94eUJveCcsXG5cbiAgaW1wb3J0czogW1xuICAgIHtcbiAgICAgIG5hbWU6ICdyZWdpc3RyeScsXG4gICAgICBrZXk6ICdyZWdpc3RyeScsXG4gICAgICBqYXZhVHlwZTogJ2ZvYW0uYm94LkJveFJlZ2lzdHJ5J1xuICAgIH1cbiAgXSxcblxuICBwcm9wZXJ0aWVzOiBbXG4gICAge1xuICAgICAgY2xhc3M6ICdTdHJpbmcnLFxuICAgICAgbmFtZTogJ2lkJyxcbiAgICAgIGZhY3Rvcnk6IGZ1bmN0aW9uKCkge1xuICAgICAgICAvLyBUT0RPOiBEbyB0aGVzZSBuZWVkIHRvIGJlIGxvbmcgbGl2ZWQ/XG4gICAgICAgIC8vIFNvbWVvbmUgY291bGQgc3RvcmUgYSBib3ggZm9yIGRheXMgYW5kIHRoZW4gdXNlIGl0XG4gICAgICAgIC8vIGF0IHRoYXQgcG9pbnQgdGhlIElEIG1pZ2h0IG5vIGxvbmdlciBiZSB2YWxpZC5cbiAgICAgICAgcmV0dXJuIGZvYW0ubmV4dCRVSUQoKTtcbiAgICAgIH0sXG4gICAgICBzd2lmdEZhY3Rvcnk6ICdyZXR1cm4gVVVJRCgpLnV1aWRTdHJpbmcnLFxuICAgIH0sXG4gICAge1xuICAgICAgbmFtZTogJ2RlbGVnYXRlJyxcbiAgICAgIHRyYW5zaWVudDogdHJ1ZVxuICAgIH1cbiAgXSxcblxuICBtZXRob2RzOiBbXG4gICAge1xuICAgICAgbmFtZTogJ3NlbmQnLFxuICAgICAgY29kZTogZnVuY3Rpb24gc2VuZChtc2cpIHtcbiAgICAgICAgdGhpcy5yZWdpc3RyeS51bnJlZ2lzdGVyKHRoaXMuaWQpO1xuICAgICAgICB0aGlzLmRlbGVnYXRlLnNlbmQobXNnKTtcbiAgICAgIH0sXG4gICAgICBzd2lmdENvZGU6IGZ1bmN0aW9uKCkgey8qXG4ocmVnaXN0cnkgYXMhIEJveFJlZ2lzdHJ5KS51bnJlZ2lzdGVyKGlkKVxudHJ5IGRlbGVnYXRlLnNlbmQobXNnKVxuICAgICAgKi99LFxuICAgICAgamF2YUNvZGU6IGBcbmdldFJlZ2lzdHJ5KCkudW5yZWdpc3RlcihnZXRJZCgpKTtcbmdldERlbGVnYXRlKCkuc2VuZChtZXNzYWdlKTtcbmBcbiAgICB9XG4gIF1cbn0pO1xuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgVGhlIEZPQU0gQXV0aG9ycy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuZm9hbS5DTEFTUyh7XG4gIHBhY2thZ2U6ICdmb2FtLmJveCcsXG4gIG5hbWU6ICdGdW5jdGlvbkJveCcsXG4gIGltcGxlbWVudHM6IFsnZm9hbS5ib3guQm94J10sXG4gIHByb3BlcnRpZXM6IFtcbiAgICB7XG4gICAgICBjbGFzczogJ0Z1bmN0aW9uJyxcbiAgICAgIHN3aWZ0VHlwZTogJygoQW55PykgLT4gKCkpJyxcbiAgICAgIHN3aWZ0UmVxdWlyZXNFc2NhcGluZzogdHJ1ZSxcbiAgICAgIG5hbWU6ICdmbidcbiAgICB9XG4gIF0sXG4gIG1ldGhvZHM6IFtcbiAgICB7XG4gICAgICBuYW1lOiAnc2VuZCcsXG4gICAgICBjb2RlOiBmdW5jdGlvbiBzZW5kKG0pIHtcbiAgICAgICAgdGhpcy5mbihtLm9iamVjdCk7XG4gICAgICB9LFxuICAgICAgc3dpZnRDb2RlOiAnZm4obXNnLm9iamVjdCknLFxuICAgIH0sXG4gIF1cbn0pO1xuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgVGhlIEZPQU0gQXV0aG9ycy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuZm9hbS5DTEFTUyh7XG4gIHBhY2thZ2U6ICdmb2FtLmJveCcsXG4gIG5hbWU6ICdSUENSZXR1cm5NZXNzYWdlJyxcbiAgZXh0ZW5kczogJ2ZvYW0uYm94Lk1lc3NhZ2UnLFxuICBwcm9wZXJ0aWVzOiBbXG4gICAge1xuICAgICAgY2xhc3M6ICdPYmplY3QnLFxuICAgICAgbmFtZTogJ2RhdGEnXG4gICAgfVxuICBdXG59KTtcbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IFRoZSBGT0FNIEF1dGhvcnMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmZvYW0uQ0xBU1Moe1xuICBwYWNrYWdlOiAnZm9hbS5ib3gnLFxuICBuYW1lOiAnUlBDRXJyb3JNZXNzYWdlJyxcbiAgaW1wbGVtZW50czogWydmb2FtLmNvcmUuRXhjZXB0aW9uJ10sXG4gIHByb3BlcnRpZXM6IFtcbiAgICB7XG4gICAgICBjbGFzczogJ09iamVjdCcsXG4gICAgICBuYW1lOiAnZGF0YSdcbiAgICB9XG4gIF1cbn0pO1xuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgVGhlIEZPQU0gQXV0aG9ycy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuZm9hbS5DTEFTUyh7XG4gIHBhY2thZ2U6ICdmb2FtLmJveCcsXG4gIG5hbWU6ICdTdWJzY3JpYmVNZXNzYWdlJyxcbiAgcHJvcGVydGllczogW1xuICAgIHtcbiAgICAgIG5hbWU6ICd0b3BpYydcbiAgICB9LFxuICAgIHtcbiAgICAgIG5hbWU6ICdkZXN0aW5hdGlvbidcbiAgICB9XG4gIF1cbn0pO1xuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgVGhlIEZPQU0gQXV0aG9ycy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuZm9hbS5DTEFTUyh7XG4gIHBhY2thZ2U6ICdmb2FtLmJveCcsXG4gIG5hbWU6ICdSUENSZXR1cm5Cb3gnLFxuXG4gIGltcGxlbWVudHM6IFsgJ2ZvYW0uYm94LkJveCcgXSxcblxuICByZXF1aXJlczogW1xuICAgICdmb2FtLmJveC5SUENSZXR1cm5NZXNzYWdlJyxcbiAgICAnZm9hbS5ib3guUlBDRXJyb3JNZXNzYWdlJ1xuICBdLFxuXG4gIHByb3BlcnRpZXM6IFtcbiAgICB7XG4gICAgICBuYW1lOiAncHJvbWlzZScsXG4gICAgICBmYWN0b3J5OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgIHRoaXMucmVzb2x2ZV8gPSByZXNvbHZlO1xuICAgICAgICAgIHRoaXMucmVqZWN0XyA9IHJlamVjdDtcbiAgICAgICAgfS5iaW5kKHRoaXMpKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHtcbiAgICAgIG5hbWU6ICdyZXNvbHZlXydcbiAgICB9LFxuICAgIHtcbiAgICAgIG5hbWU6ICdyZWplY3RfJ1xuICAgIH0sXG4gICAge1xuICAgICAgY2xhc3M6ICdPYmplY3QnLFxuICAgICAgbmFtZTogJ3NlbWFwaG9yZScsXG4gICAgICBqYXZhVHlwZTogJ2phdmEudXRpbC5jb25jdXJyZW50LlNlbWFwaG9yZScsXG4gICAgICBqYXZhRmFjdG9yeTogJ3JldHVybiBuZXcgamF2YS51dGlsLmNvbmN1cnJlbnQuU2VtYXBob3JlKDApOydcbiAgICB9LFxuICAgIHtcbiAgICAgIGNsYXNzOiAnT2JqZWN0JyxcbiAgICAgIG5hbWU6ICdtZXNzYWdlJyxcbiAgICAgIGphdmFUeXBlOiAnZm9hbS5ib3guTWVzc2FnZSdcbiAgICB9XG4gIF0sXG5cbiAgbWV0aG9kczogW1xuICAgIHtcbiAgICAgIG5hbWU6ICdzZW5kJyxcbiAgICAgIGNvZGU6IGZ1bmN0aW9uIHNlbmQobXNnKSB7XG4gICAgICAgIGlmICggdGhpcy5SUENSZXR1cm5NZXNzYWdlLmlzSW5zdGFuY2UobXNnLm9iamVjdCkgKSB7XG4gICAgICAgICAgdGhpcy5yZXNvbHZlXyhtc2cub2JqZWN0LmRhdGEpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIHRoaXMuUlBDRXJyb3JNZXNzYWdlLmlzSW5zdGFuY2UobXNnLm9iamVjdCkgKSB7XG4gICAgICAgICAgdGhpcy5yZWplY3RfKG1zZy5vYmplY3QuZGF0YSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICggZm9hbS5jb3JlLkV4Y2VwdGlvbi5pc0luc3RhbmNlKG1zZy5vYmplY3QpICkge1xuICAgICAgICAgIHRoaXMucmVqZWN0Xyhtc2cub2JqZWN0KTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCBtc2cub2JqZWN0IGluc3RhbmNlb2YgRXJyb3IgKSB7XG4gICAgICAgICAgdGhpcy5yZWplY3RfKG1zZy5vYmplY3QpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMud2FybignSW52YWxpZCBtZXNzYWdlIHRvIFJQQ1JldHVybkJveC4nKTtcbiAgICAgIH0sXG4gICAgICBqYXZhQ29kZTogYFxuc2V0TWVzc2FnZShtZXNzYWdlKTtcbmdldFNlbWFwaG9yZSgpLnJlbGVhc2UoKTtcbmBcbiAgICB9XG4gIF1cbn0pO1xuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgVGhlIEZPQU0gQXV0aG9ycy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuZm9hbS5DTEFTUyh7XG4gIHBhY2thZ2U6ICdmb2FtLmJveCcsXG4gIG5hbWU6ICdSUENNZXNzYWdlJyxcbiAgZXh0ZW5kczogJ2ZvYW0uYm94Lk1lc3NhZ2UnLFxuICBwcm9wZXJ0aWVzOiBbXG4gICAge1xuICAgICAgY2xhc3M6ICdTdHJpbmcnLFxuICAgICAgbmFtZTogJ25hbWUnXG4gICAgfSxcbiAgICB7XG4gICAgICBjbGFzczogJ0FycmF5JyxcbiAgICAgIG5hbWU6ICdhcmdzJ1xuICAgIH1cbiAgXVxufSk7XG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBUaGUgRk9BTSBBdXRob3JzLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5mb2FtLkNMQVNTKHtcbiAgcGFja2FnZTogJ2ZvYW0uZGFvJyxcbiAgbmFtZTogJ0Jhc2VDbGllbnREQU8nLFxuICBleHRlbmRzOiAnZm9hbS5kYW8uQWJzdHJhY3REQU8nLFxuXG4gIHByb3BlcnRpZXM6IFtcbiAgICB7XG4gICAgICBjbGFzczogJ1N0dWInLFxuICAgICAgb2Y6ICdmb2FtLmRhby5EQU8nLFxuICAgICAgbmFtZTogJ2RlbGVnYXRlJyxcbiAgICAgIG1ldGhvZHM6IFtcbiAgICAgICAgJ3B1dF8nLFxuICAgICAgICAncmVtb3ZlXycsXG4gICAgICAgICdyZW1vdmVBbGxfJyxcbiAgICAgICAgJ3NlbGVjdF8nLFxuICAgICAgICAnbGlzdGVuXycsXG4gICAgICAgICdmaW5kXydcbiAgICAgIF1cbiAgICB9XG4gIF1cbn0pO1xuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgVGhlIEZPQU0gQXV0aG9ycy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuZm9hbS5DTEFTUyh7XG4gIHBhY2thZ2U6ICdmb2FtLmRhbycsXG4gIG5hbWU6ICdNZXJnZUJveCcsXG4gIGV4dGVuZHM6ICdmb2FtLmJveC5Qcm94eUJveCcsXG4gIHByb3BlcnRpZXM6IFtcbiAgICB7XG4gICAgICBjbGFzczogJ0ludCcsXG4gICAgICBuYW1lOiAnZGVsYXknLFxuICAgICAgdmFsdWU6IDEwMFxuICAgIH0sXG4gICAge1xuICAgICAgbmFtZTogJ21zZycsXG4gICAgICB0cmFuc2llbnQ6IHRydWVcbiAgICB9LFxuICAgIHtcbiAgICAgIGNsYXNzOiAnQXJyYXknLFxuICAgICAgbmFtZTogJ3F1ZXVlJyxcbiAgICAgIHRyYW5zaWVudDogdHJ1ZVxuICAgIH1cbiAgXSxcbiAgbWV0aG9kczogW1xuICAgIGZ1bmN0aW9uIHNlbmQobSkge1xuICAgICAgaWYgKCAhIHRoaXMudGltZW91dCApIHtcbiAgICAgIH1cbiAgICB9XG4gIF0sXG4gIGxpc3RlbmVyczogW1xuICAgIGZ1bmN0aW9uIGRvU2VuZCgpIHtcbiAgICAgIHZhciBxdWV1ZSA9IHRoaXMucXVldWU7XG4gICAgICB0aGlzLnF1ZXVlID0gdW5kZWZpbmVkO1xuICAgICAgdGhpcy50aW1lb3V0ID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgXVxufSk7XG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBUaGUgRk9BTSBBdXRob3JzLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5mb2FtLkNMQVNTKHtcbiAgcGFja2FnZTogJ2ZvYW0uZGFvJyxcbiAgbmFtZTogJ1Jlc2V0U2luaycsXG4gIGV4dGVuZHM6ICdmb2FtLmRhby5Qcm94eVNpbmsnLFxuICBtZXRob2RzOiBbXG4gICAge1xuICAgICAgbmFtZTogJ3B1dCcsXG4gICAgICBjb2RlOiBmdW5jdGlvbihvYmosIHN1YikgeyB0aGlzLnJlc2V0KHN1Yik7IH0sXG4gICAgICBqYXZhQ29kZTogJ3Jlc2V0KHN1Yik7J1xuICAgIH0sXG4gICAge1xuICAgICAgbmFtZTogJ3JlbW92ZScsXG4gICAgICBjb2RlOiBmdW5jdGlvbihvYmosIHN1YikgeyB0aGlzLnJlc2V0KHN1Yik7IH0sXG4gICAgICBqYXZhQ29kZTogJ3Jlc2V0KHN1Yik7J1xuICAgIH1cbiAgXVxufSk7XG5cbmZvYW0uQ0xBU1Moe1xuICBwYWNrYWdlOiAnZm9hbS5kYW8nLFxuICBuYW1lOiAnTWVyZ2VkUmVzZXRTaW5rJyxcbiAgZXh0ZW5kczogJ2ZvYW0uZGFvLlJlc2V0U2luaycsXG4gIG1ldGhvZHM6IFtcbiAgICB7XG4gICAgICBuYW1lOiAncmVzZXQnLFxuICAgICAgY29kZTogZnVuY3Rpb24oc3ViKSB7IHRoaXMuZG9SZXNldChzdWIpOyB9LFxuICAgICAgamF2YUNvZGU6IGBkb1Jlc2V0KHN1Yik7YFxuICAgIH1cbiAgXSxcbiAgbGlzdGVuZXJzOiBbXG4gICAge1xuICAgICAgbmFtZTogJ2RvUmVzZXQnLFxuICAgICAgaXNNZXJnZWQ6IHRydWUsXG4gICAgICBtZXJnZURlbGF5OiAyMDAsXG4gICAgICBjb2RlOiBmdW5jdGlvbihzdWIpIHtcbiAgICAgICAgdGhpcy5kZWxlZ2F0ZS5yZXNldChzdWIpO1xuICAgICAgfSxcbiAgICAgIGphdmFDb2RlOiBgXG50cnkge1xuICBnZXREZWxlZ2F0ZSgpLnJlc2V0KHN1Yik7XG59IGNhdGNoKEV4Y2VwdGlvbiBlKSB7XG4gIHN1Yi5kZXRhY2goKTtcbn1cbmBcbiAgICB9XG4gIF1cbn0pO1xuXG5mb2FtLkNMQVNTKHtcbiAgcGFja2FnZTogJ2ZvYW0uZGFvJyxcbiAgbmFtZTogJ0NsaWVudERBTycsXG4gIGV4dGVuZHM6ICdmb2FtLmRhby5CYXNlQ2xpZW50REFPJyxcblxuICByZXF1aXJlczogW1xuICAgICdmb2FtLmJveC5Ta2VsZXRvbkJveCcsXG4gICAgJ2ZvYW0uY29yZS5TZXJpYWxpemFibGUnLFxuICAgICdmb2FtLmRhby5BcnJheVNpbmsnLFxuICAgICdmb2FtLmRhby5DbGllbnRTaW5rJyxcbiAgXSxcblxuICBtZXRob2RzOiBbXG4gICAge1xuICAgICAgbmFtZTogJ3B1dF8nLFxuICAgICAgY29kZTogICAgIGZ1bmN0aW9uIHB1dF8oeCwgb2JqKSB7XG4gICAgICAgIHJldHVybiB0aGlzLlNVUEVSKG51bGwsIG9iaik7XG4gICAgICB9LFxuICAgICAgamF2YUNvZGU6IGBcbnJldHVybiBzdXBlci5wdXRfKG51bGwsIG9iaik7XG5gLFxuICAgICAgc3dpZnRDb2RlOiAncmV0dXJuIHRyeSBzdXBlci5wdXRfKG5pbCwgb2JqKScsXG4gICAgfSxcbiAgICB7XG4gICAgICBuYW1lOiAncmVtb3ZlXycsXG4gICAgICBjb2RlOiBmdW5jdGlvbiByZW1vdmVfKHgsIG9iaikge1xuICAgICAgICByZXR1cm4gdGhpcy5TVVBFUihudWxsLCBvYmopO1xuICAgICAgfSxcbiAgICAgIGphdmFDb2RlOiBgXG5yZXR1cm4gc3VwZXIucmVtb3ZlXyhudWxsLCBvYmopO1xuYCxcbiAgICAgIHN3aWZ0Q29kZTogJ3JldHVybiB0cnkgc3VwZXIucmVtb3ZlXyhuaWwsIG9iaiknLFxuICAgIH0sXG4gICAge1xuICAgICAgbmFtZTogJ2ZpbmRfJyxcbiAgICAgIGNvZGU6ICAgICBmdW5jdGlvbiBmaW5kXyh4LCBrZXkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuU1VQRVIobnVsbCwga2V5KTtcbiAgICAgIH0sXG4gICAgICBqYXZhQ29kZTogYFxucmV0dXJuIHN1cGVyLmZpbmRfKG51bGwsIGlkKTtcbmAsXG4gICAgICBzd2lmdENvZGU6ICdyZXR1cm4gdHJ5IHN1cGVyLmZpbmRfKG5pbCwgaWQpJyxcbiAgICB9LFxuICAgIHtcbiAgICAgIG5hbWU6ICdzZWxlY3RfJyxcbiAgICAgIGNvZGU6IGZ1bmN0aW9uIHNlbGVjdF8oeCwgc2luaywgc2tpcCwgbGltaXQsIG9yZGVyLCBwcmVkaWNhdGUpIHtcbiAgICAgICAgaWYgKCBwcmVkaWNhdGUgPT09IGZvYW0ubWxhbmcucHJlZGljYXRlLlRydWUuY3JlYXRlKCkgKSBwcmVkaWNhdGUgPSBudWxsO1xuICAgICAgICBpZiAoICEgc2tpcCApIHNraXAgPSAwO1xuICAgICAgICBpZiAoIGZvYW0uVW5kZWZpbmVkLmlzSW5zdGFuY2UobGltaXQpICkgbGltaXQgPSBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUjtcblxuICAgICAgICBpZiAoICEgdGhpcy5TZXJpYWxpemFibGUuaXNJbnN0YW5jZShzaW5rKSApIHtcbiAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICAgICAgICByZXR1cm4gdGhpcy5TVVBFUihudWxsLCBmb2FtLmRhby5BcnJheVNpbmsuY3JlYXRlKCksIHNraXAsIGxpbWl0LCBvcmRlciwgcHJlZGljYXRlKS50aGVuKGZ1bmN0aW9uKHJlc3VsdCkge1xuICAgICAgICAgICAgdmFyIGl0ZW1zID0gcmVzdWx0LmFycmF5O1xuXG4gICAgICAgICAgICBpZiAoICEgc2luayApIHJldHVybiByZXN1bHQ7XG5cbiAgICAgICAgICAgIHZhciBzdWIgPSBmb2FtLmNvcmUuRk9iamVjdC5jcmVhdGUoKTtcbiAgICAgICAgICAgIHZhciBkZXRhY2hlZCA9IGZhbHNlO1xuICAgICAgICAgICAgc3ViLm9uRGV0YWNoKGZ1bmN0aW9uKCkgeyBkZXRhY2hlZCA9IHRydWU7IH0pO1xuXG4gICAgICAgICAgICBmb3IgKCB2YXIgaSA9IDAgOyBpIDwgaXRlbXMubGVuZ3RoIDsgaSsrICkge1xuICAgICAgICAgICAgICBpZiAoIGRldGFjaGVkICkgYnJlYWs7XG5cbiAgICAgICAgICAgICAgc2luay5wdXQoaXRlbXNbaV0sIHN1Yik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHNpbmsuZW9mKCk7XG5cbiAgICAgICAgICAgIHJldHVybiBzaW5rO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuU1VQRVIobnVsbCwgc2luaywgc2tpcCwgbGltaXQsIG9yZGVyLCBwcmVkaWNhdGUpO1xuICAgICAgfSxcbiAgICAgIGphdmFDb2RlOiBgXG5yZXR1cm4gc3VwZXIuc2VsZWN0XyhudWxsLCBzaW5rLCBza2lwLCBsaW1pdCwgb3JkZXIsIHByZWRpY2F0ZSk7XG5gLFxuICAgICAgc3dpZnRDb2RlOiBgXG5pZiBzaW5rIGlzIFNlcmlhbGl6YWJsZSB7XG4gIHJldHVybiB0cnkgc3VwZXIuc2VsZWN0XyhuaWwsIHNpbmssIHNraXAsIGxpbWl0LCBvcmRlciwgcHJlZGljYXRlKVxufVxubGV0IHJlc3VsdCA9IHRyeSBzdXBlci5zZWxlY3RfKG5pbCwgQXJyYXlTaW5rX2NyZWF0ZSgpLCBza2lwLCBsaW1pdCwgb3JkZXIsIHByZWRpY2F0ZSkgYXMhIEFycmF5U2lua1xudmFyIGRldGFjaGVkID0gZmFsc2VcbmxldCBzdWIgPSBTdWJzY3JpcHRpb24geyBkZXRhY2hlZCA9IHRydWUgfVxuZm9yIG8gaW4gcmVzdWx0LmFycmF5IHtcbiAgaWYgZGV0YWNoZWQgeyBicmVhayB9XG4gIHNpbmsucHV0KG8sIHN1Yilcbn1cbnNpbmsuZW9mKClcbnJldHVybiBzaW5rXG5gLFxuICAgIH0sXG5cbiAgICB7XG4gICAgICBuYW1lOiAncmVtb3ZlQWxsXycsXG4gICAgICBjb2RlOiBmdW5jdGlvbiByZW1vdmVBbGxfKHgsIHNraXAsIGxpbWl0LCBvcmRlciwgcHJlZGljYXRlKSB7XG4gICAgICAgIGlmICggcHJlZGljYXRlID09PSBmb2FtLm1sYW5nLnByZWRpY2F0ZS5UcnVlLmNyZWF0ZSgpICkgcHJlZGljYXRlID0gbnVsbDtcbiAgICAgICAgaWYgKCAhIHNraXAgKSBza2lwID0gMDtcbiAgICAgICAgaWYgKCBmb2FtLlVuZGVmaW5lZC5pc0luc3RhbmNlKGxpbWl0KSApIGxpbWl0ID0gTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVI7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuU1VQRVIobnVsbCwgc2tpcCwgbGltaXQsIG9yZGVyLCBwcmVkaWNhdGUpO1xuICAgICAgfSxcbiAgICAgIGphdmFDb2RlOiBgXG5zdXBlci5yZW1vdmVBbGxfKG51bGwsIHNraXAsIGxpbWl0LCBvcmRlciwgcHJlZGljYXRlKTtcbmAsXG4gICAgICBzd2lmdENvZGU6ICd0cnkgc3VwZXIucmVtb3ZlQWxsXyhuaWwsIHNraXAsIGxpbWl0LCBvcmRlciwgcHJlZGljYXRlKScsXG4gICAgfSxcblxuICAgIHtcbiAgICAgIG5hbWU6ICdsaXN0ZW5fJyxcbiAgICAgIGNvZGU6IGZ1bmN0aW9uIGxpc3Rlbl8oeCwgc2luaywgcHJlZGljYXRlKSB7XG4gICAgICAgIHRoaXMuU1VQRVIobnVsbCwgc2luaywgcHJlZGljYXRlKTtcbiAgICAgICAgcmV0dXJuIGZvYW0uY29yZS5GT2JqZWN0LmNyZWF0ZSgpO1xuICAgICAgfSxcbiAgICAgIGphdmFDb2RlOiBgc3VwZXIubGlzdGVuXyhudWxsLCBzaW5rLCBwcmVkaWNhdGUpO2AsXG4gICAgICBzd2lmdENvZGU6IGByZXR1cm4gdHJ5IHN1cGVyLmxpc3Rlbl8obmlsLCBzaW5rLCBwcmVkaWNhdGUpYCxcbiAgICB9XG4gIF1cbn0pO1xuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgVGhlIEZPQU0gQXV0aG9ycy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuZm9hbS5DTEFTUyh7XG4gIHBhY2thZ2U6ICdmb2FtLmRhbycsXG4gIG5hbWU6ICdFdmVudGxlc3NDbGllbnREQU8nLFxuICBleHRlbmRzOiAnZm9hbS5kYW8uQWJzdHJhY3REQU8nLFxuXG4gIHByb3BlcnRpZXM6IFtcbiAgICB7XG4gICAgICBjbGFzczogJ1N0dWInLFxuICAgICAgb2Y6ICdmb2FtLmRhby5EQU8nLFxuICAgICAgbmFtZTogJ2RlbGVnYXRlJyxcbiAgICAgIG1ldGhvZHM6IFtcbiAgICAgICAgJ3B1dF8nLFxuICAgICAgICAncmVtb3ZlXycsXG4gICAgICAgICdzZWxlY3RfJyxcbiAgICAgICAgJ3JlbW92ZUFsbF8nLFxuICAgICAgICAnZmluZF8nXG4gICAgICBdLFxuICAgICAgZXZlbnRQcm94eTogZmFsc2VcbiAgICB9XG4gIF1cbn0pO1xuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgVGhlIEZPQU0gQXV0aG9ycy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuZm9hbS5DTEFTUyh7XG4gIHBhY2thZ2U6ICdmb2FtLmRhbycsXG4gIG5hbWU6ICdQb2xsaW5nQ2xpZW50REFPJyxcbiAgZXh0ZW5kczogJ2ZvYW0uZGFvLkNsaWVudERBTycsXG5cbiAgcmVxdWlyZXM6IFtcbiAgICAnZm9hbS5kYW8uQXJyYXlTaW5rJ1xuICBdLFxuXG4gIG1ldGhvZHM6IFtcbiAgICBmdW5jdGlvbiBwdXRfKHgsIG9iaikge1xuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgcmV0dXJuIHRoaXMuU1VQRVIoeCwgb2JqKS50aGVuKGZ1bmN0aW9uKG8pIHtcbiAgICAgICAgc2VsZi5vbi5wdXQucHViKG8pO1xuICAgICAgICByZXR1cm4gbztcbiAgICAgIH0pO1xuICAgIH0sXG5cbiAgICBmdW5jdGlvbiByZW1vdmVfKHgsIG9iaikge1xuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgcmV0dXJuIHRoaXMuU1VQRVIoeCwgb2JqKS50aGVuKGZ1bmN0aW9uKG8pIHtcbiAgICAgICAgc2VsZi5vbi5yZW1vdmUucHViKG9iaik7XG4gICAgICAgIHJldHVybiBvO1xuICAgICAgfSk7XG4gICAgfSxcblxuICAgIGZ1bmN0aW9uIHJlbW92ZUFsbF8oeCwgc2tpcCwgbGltaXQsIG9yZGVyLCBwcmVkaWNhdGUpIHtcbiAgICAgIHRoaXMuU1VQRVIoeCwgc2tpcCwgbGltaXQsIG9yZGVyLCBwcmVkaWNhdGUpO1xuICAgICAgdGhpcy5vbi5yZXNldC5wdWIoKTtcbiAgICB9XG4gIF1cbn0pO1xuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgVGhlIEZPQU0gQXV0aG9ycy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuZm9hbS5DTEFTUyh7XG4gIHBhY2thZ2U6ICdmb2FtLmRhbycsXG4gIG5hbWU6ICdTdHJlYW1pbmdDbGllbnREQU8nLFxuICBleHRlbmRzOiAnZm9hbS5kYW8uQmFzZUNsaWVudERBTycsXG5cbiAgcmVxdWlyZXM6IFtcbiAgICAnZm9hbS5kYW8uQXJyYXlTaW5rJyxcbiAgICAnZm9hbS5kYW8uQm94REFPTGlzdGVuZXInXG4gIF0sXG4gIGltcG9ydHM6IFsgJ3JlZ2lzdHJ5JyBdLFxuXG4gIGNsYXNzZXM6IFtcbiAgICB7XG4gICAgICBuYW1lOiAnU3RyZWFtaW5nUmVwbHlCb3gnLFxuICAgICAgaW1wbGVtZW50czogWyAnZm9hbS5ib3guQm94JyBdLFxuXG4gICAgICBpbXBvcnRzOiBbICdyZWdpc3RyeScgXSxcblxuICAgICAgcHJvcGVydGllczogW1xuICAgICAgICB7XG4gICAgICAgICAgbmFtZTogJ2lkJyxcbiAgICAgICAgICBmYWN0b3J5OiBmdW5jdGlvbigpIHsgcmV0dXJuIGZvYW0ubmV4dCRVSUQoKTsgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgY2xhc3M6ICdGT2JqZWN0UHJvcGVydHknLFxuICAgICAgICAgIG9mOiAnZm9hbS5kYW8uU2luaycsXG4gICAgICAgICAgbmFtZTogJ3NpbmsnXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICBjbGFzczogJ0Jvb2xlYW4nLFxuICAgICAgICAgIG5hbWU6ICdkZXRhY2hPbkVPRidcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIG5hbWU6ICdwcm9taXNlJyxcbiAgICAgICAgICBmYWN0b3J5OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgICAgc2VsZi5yZXNvbHZlXyA9IHJlc29sdmU7XG4gICAgICAgICAgICAgIHNlbGYucmVqZWN0XyA9IHJlamVjdDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIG5hbWU6ICdzaW5rU3ViJyxcbiAgICAgICAgICBmYWN0b3J5OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBzdWIgPSBmb2FtLmNvcmUuRk9iamVjdC5jcmVhdGUoKTtcbiAgICAgICAgICAgIC8vIFRPRE8obWFya2RpdHRtZXIpOiBOb3RpZnkgcmVtb3RlIERBTyBvZiBkZXRhY2htZW50LlxuICAgICAgICAgICAgc3ViLm9uRGV0YWNoKHRoaXMudW5yZWdpc3RlclNlbGYpO1xuICAgICAgICAgICAgcmV0dXJuIHN1YjtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgICdyZXNvbHZlXycsXG4gICAgICAgICdyZWplY3RfJ1xuICAgICAgXSxcblxuICAgICAgbWV0aG9kczogW1xuICAgICAgICBmdW5jdGlvbiBzZW5kKG1zZykge1xuICAgICAgICAgIC8vIFRPRE8obWFya2RpdHRtZXIpOiBFcnJvciBjaGVjayBtZXNzYWdlIHR5cGUuXG5cbiAgICAgICAgICBzd2l0Y2ggKCBtc2cub2JqZWN0Lm5hbWUgKSB7XG4gICAgICAgICAgICBjYXNlICdwdXQnOlxuICAgICAgICAgICAgICB0aGlzLnNpbmsucHV0KG1zZy5vYmplY3Qub2JqLCB0aGlzLnNpbmtTdWIpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3JlbW92ZSc6XG4gICAgICAgICAgICAgIHRoaXMuc2luay5yZW1vdmUobXNnLm9iamVjdC5vYmosIHRoaXMuc2lua1N1Yik7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnZW9mJzpcbiAgICAgICAgICAgICAgdGhpcy5zaW5rLmVvZigpO1xuICAgICAgICAgICAgICB0aGlzLnJlc29sdmVfKHRoaXMuc2luayk7XG4gICAgICAgICAgICAgIGlmICggdGhpcy5kZXRhY2hPbkVPRiApIHRoaXMuc2lua1N1Yi5kZXRhY2goKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdyZXNldCc6XG4gICAgICAgICAgICAgIHRoaXMuc2luay5yZXNldCgpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIF0sXG5cbiAgICAgIGxpc3RlbmVyczogW1xuICAgICAgICBmdW5jdGlvbiByZWdpc3RlclNlbGYoKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZXhwb3J0Qm94XyA9IHRoaXMucmVnaXN0cnkucmVnaXN0ZXIodGhpcy5pZCwgbnVsbCwgdGhpcyk7XG4gICAgICAgIH0sXG4gICAgICAgIGZ1bmN0aW9uIHVucmVnaXN0ZXJTZWxmKCkgeyB0aGlzLnJlZ2lzdHJ5LnVucmVnaXN0ZXIodGhpcy5pZCk7IH1cbiAgICAgIF1cbiAgICB9XG4gIF0sXG5cbiAgbWV0aG9kczogW1xuICAgIGZ1bmN0aW9uIHB1dF8oeCwgb2JqKSB7IHJldHVybiB0aGlzLlNVUEVSKG51bGwsIG9iaik7IH0sXG4gICAgZnVuY3Rpb24gcmVtb3ZlXyh4LCBvYmopIHsgcmV0dXJuIHRoaXMuU1VQRVIobnVsbCwgb2JqKTsgfSxcbiAgICBmdW5jdGlvbiBmaW5kXyh4LCBrZXkpIHsgcmV0dXJuIHRoaXMuU1VQRVIobnVsbCwga2V5KTsgfSxcbiAgICBmdW5jdGlvbiBzZWxlY3RfKHgsIHNpbmssIHNraXAsIGxpbWl0LCBvcmRlciwgcHJlZGljYXRlKSB7XG4gICAgICB2YXIgcmVwbHlCb3ggPSB0aGlzLlN0cmVhbWluZ1JlcGx5Qm94LmNyZWF0ZSh7XG4gICAgICAgIHNpbms6IHNpbmsgfHwgdGhpcy5BcnJheVNpbmsuY3JlYXRlKCksXG4gICAgICAgIGRldGFjaE9uRU9GOiB0cnVlXG4gICAgICB9KTtcbiAgICAgIHZhciBwcm9taXNlID0gcmVwbHlCb3gucHJvbWlzZTtcblxuICAgICAgdmFyIHJlZ2lzdGVyZWRSZXBseUJveCA9IHJlcGx5Qm94LnJlZ2lzdGVyU2VsZigpO1xuXG4gICAgICAvLyBUT0RPKG1hcmtkaXR0bWVyKTogU2hvdWxkbid0IHRoZXJlIGJlIGFuIGFubm90YXRpb24gZm9yIGFuIGVycm9yQm94XG4gICAgICAvLyBzb21ld2hlcmUgaGVyZT9cbiAgICAgIHRoaXMuU1VQRVIoXG4gICAgICAgICAgbnVsbCwgdGhpcy5Cb3hEQU9MaXN0ZW5lci5jcmVhdGUoeyBib3g6IHJlZ2lzdGVyZWRSZXBseUJveCB9KSxcbiAgICAgICAgICBza2lwLCBsaW1pdCwgb3JkZXIsIHByZWRpY2F0ZSlcbiAgICAgICAgICAgICAgLmNhdGNoKGZ1bmN0aW9uKGVycm9yKSB7IHJlcGx5Qm94LnJlamVjdF8oZXJyb3IpOyB9KTtcbiAgICAgIHJldHVybiBwcm9taXNlO1xuICAgIH0sXG4gICAgZnVuY3Rpb24gbGlzdGVuXyh4LCBzaW5rLCBwcmVkaWNhdGUpIHtcbiAgICAgIHZhciByZXBseUJveCA9IHRoaXMuU3RyZWFtaW5nUmVwbHlCb3guY3JlYXRlKHtcbiAgICAgICAgc2luazogc2luayB8fCB0aGlzLkFycmF5U2luay5jcmVhdGUoKVxuICAgICAgfSk7XG5cbiAgICAgIC8vIFRPRE8obWFya2RpdHRtZXIpOiBTaG91bGRuJ3QgdGhlcmUgYmUgYW4gYW5ub3RhdGlvbiBmb3IgYW4gZXJyb3JCb3hcbiAgICAgIC8vIHNvbWV3aGVyZSBoZXJlP1xuICAgICAgdGhpcy5TVVBFUihudWxsLCB0aGlzLkJveERBT0xpc3RlbmVyLmNyZWF0ZSh7XG4gICAgICAgIGJveDogcmVwbHlCb3gucmVnaXN0ZXJTZWxmKClcbiAgICAgIH0pLCBwcmVkaWNhdGUpO1xuXG4gICAgICByZXR1cm4gcmVwbHlCb3guc2lua1N1YjtcbiAgICB9XG4gIF1cbn0pO1xuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgVGhlIEZPQU0gQXV0aG9ycy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuZm9hbS5DTEFTUyh7XG4gIHBhY2thZ2U6ICdmb2FtLmRhbycsXG4gIG5hbWU6ICdSZXF1ZXN0UmVzcG9uc2VDbGllbnREQU8nLFxuICBleHRlbmRzOiAnZm9hbS5kYW8uQmFzZUNsaWVudERBTycsXG5cbiAgcmVxdWlyZXM6IFtcbiAgICAnZm9hbS5jb3JlLlNlcmlhbGl6YWJsZSdcbiAgXSxcblxuICBkb2N1bWVudGF0aW9uOiBmdW5jdGlvbigpIHsvKkEgQ2xpZW50REFPIGltcGxlbWVudGF0aW9uIHdoaWNoIHB1Ymxpc2hlcyBpdHMgb3duIGV2ZW50cyB1cG9uIHB1dC9yZW1vdmUuXG5TdWl0YWJsZSBmb3IgdXNhZ2UgYWdhaW5zdCBiYWNrZW5kcyB0aGF0IGRvbid0IHN1cHBvcnQgbGlzdGVuKCksIHN1Y2ggYXMgcGxhaW4gSFRUUCBiYXNlZCBzZXJ2ZXJzLiovfSxcblxuICBtZXRob2RzOiBbXG4gICAgZnVuY3Rpb24gcHV0Xyh4LCBvYmopIHtcbiAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgIHJldHVybiB0aGlzLlNVUEVSKG51bGwsIG9iaikudGhlbihmdW5jdGlvbihvYmopIHtcbiAgICAgICAgc2VsZi5vbi5wdXQucHViKG9iaik7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgICB9KTtcbiAgICB9LFxuXG4gICAgZnVuY3Rpb24gcmVtb3ZlXyh4LCBvYmopIHtcbiAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgIHJldHVybiB0aGlzLlNVUEVSKG51bGwsIG9iaikudGhlbihmdW5jdGlvbihvKSB7XG4gICAgICAgIHNlbGYub24ucmVtb3ZlLnB1YihvYmopO1xuICAgICAgICByZXR1cm4gbztcbiAgICAgIH0pO1xuICAgIH0sXG5cbiAgICBmdW5jdGlvbiBmaW5kXyh4LCBrZXkpIHtcbiAgICAgIHJldHVybiB0aGlzLlNVUEVSKG51bGwsIGtleSk7XG4gICAgfSxcblxuICAgIGZ1bmN0aW9uIHNlbGVjdF8oeCwgc2luaywgc2tpcCwgbGltaXQsIG9yZGVyLCBwcmVkaWNhdGUpIHtcbiAgICAgIGlmICggcHJlZGljYXRlID09PSBmb2FtLm1sYW5nLnByZWRpY2F0ZS5UcnVlLmNyZWF0ZSgpICkgcHJlZGljYXRlID0gbnVsbDtcbiAgICAgIGlmICggISBza2lwICkgc2tpcCA9IDA7XG4gICAgICBpZiAoICEgbGltaXQgKSBsaW1pdCA9IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSO1xuXG4gICAgICBpZiAoICEgdGhpcy5TZXJpYWxpemFibGUuaXNJbnN0YW5jZShzaW5rKSApIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgICAgIHJldHVybiB0aGlzLlNVUEVSKG51bGwsIGZvYW0uZGFvLkFycmF5U2luay5jcmVhdGUoKSwgc2tpcCwgbGltaXQsIG9yZGVyLCBwcmVkaWNhdGUpLnRoZW4oZnVuY3Rpb24ocmVzdWx0KSB7XG4gICAgICAgICAgdmFyIGl0ZW1zID0gcmVzdWx0LmFycmF5O1xuXG4gICAgICAgICAgaWYgKCAhIHNpbmsgKSByZXR1cm4gcmVzdWx0O1xuXG4gICAgICAgICAgdmFyIHN1YiA9IGZvYW0uY29yZS5GT2JqZWN0LmNyZWF0ZSgpO1xuICAgICAgICAgIHZhciBkZXRhY2hlZCA9IGZhbHNlO1xuICAgICAgICAgIHN1Yi5vbkRldGFjaChmdW5jdGlvbigpIHsgZGV0YWNoZWQgPSB0cnVlOyB9KTtcblxuICAgICAgICAgIGZvciAoIHZhciBpID0gMCA7IGkgPCBpdGVtcy5sZW5ndGggOyBpKysgKSB7XG4gICAgICAgICAgICBpZiAoIGRldGFjaGVkICkgYnJlYWs7XG5cbiAgICAgICAgICAgIHNpbmsucHV0KGl0ZW1zW2ldLCBzdWIpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHNpbmsuZW9mKCk7XG5cbiAgICAgICAgICByZXR1cm4gc2luaztcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLlNVUEVSKG51bGwsIHNpbmssIHNraXAsIGxpbWl0LCBvcmRlciwgcHJlZGljYXRlKTtcbiAgICB9LFxuXG4gICAgZnVuY3Rpb24gcmVtb3ZlQWxsXyh4LCBza2lwLCBsaW1pdCwgb3JkZXIsIHByZWRpY2F0ZSkge1xuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgcmV0dXJuIHRoaXMuU1VQRVIobnVsbCwgc2tpcCwgbGltaXQsIG9yZGVyLCBwcmVkaWNhdGUpLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgIHNlbGYub24ucmVzZXQucHViKCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0pO1xuICAgIH0sXG5cbiAgICBmdW5jdGlvbiBsaXN0ZW5fKHgsIHNpbmssIHByZWRpY2F0ZSkge1xuICAgICAgcmV0dXJuIHRoaXMuX19jb250ZXh0X18ubG9va3VwKCdmb2FtLmRhby5BYnN0cmFjdERBTycpLlxuICAgICAgICBwcm90b3R5cGUubGlzdGVuXy5jYWxsKHRoaXMsIHgsIHNpbmssIHByZWRpY2F0ZSk7XG4gICAgfVxuICBdXG59KTtcbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IFRoZSBGT0FNIEF1dGhvcnMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmZvYW0uQ0xBU1Moe1xuICBwYWNrYWdlIDonZm9hbS5ib3gnLFxuICBuYW1lOiAnSW52YWxpZE1lc3NhZ2VFeGNlcHRpb24nLFxuICBzd2lmdEltcGxlbWVudHM6IFsnRXJyb3InXSxcblxuICBwcm9wZXJ0aWVzOiBbXG4gICAgJ21lc3NhZ2VUeXBlJ1xuICBdXG59KTtcbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IFRoZSBGT0FNIEF1dGhvcnMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmZvYW0uQ0xBU1Moe1xuICBwYWNrYWdlOiAnZm9hbS5ib3gnLFxuICBuYW1lOiAnRXZlbnRNZXNzYWdlJyxcblxuICBwcm9wZXJ0aWVzOiBbXG4gICAge1xuICAgICAgY2xhc3M6ICdBcnJheScsXG4gICAgICBuYW1lOiAnYXJncydcbiAgICB9XG4gIF1cbn0pO1xuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgVGhlIEZPQU0gQXV0aG9ycy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuZm9hbS5DTEFTUyh7XG4gIHBhY2thZ2U6ICdmb2FtLmJveCcsXG4gIG5hbWU6ICdFdmVudERpc3BhdGNoQm94JyxcblxuICBpbXBsZW1lbnRzOiBbJ2ZvYW0uYm94LkJveCddLFxuXG4gIHJlcXVpcmVzOiBbXG4gICAgJ2ZvYW0uYm94LkV2ZW50TWVzc2FnZScsXG4gICAgJ2ZvYW0uYm94LkludmFsaWRNZXNzYWdlRXhjZXB0aW9uJ1xuICBdLFxuXG4gIHByb3BlcnRpZXM6IFtcbiAgICB7XG4gICAgICBuYW1lOiAndGFyZ2V0J1xuICAgIH1cbiAgXSxcblxuICBtZXRob2RzOiBbXG4gICAgZnVuY3Rpb24gc2VuZChtc2cpIHtcbiAgICAgIGlmICggISB0aGlzLkV2ZW50TWVzc2FnZS5pc0luc3RhbmNlKG1zZy5vYmplY3QpICkge1xuICAgICAgICB0aHJvdyB0aGlzLkludmFsaWRNZXNzYWdlRXhjZXB0aW9uLmNyZWF0ZSh7XG4gICAgICAgICAgbWVzc2FnZVR5cGU6IG1lc3NhZ2UuY2xzXy5pZFxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgdGhpcy50YXJnZXQucHViLmFwcGx5KHRoaXMudGFyZ2V0LCBtc2cub2JqZWN0LmFyZ3MpO1xuICAgIH1cbiAgXVxufSk7XG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBUaGUgRk9BTSBBdXRob3JzLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5mb2FtLkNMQVNTKHtcbiAgcGFja2FnZTogJ2ZvYW0uYm94JyxcbiAgbmFtZTogJ1NrZWxldG9uQm94JyxcbiAgaW1wbGVtZW50czogWydmb2FtLmJveC5Cb3gnXSxcblxuICByZXF1aXJlczogW1xuICAgICdmb2FtLmJveC5NZXNzYWdlJyxcbiAgICAnZm9hbS5ib3guUlBDTWVzc2FnZScsXG4gICAgJ2ZvYW0uYm94LlJQQ1JldHVybk1lc3NhZ2UnLFxuICAgICdmb2FtLmJveC5SUENFcnJvck1lc3NhZ2UnLFxuICAgICdmb2FtLmJveC5JbnZhbGlkTWVzc2FnZUV4Y2VwdGlvbidcbiAgXSxcblxuICBwcm9wZXJ0aWVzOiBbXG4gICAge1xuICAgICAgbmFtZTogJ2RhdGEnXG4gICAgfVxuICBdLFxuXG4gIG1ldGhvZHM6IFtcbiAgICB7XG4gICAgICBuYW1lOiAnY2FsbCcsXG4gICAgICBhcmdzOiBbXG4gICAgICAgIHtcbiAgICAgICAgICBzd2lmdFR5cGU6ICdNZXNzYWdlPycsXG4gICAgICAgICAgbmFtZTogJ21lc3NhZ2UnLFxuICAgICAgICB9LFxuICAgICAgXSxcbiAgICAgIGNvZGU6IGZ1bmN0aW9uKG1lc3NhZ2UpIHtcbiAgICAgICAgdmFyIHA7XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB2YXIgbWV0aG9kID0gdGhpcy5kYXRhLmNsc18uZ2V0QXhpb21CeU5hbWUobWVzc2FnZS5vYmplY3QubmFtZSk7XG4gICAgICAgICAgdmFyIGFyZ3MgPSBtZXNzYWdlLm9iamVjdC5hcmdzLnNsaWNlKCk7XG5cbiAgICAgICAgICAvLyBUT0RPOiBUaGlzIGlzIHByZXR0eSBoYWNraXNoLiAgQ29udGV4dC1PcmllbnRlZCBtZXRob2RzIHNob3VsZCBqdXN0IGJlIG1vZGVsZWQuXG4gICAgICAgICAgaWYgKCBtZXRob2QgJiYgbWV0aG9kLmFyZ3MgJiYgbWV0aG9kLmFyZ3NbMF0gJiYgbWV0aG9kLmFyZ3NbMF0ubmFtZSA9PSAneCcgKSB7XG4gICAgICAgICAgICB2YXIgeCA9IHRoaXMuX19jb250ZXh0X18uY3JlYXRlU3ViQ29udGV4dCh7XG4gICAgICAgICAgICAgIG1lc3NhZ2U6IG1lc3NhZ2VcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgYXJnc1swXSA9IHg7XG4gICAgICAgICAgfVxuICAgICAgICAgIHAgPSB0aGlzLmRhdGFbbWVzc2FnZS5vYmplY3QubmFtZV0uYXBwbHkodGhpcy5kYXRhLCBhcmdzKTtcbiAgICAgICAgfSBjYXRjaChlKSB7XG4gICAgICAgICAgbWVzc2FnZS5hdHRyaWJ1dGVzLnJlcGx5Qm94ICYmIG1lc3NhZ2UuYXR0cmlidXRlcy5yZXBseUJveC5zZW5kKHRoaXMuTWVzc2FnZS5jcmVhdGUoe1xuICAgICAgICAgICAgb2JqZWN0OiB0aGlzLlJQQ0Vycm9yTWVzc2FnZS5jcmVhdGUoeyBkYXRhOiBlLm1lc3NhZ2UgfSlcbiAgICAgICAgICB9KSk7XG5cbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcmVwbHlCb3ggPSBtZXNzYWdlLmF0dHJpYnV0ZXMucmVwbHlCb3g7XG5cbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgICAgIGlmICggcCBpbnN0YW5jZW9mIFByb21pc2UgKSB7XG4gICAgICAgICAgcC50aGVuKFxuICAgICAgICAgICAgZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICAgICAgICByZXBseUJveC5zZW5kKHNlbGYuTWVzc2FnZS5jcmVhdGUoe1xuICAgICAgICAgICAgICAgIG9iamVjdDogc2VsZi5SUENSZXR1cm5NZXNzYWdlLmNyZWF0ZSh7IGRhdGE6IGRhdGEgfSlcbiAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGZ1bmN0aW9uKGVycm9yKSB7XG4gICAgICAgICAgICAgIG1lc3NhZ2UuYXR0cmlidXRlcy5yZXBseUJveCAmJiBtZXNzYWdlLmF0dHJpYnV0ZXMucmVwbHlCb3guc2VuZChzZWxmLk1lc3NhZ2UuY3JlYXRlKHtcbiAgICAgICAgICAgICAgICBvYmplY3Q6IHNlbGYuUlBDRXJyb3JNZXNzYWdlLmNyZWF0ZSh7IGRhdGE6IGVycm9yICYmIGVycm9yLnRvU3RyaW5nKCkgfSlcbiAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVwbHlCb3ggJiYgcmVwbHlCb3guc2VuZCh0aGlzLk1lc3NhZ2UuY3JlYXRlKHtcbiAgICAgICAgICAgIG9iamVjdDogdGhpcy5SUENSZXR1cm5NZXNzYWdlLmNyZWF0ZSh7IGRhdGE6IHAgfSlcbiAgICAgICAgICB9KSk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBzd2lmdENvZGU6IGZ1bmN0aW9uKCkgey8qXG5kbyB7XG4gIGd1YXJkIGxldCBvYmplY3QgPSBtZXNzYWdlPy5vYmplY3QgYXM/IFJQQ01lc3NhZ2UsXG4gICAgICAgIGxldCBkYXRhID0gc2VsZi5kYXRhIGFzPyBGT2JqZWN0LFxuICAgICAgICBsZXQgbWV0aG9kID0gZGF0YS5vd25DbGFzc0luZm8oKS5heGlvbShieU5hbWU6IG9iamVjdC5uYW1lKSBhcz8gTWV0aG9kSW5mb1xuICBlbHNlIHtcbiAgICB0aHJvdyBJbnZhbGlkTWVzc2FnZUV4Y2VwdGlvbl9jcmVhdGUoKVxuICB9XG5cbiAgLy8gVE9ETyBoYW5kbGUgY29udGV4dCBvcmllbnRlZCBtZXRob2RzLlxuXG4gIHZhciBwID0gdHJ5IG1ldGhvZC5jYWxsKGRhdGEsIGFyZ3M6IG9iamVjdC5hcmdzKVxuXG4gIGd1YXJkIGxldCByZXBseUJveCA9IG1lc3NhZ2U/LmF0dHJpYnV0ZXNbXCJyZXBseUJveFwiXSBhcz8gQm94IGVsc2UgeyByZXR1cm4gfVxuICBpZiBsZXQgcEZ1dCA9IHAgYXM/IEZ1dHVyZTxBbnk+IHsgcCA9IHRyeSBwRnV0LmdldCgpIH1cbiAgdHJ5IHJlcGx5Qm94LnNlbmQoTWVzc2FnZV9jcmVhdGUoW1xuICAgIFwib2JqZWN0XCI6IFJQQ1JldHVybk1lc3NhZ2VfY3JlYXRlKFtcImRhdGFcIjogcF0pXG4gIF0pKVxufSBjYXRjaCBsZXQgZSB7XG4gIGlmIGxldCBlcnJvckJveCA9IG1lc3NhZ2U/LmF0dHJpYnV0ZXNbXCJlcnJvckJveFwiXSBhcz8gQm94IHtcbiAgICB0cnk/IGVycm9yQm94LnNlbmQoTWVzc2FnZV9jcmVhdGUoW1xuICAgICAgXCJvYmplY3RcIjogUlBDRXJyb3JNZXNzYWdlX2NyZWF0ZShbXG4gICAgICAgIFwiZGF0YVwiOiBlLmxvY2FsaXplZERlc2NyaXB0aW9uXG4gICAgICBdKVxuICAgIF0pKVxuICB9XG59XG4gICAgICAqL30sXG4gICAgfSxcblxuICAgIHtcbiAgICAgIG5hbWU6ICdzZW5kJyxcbiAgICAgIGNvZGU6IGZ1bmN0aW9uKG1lc3NhZ2UpIHtcbiAgICAgICAgaWYgKCB0aGlzLlJQQ01lc3NhZ2UuaXNJbnN0YW5jZShtZXNzYWdlLm9iamVjdCkgKSB7XG4gICAgICAgICAgdGhpcy5jYWxsKG1lc3NhZ2UpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRocm93IHRoaXMuSW52YWxpZE1lc3NhZ2VFeGNlcHRpb24uY3JlYXRlKHtcbiAgICAgICAgICBtZXNzYWdlVHlwZTogbWVzc2FnZS5jbHNfICYmIG1lc3NhZ2UuY2xzXy5pZFxuICAgICAgICB9KTtcbiAgICAgIH0sXG4gICAgICBzd2lmdENvZGU6IGZ1bmN0aW9uKCkgey8qXG5pZiBsZXQgXyA9IG1zZy5vYmplY3QgYXM/IFJQQ01lc3NhZ2Uge1xuICBjYWxsKG1zZylcbiAgcmV0dXJuXG59XG5cbnRocm93IEludmFsaWRNZXNzYWdlRXhjZXB0aW9uX2NyZWF0ZShbXG4gIFwibWVzc2FnZVR5cGVcIjogbXNnLm93bkNsYXNzSW5mbygpLmlkLFxuXSlcbiAgICAgICovfSxcbiAgICB9LFxuICBdXG59KTtcbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IFRoZSBGT0FNIEF1dGhvcnMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmZvYW0uQ0xBU1Moe1xuICBwYWNrYWdlOiAnZm9hbS5ib3gnLFxuICBuYW1lOiAnTnVsbEJveCcsXG5cbiAgaW1wbGVtZW50czogWydmb2FtLmJveC5Cb3gnXSxcblxuICBtZXRob2RzOiBbXG4gICAge1xuICAgICAgbmFtZTogJ3NlbmQnLFxuICAgICAgY29kZTogZnVuY3Rpb24oKSB7fVxuICAgIH1cbiAgXVxufSk7XG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBUaGUgRk9BTSBBdXRob3JzLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5mb2FtLkNMQVNTKHtcbiAgcGFja2FnZTogJ2ZvYW0uYm94JyxcbiAgbmFtZTogJ1NvY2tldEJveCcsXG4gIGV4dGVuZHM6ICdmb2FtLmJveC5Qcm94eUJveCcsXG5cbiAgcmVxdWlyZXM6IFtcbiAgICAnZm9hbS5ib3guU29ja2V0Q29ubmVjdEJveCdcbiAgXSxcblxuICBheGlvbXM6IFtcbiAgICBmb2FtLnBhdHRlcm4uTXVsdGl0b24uY3JlYXRlKHtcbiAgICAgIHByb3BlcnR5OiAnYWRkcmVzcydcbiAgICB9KVxuICBdLFxuXG4gIHByb3BlcnRpZXM6IFtcbiAgICB7XG4gICAgICBjbGFzczogJ1N0cmluZycsXG4gICAgICBuYW1lOiAnbmFtZSdcbiAgICB9LFxuICAgIHtcbiAgICAgIGNsYXNzOiAnU3RyaW5nJyxcbiAgICAgIG5hbWU6ICdhZGRyZXNzJ1xuICAgIH0sXG4gICAge1xuICAgICAgbmFtZTogJ2RlbGVnYXRlJyxcbiAgICAgIHRyYW5zaWVudDogdHJ1ZSxcbiAgICAgIGZhY3Rvcnk6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gZm9hbS5ib3guU29ja2V0Q29ubmVjdEJveC5jcmVhdGUoe1xuICAgICAgICAgIGFkZHJlc3M6IHRoaXMuYWRkcmVzc1xuICAgICAgICB9LCB0aGlzKTtcbiAgICAgIH0sXG4gICAgICBzd2lmdEZhY3Rvcnk6IGBcbnJldHVybiBTb2NrZXRDb25uZWN0Qm94X2NyZWF0ZShbXG4gIFwiYWRkcmVzcyRcIjogYWRkcmVzcyQsXG5dKVxuICAgICAgYFxuICAgIH1cbiAgXVxufSk7XG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBUaGUgRk9BTSBBdXRob3JzLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5mb2FtLkNMQVNTKHtcbiAgcGFja2FnZTogJ2ZvYW0uYm94JyxcbiAgbmFtZTogJ1NvY2tldEJveDInLFxuXG4gIGltcG9ydHM6IFtcbiAgICAnc29ja2V0U2VydmljZScsXG4gIF0sXG5cbiAgYXhpb21zOiBbXG4gICAgZm9hbS5wYXR0ZXJuLk11bHRpdG9uLmNyZWF0ZSh7XG4gICAgICBwcm9wZXJ0eTogJ2FkZHJlc3MnXG4gICAgfSlcbiAgXSxcblxuICBwcm9wZXJ0aWVzOiBbXG4gICAge1xuICAgICAgY2xhc3M6ICdTdHJpbmcnLFxuICAgICAgbmFtZTogJ2FkZHJlc3MnXG4gICAgfSxcbiAgICB7XG4gICAgICBuYW1lOiAncHJvbWlzZScsXG4gICAgICB0cmFuc2llbnQ6IHRydWUsXG4gICAgICBmYWN0b3J5OiBmdW5jdGlvbigpIHtcbiAgICAgIH1cbiAgICB9XG4gIF0sXG5cbiAgbWV0aG9kczogW1xuICAgIGZ1bmN0aW9uIHNlbmQobSkge1xuICAgIH1cbiAgXSxcblxuICBsaXN0ZW5lcnM6IFtcbiAgICBmdW5jdGlvbiBvbkNvbm5lY3QoKSB7XG4gICAgICB0aGlzLnNvY2tldFNlcnZpY2UuYWRkU29ja2V0KHRoaXMpO1xuICAgICAgdGhpcy5zZW5kKHRoaXMuUmVnaXN0ZXJTZWxmTWVzc2FnZS5jcmVhdGUoe1xuICAgICAgICBuYW1lOiB0aGlzLm1lLm5hbWVcbiAgICAgIH0pKTtcbiAgICAgIHRoaXMuY29ubmVjdC5wdWIoKTtcbiAgICB9LFxuICAgIGZ1bmN0aW9uIG9uRXJyb3IoKSB7XG4gICAgfVxuICBdXG59KTtcbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IFRoZSBGT0FNIEF1dGhvcnMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmZvYW0uQ0xBU1Moe1xuICBwYWNrYWdlOiAnZm9hbS5ib3gnLFxuICBuYW1lOiAnU29ja2V0Q29ubmVjdEJveCcsXG4gIGV4dGVuZHM6ICdmb2FtLmJveC5Qcm9taXNlZEJveCcsXG5cbiAgcmVxdWlyZXM6IFtcbiAgICB7XG4gICAgICBmbGFnczogWydqcyddLFxuICAgICAgcGF0aDogJ2ZvYW0uYm94LlJhd1NvY2tldEJveCcsXG4gICAgfSxcbiAgXSxcblxuICBwcm9wZXJ0aWVzOiBbXG4gICAge1xuICAgICAgY2xhc3M6ICdTdHJpbmcnLFxuICAgICAgbmFtZTogJ2FkZHJlc3MnXG4gICAgfSxcbiAgICB7XG4gICAgICBuYW1lOiAnZGVsZWdhdGUnLFxuICAgICAgZmFjdG9yeTogZnVuY3Rpb24oKSB7XG4gICAgICAgIC8vIFVzZSBkZWZhdWx0IEZPQU0gaW1wbGVtZW50YXRpb24gb2YgU29ja2V0LiBEbyBub3QgYXR0ZW1wdCB0byBsb29rdXBcbiAgICAgICAgLy8gc2Vuc2l0aXZlIFwiZm9hbS5uZXQubm9kZS5Tb2NrZXRcIiBjbGFzcyBpbiBib3ggY29udGV4dC5cbiAgICAgICAgcmV0dXJuIGZvYW0ubG9va3VwKCdmb2FtLm5ldC5ub2RlLlNvY2tldCcpLmNyZWF0ZShudWxsLCB0aGlzKS5cbiAgICAgICAgICAgIGNvbm5lY3RUbyh0aGlzLmFkZHJlc3MpLnRoZW4oZnVuY3Rpb24ocykge1xuICAgICAgICAgICAgICByZXR1cm4gdGhpcy5SYXdTb2NrZXRCb3guY3JlYXRlKHsgc29ja2V0OiBzIH0pO1xuICAgICAgICAgICAgfS5iaW5kKHRoaXMpKTtcbiAgICAgIH0sXG4gICAgICBzd2lmdEZhY3Rvcnk6IGBcbmxldCBzb2NrZXRTZXJ2aWNlID0gX19jb250ZXh0X19bXCJzb2NrZXRTZXJ2aWNlXCJdIGFzISBTb2NrZXRTZXJ2aWNlIC8vIFRPRE8gaW1wb3J0XG5yZXR1cm4gc29ja2V0U2VydmljZS5nZXRTb2NrZXRCb3hGdXR1cmUoYWRkcmVzcylcbiAgICAgIGBcbiAgICB9XG4gIF1cbn0pO1xuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgVGhlIEZPQU0gQXV0aG9ycy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuZm9hbS5DTEFTUyh7XG4gIHBhY2thZ2U6ICdmb2FtLmJveCcsXG4gIG5hbWU6ICdSYXdTb2NrZXRCb3gnLFxuICBpbXBsZW1lbnRzOiBbICdmb2FtLmJveC5Cb3gnIF0sXG5cbiAgcmVxdWlyZXM6IFsgJ2ZvYW0uYm94LlJlcGx5Qm94JyBdLFxuICBpbXBvcnRzOiBbXG4gICAgJ21lJyxcbiAgICAncmVnaXN0cnknLFxuICBdLFxuXG4gIHByb3BlcnRpZXM6IFtcbiAgICB7XG4gICAgICBjbGFzczogJ09iamVjdCcsXG4gICAgICBuYW1lOiAnc29ja2V0JyxcbiAgICAgIGphdmFUeXBlOiAnb3JnLmphdmFfd2Vic29ja2V0LldlYlNvY2tldCdcbiAgICB9XG4gIF0sXG5cbiAgY2xhc3NlczogW1xuICAgIHtcbiAgICAgIG5hbWU6ICdKU09OT3V0cHV0dGVyJyxcbiAgICAgIGV4dGVuZHM6ICdmb2FtLmpzb24uT3V0cHV0dGVyJyxcblxuICAgICAgcmVxdWlyZXM6IFsgJ2ZvYW0uYm94LlJldHVybkJveCcgXSxcbiAgICAgIGltcG9ydHM6IFsgJ21lJyBdLFxuICAgICAgbWV0aG9kczogW1xuICAgICAgICBmdW5jdGlvbiBvdXRwdXQobykge1xuICAgICAgICAgIGlmICggbyA9PT0gdGhpcy5tZSApIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLlNVUEVSKHRoaXMuUmV0dXJuQm94LmNyZWF0ZSgpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHRoaXMuU1VQRVIobyk7XG4gICAgICAgIH1cbiAgICAgIF1cbiAgICB9XG4gIF0sXG5cbiAgbWV0aG9kczogW1xuICAgIHtcbiAgICAgIG5hbWU6ICdzZW5kJyxcbiAgICAgIGNvZGU6IGZ1bmN0aW9uIHNlbmQobXNnKSB7XG4gICAgICAgIHZhciByZXBseUJveCA9IG1zZy5hdHRyaWJ1dGVzLnJlcGx5Qm94O1xuICAgICAgICBpZiAoIHJlcGx5Qm94ICkge1xuICAgICAgICAgIC8vIFRPRE86IFdlIHNob3VsZCBwcm9iYWJseSBjbG9uZSBoZXJlLCBidXQgb2Z0ZW4gdGhlIG1lc3NhZ2VcbiAgICAgICAgICAvLyBjb250YWlucyBSUEMgYXJndW1lbnRzIHRoYXQgZG9uJ3QgY2xvbmUgcHJvcGVybHkuICBTb1xuICAgICAgICAgIC8vIGluc3RlYWQgd2Ugd2lsbCBtdXRhdGUgcmVwbHlCb3ggYW5kIHB1dCBpdCBiYWNrIGFmdGVyLlxuXG4gICAgICAgICAgLy8gRXZlbiBiZXR0ZXIgc29sdXRpb24gd291bGQgYmUgdG8gbW92ZSByZXBseUJveCB0byBhXG4gICAgICAgICAgLy8gcHJvcGVydHkgb24gTWVzc2FnZSBhbmQgaGF2ZSBjdXN0b20gc2VyaWFsaXphdGlvbiBpbiBpdCB0b1xuICAgICAgICAgIC8vIGRvIHRoZSByZWdpc3RyYXRpb24uXG5cbiAgICAgICAgICBtc2cuYXR0cmlidXRlcy5yZXBseUJveCA9IHRoaXMuX19jb250ZXh0X18ucmVnaXN0cnkuXG4gICAgICAgICAgICAgIHJlZ2lzdGVyKG1zZy5hdHRyaWJ1dGVzLnJlcGx5Qm94LmlkLCBudWxsLFxuICAgICAgICAgICAgICAgICAgICAgICBtc2cuYXR0cmlidXRlcy5yZXBseUJveCk7XG4gICAgICAgIH1cblxuICAgICAgICB0cnkge1xuICAgICAgICAgIHRoaXMuc29ja2V0LndyaXRlKG1zZyk7XG4gICAgICAgICAgaWYgKCByZXBseUJveCApIHtcbiAgICAgICAgICAgIG1zZy5hdHRyaWJ1dGVzLnJlcGx5Qm94ID0gcmVwbHlCb3g7XG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgIHJlcGx5Qm94ICYmIHJlcGx5Qm94LnNlbmQoZm9hbS5ib3guTWVzc2FnZS5jcmVhdGUoeyBvYmplY3Q6IGVycm9yIH0pKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgXVxufSk7XG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBUaGUgRk9BTSBBdXRob3JzLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5mb2FtLkNMQVNTKHtcbiAgcGFja2FnZTogJ2ZvYW0uYm94JyxcbiAgbmFtZTogJ1NlbmRGYWlsZWRFcnJvcicsXG4gIGV4dGVuZHM6ICdmb2FtLmJveC5NZXNzYWdlJyxcblxuICBwcm9wZXJ0aWVzOiBbXG4gICAge1xuICAgICAgbmFtZTogJ29yaWdpbmFsJ1xuICAgIH0sXG4gICAge1xuICAgICAgbmFtZTogJ2Vycm9yJ1xuICAgIH1cbiAgXVxufSk7XG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBUaGUgRk9BTSBBdXRob3JzLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5mb2FtLkNMQVNTKHtcbiAgcGFja2FnZTogJ2ZvYW0uYm94JyxcbiAgbmFtZTogJ1JlZ2lzdGVyU2VsZk1lc3NhZ2UnLFxuICBleHRlbmRzOiAnZm9hbS5ib3guTWVzc2FnZScsXG5cbiAgcHJvcGVydGllczogW1xuICAgIHtcbiAgICAgIGNsYXNzOiAnU3RyaW5nJyxcbiAgICAgIG5hbWU6ICduYW1lJ1xuICAgIH1cbiAgXVxufSk7XG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBUaGUgRk9BTSBBdXRob3JzLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5mb2FtLkNMQVNTKHtcbiAgcGFja2FnZTogJ2ZvYW0uYm94JyxcbiAgbmFtZTogJ1Jhd1dlYlNvY2tldEJveCcsXG4gIGltcGxlbWVudHM6IFsnZm9hbS5ib3guQm94J10sXG4gIHJlcXVpcmVzOiBbXG4gICAgJ2ZvYW0uYm94LlJlcGx5Qm94J1xuICBdLFxuICBpbXBvcnRzOiBbXG4gICAge1xuICAgICAgbmFtZTogJ21lJyxcbiAgICAgIGtleTogJ21lJyxcbiAgICAgIGphdmFUeXBlOiAnZm9hbS5ib3guQm94J1xuICAgIH0sXG4gICAge1xuICAgICAga2V5OiAncmVnaXN0cnknLFxuICAgICAgbmFtZTogJ3JlZ2lzdHJ5JyxcbiAgICAgIGphdmFUeXBlOiAnZm9hbS5ib3guQm94UmVnaXN0cnknLFxuICAgIH1cbiAgXSxcblxuICBwcm9wZXJ0aWVzOiBbXG4gICAge1xuICAgICAgY2xhc3M6ICdPYmplY3QnLFxuICAgICAgbmFtZTogJ3NvY2tldCcsXG4gICAgICBqYXZhVHlwZTogJ2ZvYW0ubmV0LldlYlNvY2tldCdcbiAgICB9XG4gIF0sXG5cbiAgY2xhc3NlczogW1xuICAgIGZvYW0uY29yZS5Jbm5lckNsYXNzLmNyZWF0ZSh7XG4gICAgICBnZW5lcmF0ZUphdmE6IGZhbHNlLFxuICAgICAgbW9kZWw6IHtcbiAgICAgICAgbmFtZTogJ0pTT05PdXRwdXR0ZXInLFxuICAgICAgICBleHRlbmRzOiAnZm9hbS5qc29uLk91dHB1dHRlcicsXG4gICAgICAgIHJlcXVpcmVzOiBbXG4gICAgICAgICAgJ2ZvYW0uYm94LlJldHVybkJveCdcbiAgICAgICAgXSxcbiAgICAgICAgaW1wb3J0czogW1xuICAgICAgICAgICdtZSdcbiAgICAgICAgXSxcbiAgICAgICAgbWV0aG9kczogW1xuICAgICAgICAgIGZ1bmN0aW9uIG91dHB1dChvKSB7XG4gICAgICAgICAgICBpZiAoIG8gPT09IHRoaXMubWUgKSB7XG4gICAgICAgICAgICAgIHJldHVybiB0aGlzLlNVUEVSKHRoaXMuUmV0dXJuQm94LmNyZWF0ZSgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLlNVUEVSKG8pO1xuICAgICAgICAgIH1cbiAgICAgICAgXVxuICAgICAgfVxuICAgIH0pXG4gIF0sXG5cbiAgbWV0aG9kczogW1xuICAgIHtcbiAgICAgIG5hbWU6ICdzZW5kJyxcbiAgICAgIGNvZGU6IGZ1bmN0aW9uIHNlbmQobXNnKSB7XG4gICAgICAgIHZhciByZXBseUJveCA9IG1zZy5hdHRyaWJ1dGVzLnJlcGx5Qm94O1xuICAgICAgICBpZiAoIHJlcGx5Qm94ICkge1xuICAgICAgICAgIC8vIFRPRE86IFNob3VsZCByZXBseUJveCBqdXN0IGJlIGEgcHJvcGVydHkgb24gbWVzc2FnZSB3aXRoXG4gICAgICAgICAgLy8gY3VzdG9tIHNlcmlhbGl6YXRpb24/XG5cbiAgICAgICAgICAvLyBUT0RPOiBBZGQgb25lLXRpbWUgc2VydmljZSBwb2xpY3lcblxuICAgICAgICAgIG1zZy5hdHRyaWJ1dGVzLnJlcGx5Qm94ID0gdGhpcy5fX2NvbnRleHRfXy5yZWdpc3RyeS5cbiAgICAgICAgICAgICAgcmVnaXN0ZXIobXNnLmF0dHJpYnV0ZXMucmVwbHlCb3guaWQsIG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgIG1zZy5hdHRyaWJ1dGVzLnJlcGx5Qm94KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBwYXlsb2FkID0gdGhpcy5KU09OT3V0cHV0dGVyLmNyZWF0ZSgpLmNvcHlGcm9tKGZvYW0uanNvbi5OZXR3b3JrKS5zdHJpbmdpZnkobXNnKTtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgIHRoaXMuc29ja2V0LnNlbmQocGF5bG9hZCk7XG4gICAgICAgIH0gY2F0Y2goZSkge1xuICAgICAgICAgIHJlcGx5Qm94ICYmIHJlcGx5Qm94LnNlbmQoZm9hbS5ib3guTWVzc2FnZS5jcmVhdGUoeyBvYmplY3Q6IGUgfSkpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgamF2YUNvZGU6IGBcbmZvYW0ubGliLmpzb24uT3V0cHV0dGVyIG91dHB1dHRlciA9IG5ldyBPdXRwdXR0ZXIoKTtcbm91dHB1dHRlci5zZXRYKGdldFgoKSk7XG5cbi8vIFRPRE86IENsb25lIG1lc3NhZ2Ugb3Igc29tZXRoaW5nIHdoZW4gaXQgY2xvbmVzIHNhZmVseS5cbmZvYW0uYm94LkJveCByZXBseUJveCA9IChmb2FtLmJveC5Cb3gpbWVzc2FnZS5nZXRBdHRyaWJ1dGVzKCkuZ2V0KFwicmVwbHlCb3hcIik7XG5cbmlmICggcmVwbHlCb3ggIT0gbnVsbCApIHtcbiAgZm9hbS5ib3guU3ViQm94IGV4cG9ydCA9IChmb2FtLmJveC5TdWJCb3gpZ2V0UmVnaXN0cnkoKS5yZWdpc3RlcihudWxsLCBudWxsLCByZXBseUJveCk7XG5cbiAgcmVwbHlCb3ggPSBuZXcgZm9hbS5ib3guUmVwbHlCb3goZ2V0WCgpLCBleHBvcnQuZ2V0TmFtZSgpLCByZXBseUJveCk7XG59XG5cblN0cmluZyBwYXlsb2FkID0gb3V0cHV0dGVyLnN0cmluZ2lmeShtZXNzYWdlKTtcblxubWVzc2FnZS5nZXRBdHRyaWJ1dGVzKCkucHV0KFwicmVwbHlCb3hcIiwgcmVwbHlCb3gpO1xuXG50cnkge1xuICBnZXRTb2NrZXQoKS5zZW5kKHBheWxvYWQpO1xufSBjYXRjaCAoIGphdmEuaW8uSU9FeGNlcHRpb24gZSApIHtcbiAgZm9hbS5ib3guTWVzc2FnZSByZXBseSA9IG5ldyBmb2FtLmJveC5NZXNzYWdlKCk7XG4gIHJlcGx5LnNldE9iamVjdChlKTtcbiAgaWYgKCByZXBseUJveCAhPSBudWxsICkgcmVwbHlCb3guc2VuZChyZXBseSk7XG59XG5gXG4gICAgfVxuICBdLFxuXG4gIGF4aW9tczogW1xuICAgIHtcbiAgICAgIG5hbWU6ICdqYXZhRXh0cmFzJyxcbiAgICAgIGJ1aWxkSmF2YUNsYXNzOiBmdW5jdGlvbihjbHMpIHtcbiAgICAgICAgY2xzLmV4dHJhcy5wdXNoKGZvYW0uamF2YS5Db2RlLmNyZWF0ZSh7XG4gICAgICAgICAgZGF0YTogYFxucHJvdGVjdGVkIGNsYXNzIE91dHB1dHRlciBleHRlbmRzIGZvYW0ubGliLmpzb24uT3V0cHV0dGVyIHtcbiAgcHVibGljIE91dHB1dHRlcigpIHtcbiAgICBzdXBlcihmb2FtLmxpYi5qc29uLk91dHB1dHRlck1vZGUuTkVUV09SSyk7XG4gIH1cblxuICBwcm90ZWN0ZWQgdm9pZCBvdXRwdXRGT2JqZWN0KGZvYW0uY29yZS5GT2JqZWN0IG8pIHtcbiAgICBpZiAoIG8gPT0gZ2V0TWUoKSApIHtcbiAgICAgIG8gPSBnZXRYKCkuY3JlYXRlKGZvYW0uYm94LlJldHVybkJveC5jbGFzcyk7XG4gICAgfVxuICAgIHN1cGVyLm91dHB1dEZPYmplY3Qobyk7XG4gIH1cbn1cbmB9KSk7XG4gICAgICB9XG4gICAgfVxuICBdXG59KTtcbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IFRoZSBGT0FNIEF1dGhvcnMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqL1xuXG5mb2FtLkNMQVNTKHtcbiAgcGFja2FnZTogJ2ZvYW0uYm94JyxcbiAgbmFtZTogJ1JldHVybkJveCcsXG4gIGRvY3VtZW50YXRpb246ICdBIGJveCB0aGF0IHNlbmRzIG1lc3NhZ2VzIGJhY2sgb3ZlciB0aGUgY29ubmVjdGlvbiBpdCBjYW1lIGluIG9uLicsXG4gIGltcGxlbWVudHM6IFsnZm9hbS5ib3guQm94J10sXG4gIG1ldGhvZHM6IFtcbiAgICB7XG4gICAgICBuYW1lOiAnc2VuZCcsXG4gICAgICBjb2RlOiBmdW5jdGlvbihtZXNzYWdlKSB7XG4gICAgICAgIHRoaXMuX19jb250ZXh0X18ucmV0dXJuQm94LnNlbmQobWVzc2FnZSk7XG4gICAgICB9LFxuICAgICAgc3dpZnRDb2RlOiBgdHJ5IChfX2NvbnRleHRfX1tcInJldHVybkJveFwiXSBhcyEgQm94KS5zZW5kKG1zZylgLFxuICAgICAgamF2YUNvZGU6IGBcbigoZm9hbS5ib3guQm94KWdldFgoKS5nZXQoXCJyZXR1cm5Cb3hcIikpLnNlbmQobWVzc2FnZSk7XG5gXG4gICAgfVxuICBdXG59KTtcbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IFRoZSBGT0FNIEF1dGhvcnMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmZvYW0uQ0xBU1Moe1xuICBwYWNrYWdlOiAnZm9hbS5ib3gnLFxuICBuYW1lOiAnUmF3TWVzc2FnZVBvcnRCb3gnLFxuICBpbXBsZW1lbnRzOiBbICdmb2FtLmJveC5Cb3gnIF0sXG4gIHJlcXVpcmVzOiBbXG4gICAgJ2ZvYW0uanNvbi5PdXRwdXR0ZXInLFxuICAgICdmb2FtLmJveC5SZXBseUJveCdcbiAgXSxcblxuICBwcm9wZXJ0aWVzOiBbXG4gICAge1xuICAgICAgbmFtZTogJ3BvcnQnXG4gICAgfSxcbiAgICB7XG4gICAgICBjbGFzczogJ0ZPYmplY3RQcm9wZXJ0eScsXG4gICAgICBvZjogJ2ZvYW0uanNvbi5PdXRwdXR0ZXInLFxuICAgICAgbmFtZTogJ291dHB1dHRlcicsXG4gICAgICBmYWN0b3J5OiBmdW5jdGlvbigpIHtcbiAgICAgICAgLy8gTk9URTogQ29uZmlndXJhdGlvbiBtdXN0IGJlIGNvbnNpc3RlbnQgd2l0aCBwYXJzZXIgaW5cbiAgICAgICAgLy8gZm9hbS5tZXNzYWdlcG9ydC5NZXNzYWdlUG9ydFNlcnZpY2UuXG4gICAgICAgIC8vXG4gICAgICAgIC8vIFVzZSBkZWZhdWx0IEZPQU0gaW1wbGVtZW50YXRpb24gb2YgT3V0cHV0dGVyLiBEbyBub3QgYXR0ZW1wdCB0b1xuICAgICAgICAvLyBsb29rdXAgc2Vuc2l0aXZlIFwiZm9hbS5qc29uLk91dHB1dHRlclwiIGNsYXNzIGluIGJveCBjb250ZXh0LlxuICAgICAgICByZXR1cm4gdGhpcy5PdXRwdXR0ZXIuY3JlYXRlKCkuY29weUZyb20oZm9hbS5qc29uLk5ldHdvcmspXG4gICAgICB9XG4gICAgfVxuICBdLFxuICBtZXRob2RzOiBbXG4gICAgZnVuY3Rpb24gc2VuZChtZXNzYWdlKSB7XG4gICAgICB2YXIgcmVwbHlCb3ggPSBtZXNzYWdlLmF0dHJpYnV0ZXMucmVwbHlCb3g7XG4gICAgICBpZiAoIHJlcGx5Qm94ICkge1xuICAgICAgICAvLyBUT0RPOiBXZSBzaG91bGQgcHJvYmFibHkgY2xvbmUgaGVyZSwgYnV0IG9mdGVuIHRoZSBtZXNzYWdlXG4gICAgICAgIC8vIGNvbnRhaW5zIFJQQyBhcmd1bWVudHMgdGhhdCBkb24ndCBjbG9uZSBwcm9wZXJseS4gIFNvXG4gICAgICAgIC8vIGluc3RlYWQgd2Ugd2lsbCBtdXRhdGUgcmVwbHlCb3ggYW5kIHB1dCBpdCBiYWNrIGFmdGVyLlxuXG4gICAgICAgIC8vIEV2ZW4gYmV0dGVyIHNvbHV0aW9uIHdvdWxkIGJlIHRvIG1vdmUgcmVwbHlCb3ggdG8gYVxuICAgICAgICAvLyBwcm9wZXJ0eSBvbiBNZXNzYWdlIGFuZCBoYXZlIGN1c3RvbSBzZXJpYWxpemF0aW9uIGluIGl0IHRvXG4gICAgICAgIC8vIGRvIHRoZSByZWdpc3RyYXRpb24uXG4gICAgICAgIG1lc3NhZ2UuYXR0cmlidXRlcy5yZXBseUJveCA9IHRoaXMuX19jb250ZXh0X18ucmVnaXN0cnkucmVnaXN0ZXIoXG4gICAgICAgICAgICBtZXNzYWdlLmF0dHJpYnV0ZXMucmVwbHlCb3guaWQsIG51bGwsIG1lc3NhZ2UuYXR0cmlidXRlcy5yZXBseUJveCk7XG5cbiAgICAgICAgLy8gVE9ETzogVGhlcmUgc2hvdWxkIGJlIGEgYmV0dGVyIHdheSB0byBkbyB0aGlzLlxuICAgICAgICByZXBseUJveCA9IHRoaXMuUmVwbHlCb3guY3JlYXRlKHtcbiAgICAgICAgICBpZDogbWVzc2FnZS5hdHRyaWJ1dGVzLnJlcGx5Qm94Lm5hbWVcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHZhciBwYXlsb2FkID0gdGhpcy5vdXRwdXR0ZXIuc3RyaW5naWZ5KG1lc3NhZ2UpO1xuXG4gICAgICBpZiAoIHJlcGx5Qm94ICkge1xuICAgICAgICBtZXNzYWdlLmF0dHJpYnV0ZXMucmVwbHlCb3ggPSByZXBseUJveDtcbiAgICAgIH1cblxuICAgICAgdGhpcy5wb3J0LnBvc3RNZXNzYWdlKHBheWxvYWQpO1xuICAgIH1cbiAgXVxufSk7XG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBUaGUgRk9BTSBBdXRob3JzLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5mb2FtLkNMQVNTKHtcbiAgcGFja2FnZTogJ2ZvYW0uYm94JyxcbiAgbmFtZTogJ1dlYlNvY2tldEJveCcsXG5cbiAgcmVxdWlyZXM6IFtcbiAgICAnZm9hbS5uZXQud2ViLldlYlNvY2tldCcsXG4gICAgJ2ZvYW0uYm94Lk1lc3NhZ2UnLFxuICAgICdmb2FtLmJveC5SYXdXZWJTb2NrZXRCb3gnXG4gIF0sXG5cbiAgaW1wb3J0czogW1xuICAgICd3ZWJTb2NrZXRTZXJ2aWNlJyxcbiAgICAnbWUnLFxuICAgICd3aW5kb3cnXG4gIF0sXG5cbiAgYXhpb21zOiBbXG4gICAgZm9hbS5wYXR0ZXJuLk11bHRpdG9uLmNyZWF0ZSh7XG4gICAgICBwcm9wZXJ0eTogJ3VyaSdcbiAgICB9KVxuICBdLFxuXG4gIHByb3BlcnRpZXM6IFtcbiAgICB7XG4gICAgICBuYW1lOiAndXJpJyxcbiAgICB9LFxuICAgIHtcbiAgICAgIG5hbWU6ICdkZWxlZ2F0ZScsXG4gICAgICBmYWN0b3J5OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHdzID0gdGhpcy5XZWJTb2NrZXQuY3JlYXRlKHtcbiAgICAgICAgICB1cmk6IHRoaXMucHJlcGFyZVVSTCh0aGlzLnVyaSksXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiB3cy5jb25uZWN0KCkudGhlbihmdW5jdGlvbih3cykge1xuICAgICAgICAgIHdzLmRpc2Nvbm5lY3RlZC5zdWIoZnVuY3Rpb24oc3ViKSB7XG4gICAgICAgICAgICBzdWIuZGV0YWNoKCk7XG4gICAgICAgICAgICB0aGlzLmRlbGVnYXRlID0gdW5kZWZpbmVkO1xuICAgICAgICAgIH0uYmluZCh0aGlzKSk7XG5cbiAgICAgICAgICB0aGlzLndlYlNvY2tldFNlcnZpY2UuYWRkU29ja2V0KHdzKTtcblxuICAgICAgICAgIHJldHVybiB0aGlzLlJhd1dlYlNvY2tldEJveC5jcmVhdGUoeyBzb2NrZXQ6IHdzIH0pO1xuICAgICAgICB9LmJpbmQodGhpcyksIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAvLyBGYWlsZWQgdG8gY29ubmVjdCwgY2xlYXIgdGhlIGRlbGVnYXRlIHNvIHRoYXQgdGhlIG5leHQgc2VuZFxuICAgICAgICAgIC8vIHdpbGwgcmVjb25uZWN0LlxuICAgICAgICAgIHRoaXMuZGVsZWdhdGUgPSB1bmRlZmluZWQ7XG4gICAgICAgIH0uYmluZCh0aGlzKSk7XG4gICAgICB9XG4gICAgfVxuICBdLFxuXG4gIG1ldGhvZHM6IFtcbiAgICBmdW5jdGlvbiBwcmVwYXJlVVJMKHVybCkge1xuICAgICAgLyogQWRkIHdpbmRvdydzIG9yaWdpbiBpZiB1cmwgaXMgbm90IGNvbXBsZXRlLiAqL1xuICAgICAgaWYgKCB0aGlzLndpbmRvdyAmJiB1cmwuaW5kZXhPZignOicpID09IC0xICkge1xuICAgICAgICB2YXIgcHJvdG9jb2wgPSBcIndzOi8vXCI7XG4gICAgICAgIGlmICggdGhpcy53aW5kb3cubG9jYXRpb24ucHJvdG9jb2wgPT09IFwiaHR0cHM6XCIgKSB7XG4gICAgICAgICAgcHJvdG9jb2wgPSBcIndzczovL1wiO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHByb3RvY29sICsgdGhpcy53aW5kb3cubG9jYXRpb24uaG9zdG5hbWUgK1xuICAgICAgICAgICggdGhpcy53aW5kb3cubG9jYXRpb24ucG9ydCA/ICc6JyArICggcGFyc2VJbnQodGhpcy53aW5kb3cubG9jYXRpb24ucG9ydCkgKyAxICkgOiAnJyApICtcbiAgICAgICAgICAnLycgKyB1cmw7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB1cmw7XG4gICAgfSxcblxuICAgIHtcbiAgICAgIG5hbWU6ICdzZW5kJyxcbiAgICAgIGNvZGU6IGZ1bmN0aW9uIHNlbmQobXNnKSB7XG4gICAgICAgIHRoaXMuZGVsZWdhdGUudGhlbihmdW5jdGlvbihkKSB7XG4gICAgICAgICAgZC5zZW5kKG1zZyk7XG4gICAgICAgIH0sIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAvLyBGYWlsZWQgdG8gY29ubmVjdC5cbiAgICAgICAgICBpZiAoIG1zZy5hdHRyaWJ1dGVzLnJlcGx5Qm94ICkgbXNnLmF0dHJpYnV0ZXMucmVwbHlCb3guc2VuZChmb2FtLmJveC5NZXNzYWdlLmNyZWF0ZSh7XG4gICAgICAgICAgICBvYmplY3Q6IGVcbiAgICAgICAgICB9KSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgXVxufSk7XG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBUaGUgRk9BTSBBdXRob3JzLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5mb2FtLkNMQVNTKHtcbiAgcGFja2FnZTogJ2ZvYW0uYm94JyxcbiAgbmFtZTogJ0NsYXNzV2hpdGVsaXN0Q29udGV4dCcsXG4gIGV4cG9ydHM6IFtcbiAgICAnbG9va3VwJ1xuICBdLFxuICBwcm9wZXJ0aWVzOiBbXG4gICAge1xuICAgICAgY2xhc3M6ICdTdHJpbmdBcnJheScsXG4gICAgICBuYW1lOiAnd2hpdGVsaXN0J1xuICAgIH0sXG4gICAge1xuICAgICAgbmFtZTogJ3doaXRlbGlzdF8nLFxuICAgICAgZXhwcmVzc2lvbjogZnVuY3Rpb24od2hpdGVsaXN0KSB7XG4gICAgICAgIHZhciB3ID0ge307XG4gICAgICAgIGZvciAoIHZhciBpID0gMCA7IGkgPCB3aGl0ZWxpc3QubGVuZ3RoIDsgaSsrICkge1xuICAgICAgICAgIHdbd2hpdGVsaXN0W2ldXSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHc7XG4gICAgICB9LFxuICAgICAgc3dpZnRUeXBlOiAnU2V0PFN0cmluZz4nLFxuICAgICAgc3dpZnRFeHByZXNzaW9uQXJnczogWyd3aGl0ZWxpc3QnXSxcbiAgICAgIHN3aWZ0RXhwcmVzc2lvbjogZnVuY3Rpb24oKSB7LypcbnZhciB3ID0gU2V0PFN0cmluZz4oKVxuZm9yIGkgaW4gd2hpdGVsaXN0IHtcbiAgdy5pbnNlcnQoaSlcbn1cbnJldHVybiB3XG4gICAgICAqL31cbiAgICB9XG4gIF0sXG4gIG1ldGhvZHM6IFtcbiAgICB7XG4gICAgICBjbGFzczogJ0NvbnRleHRNZXRob2QnLFxuICAgICAgbmFtZTogJ2xvb2t1cCcsXG4gICAgICBzd2lmdFJldHVybnM6ICdDbGFzc0luZm8/JyxcbiAgICAgIHN3aWZ0VGhyb3dzOiB0cnVlLFxuICAgICAgYXJnczogW1xuICAgICAgICB7XG4gICAgICAgICAgc3dpZnRUeXBlOiAnQ29udGV4dCcsXG4gICAgICAgICAgbmFtZTogJ1gnLFxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgc3dpZnRUeXBlOiAnU3RyaW5nJyxcbiAgICAgICAgICBuYW1lOiAnaWQnLFxuICAgICAgICB9LFxuICAgICAgXSxcbiAgICAgIGNvZGU6IGZ1bmN0aW9uKFgsIGlkKSB7XG4gICAgICAgIC8vIFRPRE86IFRoaXMgc2hvdWxkIGJlOlxuICAgICAgICAvLyBpZiAoICEgdGhpcy53aGl0ZWxpc3RfW2lkXSApIHsgLi4uIH1cbiAgICAgICAgLy8gQ2hhbmdlIGl0IGJhY2sgb25jZSAjNzc3IGlzIGNsb3NlZC5cbiAgICAgICAgaWYgKCB0aGlzLndoaXRlbGlzdC5pbmRleE9mKGlkKSA9PT0gLTEgKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDbGFzcyBcIicgKyBpZCArICdcIiBpcyBub3Qgd2hpdGVsaXN0ZWQuJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX19jb250ZXh0X18ubG9va3VwLmNhbGwoWCwgaWQpO1xuICAgICAgfSxcbiAgICAgIHN3aWZ0Q29kZTogZnVuY3Rpb24oKSB7LypcbmlmIHdoaXRlbGlzdC5jb250YWlucyhpZCkge1xuICB0aHJvdyBGb2FtRXJyb3IoXCJDbGFzcyBcIiArIGlkICsgXCIgaXMgbm90IHdoaXRlbGlzdGVkLlwiKVxufVxucmV0dXJuIFgubG9va3VwKGlkKVxuICAgICAgKi99XG4gICAgfVxuICBdXG59KTtcbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IFRoZSBGT0FNIEF1dGhvcnMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmZvYW0uQ0xBU1Moe1xuICBwYWNrYWdlOiAnZm9hbS5ib3gnLFxuICBuYW1lOiAnTG9nZ2VkTG9va3VwQ29udGV4dCcsXG5cbiAgZXhwb3J0czogW1xuICAgICdsb29rdXAnLFxuICBdLFxuXG4gIHByb3BlcnRpZXM6IFtcbiAgICB7XG4gICAgICBjbGFzczogJ01hcCcsXG4gICAgICBuYW1lOiAncmVjb3JkJ1xuICAgIH1cbiAgXSxcblxuICBtZXRob2RzOiBbXG4gICAge1xuICAgICAgY2xhc3M6ICdDb250ZXh0TWV0aG9kJyxcbiAgICAgIG5hbWU6ICdsb29rdXAnLFxuICAgICAgc3dpZnRSZXR1cm5zOiAnQ2xhc3NJbmZvPycsXG4gICAgICBzd2lmdFRocm93czogdHJ1ZSxcbiAgICAgIGFyZ3M6IFtcbiAgICAgICAge1xuICAgICAgICAgIHN3aWZ0VHlwZTogJ0NvbnRleHQnLFxuICAgICAgICAgIG5hbWU6ICdYJyxcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIHN3aWZ0VHlwZTogJ1N0cmluZycsXG4gICAgICAgICAgbmFtZTogJ2lkJyxcbiAgICAgICAgfSxcbiAgICAgIF0sXG4gICAgICBjb2RlOiBmdW5jdGlvbihYLCBpZCwgb3B0X3N1cHByZXNzKSB7XG4gICAgICAgIHRoaXMucmVjb3JkW2lkXSA9IGlkO1xuICAgICAgICByZXR1cm4gdGhpcy5fX2NvbnRleHRfXy5sb29rdXAuY2FsbChYLCBpZCwgb3B0X3N1cHByZXNzKTtcbiAgICAgIH0sXG4gICAgICBzd2lmdENvZGU6IGZ1bmN0aW9uKCkgey8qXG5yZWNvcmRbaWRdID0gaWQ7XG5yZXR1cm4gWC5sb29rdXAoaWQpXG4gICAgICAqL31cbiAgICB9XG4gIF1cbn0pO1xuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgVGhlIEZPQU0gQXV0aG9ycy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuZm9hbS5DTEFTUyh7XG4gIHBhY2thZ2U6ICdmb2FtLmJveCcsXG4gIG5hbWU6ICdDb250ZXh0JyxcbiAgc3dpZnROYW1lOiAnQm94Q29udGV4dCcsXG5cbiAgcmVxdWlyZXM6IFtcbiAgICAnZm9hbS5ib3guQm94UmVnaXN0cnlCb3gnLFxuICAgICdmb2FtLmJveC5OYW1lZEJveCcsXG4gICAgJ2ZvYW0uYm94LkNsYXNzV2hpdGVsaXN0Q29udGV4dCcsXG4gICAgJ2ZvYW0uYm94LkxvZ2dlZExvb2t1cENvbnRleHQnLFxuICBdLFxuXG4gIGV4cG9ydHM6IFtcbiAgICAnY3JlYXRpb25Db250ZXh0JyxcbiAgICAnbWUnLFxuICAgICdtZXNzYWdlUG9ydFNlcnZpY2UnLFxuICAgICdyZWdpc3RyeScsXG4gICAgJ3Jvb3QnLFxuICAgICdzb2NrZXRTZXJ2aWNlJyxcbiAgICAnd2ViU29ja2V0U2VydmljZSdcbiAgXSxcblxuICBwcm9wZXJ0aWVzOiBbXG4gICAge1xuICAgICAgbmFtZTogJ21lc3NhZ2VQb3J0U2VydmljZScsXG4gICAgICBoaWRkZW46IHRydWUsXG4gICAgICBmYWN0b3J5OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIG1vZGVsID0gdGhpcy5sb29rdXAoJ2ZvYW0ubWVzc2FnZXBvcnQuTWVzc2FnZVBvcnRTZXJ2aWNlJywgdHJ1ZSk7XG4gICAgICAgIGlmICggbW9kZWwgKSB7XG4gICAgICAgICAgcmV0dXJuIG1vZGVsLmNyZWF0ZSh7XG4gICAgICAgICAgICBkZWxlZ2F0ZTogdGhpcy5yZWdpc3RyeVxuICAgICAgICAgIH0sIHRoaXMpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICB7XG4gICAgICBuYW1lOiAnc29ja2V0U2VydmljZScsXG4gICAgICBoaWRkZW46IHRydWUsXG4gICAgICBmYWN0b3J5OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIG1vZGVsID0gdGhpcy5sb29rdXAoJ2ZvYW0ubmV0Lm5vZGUuU29ja2V0U2VydmljZScsIHRydWUpO1xuICAgICAgICBpZiAoIG1vZGVsICkge1xuICAgICAgICAgIHJldHVybiBtb2RlbC5jcmVhdGUoe1xuICAgICAgICAgICAgcG9ydDogTWF0aC5mbG9vciggMTAwMDAgKyAoIE1hdGgucmFuZG9tKCkgKiAxMDAwMCApICksXG4gICAgICAgICAgICBkZWxlZ2F0ZTogdGhpcy5yZWdpc3RyeVxuICAgICAgICAgIH0sIHRoaXMpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgc3dpZnRGYWN0b3J5OiBgXG5yZXR1cm4gX19jb250ZXh0X18ubG9va3VwKFwiZm9hbS5zd2lmdC5uZXQuU29ja2V0U2VydmljZVwiKSEuY3JlYXRlKGFyZ3M6IFtcbiAgXCJkZWxlZ2F0ZSRcIjogcmVnaXN0cnkkLFxuXSwgeDogX19zdWJDb250ZXh0X18pXG4gICAgICBgLFxuICAgIH0sXG4gICAge1xuICAgICAgbmFtZTogJ3dlYlNvY2tldFNlcnZpY2UnLFxuICAgICAgaGlkZGVuOiB0cnVlLFxuICAgICAgZmFjdG9yeTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBtb2RlbCA9IHRoaXMubG9va3VwKCdmb2FtLm5ldC5ub2RlLldlYlNvY2tldFNlcnZpY2UnLCB0cnVlKSB8fFxuICAgICAgICAgICAgdGhpcy5sb29rdXAoJ2ZvYW0ubmV0LndlYi5XZWJTb2NrZXRTZXJ2aWNlJywgdHJ1ZSk7XG5cbiAgICAgICAgaWYgKCBtb2RlbCApIHtcbiAgICAgICAgICByZXR1cm4gbW9kZWwuY3JlYXRlKHtcbiAgICAgICAgICAgIGRlbGVnYXRlOiB0aGlzLnJlZ2lzdHJ5XG4gICAgICAgICAgfSwgdGhpcyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIHtcbiAgICAgIGNsYXNzOiAnRk9iamVjdFByb3BlcnR5JyxcbiAgICAgIG9mOiAnZm9hbS5ib3guQm94JyxcbiAgICAgIG5hbWU6ICdyZWdpc3RyeScsXG4gICAgICBoaWRkZW46IHRydWUsXG4gICAgICBmYWN0b3J5OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuQm94UmVnaXN0cnlCb3guY3JlYXRlKCk7XG4gICAgICB9LFxuICAgICAgc3dpZnRGYWN0b3J5OiAncmV0dXJuIEJveFJlZ2lzdHJ5Qm94X2NyZWF0ZSgpJyxcbiAgICB9LFxuICAgIHtcbiAgICAgIGNsYXNzOiAnRk9iamVjdFByb3BlcnR5JyxcbiAgICAgIG9mOiAnZm9hbS5ib3guQm94JyxcbiAgICAgIG5hbWU6ICdyb290JyxcbiAgICAgIGhpZGRlbjogdHJ1ZSxcbiAgICAgIHBvc3RTZXQ6IGZ1bmN0aW9uKF8sIHJvb3QpIHtcbiAgICAgICAgZm9hbS5ib3guTmFtZWRCb3guY3JlYXRlKHsgbmFtZTogJycgfSkuZGVsZWdhdGUgPSByb290O1xuICAgICAgfSxcbiAgICAgIHN3aWZ0UG9zdFNldDogJ05hbWVkQm94X2NyZWF0ZShbXCJuYW1lXCI6IFwiXCJdKS5kZWxlZ2F0ZSA9IG5ld1ZhbHVlIScsXG4gICAgfSxcbiAgICB7XG4gICAgICBjbGFzczogJ1N0cmluZycsXG4gICAgICBuYW1lOiAnbXluYW1lJyxcbiAgICAgIGhpZGRlbjogdHJ1ZSxcbiAgICAgIHN3aWZ0RmFjdG9yeTpcbiAgICAgICAgICAncmV0dXJuIFwiL2NvbS9mb2FtZGV2L2Fub255bW91cy9cIiArIFVVSUQoKS51dWlkU3RyaW5nJyxcbiAgICAgIGZhY3Rvcnk6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gZm9hbS5pc1NlcnZlciA/XG4gICAgICAgICAgJy9wcm9jLycgKyByZXF1aXJlKCdwcm9jZXNzJykucGlkICsgJy8nICsgZm9hbS51dWlkLnJhbmRvbUdVSUQoKSA6XG4gICAgICAgICAgJy9jb20vZm9hbWRldi9hbm9ueW1vdXMvJyArIGZvYW0udXVpZC5yYW5kb21HVUlEKCk7XG4gICAgICB9XG4gICAgfSxcbiAgICB7XG4gICAgICBuYW1lOiAnbWUnLFxuICAgICAgaGlkZGVuOiB0cnVlLFxuICAgICAgdHJhbnNpZW50OiB0cnVlLFxuICAgICAgZmFjdG9yeTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBtZSA9IHRoaXMuTmFtZWRCb3guY3JlYXRlKHsgbmFtZTogdGhpcy5teW5hbWUgfSk7XG4gICAgICAgIG1lLmRlbGVnYXRlID0gdGhpcy5yZWdpc3RyeTtcbiAgICAgICAgcmV0dXJuIG1lO1xuICAgICAgfSxcbiAgICAgIHN3aWZ0RmFjdG9yeTogZnVuY3Rpb24oKSB7LypcbiAgICAgICAgbGV0IG1lID0gTmFtZWRCb3hfY3JlYXRlKFtcIm5hbWVcIjogc2VsZi5teW5hbWVdKVxuICAgICAgICBtZS5kZWxlZ2F0ZSA9IHNlbGYucmVnaXN0cnkhXG4gICAgICAgIHJldHVybiBtZVxuICAgICAgKi99LFxuICAgIH0sXG4gICAge1xuICAgICAgY2xhc3M6ICdCb29sZWFuJyxcbiAgICAgIG5hbWU6ICd1bnNhZmUnLFxuICAgICAgdmFsdWU6IHRydWVcbiAgICB9LFxuICAgIHtcbiAgICAgIGNsYXNzOiAnU3RyaW5nQXJyYXknLFxuICAgICAgbmFtZTogJ2NsYXNzV2hpdGVsaXN0J1xuICAgIH0sXG4gICAge1xuICAgICAgbmFtZTogJ2NyZWF0aW9uQ29udGV4dCcsXG4gICAgICBkb2N1bWVudGF0aW9uOiBgUHJvdmlkZXMgcmVxdWlyZWQgaW1wb3J0IGZvciBib3hlcyB0aGF0IHBhcnNlIHN0cmluZ3MgaW50b1xuICAgICAgICAgIEZPYmplY3RzLmAsXG4gICAgICBoaWRkZW46IHRydWUsXG4gICAgICBmYWN0b3J5OiBmdW5jdGlvbigpIHtcbiAgICAgICAgLy8gVE9ETzogQmV0dGVyIHdheSB0byBpbmplY3QgdGhlIGNsYXNzIHdoaXRlbGlzdC5cbiAgICAgICAgaWYgKCB0aGlzLnVuc2FmZSApIHtcbiAgICAgICAgICBjb25zb2xlLndhcm4oJyoqKiogQm94ZXMgYXJlIHJ1bm5pbmcgaW4gVU5TQUZFIG1vZGUuICBUdXJuIHRoaXMgb2ZmIGJlZm9yZSB5b3UgZ28gdG8gcHJvZHVjdGlvbiEnKTtcbiAgICAgICAgICByZXR1cm4gdGhpcy5Mb2dnZWRMb29rdXBDb250ZXh0LmNyZWF0ZShudWxsLCB0aGlzKS5fX3N1YkNvbnRleHRfXztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLkNsYXNzV2hpdGVsaXN0Q29udGV4dC5jcmVhdGUoe1xuICAgICAgICAgIHdoaXRlbGlzdDogdGhpcy5jbGFzc1doaXRlbGlzdFxuICAgICAgICB9LCB0aGlzKS5fX3N1YkNvbnRleHRfXztcbiAgICAgIH0sXG4gICAgICBzd2lmdEZhY3Rvcnk6IGBcbnJldHVybiBDbGFzc1doaXRlbGlzdENvbnRleHRfY3JlYXRlKFtcbiAgXCJ3aGl0ZWxpc3QkXCI6IGNsYXNzV2hpdGVsaXN0JCxcbl0pLl9fc3ViQ29udGV4dF9fXG4gICAgICBgLFxuICAgIH1cbiAgXVxufSk7XG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBUaGUgRk9BTSBBdXRob3JzLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5mb2FtLkNMQVNTKHtcbiAgcGFja2FnZTogJ2ZvYW0uYm94JyxcbiAgbmFtZTogJ0JveFNlcnZpY2UnLFxuXG4gIHByb3BlcnRpZXM6IFtcbiAgICB7XG4gICAgICBjbGFzczogJ0NsYXNzJyxcbiAgICAgIG5hbWU6ICdzZXJ2ZXInXG4gICAgfSxcbiAgICB7XG4gICAgICBjbGFzczogJ0NsYXNzJyxcbiAgICAgIG5hbWU6ICdjbGllbnQnXG4gICAgfSxcbiAgICB7XG4gICAgICBjbGFzczogJ0ZPYmplY3RQcm9wZXJ0eScsXG4gICAgICBvZjogJ2ZvYW0uYm94LkJveFNlcnZpY2UnLFxuICAgICAgbmFtZTogJ25leHQnXG4gICAgfVxuICBdLFxuXG4gIG1ldGhvZHM6IFtcbiAgICB7XG4gICAgICBuYW1lOiAnc2VydmVyQm94JyxcbiAgICAgIGFyZ3M6IFtcbiAgICAgICAge1xuICAgICAgICAgIHN3aWZ0VHlwZTogJ0JveCcsXG4gICAgICAgICAgbmFtZTogJ2JveCcsXG4gICAgICAgIH0sXG4gICAgICBdLFxuICAgICAgcmV0dXJuczogJ2ZvYW0uYm94LkJveCcsXG4gICAgICBjb2RlOiBmdW5jdGlvbiBzZXJ2ZXJCb3goYm94KSB7XG4gICAgICAgIGJveCA9IHRoaXMubmV4dCA/IHRoaXMubmV4dC5zZXJ2ZXJCb3goYm94KSA6IGJveDtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VydmVyID8gdGhpcy5zZXJ2ZXIuY3JlYXRlKHsgZGVsZWdhdGU6IGJveCB9KSA6IGJveDtcbiAgICAgIH0sXG4gICAgICBzd2lmdENvZGU6IGZ1bmN0aW9uKCkgey8qXG5sZXQgYm94MjogQm94ID0gbmV4dD8uc2VydmVyQm94KGJveCkgPz8gYm94XG5yZXR1cm4gc2VydmVyLmNyZWF0ZShhcmdzOiBbXCJkZWxlZ2F0ZVwiOiBib3gyXSwgeDogX19zdWJDb250ZXh0X18pIGFzISBCb3hcbiAgICAgICovfSxcbiAgICB9LFxuICAgIHtcbiAgICAgIG5hbWU6ICdjbGllbnRCb3gnLFxuICAgICAgYXJnczogW1xuICAgICAgICB7XG4gICAgICAgICAgbmFtZTogJ2JveCcsXG4gICAgICAgICAgc3dpZnRUeXBlOiAnQm94JyxcbiAgICAgICAgfSxcbiAgICAgIF0sXG4gICAgICByZXR1cm5zOiAnZm9hbS5ib3guQm94JyxcbiAgICAgIGNvZGU6IGZ1bmN0aW9uKGJveCkge1xuICAgICAgICBib3ggPSB0aGlzLmNsaWVudCA/IHRoaXMuY2xpZW50LmNyZWF0ZSh7IGRlbGVnYXRlOiBib3ggfSkgOiBib3g7XG4gICAgICAgIHJldHVybiB0aGlzLm5leHQgP1xuICAgICAgICAgIHRoaXMubmV4dC5jbGllbnRCb3goYm94KSA6XG4gICAgICAgICAgYm94O1xuICAgICAgfSxcbiAgICAgIHN3aWZ0Q29kZTogZnVuY3Rpb24oKSB7LypcbmxldCBib3gyID0gY2xpZW50LmNyZWF0ZShhcmdzOiBbXCJkZWxlZ2F0ZVwiOiBib3hdLCB4OiBfX3N1YkNvbnRleHRfXykgYXMhIEJveFxucmV0dXJuIG5leHQ/LmNsaWVudEJveChib3gyKSA/PyBib3gyXG4gICAgICAqL30sXG4gICAgfSxcbiAgXVxufSk7XG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBUaGUgRk9BTSBBdXRob3JzLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5mb2FtLkNMQVNTKHtcbiAgcGFja2FnZTogJ2ZvYW0uYm94JyxcbiAgbmFtZTogJ0hUVFBSZXBseUJveCcsXG4gIGltcGxlbWVudHM6IFsnZm9hbS5ib3guQm94J10sXG5cbiAgaW1wb3J0czogW1xuICAgIC8vIE9wdGlvbmFsIGltcG9ydC5cbiAgICAvLyAgICAnaHR0cFJlc3BvbnNlJ1xuICBdLFxuXG4gIG1ldGhvZHM6IFtcbiAgICB7XG4gICAgICBuYW1lOiAnc2VuZCcsXG4gICAgICBjb2RlOiBmdW5jdGlvbihtKSB7XG4gICAgICAgIHRocm93ICd1bmltcGxlbWVudGVkJztcbiAgICAgIH0sXG4gICAgICBzd2lmdENvZGU6ICd0aHJvdyBGb2FtRXJyb3IoXCJ1bmltcGxlbWVudGVkXCIpJyxcbiAgICB9XG4gIF1cbn0pO1xuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgVGhlIEZPQU0gQXV0aG9ycy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuZm9hbS5DTEFTUyh7XG4gIHBhY2thZ2U6ICdmb2FtLmJveCcsXG4gIG5hbWU6ICdBdXRoZW50aWNhdGVkQm94JyxcbiAgZXh0ZW5kczogJ2ZvYW0uYm94LlByb3h5Qm94JyxcblxuICBpbXBvcnRzOiBbXG4gICAgJ2lkVG9rZW4nXG4gIF0sXG5cbiAgbWV0aG9kczogW1xuICAgIGZ1bmN0aW9uIHNlbmQobSkge1xuICAgICAgbS5hdHRyaWJ1dGVzLmlkVG9rZW4gPSB0aGlzLmlkVG9rZW47XG4gICAgICB0aGlzLlNVUEVSKG0pO1xuICAgIH1cbiAgXVxufSk7XG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBUaGUgRk9BTSBBdXRob3JzLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5mb2FtLkNMQVNTKHtcbiAgcGFja2FnZTogJ2ZvYW0uYm94JyxcbiAgbmFtZTogJ0NoZWNrQXV0aGVudGljYXRpb25Cb3gnLFxuICBleHRlbmRzOiAnZm9hbS5ib3guUHJveHlCb3gnLFxuXG4gIGltcG9ydHM6IFtcbiAgICAndG9rZW5WZXJpZmllcidcbiAgXSxcblxuICBtZXRob2RzOiBbXG4gICAge1xuICAgICAgbmFtZTogJ3NlbmQnLFxuICAgICAgY29kZTogZnVuY3Rpb24gc2VuZCgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmltcGxlbWVudGVkLicpO1xuICAgICAgfVxuICAgIH1cbiAgXVxufSk7XG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBUaGUgRk9BTSBBdXRob3JzLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKi9cbmZvYW0uQ0xBU1Moe1xuICBwYWNrYWdlOiAnZm9hbS5ib3gnLFxuICBuYW1lOiAnSFRUUEV4Y2VwdGlvbicsXG4gIGltcGxlbWVudHM6IFsgJ2ZvYW0uY29yZS5FeGNlcHRpb24nIF0sXG4gIHByb3BlcnRpZXM6IFtcbiAgICAncmVzcG9uc2UnXG4gIF1cbn0pO1xuXG5mb2FtLkNMQVNTKHtcbiAgcGFja2FnZTogJ2ZvYW0uYm94JyxcbiAgbmFtZTogJ0hUVFBCb3gnLFxuXG4gIGltcGxlbWVudHM6IFsgJ2ZvYW0uYm94LkJveCcgXSxcblxuICByZXF1aXJlczogW1xuICAgIHtcbiAgICAgIHBhdGg6ICdmb2FtLmpzb24uUGFyc2VyJyxcbiAgICAgIGZsYWdzOiBbJ2pzJ10sXG4gICAgfSxcbiAgICB7XG4gICAgICBwYXRoOiAnZm9hbS5uZXQud2ViLkhUVFBSZXF1ZXN0JyxcbiAgICAgIGZsYWdzOiBbJ2pzJ10sXG4gICAgfSxcbiAgICB7XG4gICAgICBwYXRoOiAnZm9hbS5qc29uLk91dHB1dHRlcicsXG4gICAgICBmbGFnczogWydqcyddLFxuICAgIH0sXG4gICAge1xuICAgICAgcGF0aDogJ2ZvYW0uc3dpZnQucGFyc2UuanNvbi5GT2JqZWN0UGFyc2VyJyxcbiAgICAgIGZsYWdzOiBbJ3N3aWZ0J10sXG4gICAgfSxcbiAgICB7XG4gICAgICBuYW1lOiAnU3dpZnRPdXRwdXR0ZXInLFxuICAgICAgcGF0aDogJ2ZvYW0uc3dpZnQucGFyc2UuanNvbi5vdXRwdXQuT3V0cHV0dGVyJyxcbiAgICAgIGZsYWdzOiBbJ3N3aWZ0J10sXG4gICAgfSxcbiAgICAnZm9hbS5ib3guSFRUUFJlcGx5Qm94JyxcbiAgXSxcblxuICBpbXBvcnRzOiBbXG4gICAgJ2NyZWF0aW9uQ29udGV4dCcsXG4gICAge1xuICAgICAgbmFtZTogJ21lJyxcbiAgICAgIGtleTogJ21lJyxcbiAgICAgIGphdmFUeXBlOiAnZm9hbS5ib3guQm94J1xuICAgIH0sXG4gICAgJ3dpbmRvdydcbiAgXSxcblxuICBwcm9wZXJ0aWVzOiBbXG4gICAge1xuICAgICAgY2xhc3M6ICdTdHJpbmcnLFxuICAgICAgbmFtZTogJ3VybCdcbiAgICB9LFxuICAgIHtcbiAgICAgIGNsYXNzOiAnU3RyaW5nJyxcbiAgICAgIG5hbWU6ICdtZXRob2QnLFxuICAgICAgdmFsdWU6ICdQT1NUJ1xuICAgIH0sXG4gICAge1xuICAgICAgY2xhc3M6ICdGT2JqZWN0UHJvcGVydHknLFxuICAgICAgb2Y6ICdmb2FtLmpzb24uUGFyc2VyJyxcbiAgICAgIHN3aWZ0VHlwZTogJ0ZPYmplY3RQYXJzZXInLFxuICAgICAgbmFtZTogJ3BhcnNlcicsXG4gICAgICBnZW5lcmF0ZUphdmE6IGZhbHNlLFxuICAgICAgZmFjdG9yeTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLlBhcnNlci5jcmVhdGUoe1xuICAgICAgICAgIHN0cmljdDogICAgICAgICAgdHJ1ZSxcbiAgICAgICAgICAvLyBUcnVzdCBvdXIgb3duIHNlcnZlciwgYnV0IGZvcmNlIG90aGVyIHNlcnZlcnMgdG8gZ28gdGhyb3VnaFxuICAgICAgICAgIC8vIHdoaXRlbGlzdC5cbiAgICAgICAgICBjcmVhdGlvbkNvbnRleHQ6IHRoaXMudXJsLmluZGV4T2YoJzonKSA9PSAtMSA/XG4gICAgICAgICAgICB0aGlzLl9fY29udGV4dF9fICAgICA6XG4gICAgICAgICAgICB0aGlzLmNyZWF0aW9uQ29udGV4dFxuICAgICAgICB9KTtcbiAgICAgIH0sXG4gICAgICBzd2lmdEZhY3Rvcnk6ICdyZXR1cm4gRk9iamVjdFBhcnNlcl9jcmVhdGUoKScsXG4gICAgfSxcbiAgICB7XG4gICAgICBjbGFzczogJ0ZPYmplY3RQcm9wZXJ0eScsXG4gICAgICBvZjogJ2ZvYW0uanNvbi5PdXRwdXR0ZXInLFxuICAgICAgbmFtZTogJ291dHB1dHRlcicsXG4gICAgICBnZW5lcmF0ZUphdmE6IGZhbHNlLFxuICAgICAgc3dpZnRGYWN0b3J5OiAncmV0dXJuIFN3aWZ0T3V0cHV0dGVyX2NyZWF0ZSgpJyxcbiAgICAgIGZhY3Rvcnk6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5PdXRwdXR0ZXIuY3JlYXRlKCkuY29weUZyb20oZm9hbS5qc29uLk5ldHdvcmspO1xuICAgICAgfVxuICAgIH1cbiAgXSxcblxuICBheGlvbXM6IFtcbiAgICB7XG4gICAgICBuYW1lOiAnamF2YUV4dHJhcycsXG4gICAgICBidWlsZEphdmFDbGFzczogZnVuY3Rpb24oY2xzKSB7XG4gICAgICAgIGNscy5leHRyYXMucHVzaChmb2FtLmphdmEuQ29kZS5jcmVhdGUoe1xuICAgICAgICAgIGRhdGE6IGBcbnByb3RlY3RlZCBjbGFzcyBPdXRwdXR0ZXIgZXh0ZW5kcyBmb2FtLmxpYi5qc29uLk91dHB1dHRlciB7XG4gIHB1YmxpYyBPdXRwdXR0ZXIoKSB7XG4gICAgc3VwZXIoZm9hbS5saWIuanNvbi5PdXRwdXR0ZXJNb2RlLk5FVFdPUkspO1xuICB9XG5cbiAgcHJvdGVjdGVkIHZvaWQgb3V0cHV0Rk9iamVjdChmb2FtLmNvcmUuRk9iamVjdCBvKSB7XG4gICAgaWYgKCBvID09IGdldE1lKCkgKSB7XG4gICAgICBvID0gZ2V0WCgpLmNyZWF0ZShmb2FtLmJveC5IVFRQUmVwbHlCb3guY2xhc3MpO1xuICAgIH1cbiAgICBzdXBlci5vdXRwdXRGT2JqZWN0KG8pO1xuICB9XG59XG5cbnByb3RlY3RlZCBjbGFzcyBSZXNwb25zZVRocmVhZCBpbXBsZW1lbnRzIFJ1bm5hYmxlIHtcbiAgcHJvdGVjdGVkIGphdmEubmV0LlVSTENvbm5lY3Rpb24gY29ubl87XG4gIHB1YmxpYyBSZXNwb25zZVRocmVhZChqYXZhLm5ldC5VUkxDb25uZWN0aW9uIGNvbm4pIHtcbiAgICBjb25uXyA9IGNvbm47XG4gIH1cblxuICBwdWJsaWMgdm9pZCBydW4oKSB7XG4gIH1cbn1cbmB9KSk7XG4gICAgICB9XG4gICAgfVxuICBdLFxuXG4gIG1ldGhvZHM6IFtcbiAgICBmdW5jdGlvbiBwcmVwYXJlVVJMKHVybCkge1xuICAgICAgLyogQWRkIHdpbmRvdydzIG9yaWdpbiBpZiB1cmwgaXMgbm90IGNvbXBsZXRlLiAqL1xuICAgICAgaWYgKCB0aGlzLndpbmRvdyAmJiB1cmwuaW5kZXhPZignOicpID09IC0xICkge1xuICAgICAgICByZXR1cm4gdGhpcy53aW5kb3cubG9jYXRpb24ub3JpZ2luICsgJy8nICsgdXJsO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdXJsO1xuICAgIH0sXG5cbiAgICB7XG4gICAgICBuYW1lOiAnc2VuZCcsXG4gICAgICBjb2RlOiBmdW5jdGlvbihtc2cpIHtcbiAgICAgICAgLy8gVE9ETzogV2Ugc2hvdWxkIHByb2JhYmx5IGNsb25lIGhlcmUsIGJ1dCBvZnRlbiB0aGUgbWVzc2FnZVxuICAgICAgICAvLyBjb250YWlucyBSUEMgYXJndW1lbnRzIHRoYXQgZG9uJ3QgY2xvbmUgcHJvcGVybHkuICBTb1xuICAgICAgICAvLyBpbnN0ZWFkIHdlIHdpbGwgbXV0YXRlIHJlcGx5Qm94IGFuZCBwdXQgaXQgYmFjayBhZnRlci5cbiAgICAgICAgdmFyIHJlcGx5Qm94ID0gbXNnLmF0dHJpYnV0ZXMucmVwbHlCb3g7XG5cbiAgICAgICAgbXNnLmF0dHJpYnV0ZXMucmVwbHlCb3ggPSB0aGlzLkhUVFBSZXBseUJveC5jcmVhdGUoKTtcblxuICAgICAgICB2YXIgcGF5bG9hZCA9IHRoaXMub3V0cHV0dGVyLnN0cmluZ2lmeShtc2cpO1xuXG4gICAgICAgIG1zZy5hdHRyaWJ1dGVzLnJlcGx5Qm94ID0gcmVwbHlCb3g7XG5cbiAgICAgICAgdmFyIHJlcSA9IHRoaXMuSFRUUFJlcXVlc3QuY3JlYXRlKHtcbiAgICAgICAgICB1cmw6ICAgICB0aGlzLnByZXBhcmVVUkwodGhpcy51cmwpLFxuICAgICAgICAgIG1ldGhvZDogIHRoaXMubWV0aG9kLFxuICAgICAgICAgIHBheWxvYWQ6IHBheWxvYWRcbiAgICAgICAgfSkuc2VuZCgpO1xuXG4gICAgICAgIHJlcS50aGVuKGZ1bmN0aW9uKHJlc3ApIHtcbiAgICAgICAgICByZXR1cm4gcmVzcC5wYXlsb2FkO1xuICAgICAgICB9KS50aGVuKGZ1bmN0aW9uKHApIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5wYXJzZXIuYXBhcnNlKHApO1xuICAgICAgICB9LmJpbmQodGhpcykpLnRoZW4oZnVuY3Rpb24ocm1zZykge1xuICAgICAgICAgIHJtc2cgJiYgcmVwbHlCb3ggJiYgcmVwbHlCb3guc2VuZChybXNnKTtcbiAgICAgICAgfS5iaW5kKHRoaXMpLCBmdW5jdGlvbihyKSB7XG4gICAgICAgICAgcmVwbHlCb3ggJiYgcmVwbHlCb3guc2VuZChmb2FtLmJveC5NZXNzYWdlLmNyZWF0ZSh7IG9iamVjdDogZm9hbS5ib3guSFRUUEV4Y2VwdGlvbi5jcmVhdGUoeyByZXNwb25zZTogciB9KSB9KSk7XG4gICAgICAgIH0pO1xuICAgICAgfSxcbiAgICAgIHN3aWZ0Q29kZTogZnVuY3Rpb24oKSB7LypcbmxldCByZXBseUJveCA9IG1zZy5hdHRyaWJ1dGVzW1wicmVwbHlCb3hcIl0gYXM/IEJveFxubXNnLmF0dHJpYnV0ZXNbXCJyZXBseUJveFwiXSA9IEhUVFBSZXBseUJveF9jcmVhdGUoKVxuXG52YXIgcmVxdWVzdCA9IFVSTFJlcXVlc3QodXJsOiBGb3VuZGF0aW9uLlVSTChzdHJpbmc6IHNlbGYudXJsKSEpXG5yZXF1ZXN0Lmh0dHBNZXRob2QgPSBcIlBPU1RcIlxucmVxdWVzdC5odHRwQm9keSA9IG91dHB1dHRlcj8uc3dpZnRTdHJpbmdpZnkobXNnKS5kYXRhKHVzaW5nOiAudXRmOClcblxubXNnLmF0dHJpYnV0ZXNbXCJyZXBseUJveFwiXSA9IHJlcGx5Qm94XG5cbmxldCB0YXNrID0gVVJMU2Vzc2lvbi5zaGFyZWQuZGF0YVRhc2sod2l0aDogcmVxdWVzdCkgeyBkYXRhLCByZXNwb25zZSwgZXJyb3IgaW5cbiAgZG8ge1xuICAgIGd1YXJkIGxldCBkYXRhID0gZGF0YSBlbHNlIHtcbiAgICAgIHRocm93IEZvYW1FcnJvcihcIkhUVFBCb3ggbm8gcmVzcG9uc2VcIilcbiAgICB9XG4gICAgZ3VhcmQgbGV0IHN0ciA9IFN0cmluZyhkYXRhOiBkYXRhLCBlbmNvZGluZzogLnV0ZjgpLFxuICAgICAgICAgIGxldCBvYmogPSBzZWxmLnBhcnNlci5wYXJzZVN0cmluZyhzdHIpIGFzPyBNZXNzYWdlIGVsc2Uge1xuICAgICAgdGhyb3cgRm9hbUVycm9yKFwiRmFpbGVkIHRvIHBhcnNlIEhUVFBCb3ggcmVzcG9uc2VcIilcbiAgICB9XG4gICAgdHJ5IHJlcGx5Qm94Py5zZW5kKG9iailcbiAgfSBjYXRjaCBsZXQgZSB7XG4gICAgdHJ5PyByZXBseUJveD8uc2VuZChzZWxmLl9fY29udGV4dF9fLmNyZWF0ZShNZXNzYWdlLnNlbGYsIGFyZ3M6IFtcIm9iamVjdFwiOiBlXSkhKVxuICB9XG59XG50YXNrLnJlc3VtZSgpXG4gICAgICAqL30sXG4gICAgICBqYXZhQ29kZTogYFxuLy8gVE9ETzogR28gYXN5bmMgYW5kIG1ha2UgcmVxdWVzdCBpbiBhIHNlcGFyYXRlIHRocmVhZC5cbmphdmEubmV0Lkh0dHBVUkxDb25uZWN0aW9uIGNvbm47XG5mb2FtLmJveC5Cb3ggcmVwbHlCb3ggPSAoZm9hbS5ib3guQm94KW1lc3NhZ2UuZ2V0QXR0cmlidXRlcygpLmdldChcInJlcGx5Qm94XCIpO1xuXG50cnkge1xuICBqYXZhLm5ldC5VUkwgdXJsID0gbmV3IGphdmEubmV0LlVSTChnZXRVcmwoKSk7XG4gIGNvbm4gPSAoamF2YS5uZXQuSHR0cFVSTENvbm5lY3Rpb24pdXJsLm9wZW5Db25uZWN0aW9uKCk7XG4gIGNvbm4uc2V0RG9PdXRwdXQodHJ1ZSk7XG4gIGNvbm4uc2V0UmVxdWVzdE1ldGhvZChcIlBPU1RcIik7XG4gIGNvbm4uc2V0UmVxdWVzdFByb3BlcnR5KFwiQWNjZXB0XCIsIFwiYXBwbGljYXRpb24vanNvblwiKTtcbiAgY29ubi5zZXRSZXF1ZXN0UHJvcGVydHkoXCJDb250ZW50LVR5cGVcIiwgXCJhcHBsaWNhdGlvbi9qc29uXCIpO1xuXG4gIGphdmEuaW8uT3V0cHV0U3RyZWFtV3JpdGVyIG91dHB1dCA9IG5ldyBqYXZhLmlvLk91dHB1dFN0cmVhbVdyaXRlcihjb25uLmdldE91dHB1dFN0cmVhbSgpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgamF2YS5uaW8uY2hhcnNldC5TdGFuZGFyZENoYXJzZXRzLlVURl84KTtcblxuXG4gIC8vIFRPRE86IENsb25lIG1lc3NhZ2Ugb3Igc29tZXRoaW5nIHdoZW4gaXQgY2xvbmVzIHNhZmVseS5cbiAgbWVzc2FnZS5nZXRBdHRyaWJ1dGVzKCkucHV0KFwicmVwbHlCb3hcIiwgZ2V0WCgpLmNyZWF0ZShmb2FtLmJveC5IVFRQUmVwbHlCb3guY2xhc3MpKTtcblxuXG4gIGZvYW0ubGliLmpzb24uT3V0cHV0dGVyIG91dHB1dHRlciA9IG5ldyBmb2FtLmxpYi5qc29uLk91dHB1dHRlcihmb2FtLmxpYi5qc29uLk91dHB1dHRlck1vZGUuTkVUV09SSyk7XG4gIG91dHB1dHRlci5zZXRYKGdldFgoKSk7XG4gIG91dHB1dC53cml0ZShvdXRwdXR0ZXIuc3RyaW5naWZ5KG1lc3NhZ2UpKTtcblxuICBtZXNzYWdlLmdldEF0dHJpYnV0ZXMoKS5wdXQoXCJyZXBseUJveFwiLCByZXBseUJveCk7XG5cbiAgb3V0cHV0LmNsb3NlKCk7XG5cbi8vIFRPRE86IFN3aXRjaCB0byBSZWFkZXJQU3RyZWFtIHdoZW4gaHR0cHM6Ly9naXRodWIuY29tL2ZvYW0tZnJhbWV3b3JrL2ZvYW0yL2lzc3Vlcy83NDUgaXMgZml4ZWQuXG5ieXRlW10gYnVmID0gbmV3IGJ5dGVbODM4ODYwOF07XG5qYXZhLmlvLklucHV0U3RyZWFtIGlucHV0ID0gY29ubi5nZXRJbnB1dFN0cmVhbSgpO1xuXG5pbnQgb2ZmID0gMDtcbmludCBsZW4gPSBidWYubGVuZ3RoO1xuaW50IHJlYWQgPSAtMTtcbndoaWxlICggbGVuICE9IDAgJiYgKCByZWFkID0gaW5wdXQucmVhZChidWYsIG9mZiwgbGVuKSApICE9IC0xICkge1xuICBvZmYgKz0gcmVhZDtcbiAgbGVuIC09IHJlYWQ7XG59XG5cbmlmICggbGVuID09IDAgJiYgcmVhZCAhPSAtMSApIHtcbiAgdGhyb3cgbmV3IFJ1bnRpbWVFeGNlcHRpb24oXCJNZXNzYWdlIHRvbyBsYXJnZS5cIik7XG59XG5cblN0cmluZyBzdHIgPSBuZXcgU3RyaW5nKGJ1ZiwgMCwgb2ZmLCBqYXZhLm5pby5jaGFyc2V0LlN0YW5kYXJkQ2hhcnNldHMuVVRGXzgpO1xuXG5mb2FtLmNvcmUuRk9iamVjdCByZXNwb25zZU1lc3NhZ2UgPSBnZXRYKCkuY3JlYXRlKGZvYW0ubGliLmpzb24uSlNPTlBhcnNlci5jbGFzcykucGFyc2VTdHJpbmcoc3RyKTtcblxuaWYgKCByZXNwb25zZU1lc3NhZ2UgPT0gbnVsbCApIHtcbiAgdGhyb3cgbmV3IFJ1bnRpbWVFeGNlcHRpb24oXCJFcnJvciBwYXJzaW5nIHJlc3BvbnNlLlwiKTtcbn1cblxuaWYgKCAhICggcmVzcG9uc2VNZXNzYWdlIGluc3RhbmNlb2YgZm9hbS5ib3guTWVzc2FnZSApICkge1xuICB0aHJvdyBuZXcgUnVudGltZUV4Y2VwdGlvbihcIkludmFsaWQgcmVzcG9uc2UgdHlwZTogXCIgKyByZXNwb25zZU1lc3NhZ2UuZ2V0Q2xhc3MoKS5nZXROYW1lKCkgKyBcIiBleHBlY3RlZCBmb2FtLmJveC5NZXNzYWdlLlwiKTtcbn1cblxuXG5yZXBseUJveC5zZW5kKChmb2FtLmJveC5NZXNzYWdlKXJlc3BvbnNlTWVzc2FnZSk7XG5cbn0gY2F0Y2goamF2YS5pby5JT0V4Y2VwdGlvbiBlKSB7XG4gIGZvYW0uYm94Lk1lc3NhZ2UgcmVwbHlNZXNzYWdlID0gZ2V0WCgpLmNyZWF0ZShmb2FtLmJveC5NZXNzYWdlLmNsYXNzKTtcbiAgcmVwbHlNZXNzYWdlLnNldE9iamVjdChlKTtcbiAgcmVwbHlCb3guc2VuZChyZXBseU1lc3NhZ2UpO1xufVxuYFxuICAgIH1cbiAgXVxufSk7XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IFRoZSBGT0FNIEF1dGhvcnMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmZvYW0uQ0xBU1Moe1xuICBwYWNrYWdlOiAnZm9hbS5ib3gnLFxuICBuYW1lOiAnTWVzc2FnZVBvcnRCb3gnLFxuICBleHRlbmRzOiAnZm9hbS5ib3guUHJveHlCb3gnLFxuXG4gIHJlcXVpcmVzOiBbXG4gICAgJ2ZvYW0uYm94LlJhd01lc3NhZ2VQb3J0Qm94JyxcbiAgICAnZm9hbS5ib3guUmVnaXN0ZXJTZWxmTWVzc2FnZScsXG4gICAgJ2ZvYW0uYm94Lk1lc3NhZ2UnLFxuICAgICdmb2FtLmpzb24uT3V0cHV0dGVyJ1xuICBdLFxuXG4gIGltcG9ydHM6IFtcbiAgICAnbWUnLFxuICAgICdtZXNzYWdlUG9ydFNlcnZpY2UnXG4gIF0sXG5cbiAgcHJvcGVydGllczogW1xuICAgIHtcbiAgICAgIG5hbWU6ICd0YXJnZXQnXG4gICAgfSxcbiAgICB7XG4gICAgICBuYW1lOiAnZGVsZWdhdGUnLFxuICAgICAgZmFjdG9yeTogZnVuY3Rpb24oKSB7XG5cdHZhciBjaGFubmVsID0gbmV3IE1lc3NhZ2VDaGFubmVsKCk7XG5cdHRoaXMubWVzc2FnZVBvcnRTZXJ2aWNlLmFkZFBvcnQoY2hhbm5lbC5wb3J0MSk7XG5cblx0dGhpcy50YXJnZXQucG9zdE1lc3NhZ2UoY2hhbm5lbC5wb3J0MiwgWyBjaGFubmVsLnBvcnQyIF0pO1xuXG4gICAgICAgIGNoYW5uZWwucG9ydDEucG9zdE1lc3NhZ2UodGhpcy5vdXRwdXR0ZXIuc3RyaW5naWZ5KFxuICAgICAgICAgICAgdGhpcy5NZXNzYWdlLmNyZWF0ZSh7XG4gICAgICAgICAgICAgIG9iamVjdDogdGhpcy5SZWdpc3RlclNlbGZNZXNzYWdlLmNyZWF0ZSh7IG5hbWU6IHRoaXMubWUubmFtZSB9KVxuICAgICAgICAgICAgfSkpKTtcblxuXHRyZXR1cm4gdGhpcy5SYXdNZXNzYWdlUG9ydEJveC5jcmVhdGUoeyBwb3J0OiBjaGFubmVsLnBvcnQxIH0pO1xuICAgICAgfVxuICAgIH0sXG4gICAge1xuICAgICAgY2xhc3M6ICdGT2JqZWN0UHJvcGVydHknLFxuICAgICAgb2Y6ICdmb2FtLmpzb24uT3V0cHV0dGVyJyxcbiAgICAgIG5hbWU6ICdvdXRwdXR0ZXInLFxuICAgICAgZmFjdG9yeTogZnVuY3Rpb24oKSB7XG4gICAgICAgIC8vIE5PVEU6IENvbmZpZ3VyYXRpb24gbXVzdCBiZSBjb25zaXN0ZW50IHdpdGggcGFyc2VyIGluXG4gICAgICAgIC8vIGZvYW0ubWVzc2FnZXBvcnQuTWVzc2FnZVBvcnRTZXJ2aWNlLlxuICAgICAgICAvL1xuICAgICAgICAvLyBVc2UgZGVmYXVsdCBGT0FNIGltcGxlbWVudGF0aW9uIG9mIE91dHB1dHRlci4gRG8gbm90IGF0dGVtcHQgdG9cbiAgICAgICAgLy8gbG9va3VwIHNlbnNpdGl2ZSBcImZvYW0uanNvbi5PdXRwdXR0ZXJcIiBjbGFzcyBpbiBib3ggY29udGV4dC5cbiAgICAgICAgcmV0dXJuIHRoaXMuT3V0cHV0dGVyLmNyZWF0ZSgpLmNvcHlGcm9tKGZvYW0uanNvbi5OZXR3b3JrKVxuICAgICAgfVxuICAgIH1cbiAgXVxufSk7XG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBUaGUgRk9BTSBBdXRob3JzLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5mb2FtLkNMQVNTKHtcbiAgcGFja2FnZTogJ2ZvYW0uYm94JyxcbiAgbmFtZTogJ0ZvcndhcmRlZE1lc3NhZ2UnLFxuXG4gIHByb3BlcnRpZXM6IFtcbiAgICB7XG4gICAgICBjbGFzczogJ0ZPYmplY3RQcm9wZXJ0eScsXG4gICAgICBvZjogJ2ZvYW0uYm94LkJveCcsXG4gICAgICBuYW1lOiAnZGVzdGluYXRpb24nXG4gICAgfSxcbiAgICB7XG4gICAgICBjbGFzczogJ0ZPYmplY3RQcm9wZXJ0eScsXG4gICAgICBuYW1lOiAncGF5bG9hZCdcbiAgICB9XG4gIF1cbn0pO1xuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgVGhlIEZPQU0gQXV0aG9ycy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuZm9hbS5DTEFTUyh7XG4gIHBhY2thZ2U6ICdmb2FtLmJveCcsXG4gIG5hbWU6ICdGb3J3YXJkQm94JyxcbiAgZXh0ZW5kczogJ2ZvYW0uYm94LlByb3h5Qm94JyxcblxuICByZXF1aXJlczogW1xuICAgICdmb2FtLmJveC5Gb3J3YXJkZWRNZXNzYWdlJ1xuICBdLFxuXG4gIHByb3BlcnRpZXM6IFtcbiAgICB7XG4gICAgICBuYW1lOiAnZGVzdGluYXRpb24nXG4gICAgfVxuICBdLFxuXG4gIG1ldGhvZHM6IFtcbiAgICBmdW5jdGlvbiBzZW5kKG0pIHtcbiAgICAgIG0ub2JqZWN0ID0gdGhpcy5Gb3J3YXJkZWRNZXNzYWdlLmNyZWF0ZSh7XG4gICAgICAgIGRlc3RpbmF0aW9uOiB0aGlzLmRlc3RpbmF0aW9uLFxuICAgICAgICBwYXlsb2FkOiBtLm9iamVjdFxuICAgICAgfSk7XG4gICAgICB0aGlzLlNVUEVSKG0pO1xuICAgIH1cbiAgXVxufSk7XG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBUaGUgRk9BTSBBdXRob3JzLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5mb2FtLkNMQVNTKHtcbiAgcGFja2FnZTogJ2ZvYW0uYm94JyxcbiAgbmFtZTogJ0ZvcndhcmRpbmdCb3gnLFxuICBpbXBsZW1lbnRzOiBbICdmb2FtLmJveC5Cb3gnIF0sXG5cbiAgcmVxdWlyZXM6IFtcbiAgICAnZm9hbS5ib3guRm9yd2FyZGVkTWVzc2FnZSdcbiAgXSxcblxuICBtZXRob2RzOiBbXG4gICAgZnVuY3Rpb24gc2VuZChtKSB7XG4gICAgICBpZiAoICEgdGhpcy5Gb3J3YXJkZWRNZXNzYWdlLmlzSW5zdGFuY2UobS5vYmplY3QpIClcbiAgICAgICAgdGhyb3cgZm9hbS5ib3guSW52YWxpZE1lc3NhZ2VFeGNlcHRpb24uY3JlYXRlKCk7XG5cbiAgICAgIHZhciB3cmFwcGVyID0gbS5vYmplY3Q7XG4gICAgICBtLm9iamVjdCA9IHdyYXBwZXIucGF5bG9hZDtcblxuICAgICAgd3JhcHBlci5kZXN0aW5hdGlvbi5kZXNjcmliZSgpO1xuICAgICAgd3JhcHBlci5kZXN0aW5hdGlvbi5zZW5kKG0pO1xuICAgIH1cbiAgXVxufSk7XG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBUaGUgRk9BTSBBdXRob3JzLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKi9cblxuZm9hbS5DTEFTUyh7XG4gIHBhY2thZ2U6ICdmb2FtLmJveCcsXG4gIG5hbWU6ICdSZW1vdGUnLFxuICBwcm9wZXJ0aWVzOiBbXG4gICAge1xuICAgICAgY2xhc3M6ICdTdHJpbmcnLFxuICAgICAgbmFtZTogJ2NsaWVudENsYXNzJ1xuICAgIH1cbiAgXSxcbiAgbWV0aG9kczogW1xuICAgIGZ1bmN0aW9uIGluc3RhbGxJbkNsYXNzKGNscykge1xuICAgICAgdmFyIGNsaWVudENsYXNzID0gdGhpcy5jbGllbnRDbGFzcyB8fCBjbHMuZ2V0QXhpb21zQnlDbGFzcyhmb2FtLmNvcmUuSW1wbGVtZW50cylbMF0ucGF0aDtcblxuICAgICAgY2xzLmluc3RhbGxBeGlvbShmb2FtLmNvcmUuTWV0aG9kLmNyZWF0ZSh7XG4gICAgICAgIG5hbWU6ICdvdXRwdXRKU09OJyxcbiAgICAgICAgY29kZTogZnVuY3Rpb24ob3V0cHV0dGVyKSB7XG4gICAgICAgICAgdmFyIGNscyA9IHRoaXMuX19jb250ZXh0X18ubG9va3VwKGNsaWVudENsYXNzLCB0cnVlKTtcblxuICAgICAgICAgIGlmICggISBjbHMgKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvdWxkIG5vdCBmaW5kICcgKyBjbGllbnRDbGFzcyArICcgdG8gc2VyaWFsaXplICcgKyB0aGlzLmNsc18uaWQpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICggISBmb2FtLmNvcmUuU3R1Yi5pc0luc3RhbmNlKGNscy5nZXRBeGlvbUJ5TmFtZSgnZGVsZWdhdGUnKSkgKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIHN0dWIgcHJvcGVydHkgdG8gYmUgbmFtZWQgXCJkZWxlZ2F0ZVwiIGZvciAnICsgY2xzLmlkKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgWCA9IHRoaXMuX19zdWJDb250ZXh0X187XG4gICAgICAgICAgdmFyIHJlZ2lzdHJ5ID0gWC5yZWdpc3RyeTtcblxuICAgICAgICAgIHZhciBib3ggPSBmb2FtLmJveC5Ta2VsZXRvbkJveC5jcmVhdGUoeyBkYXRhOiB0aGlzIH0sIFgpO1xuICAgICAgICAgIGJveCA9IHJlZ2lzdHJ5LnJlZ2lzdGVyKG51bGwsIG51bGwsIGJveCk7XG5cbiAgICAgICAgICB2YXIgb2JqID0gY2xzLmNyZWF0ZShudWxsLCBYKTtcbiAgICAgICAgICBvYmouZGVsZWdhdGUgPSBib3g7XG5cbiAgICAgICAgICBvdXRwdXR0ZXIub3V0cHV0KG9iaik7XG4gICAgICAgIH1cbiAgICAgIH0pKTtcbiAgICB9XG4gIF1cbn0pO1xuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgVGhlIEZPQU0gQXV0aG9ycy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICovXG5cbmZvYW0uQ0xBU1Moe1xuICBwYWNrYWdlOiAnZm9hbS5ib3gnLFxuICBuYW1lOiAnU2Vzc2lvblJlcGx5Qm94JyxcbiAgZXh0ZW5kczogJ2ZvYW0uYm94LlByb3h5Qm94JyxcblxuICByZXF1aXJlczogW1xuICAgICdmb2FtLmJveC5SUENFcnJvck1lc3NhZ2UnXG4gIF0sXG5cbiAgaW1wb3J0czogW1xuICAgICdyZXF1ZXN0TG9naW4nXG4gIF0sXG5cbiAgcHJvcGVydGllczogW1xuICAgICdtc2cnLFxuICAgICdjbGllbnRCb3gnXG4gIF0sXG5cbiAgbWV0aG9kczogW1xuICAgIHtcbiAgICAgIG5hbWU6ICdzZW5kJyxcbiAgICAgIGNvZGU6IGZ1bmN0aW9uIHNlbmQobXNnKSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgICAgICAvLyBUT0RPOiBpZiBJIGdldCBhbiBBdXRoRXhjZXB0aW9uIHRoZSBjYWxsIHRoZSByZXF1ZXN0TG9naW5cbiAgICAgICAgLy8gaGFuZGxlciB0aGVuIHJldHJ5IG9uY2UgaXQgZmluaXNoZXMuXG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCcqKioqKioqKioqKioqKioqKioqKioqKioqIFJFUExZOiAnLCBmb2FtLmpzb24uc3RyaW5naWZ5KG1zZykpO1xuICAgICAgICAvLyBFeGNlcHRpb24gbG9va3MgbGlrZSB0aGlzOlxuICAgICAgICAvLyB7Y2xhc3M6XCJmb2FtLmJveC5NZXNzYWdlXCIsYXR0cmlidXRlczp7fSxvYmplY3Q6e2NsYXNzOlwiZm9hbS5ib3guUlBDRXJyb3JNZXNzYWdlXCIsZGF0YTp7Y2xhc3M6XCJmb2FtLmJveC5SZW1vdGVFeGNlcHRpb25cIixpZDpcImphdmEuc2VjdXJpdHkuQWNjZXNzQ29udHJvbEV4Y2VwdGlvblwiLG1lc3NhZ2U6XCJub3QgbG9nZ2VkIGluXCJ9fX1cbiAgICAgICAgaWYgKCB0aGlzLlJQQ0Vycm9yTWVzc2FnZS5pc0luc3RhbmNlKG1zZy5vYmplY3QpICYmIG1zZy5vYmplY3QuZGF0YS5pZCA9PT0gJ2phdmEuc2VjdXJpdHkuQWNjZXNzQ29udHJvbEV4Y2VwdGlvbicgKSB7XG4gICAgICAgICAgdGhpcy5yZXF1ZXN0TG9naW4oKS50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgc2VsZi5jbGllbnRCb3guc2VuZChzZWxmLm1zZyk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5kZWxlZ2F0ZS5zZW5kKG1zZyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIF1cbn0pO1xuXG5cbmZvYW0uQ0xBU1Moe1xuICBwYWNrYWdlOiAnZm9hbS5ib3gnLFxuICBuYW1lOiAnU2Vzc2lvbkNsaWVudEJveCcsXG4gIGV4dGVuZHM6ICdmb2FtLmJveC5Qcm94eUJveCcsXG5cbiAgcmVxdWlyZXM6IFsgJ2ZvYW0uYm94LlNlc3Npb25SZXBseUJveCcgXSxcblxuICBjb25zdGFudHM6IFtcbiAgICB7XG4gICAgICBuYW1lOiAnU0VTU0lPTl9LRVknLFxuICAgICAgdmFsdWU6ICdzZXNzaW9uSWQnLFxuICAgICAgdHlwZTogJ1N0cmluZycsXG4gICAgICBzd2lmdFZhbHVlOiAnXCJzZXNzaW9uSWRcIicsXG4gICAgICBzd2lmdFR5cGU6ICdTdHJpbmcnLFxuICAgIH1cbiAgXSxcblxuICBwcm9wZXJ0aWVzOiBbXG4gICAge1xuICAgICAgY2xhc3M6ICdTdHJpbmcnLFxuICAgICAgbmFtZTogJ3Nlc3Npb25OYW1lJyxcbiAgICAgIHZhbHVlOiAnZGVmYXVsdFNlc3Npb24nXG4gICAgfSxcbiAgICB7XG4gICAgICBjbGFzczogJ1N0cmluZycsXG4gICAgICBuYW1lOiAnc2Vzc2lvbklEJyxcbiAgICAgIGZhY3Rvcnk6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gbG9jYWxTdG9yYWdlW3RoaXMuc2Vzc2lvbk5hbWVdIHx8XG4gICAgICAgICAgICAoIGxvY2FsU3RvcmFnZVt0aGlzLnNlc3Npb25OYW1lXSA9IGZvYW0udXVpZC5yYW5kb21HVUlEKCkgKTtcbiAgICAgIH0sXG4gICAgICBzd2lmdEV4cHJlc3Npb25BcmdzOiBbICdzZXNzaW9uTmFtZScgXSxcbiAgICAgIHN3aWZ0RXhwcmVzc2lvbjogYFxubGV0IGRlZmF1bHRzID0gVXNlckRlZmF1bHRzLnN0YW5kYXJkIC8vIFRPRE8gYWxsb3cgdXMgdG8gY29uZmlndXJlP1xuaWYgbGV0IGlkID0gZGVmYXVsdHMuc3RyaW5nKGZvcktleTogc2Vzc2lvbk5hbWUpIHtcbiAgcmV0dXJuIGlkXG59XG5sZXQgaWQgPSBVVUlEKCkudXVpZFN0cmluZ1xuZGVmYXVsdHMuc2V0KGlkLCBmb3JLZXk6IHNlc3Npb25OYW1lKVxucmV0dXJuIGlkXG4gICAgICBgLFxuICAgICAgamF2YUZhY3Rvcnk6XG5gU3RyaW5nIHV1aWQgPSAoU3RyaW5nKSBnZXRYKCkuZ2V0KGdldFNlc3Npb25OYW1lKCkpO1xuaWYgKCBcIlwiLmVxdWFscyh1dWlkKSApIHtcbiAgdXVpZCA9IGphdmEudXRpbC5VVUlELnJhbmRvbVVVSUQoKS50b1N0cmluZygpO1xuICBnZXRYKCkucHV0KGdldFNlc3Npb25OYW1lKCksIHV1aWQpO1xufVxucmV0dXJuIHV1aWQ7YFxuICAgIH1cbiAgXSxcblxuICBtZXRob2RzOiBbXG4gICAge1xuICAgICAgbmFtZTogJ3NlbmQnLFxuICAgICAgY29kZTogZnVuY3Rpb24gc2VuZChtc2cpIHtcbiAgICAgICAgbXNnLmF0dHJpYnV0ZXNbdGhpcy5TRVNTSU9OX0tFWV0gPSB0aGlzLnNlc3Npb25JRDtcblxuICAgICAgICAvLyBjb25zb2xlLmxvZygnKioqKiogU0VORCBTRVNTSU9OIElEOiAnLCB0aGlzLnNlc3Npb25JRC8qZm9hbS5qc29uLnN0cmluZ2lmeShtc2cpKi8pO1xuXG4gICAgICAgIG1zZy5hdHRyaWJ1dGVzLnJlcGx5Qm94ID0gdGhpcy5TZXNzaW9uUmVwbHlCb3guY3JlYXRlKHtcbiAgICAgICAgICBtc2c6ICAgICAgIG1zZyxcbiAgICAgICAgICBjbGllbnRCb3g6IHRoaXMsXG4gICAgICAgICAgZGVsZWdhdGU6ICBtc2cuYXR0cmlidXRlcy5yZXBseUJveFxuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLmRlbGVnYXRlLnNlbmQobXNnKTtcbiAgICAgIH0sXG4gICAgICBzd2lmdENvZGU6IGBcbm1zZy5hdHRyaWJ1dGVzW1Nlc3Npb25DbGllbnRCb3guU0VTU0lPTl9LRVldID0gc2Vzc2lvbklEXG5tc2cuYXR0cmlidXRlc1tcInJlcGx5Qm94XCJdID0gU2Vzc2lvblJlcGx5Qm94X2NyZWF0ZShbXG4gIFwibXNnXCI6IG1zZyxcbiAgXCJjbGllbnRCb3hcIjogc2VsZixcbiAgXCJkZWxlZ2F0ZVwiOiBtc2cuYXR0cmlidXRlc1tcInJlcGx5Qm94XCJdIGFzPyBCb3gsXG5dKVxudHJ5IGRlbGVnYXRlLnNlbmQobXNnKVxuICAgICAgYCxcbiAgICB9XG4gIF1cbn0pO1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBUaGUgRk9BTSBBdXRob3JzLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5mb2FtLkNMQVNTKHtcbiAgcGFja2FnZTogJ2ZvYW0uYm94JyxcbiAgbmFtZTogJ1J1bm5hYmxlJyxcblxuICBkb2N1bWVudGF0aW9uOiBgQW4gYXN5bmNocm9ub3VzIGNvbXB1dGF0aW9uIHRoYXQgcHJvZHVjZXMgb25lIG9yIG1vcmUgb3V0cHV0cyxcbiAgICAgIGFuZCBzZW5kcyB0aGVtIHRvIGl0cyBvdXRwdXRCb3gsIHJlcG9ydGluZyBhbnkgZXJyb3JzIHRvIGVycm9yQm94LmAsXG5cbiAgcmVxdWlyZXM6IFsgJ2ZvYW0uYm94Lk1lc3NhZ2UnIF0sXG5cbiAgcHJvcGVydGllczogW1xuICAgIHtcbiAgICAgIGNsYXNzOiAnU3RyaW5nJyxcbiAgICAgIG5hbWU6ICdpb1JlbGF0aW9uc2hpcFR5cGUnLFxuICAgICAgZG9jdW1lbnRhdGlvbjogJ1RoZSBuOm0gcmVsYXRpb25zaGlwIHR5cGUgb2YgaW5wdXQtdG8tb3V0cHV0LicsXG4gICAgICB2YWx1ZTogJzE6MSdcbiAgICB9LFxuICAgIHtcbiAgICAgIGNsYXNzOiAnQ2xhc3MnLFxuICAgICAgZG9jdW1lbnRhdGlvbjogJ1R5cGUgb2YgaW5wdXQgcGFyYW1ldGVyIG9mIHJ1bigpLicsXG4gICAgICBuYW1lOiAnaW5wdXRUeXBlJyxcbiAgICAgIGZhY3Rvcnk6IGZ1bmN0aW9uKCkgeyByZXR1cm4gZm9hbS5jb3JlLkZPYmplY3Q7IH1cbiAgICB9LFxuICAgIHtcbiAgICAgIGNsYXNzOiAnQ2xhc3MnLFxuICAgICAgZG9jdW1lbnRhdGlvbjogJ1R5cGUgb2YgaW5wdXQgdmF1bGVzIHByb2R1Y2VkIGJ5IHJ1bigpLicsXG4gICAgICBuYW1lOiAnb3V0cHV0VHlwZScsXG4gICAgICBmYWN0b3J5OiBmdW5jdGlvbigpIHsgcmV0dXJuIGZvYW0uY29yZS5GT2JqZWN0OyB9XG4gICAgfSxcbiAgICB7XG4gICAgICBjbGFzczogJ0ZPYmplY3RQcm9wZXJ0eScsXG4gICAgICBvZjogJ2ZvYW0uYm94LkJveCcsXG4gICAgICBkb2N1bWVudGF0aW9uOiAnQm94IHRvIHNlbmQgdG8gZm9yIGNvbXB1dGF0aW9uIG91dHB1dChzKS4nLFxuICAgICAgbmFtZTogJ291dHB1dEJveCdcbiAgICB9LFxuICAgIHtcbiAgICAgIGNsYXNzOiAnRk9iamVjdFByb3BlcnR5JyxcbiAgICAgIG9mOiAnZm9hbS5ib3guQm94JyxcbiAgICAgIGRvY3VtZW50YXRpb246ICdCb3ggdG8gc2VuZCB0byBmb3IgaW50ZXJuYWwgZXJyb3JzKHMpLicsXG4gICAgICBuYW1lOiAnZXJyb3JCb3gnXG4gICAgfVxuICBdLFxuXG4gIG1ldGhvZHM6IFtcbiAgICB7XG4gICAgICBuYW1lOiAncnVuJyxcbiAgICAgIGRvY3VtZW50YXRpb246ICdNb2RlbGVkIGNvbXB1dGF0aW9uIGZvciBvdXRwdXRpbmcgdG8gYSBib3guJyxcbiAgICAgIGNvZGU6IGZ1bmN0aW9uKCkge31cbiAgICB9LFxuICAgIHtcbiAgICAgIG5hbWU6ICdvdXRwdXQnLFxuICAgICAgYXJnczogW1xuICAgICAgICB7XG4gICAgICAgICAgdHlwZU5hbWU6ICd0aGlzLm91dHB1dFR5cGUnLFxuICAgICAgICAgIGRvY3VtZW50YXRpb246ICdIZWxwZXIgZnVuY3Rpb24gZm9yIG91dHB1dGluZyBhIHZhbHVlLicsXG4gICAgICAgIH1cbiAgICAgIF0sXG4gICAgICBjb2RlOiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICB0aGlzLm91dHB1dEJveC5zZW5kKHRoaXMuTWVzc2FnZS5jcmVhdGUoe1xuICAgICAgICAgIG9iamVjdDogdmFsdWVcbiAgICAgICAgfSkpO1xuICAgICAgfVxuICAgIH0sXG4gICAge1xuICAgICAgbmFtZTogJ2Vycm9yJyxcbiAgICAgIGFyZ3M6IFtcbiAgICAgICAge1xuICAgICAgICAgIHR5cGVOYW1lOiAnRXJyb3InLFxuICAgICAgICAgIGRvY3VtZW50YXRpb246ICdIZWxwZXIgZnVuY3Rpb24gZm9yIHJlcG9ydGluZyBhbiBlcnJvci4nLFxuICAgICAgICB9XG4gICAgICBdLFxuICAgICAgY29kZTogZnVuY3Rpb24oZXJyb3IpIHtcbiAgICAgICAgdGhpcy5lcnJvckJveC5zZW5kKHRoaXMuTWVzc2FnZS5jcmVhdGUoe1xuICAgICAgICAgIG9iamVjdDogZXJyb3JcbiAgICAgICAgfSkpO1xuICAgICAgfVxuICAgIH1cbiAgXVxufSk7XG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBUaGUgRk9BTSBBdXRob3JzLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5mb2FtLkNMQVNTKHtcbiAgcGFja2FnZTogJ2ZvYW0uYm94JyxcbiAgbmFtZTogJ0xvZ0JveCcsXG4gIGV4dGVuZHM6ICdmb2FtLmJveC5Qcm94eUJveCcsXG5cbiAgZG9jdW1lbnRhdGlvbjogJ0xvZyBpbnB1dCBtZXNzYWdlcyBiZWZvcmUgcGFzc2luZyB0byBvcHRpb25hbCBkZWxlZ2F0ZS4nLFxuXG4gIHJlcXVpcmVzOiBbICdmb2FtLmxvZy5Mb2dMZXZlbCcgXSxcblxuICBpbXBvcnRzOiBbXG4gICAgJ2RlYnVnJyxcbiAgICAnbG9nJyxcbiAgICAnaW5mbycsXG4gICAgJ3dhcm4nLFxuICAgICdlcnJvcidcbiAgXSxcblxuICBzd2lmdEltcG9ydHM6IFsnb3MnXSxcblxuICBwcm9wZXJ0aWVzOiBbXG4gICAge1xuICAgICAgY2xhc3M6ICdTdHJpbmcnLFxuICAgICAgbmFtZTogJ25hbWUnLFxuICAgICAgZmFjdG9yeTogZnVuY3Rpb24oKSB7IHJldHVybiBgTG9nQm94JHt0aGlzLiRVSUR9YDsgfSxcbiAgICAgIHN3aWZ0RmFjdG9yeTogJ3JldHVybiBcIkxvZ0JveCRcIitVVUlEKCkudXVpZFN0cmluZycsXG4gICAgfSxcbiAgICB7XG4gICAgICBjbGFzczogJ0ZPYmplY3RQcm9wZXJ0eScsXG4gICAgICBvZjogJ2ZvYW0ubG9nLkxvZ0xldmVsJyxcbiAgICAgIG5hbWU6ICdsb2dMZXZlbCcsXG4gICAgICBmYWN0b3J5OiBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMuTG9nTGV2ZWwuSU5GTzsgfSxcbiAgICAgIHN3aWZ0RmFjdG9yeTogJ3JldHVybiBMb2dMZXZlbC5JTkZPJyxcbiAgICB9XG4gIF0sXG5cbiAgbWV0aG9kczogW1xuICAgIHtcbiAgICAgIG5hbWU6ICdzZW5kJyxcbiAgICAgIGNvZGU6IGZ1bmN0aW9uKG1lc3NhZ2UpIHtcbiAgICAgICAgdmFyIG91dHB1dCA9IG1lc3NhZ2Uub2JqZWN0O1xuICAgICAgICB0aGlzW3RoaXMubG9nTGV2ZWwuY29uc29sZU1ldGhvZE5hbWVdLmFwcGx5KHRoaXMsIFtcbiAgICAgICAgICB0aGlzLm5hbWUsXG4gICAgICAgICAgb3V0cHV0IGluc3RhbmNlb2YgRXJyb3IgPyBvdXRwdXQudG9TdHJpbmcoKSA6XG4gICAgICAgICAgICBmb2FtLmpzb24uUHJldHR5LnN0cmluZ2lmeShtZXNzYWdlKVxuICAgICAgICBdKTtcbiAgICAgICAgdGhpcy5kZWxlZ2F0ZSAmJiB0aGlzLmRlbGVnYXRlLnNlbmQobWVzc2FnZSk7XG4gICAgICB9LFxuICAgICAgc3dpZnRDb2RlOiBgXG5sZXQgb3V0cHV0ID0gbXNnLm9iamVjdDtcbmxldCBsb2dNc2cgPSBbXG4gIG5hbWUsXG4gIG91dHB1dCBpcyBFcnJvciA/IChvdXRwdXQgYXMhIEVycm9yKS5sb2NhbGl6ZWREZXNjcmlwdGlvbiA6IG1zZy50b1N0cmluZygpXG5dLmpvaW5lZChzZXBhcmF0b3I6IFwiIFwiKVxuaWYgbGV0IGxvZ0xldmVsU3RyID0gbG9nTGV2ZWw/LmNvbnNvbGVNZXRob2ROYW1lLFxuICAgbGV0IGxvZ01ldGhvZCA9IGdldChrZXk6IGxvZ0xldmVsU3RyKSBhcz8gKFN0cmluZykgLT4gVm9pZCB7XG4gIGxvZ01ldGhvZChsb2dNc2cpXG59IGVsc2Uge1xuICBvc19sb2coXCIlQFwiLCBsb2dNc2cpXG59XG50cnkgZGVsZWdhdGUuc2VuZChtc2cpXG4gICAgICBgLFxuICAgIH0sXG4gIF1cbn0pO1xuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgVGhlIEZPQU0gQXV0aG9ycy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuZm9hbS5DTEFTUyh7XG4gIHBhY2thZ2U6ICdmb2FtLmJveCcsXG4gIG5hbWU6ICdNdWx0aURlbGVnYXRlQm94JyxcbiAgaW1wbGVtZW50czogWyAnZm9hbS5ib3guQm94JyBdLFxuXG4gIGRvY3VtZW50YXRpb246IGBCYXNlIGNsYXNzIGZvciBib3hlcyB0aGF0IG1hbmFnZSBkaXNwYXRjaCB0byBtdWx0aXBsZVxuICAgICAgZGVsZWdhdGVzLmAsXG5cbiAgcHJvcGVydGllczogW1xuICAgIHtcbiAgICAgIGNsYXNzOiAnRk9iamVjdEFycmF5JyxcbiAgICAgIG9mOiAnZm9hbS5ib3guQm94JyxcbiAgICAgIG5hbWU6ICdkZWxlZ2F0ZXMnXG4gICAgfVxuICBdLFxuXG4gIG1ldGhvZHM6IFtcbiAgICBmdW5jdGlvbiBzZW5kKG1lc3NhZ2UpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQ2FsbCB0byBhYnN0cmFjdCBNdWx0aURlbGVnYXRlQm94LnNlbmQobWVzc2FnZSknKTtcbiAgICB9XG4gIF1cbn0pO1xuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgVGhlIEZPQU0gQXV0aG9ycy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuZm9hbS5DTEFTUyh7XG4gIHBhY2thZ2U6ICdmb2FtLmJveCcsXG4gIG5hbWU6ICdCcm9hZGNhc3RCb3gnLFxuICBleHRlbmRzOiAnZm9hbS5ib3guTXVsdGlEZWxlZ2F0ZUJveCcsXG5cbiAgZG9jdW1lbnRhdGlvbjogYEJyb2FkY2FzdCBhbGwgbWVzc2FnZXMgdG8gbXVsdGlwbGUgZGVsZWdhdGUgYm94ZXMuYCxcblxuICBtZXRob2RzOiBbXG4gICAgZnVuY3Rpb24gc2VuZChtZXNzYWdlKSB7XG4gICAgICB2YXIgZHMgPSB0aGlzLmRlbGVnYXRlcztcbiAgICAgIGZvciAoIHZhciBpID0gMDsgaSA8IGRzLmxlbmd0aDsgaSsrICkge1xuICAgICAgICBkc1tpXS5zZW5kKG1lc3NhZ2UpO1xuICAgICAgfVxuICAgIH1cbiAgXVxufSk7XG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBUaGUgRk9BTSBBdXRob3JzLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5mb2FtLkNMQVNTKHtcbiAgcGFja2FnZTogJ2ZvYW0uYm94JyxcbiAgbmFtZTogJ1JvdW5kUm9iaW5Cb3gnLFxuICBleHRlbmRzOiAnZm9hbS5ib3guTXVsdGlEZWxlZ2F0ZUJveCcsXG5cbiAgZG9jdW1lbnRhdGlvbjogYERlbGVnYXRlcyBtZXNzYWdlcyB0byBib3ggd29ya2VycyB1c2luZyByb3VuZCByb2JpblxuICAgICAgc3RyYXRlZ3kuYCxcblxuICBwcm9wZXJ0aWVzOiBbXG4gICAge1xuICAgICAgbmFtZTogJ2N1cnJlbnRCb3hJZF8nLFxuICAgICAgdmFsdWU6IDAsXG4gICAgICBwcmVTZXQ6IGZ1bmN0aW9uKF8sIHZhbCkge1xuICAgICAgICByZXR1cm4gdmFsICUgdGhpcy5kZWxlZ2F0ZXMubGVuZ3RoO1xuICAgICAgfVxuICAgIH1cbiAgXSxcblxuICBtZXRob2RzOiBbXG4gICAgZnVuY3Rpb24gc2VuZChtZXNzYWdlKSB7XG4gICAgICB0aGlzLmRlbGVnYXRlc1t0aGlzLmN1cnJlbnRCb3hJZF8rK10uc2VuZChtZXNzYWdlKTtcbiAgICB9XG4gIF1cbn0pO1xuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgVGhlIEZPQU0gQXV0aG9ycy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuZm9hbS5DTEFTUyh7XG4gIHBhY2thZ2U6ICdmb2FtLmJveC5waXBlbGluZScsXG4gIG5hbWU6ICdSdW5uYWJsZVJQQ0JveCcsXG4gIGV4dGVuZHM6ICdmb2FtLmJveC5Qcm94eUJveCcsXG5cbiAgZG9jdW1lbnRhdGlvbjogJ0EgYm94IHRoYXQgd3JhcHMgaW5wdXQgbWVzc2FnZXMgaW4gUnVubmFibGUucnVuKCkgUlBDIGNhbGxzLicsXG5cbiAgcmVxdWlyZXM6IFtcbiAgICAnZm9hbS5ib3guTWVzc2FnZScsXG4gICAgJ2ZvYW0uYm94LlJQQ01lc3NhZ2UnXG4gIF0sXG5cbiAgcHJvcGVydGllczogW1xuICAgIHtcbiAgICAgIGNsYXNzOiAnRk9iamVjdFByb3BlcnR5JyxcbiAgICAgIG9mOiAnZm9hbS5ib3guQm94JyxcbiAgICAgIGRvY3VtZW50YXRpb246IGBFcnJvciBib3ggZm9yIHJvdXRpbmcgZXJyb3JzIHdoZW4gc2VuZGluZyB0b1xuICAgICAgICAgICAgICBydW5uYWJsZS5gLFxuICAgICAgbmFtZTogJ2Vycm9yQm94J1xuICAgIH0sXG4gIF0sXG5cbiAgbWV0aG9kczogW1xuICAgIGZ1bmN0aW9uIHNlbmQoaW5wdXRNZXNzYWdlKSB7XG4gICAgICByZXR1cm4gdGhpcy5kZWxlZ2F0ZSAmJiB0aGlzLmRlbGVnYXRlLnNlbmQodGhpcy5NZXNzYWdlLmNyZWF0ZSh7XG4gICAgICAgIG9iamVjdDogdGhpcy5SUENNZXNzYWdlLmNyZWF0ZSh7XG4gICAgICAgICAgbmFtZTogJ3J1bicsXG4gICAgICAgICAgYXJnczogWyBpbnB1dE1lc3NhZ2Uub2JqZWN0IF1cbiAgICAgICAgfSksXG4gICAgICAgIGF0dHJpYnV0ZXM6IHsgZXJyb3JCb3g6IHRoaXMuZXJyb3JCb3ggfVxuICAgICAgfSkpO1xuICAgIH1cbiAgXVxufSk7XG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBUaGUgRk9BTSBBdXRob3JzLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5mb2FtLkNMQVNTKHtcbiAgcGFja2FnZTogJ2ZvYW0uYm94LnBpcGVsaW5lJyxcbiAgbmFtZTogJ1BpcGVsaW5lTm9kZScsXG5cbiAgZG9jdW1lbnRhdGlvbjogYGZvYW0uYm94LlBpcGVsaW5lTWFuYWdlciBvYmplY3QgdGhhdCBlbmNhcHN1bGF0ZXMgZGF0YSByZWxhdGVkXG4gICAgICB0byBydW5uYWJsZS5gLFxuXG4gIHJlcXVpcmVzOiBbXG4gICAgJ2ZvYW0uYm94LkxvZ0JveCcsXG4gICAgJ2ZvYW0uYm94LlByb21pc2VkQm94JyxcbiAgICAnZm9hbS5ib3guU2tlbGV0b25Cb3gnLFxuICAgICdmb2FtLmxvZy5Mb2dMZXZlbCdcbiAgXSxcbiAgaW1wb3J0czogWyAnZGVmYXVsdEVycm9yQm94PycgXSxcblxuICBwcm9wZXJ0aWVzOiBbXG4gICAge1xuICAgICAgY2xhc3M6ICdGT2JqZWN0UHJvcGVydHknLFxuICAgICAgb2Y6ICdmb2FtLmJveC5SdW5uYWJsZScsXG4gICAgICBuYW1lOiAncnVubmFibGUnXG4gICAgfSxcbiAgICB7XG4gICAgICBjbGFzczogJ0ZPYmplY3RQcm9wZXJ0eScsXG4gICAgICBvZjogJ2ZvYW0uYm94LkJveCcsXG4gICAgICBuYW1lOiAnbG9jYWxJbnB1dCcsXG4gICAgICB0cmFuc2llbnQ6IHRydWUsXG4gICAgICBleHByZXNzaW9uOiBmdW5jdGlvbihydW5uYWJsZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5Ta2VsZXRvbkJveC5jcmVhdGUoe1xuICAgICAgICAgIGRhdGE6IHJ1bm5hYmxlXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0sXG4gICAge1xuICAgICAgY2xhc3M6ICdGT2JqZWN0UHJvcGVydHknLFxuICAgICAgb2Y6ICdmb2FtLmJveC5Qcm9taXNlZEJveCcsXG4gICAgICBuYW1lOiAncmVtb3RlSW5wdXQnLFxuICAgICAgZmFjdG9yeTogZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLlByb21pc2VkQm94LmNyZWF0ZSgpOyB9XG4gICAgfSxcbiAgICB7XG4gICAgICBjbGFzczogJ0ZPYmplY3RQcm9wZXJ0eScsXG4gICAgICBvZjogJ2ZvYW0uYm94LkJveCcsXG4gICAgICBuYW1lOiAnZXJyb3JCb3gnLFxuICAgICAgZG9jdW1lbnRhdGlvbjogJ0Vycm9yIGJveCBmb3IgUlBDLXJlbGF0ZWQgZXJyb3JzIGV4dGVybmFsIHRvIHJ1bm5hYmxlLicsXG4gICAgICBmYWN0b3J5OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGVmYXVsdEVycm9yQm94IHx8IHRoaXMuTG9nQm94LmNyZWF0ZSh7XG4gICAgICAgICAgbG9nTGV2ZWw6IHRoaXMuTG9nTGV2ZWwuRVJST1JcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICBdXG59KTtcbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IFRoZSBGT0FNIEF1dGhvcnMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmZvYW0uQ0xBU1Moe1xuICBwYWNrYWdlOiAnZm9hbS5ib3gucGlwZWxpbmUnLFxuICBuYW1lOiAnUGlwZWxpbmVNYW5hZ2VyJyxcblxuICBkb2N1bWVudGF0aW9uOiBgQSBtYW5hZ2VyIGZvciBjb21wb3NpbmcgcGlwZWxpbmVzIG9mIGZvYW0uYm94LlJ1bm5hYmxlXG4gICAgaW5zdGFuY2VzLiBQaXBlbGluZXMgbWF5IGZvcmsgdmlhIG11bHRpcGxlIHRoZW4oKXMuIE1hbmFnZXIncyBjdXJyZW50XG4gICAgcnVubmFibGVzIG1heSBiZSBib3VuZCB0b2dldGhlciB3aXRoIGJpbmQoKTsgdGhpcyBjYW4gYmUgdXNlZCB0byBtZXJnZVxuICAgIHBpcGVsaW5lcy4gUGlwZWxpbmVzIG1heSBub3QgY29udGFpbiBjeWNsZXMuXG5cbiAgICBOb3RlIHRoYXQgZWFjaCBydW5uYWJsZSBpcyByZWdpc3RlcmVkIGFzIGEgc2VydmljZSBleGFjdGx5IG9uY2UsIGV2ZW4gaWZcbiAgICBhIGJ1aWxkZXIgcmVmZXJyaW5nIHRvIHBpcGVsaW5lIHN0YWdlcyBpcyBidWlsdCBtdWx0aXBsZSB0aW1lcy5cblxuICAgIEUuZy4sXG5cbiAgICB2YXIgYiA9IFBpcGVsaW5lTWFuYWdlci5jcmVhdGUoKTtcbiAgICB2YXIgc2hhcmVkID0gYi50aGVuKHNoYXJlZFJ1bm5hYmxlKTtcblxuICAgIHNoYXJlZC50aGVuKGZvcmtSdW5uYWJsZTEpO1xuICAgIHNoYXJlZC50aGVuKGZvcmtSdW5uYWJsZTIpO1xuXG4gICAgdmFyIG1lcmdlMUJ1aWxkZXIgPSBQaXBlbGluZU1hbmFnZXIuY3JlYXRlKCkudGhlbihtZXJnZVJ1bm5hYmxlMSk7XG4gICAgdmFyIG1lcmdlMkJ1aWxkZXIgPSBQaXBlbGluZU1hbmFnZXIuY3JlYXRlKCkudGhlbihtZXJnZVJ1bm5hYmxlMSk7XG4gICAgbWVyZ2UxQnVpbGRlci5iaW5kKHNoYXJlZCk7XG4gICAgbWVyZ2UyQnVpbGRlci5iaW5kKHNoYXJlZCk7XG5cbiAgICB2YXIgaW5wdXRUb01lcmdlMVJ1bm5hYmxlID0gbWVyZ2UxQnVpbGRlci5idWlsZCgpO1xuICAgIHZhciBpbnB1dFRvTWVyZ2UyUnVubmFibGUgPSBtZXJnZTJCdWlsZGVyLmJ1aWxkKCk7XG4gICAgLy8gWWllbGRzIGlucHV0IGJveGVzIGZvciBtZXJnZVJ1bm5hYmxlMSBhbmQgbWVyZ2VSdW5uYWJsZTJcbiAgICAvLyBvbiBwaXBlbGluZTpcbiAgICAvL1xuICAgIC8vIG1lcmdlUnVubmFibGUxIC0tICAgICAgICAgICAgICAgICAgICAgICAtLSBmb3JrUnVubmFibGUxXG4gICAgLy8gICAgICAgICAgICAgICAgICA+LS0gc2hhcmVkUnVubmFibGUgLS0gPFxuICAgIC8vIG1lcmdlUnVubmFibGUyIC0tICAgICAgICAgICAgICAgICAgICAgICAtLSBmb3JrUnVubmFibGUyYCxcblxuICByZXF1aXJlczogW1xuICAgICdmb2FtLmJveC5Cb3gnLFxuICAgICdmb2FtLmJveC5Ccm9hZGNhc3RCb3gnLFxuICAgICdmb2FtLmJveC5Mb2dCb3gnLFxuICAgICdmb2FtLmJveC5NZXNzYWdlJyxcbiAgICAnZm9hbS5ib3guUlBDTWVzc2FnZScsXG4gICAgJ2ZvYW0uYm94LlJQQ1JldHVybkJveCcsXG4gICAgJ2ZvYW0uYm94LnBpcGVsaW5lLlBpcGVsaW5lTm9kZScsXG4gICAgJ2ZvYW0uYm94LnBpcGVsaW5lLlJ1bm5hYmxlUlBDQm94J1xuICBdLFxuXG4gIGltcG9ydHM6IFtcbiAgICAncmVnaXN0cnknLFxuICAgICdkZWZhdWx0T3V0cHV0Qm94PyBhcyBjdHhEZWZhdWx0T3V0cHV0Qm94J1xuICBdLFxuXG4gIHByb3BlcnRpZXM6IFtcbiAgICB7XG4gICAgICBjbGFzczogJ0ZPYmplY3RQcm9wZXJ0eScsXG4gICAgICBvZjogJ2ZvYW0uYm94LkJveCcsXG4gICAgICBuYW1lOiAnZGVmYXVsdE91dHB1dEJveCcsXG4gICAgICBkb2N1bWVudGF0aW9uOiBgT3V0cHV0IGJveCB1c2VkIGZvciBlbmQtb2YtY29tcHV0YXRpb24gKHdoZW4gbm9cbiAgICAgICAgICBuZXh0LXRvLXJ1biBkZWxlZ2F0ZXMgYm91bmQgdG8gdGhpcyBzdGVwIGluIHRoZSBwaXBlbGluZSkuYCxcbiAgICAgIGZhY3Rvcnk6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jdHhEZWZhdWx0T3V0cHV0Qm94IHx8IHRoaXMuTG9nQm94LmNyZWF0ZSgpO1xuICAgICAgfVxuICAgIH0sXG4gICAge1xuICAgICAgY2xhc3M6ICdGT2JqZWN0UHJvcGVydHknLFxuICAgICAgb2Y6ICdmb2FtLmJveC5waXBlbGluZS5QaXBlbGluZU5vZGUnLFxuICAgICAgbmFtZTogJ3BpcGVsaW5lJyxcbiAgICAgIGRvY3VtZW50YXRpb246ICdQaXBlbGluZU5vZGUgc3RlcCBmb3IgZW5jYXBzdWxhdGluZyBydW5uYWJsZS4nLFxuICAgICAgZmFjdG9yeTogZnVuY3Rpb24oKSB7IHRoaXMuUGlwZWxpbmVOb2RlLmNyZWF0ZSgpOyB9XG4gICAgfSxcbiAgICB7XG4gICAgICBjbGFzczogJ0ZPYmplY3RBcnJheScsXG4gICAgICBvZjogJ2ZvYW0uYm94LnBpcGVsaW5lLlBpcGVsaW5lTWFuYWdlcicsXG4gICAgICBuYW1lOiAnZGVsZWdhdGVzJyxcbiAgICAgIGRvY3VtZW50YXRpb246IGBJbW1lZGlhdGUgbmV4dCBzdGVwKHMpIGluIHRoZSBwaXBlbGluZSBhZnRlciB0aGlzIHJ1bm5hYmxlXG4gICAgICAgICAgc3RlcC5gLFxuICAgICAgcG9zdFNldDogZnVuY3Rpb24ob2xkLCBudSkge1xuICAgICAgICB2YXIgcGwgPSB0aGlzLnBpcGVsaW5lO1xuXG4gICAgICAgIGlmICggbnUubGVuZ3RoID09PSAwICkge1xuICAgICAgICAgIC8vIEVuZCBvZiB0aGUgbGluZS4gRG8gbm90IHdyYXAgUlBDTWVzc2FnZSBhcm91bmQgb3V0cHV0IGJveC5cbiAgICAgICAgICBwbC5ydW5uYWJsZS5vdXRwdXRCb3ggPSB0aGlzLmRlZmF1bHRPdXRwdXRCb3g7XG4gICAgICAgIH0gZWxzZSBpZiAoIHRoaXMuZGVsZWdhdGVzLmxlbmd0aCA9PT0gMSApIHtcbiAgICAgICAgICAvLyBKdXN0IG9uZSBkZWxlZ2F0ZS4gV3JhcCBSUENNZXNzYWdlIGFyb3VuZCBvdXRwdXQgdmFsdWUuXG4gICAgICAgICAgcGwucnVubmFibGUub3V0cHV0Qm94ID0gdGhpcy5SdW5uYWJsZVJQQ0JveC5jcmVhdGUoe1xuICAgICAgICAgICAgZGVsZWdhdGU6IG51WzBdLnBpcGVsaW5lLnJlbW90ZUlucHV0LFxuICAgICAgICAgICAgZXJyb3JCb3g6IG51WzBdLnBpcGVsaW5lLmVycm9yQm94XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gTWFueSBkZWxlZ2F0ZXMuIFdyYXAgUlBDTWVzc2FnZSBhcm91bmQgb3V0cHV0IHZhbHVlIGFuZCBwYXNzIGFsb25nXG4gICAgICAgICAgLy8gdG8gYWxsIGRlbGVnYXRlcy5cbiAgICAgICAgICBwbC5ydW5uYWJsZS5vdXRwdXRCb3ggPSB0aGlzLkJyb2FkY2FzdEJveC5jcmVhdGUoe1xuICAgICAgICAgICAgICBkZWxlZ2F0ZXM6IG51Lm1hcChmdW5jdGlvbihwaXBlbGluZUJ1aWxkZXIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5SdW5uYWJsZVJQQ0JveC5jcmVhdGUoe1xuICAgICAgICAgICAgICAgICAgZGVsZWdhdGU6IHBpcGVsaW5lQnVpbGRlci5waXBlbGluZS5yZW1vdGVJbnB1dCxcbiAgICAgICAgICAgICAgICAgIGVycm9yQm94OiBwaXBlbGluZUJ1aWxkZXIucGlwZWxpbmUuZXJyb3JCb3hcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfS5iaW5kKHRoaXMpKVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICB7XG4gICAgICBjbGFzczogJ0ZPYmplY3RBcnJheScsXG4gICAgICBvZjogJ2ZvYW0uYm94LnBpcGVsaW5lLlBpcGVsaW5lTWFuYWdlcicsXG4gICAgICBuYW1lOiAncGFyZW50cycsXG4gICAgICBkb2N1bWVudGF0aW9uOiBgSW1tZWRpYXRlIHByZXZpb3VzIHN0ZXAocykgaW4gdGhlIHBpcGVsaW5lIGJlZm9yZSB0aGlzXG4gICAgICAgICAgcnVubmFibGUgc3RlcC5gLFxuICAgIH0sXG4gICAge1xuICAgICAgY2xhc3M6ICdGT2JqZWN0UHJvcGVydHknLFxuICAgICAgb2Y6ICdmb2FtLmJveC5Cb3gnLFxuICAgICAgbmFtZTogJ2J1aWx0SW5wdXRCb3hfJyxcbiAgICAgIGRvY3VtZW50YXRpb246IGBJbnB1dCBib3ggdGhhdCBjYW4gYmUgcmV0dXJuZWQgZnJvbSBidWlsZGluZyB0aGlzXG4gICAgICAgICAgYnVpbGRlci4gQWNjZXB0cyBtZXNzYWdlcyBjb250YWluaW5nIHRoaXMgcnVubmFibGUgc3RlcCdzIGlucHV0VHlwZS5gLFxuICAgICAgdmFsdWU6IG51bGxcbiAgICB9XG4gIF0sXG5cbiAgbWV0aG9kczogW1xuICAgIGZ1bmN0aW9uIGluaXQoKSB7XG4gICAgICB0aGlzLnZhbGlkYXRlKCk7XG4gICAgICBmb2FtLmFzc2VydCh0aGlzLkJveC5pc0luc3RhbmNlKHRoaXMucmVnaXN0cnkpLFxuICAgICAgICAgICAgICAgICAgJ1BpcGVsaW5lTm9kZSByZXF1aXJlcyByZWdpc3RyeSB0aGF0IGltcGxlbWVudHMgQm94Jyk7XG4gICAgICB0aGlzLlNVUEVSKCk7XG4gICAgfSxcbiAgICB7XG4gICAgICBuYW1lOiAndGhlbicsXG4gICAgICByZXR1cm5zOiB7IHR5cGVOYW1lOiAnZm9hbS5ib3gucGlwZWxpbmUuUGlwZWxpbmVNYW5hZ2VyJyB9LFxuICAgICAgYXJnczogWyB7IHR5cGVOYW1lOiAnZm9hbS5ib3guUnVubmFibGUnIH0gXSxcbiAgICAgIGRvY3VtZW50YXRpb246IGBBcHBlbmQgYW4gaW1tZWRpYXRlIG5leHQgc3RlcCB0byBwaXBlbGluZS5gLFxuICAgICAgY29kZTogZnVuY3Rpb24ocnVubmFibGUpIHtcbiAgICAgICAgdmFyIHBsID0gdGhpcy5waXBlbGluZTtcbiAgICAgICAgaWYgKCAhIHBsICkge1xuICAgICAgICAgIHRoaXMucGlwZWxpbmUgPSB0aGlzLlBpcGVsaW5lTm9kZS5jcmVhdGUoeyBydW5uYWJsZTogcnVubmFibGUgfSk7XG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbmV4dCA9IHRoaXMuY2xzXy5jcmVhdGUoe1xuICAgICAgICAgIHBpcGVsaW5lOiB0aGlzLlBpcGVsaW5lTm9kZS5jcmVhdGUoeyBydW5uYWJsZTogcnVubmFibGUgfSksXG4gICAgICAgICAgcGFyZW50czogWyB0aGlzIF1cbiAgICAgICAgfSwgdGhpcy5fX3N1YkNvbnRleHRfXyk7XG4gICAgICAgIHRoaXMuZGVsZWdhdGVzID0gdGhpcy5kZWxlZ2F0ZXMuY29uY2F0KFsgbmV4dCBdKTtcbiAgICAgICAgcmV0dXJuIG5leHQ7XG4gICAgICB9XG4gICAgfSxcbiAgICB7XG4gICAgICBuYW1lOiAnYmluZCcsXG4gICAgICBhcmdzOiBbIHsgdHlwZU5hbWU6ICdmb2FtLmJveC5waXBlbGluZS5QaXBlbGluZU1hbmFnZXInIH0gXSxcbiAgICAgIGRvY3VtZW50YXRpb246IGBCaW5kIHRoaXMgcGlwZWxpbmUgbWFuYWdlcidzIGN1cnJlbnQgcnVubmFibGUgdG9cbiAgICAgICAgICBwYXJhbWV0ZXIncyBjdXJyZW50IHJ1bm5hYmxlLiBOb3QgYSBjb250aW51YXRpb24gKG5vIHJldHVybiB2YWx1ZSkuYCxcbiAgICAgIGNvZGU6IGZ1bmN0aW9uKHBpcGVsaW5lQnVpbGRlcikge1xuICAgICAgICB0aGlzLmRlbGVnYXRlcyA9IHRoaXMuZGVsZWdhdGVzLmNvbmNhdChbIHBpcGVsaW5lQnVpbGRlciBdKTtcbiAgICAgICAgcGlwZWxpbmVCdWlsZGVyLnBhcmVudHMgPSBwaXBlbGluZUJ1aWxkZXIucGFyZW50cy5jb25jYXQoWyB0aGlzIF0pO1xuICAgICAgfVxuICAgIH0sXG4gICAge1xuICAgICAgbmFtZTogJ2J1aWxkJyxcbiAgICAgIGRvY3VtZW50YXRpb246IGBCdWlsZCB0aGUgZW50aXJlIHBpcGVsaW5lLCBhbGxvd2luZyBtdWx0aXBsZSBoZWFkcy5gLFxuICAgICAgcmV0dXJuczoge1xuICAgICAgICB0eXBlTmFtZTogJ0FycmF5W2ZvYW0uYm94LkJveF0nLFxuICAgICAgICBkb2N1bWVudGF0aW9uOiBgSW5wdXQgYm94ZXMgYWNjZXB0aW5nIG1lc3NhZ2VzIGNvbnRhaW5pbmcgdGhlIGlucHV0VHlwZXNcbiAgICAgICAgICAgIG9mIGVhY2ggaGVhZCdzIHJ1bm5hYmxlLiBCb3hlcyBhcmUgaW4gdGhlIG9yZGVyIHRoZXkgZmlyc3QoKWVkIHRvXG4gICAgICAgICAgICB0aGUgbWVyZ2UgcG9pbnRzIGluIHRoZSBwaXBlbGluZS5gXG4gICAgICB9LFxuICAgICAgY29kZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciByZXQgPSB0aGlzLmJ1aWxkXygpO1xuICAgICAgICBpZiAoIHRoaXMucGFyZW50cy5sZW5ndGggPT09IDAgKSByZXR1cm4gcmV0O1xuXG4gICAgICAgIC8vIEZsYXR0ZW4gYXJyYXlzIG9mIGhlYWRzIGJ1aWxkXygpaW5nIGJhY2t3YXJkcyBpbiB0aGUgcGlwZWxpbmUuXG4gICAgICAgIHRoaXMucGFyZW50cy5tYXAoZnVuY3Rpb24ocGFyZW50KSB7IHJldHVybiBwYXJlbnQuYnVpbGQoKTsgfSlcbiAgICAgICAgICAgIC5yZWR1Y2UoZnVuY3Rpb24oYWNjLCB2KSB7IHJldHVybiBhY2MuY29uY2F0KHYpOyB9LCBbXSk7XG5cbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgIH1cbiAgICB9LFxuICAgIGZ1bmN0aW9uIGJ1aWxkXygpIHtcbiAgICAgIGlmICggdGhpcy5idWlsdElucHV0Qm94XyApIHJldHVybiB0aGlzLmJ1aWx0SW5wdXRCb3hfO1xuXG4gICAgICAvLyBCdWlsZCBmb3J3YXJkLCBqdXN0IGluIGNhc2UgYnVpbGQoKSB3YXMgaW5pdGlhdGVkIGluIHRoZSBtaWRkbGUgb2YgYVxuICAgICAgLy8gcGlwZWxpbmUuIE5PVEU6IFRoaXMgaXMgaW5jb21wYXRpYmxlIHdpdGggY2lyY3VsYXIgcGlwZWxpbmVzLlxuICAgICAgdGhpcy5kZWxlZ2F0ZXMubWFwKGZ1bmN0aW9uKGRlbGVnYXRlKSB7IHJldHVybiBkZWxlZ2F0ZS5idWlsZF8oKTsgfSk7XG5cbiAgICAgIGlmICggdGhpcy5idWlsdElucHV0Qm94XyApIHJldHVybiB0aGlzLmJ1aWx0SW5wdXRCb3hfO1xuXG4gICAgICB2YXIgcGwgPSB0aGlzLnBpcGVsaW5lO1xuICAgICAgdmFyIG9uUmVnaXN0ZXJlZEJveCA9IHRoaXMuUlBDUmV0dXJuQm94LmNyZWF0ZSgpO1xuICAgICAgdmFyIG9uUmVnaXN0ZXJlZFByb21pc2UgPSBvblJlZ2lzdGVyZWRCb3gucHJvbWlzZTtcbiAgICAgIHRoaXMucmVnaXN0cnkuc2VuZCh0aGlzLk1lc3NhZ2UuY3JlYXRlKHtcbiAgICAgICAgb2JqZWN0OiB0aGlzLlJQQ01lc3NhZ2UuY3JlYXRlKHtcbiAgICAgICAgICBuYW1lOiAncmVnaXN0ZXInLFxuICAgICAgICAgIGFyZ3M6IFsgbnVsbCwgbnVsbCwgcGwubG9jYWxJbnB1dCBdXG4gICAgICAgIH0pLFxuICAgICAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgICAgcmVwbHlCb3g6IG9uUmVnaXN0ZXJlZEJveCxcbiAgICAgICAgICBlcnJvckJveDogcGwuZXJyb3JCb3hcbiAgICAgICAgfVxuICAgICAgfSkpO1xuICAgICAgcGwucmVtb3RlSW5wdXQuZGVsZWdhdGUgPSBvblJlZ2lzdGVyZWRQcm9taXNlO1xuXG4gICAgICAvLyBBY2NlcHQgaW5wdXQgb2JqZWN0cyBhcyBpbnB1dDsgcmV0dXJuIGJveCB0aGF0IHdpbGwgd3JhcCB0aGVtIGluIFJQQ3NcbiAgICAgIC8vIHRvIHJ1bm5hYmxlLlxuICAgICAgcmV0dXJuIHRoaXMuYnVpbHRJbnB1dEJveF8gPSB0aGlzLlJ1bm5hYmxlUlBDQm94LmNyZWF0ZSh7XG4gICAgICAgIGRlbGVnYXRlOiBwbC5yZW1vdGVJbnB1dCxcbiAgICAgICAgZXJyb3JCb3g6IHBsLmVycm9yQm94XG4gICAgICB9KTtcbiAgICB9XG4gIF1cbn0pO1xuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgVGhlIEZPQU0gQXV0aG9ycy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuZm9hbS5DTEFTUyh7XG4gIHBhY2thZ2U6ICdmb2FtLmJveC5waXBlbGluZScsXG4gIG5hbWU6ICdQaXBlbGluZUJ1aWxkZXInLFxuXG4gIGRvY3VtZW50YXRpb246IGBTaW1wbGlmaWVkIGJ1aWxkZXIgcGF0dGVybiBmb3IgY29uc3RydWN0aW5nIHBpcGVsaWVucy5cblxuICAgIEUuZy4sXG5cbiAgICB2YXIgbWVyZ2UxID0gUGlwZWxpbmVCdWlsZGVyLmNyZWF0ZSgpLmFwcGVuZChtZXJnZVJ1bm5hYmxlMSk7XG4gICAgdmFyIG1lcmdlMiA9IFBpcGVsaW5lQnVpbGRlci5jcmVhdGUoKS5hcHBlbmQobWVyZ2VSdW5uYWJsZTIpO1xuICAgIHZhciBzaGFyZWRBbmRGMSA9IFBpcGVsaW5lQnVpbGRlci5jcmVhdGUoKS5hcHBlbmQoc2hhcmVkUnVubmFibGUpO1xuICAgIHZhciBmMiA9IHNoYXJlZEFuZEYxLmZvcmsoZm9ya1J1bm5hYmxlMik7XG5cbiAgICBzaGFyZWRBbmRGMS5hcHBlbmQoZm9ya1J1bm5hYmxlMSk7XG4gICAgbWVyZ2UxLmFwcGVuZChzaGFyZWRBbmRGMSk7XG4gICAgbWVyZ2UyLmFwcGVuZChzaGFyZWRBbmRGMSk7XG5cbiAgICB2YXIgaW5wdXRCb3hGb3JNZXJnZTEgPSBtZXJnZTEuYnVpbGQoKTtcbiAgICB2YXIgaW5wdXRCb3hGb3JNZXJnZTIgPSBtZXJnZTIuYnVpbGQoKTtcbiAgICAvLyBZaWVsZHMgaW5wdXQgYm94ZXMgZm9yIG1lcmdlUnVubmFibGUxIGFuZCBtZXJnZVJ1bm5hYmxlMlxuICAgIC8vIG9uIHBpcGVsaW5lOlxuICAgIC8vXG4gICAgLy8gbWVyZ2VSdW5uYWJsZTEgLS0gICAgICAgICAgICAgICAgICAgICAgIC0tIGZvcmtSdW5uYWJsZTFcbiAgICAvLyAgICAgICAgICAgICAgICAgID4tLSBzaGFyZWRSdW5uYWJsZSAtLSA8XG4gICAgLy8gbWVyZ2VSdW5uYWJsZTIgLS0gICAgICAgICAgICAgICAgICAgICAgIC0tIGZvcmtSdW5uYWJsZTJgLFxuXG4gIHJlcXVpcmVzOiBbXG4gICAgJ2ZvYW0uYm94LlJ1bm5hYmxlJyxcbiAgICAnZm9hbS5ib3gucGlwZWxpbmUuUGlwZWxpbmVNYW5hZ2VyJ1xuICBdLFxuXG4gIHByb3BlcnRpZXM6IFtcbiAgICB7XG4gICAgICBjbGFzczogJ0ZPYmplY3RQcm9wZXJ0eScsXG4gICAgICBvZjogJ2ZvYW0uYm94LnBpcGVsaW5lLlBpcGVsaW5lTWFuYWdlcicsXG4gICAgICBuYW1lOiAnaGVhZF8nLFxuICAgICAgdmFsdWU6IG51bGxcbiAgICB9LFxuICAgIHtcbiAgICAgIGNsYXNzOiAnRk9iamVjdFByb3BlcnR5JyxcbiAgICAgIG9mOiAnZm9hbS5ib3gucGlwZWxpbmUuUGlwZWxpbmVNYW5hZ2VyJyxcbiAgICAgIG5hbWU6ICd0YWlsXycsXG4gICAgICB2YWx1ZTogbnVsbFxuICAgIH1cbiAgXSxcblxuICBtZXRob2RzOiBbXG4gICAgZnVuY3Rpb24gYXBwZW5kKG8pIHtcbiAgICAgIGlmICggdGhpcy5SdW5uYWJsZS5pc0luc3RhbmNlKG8pIClcbiAgICAgICAgcmV0dXJuIHRoaXMuYXBwZW5kUnVubmFibGVfKG8pO1xuICAgICAgZWxzZSBpZiAoIHRoaXMuY2xzXy5pc0luc3RhbmNlKG8pIClcbiAgICAgICAgcmV0dXJuIHRoaXMuYXBwZW5kUGlwZWxpbmVfKG8pO1xuXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1BpcGVsaW5lOiBEbyBub3Qga25vdyBob3cgdG8gYXBwZW5kICcgKyBvLnRvU3RyaW5nKCkpO1xuICAgIH0sXG4gICAgZnVuY3Rpb24gZm9yayhvKSB7XG4gICAgICB2YXIgcmV0ID0gdGhpcy5jbHNfLmNyZWF0ZShudWxsLCB0aGlzLl9fc3ViQ29udGV4dF9fKS5hcHBlbmQobyk7XG4gICAgICB0aGlzLnRhaWxfLmJpbmQocmV0LmhlYWRfKTtcbiAgICAgIHJldHVybiByZXQ7XG4gICAgfSxcbiAgICBmdW5jdGlvbiBidWlsZCgpIHtcbiAgICAgIHJldHVybiB0aGlzLmhlYWRfLmJ1aWxkKCk7XG4gICAgfSxcbiAgICBmdW5jdGlvbiBhcHBlbmRSdW5uYWJsZV8ocnVubmFibGUpIHtcbiAgICAgIGlmICggISB0aGlzLmhlYWRfICkge1xuICAgICAgICB0aGlzLmhlYWRfID0gdGhpcy50YWlsXyA9IHRoaXMuUGlwZWxpbmVNYW5hZ2VyLmNyZWF0ZSgpLnRoZW4ocnVubmFibGUpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cblxuICAgICAgdGhpcy50YWlsXyA9IHRoaXMudGFpbF8udGhlbihydW5uYWJsZSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIGZ1bmN0aW9uIGFwcGVuZFBpcGVsaW5lXyhwaXBlbGluZSkge1xuICAgICAgdGhpcy50YWlsXy5iaW5kKHBpcGVsaW5lLmhlYWRfKTtcbiAgICAgIC8vIERvbid0IHVzZSBjbG9uZSgpOyBzaGFsbG93IGNvcHkuXG4gICAgICByZXR1cm4gdGhpcy5jbHNfLmNyZWF0ZSh7XG4gICAgICAgIGhlYWRfOiB0aGlzLmhlYWRfIHx8IHBpcGVsaW5lLmhlYWRfLFxuICAgICAgICB0YWlsXzogcGlwZWxpbmUudGFpbF9cbiAgICAgIH0sIHRoaXMuX19zdWJDb250ZXh0X18pO1xuICAgIH1cbiAgXVxufSk7XG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG4vKipcbkFzeW5jIGZ1bmN0aW9ucyBjb21wb3NlIG90aGVyIGFzeW5jaHJvbm91cyBmdW5jdGlvbnMgdGhhdCByZXR1cm4gcHJvbWlzZXMuXG5cbjxwPk9uZSBrZXkgdG8gdXNpbmcgdGhlc2UgZnVuY3Rpb25zIGlzIHRvIG5vdGUgdGhhdCB0aGV5IHJldHVybiBhIGZ1bmN0aW9uXG50aGF0IGRvZXMgdGhlIHJlYWwgd29yaywgc28gY2FsbGluZyBmb2FtLmFzeW5jLnNlcXVlbmNlKG15RnVuY0FycmF5KSxcbmZvciBpbnN0YW5jZSwgZG9lc24ndCBjcmVhdGUgYSBwcm9taXNlIG9yIGNhbGwgYW55IG9mIHRoZSBmdW5jdGlvbnMgcGFzc2VkXG50byBpdC4gSXQgaW5zdGVhZCBzZXRzIHVwIGFuZCByZXR1cm5zIGEgZnVuY3Rpb24gdGhhdCB3aWxsIHJldHVybiBhIHByb21pc2VcbmFuZCBldmFsdWF0ZSBhcmd1bWVudHMgYXMgbmVlZGVkLlxuXG48cD5UbyB1c2UgdGhlIHJldHVybmVkIGZ1bmN0aW9uLCBwYXNzIGl0IHRvIGEgUHJvbWlzZS50aGVuIGNhbGw6XG48cHJlPlByb21pc2UucmVzb2x2ZSgpLnRoZW4oZm9hbS5hc3luYy5zZXF1ZW5jZSggWyBmbjEsIGZuMiBdICkpOzwvcHJlPlxuPHA+T3IgY3JlYXRlIGEgbmV3IHByb21pc2U6XG48cHJlPnZhciBwID0gbmV3IFByb21pc2UoZm9hbS5hc3luYy5zZXF1ZW5jZSggWyBmbjEsIGZuMiBdICkpOzwvcHJlPlxuXG48cD5Bc3luYyBmdW5jdGlvbnMgY2FuIGFsc28gYmUgbmVzdGVkOlxuPHByZT5cbnZhciBzZXEgPSBmb2FtLmFzeW5jLnNlcXVlbmNlKFtcbiAgZm9hbS5hc3luYy5sb2coXCJTdGFydGluZy4uLlwiKSxcbiAgZm9hbS5hc3luYy5yZXBlYXQoMTAsIGZvYW0uYXN5bmMuc2VxdWVuY2UoW1xuICAgIGZ1bmN0aW9uKGkpIHsgY29uc29sZS5sb2coXCJpdGVyYXRpb25cIiwgaSk7IH0pLFxuICAgIGZvYW0uYXN5bmMuc2xlZXAoMTAwMClcbiAgXSlcbl0pO1xuUHJvbWlzZS5yZXNvbHZlKCkudGhlbihzZXEpLnRoZW4oZm9hbS5hc3luYy5sb2coXCJEb25lIVwiKSk7XG48L3ByZT5cbiAqL1xuZm9hbS5MSUIoe1xuICBuYW1lOiAnZm9hbS5hc3luYycsXG5cbiAgbWV0aG9kczogW1xuICAgIGZ1bmN0aW9uIHNlcXVlbmNlKHMpIHtcbiAgICAgIC8qKiBUYWtlcyBhbiBhcnJheSBvZiBmdW5jdGlvbnMgKHRoYXQgbWF5IHJldHVybiBhIHByb21pc2UpIGFuZCBydW5zXG4gICAgICAgIHRoZW0gb25lIGFmdGVyIGFudGhlci4gRnVuY3Rpb25zIHRoYXQgcmV0dXJuIGEgcHJvbWlzZSB3aWxsIGhhdmUgdGhhdFxuICAgICAgICBwcm9taXNlIGNoYWluZWQsIHN1Y2ggdGhhdCB0aGUgbmV4dCBmdW5jdGlvbiB3aWxsIG5vdCBydW4gdW50aWwgdGhlXG4gICAgICAgIHByZXZpb3VzIGZ1bmN0aW9uJ3MgcmV0dXJuZWQgcHJvbWlzZSBpcyByZXNvbHZlZC5cblxuICAgICAgICA8cD5FcnJvcnMgYXJlIG5vdCBoYW5kbGVkLCBzbyBjaGFpbiBhbnkgZGVzaXJlZCBlcnJvciBoYW5kbGVyc1xuICAgICAgICBvbnRvIHRoZSBwcm9taXNlIHJldHVybmVkLlxuXG4gICAgICAgIDxwPllvdSBjYW4gdXNlIHNlcXVlbmNlJ3MgcmV0dXJuZWQgZnVuY3Rpb24gZGlyZWN0bHkgaW4gYSB0aGVuIGNhbGw6XG4gICAgICAgIDxwcmU+cHJvbWlzZS50aGVuKGZvYW0uYXN5bmMuc2VxdWVuY2UoLi4uKSk7PC9wcmU+XG4gICAgICAgIDxwPk9yIGNhbGwgaXQgZGlyZWN0bHk6XG4gICAgICAgIDxwcmU+KGZvYW0uYXN5bmMuc2VxdWVuY2UoLi4uKSkoKS50aGVuKC4uLik7PC9wcmU+XG5cbiAgICAgICAgQHBhcmFtIHtBcnJheX0gcyBBbiBhcnJheSBvZiBmdW5jdGlvbnMgdGhhdCByZXR1cm4gUHJvbWlzZXNcbiAgICAgICAgQHJldHVybnMge0Z1bmN0aW9ufSAgQSBmdW5jdGlvbiB0aGF0IHJldHVybnMgYSBwcm9taXNlIHRoYXQgd2lsbFxuICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlIGFmdGVyIHRoZSBsYXN0IGZ1bmN0aW9uJ3MgcmV0dXJuIGlzIHJlc29sdmVkLlxuICAgICAgKi9cbiAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKCAhIHMubGVuZ3RoICkgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuXG4gICAgICAgIHZhciBwID0gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgICAgIGZvciAoIHZhciBpID0gMDsgaSA8IHMubGVuZ3RoOyArK2kgKSB7XG4gICAgICAgICAgcCA9IHAudGhlbihzW2ldKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcDtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgZnVuY3Rpb24gcmVwZWF0KHRpbWVzLCBmbikge1xuICAgICAgLyoqIFRha2VzIGEgZnVuY3Rpb24gKHRoYXQgbWF5IHJldHVybiBhIHByb21pc2UpIGFuZCBydW5zIGl0IG11bHRpcGxlXG4gICAgICAgIHRpbWVzLiBBIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhIHByb21pc2Ugd2lsbCBoYXZlIHRoYXRcbiAgICAgICAgcHJvbWlzZSBjaGFpbmVkLCBzdWNoIHRoYXQgdGhlIG5leHQgY2FsbCB3aWxsIG5vdCBydW4gdW50aWwgdGhlXG4gICAgICAgIHByZXZpb3VzIGNhbGwncyByZXR1cm5lZCBwcm9taXNlIGlzIHJlc29sdmVkLiBUaGUgZnVuY3Rpb24gcGFzc2VkIGluXG4gICAgICAgIHdpbGwgYmUgY2FsbGVkIHdpdGggb25lIGFyZ3VtZW50LCB0aGUgbnVtYmVyIG9mIHRoZSBpdGVyYXRpb24sIGZyb21cbiAgICAgICAgMCB0byB0aW1lcyAtIDEuXG5cbiAgICAgICAgPHA+RXJyb3JzIGFyZSBub3QgaGFuZGxlZCwgc28gY2hhaW4gYW55IGRlc2lyZWQgZXJyb3IgaGFuZGxlcnNcbiAgICAgICAgb250byB0aGUgcHJvbWlzZSByZXR1cm5lZC5cblxuICAgICAgICA8cD5Zb3UgY2FuIHVzZSByZXBlYXQncyByZXR1cm5lZCBmdW5jdGlvbiBkaXJlY3RseSBpbiBhIHRoZW4gY2FsbDpcbiAgICAgICAgPHByZT5wcm9taXNlLnRoZW4oZm9hbS5hc3luYy5yZXBlYXQoLi4uKSk7PC9wcmU+XG4gICAgICAgIDxwPk9yIGNhbGwgaXQgZGlyZWN0bHk6XG4gICAgICAgIDxwcmU+KGZvYW0uYXN5bmMucmVwZWF0KC4uLikpKCkudGhlbiguLi4pOzwvcHJlPlxuXG4gICAgICAgIEBwYXJhbSB7TnVtYmVyfSB0aW1lcyBudW1iZXIgb2YgdGltZXMgdG8gcmVwZWF0IGluIHNlcXVlbmNlLlxuICAgICAgICBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBGdW5jdGlvbiB0aGF0IHJldHVybnMgYSBQcm9taXNlLlxuICAgICAgICBAcmV0dXJucyB7RnVuY3Rpb259ICBBIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhIFByb21pc2UgdGhhdCB3aWxsIHJlc29sdmVcbiAgICAgICAgICAgICAgICAgICAgICAgYWZ0ZXIgdGhlIGxhc3QgcmVwZXRpdGlvbidzIHJldHVybiByZXNvbHZlcy5cbiAgICAgICovXG4gICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBwID0gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgICAgIHZhciBuID0gMDtcbiAgICAgICAgZm9yICggdmFyIGkgPSAwOyBpIDwgdGltZXM7ICsraSApIHtcbiAgICAgICAgICBwID0gcC50aGVuKGZ1bmN0aW9uKCkgeyByZXR1cm4gZm4obisrKTsgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHA7XG4gICAgICB9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgIFRha2VzIGEgZnVuY3Rpb24gKHRoYXQgbWF5IHJldHVybiBhIHByb21pc2UpIGFuZCBydW5zIGl0IG11bHRpcGxlXG4gICAgICB0aW1lcyBpbiBwYXJhbGxlbC4gQSBmdW5jdGlvbiB0aGF0IHJldHVybnMgYSBwcm9taXNlIHdpbGwgaGF2ZSB0aGF0XG4gICAgICBwcm9taXNlIGNoYWluZWQsIHN1Y2ggdGhhdCB0aGUgZW50aXJlIGdyb3VwIHdpbGwgbm90IHJlc29sdmUgdW50aWxcbiAgICAgIGFsbCByZXR1cm5lZCBwcm9taXNlcyBoYXZlIHJlc29sdmVkIChhcyBpbiB0aGUgc3RhbmRhcmQgUHJvbWlzZS5hbGwpO1xuICAgICAgVGhlIGZ1bmN0aW9uIHBhc3NlZCBpblxuICAgICAgd2lsbCBiZSBjYWxsZWQgd2l0aCBvbmUgYXJndW1lbnQsIHRoZSBudW1iZXIgb2YgdGhlIGl0ZXJhdGlvbiwgZnJvbVxuICAgICAgMCB0byB0aW1lcyAtIDEuXG5cbiAgICAgIDxwPkVycm9ycyBhcmUgbm90IGhhbmRsZWQsIHNvIGNoYWluIGFueSBkZXNpcmVkIGVycm9yIGhhbmRsZXJzXG4gICAgICBvbnRvIHRoZSBwcm9taXNlIHJldHVybmVkLlxuXG4gICAgICA8cD5Zb3UgY2FuIHVzZSByZXBlYXRQYXJhbGxlbCdzIHJldHVybmVkIGZ1bmN0aW9uIGRpcmVjdGx5IGluIGEgdGhlbiBjYWxsOlxuICAgICAgPHByZT5wcm9taXNlLnRoZW4oZm9hbS5hc3luYy5yZXBlYXRQYXJhbGxlbCguLi4pKTs8L3ByZT5cbiAgICAgIDxwPk9yIGNhbGwgaXQgZGlyZWN0bHk6XG4gICAgICA8cHJlPihmb2FtLmFzeW5jLnJlcGVhdFBhcmFsbGVsKC4uLikpKCkudGhlbiguLi4pOzwvcHJlPlxuXG5cbiAgICAgIEBwYXJhbSB7TnVtYmVyfSB0aW1lcyBudW1iZXIgb2YgdGltZXMgdG8gcmVwZWF0IGluIHNlcXVlbmNlLlxuICAgICAgQHBhcmFtIHtGdW5jdGlvbn0gZm4gRnVuY3Rpb24gdGhhdCByZXR1cm5zIGEgUHJvbWlzZS5cbiAgICAgIEByZXR1cm5zIHtGdW5jdGlvbn0gIEEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGEgUHJvbWlzZSB0aGF0IHdpbGwgcmVzb2x2ZVxuICAgICAgICAgICAgICAgICAgIGFmdGVyIGV2ZXJ5IHJlcGV0aXRpb24ncyByZXR1cm4gcmVzb2x2ZXNcbiAgICAqL1xuICAgIGZ1bmN0aW9uIHJlcGVhdFBhcmFsbGVsKHRpbWVzLCBmbikge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgcHJvbWlzZXMgPSBbXTtcbiAgICAgICAgZm9yICggdmFyIGkgPSAwOyBpIDwgdGltZXM7ICsraSApIHtcbiAgICAgICAgICBwcm9taXNlc1tpXSA9IGZuKGkpOyAvLyBUT0RPOiB3aGF0IGlmIG5vdCByZXR1cm5lZCBhIHByb21pc2U/XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFByb21pc2UuYWxsKHByb21pc2VzKTtcbiAgICAgIH07XG4gICAgfSxcblxuICAgIGZ1bmN0aW9uIGxvZygpIHtcbiAgICAgIC8qKiBSZXR1cm5zIGEgZnVuY3Rpb24geW91IGNhbiBwYXNzIHRvIGEgLnRoZW4gY2FsbCwgb3Igb3RoZXIgZm9hbS5hc3luY1xuICAgICAgICBmdW5jdGlvbnMuIFRha2VzIHZhcmlhYmxlIGFyZ3VtZW50cyB0aGF0IGFyZSBwYXNzZWQgdG8gY29uc29sZS5sb2cuICovXG4gICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cztcbiAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgY29uc29sZS5sb2cuYXBwbHkoY29uc29sZSwgYXJncyk7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICAgIH07XG4gICAgfSxcblxuICAgIGZ1bmN0aW9uIHNsZWVwKC8qIE51bWJlciAqLyB0aW1lKSB7XG4gICAgICAvKiogUmV0dXJucyBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhIHByb21pc2UgdGhhdCBkZWxheXMgYnkgdGhlIGdpdmVuXG4gICAgICAgIHRpbWUgYmVmb3JlIHJlc29sdmluZy4gKi9cbiAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7IHJlc29sdmUoKTsgfSwgdGltZSk7XG4gICAgICAgIH0pO1xuICAgICAgfTtcbiAgICB9XG4gIF1cbn0pO1xuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgVGhlIEZPQU0gQXV0aG9ycy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICovXG5cbmZvYW0uQ0xBU1Moe1xuICBwYWNrYWdlOiAnZm9hbS5kYW8nLFxuICBuYW1lOiAnQ2xpZW50U2luaycsXG4gIGltcGxlbWVudHM6IFsgJ2ZvYW0uZGFvLlNpbmsnIF0sXG4gIHByb3BlcnRpZXM6IFtcbiAgICB7XG4gICAgICBjbGFzczogJ1N0dWInLFxuICAgICAgb2Y6ICdmb2FtLmRhby5TaW5rJyxcbiAgICAgIG5hbWU6ICdkZWxlZ2F0ZScsXG4gICAgICBub3RpZmljYXRpb25zOiBbICdwdXQnLCAncmVtb3ZlJywgJ2VvZicsICdlcnJvcicsICdyZXNldCcgXVxuICAgIH1cbiAgXVxufSk7XG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5mb2FtLkNMQVNTKHtcbiAgcGFja2FnZTogJ2ZvYW0udTInLFxuICBuYW1lOiAnVmlld0ZhY3RvcnknLFxuICBleHRlbmRzOiAnZm9hbS5jb3JlLlByb3BlcnR5JyxcblxuICBkb2N1bWVudGF0aW9uOiAnU2V0IGEgVmlld0ZhY3RvcnkgdG8gYmUgYSBzdHJpbmcgY29udGFpbmluZyBhIGNsYXNzIG5hbWUsICcgK1xuICAgICAgJ2EgQ2xhc3Mgb2JqZWN0LCBvciBhIGZhY3RvcnkgZnVuY3Rpb24oYXJncywgY29udGV4dCkuIHRoaXMubXlGYWN0b3J5ICcgK1xuICAgICAgJ2lzIHRoZSBvcmlnaW5hbCB2YWx1ZSwgYnV0IHlvdSBjYW4gY2FsbCB0aGlzLm15RmFjdG9yeSRmKGFyZ3MsIGN0eCkgJyArXG4gICAgICAndG8gY3JlYXRlIGFuIGluc3RhbmNlLiBVc2VmdWwgZm9yIHJvd1ZpZXdzIGFuZCBzaW1pbGFyLicsXG5cbiAgbWV0aG9kczogW1xuICAgIGZ1bmN0aW9uIGluc3RhbGxJblByb3RvKHByb3RvKSB7XG4gICAgICB0aGlzLlNVUEVSKHByb3RvKTtcblxuICAgICAgdmFyIG5hbWUgPSB0aGlzLm5hbWU7XG5cbiAgICAgIHByb3RvW25hbWUgKyAnJGYnXSA9IGZ1bmN0aW9uKGFyZ3MsIGN0eCkge1xuICAgICAgICBjb25zb2xlLndhcm4oJ0RlcHJlY2F0ZWQgdXNlIG9mIFZpZXdGYWN0b3J5OyB1c2UgVmlld1NwZWMgaW5zdGVhZCEnKTtcbiAgICAgICAgY3R4ID0gY3R4IHx8IHRoaXM7XG4gICAgICAgIHZhciByYXcgPSB0aGlzW25hbWVdO1xuXG4gICAgICAgIGlmICggdHlwZW9mIHJhdyA9PT0gJ2Z1bmN0aW9uJyApIHtcbiAgICAgICAgICByZXR1cm4gcmF3LmNhbGwodGhpcywgYXJncywgY3R4KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICggdHlwZW9mIHJhdyA9PT0gJ3N0cmluZycgKSB7XG4gICAgICAgICAgcmV0dXJuIGN0eC5sb29rdXAocmF3KS5jcmVhdGUoYXJncywgY3R4KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByYXcuY3JlYXRlKGFyZ3MsIGN0eCk7XG4gICAgICB9O1xuICAgIH1cbiAgXVxufSk7XG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5mb2FtLkNMQVNTKHtcbiAgcGFja2FnZTogJ2ZvYW0udTInLFxuICBuYW1lOiAnREFPTGlzdCcsXG4gIGV4dGVuZHM6ICdmb2FtLnUyLkVsZW1lbnQnLFxuXG4gIHRvcGljczogWyAncm93Q2xpY2snIF0sXG5cbiAgZXhwb3J0czogW1xuICAgICdzZWxlY3Rpb24nLFxuICAgICdob3ZlclNlbGVjdGlvbidcbiAgXSxcblxuICBpbXBvcnRzOiBbXG4gICAgJ2VkaXRSZWNvcmQ/JyxcbiAgICAnc2VsZWN0aW9uPyBhcyBpbXBvcnRTZWxlY3Rpb24nXG4gIF0sXG5cbiAgcHJvcGVydGllczogW1xuICAgIHtcbiAgICAgIGNsYXNzOiAnZm9hbS5kYW8uREFPUHJvcGVydHknLFxuICAgICAgbmFtZTogJ2RhdGEnXG4gICAgfSxcbiAgICB7XG4gICAgICBjbGFzczogJ2ZvYW0udTIuVmlld1NwZWMnLFxuICAgICAgbmFtZTogJ3Jvd1ZpZXcnXG4gICAgfSxcbiAgICB7XG4gICAgICAvLyBkZXByZWNhdGVkXG4gICAgICBjbGFzczogJ2ZvYW0udTIuVmlld0ZhY3RvcnknLFxuICAgICAgbmFtZTogJ3Jvd0ZhY3RvcnknXG4gICAgfSxcbiAgICAnc2VsZWN0aW9uJyxcbiAgICAnaG92ZXJTZWxlY3Rpb24nXG4gIF0sXG5cbiAgbWV0aG9kczogW1xuICAgIGZ1bmN0aW9uIGluaXRFKCkge1xuICAgICAgdmFyIHZpZXcgPSB0aGlzO1xuICAgICAgdGhpcy5cbiAgICAgICAgYWRkQ2xhc3ModGhpcy5teUNsYXNzKCkpLlxuICAgICAgICBzZWxlY3QodGhpcy5kYXRhJHByb3h5LCBmdW5jdGlvbihvYmopIHtcbiAgICAgICAgICByZXR1cm4gKCB0aGlzLnJvd1ZpZXcgP1xuICAgICAgICAgICAgICAgICAgICAgICBmb2FtLnUyLlZpZXdTcGVjLmNyZWF0ZVZpZXcodGhpcy5yb3dWaWV3LCB7IGRhdGE6IG9iaiB9LCB0aGlzLCB0aGlzLl9fc3ViU3ViQ29udGV4dF9fKSA6XG4gICAgICAgICAgICAgICAgICAgICAgIHRoaXMucm93RmFjdG9yeSRmKHsgZGF0YTogb2JqIH0pICkuXG4gICAgICAgICAgICAgIG9uKCdtb3VzZW92ZXInLCBmdW5jdGlvbigpIHsgdmlldy5ob3ZlclNlbGVjdGlvbiA9IG9iajsgfSkuXG4gICAgICAgICAgICAgIG9uKCdjbGljaycsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHZpZXcuc2VsZWN0aW9uID0gb2JqO1xuICAgICAgICAgICAgICAgIGlmICggdmlldy5pbXBvcnRTZWxlY3Rpb24kICkgdmlldy5pbXBvcnRTZWxlY3Rpb24gPSBvYmo7XG4gICAgICAgICAgICAgICAgaWYgKCB2aWV3LmVkaXRSZWNvcmQkICkgdmlldy5lZGl0UmVjb3JkKG9iaik7XG4gICAgICAgICAgICAgICAgdmlldy5yb3dDbGljay5wdWIob2JqKVxuICAgICAgICAgICAgICB9KS5cbiAgICAgICAgICAgICAgYWRkQ2xhc3ModGhpcy5zbG90KGZ1bmN0aW9uKHNlbGVjdGlvbikge1xuICAgICAgICAgICAgICAgIGlmICggb2JqID09PSBzZWxlY3Rpb24gKSByZXR1cm4gdmlldy5teUNsYXNzKCdzZWxlY3RlZCcpO1xuICAgICAgICAgICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICAgICAgICB9LCB2aWV3LnNlbGVjdGlvbiQpKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICBdXG59KTtcblxuZm9hbS5DTEFTUyh7XG4gIHJlZmluZXM6ICdmb2FtLmRhby5SZWxhdGlvbnNoaXBEQU8nLFxuXG4gIHJlcXVpcmVzOiBbXG4gICAgJ2ZvYW0udTIuQ2l0YXRpb25WaWV3JyxcbiAgICAnZm9hbS51Mi5EQU9MaXN0J1xuICBdLFxuXG4gIG1ldGhvZHM6IFtcbiAgICBmdW5jdGlvbiB0b0UoYXJncywgY3R4KSB7XG4gICAgICBhcmdzID0gYXJncyB8fCB7fTtcbiAgICAgIGFyZ3MuZGF0YSA9IHRoaXM7XG4gICAgICBhcmdzLnJvd1ZpZXcgPSB0aGlzLkNpdGF0aW9uVmlldztcbiAgICAgIHJldHVybiB0aGlzLkRBT0xpc3QuY3JlYXRlKGFyZ3MsIGN0eCk7XG4gICAgfVxuICBdXG5cbn0pXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5mb2FtLkNMQVNTKHtcbiAgcGFja2FnZTogJ2ZvYW0udTInLFxuICBuYW1lOiAnVGFibGVDZWxsUHJvcGVydHlSZWZpbmVtZW50JyxcbiAgcmVmaW5lczogJ2ZvYW0uY29yZS5Qcm9wZXJ0eScsXG5cbiAgcHJvcGVydGllczogW1xuICAgIHtcbiAgICAgIG5hbWU6ICdjb2x1bW5MYWJlbCcsXG4gICAgICBmYWN0b3J5OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubGFiZWw7XG4gICAgICB9XG4gICAgfSxcbiAgICB7XG4gICAgICBuYW1lOiAndGFibGVDZWxsVmlldycsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24ob2JqKSB7XG4gICAgICAgIHJldHVybiBvYmpbdGhpcy5uYW1lXTtcbiAgICAgIH1cbiAgICB9XG4gIF1cbn0pO1xuXG5cbmZvYW0uQ0xBU1Moe1xuICBwYWNrYWdlOiAnZm9hbS51MicsXG4gIG5hbWU6ICdUYWJsZUNlbGxBY3Rpb25SZWZpbmVtZW50JyxcbiAgcmVmaW5lczogJ2ZvYW0uY29yZS5BY3Rpb24nLFxuXG4gIHByb3BlcnRpZXM6IFtcbiAgICB7XG4gICAgICBjbGFzczogJ1N0cmluZycsXG4gICAgICBuYW1lOiAnY29sdW1uTGFiZWwnXG4gICAgfSxcbiAgICB7XG4gICAgICBuYW1lOiAndGFibGVDZWxsVmlldycsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24ob2JqLCBlKSB7XG4gICAgICAgIC8vICAgICAgIHJldHVybiBmb2FtLnUyLkFjdGlvblZpZXcuY3JlYXRlKHthY3Rpb246IHRoaXMsIGRhdGE6IG9ian0pO1xuXG4gICAgICAgIHJldHVybiB0aGlzLnRvRShudWxsLCBlLl9fc3ViQ29udGV4dF9fLmNyZWF0ZVN1YkNvbnRleHQoe2RhdGE6IG9ian0pKTtcbiAgICAgIH1cbiAgICB9XG4gIF1cbn0pO1xuXG5cbmZvYW0uQ0xBU1Moe1xuICBwYWNrYWdlOiAnZm9hbS51MicsXG4gIG5hbWU6ICdUYWJsZUJvZHknLFxuICBleHRlbmRzOiAnZm9hbS51Mi5FbGVtZW50JyxcblxuICByZXF1aXJlczogW1xuICAgIC8vIFRPRE8oYnJhZGVuKTogVGhpcyBzaG91bGQgaW1wbGVtZW50IEV4cHJlc3Npb25zIGluc3RlYWQuXG4gICAgJ2ZvYW0ubWxhbmcucHJlZGljYXRlLkFuZCcsXG4gICAgJ2ZvYW0ubWxhbmcucHJlZGljYXRlLkVxJyxcbiAgICAnZm9hbS5tbGFuZy5wcmVkaWNhdGUuTm90JyxcbiAgICAnZm9hbS5tbGFuZy5wcmVkaWNhdGUuT3InLFxuICAgICdmb2FtLnUyLkNoZWNrQm94JyxcbiAgICAnZm9hbS51Mi5UYWJsZUNlbGxSZWZpbmVtZW50J1xuICBdLFxuXG4gIGltcG9ydHM6IFtcbiAgICAnc2VsZWN0aW9uUXVlcnknLCAvLyBPcHRpb25hbC4gSW5zdGFsbGVkIGJ5IHRoZSBUYWJsZVNlbGVjdGlvbiBkZWNvcmF0b3IuXG4gICAgJ3RhYmxlVmlldydcbiAgXSxcblxuICBwcm9wZXJ0aWVzOiBbXG4gICAgWyAnbm9kZU5hbWUnLCAndGJvZHknIF0sXG4gICAgWyAnY29sdW1uc18nIF0sXG4gICAgJ3NlbGVjdGlvbkZlZWRiYWNrXycsXG4gICAge1xuICAgICAgbmFtZTogJ3Jvd3NfJyxcbiAgICAgIGZhY3Rvcnk6IGZ1bmN0aW9uKCkgeyByZXR1cm4ge307IH1cbiAgICB9XG4gIF0sXG5cbiAgbWV0aG9kczogW1xuICAgIGZ1bmN0aW9uIGluaXRFKCkge1xuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgdGhpcy5vbignY2xpY2snLCBmdW5jdGlvbihldmVudCkge1xuICAgICAgICB2YXIgb2JqID0gc2VsZi5lVG9PYmooZXZlbnQpO1xuICAgICAgICBpZiAoIG9iaiApIHNlbGYudGFibGVWaWV3LnNlbGVjdGlvbiA9IG9iajtcbiAgICAgIH0pLlxuICAgICAgb24oJ2RibGNsaWNrJywgZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgdmFyIG9iaiA9IHNlbGYuZVRvT2JqKGV2ZW50KTtcbiAgICAgICAgaWYgKCBvYmogKSAxO1xuICAgICAgfSk7XG4gICAgfSxcblxuICAgIGZ1bmN0aW9uIGVUb09iaihldmVudCkge1xuICAgICAgLyoqIEZpbmQgdGhlIG9iamVjdCBhc3NvY2lhdGVkIHdpdGggYSBET00gZWxlbWVudC4gKiovXG4gICAgICB2YXIgbWUgPSB0aGlzLmVsKCk7XG4gICAgICB2YXIgZSA9IGV2ZW50LnRhcmdldDtcbiAgICAgIHdoaWxlICggZS5ub2RlTmFtZSAhPT0gJ1RSJyAmJiBlICE9PSBtZSApXG4gICAgICAgIGUgPSBlLnBhcmVudE5vZGU7XG5cbiAgICAgIC8vIElmIHdlIG1hbmFnZWQgdG8gY2xpY2sgYmV0d2VlbiByb3dzLCBkbyBub3RoaW5nLlxuICAgICAgaWYgKCBlID09PSBtZSApIHJldHVybjtcblxuICAgICAgLy8gT3RoZXJ3aXNlLCB3ZSBmb3VuZCB0aGUgdHIuXG4gICAgICByZXR1cm4gdGhpcy5yb3dzX1tlLmlkXTtcbiAgICB9LFxuXG4gICAgZnVuY3Rpb24gYWRkT2JqKG9iaikge1xuICAgICAgdmFyIGUgPSB0aGlzLnN0YXJ0KCd0cicpXG4gICAgICAgICAgLmVuYWJsZUNsYXNzKHRoaXMudGFibGVWaWV3Lm15Q2xhc3MoJ3NlbGVjdGVkJyksXG4gICAgICAgICAgICAgIHRoaXMudGFibGVWaWV3LnNlbGVjdGlvbiQubWFwKGZ1bmN0aW9uKHNlbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBzZWwgPT09IG9iajtcbiAgICAgICAgICAgICAgfSkpO1xuXG4gICAgICBpZiAoIHRoaXMuc2VsZWN0aW9uUXVlcnkkICkge1xuICAgICAgICB2YXIgY2I7XG4gICAgICAgIGUuc3RhcnQoJ3RkJylcbiAgICAgICAgICAgIC5zdGFydCh0aGlzLkNoZWNrQm94KS5jYWxsKGZ1bmN0aW9uKCkgeyBjYiA9IHRoaXM7IH0pLmVuZCgpXG4gICAgICAgIC5lbmQoKTtcblxuICAgICAgICB0aGlzLnNlbGVjdGlvblF1ZXJ5JC5zdWIoZm9hbS5GdW5jdGlvbi5iaW5kKHRoaXMuc2VsZWN0aW9uVXBkYXRlLCB0aGlzLFxuICAgICAgICAgICAgY2IsIG9iaikpO1xuICAgICAgICB0aGlzLnNlbGVjdGlvblVwZGF0ZShjYiwgb2JqKTtcbiAgICAgICAgY2IuZGF0YSQuc3ViKGZvYW0uRnVuY3Rpb24uYmluZCh0aGlzLnNlbGVjdGlvbkNsaWNrLCB0aGlzLCBvYmopKTtcbiAgICAgIH1cblxuICAgICAgZm9yICggdmFyIGogPSAwIDsgaiA8IHRoaXMuY29sdW1uc18ubGVuZ3RoIDsgaisrICkge1xuICAgICAgICB2YXIgcHJvcCA9IHRoaXMuY29sdW1uc19bal07XG4gICAgICAgIGUgPSBlLnN0YXJ0KCd0ZCcpLmFkZChwcm9wLnRhYmxlQ2VsbFZpZXcob2JqLCBlKSkuZW5kKCk7XG4gICAgICB9XG4gICAgICBlLmVuZCgpO1xuICAgICAgdGhpcy5yb3dzX1tlLmlkXSA9IG9iajtcbiAgICB9XG4gIF0sXG5cbiAgbGlzdGVuZXJzOiBbXG4gICAge1xuICAgICAgbmFtZTogJ3NlbGVjdGlvblVwZGF0ZScsXG4gICAgICBjb2RlOiBmdW5jdGlvbihjaGVja2JveCwgb2JqKSB7XG4gICAgICAgIHZhciBzZWxlY3RlZCA9IHRoaXMuc2VsZWN0aW9uUXVlcnkuZihvYmopO1xuICAgICAgICBpZiAoIHNlbGVjdGVkICE9PSBjaGVja2JveC5kYXRhICkge1xuICAgICAgICAgIC8vIE5lZWQgdG8gcHJldmVudCBmZWVkYmFjayBiZXR3ZWVuIHRoZXNlIHR3byBsaXN0ZW5lcnMuXG4gICAgICAgICAgdGhpcy5zZWxlY3Rpb25GZWVkYmFja18gPSB0cnVlO1xuICAgICAgICAgIGNoZWNrYm94LmRhdGEgPSBzZWxlY3RlZDtcbiAgICAgICAgICB0aGlzLnNlbGVjdGlvbkZlZWRiYWNrXyA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICB7XG4gICAgICBuYW1lOiAnc2VsZWN0aW9uQ2xpY2snLFxuICAgICAgY29kZTogZnVuY3Rpb24ob2JqLCBfLCBfXywgX19fLCBzbG90KSB7XG4gICAgICAgIGlmICggdGhpcy5zZWxlY3Rpb25GZWVkYmFja18gKSByZXR1cm47XG5cbiAgICAgICAgdmFyIHEgPSB0aGlzLkVxLmNyZWF0ZSh7IGFyZzE6IG9iai5JRCwgYXJnMjogb2JqLmlkIH0pO1xuICAgICAgICBpZiAoIHNsb3QuZ2V0KCkgKSB7XG4gICAgICAgICAgdGhpcy5zZWxlY3Rpb25RdWVyeSA9IHRoaXMuT3IuY3JlYXRlKHtcbiAgICAgICAgICAgIGFyZ3M6IFsgcSwgdGhpcy5zZWxlY3Rpb25RdWVyeSBdXG4gICAgICAgICAgfSkucGFydGlhbEV2YWwoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLnNlbGVjdGlvblF1ZXJ5ID0gdGhpcy5BbmQuY3JlYXRlKHtcbiAgICAgICAgICAgIGFyZ3M6IFsgdGhpcy5Ob3QuY3JlYXRlKHsgYXJnMTogcSB9KSwgdGhpcy5zZWxlY3Rpb25RdWVyeSBdXG4gICAgICAgICAgfSkucGFydGlhbEV2YWwoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgXVxufSk7XG5cblxuZm9hbS5DTEFTUyh7XG4gIHBhY2thZ2U6ICdmb2FtLnUyJyxcbiAgbmFtZTogJ1RhYmxlQm9keVNpbmsnLFxuICBleHRlbmRzOiAnZm9hbS5kYW8uQWJzdHJhY3RTaW5rJyxcblxuICByZXF1aXJlczogW1xuICAgICdmb2FtLnUyLlRhYmxlQm9keSdcbiAgXSxcblxuICBwcm9wZXJ0aWVzOiBbXG4gICAgJ2NvbHVtbnNfJyxcbiAgICB7XG4gICAgICBuYW1lOiAnYm9keScsXG4gICAgICBmYWN0b3J5OiBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMuVGFibGVCb2R5LmNyZWF0ZSh7IGNvbHVtbnNfOiB0aGlzLmNvbHVtbnNfIH0pOyB9XG4gICAgfVxuICBdLFxuICBtZXRob2RzOiBbXG4gICAgZnVuY3Rpb24gcHV0KG9iaikge1xuICAgICAgdGhpcy5ib2R5LmFkZE9iaihvYmopO1xuICAgIH1cbiAgXVxufSk7XG5cblxuZm9hbS5DTEFTUyh7XG4gIHBhY2thZ2U6ICdmb2FtLnUyJyxcbiAgbmFtZTogJ1RhYmxlSGVhZGVyJyxcbiAgZXh0ZW5kczogJ2ZvYW0udTIuRWxlbWVudCcsXG5cbiAgcmVxdWlyZXM6IFtcbiAgICAnZm9hbS5tbGFuZy5vcmRlci5EZXNjJyxcbiAgICAnZm9hbS51Mi5FbnRpdHknXG4gIF0sXG5cbiAgaW1wb3J0czogW1xuICAgICdzZWxlY3Rpb25RdWVyeScsIC8vIE9wdGlvbmFsLiBFeHBvcnRlZCBieSBUYWJsZVNlbGVjdGlvbi5cbiAgICAndGFibGVWaWV3J1xuICBdLFxuXG4gIHByb3BlcnRpZXM6IFtcbiAgICB7XG4gICAgICBuYW1lOiAnY29sdW1uc18nLFxuICAgICAgcmVxdWlyZWQ6IHRydWVcbiAgICB9LFxuICAgICdzb3J0T3JkZXInXG4gIF0sXG5cbiAgbWV0aG9kczogW1xuICAgIGZ1bmN0aW9uIGluaXRFKCkge1xuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgdGhpcy5ub2RlTmFtZSA9ICd0aGVhZCc7XG5cbiAgICAgIHZhciBlID0gdGhpcy5zdGFydCgndHInKTtcbiAgICAgIGlmICggdGhpcy5zZWxlY3Rpb25RdWVyeSQgKSB7XG4gICAgICAgIGUudGFnKCd0ZCcpO1xuICAgICAgfVxuXG4gICAgICBmb3IgKCB2YXIgaSA9IDAgOyBpIDwgdGhpcy5jb2x1bW5zXy5sZW5ndGggOyBpKysgKSB7XG4gICAgICAgIHZhciBzb3J0aW5nJCA9IHRoaXMuc29ydE9yZGVyJC5tYXAoZnVuY3Rpb24ocHJvcCwgb3JkZXIpIHtcbiAgICAgICAgICBpZiAoICEgb3JkZXIgKSByZXR1cm4gJyc7XG4gICAgICAgICAgdmFyIGRlc2MgPSB0aGlzLkRlc2MuaXNJbnN0YW5jZShvcmRlcik7XG4gICAgICAgICAgdmFyIGJhc2VPcmRlciA9IGRlc2MgPyBvcmRlci5hcmcxIDogb3JkZXI7XG4gICAgICAgICAgcmV0dXJuIHByb3AubmFtZSA9PT0gYmFzZU9yZGVyLm5hbWUgP1xuICAgICAgICAgICAgICB0aGlzLkVudGl0eS5jcmVhdGUoeyBuYW1lOiBkZXNjID8gJ2RhcnInIDogJ3VhcnInIH0pIDogJyc7XG4gICAgICAgIH0uYmluZCh0aGlzLCB0aGlzLmNvbHVtbnNfW2ldKSk7XG5cbiAgICAgICAgZS5zdGFydCgndGQnKVxuICAgICAgICAgICAgLmVuYWJsZUNsYXNzKHRoaXMubXlDbGFzcygnc29ydGluZycpLCBzb3J0aW5nJClcbiAgICAgICAgICAgIC5zdGFydCgnc3BhbicpXG4gICAgICAgICAgICAgICAgLmFkZENsYXNzKHRoaXMubXlDbGFzcygnc29ydC1kaXJlY3Rpb24nKSlcbiAgICAgICAgICAgICAgICAuYWRkKHNvcnRpbmckKVxuICAgICAgICAgICAgLmVuZCgpXG4gICAgICAgICAgICAuYWRkKHRoaXMuY29sdW1uc19baV0uY29sdW1uTGFiZWwpXG4gICAgICAgICAgICAub24oJ2NsaWNrJywgdGhpcy50YWJsZVZpZXcuc29ydEJ5LmJpbmQodGhpcy50YWJsZVZpZXcsIHRoaXMuY29sdW1uc19baV0pKVxuICAgICAgICAgICAgLmVuZCgpO1xuICAgICAgfVxuICAgICAgZS5lbmQoKTtcbiAgICB9XG4gIF1cbn0pO1xuXG5cbmZvYW0uQ0xBU1Moe1xuICBwYWNrYWdlOiAnZm9hbS51MicsXG4gIG5hbWU6ICdUYWJsZVZpZXcnLFxuICBleHRlbmRzOiAnZm9hbS51Mi5FbGVtZW50JyxcblxuICByZXF1aXJlczogW1xuICAgICdmb2FtLm1sYW5nLm9yZGVyLkRlc2MnLFxuICAgICdmb2FtLnUyLlRhYmxlQm9keVNpbmsnLFxuICAgICdmb2FtLnUyLlRhYmxlSGVhZGVyJ1xuICBdLFxuXG4gIGV4cG9ydHM6IFtcbiAgICAnYXMgdGFibGVWaWV3J1xuICBdLFxuXG4gIGNzczogYFxuICAgIF5zb3J0aW5nIHtcbiAgICAgIGZvbnQtd2VpZ2h0OiBib2xkO1xuICAgIH1cblxuICAgIF5zb3J0LWRpcmVjdGlvbiB7XG4gICAgICBkaXNwbGF5OiBub25lO1xuICAgICAgbWFyZ2luLXJpZ2h0OiA4cHg7XG4gICAgfVxuICAgIF5zb3J0aW5nIF5zb3J0LWRpcmVjdGlvbiB7XG4gICAgICBkaXNwbGF5OiBpbml0aWFsO1xuICAgIH1cbiAgYCxcblxuICBwcm9wZXJ0aWVzOiBbXG4gICAge1xuICAgICAgY2xhc3M6ICdDbGFzcycsXG4gICAgICBuYW1lOiAnb2YnLFxuICAgICAgZmFjdG9yeTogZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLmRhdGEub2Y7IH1cbiAgICB9LFxuICAgIFsgJ25vZGVOYW1lJywgJ3RhYmxlJyBdLFxuICAgIHtcbiAgICAgIG5hbWU6ICdjb2x1bW5zXycsXG4gICAgICBleHByZXNzaW9uOiBmdW5jdGlvbihjb2x1bW5zLCBvZikge1xuICAgICAgICB2YXIgY2xzID0gdGhpcy5vZjtcbiAgICAgICAgcmV0dXJuIGNvbHVtbnMubWFwKGZ1bmN0aW9uKHApIHtcbiAgICAgICAgICAvLyBMb29rdXAgU3RyaW5nIHZhbHVlcyBhcyBBeGlvbSBuYW1lcywgb3RoZXJ3aXNlLFxuICAgICAgICAgIC8vIHRyZWF0IHRoZSBvYmplY3QgYXMgdGhlIGNvbHVtbiBvYmplY3QgaXRzZWxmLlxuICAgICAgICAgIHJldHVybiB0eXBlb2YgcCA9PT0gJ3N0cmluZycgP1xuICAgICAgICAgICAgICBjbHMuZ2V0QXhpb21CeU5hbWUocCkgOlxuICAgICAgICAgICAgICBwIDtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSxcbiAgICB7XG4gICAgICAvLyBUT0RPOiByZW1vdmUgd2hlbiBhbGwgY29kZSBwb3J0ZWRcbiAgICAgIG5hbWU6ICdwcm9wZXJ0aWVzJyxcbiAgICAgIHNldHRlcjogZnVuY3Rpb24oXywgcHMpIHtcbiAgICAgICAgY29uc29sZS53YXJuKFwiRGVwcmVjYXRlZCB1c2Ugb2YgVGFibGVWaWV3LnByb3BlcnRpZXMuIFVzZSAnY29sdW1ucycgaW5zdGVhZC5cIik7XG4gICAgICAgIHRoaXMuY29sdW1ucyA9IHBzO1xuICAgICAgfVxuICAgIH0sXG4gICAge1xuICAgICAgbmFtZTogJ2NvbHVtbnMnLFxuICAgICAgZXhwcmVzc2lvbjogZnVuY3Rpb24ob2YpIHtcbiAgICAgICAgaWYgKCAhIHRoaXMub2YgKSByZXR1cm4gW107XG5cbiAgICAgICAgdmFyIHRhYmxlQ29sdW1ucyA9IHRoaXMub2YuZ2V0QXhpb21CeU5hbWUoJ3RhYmxlQ29sdW1ucycpO1xuXG4gICAgICAgIGlmICggdGFibGVDb2x1bW5zICkgcmV0dXJuIHRhYmxlQ29sdW1ucy5jb2x1bW5zO1xuXG4gICAgICAgIHJldHVybiB0aGlzLm9mLmdldEF4aW9tc0J5Q2xhc3MoZm9hbS5jb3JlLlByb3BlcnR5KVxuICAgICAgICAgICAgLmZpbHRlcihmdW5jdGlvbihwKSB7IHJldHVybiAhIHAuaGlkZGVuOyB9KVxuICAgICAgICAgICAgLm1hcChmb2FtLmNvcmUuUHJvcGVydHkuTkFNRS5mKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHtcbiAgICAgIG5hbWU6ICdjb25maWcnXG4gICAgICAvLyBNYXAgb2YgcHJvcGVydHktbmFtZToge21hcCBvZiBwcm9wZXJ0eSBvdmVycmlkZXN9IGZvciBjb25maWd1cmluZyBwcm9wZXJ0aWVzXG4gICAgICAvLyB2YWx1ZXMgaW5jbHVkZSAnbGFiZWwnLCAndW5pdHMnLCBhbmQgJ3ZpZXcnXG4gICAgfSxcbiAgICB7XG4gICAgICBjbGFzczogJ2ZvYW0uZGFvLkRBT1Byb3BlcnR5JyxcbiAgICAgIG5hbWU6ICdkYXRhJ1xuICAgIH0sXG4gICAge1xuICAgICAgbmFtZTogJ2hlYWRlcicsXG4gICAgICBleHByZXNzaW9uOiBmdW5jdGlvbihjb2x1bW5zXykge1xuICAgICAgICByZXR1cm4gdGhpcy5UYWJsZUhlYWRlci5jcmVhdGUoe1xuICAgICAgICAgIGNvbHVtbnNfOiBjb2x1bW5zXyxcbiAgICAgICAgICBzb3J0T3JkZXIkOiB0aGlzLnNvcnRPcmRlciRcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSxcbiAgICB7XG4gICAgICBuYW1lOiAnYm9keScsXG4gICAgICBmYWN0b3J5OiBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMuRSgndGJvZHknKTsgfVxuICAgIH0sXG4gICAge1xuICAgICAgbmFtZTogJ3NvcnRPcmRlcidcbiAgICB9LFxuICAgIHtcbiAgICAgIG5hbWU6ICdzZWxlY3Rpb24nXG4gICAgfVxuICBdLFxuXG4gIG1ldGhvZHM6IFtcbiAgICBmdW5jdGlvbiBpbml0KCkge1xuICAgICAgdGhpcy5TVVBFUigpO1xuXG4gICAgICBjb25zb2xlLmxvZygnRGVwcmVjYXRlZCB1c2Ugb2YgZm9hbS51Mi5UYWJsZVZpZXcuIFVzZSBmb2FtLnUyLnZpZXcuVGFibGVWaWV3IGluc3RlYWQuJyk7XG4gICAgfSxcblxuICAgIGZ1bmN0aW9uIGluaXRFKCkge1xuICAgICAgLy8gQ29uZmlndXJlIGNvbHVtbnMgaWYgJ2NvbmZpZycgc2V0LlxuICAgICAgaWYgKCB0aGlzLmNvbmZpZyApIHtcbiAgICAgICAgZm9yICggdmFyIGkgPSAwIDsgaSA8IHRoaXMuY29sdW1uc18ubGVuZ3RoIDsgaSsrICkge1xuICAgICAgICAgIHZhciBjb2wgPSB0aGlzLmNvbHVtbnNfW2ldO1xuICAgICAgICAgIHZhciBjZmcgPSB0aGlzLmNvbmZpZ1tjb2wubmFtZV07XG5cbiAgICAgICAgICBpZiAoIGNmZyApIHRoaXMuY29sdW1uc19baV0gPSBjb2wuY2xvbmUoKS5jb3B5RnJvbShjZmcpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHRoaXMub25EQU9VcGRhdGUoKTtcbiAgICAgIHRoaXMuZGF0YSRwcm94eS5zdWIoJ29uJywgdGhpcy5vbkRBT1VwZGF0ZSk7XG5cbiAgICAgIHJldHVybiB0aGlzLlxuICAgICAgICAgIGFkZENsYXNzKHRoaXMubXlDbGFzcygpKS5cbiAgICAgICAgICBhZGQodGhpcy5oZWFkZXIkLCB0aGlzLmJvZHkkKTtcbiAgICB9LFxuXG4gICAgZnVuY3Rpb24gc29ydEJ5KHByb3ApIHtcbiAgICAgIC8vIFR3byBjYXNlczogc2FtZSBhcyB0aGUgY3VycmVudCBwcm9wLCBvciBkaWZmZXJlbnQuXG4gICAgICB2YXIgc29ydE5hbWUgPSB0aGlzLnNvcnRPcmRlciA/XG4gICAgICAgICAgKHRoaXMuRGVzYy5pc0luc3RhbmNlKHRoaXMuc29ydE9yZGVyKSA/IHRoaXMuc29ydE9yZGVyLmFyZzEubmFtZSA6XG4gICAgICAgICAgICAgIHRoaXMuc29ydE9yZGVyLm5hbWUpIDpcbiAgICAgICAgICAnJztcbiAgICAgIGlmICggc29ydE5hbWUgPT09IHByb3AubmFtZSApIHtcbiAgICAgICAgLy8gSW52ZXJ0IHRoZSBwcmV2aW91cyBvcmRlci5cbiAgICAgICAgdGhpcy5zb3J0T3JkZXIgPSB0aGlzLkRlc2MuaXNJbnN0YW5jZSh0aGlzLnNvcnRPcmRlcikgP1xuICAgICAgICAgICAgcHJvcCA6IHRoaXMuRGVzYy5jcmVhdGUoeyBhcmcxOiBwcm9wIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gU2V0IGl0IHRvIHRoZSBuZXcgY29sdW1uLlxuICAgICAgICB0aGlzLnNvcnRPcmRlciA9IHByb3A7XG4gICAgICB9XG4gICAgICB0aGlzLm9uREFPVXBkYXRlKCk7XG4gICAgfVxuICBdLFxuXG4gIGxpc3RlbmVyczogW1xuICAgIHtcbiAgICAgIG5hbWU6ICdvbkRBT1VwZGF0ZScsXG4gICAgICBpc0ZyYW1lZDogdHJ1ZSxcbiAgICAgIGNvZGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgZGFvID0gdGhpcy5kYXRhO1xuICAgICAgICBpZiAoIHRoaXMuc29ydE9yZGVyICkge1xuICAgICAgICAgIGRhbyA9IGRhby5vcmRlckJ5KHRoaXMuc29ydE9yZGVyKTtcbiAgICAgICAgfVxuICAgICAgICBkYW8uc2VsZWN0KHRoaXMuVGFibGVCb2R5U2luay5jcmVhdGUoe1xuICAgICAgICAgIGNvbHVtbnNfOiB0aGlzLmNvbHVtbnNfXG4gICAgICAgIH0pKS50aGVuKGZ1bmN0aW9uKGEpIHtcbiAgICAgICAgICB0aGlzLmJvZHkgPSBhLmJvZHk7XG4gICAgICAgIH0uYmluZCh0aGlzKSk7XG4gICAgICB9XG4gICAgfVxuICBdXG59KTtcbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmZvYW0uQ0xBU1Moe1xuICBwYWNrYWdlOiAnZm9hbS51MicsXG4gIG5hbWU6ICdUYWJsZVNlbGVjdGlvbicsXG4gIGV4dGVuZHM6ICdmb2FtLnUyLkVsZW1lbnQnLFxuXG4gIHJlcXVpcmVzOiBbXG4gICAgJ2ZvYW0uZGFvLkFycmF5U2luaycsXG4gICAgJ2ZvYW0ubWxhbmcucHJlZGljYXRlLkZhbHNlJyxcbiAgICAnZm9hbS5tbGFuZy5wcmVkaWNhdGUuSW4nLFxuICAgICdmb2FtLm1sYW5nLnByZWRpY2F0ZS5PcicsXG4gICAgJ2ZvYW0ubWxhbmcucHJlZGljYXRlLk5vdCcsXG4gICAgJ2ZvYW0ubWxhbmcuc2luay5Db3VudCcsXG4gICAgJ2ZvYW0ubWxhbmcuc2luay5NYXAnLFxuICAgICdmb2FtLnUyLlRhYmxlVmlldydcbiAgXSxcblxuICBpbXBvcnRzOiBbXG4gICAgJ3VuZmlsdGVyZWREQU8nXG4gIF0sXG5cbiAgZXhwb3J0czogW1xuICAgICdidWxrQWN0aW9ucycsXG4gICAgJ3NlbGVjdGlvblF1ZXJ5J1xuICBdLFxuXG4gIHByb3BlcnRpZXM6IFtcbiAgICB7XG4gICAgICBuYW1lOiAnZGF0YScsXG4gICAgICBwb3N0U2V0OiBmdW5jdGlvbihvbGQsIG51KSB7XG4gICAgICAgIGlmICggdGhpcy5kYW9TdWJfICkge1xuICAgICAgICAgIHRoaXMuZGFvU3ViXy5kZXRhY2goKTtcbiAgICAgICAgICB0aGlzLmRhb1N1Yl8gPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmICggbnUgKSB0aGlzLmRhb1N1Yl8gPSBudS5vbi5zdWIodGhpcy51cGRhdGVDb3VudHMpO1xuICAgICAgICB0aGlzLnVwZGF0ZUNvdW50cygpO1xuICAgICAgfVxuICAgIH0sXG4gICAgJ2Rhb1N1Yl8nLFxuICAgIHtcbiAgICAgIGNsYXNzOiAnQ2xhc3MnLFxuICAgICAgbmFtZTogJ29mJyxcbiAgICAgIGV4cHJlc3Npb246IGZ1bmN0aW9uKGRhdGEpIHsgcmV0dXJuIGRhdGEub2Y7IH1cbiAgICB9LFxuICAgIHtcbiAgICAgIG5hbWU6ICdzZWxlY3Rpb25RdWVyeScsXG4gICAgICBmYWN0b3J5OiBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMuRmFsc2UuY3JlYXRlKCk7IH1cbiAgICB9LFxuICAgICdmaWx0ZXJlZENvdW50XycsXG4gICAgJ3RvdGFsQ291bnRfJyxcbiAgICB7XG4gICAgICBjbGFzczogJ1N0cmluZycsXG4gICAgICBuYW1lOiAnc2VsZWN0aW9uVGV4dF8nLFxuICAgICAgZXhwcmVzc2lvbjogZnVuY3Rpb24oZmlsdGVyZWRDb3VudF8sIHRvdGFsQ291bnRfKSB7XG4gICAgICAgIGlmICggISB0b3RhbENvdW50XyApIHJldHVybiAnJztcbiAgICAgICAgdmFyIHMgPSAodG90YWxDb3VudF8gfHwgJzAnKSArICcgc2VsZWN0ZWQnO1xuICAgICAgICBpZiAoIHRvdGFsQ291bnRfICE9PSBmaWx0ZXJlZENvdW50XyApIHtcbiAgICAgICAgICBzICs9ICcgKCcgKyAoZmlsdGVyZWRDb3VudF8gfHwgJzAnKSArICcgc2hvd24pJztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcztcbiAgICAgIH1cbiAgICB9LFxuICAgICdzZWxlY3RBbGxTdGF0ZScsXG4gICAge1xuICAgICAgY2xhc3M6ICdGT2JqZWN0QXJyYXknLFxuICAgICAgb2Y6ICdBY3Rpb24nLFxuICAgICAgbmFtZTogJ2J1bGtBY3Rpb25zJ1xuICAgIH0sXG4gICAge1xuICAgICAgY2xhc3M6ICdmb2FtLnUyLlZpZXdTcGVjJyxcbiAgICAgIG5hbWU6ICd2aWV3JyxcbiAgICAgIHZhbHVlOiB7IGNsYXNzOiAnZm9hbS51Mi5UYWJsZVZpZXcnIH1cbiAgICB9XG4gIF0sXG5cbiAgbWV0aG9kczogW1xuICAgIGZ1bmN0aW9uIGluaXRFKCkge1xuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgdGhpcy5zdGFydCgpXG4gICAgICAgICAgLnN0YXJ0KCdkaXYnKVxuICAgICAgICAgICAgICAuYWRkKCdTZWxlY3QnKVxuICAgICAgICAgICAgICAuc3RhcnQoJ2EnKVxuICAgICAgICAgICAgICAgICAgLmF0dHJzKHsgaHJlZjogJ2phdmFzY3JpcHQ6JyB9KVxuICAgICAgICAgICAgICAgICAgLm9uKCdjbGljaycsIHRoaXMuc2VsZWN0QWxsKVxuICAgICAgICAgICAgICAgICAgLmFkZENsYXNzKHRoaXMubXlDbGFzcygnbGluaycpKVxuICAgICAgICAgICAgICAgICAgLmFkZCgnQWxsJylcbiAgICAgICAgICAgICAgLmVuZCgpXG4gICAgICAgICAgICAgIC5zdGFydCgnYScpXG4gICAgICAgICAgICAgICAgICAuYXR0cnMoeyBocmVmOiAnamF2YXNjcmlwdDonIH0pXG4gICAgICAgICAgICAgICAgICAub24oJ2NsaWNrJywgdGhpcy5zZWxlY3ROb25lKVxuICAgICAgICAgICAgICAgICAgLmFkZENsYXNzKHRoaXMubXlDbGFzcygnbGluaycpKVxuICAgICAgICAgICAgICAgICAgLmFkZCgnTm9uZScpXG4gICAgICAgICAgICAgIC5lbmQoKVxuICAgICAgICAgIC5lbmQoKVxuICAgICAgICAgIC5zdGFydCgnc3BhbicpLmFkZCh0aGlzLnNlbGVjdGlvblRleHRfJCkuZW5kKClcbiAgICAgICAgICAuc3RhcnQoKVxuICAgICAgICAgICAgICAuYWRkQ2xhc3ModGhpcy5teUNsYXNzKCdhY3Rpb25zJykpXG4gICAgICAgICAgICAgIC5hZGQodGhpcy5idWxrQWN0aW9ucylcbiAgICAgICAgICAuZW5kKClcbiAgICAgIC5lbmQoKVxuICAgICAgLnN0YXJ0KHRoaXMudmlldywge1xuICAgICAgICBvZjogdGhpcy5vZixcbiAgICAgICAgZGF0YSQ6IHRoaXMuZGF0YSRcbiAgICAgIH0pLmVuZCgpO1xuXG4gICAgICB0aGlzLnNlbGVjdGlvblF1ZXJ5JC5zdWIodGhpcy51cGRhdGVDb3VudHMpO1xuICAgIH1cbiAgXSxcblxuICBsaXN0ZW5lcnM6IFtcbiAgICB7XG4gICAgICBuYW1lOiAnc2VsZWN0Tm9uZScsXG4gICAgICBpc0ZyYW1lZDogdHJ1ZSxcbiAgICAgIGNvZGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLnNlbGVjdGlvblF1ZXJ5ID0gdGhpcy5GYWxzZS5jcmVhdGUoKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHtcbiAgICAgIG5hbWU6ICdzZWxlY3RBbGwnLFxuICAgICAgaXNGcmFtZWQ6IHRydWUsXG4gICAgICBjb2RlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICB0aGlzLmRhdGEuc2VsZWN0KHRoaXMuTWFwLmNyZWF0ZSh7XG4gICAgICAgICAgYXJnMTogdGhpcy5vZi5JRCxcbiAgICAgICAgICBkZWxlZ2F0ZTogdGhpcy5BcnJheVNpbmsuY3JlYXRlKClcbiAgICAgICAgfSkpLnRoZW4oZnVuY3Rpb24oYXJyYXkpIHtcbiAgICAgICAgICB2YXIgcSA9IHNlbGYuSW4uY3JlYXRlKHtcbiAgICAgICAgICAgIGFyZzE6IHNlbGYub2YuSUQsXG4gICAgICAgICAgICBhcmcyOiBhcnJheS5kZWxlZ2F0ZS5hXG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICBzZWxmLnNlbGVjdGlvblF1ZXJ5ID0gc2VsZi5Pci5jcmVhdGUoe1xuICAgICAgICAgICAgYXJnczogWyBzZWxmLnNlbGVjdGlvblF1ZXJ5LCBxIF1cbiAgICAgICAgICB9KS5wYXJ0aWFsRXZhbCgpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHtcbiAgICAgIG5hbWU6ICd1cGRhdGVDb3VudHMnLFxuICAgICAgaXNGcmFtZWQ6IHRydWUsXG4gICAgICBjb2RlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICB0aGlzLnVuZmlsdGVyZWREQU8ud2hlcmUodGhpcy5zZWxlY3Rpb25RdWVyeSlcbiAgICAgICAgICAgIC5zZWxlY3QodGhpcy5Db3VudC5jcmVhdGUoKSlcbiAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uKGMpIHsgc2VsZi50b3RhbENvdW50XyA9IGMudmFsdWU7IH0pO1xuICAgICAgICB0aGlzLmRhdGEud2hlcmUodGhpcy5zZWxlY3Rpb25RdWVyeSlcbiAgICAgICAgICAgIC5zZWxlY3QodGhpcy5Db3VudC5jcmVhdGUoKSlcbiAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uKGMpIHsgc2VsZi5maWx0ZXJlZENvdW50XyA9IGMudmFsdWU7IH0pO1xuICAgICAgfVxuICAgIH1cbiAgXSxcblxuICBheGlvbXM6IFtcbiAgICBmb2FtLnUyLkNTUy5jcmVhdGUoe1xuICAgICAgY29kZTogZnVuY3Rpb24gQ1NTKCkgey8qXG4gICAgICAgIF5saW5rIHtcbiAgICAgICAgICBjb2xvcjogIzAwYztcbiAgICAgICAgICBtYXJnaW46IDAgOHB4O1xuICAgICAgICAgIHRleHQtZGVjb3JhdGlvbjogbm9uZTtcbiAgICAgICAgfVxuICAgICAgKi99XG4gICAgfSlcbiAgXVxufSk7XG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5mb2FtLkNMQVNTKHtcbiAgcGFja2FnZTogJ2ZvYW0udTInLFxuICBuYW1lOiAnU2Nyb2xsZXInLFxuICBleHRlbmRzOiAnZm9hbS51Mi5FbGVtZW50JyxcblxuICAvKipcbiAgICogV3JhcHMgYSBUYWJsZVZpZXcgb3Igc2ltaWxhciBhbmQgYWRkcyBhIFNjcm9sbFZpZXcgdG8gaXQuXG4gICAqIENvbmZpZ3VyZSB0aGUgdGFibGUgdmlldyB3aXRoIHRoZSB0YWJsZVZpZXcgcHJvcGVydHksIGFuZCB0aGUgc2Nyb2xsYmFyXG4gICAqIHdpdGggdGhlIHNjcm9sbFZpZXcgcHJvcGVydHkuXG4gICAqIFNldCBkYXRhIHRvIHRoZSBEQU8sIGFuZCB0aGUgdGFibGVWaWV3IHdpbGwgcmVjZWl2ZSB0aGF0IERBTyB3aXRoIHNraXBcbiAgICogYXBwbGllZCBjb3JyZWN0bHkuXG4gICAqXG4gICAqIFRoaXMgdmlldyBuZWVkcyB0byBrbm93IHRoZSBzaXplIG9mIGl0cyBjb250YWluZXIsIGluIG9yZGVyIHRvIHNpemUgdGhlXG4gICAqIHRhYmxlVmlldyBhbmQgc2Nyb2xsYmFyIGFjY29yZGluZ2x5LiBUaGVyZWZvcmUgaXQgbmVlZHMgYSBmaXhlZCByb3cgaGVpZ2h0XG4gICAqIHRvIHVzZSBmb3IgdGhlIHRhYmxlLiBTZXQgcm93SGVpZ2h0IHRvIHRoZSBudW1iZXIgb2YgcGl4ZWxzIHBlciByb3cuXG4gICAqL1xuICByZXF1aXJlczogW1xuICAgICdmb2FtLmdyYXBoaWNzLkNhbnZhcycsXG4gICAgJ2ZvYW0uZ3JhcGhpY3MuU2Nyb2xsQ1ZpZXcnLFxuICAgICdmb2FtLm1sYW5nLnNpbmsuQ291bnQnLFxuICAgICdmb2FtLnUyLlRhYmxlVmlldycsXG4gICAgJ2ZvYW0udTIuVmlld1NwZWMnXG4gIF0sXG5cbiAgaW1wb3J0czogW1xuICAgICd3aW5kb3cnXG4gIF0sXG5cbiAgY3NzOiBgXG4gICAgXiB7XG4gICAgICBkaXNwbGF5OiBmbGV4O1xuICAgICAgZmxleC1ncm93OiAxO1xuICAgICAgb3ZlcmZsb3c6IGhpZGRlbjtcbiAgICB9XG4gICAgXmNvbnRhaW5lciB7XG4gICAgICBmbGV4LWdyb3c6IDE7XG4gICAgICBvdmVyZmxvdy14OiBhdXRvO1xuICAgICAgb3ZlcmZsb3cteTogaGlkZGVuO1xuICAgIH1cbiAgICBeIGNhbnZhcyB7XG4gICAgICBhbGlnbi1zZWxmOiBmbGV4LXN0YXJ0O1xuICAgICAgZmxleC1ncm93OiAwO1xuICAgICAgZmxleC1zaHJpbms6IDA7XG4gICAgfVxuICBgLFxuXG4gIHByb3BlcnRpZXM6IFtcbiAgICB7XG4gICAgICBuYW1lOiAnb2YnLFxuICAgICAgZXhwcmVzc2lvbjogZnVuY3Rpb24oZGF0YSkgeyByZXR1cm4gZGF0YS5vZjsgfVxuICAgIH0sXG4gICAge1xuICAgICAgY2xhc3M6ICdmb2FtLmRhby5EQU9Qcm9wZXJ0eScsXG4gICAgICBuYW1lOiAnZGF0YScsXG4gICAgICByZXF1aXJlZDogdHJ1ZVxuICAgIH0sXG4gICAge1xuICAgICAgY2xhc3M6ICdJbnQnLFxuICAgICAgbmFtZTogJ3Jvd0hlaWdodCcsXG4gICAgICB2YWx1ZTogMzZcbiAgICB9LFxuICAgIHtcbiAgICAgIGNsYXNzOiAnZm9hbS51Mi5WaWV3U3BlYycsXG4gICAgICBuYW1lOiAndGFibGVWaWV3JyxcbiAgICAgIHZhbHVlOiB7IGNsYXNzOiAnZm9hbS51Mi5UYWJsZVZpZXcnIH1cbiAgICB9LFxuICAgIHtcbiAgICAgIGNsYXNzOiAnZm9hbS51Mi5WaWV3U3BlYycsXG4gICAgICBuYW1lOiAnc2Nyb2xsVmlldycsXG4gICAgICB2YWx1ZTogeyBjbGFzczogJ2ZvYW0uZ3JhcGhpY3MuU2Nyb2xsQ1ZpZXcnIH1cbiAgICB9LFxuICAgIHtcbiAgICAgIC8qKiBUaGUgYWN0dWFsIFRhYmxlVmlldyBpbnN0YW5jZS4gKi9cbiAgICAgIG5hbWU6ICd0YWJsZSdcbiAgICB9LFxuICAgIHtcbiAgICAgIC8qKiBUaGUgYWN0dWFsIFNjcm9sbENWaWV3IGluc3RhbmNlLiAqL1xuICAgICAgbmFtZTogJ3Njcm9sbEJhcidcbiAgICB9LFxuICAgICdzY3JvbGxWYWx1ZV8nLFxuICAgICdzY3JvbGxIZWlnaHRfJyxcbiAgICAnc2Nyb2xsRXh0ZW50XycsXG4gICAgJ3BvaW50ZXInXG4gIF0sXG5cbiAgbWV0aG9kczogW1xuICAgIGZ1bmN0aW9uIGluaXRFKCkge1xuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgICB0aGlzLmRhdGEkcHJveHkuc3ViKCdvbicsIHRoaXMub25EQU9VcGRhdGUpO1xuICAgICAgdGhpcy5vbkRBT1VwZGF0ZSgpO1xuXG4gICAgICB0aGlzLnNjcm9sbEJhciA9IHRoaXMuY3JlYXRlQ2hpbGRfKHRoaXMuc2Nyb2xsVmlldywge1xuICAgICAgICB2YWx1ZSQ6ICB0aGlzLnNjcm9sbFZhbHVlXyQsXG4gICAgICAgIGV4dGVudCQ6IHRoaXMuc2Nyb2xsRXh0ZW50XyQsXG4gICAgICAgIGhlaWdodCQ6IHRoaXMuc2Nyb2xsSGVpZ2h0XyRcbiAgICAgIH0pO1xuXG4gICAgICB0aGlzLmFkZENsYXNzKHRoaXMubXlDbGFzcygpKVxuICAgICAgICAgIC5zdGFydCgpXG4gICAgICAgICAgICAgIC5hZGRDbGFzcyh0aGlzLm15Q2xhc3MoJ2NvbnRhaW5lcicpKVxuICAgICAgICAgICAgICAuY2FsbChmdW5jdGlvbigpIHsgc2VsZi50YWJsZSA9IHRoaXM7IH0pXG4gICAgICAgICAgICAgIC5zdGFydCh0aGlzLnRhYmxlVmlldywge1xuICAgICAgICAgICAgICAgIG9mOiB0aGlzLm9mLFxuICAgICAgICAgICAgICAgIGRhdGEkOiB0aGlzLnNsb3QoZnVuY3Rpb24oZGFvLCBleHRlbnQsIHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gZGFvLmxpbWl0KGV4dGVudCkuc2tpcCh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfSwgdGhpcy5kYXRhJCwgdGhpcy5zY3JvbGxFeHRlbnRfJCwgdGhpcy5zY3JvbGxWYWx1ZV8kKVxuICAgICAgICAgICAgICB9KS5lbmQoKVxuICAgICAgICAgIC5lbmQoKVxuICAgICAgICAgIC5zdGFydCh0aGlzLkNhbnZhcylcbiAgICAgICAgICAgICAgLmF0dHJzKHsgaGVpZ2h0OiB0aGlzLnNjcm9sbEhlaWdodF8kIH0pXG4gICAgICAgICAgICAgIC5jYWxsKGZ1bmN0aW9uKCkgeyB0aGlzLmN2aWV3ID0gc2VsZi5zY3JvbGxCYXI7IH0pXG4gICAgICAgICAgLmVuZCgpXG4gICAgICAgICAgLm9uKCd3aGVlbCcsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgIHZhciBuZWdhdGl2ZSA9IGUuZGVsdGFZIDwgMDtcbiAgICAgICAgICAgIC8vIENvbnZlcnQgdG8gcm93cywgcm91bmRpbmcgdXAuIChUaGVyZWZvcmUgbWludW11bSAxLilcbiAgICAgICAgICAgIHZhciByb3dzID0gTWF0aC5jZWlsKE1hdGguYWJzKGUuZGVsdGFZKSAvIHNlbGYucm93SGVpZ2h0KTtcbiAgICAgICAgICAgIHNlbGYuc2Nyb2xsVmFsdWVfICs9IG5lZ2F0aXZlID8gLXJvd3MgOiByb3dzO1xuICAgICAgICAgIH0pO1xuXG4gICAgICB0aGlzLm9ubG9hZC5zdWIoZnVuY3Rpb24oKSB7XG4gICAgICAgIHNlbGYub25SZXNpemUoKTtcbiAgICAgICAgc2VsZi53aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgc2VsZi5vblJlc2l6ZSk7XG4gICAgICB9KTtcblxuICAgICAgdGhpcy5vbnVubG9hZC5zdWIoZnVuY3Rpb24oKSB7XG4gICAgICAgIHNlbGYud2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIHNlbGYub25SZXNpemUpO1xuICAgICAgfSk7XG4gICAgfVxuICBdLFxuXG4gIGxpc3RlbmVyczogW1xuICAgIHtcbiAgICAgIG5hbWU6ICdvblJlc2l6ZScsXG4gICAgICBpc0ZyYW1lZDogdHJ1ZSxcbiAgICAgIGNvZGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoICEgdGhpcy5lbCgpICkgcmV0dXJuO1xuXG4gICAgICAgIC8vIERldGVybWluZSB0aGUgaGVpZ2h0IG9mIHRoZSB0YWJsZSdzIHNwYWNlLlxuICAgICAgICB2YXIgaGVpZ2h0ID0gdGhpcy5lbCgpLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmhlaWdodDtcbiAgICAgICAgdGhpcy5zY3JvbGxIZWlnaHRfID0gaGVpZ2h0O1xuICAgICAgICB0aGlzLnNjcm9sbEV4dGVudF8gPSBNYXRoLmZsb29yKGhlaWdodCAvIHRoaXMucm93SGVpZ2h0KTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHtcbiAgICAgIG5hbWU6ICdvbkRBT1VwZGF0ZScsXG4gICAgICBpc0ZyYW1lZDogdHJ1ZSxcbiAgICAgIGNvZGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIHRoaXMuZGF0YS5zZWxlY3QodGhpcy5Db3VudC5jcmVhdGUoKSkudGhlbihmdW5jdGlvbihjKSB7XG4gICAgICAgICAgc2VsZi5zY3JvbGxCYXIuc2l6ZSA9IGMudmFsdWU7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgXVxufSk7XG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5mb2FtLkNMQVNTKHtcbiAgcGFja2FnZTogJ2ZvYW0udTInLFxuICBuYW1lOiAnQWN0aW9uVmlldycsXG4gIGV4dGVuZHM6ICdmb2FtLnUyLlVuc3R5bGVkQWN0aW9uVmlldycsXG5cbiAgY3NzOiBgXG4gICAgYnV0dG9uXiB7XG4gICAgICAtd2Via2l0LWJveC1zaGFkb3c6IGluc2V0IDAgMXB4IDAgMCAjZmZmZmZmO1xuICAgICAgYm94LXNoYWRvdzogaW5zZXQgMCAxcHggMCAwICNmZmZmZmY7XG4gICAgICBiYWNrZ3JvdW5kOiAtd2Via2l0LWdyYWRpZW50KCBsaW5lYXIsIGxlZnQgdG9wLCBsZWZ0IGJvdHRvbSwgY29sb3Itc3RvcCgwLjA1LCAjZWRlZGVkKSwgY29sb3Itc3RvcCgxLCAjZGZkZmRmKSApO1xuICAgICAgYmFja2dyb3VuZDogLW1vei1saW5lYXItZ3JhZGllbnQoIGNlbnRlciB0b3AsICNlZGVkZWQgNSUsICNkZmRmZGYgMTAwJSApO1xuICAgICAgYmFja2dyb3VuZC1jb2xvcjogI2VkZWRlZDtcbiAgICAgIC1tb3otYm9yZGVyLXJhZGl1czogM3B4O1xuICAgICAgLXdlYmtpdC1ib3JkZXItcmFkaXVzOiAzcHg7XG4gICAgICBib3JkZXItcmFkaXVzOiAzcHg7XG4gICAgICBib3JkZXI6IDFweCBzb2xpZCAjZGNkY2RjO1xuICAgICAgZGlzcGxheTogaW5saW5lLWJsb2NrO1xuICAgICAgY29sb3I6ICM3Nzc3Nzc7XG4gICAgICBmb250LWZhbWlseTogQXJpYWw7XG4gICAgICBmb250LXNpemU6IDEycHg7XG4gICAgICBmb250LXdlaWdodDogYm9sZDtcbiAgICAgIG1hcmdpbjogMnB4O1xuICAgICAgcGFkZGluZzogNHB4IDE2cHg7XG4gICAgICB0ZXh0LWRlY29yYXRpb246IG5vbmU7XG4gICAgfVxuXG4gICAgXnVuYXZhaWxhYmxlIHtcbiAgICAgIGRpc3BsYXk6IG5vbmU7XG4gICAgfVxuXG4gICAgXjpob3ZlciB7XG4gICAgICBiYWNrZ3JvdW5kOiAtd2Via2l0LWdyYWRpZW50KCBsaW5lYXIsIGxlZnQgdG9wLCBsZWZ0IGJvdHRvbSwgY29sb3Itc3RvcCgwLjA1LCAjZGZkZmRmKSwgY29sb3Itc3RvcCgxLCAjZWRlZGVkKSApO1xuICAgICAgYmFja2dyb3VuZDogLW1vei1saW5lYXItZ3JhZGllbnQoIGNlbnRlciB0b3AsICNkZmRmZGYgNSUsICNlZGVkZWQgMTAwJSApO1xuICAgICAgYmFja2dyb3VuZC1jb2xvcjogI2RmZGZkZjtcbiAgICB9XG5cbiAgICBeIGltZyB7XG4gICAgICB2ZXJ0aWNhbC1hbGlnbjogbWlkZGxlO1xuICAgIH1cblxuICAgIF46ZGlzYWJsZWQgeyBmaWx0ZXI6IGdyYXlzY2FsZSg4MCUpOyB9XG5cbiAgICBeLm1hdGVyaWFsLWljb25zIHtcbiAgICAgIGN1cnNvcjogcG9pbnRlcjtcbiAgICB9XG4gIGAsXG5cbiAgcHJvcGVydGllczogW1xuICAgIHtcbiAgICAgIGNsYXNzOiAnQm9vbGVhbicsXG4gICAgICBuYW1lOiAnc2hvd0xhYmVsJyxcbiAgICAgIGV4cHJlc3Npb246IGZ1bmN0aW9uKGljb24sIGljb25Gb250TmFtZSApIHsgcmV0dXJuICEgKCBpY29uIHx8IGljb25Gb250TmFtZSk7IH1cbiAgICB9LFxuICAgIHtcbiAgICAgIGNsYXNzOiAnVVJMJyxcbiAgICAgIG5hbWU6ICdpY29uJyxcbiAgICAgIGZhY3Rvcnk6IGZ1bmN0aW9uKGFjdGlvbikgeyByZXR1cm4gdGhpcy5hY3Rpb24uaWNvbjsgfVxuICAgIH0sXG4gICAge1xuICAgICAgY2xhc3M6ICdTdHJpbmcnLFxuICAgICAgbmFtZTogJ2ljb25Gb250RmFtaWx5JyxcbiAgICAgIGZhY3Rvcnk6IGZ1bmN0aW9uKGFjdGlvbikgeyByZXR1cm4gdGhpcy5hY3Rpb24uaWNvbkZvbnRGYW1pbHk7IH1cbiAgICB9LFxuICAgIHtcbiAgICAgIGNsYXNzOiAnU3RyaW5nJyxcbiAgICAgIG5hbWU6ICdpY29uRm9udENsYXNzJyxcbiAgICAgIGZhY3Rvcnk6IGZ1bmN0aW9uKGFjdGlvbikgeyByZXR1cm4gdGhpcy5hY3Rpb24uaWNvbkZvbnRDbGFzczsgfVxuICAgIH0sXG4gICAge1xuICAgICAgY2xhc3M6ICdTdHJpbmcnLFxuICAgICAgbmFtZTogJ2ljb25Gb250TmFtZScsXG4gICAgICBmYWN0b3J5OiBmdW5jdGlvbihhY3Rpb24pIHsgcmV0dXJuIHRoaXMuYWN0aW9uLmljb25Gb250TmFtZTsgfVxuICAgIH0sXG4gICAgJ2RhdGEnLFxuICAgICdhY3Rpb24nLFxuICAgIFsgJ25vZGVOYW1lJywgJ2J1dHRvbicgXSxcbiAgICB7XG4gICAgICBuYW1lOiAnbGFiZWwnLFxuICAgICAgZmFjdG9yeTogZnVuY3Rpb24oYWN0aW9uKSB7IHJldHVybiB0aGlzLmFjdGlvbi5sYWJlbDsgfVxuICAgIH1cbiAgXSxcblxuICBtZXRob2RzOiBbXG4gICAgZnVuY3Rpb24gaW5pdEUoKSB7XG4gICAgICB0aGlzLmluaXRDbHMoKTtcblxuICAgICAgdGhpcy5cbiAgICAgICAgb24oJ2NsaWNrJywgdGhpcy5jbGljayk7XG5cbiAgICAgIGlmICggdGhpcy5pY29uICkge1xuICAgICAgICAvLyB0aGlzLm5vZGVOYW1lID0gJ2EnO1xuICAgICAgICB0aGlzLnN0YXJ0KCdpbWcnKS5hdHRyKCdzcmMnLCB0aGlzLmljb24pLmVuZCgpO1xuICAgICAgfSBlbHNlIGlmICggdGhpcy5pY29uRm9udE5hbWUgKSB7XG4gICAgICAgIHRoaXMubm9kZU5hbWUgPSAnaSc7XG4gICAgICAgIHRoaXMuY3NzQ2xhc3ModGhpcy5hY3Rpb24ubmFtZSk7XG4gICAgICAgIHRoaXMuY3NzQ2xhc3ModGhpcy5pY29uRm9udENsYXNzKTsgLy8gcmVxdWlyZWQgYnkgZm9udCBwYWNrYWdlXG4gICAgICAgIHRoaXMuc3R5bGUoeydmb250LWZhbWlseSc6IHRoaXMuaWNvbkZvbnRGYW1pbHl9KTtcbiAgICAgICAgdGhpcy5hZGQodGhpcy5pY29uRm9udE5hbWUpO1xuICAgICAgfVxuXG4gICAgICBpZiAoIHRoaXMuc2hvd0xhYmVsICkge1xuICAgICAgICB0aGlzLmFkZCh0aGlzLmxhYmVsJCk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuc2V0QXR0cmlidXRlKCd0aXRsZScsIHRoaXMuYWN0aW9uLnRvb2xUaXApOyAvLyBob3ZlciB0ZXh0XG5cbiAgICAgIGlmICggdGhpcy5hY3Rpb24gKSB7XG4gICAgICAgIGlmICggdGhpcy5hY3Rpb24uaXNBdmFpbGFibGUgKSB7XG4gICAgICAgICAgdGhpcy5lbmFibGVDbGFzcyh0aGlzLm15Q2xhc3MoJ3VuYXZhaWxhYmxlJyksIHRoaXMuYWN0aW9uLmNyZWF0ZUlzQXZhaWxhYmxlJCh0aGlzLmRhdGEkKSwgdHJ1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIHRoaXMuYWN0aW9uLmlzRW5hYmxlZCApIHtcbiAgICAgICAgICB0aGlzLmF0dHJzKHtkaXNhYmxlZDogdGhpcy5hY3Rpb24uY3JlYXRlSXNFbmFibGVkJCh0aGlzLmRhdGEkKS5tYXAoZnVuY3Rpb24oZSkgeyByZXR1cm4gZSA/IGZhbHNlIDogJ2Rpc2FibGVkJzsgfSl9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBmdW5jdGlvbiBpbml0Q2xzKCkge1xuICAgICAgdGhpcy5hZGRDbGFzcyh0aGlzLm15Q2xhc3MoKSk7XG4gICAgICB0aGlzLmFkZENsYXNzKHRoaXMubXlDbGFzcyh0aGlzLmFjdGlvbi5uYW1lKSk7XG4gICAgfVxuICBdLFxuXG4gIGxpc3RlbmVyczogW1xuICAgIGZ1bmN0aW9uIGNsaWNrKGUpIHtcbiAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICB0aGlzLmFjdGlvbiAmJiB0aGlzLmFjdGlvbi5tYXliZUNhbGwodGhpcy5fX3N1YkNvbnRleHRfXywgdGhpcy5kYXRhKTtcbiAgICB9XG4gIF1cbn0pO1xuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTYgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbmZvYW0uQ0xBU1Moe1xuICBwYWNrYWdlOiAnZm9hbS51Mi5tZCcsXG4gIG5hbWU6ICdBY3Rpb25WaWV3JyxcbiAgZXh0ZW5kczogJ2ZvYW0udTIuRWxlbWVudCcsXG5cbiAgYXhpb21zOiBbXG4gICAgZm9hbS51Mi5DU1MuY3JlYXRlKHtcbiAgICAgIGNvZGU6IGZ1bmN0aW9uIENTUygpIHsvKlxuICAgICAgICBedW5hdmFpbGFibGUge1xuICAgICAgICAgIGRpc3BsYXk6IG5vbmU7XG4gICAgICAgIH1cbiAgICAgICovfVxuICAgIH0pXG4gIF0sXG5cbiAgcHJvcGVydGllczogW1xuICAgICdkYXRhJyxcbiAgICAnYWN0aW9uJyxcbiAgICB7XG4gICAgICBjbGFzczogJ0Jvb2xlYW4nLFxuICAgICAgbmFtZTogJ3JhaXNlZCcsXG4gICAgICBkb2N1bWVudGF0aW9uOiAnQ29udHJvbHMgdGhlIFwicmFpc2VkXCIgYXR0cmlidXRlIGluIFBvbHltZXIuIERlZmF1bHRzICcgK1xuICAgICAgICAgICd0byBmYWxzZTsgc2V0IHRoaXMgdG8gdHJ1ZSBmb3IgYSByYWlzZWQsIGJvcmRlcmVkIGJ1dHRvbi4nXG4gICAgfSxcbiAgICB7XG4gICAgICBuYW1lOiAnbGFiZWwnLFxuICAgICAgZXhwcmVzc2lvbjogZnVuY3Rpb24oYWN0aW9uKSB7IHJldHVybiBhY3Rpb24ubGFiZWw7IH1cbiAgICB9XG4gIF0sXG5cbiAgbWV0aG9kczogW1xuICAgIGZ1bmN0aW9uIGluaXRFKCkge1xuICAgICAgdGhpcy5ub2RlTmFtZSA9ICdwYXBlci1idXR0b24nO1xuICAgICAgdGhpcy5hZGRDbGFzcyh0aGlzLm15Q2xhc3MoKSlcbiAgICAgICAgICAuYXR0cnMoeyByYWlzZWQ6IHRoaXMucmFpc2VkJCB9KVxuICAgICAgICAgIC5vbignY2xpY2snLCB0aGlzLmNsaWNrKVxuICAgICAgICAgIC5hZGQodGhpcy5sYWJlbCQpO1xuXG4gICAgICBpZiAoIHRoaXMuYWN0aW9uLmlzQXZhaWxhYmxlICkge1xuICAgICAgICB0aGlzLmVuYWJsZUNsYXNzKHRoaXMubXlDbGFzcygndW5hdmFpbGFibGUnKSxcbiAgICAgICAgICAgICAgdGhpcy5hY3Rpb24uY3JlYXRlSXNBdmFpbGFibGUkKHRoaXMuZGF0YSQpLCB0cnVlIC8qIG5lZ2F0ZSAqLyk7XG4gICAgICB9XG5cbiAgICAgIGlmICggdGhpcy5hY3Rpb24uaXNFbmFibGVkICkge1xuICAgICAgICB0aGlzLmF0dHJzKHtcbiAgICAgICAgICBkaXNhYmxlZDogdGhpcy5hY3Rpb24uY3JlYXRlSXNFbmFibGVkJCh0aGlzLmRhdGEkKS5tYXAoZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgcmV0dXJuIGUgPyBmYWxzZSA6ICdkaXNhYmxlZCc7XG4gICAgICAgICAgfSlcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICBdLFxuXG4gIGxpc3RlbmVyczogW1xuICAgIGZ1bmN0aW9uIGNsaWNrKCkge1xuICAgICAgdGhpcy5hY3Rpb24ubWF5YmVDYWxsKHRoaXMuX19zdWJDb250ZXh0X18sIHRoaXMuZGF0YSk7XG4gICAgfVxuICBdXG59KTtcbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmZvYW0uQ0xBU1Moe1xuICBwYWNrYWdlOiAnZm9hbS51MicsXG4gIG5hbWU6ICdVbnN0eWxlZEFjdGlvblZpZXcnLFxuICBleHRlbmRzOiAnZm9hbS51Mi5FbGVtZW50JyxcblxuICBkb2N1bWVudGF0aW9uOiBmdW5jdGlvbigpIHtgXG4gICAgQSBidXR0b24gVmlldyBmb3IgdHJpZ2dlcmluZyBBY3Rpb25zLlxuXG4gICAgSWNvbiBGb250c1xuICAgIElmIHVzaW5nIGljb24tZm9udHMgYSBjc3Mgc3R5bGVzaGVldCBsaW5rIHRvIHRoZSBmb250cyBpcyByZXF1aXJlZCBpbiBpbmRleC5odG1sLlxuICAgIFRoZSBkZWZhdWx0IG9mIGZvYW0uY29yZS5BY3Rpb24uanMgaXMgJ01hdGVyaWFsIEljb25zJyBzdXBwb3J0ZWQgYnkgdGhlIGZvbGxvd2luZ1xuICAgIGxpbms6IDxsaW5rIGhyZWY9XCJodHRwczovL2ZvbnRzLmdvb2dsZWFwaXMuY29tL2ljb24/ZmFtaWx5PU1hdGVyaWFsK0ljb25zXCIgcmVsPVwic3R5bGVzaGVldFwiPjwvbGluaz5cbiAgYH0sXG5cbiAgZW51bXM6IFtcbiAgICB7XG4gICAgICBuYW1lOiAnQnV0dG9uU3RhdGUnLFxuXG4gICAgICB2YWx1ZXM6IFtcbiAgICAgICAgeyBuYW1lOiAnTk9fQ09ORklSTScgfSwgLy8gTm8gY29uZmlybWF0aW9uIHJlcXVpcmVkLCBmaXJlIG9uIGNsaWNrXG4gICAgICAgIHsgbmFtZTogJ0NPTkZJUk0nIH0sICAgIC8vIENvbmZpcm1hdGlvbiByZXF1aXJlZCwgZGVib3VuY2Ugb24gY2xpY2tcbiAgICAgICAgeyBuYW1lOiAnREVCT1VOQ0UnIH0sICAgLy8gTW92ZSB0byBBcm1lZCBhZnRlciBkZWxheSwgTk9QIG9uIGNsaWNrXG4gICAgICAgIHsgbmFtZTogJ0FSTUVEJyB9ICAgICAgIC8vIFdhaXRpbmcgZm9yIGNvbmZpcm1hdGlvbiwgZmlyZSBvbiBjbGlja1xuICAgICAgXVxuICAgIH1cbiAgXSxcblxuICBtZXNzYWdlczogW1xuICAgIHsgbmFtZTogJ2NvbmZpcm0nLCBtZXNzYWdlOiAnQ29uZmlybScgfVxuICBdLFxuXG4gIHByb3BlcnRpZXM6IFtcbiAgICB7XG4gICAgICBjbGFzczogJ0Jvb2xlYW4nLFxuICAgICAgbmFtZTogJ3Nob3dMYWJlbCcsXG4gICAgICBleHByZXNzaW9uOiBmdW5jdGlvbihpY29uLCBpY29uRm9udE5hbWUgKSB7IHJldHVybiAhICggaWNvbiB8fCBpY29uRm9udE5hbWUpOyB9XG4gICAgfSxcbiAgICB7XG4gICAgICBjbGFzczogJ1VSTCcsXG4gICAgICBuYW1lOiAnaWNvbicsXG4gICAgICBmYWN0b3J5OiBmdW5jdGlvbihhY3Rpb24pIHsgcmV0dXJuIHRoaXMuYWN0aW9uLmljb247IH1cbiAgICB9LFxuICAgIHtcbiAgICAgIGNsYXNzOiAnU3RyaW5nJyxcbiAgICAgIG5hbWU6ICdpY29uRm9udEZhbWlseScsXG4gICAgICBmYWN0b3J5OiBmdW5jdGlvbihhY3Rpb24pIHsgcmV0dXJuIHRoaXMuYWN0aW9uLmljb25Gb250RmFtaWx5OyB9XG4gICAgfSxcbiAgICB7XG4gICAgICBjbGFzczogJ1N0cmluZycsXG4gICAgICBuYW1lOiAnaWNvbkZvbnRDbGFzcycsXG4gICAgICBmYWN0b3J5OiBmdW5jdGlvbihhY3Rpb24pIHsgcmV0dXJuIHRoaXMuYWN0aW9uLmljb25Gb250Q2xhc3M7IH1cbiAgICB9LFxuICAgIHtcbiAgICAgIGNsYXNzOiAnU3RyaW5nJyxcbiAgICAgIG5hbWU6ICdpY29uRm9udE5hbWUnLFxuICAgICAgZmFjdG9yeTogZnVuY3Rpb24oYWN0aW9uKSB7IHJldHVybiB0aGlzLmFjdGlvbi5pY29uRm9udE5hbWU7IH1cbiAgICB9LFxuICAgIHtcbiAgICAgIGNsYXNzOiAnU3RyaW5nJyxcbiAgICAgIG5hbWU6ICdsYWJlbFBsYWNlaG9sZGVyJyxcbiAgICAgIGV4cHJlc3Npb246IGZ1bmN0aW9uKGxhYmVsKSB7IHJldHVybiB0aGlzLmFjdGlvbi5sYWJlbDsgfVxuICAgIH0sXG4gICAge1xuICAgICAgbmFtZTogJ2J1dHRvblN0YXRlJyxcbiAgICAgIGZhY3Rvcnk6IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcy5hY3Rpb24gJiYgdGhpcy5hY3Rpb24uY29uZmlybWF0aW9uUmVxdWlyZWQgPyB0aGlzLkJ1dHRvblN0YXRlLkNPTkZJUk0gOiB0aGlzLkJ1dHRvblN0YXRlLk5PX0NPTkZJUk07IH1cbiAgICB9LFxuICAgICdkYXRhJyxcbiAgICAnYWN0aW9uJyxcbiAgICBbICdub2RlTmFtZScsICdidXR0b24nIF0sXG4gICAge1xuICAgICAgbmFtZTogJ2xhYmVsJyxcbiAgICAgIGZhY3Rvcnk6IGZ1bmN0aW9uKGFjdGlvbikgeyByZXR1cm4gdGhpcy5hY3Rpb24ubGFiZWw7IH1cbiAgICB9XG4gIF0sXG5cbiAgbWV0aG9kczogW1xuICAgIGZ1bmN0aW9uIGluaXRFKCkge1xuICAgICAgdGhpcy5pbml0Q2xzKCk7XG5cbiAgICAgIHRoaXMuXG4gICAgICAgIG9uKCdjbGljaycsIHRoaXMuY2xpY2spO1xuXG4gICAgICB0aGlzLmFkZENvbnRlbnQoKTtcblxuICAgICAgdGhpcy5zZXRBdHRyaWJ1dGUoJ3RpdGxlJywgdGhpcy5hY3Rpb24udG9vbFRpcCk7IC8vIGhvdmVyIHRleHRcblxuICAgICAgaWYgKCB0aGlzLmFjdGlvbiApIHtcbiAgICAgICAgaWYgKCB0aGlzLmFjdGlvbi5pc0F2YWlsYWJsZSApIHtcbiAgICAgICAgICB0aGlzLmVuYWJsZUNsYXNzKHRoaXMubXlDbGFzcygndW5hdmFpbGFibGUnKSwgdGhpcy5hY3Rpb24uY3JlYXRlSXNBdmFpbGFibGUkKHRoaXMuZGF0YSQpLCB0cnVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICggdGhpcy5hY3Rpb24uaXNFbmFibGVkICkge1xuICAgICAgICAgIHRoaXMuYXR0cnMoe2Rpc2FibGVkOiB0aGlzLmFjdGlvbi5jcmVhdGVJc0VuYWJsZWQkKHRoaXMuZGF0YSQpLm1hcChmdW5jdGlvbihlKSB7IHJldHVybiBlID8gZmFsc2UgOiAnZGlzYWJsZWQnOyB9KX0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIGZ1bmN0aW9uIGluaXRDbHMoKSB7XG4gICAgICB0aGlzLmFkZENsYXNzKHRoaXMubXlDbGFzcygpKTtcbiAgICAgIHRoaXMuYWRkQ2xhc3ModGhpcy5teUNsYXNzKHRoaXMuYWN0aW9uLm5hbWUpKTtcbiAgICB9LFxuXG4gICAgZnVuY3Rpb24gYWRkQ29udGVudCgpIHtcbiAgICAgIC8qKiBBZGQgdGV4dCBvciBpY29uIHRvIGJ1dHRvbi4gKiovXG4gICAgICBpZiAoIHRoaXMuaWNvbiApIHtcbiAgICAgICAgLy8gdGhpcy5ub2RlTmFtZSA9ICdhJztcbiAgICAgICAgdGhpcy5zdGFydCgnaW1nJykuYXR0cignc3JjJywgdGhpcy5pY29uKS5lbmQoKTtcbiAgICAgIH0gZWxzZSBpZiAoIHRoaXMuaWNvbkZvbnROYW1lICkge1xuICAgICAgICB0aGlzLm5vZGVOYW1lID0gJ2knO1xuICAgICAgICB0aGlzLmNzc0NsYXNzKHRoaXMuYWN0aW9uLm5hbWUpO1xuICAgICAgICB0aGlzLmNzc0NsYXNzKHRoaXMuaWNvbkZvbnRDbGFzcyk7IC8vIHJlcXVpcmVkIGJ5IGZvbnQgcGFja2FnZVxuICAgICAgICB0aGlzLnN0eWxlKHsnZm9udC1mYW1pbHknOiB0aGlzLmljb25Gb250RmFtaWx5fSk7XG4gICAgICAgIHRoaXMuYWRkKHRoaXMuaWNvbkZvbnROYW1lKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCB0aGlzLnNob3dMYWJlbCApIHtcbiAgICAgICAgdGhpcy5hZGQodGhpcy5sYWJlbCQpO1xuICAgICAgfVxuICAgIH1cbiAgXSxcblxuICBsaXN0ZW5lcnM6IFtcbiAgICBmdW5jdGlvbiBjbGljayhlKSB7XG4gICAgICBpZiAoIHRoaXMuYnV0dG9uU3RhdGUgPT0gdGhpcy5CdXR0b25TdGF0ZS5OT19DT05GSVJNICkge1xuICAgICAgICB0aGlzLmFjdGlvbiAmJiB0aGlzLmFjdGlvbi5tYXliZUNhbGwodGhpcy5fX3N1YkNvbnRleHRfXywgdGhpcy5kYXRhKTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKCB0aGlzLmJ1dHRvblN0YXRlID09IHRoaXMuQnV0dG9uU3RhdGUuQ09ORklSTSApIHtcbiAgICAgICAgdGhpcy5idXR0b25TdGF0ZSA9IHRoaXMuQnV0dG9uU3RhdGUuREVCT1VOQ0U7XG4gICAgICAgIHRoaXMucmVtb3ZlQWxsQ2hpbGRyZW4oKTtcbiAgICAgICAgdGhpcy5hZGQodGhpcy5jb25maXJtKTtcbiAgICAgICAgdGhpcy5kZWJvdW5jZSgpO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoIHRoaXMuYnV0dG9uU3RhdGUgPT0gdGhpcy5CdXR0b25TdGF0ZS5BUk1FRCApIHtcbiAgICAgICAgdGhpcy5yZW1vdmVBbGxDaGlsZHJlbigpO1xuICAgICAgICB0aGlzLmFkZENvbnRlbnQoKTtcbiAgICAgICAgdGhpcy5hY3Rpb24gJiYgdGhpcy5hY3Rpb24ubWF5YmVDYWxsKHRoaXMuX19zdWJDb250ZXh0X18sIHRoaXMuZGF0YSk7XG4gICAgICB9XG5cbiAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgfSxcbiAgICB7XG4gICAgICBuYW1lOiAnZGVib3VuY2UnLFxuICAgICAgaXNNZXJnZWQ6IHRydWUsXG4gICAgICBtZXJnZURlbGF5OiAyMDAsXG4gICAgICBjb2RlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5idXR0b25TdGF0ZSA9IHRoaXMuQnV0dG9uU3RhdGUuQVJNRUQ7XG4gICAgICAgIHRoaXMuZGVhY3RpdmF0ZUNvbmZpcm0oKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHtcbiAgICAgIG5hbWU6ICdkZWFjdGl2YXRlQ29uZmlybScsXG4gICAgICBpc01lcmdlZDogdHJ1ZSxcbiAgICAgIG1lcmdlRGVsYXk6IDYwMDAsXG4gICAgICBjb2RlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5yZW1vdmVBbGxDaGlsZHJlbigpO1xuICAgICAgICB0aGlzLmFkZENvbnRlbnQoKTtcbiAgICAgICAgdGhpcy5idXR0b25TdGF0ZSA9IHRoaXMuQnV0dG9uU3RhdGUuQ09ORklSTTtcbiAgICAgIH1cbiAgICB9XG4gIF1cbn0pO1xuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTUgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuZm9hbS5DTEFTUyh7XG4gIHBhY2thZ2U6ICdmb2FtLnUyJyxcbiAgbmFtZTogJ0RldGFpbFByb3BlcnR5VmlldycsXG4gIGV4dGVuZHM6ICdmb2FtLnUyLkVsZW1lbnQnLFxuXG4gIGRvY3VtZW50YXRpb246ICdWaWV3IGZvciBvbmUgcm93L3Byb3BlcnR5IG9mIGEgRGV0YWlsVmlldy4nLFxuXG4gIHByb3BlcnRpZXM6IFtcbiAgICAncHJvcCcsXG4gICAgWyAnbm9kZU5hbWUnLCAndHInIF1cbiAgXSxcblxuICBheGlvbXM6IFtcbiAgICBmb2FtLnUyLkNTUy5jcmVhdGUoe2NvZGU6IGBcbiAgICAgIC5mb2FtLXUyLVByb3BlcnR5Vmlldy1sYWJlbCB7XG4gICAgICAgIGNvbG9yOiAjNDQ0O1xuICAgICAgICBkaXNwbGF5OiBibG9jaztcbiAgICAgICAgZmxvYXQ6IGxlZnQ7XG4gICAgICAgIGZvbnQtc2l6ZTogMTNweDtcbiAgICAgICAgcGFkZGluZzogNHB4IDhweCA0cHggOHB4O1xuICAgICAgICB0ZXh0LWFsaWduOiBsZWZ0O1xuICAgICAgICB2ZXJ0aWNhbC1hbGlnbjogdG9wO1xuICAgICAgICB3aGl0ZS1zcGFjZTogbm93cmFwO1xuICAgICAgfVxuICAgICAgLmZvYW0tdTItUHJvcGVydHlWaWV3LXZpZXcge1xuICAgICAgICBwYWRkaW5nOiAycHggOHB4IDJweCA2cHg7XG4gICAgICB9XG4gICAgICAuZm9hbS11Mi1Qcm9wZXJ0eVZpZXctdW5pdHMgIHtcbiAgICAgICAgY29sb3I6ICM0NDQ7XG4gICAgICAgIGZvbnQtc2l6ZTogMTJweDtcbiAgICAgICAgcGFkZGluZzogNHB4O1xuICAgICAgICB0ZXh0LWFsaWduOiByaWdodDtcbiAgICAgIH1cbiAgICBgfSlcbiAgXSxcblxuICBtZXRob2RzOiBbXG4gICAgZnVuY3Rpb24gaW5pdEUoKSB7XG4gICAgICB2YXIgcHJvcCA9IHRoaXMucHJvcDtcblxuICAgICAgLy8gVE9ETzogaGlkZSB0aGlzIGVsZW1lbnQgaWYgdGhlIHByb3AgY2hhbmdlcyBpdCdzIG1vZGUgdG8gSElEREVOLlxuICAgICAgdGhpcy5cbiAgICAgICAgYWRkQ2xhc3MoJ2ZvYW0tdTItUHJvcGVydHlWaWV3JykuXG4gICAgICAgIHN0YXJ0KCd0ZCcpLmFkZENsYXNzKCdmb2FtLXUyLVByb3BlcnR5Vmlldy1sYWJlbCcpLmFkZChwcm9wLmxhYmVsKS5lbmQoKS5cbiAgICAgICAgc3RhcnQoJ3RkJykuYWRkQ2xhc3MoJ2ZvYW0tdTItUHJvcGVydHlWaWV3LXZpZXcnKS5hZGQoXG4gICAgICAgICAgcHJvcCxcbiAgICAgICAgICBwcm9wLnVuaXRzICYmIHRoaXMuRSgnc3BhbicpLmFkZENsYXNzKCdmb2FtLXUyLVByb3BlcnR5Vmlldy11bml0cycpLmFkZCgnICcsIHByb3AudW5pdHMpKS5cbiAgICAgICAgZW5kKCk7XG4gICAgfVxuICBdXG59KTtcbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE1IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmZvYW0uQ0xBU1Moe1xuICBwYWNrYWdlOiAnZm9hbS51MicsXG4gIG5hbWU6ICdEZXRhaWxWaWV3JyxcbiAgZXh0ZW5kczogJ2ZvYW0udTIuVmlldycsXG5cbiAgZG9jdW1lbnRhdGlvbjogJ0EgZ2VuZXJpYyBwcm9wZXJ0eS1zaGVldCBzdHlsZSBWaWV3IGZvciBlZGl0aW5nIGFuIEZPYmplY3QuJyxcblxuICByZXF1aXJlczogW1xuICAgICdmb2FtLmNvcmUuUHJvcGVydHknLFxuICAgICdmb2FtLnUyLkRldGFpbFByb3BlcnR5VmlldydcbiAgXSxcblxuICBleHBvcnRzOiBbXG4gICAgJ2N1cnJlbnREYXRhIGFzIGRhdGEnLFxuICAgICdjb250cm9sbGVyTW9kZSdcbiAgXSxcblxuICBheGlvbXM6IFtcbiAgICBmb2FtLnBhdHRlcm4uRmFjZXRlZC5jcmVhdGUoKVxuICBdLFxuXG4gIHByb3BlcnRpZXM6IFtcbiAgICB7XG4gICAgICBuYW1lOiAnZGF0YScsXG4gICAgICBhdHRyaWJ1dGU6IHRydWUsXG4gICAgICBwcmVTZXQ6IGZ1bmN0aW9uKF8sIGRhdGEpIHtcbiAgICAgICAgdmFyIG9mID0gZGF0YSAmJiBkYXRhLmNsc187XG4gICAgICAgIGlmICggb2YgIT09IHRoaXMub2YgKSB7XG4gICAgICAgICAgdGhpcy5vZiA9IG9mO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuY3VycmVudERhdGEgPSBkYXRhO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkYXRhO1xuICAgICAgfVxuICAgIH0sXG4gICAgJ2N1cnJlbnREYXRhJyxcbiAgICB7XG4gICAgICBjbGFzczogJ0NsYXNzJyxcbiAgICAgIG5hbWU6ICdvZidcbiAgICB9LFxuICAgIHtcbiAgICAgIGNsYXNzOiAnQm9vbGVhbicsXG4gICAgICBuYW1lOiAnc2hvd0FjdGlvbnMnXG4gICAgfSxcbiAgICB7XG4gICAgICBuYW1lOiAncHJvcGVydGllcycsXG4gICAgICAvLyBUT0RPOiBNYWtlIGFuIEZPYmplY3RBcnJheSB3aGVuIGl0IHZhbGlkYXRlcyBwcm9wZXJseVxuICAgICAgcHJlU2V0OiBmdW5jdGlvbihfLCBwcykge1xuICAgICAgICBmb2FtLmFzc2VydChwcywgJ1Byb3BlcnRpZXMgcmVxdWlyZWQuJyk7XG4gICAgICAgIGZvciAoIHZhciBpID0gMCA7IGkgPCBwcy5sZW5ndGggOyBpKysgKSB7XG4gICAgICAgICAgZm9hbS5hc3NlcnQoXG4gICAgICAgICAgICAgIGZvYW0uY29yZS5Qcm9wZXJ0eS5pc0luc3RhbmNlKHBzW2ldKSxcbiAgICAgICAgICAgICAgXCJOb24tUHJvcGVydHkgaW4gJ3Byb3BlcnRpZXMnIGxpc3Q6XCIsXG4gICAgICAgICAgICAgIHBzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcHM7XG4gICAgICB9LFxuICAgICAgZXhwcmVzc2lvbjogZnVuY3Rpb24ob2YpIHtcbiAgICAgICAgaWYgKCAhIG9mICkgcmV0dXJuIFtdO1xuICAgICAgICByZXR1cm4gdGhpcy5vZi5nZXRBeGlvbXNCeUNsYXNzKGZvYW0uY29yZS5Qcm9wZXJ0eSkuXG4gICAgICAgICAgLy8gVE9ETzogdGhpcyBpcyBhIHRlbXBvcmFyeSBmaXgsIGJ1dCBWaXNpYmlsaXR5LkhJRERFTiBzaG91bGQgYmUgaW5jbHVkZWQgYW5kIGNvdWxkIGJlIHN3aXRjaGVkXG4gICAgICAgICAgZmlsdGVyKGZ1bmN0aW9uKHApIHsgcmV0dXJuICEgKCBwLmhpZGRlbiB8fCBwLnZpc2liaWxpdHkgPT09IGZvYW0udTIuVmlzaWJpbGl0eS5ISURERU4gKTsgfSk7XG4gICAgICB9XG4gICAgfSxcbiAgICB7XG4gICAgICBuYW1lOiAnY29uZmlnJ1xuICAgICAgLy8gTWFwIG9mIHByb3BlcnR5LW5hbWU6IHttYXAgb2YgcHJvcGVydHkgb3ZlcnJpZGVzfSBmb3IgY29uZmlndXJpbmcgcHJvcGVydGllc1xuICAgICAgLy8gdmFsdWVzIGluY2x1ZGUgJ2xhYmVsJywgJ3VuaXRzJywgYW5kICd2aWV3J1xuICAgIH0sXG4gICAge1xuICAgICAgbmFtZTogJ2FjdGlvbnMnLFxuICAgICAgZXhwcmVzc2lvbjogZnVuY3Rpb24ob2YpIHtcbiAgICAgICAgaWYgKCAhIG9mICkgcmV0dXJuIFtdO1xuICAgICAgICByZXR1cm4gdGhpcy5vZi5nZXRBeGlvbXNCeUNsYXNzKGZvYW0uY29yZS5BY3Rpb24pO1xuICAgICAgfVxuICAgIH0sXG4gICAge1xuICAgICAgbmFtZTogJ3RpdGxlJyxcbiAgICAgIGF0dHJpYnV0ZTogdHJ1ZSxcbiAgICAgIGV4cHJlc3Npb246IGZ1bmN0aW9uKG9mKSB7IHJldHVybiB0aGlzLm9mID8gdGhpcy5vZi5tb2RlbF8ubGFiZWwgOiAnJzsgfSxcbiAgICAgIC8vIGRvY3VtZW50YXRpb246IGZ1bmN0aW9uKCkgey8qXG4gICAgICAvLyAgPHA+VGhlIGRpc3BsYXkgdGl0bGUgZm9yIHRoZSAkJERPQ3tyZWY6J2ZvYW0udWkuVmlldyd9LlxuICAgICAgLy8gIDwvcD5cbiAgICAgIC8vKi99XG4gICAgfSxcbiAgICBbICdub2RlTmFtZScsICdkaXYnIF1cbiAgXSxcblxuICBjc3M6IGBcbiAgICBedG9vbGJhciB7XG4gICAgICBwYWRkaW5nLXRvcDogNHB4O1xuICAgIH1cbiAgYCxcblxuICAvKlxuICBUT0RPOiBwb3J0IG9sZCBGT0FNMSBDU1NcbiAgICAgIF4ge1xuICAgICAgICBiYWNrZ3JvdW5kOiAjZmRmZGZkO1xuICAgICAgICBib3JkZXI6IHNvbGlkIDFweCAjZGRkZGRkO1xuICAgICAgICBib3gtc2hhZG93OiAwIDNweCA2cHggcmdiYSgwLDAsMCwwLjE2KSwgMCAzcHggNnB4IHJnYmEoMCwwLDAsMC4yMyk7XG4gICAgICAgIGRpc3BsYXk6IGlubGluZS1ibG9jaztcbiAgICAgICAgbWFyZ2luOiA1cHg7XG4gICAgICAgIHBhZGRpbmc6IDNweDtcbiAgICAgIH1cbiAgICAgIF4gdGFibGUge1xuICAgICAgICBwYWRkaW5nLWJvdHRvbTogMnB4O1xuICAgICAgfVxuICAgICAgXnRpdGxlIHtcbiAgICAgICAgY29sb3I6ICMzMzM7XG4gICAgICAgIGZsb2F0OiBsZWZ0O1xuICAgICAgICBmb250LXNpemU6IDE0cHg7XG4gICAgICAgIGZvbnQtd2VpZ2h0OiBib2xkO1xuICAgICAgICBtYXJnaW4tYm90dG9tOiA4cHg7XG4gICAgICAgIHBhZGRpbmc6IDJweDtcbiAgICAgIH1cbiAgICAgIF50b29sYmFyIHtcbiAgICAgICAgbWFyZ2luLWxlZnQ6IDVweDtcbiAgICAgIH1cbiAgICAgIF4gaW5wdXQge1xuICAgICAgICBib3JkZXI6IHNvbGlkIDFweCAjYWFjZmU0O1xuICAgICAgICBmb250LXNpemU6IDEwcHg7XG4gICAgICAgIG1hcmdpbjogMnB4IDAgMHB4IDJweDtcbiAgICAgICAgcGFkZGluZzogNHB4IDJweDtcbiAgICAgIH1cbiAgICAgIF4gdGV4dGFyZWEge1xuICAgICAgICBib3JkZXI6IHNvbGlkIDFweCAjYWFjZmU0O1xuICAgICAgICBmbG9hdDogbGVmdDtcbiAgICAgICAgZm9udC1zaXplOiAxMHB4O1xuICAgICAgICBtYXJnaW46IDJweCAwIDBweCAycHg7XG4gICAgICAgIG92ZXJmbG93OiBhdXRvO1xuICAgICAgICBwYWRkaW5nOiA0cHggMnB4O1xuICAgICAgICB3aWR0aDogMTkxcHg7XG4gICAgICB9XG4gICAgICBeIHNlbGVjdCB7XG4gICAgICAgIGJvcmRlcjogc29saWQgMXB4ICNhYWNmZTQ7XG4gICAgICAgIGZvbnQtc2l6ZTogMTBweDtcbiAgICAgICAgbWFyZ2luOiAycHggMCAwcHggMnB4O1xuICAgICAgICBwYWRkaW5nOiA0cHggMnB4O1xuICAgICAgfVxuICAqL1xuXG4gIG1ldGhvZHM6IFtcbiAgICBmdW5jdGlvbiBpbml0RSgpIHtcbiAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgIHRoaXMuYWRkKHRoaXMuc2xvdChmdW5jdGlvbihvZiwgcHJvcGVydGllcywgYWN0aW9ucykge1xuICAgICAgICBpZiAoICEgb2YgKSByZXR1cm4gJyc7XG5cbiAgICAgICAgLy8gQmluZHMgdmlldyB0byBjdXJyZW50RGF0YSBpbnN0ZWFkIG9mIGRhdGEgYmVjYXVzZSB0aGVyZVxuICAgICAgICAvLyBpcyBhIGRlbGF5IGZyb20gd2hlbiBkYXRhIGlzIHVwZGF0ZWQgdW50aWwgd2hlbiB0aGUgVUlcbiAgICAgICAgLy8gaXMgcmVidWlsdCBpZiB0aGUgZGF0YSdzIGNsYXNzIGNoYW5nZXMuIEJpbmRpbmcgZGlyZWN0bHlcbiAgICAgICAgLy8gdG8gZGF0YSBjYXVzZXMgdmlld3MgYW5kIGFjdGlvbnMgZnJvbSB0aGUgb2xkIGNsYXNzIHRvIGdldFxuICAgICAgICAvLyBib3VuZCB0byBkYXRhIG9mIGEgbmV3IGNsYXNzLCB3aGljaCBjYXVzZXMgcHJvYmxlbXMuXG4gICAgICAgIHNlbGYuY3VycmVudERhdGEgPSBzZWxmLmRhdGE7XG5cbiAgICAgICAgdmFyIHRpdGxlID0gc2VsZi50aXRsZSAmJiB0aGlzLkUoJ3RyJykuXG4gICAgICAgICAgc3RhcnQoJ3RkJykuYWRkQ2xhc3ModGhpcy5teUNsYXNzKCd0aXRsZScpKS5hdHRycyh7Y29sc3BhbjogMn0pLlxuICAgICAgICAgICAgYWRkKHNlbGYudGl0bGUkKS5cbiAgICAgICAgICBlbmQoKTtcblxuICAgICAgICByZXR1cm4gc2VsZi5hY3Rpb25Cb3JkZXIoXG4gICAgICAgICAgdGhpcy5cbiAgICAgICAgICAgIEUoJ3RhYmxlJykuXG4gICAgICAgICAgICBhZGRDbGFzcyh0aGlzLm15Q2xhc3MoKSkuXG4gICAgICAgICAgICBhZGQodGl0bGUpLlxuICAgICAgICAgICAgZm9yRWFjaChwcm9wZXJ0aWVzLCBmdW5jdGlvbihwKSB7XG4gICAgICAgICAgICAgIHZhciBjb25maWcgPSBzZWxmLmNvbmZpZyAmJiBzZWxmLmNvbmZpZ1twLm5hbWVdO1xuXG4gICAgICAgICAgICAgIGlmICggY29uZmlnICkge1xuICAgICAgICAgICAgICAgIHAgPSBwLmNsb25lKCk7XG4gICAgICAgICAgICAgICAgZm9yICggdmFyIGtleSBpbiBjb25maWcgKSB7XG4gICAgICAgICAgICAgICAgICBwW2tleV0gPSBjb25maWdba2V5XTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICB0aGlzLnRhZyhzZWxmLkRldGFpbFByb3BlcnR5VmlldywgeyBwcm9wOiBwIH0pO1xuICAgICAgICAgICAgfSkpO1xuICAgICAgfSkpO1xuICAgIH0sXG5cbiAgICBmdW5jdGlvbiBhY3Rpb25Cb3JkZXIoZSkge1xuICAgICAgaWYgKCAhIHRoaXMuc2hvd0FjdGlvbnMgfHwgISB0aGlzLmFjdGlvbnMubGVuZ3RoICkgcmV0dXJuIGU7XG5cbiAgICAgIHJldHVybiB0aGlzLkUoKS5hZGQoZSkuXG4gICAgICAgIHN0YXJ0KCdkaXYnKS5hZGRDbGFzcyh0aGlzLm15Q2xhc3MoJ3Rvb2xiYXInKSkuYWRkKHRoaXMuYWN0aW9ucykuZW5kKCk7XG4gICAgfVxuICBdXG59KTtcbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmZvYW0uQ0xBU1Moe1xuICBwYWNrYWdlOiAnZm9hbS51Mi5tZCcsXG4gIG5hbWU6ICdEZXRhaWxWaWV3JyxcbiAgZXh0ZW5kczogJ2ZvYW0udTIuRGV0YWlsVmlldycsXG5cbiAgcmVxdWlyZXM6IFtcbiAgICAnZm9hbS5jb3JlLlByb3BlcnR5J1xuICBdLFxuXG4gIGV4cG9ydHM6IFtcbiAgICAnZGF0YSdcbiAgXSxcblxuICBwcm9wZXJ0aWVzOiBbXG4gICAge1xuICAgICAgbmFtZTogJ2RhdGEnLFxuICAgICAgcG9zdFNldDogZnVuY3Rpb24ob2xkLCBudSkge1xuICAgICAgICBpZiAoIG51ICYmIG51LmNsc18gIT09IHRoaXMub2YgKSB0aGlzLm9mID0gbnUuY2xzXztcbiAgICAgIH1cbiAgICB9LFxuICAgIHtcbiAgICAgIG5hbWU6ICdvZidcbiAgICB9LFxuICAgIHtcbiAgICAgIG5hbWU6ICdwcm9wZXJ0aWVzJyxcbiAgICAgIGV4cHJlc3Npb246IGZ1bmN0aW9uKG9mKSB7XG4gICAgICAgIHJldHVybiBvZi5nZXRBeGlvbXNCeUNsYXNzKGZvYW0uY29yZS5Qcm9wZXJ0eSkuZmlsdGVyKGZ1bmN0aW9uKHApIHtcbiAgICAgICAgICByZXR1cm4gISBwLmhpZGRlbjtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSxcbiAgICB7XG4gICAgICBuYW1lOiAndGl0bGUnLFxuICAgICAgZXhwcmVzc2lvbjogZnVuY3Rpb24ob2YpIHtcbiAgICAgICAgcmV0dXJuIG9mLm1vZGVsXy5sYWJlbDtcbiAgICAgIH1cbiAgICB9LFxuICAgIFsgJ3Nob3dUaXRsZScsIHRydWUgXSxcbiAgICBbICdub2RlTmFtZScsICdkaXYnIF1cbiAgXSxcblxuICBtZXRob2RzOiBbXG4gICAgZnVuY3Rpb24gaW5pdEUoKSB7XG4gICAgICB0aGlzLmFkZCh0aGlzLnByb3BlcnRpZXMkKTtcbiAgICB9XG4gIF1cbn0pO1xuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTYgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuZm9hbS5DTEFTUyh7XG4gIHBhY2thZ2U6ICdmb2FtLnUyLnRhZycsXG4gIG5hbWU6ICdJbWFnZScsXG4gIGV4dGVuZHM6ICdmb2FtLnUyLlZpZXcnLFxuXG4gIHByb3BlcnRpZXM6IFtcbiAgICB7XG4gICAgICBuYW1lOiAnZGlzcGxheVdpZHRoJyxcbiAgICAgIGF0dHJpYnV0ZTogdHJ1ZVxuICAgIH0sXG4gICAge1xuICAgICAgbmFtZTogJ2Rpc3BsYXlIZWlnaHQnLFxuICAgICAgYXR0cmlidXRlOiB0cnVlXG4gICAgfSxcbiAgICBbJ2FscGhhJywgMS4wXSxcbiAgICBbJ25vZGVOYW1lJywgJ2ltZyddXG4gIF0sXG5cbiAgbWV0aG9kczogW1xuICAgIGZ1bmN0aW9uIGluaXRFKCkge1xuICAgICAgdGhpcy5cbiAgICAgICAgYXR0cnMoeyBzcmM6IHRoaXMuZGF0YSQgfSkuXG4gICAgICAgIHN0eWxlKHtcbiAgICAgICAgICBoZWlnaHQ6ICB0aGlzLmRpc3BsYXlIZWlnaHQkLFxuICAgICAgICAgIHdpZHRoOiAgIHRoaXMuZGlzcGxheVdpZHRoJCxcbiAgICAgICAgICBvcGFjaXR5OiB0aGlzLmFscGhhJFxuICAgICAgICB9KTtcbiAgICB9XG4gIF1cbn0pO1xuXG5mb2FtLl9fY29udGV4dF9fLnJlZ2lzdGVyRWxlbWVudChmb2FtLnUyLnRhZy5JbWFnZSk7XG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNSBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5mb2FtLkNMQVNTKHtcbiAgcGFja2FnZTogJ2ZvYW0udTIudGFnJyxcbiAgbmFtZTogJ0lucHV0JyxcbiAgZXh0ZW5kczogJ2ZvYW0udTIuVmlldycsXG5cbiAgY3NzOiAnXjpyZWFkLW9ubHkgeyBib3JkZXI6IG5vbmU7IGJhY2tncm91bmQ6IHJnYmEoMCwwLDAsMCk7IH0nLFxuXG4gIHByb3BlcnRpZXM6IFtcbiAgICBbICdub2RlTmFtZScsICdpbnB1dCcgXSxcbiAgICB7XG4gICAgICBuYW1lOiAnZGF0YScsXG4gICAgICBwcmVTZXQ6IGZ1bmN0aW9uKG8sIGQpIHtcbiAgICAgICAgdmFyIGYgPSAhIGQgfHwgdHlwZW9mIGQgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiBkID09PSAnbnVtYmVyJyB8fCB0eXBlb2YgZCA9PT0gJ2Jvb2xlYW4nIHx8IGZvYW0uRGF0ZS5pc0luc3RhbmNlKGQpO1xuICAgICAgICBpZiAoICEgZiApIHtcbiAgICAgICAgICB0aGlzLndhcm4oJ1NldCBJbnB1dCBkYXRhIHRvIG5vbi1wcmltaXRpdmU6JyArIGQpO1xuICAgICAgICAgIHJldHVybiBvO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkO1xuICAgICAgfVxuICAgICAgLypcbiAgICAgIGFzc2VydFZhbHVlOiBmdW5jdGlvbihkKSB7XG4gICAgICAgIGZvYW0uYXNzZXJ0KCEgZCB8fCB0eXBlb2YgZCA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIGQgPT09ICdudW1iZXInIHx8IHR5cGVvZiBkID09PSAnYm9vbGVhbicgfHwgZm9hbS5EYXRlLmlzSW5zdGFuY2UoZCksICdTZXQgSW5wdXQgZGF0YSB0byBub24tcHJpbWl0aXZlLicpO1xuICAgICAgfSovXG4gICAgfSxcbiAgICB7XG4gICAgICBjbGFzczogJ0Jvb2xlYW4nLFxuICAgICAgbmFtZTogJ29uS2V5JyxcbiAgICAgIGF0dHJpYnV0ZTogdHJ1ZSxcbiAgICAgIC8vIGRvY3VtZW50YXRpb246ICdXaGVuIHRydWUsICQkRE9De3JlZjpcIi5kYXRhXCJ9IGlzIHVwZGF0ZWQgb24gZXZlcnkga2V5c3Ryb2tlLCByYXRoZXIgdGhhbiBvbiBibHVyLidcbiAgICB9LFxuICAgIHtcbiAgICAgIGNsYXNzOiAnSW50JyxcbiAgICAgIG5hbWU6ICdzaXplJ1xuICAgIH0sXG4gICAge1xuICAgICAgY2xhc3M6ICdJbnQnLFxuICAgICAgbmFtZTogJ21heExlbmd0aCcsXG4gICAgICBhdHRyaWJ1dGU6IHRydWUsXG4gICAgICAvLyBkb2N1bWVudGF0aW9uOiAnV2hlbiBzZXQsIHdpbGwgbGltaXQgdGhlIGxlbmd0aCBvZiB0aGUgaW5wdXQgdG8gYSBjZXJ0YWluIG51bWJlcidcbiAgICB9LFxuICAgICd0eXBlJyxcbiAgICAncGxhY2Vob2xkZXInXG4gIF0sXG5cbiAgbWV0aG9kczogW1xuICAgIGZ1bmN0aW9uIGluaXRFKCkge1xuICAgICAgdGhpcy5TVVBFUigpO1xuXG4gICAgICBpZiAoIHRoaXMuc2l6ZSAgICAgICAgICApIHRoaXMuc2V0QXR0cmlidXRlKCdzaXplJywgICAgICAgIHRoaXMuc2l6ZSk7XG4gICAgICBpZiAoIHRoaXMudHlwZSAgICAgICAgICApIHRoaXMuc2V0QXR0cmlidXRlKCd0eXBlJywgICAgICAgIHRoaXMudHlwZSk7XG4gICAgICBpZiAoIHRoaXMucGxhY2Vob2xkZXIgICApIHRoaXMuc2V0QXR0cmlidXRlKCdwbGFjZWhvbGRlcicsIHRoaXMucGxhY2Vob2xkZXIpO1xuICAgICAgaWYgKCB0aGlzLm1heExlbmd0aCA+IDAgKSB0aGlzLnNldEF0dHJpYnV0ZSgnbWF4bGVuZ3RoJywgICB0aGlzLm1heExlbmd0aCk7XG5cbiAgICAgIHRoaXMuaW5pdENscygpO1xuICAgICAgdGhpcy5saW5rKCk7XG4gICAgfSxcblxuICAgIGZ1bmN0aW9uIGluaXRDbHMoKSB7XG4gICAgICAvLyBUZW1wbGF0ZSBtZXRob2QsIGNhbiBiZSBvdmVycmlkZW4gYnkgc3ViLWNsYXNzZXNcbiAgICAgIHRoaXMuYWRkQ2xhc3ModGhpcy5teUNsYXNzKCkpO1xuICAgIH0sXG5cbiAgICBmdW5jdGlvbiBsaW5rKCkge1xuICAgICAgLy8gVGVtcGxhdGUgbWV0aG9kLCBjYW4gYmUgb3ZlcnJpZGVuIGJ5IHN1Yi1jbGFzc2VzXG4gICAgICB0aGlzLmF0dHJTbG90KG51bGwsIHRoaXMub25LZXkgPyAnaW5wdXQnIDogbnVsbCkubGlua0Zyb20odGhpcy5kYXRhJCk7XG4gICAgfSxcblxuICAgIGZ1bmN0aW9uIHVwZGF0ZU1vZGVfKG1vZGUpIHtcbiAgICAgIC8vIFRPRE86IG1ha2Ugc3VyZSB0aGF0IERPTSBpcyB1cGRhdGVkIGlmIHZhbHVlcyBkb24ndCBjaGFuZ2VcbiAgICAgIHRoaXMuc2V0QXR0cmlidXRlKCdyZWFkb25seScsIG1vZGUgPT09IGZvYW0udTIuRGlzcGxheU1vZGUuUk8pO1xuICAgICAgdGhpcy5zZXRBdHRyaWJ1dGUoJ2Rpc2FibGVkJywgbW9kZSA9PT0gZm9hbS51Mi5EaXNwbGF5TW9kZS5ESVNBQkxFRCk7XG4gICAgfVxuICBdXG59KTtcbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE1IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmZvYW0uQ0xBU1Moe1xuICBwYWNrYWdlOiAnZm9hbS51Mi50YWcnLFxuICBuYW1lOiAnVGV4dEFyZWEnLFxuICBleHRlbmRzOiAnZm9hbS51Mi5WaWV3JyxcblxuICBwcm9wZXJ0aWVzOiBbXG4gICAgWyAnbm9kZU5hbWUnLCAndGV4dGFyZWEnIF0sXG4gICAge1xuICAgICAgY2xhc3M6ICdJbnQnLFxuICAgICAgbmFtZTogJ3Jvd3MnLFxuICAgICAgdmFsdWU6IDRcbiAgICB9LFxuICAgIHtcbiAgICAgIGNsYXNzOiAnSW50JyxcbiAgICAgIG5hbWU6ICdjb2xzJyxcbiAgICAgIHZhbHVlOiA2MFxuICAgIH0sXG4gICAge1xuICAgICAgY2xhc3M6ICdCb29sZWFuJyxcbiAgICAgIG5hbWU6ICdvbktleScsXG4gICAgICBhdHRyaWJ1dGU6IHRydWUsXG4gICAgICBkb2N1bWVudGF0aW9uOiAnV2hlbiB0cnVlLCAkJERPQ3tyZWY6XCIuZGF0YVwifSBpcyB1cGRhdGVkIG9uIGV2ZXJ5ICcgK1xuICAgICAgICAgICdrZXlzdHJva2UsIHJhdGhlciB0aGFuIG9uIGJsdXIuJyxcbiAgICB9LFxuICBdLFxuXG4gIG1ldGhvZHM6IFtcbiAgICBmdW5jdGlvbiBpbml0RSgpIHtcbiAgICAgIHRoaXMuU1VQRVIoKTtcbiAgICAgIHRoaXMuYWRkQ2xhc3ModGhpcy5teUNsYXNzKCkpO1xuICAgICAgdGhpcy5zdHlsZSh7J3doaXRlLXNwYWNlJzogJ3ByZSd9KTtcbiAgICAgIHRoaXMuYXR0cnMoe3Jvd3M6IHRoaXMucm93cywgY29sczogdGhpcy5jb2xzfSk7XG5cbiAgICAgIC8vIFRoaXMgaXMgcmVxdWlyZWQgYmVjYXVzZSB0ZXh0YXJlYSBhY2NlcHRzIHNldHRpbmcgdGhlICd2YWx1ZSdcbiAgICAgIC8vIGFmdGVyIGl0J3Mgb3V0cHV0LCBidXQgYmVmb3JlIHJlcXVpcmVzIG91dHB1dCB0byBiZSBiZXR3ZWVuXG4gICAgICAvLyB0aGUgdGFncyB3aGVuIGl0J3MgZmlyc3Qgb3V0cHV0LlxuICAgICAvLyB0aGlzLmFkZCgodGhpcy5kYXRhICsgJycpLnJlcGxhY2UoLzwvZywgJyZsdDsnKS5yZXBsYWNlKC8+L2csICcmZ3Q7JykpO1xuXG4gICAgICB0aGlzLmF0dHJTbG90KFxuICAgICAgICAndmFsdWUnLFxuICAgICAgICB0aGlzLm9uS2V5ID8gJ2lucHV0JyA6ICdjaGFuZ2UnKS5saW5rRnJvbSh0aGlzLmRhdGEkKTtcbiAgICB9LFxuXG4gICAgZnVuY3Rpb24gbG9hZCgpIHtcbiAgICAgIC8vIHZhbHVlIGNhbid0IGJlIHNldCBiZWZvcmUgb2JqZWN0IGlzIGNyZWF0ZWQsIHNvIHNldCB2YWx1ZVxuICAgICAgLy8gb25jZSBsb2FkZWRcbiAgICAgIHRoaXMuU1VQRVIoKTtcbiAgICAgIHRoaXMuYXR0cnMoe3ZhbHVlOiB0aGlzLmRhdGEgKyAnJ30pO1xuICAgIH0sXG5cbiAgICBmdW5jdGlvbiB1cGRhdGVNb2RlXyhtb2RlKSB7XG4gICAgICAvLyBUT0RPOiBtYWtlIHN1cmUgdGhhdCBET00gaXMgdXBkYXRlZCBpZiB2YWx1ZXMgZG9uJ3QgY2hhbmdlXG4gICAgICB0aGlzLnNldEF0dHJpYnV0ZSgncmVhZG9ubHknLCBtb2RlID09PSBmb2FtLnUyLkRpc3BsYXlNb2RlLlJPKTtcbiAgICAgIHRoaXMuc2V0QXR0cmlidXRlKCdkaXNhYmxlZCcsIG1vZGUgPT09IGZvYW0udTIuRGlzcGxheU1vZGUuRElTQUJMRUQpO1xuICAgIH1cbiAgXVxufSk7XG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNSBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5mb2FtLkNMQVNTKHtcbiAgcGFja2FnZTogJ2ZvYW0udTInLFxuICBuYW1lOiAnVGV4dEZpZWxkJyxcbiAgZXh0ZW5kczogJ2ZvYW0udTIudGFnLklucHV0JyxcblxuICBjc3M6IGBcbiAgICBpbnB1dFt0eXBlPVwic2VhcmNoXCJdIHsgLXdlYmtpdC1hcHBlYXJhbmNlOiB0ZXh0ZmllbGQgIWltcG9ydGFudDsgfVxuICAgIF46cmVhZC1vbmx5IHsgYm9yZGVyOiBub25lOyBiYWNrZ3JvdW5kOiByZ2JhKDAsMCwwLDApOyB9XG4gIGAsXG5cbiAgcHJvcGVydGllczogW1xuICAgIHtcbiAgICAgIGNsYXNzOiAnSW50JyxcbiAgICAgIG5hbWU6ICdkaXNwbGF5V2lkdGgnXG4gICAgfVxuICBdLFxuXG4gIG1ldGhvZHM6IFtcbiAgICBmdW5jdGlvbiBmcm9tUHJvcGVydHkocHJvcCkge1xuICAgICAgdGhpcy5TVVBFUihwcm9wKTtcblxuICAgICAgaWYgKCAhIHRoaXMuZGlzcGxheVdpZHRoICkge1xuICAgICAgICB0aGlzLnNpemUgPSB0aGlzLmRpc3BsYXlXaWR0aCA9IHByb3AuZGlzcGxheVdpZHRoO1xuICAgICAgfVxuXG4gICAgICBpZiAoIHByb3AudmlzaWJpbGl0eSApIHtcbiAgICAgICAgdGhpcy52aXNpYmlsaXR5ID0gcHJvcC52aXNpYmlsaXR5O1xuICAgICAgfVxuICAgIH1cbiAgXVxufSk7XG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNSBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5mb2FtLkNMQVNTKHtcbiAgcGFja2FnZTogJ2ZvYW0udTInLFxuICBuYW1lOiAnSW50VmlldycsXG4gIGV4dGVuZHM6ICdmb2FtLnUyLlRleHRGaWVsZCcsXG5cbiAgY3NzOiAnXjpyZWFkLW9ubHkgeyBib3JkZXI6IG5vbmU7IGJhY2tncm91bmQ6IHJnYmEoMCwwLDAsMCk7IH0nLFxuXG4gIHByb3BlcnRpZXM6IFtcbiAgICBbICd0eXBlJywgJ251bWJlcicgXSxcbiAgICB7IGNsYXNzOiAnSW50JywgbmFtZTogJ2RhdGEnIH0sXG4gICAgJ21pbicsXG4gICAgJ21heCdcbiAgXSxcblxuICBtZXRob2RzOiBbXG4gICAgZnVuY3Rpb24gaW5pdEUoKSB7XG4gICAgICB0aGlzLlNVUEVSKCk7XG4gICAgICBpZiAoIHRoaXMubWluICE9IHVuZGVmaW5lZCApIHRoaXMuc2V0QXR0cmlidXRlKCdtaW4nLCB0aGlzLm1pbik7XG4gICAgICBpZiAoIHRoaXMubWF4ICE9IHVuZGVmaW5lZCApIHRoaXMuc2V0QXR0cmlidXRlKCdtYXgnLCB0aGlzLm1heCk7XG4gICAgfSxcblxuICAgIGZ1bmN0aW9uIGxpbmsoKSB7XG4gICAgICB0aGlzLmF0dHJTbG90KG51bGwsIHRoaXMub25LZXkgPyAnaW5wdXQnIDogbnVsbCkubGlua0Zyb20odGhpcy5kYXRhJClcbiAgICB9LFxuXG4gICAgZnVuY3Rpb24gZnJvbVByb3BlcnR5KHApIHtcbiAgICAgIHRoaXMuU1VQRVIocCk7XG4gICAgICB0aGlzLm1pbiA9IHAubWluO1xuICAgICAgdGhpcy5tYXggPSBwLm1heDtcbiAgICB9XG4gIF1cbn0pO1xuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTUgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuZm9hbS5DTEFTUyh7XG4gIHBhY2thZ2U6ICdmb2FtLnUyJyxcbiAgbmFtZTogJ0Zsb2F0VmlldycsXG4gIGV4dGVuZHM6ICdmb2FtLnUyLlRleHRGaWVsZCcsXG5cbiAgZG9jdW1lbnRhdGlvbjogJ1ZpZXcgZm9yIGVkaXRpbmcgRmxvYXQgUHJvcGVydGllcy4nLFxuXG4gIGNzczogJ146cmVhZC1vbmx5IHsgYm9yZGVyOiBub25lOyBiYWNrZ3JvdW5kOiByZ2JhKDAsMCwwLDApOyB9JyxcbiAgIFxuICBwcm9wZXJ0aWVzOiBbXG4gICAgWyAndHlwZScsICdudW1iZXInIF0sXG4gICAgeyBjbGFzczogJ0Zsb2F0JywgbmFtZTogJ2RhdGEnIH0sXG4gICAgJ3ByZWNpc2lvbicsXG4gICAgJ21pbicsXG4gICAgJ21heCdcbiAgXSxcblxuICBtZXRob2RzOiBbXG4gICAgZnVuY3Rpb24gaW5pdEUoKSB7XG4gICAgICB0aGlzLlNVUEVSKCk7XG4gICAgICB0aGlzLmFkZENsYXNzKHRoaXMubXlDbGFzcygpKTtcbiAgICAgIGlmICggdGhpcy5taW4gIT0gdW5kZWZpbmVkICkgdGhpcy5zZXRBdHRyaWJ1dGUoJ21pbicsIHRoaXMubWluKTtcbiAgICAgIGlmICggdGhpcy5tYXggIT0gdW5kZWZpbmVkICkgdGhpcy5zZXRBdHRyaWJ1dGUoJ21heCcsIHRoaXMubWF4KTtcbiAgICB9LFxuXG4gICAgZnVuY3Rpb24gbGluaygpIHtcbiAgICAgIHRoaXMuYXR0clNsb3QobnVsbCwgdGhpcy5vbktleSA/ICdpbnB1dCcgOiBudWxsKS5yZWxhdGVGcm9tKFxuICAgICAgICAgIHRoaXMuZGF0YSQsXG4gICAgICAgICAgdGhpcy50ZXh0VG9EYXRhLmJpbmQodGhpcyksXG4gICAgICAgICAgdGhpcy5kYXRhVG9UZXh0LmJpbmQodGhpcykpO1xuICAgIH0sXG5cbiAgICBmdW5jdGlvbiBmcm9tUHJvcGVydHkocCkge1xuICAgICAgdGhpcy5TVVBFUihwKTtcblxuICAgICAgdGhpcy5wcmVjaXNpb24gPSBwLnByZWNpc2lvbjtcbiAgICAgIHRoaXMubWluICAgICAgID0gcC5taW47XG4gICAgICB0aGlzLm1heCAgICAgICA9IHAubWF4O1xuICAgIH0sXG5cbiAgICBmdW5jdGlvbiBmb3JtYXROdW1iZXIodmFsKSB7XG4gICAgICBpZiAoICEgdmFsICkgcmV0dXJuICcwJztcbiAgICAgIHZhbCA9IHZhbC50b0ZpeGVkKHRoaXMucHJlY2lzaW9uKTtcbiAgICAgIHZhciBpID0gdmFsLmxlbmd0aCAtIDE7XG4gICAgICBmb3IgKCA7IGkgPiAwICYmIHZhbC5jaGFyQXQoaSkgPT09ICcwJyA7IGktLSApIHt9XG4gICAgICByZXR1cm4gdmFsLnN1YnN0cmluZygwLCB2YWwuY2hhckF0KGkpID09PSAnLicgPyBpIDogaSArIDEpO1xuICAgIH0sXG5cbiAgICBmdW5jdGlvbiBkYXRhVG9UZXh0KHZhbCkge1xuICAgICAgcmV0dXJuIHRoaXMucHJlY2lzaW9uICE9PSB1bmRlZmluZWQgP1xuICAgICAgICB0aGlzLmZvcm1hdE51bWJlcih2YWwpIDpcbiAgICAgICAgJycgKyB2YWwgO1xuICAgIH0sXG5cbiAgICBmdW5jdGlvbiB0ZXh0VG9EYXRhKHRleHQpIHtcbiAgICAgIHJldHVybiBwYXJzZUZsb2F0KHRleHQpIHx8IDA7XG4gICAgfVxuICBdXG59KTtcbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IFRoZSBGT0FNIEF1dGhvcnMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqL1xuXG5mb2FtLkNMQVNTKHtcbiAgcGFja2FnZTogJ2ZvYW0udTInLFxuICBuYW1lOiAnQ3VycmVuY3lWaWV3JyxcbiAgZXh0ZW5kczogJ2ZvYW0udTIuRmxvYXRWaWV3JyxcblxuICBkb2N1bWVudGF0aW9uOiAnVmlldyBmb3IgZm9ybWF0dGluZyBjZW50cyBpbnRvIGRvbGxhcnMuJyxcblxuICBheGlvbXM6IFtcbiAgICBmb2FtLnUyLkNTUy5jcmVhdGUoe1xuICAgICAgY29kZTogJ146cmVhZC1vbmx5IHsgYm9yZGVyOiBub25lOyBiYWNrZ3JvdW5kOiByZ2JhKDAsMCwwLDApOyB9J1xuICAgIH0pXG4gIF0sXG5cbiAgcHJvcGVydGllczogW1xuICAgIFsncHJlY2lzaW9uJywgJzInXVxuICBdLFxuXG4gIG1ldGhvZHM6IFtcbiAgICBmdW5jdGlvbiBkYXRhVG9UZXh0KHZhbCkge1xuICAgICAgcmV0dXJuIHRoaXMuU1VQRVIodmFsIC8gMTAwKTtcbiAgICB9LFxuXG4gICAgZnVuY3Rpb24gdGV4dFRvRGF0YSh0ZXh0KSB7XG4gICAgICByZXR1cm4gdGhpcy5TVVBFUih0ZXh0KSAqIDEwMDtcbiAgICB9LFxuXG4gICAgZnVuY3Rpb24gZm9ybWF0TnVtYmVyKHZhbCkge1xuICAgICAgcmV0dXJuIHZhbC50b0ZpeGVkKDIpO1xuICAgIH1cbiAgXVxufSk7XG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNSBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5mb2FtLkNMQVNTKHtcbiAgcGFja2FnZTogJ2ZvYW0udTInLFxuICBuYW1lOiAnQ2hlY2tCb3gnLFxuICBleHRlbmRzOiAnZm9hbS51Mi50YWcuSW5wdXQnLFxuXG4gIGRvY3VtZW50YXRpb246ICdDaGVja2JveCBWaWV3LicsXG5cbiAgcHJvcGVydGllczogW1xuICAgIHsgXG4gICAgICBjbGFzczogJ0Jvb2xlYW4nLCBcbiAgICAgIG5hbWU6ICdkYXRhJyBcbiAgICB9LFxuICAgIHtcbiAgICAgIGNsYXNzOiAnQm9vbGVhbicsXG4gICAgICBuYW1lOiAnc2hvd0xhYmVsJyxcbiAgICAgIGZhY3Rvcnk6IGZ1bmN0aW9uKCkgeyByZXR1cm4gISF0aGlzLmxhYmVsIH0sXG4gICAgfSxcbiAgICB7IFxuICAgICAgY2xhc3M6ICdTdHJpbmcnLCBcbiAgICAgIG5hbWU6ICdsYWJlbCcgXG4gICAgfVxuICBdLFxuXG4gIG1ldGhvZHM6IFtcbiAgICBmdW5jdGlvbiBpbml0RSgpIHtcbiAgICAgIHRoaXMuU1VQRVIoKTtcbiAgICAgIHRoaXMuc2V0QXR0cmlidXRlKCd0eXBlJywgJ2NoZWNrYm94Jyk7XG5cbiAgICAgIGlmICggdGhpcy5zaG93TGFiZWwgKSB7IFxuICAgICAgICB0aGlzLnN0YXJ0KCdsYWJlbCcpXG4gICAgICAgICAgLmFkZENsYXNzKHRoaXMubXlDbGFzcygnbGFiZWwnKSlcbiAgICAgICAgICAuYWRkQ2xhc3ModGhpcy5teUNsYXNzKCdub3NlbGVjdCcpKVxuICAgICAgICAgIC5hZGQodGhpcy5sYWJlbCQpXG4gICAgICAgICAgLm9uKCdjbGljaycsIGZ1bmN0aW9uKCkgeyBcbiAgICAgICAgICAgIHRoaXMuZGF0YSA9ICF0aGlzLmRhdGE7IFxuICAgICAgICAgIH0uYmluZCh0aGlzKSlcbiAgICAgICAgLmVuZCgpO1xuICAgICAgfVxuICAgIH0sXG4gICAgZnVuY3Rpb24gdXBkYXRlTW9kZV8obW9kZSkge1xuICAgICAgdmFyIGRpc2FibGVkID0gbW9kZSA9PT0gZm9hbS51Mi5EaXNwbGF5TW9kZS5STyB8fFxuICAgICAgICAgICAgICAgICAgICAgbW9kZSA9PT0gZm9hbS51Mi5EaXNwbGF5TW9kZS5ESVNBQkxFRDtcbiAgICAgIHRoaXMuc2V0QXR0cmlidXRlKCdkaXNhYmxlZCcsIGRpc2FibGVkKTtcbiAgICB9LFxuICAgIGZ1bmN0aW9uIGxpbmsoKSB7XG4gICAgICB0aGlzLmRhdGEkLmxpbmtUbyh0aGlzLmF0dHJTbG90KCdjaGVja2VkJykpO1xuICAgIH1cbiAgXSxcblxuICBjc3M6IGBcbiAgICBeIHtcbiAgICAgIG1hcmdpbjogOHB4O1xuICAgICAgcGFkZGluZzogOHB4O1xuICAgIH1cblxuICAgIF5sYWJlbCB7XG4gICAgICBjb2xvcjogIzQ0NDtcbiAgICAgIGZsZXgtZ3JvdzogMTtcbiAgICAgIG1hcmdpbi1sZWZ0OiAxMnB4O1xuICAgICAgb3ZlcmZsb3c6IGhpZGRlbjtcbiAgICAgIHdoaXRlLXNwYWNlOiBub3dyYXA7XG4gICAgICBkaXNwbGF5OiBpbmxpbmU7XG4gICAgfVxuXG4gICAgXm5vc2VsZWN0IHtcbiAgICAgIC13ZWJraXQtdG91Y2gtY2FsbG91dDogbm9uZTtcbiAgICAgIC13ZWJraXQtdXNlci1zZWxlY3Q6IG5vbmU7XG4gICAgICAta2h0bWwtdXNlci1zZWxlY3Q6IG5vbmU7XG4gICAgICAtbW96LXVzZXItc2VsZWN0OiBub25lO1xuICAgICAgLW1zLXVzZXItc2VsZWN0OiBub25lO1xuICAgICAgdXNlci1zZWxlY3Q6IG5vbmU7XG4gICAgfVxuICBgXG59KTtcbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IFRoZSBGT0FNIEF1dGhvcnMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqL1xuXG5mb2FtLkNMQVNTKHtcbiAgcGFja2FnZTogJ2ZvYW0udTIubWQnLFxuICBuYW1lOiAnQ2hlY2tCb3gnLFxuICBleHRlbmRzOiAnZm9hbS51Mi5DaGVja0JveCcsXG5cbiAgYXhpb21zOiBbXG4gICAgZm9hbS51Mi5DU1MuY3JlYXRlKHtcbiAgICAgIGNvZGU6IGBcbiAgICAgICAgXiB7XG4gICAgICAgICAgcGFkZGluZzogMHB4ICFpbXBvcnRhbnQ7XG5cbiAgICAgICAgICAtd2Via2l0LWFwcGVhcmFuY2U6IG5vbmU7XG4gICAgICAgICAgYm9yZGVyLXJhZGl1czogMnB4O1xuICAgICAgICAgIGJvcmRlcjogc29saWQgMnB4ICM1YTVhNWE7XG4gICAgICAgICAgYm94LXNpemluZzogYm9yZGVyLWJveDtcbiAgICAgICAgICBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7XG4gICAgICAgICAgZmlsbDogcmdiYSgwLCAwLCAwLCAwKTtcblxuICAgICAgICAgIGhlaWdodDogMThweDtcbiAgICAgICAgICB3aWR0aDogMThweDtcblxuICAgICAgICAgIG9wYWNpdHk6IDE7XG5cbiAgICAgICAgICB0cmFuc2l0aW9uOiBiYWNrZ3JvdW5kLWNvbG9yIDE0MG1zLCBib3JkZXItY29sb3IgMTQwbXM7XG4gICAgICAgIH1cblxuICAgICAgICBeOmNoZWNrZWQge1xuICAgICAgICAgIGJhY2tncm91bmQtY29sb3I6ICMwNGE5ZjQ7XG4gICAgICAgICAgYm9yZGVyLWNvbG9yOiAjMDRhOWY0O1xuICAgICAgICAgIGZpbGw6IHdoaXRlO1xuICAgICAgICB9XG5cbiAgICAgICAgXjpmb2N1c3tcbiAgICAgICAgICBvdXRsaW5lOjA7XG4gICAgICAgIH1cblxuICAgICAgICBeOmNoZWNrZWQ6YWZ0ZXIge1xuICAgICAgICAgIGNvbnRlbnQ6IHVybChkYXRhOmltYWdlL3N2Zyt4bWwsJTNDc3ZnJTIwdmlld0JveCUzRCUyMjAlMjAwJTIwNDglMjA0OCUyMiUyMHhtbG5zJTNEJTIyaHR0cCUzQS8vd3d3LnczLm9yZy8yMDAwL3N2ZyUyMiUyMHdpZHRoJTNEJTIyMTUlMjIlMjBoZWlnaHQlM0QlMjIxNSUyMiUyMHZlcnNpb24lM0QlMjIxLjElMjIlM0UlMEElMjAlMjAlMjAlM0NwYXRoJTIwZmlsbCUzRCUyMndoaXRlJTIyJTIwc3Ryb2tlLXdpZHRoJTNEJTIyMyUyMiUyMGQlM0QlMjJNMTglMjAzMi4zNEw5LjY2JTIwMjRsLTIuODMlMjAyLjgzTDE4JTIwMzhsMjQtMjQtMi44My0yLjgzeiUyMi8lM0UlMEElM0Mvc3ZnJTNFKTtcbiAgICAgICAgfVxuXG4gICAgICAgIF5sYWJlbCB7XG4gICAgICAgICAgbWFyZ2luLXRvcDogOXB4O1xuICAgICAgICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICAgICAgfVxuICAgICAgYFxuICAgIH0pXG4gIF1cbn0pO1xuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTYgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuZm9hbS5DTEFTUyh7XG4gIHBhY2thZ2U6ICdmb2FtLnUyJyxcbiAgbmFtZTogJ0NpdGF0aW9uVmlldycsXG4gIGV4dGVuZHM6ICdmb2FtLnUyLkVsZW1lbnQnLFxuXG4gIGRvY3VtZW50YXRpb246ICdBIHNpbXBsZSBkZWZhdWx0IFZpZXcgdG8gZGlzcGxheSB0aGUgSUQgb2YgYW4gb2JqZWN0LicsXG5cbiAgcHJvcGVydGllczogW1xuICAgICdkYXRhJyxcbiAgICBbICdub2RlTmFtZScsICdzcGFuJyBdLFxuICBdLFxuXG4gIG1ldGhvZHM6IFtcbiAgIGZ1bmN0aW9uIGluaXRFKCkge1xuICAgICAgdGhpcy5TVVBFUigpO1xuICAgICAgdGhpcy5hZGQodGhpcy5kYXRhJC5kb3QoJ2lkJykpLmFkZCgnICcpO1xuICAgIH1cbiAgXVxufSk7XG5cbi8vICAgIFRPRE86IG5hbWUvbGFiZWwgZGV0ZWN0aW9uICovXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5mb2FtLkNMQVNTKHtcbiAgcGFja2FnZTogJ2ZvYW0udTInLFxuICBuYW1lOiAnUG9wdXBWaWV3JyxcbiAgZXh0ZW5kczogJ2ZvYW0udTIuRWxlbWVudCcsXG5cbiAgY3NzOiBgXG4gICAgXiB7XG4gICAgICBiYWNrZ3JvdW5kOiAjOTk5O1xuICAgICAgYm94LXNoYWRvdzogM3B4IDNweCA2cHggMCBncmF5O1xuICAgICAgY29sb3I6IHdoaXRlO1xuICAgICAgZm9udC1zaXplOiAxOHB4O1xuICAgICAgb3BhY2l0eTogMC45O1xuICAgICAgcG9zaXRpb246IGFic29sdXRlO1xuICAgICAgYm94LXNpemluZzogYm9yZGVyLWJveDtcbiAgICAgIHotaW5kZXg6IDk5OTtcbiAgICB9XG4gIGAsXG5cbiAgcHJvcGVydGllczogW1xuICAgICd4JyxcbiAgICAneScsXG4gICAgJ3dpZHRoJyxcbiAgICAnaGVpZ2h0JyxcbiAgICAnbWF4V2lkdGgnLFxuICAgICdtYXhIZWlnaHQnLFxuICAgICdwYWRkaW5nJ1xuICBdLFxuXG4gIG1ldGhvZHM6IFtcbiAgICBmdW5jdGlvbiBpbml0RSgpIHtcbiAgICAgIHZhciBzZWxmICAgICA9IHRoaXM7XG4gICAgICB2YXIgcGFyZW50ICAgPSB0aGlzLnBhcmVudE5vZGU7XG4gICAgICB2YXIgY2xvc2UgICAgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgc2VsZi5yZW1vdmUoKTtcbiAgICAgICAgYmcucmVtb3ZlKCk7XG4gICAgICB9O1xuXG4gICAgICBpZiAoICEgdGhpcy5wYWRkaW5nICkgdGhpcy5wYWRkaW5nID0gMjA7XG4gICAgICBpZiAoICEgdGhpcy55ICAgICAgICkgdGhpcy55ID0gKHBhcmVudC5lbCgpLmNsaWVudEhlaWdodCAtIHRoaXMuaGVpZ2h0KS8yO1xuICAgICAgaWYgKCAhIHRoaXMueCAgICAgICApIHRoaXMueCA9IChwYXJlbnQuZWwoKS5jbGllbnRXaWR0aCAgLSB0aGlzLndpZHRoICkvMjtcbiAgICAgIGlmICggdGhpcy53aWR0aCAgICAgKSB0aGlzLnN0eWxlKHt3aWR0aCAgICA6IHRoaXMud2lkdGggICAgICsgJ3B4J30pO1xuICAgICAgaWYgKCB0aGlzLmhlaWdodCAgICApIHRoaXMuc3R5bGUoe2hlaWdodCAgIDogdGhpcy5oZWlnaHQgICAgKyAncHgnfSk7XG4gICAgICBpZiAoIHRoaXMubWF4V2lkdGggICkgdGhpcy5zdHlsZSh7bWF4V2lkdGggOiB0aGlzLm1heFdpZHRoICArICdweCd9KTtcbiAgICAgIGlmICggdGhpcy5tYXhIZWlnaHQgKSB0aGlzLnN0eWxlKHttYXhIZWlnaHQ6IHRoaXMubWF4SGVpZ2h0ICsgJ3B4J30pO1xuXG4gICAgICAvLyBNYWtlIGEgZnVsbC1zY3JlZW4gdHJhbnNwYXJlbnQgYmFja2dyb3VuZCwgd2hpY2ggd2hlbiBjbGlja2VkLFxuICAgICAgLy8gY2xvc2VzIHRoaXMgUG9wdXBcbiAgICAgIHZhciBiZyA9IHRoaXMuRSgnZGl2JykuXG4gICAgICAgIHN0eWxlKHtcbiAgICAgICAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcbiAgICAgICAgICB3aWR0aDogJzEwMCUnLFxuICAgICAgICAgIGhlaWdodDogJzEwMCUnLFxuICAgICAgICAgIG9wYWNpdHk6IDAsXG4gICAgICAgICAgdG9wOiAwLFxuICAgICAgICAgIHpJbmRleDogOTk4XG4gICAgICAgIH0pLlxuICAgICAgICBvbignY2xpY2snLCBjbG9zZSkuXG4gICAgICAgIHdyaXRlKCk7XG5cbiAgICAgIHRoaXMuXG4gICAgICAgIGFkZENsYXNzKHRoaXMubXlDbGFzcygpKS5cbiAgICAgICAgc3R5bGUoe1xuICAgICAgICAgIHBhZGRpbmc6IHRoaXMucGFkZGluZyArICdweCcsXG4gICAgICAgICAgbGVmdDogICAgdGhpcy54ICsgJ3B4JyxcbiAgICAgICAgICB0b3A6ICAgICB0aGlzLnkgKyAncHgnXG4gICAgICAgIH0pLlxuICAgICAgICBvbnVubG9hZC5zdWIoY2xvc2UpO1xuXG4gICAgICBwYXJlbnQuc3R5bGUoe3Bvc2l0aW9uOiAncmVsYXRpdmUnfSk7XG4gICAgfVxuICBdXG59KTtcbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE1IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbi8vIFRPRE86IEFkZCBkYXRhbGlzdCBzdXBwb3J0LlxuXG5mb2FtLkNMQVNTKHtcbiAgcGFja2FnZTogJ2ZvYW0udTInLFxuICBuYW1lOiAnRGF0ZVZpZXcnLFxuICBleHRlbmRzOiAnZm9hbS51Mi50YWcuSW5wdXQnLFxuXG4gIGRvY3VtZW50YXRpb246ICdWaWV3IGZvciBlZGl0aW5nIERhdGUgdmFsdWVzLicsXG5cbiAgY3NzOiAnXjpyZWFkLW9ubHkgeyBib3JkZXI6IG5vbmU7IGJhY2tncm91bmQ6IHJnYmEoMCwwLDAsMCk7IH0nLFxuXG4gIHByb3BlcnRpZXM6IFtcbiAgICBbICdwbGFjZWhvbGRlcicsICd5eXl5LW1tLWRkJyBdXG4gIF0sXG5cbiAgbWV0aG9kczogW1xuICAgIGZ1bmN0aW9uIGluaXRFKCkge1xuICAgICAgdGhpcy5TVVBFUigpO1xuICAgICAgdGhpcy5zZXRBdHRyaWJ1dGUoJ3R5cGUnLCAnZGF0ZScpO1xuICAgIH0sXG5cbiAgICBmdW5jdGlvbiBsaW5rKCkge1xuICAgICAgdGhpcy5kYXRhJC5yZWxhdGVUbyhcbiAgICAgICAgICB0aGlzLmF0dHJTbG90KG51bGwsIHRoaXMub25LZXkgPyAnaW5wdXQnIDogbnVsbCksXG4gICAgICAgICAgZnVuY3Rpb24oZGF0ZSkge1xuICAgICAgICAgICAgcmV0dXJuIGRhdGUgPyBkYXRlLnRvSVNPU3RyaW5nKCkuc3Vic3RyaW5nKDAsMTApIDogZGF0ZTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IERhdGUodmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgICk7XG4gICAgfVxuICBdXG59KTtcbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbi8vIFRPRE86IEFkZCBkYXRhbGlzdCBzdXBwb3J0LlxuXG5mb2FtLkNMQVNTKHtcbiAgcGFja2FnZTogJ2ZvYW0udTInLFxuICBuYW1lOiAnRGF0ZVRpbWVWaWV3JyxcbiAgZXh0ZW5kczogJ2ZvYW0udTIudGFnLklucHV0JyxcblxuICBkb2N1bWVudGF0aW9uOiAnVmlldyBmb3IgZWRpdGluZyBEYXRlVGltZSB2YWx1ZXMuJyxcblxuICBtZXRob2RzOiBbXG4gICAgZnVuY3Rpb24gaW5pdEUoKSB7XG4gICAgICB0aGlzLlNVUEVSKCk7XG4gICAgICB0aGlzLnNldEF0dHJpYnV0ZSgndHlwZScsICdkYXRldGltZS1sb2NhbCcpO1xuICAgIH0sXG5cbiAgICBmdW5jdGlvbiBsaW5rKCkge1xuICAgICAgdGhpcy5kYXRhJC5yZWxhdGVUbyhcbiAgICAgICAgICB0aGlzLmF0dHJTbG90KG51bGwsIHRoaXMub25LZXkgPyAnaW5wdXQnIDogbnVsbCksXG4gICAgICAgICAgZnVuY3Rpb24oZGF0ZSkge1xuICAgICAgICAgICAgcmV0dXJuIGRhdGUgPyBkYXRlLnRvSVNPU3RyaW5nKCkuc3Vic3RyaW5nKDAsMTYpIDogZGF0ZTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IERhdGUodmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgICk7XG4gICAgfVxuICBdXG59KTtcbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE1IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmZvYW0uQ0xBU1Moe1xuICBwYWNrYWdlOiAnZm9hbS51MicsXG4gIG5hbWU6ICdSYW5nZVZpZXcnLFxuICBleHRlbmRzOiAnZm9hbS51Mi50YWcuSW5wdXQnLFxuXG4gIHByb3BlcnRpZXM6IFtcbiAgICBbICd0eXBlJywgJ3JhbmdlJyBdLFxuICAgIFsgJ3N0ZXAnLCAwIF0sXG4gICAgWyAnbWluVmFsdWUnLCAwIF0sXG4gICAgWyAnbWF4VmFsdWUnLCAxMDAgXVxuICBdLFxuXG4gIG1ldGhvZHM6IFtcbiAgICBmdW5jdGlvbiBpbml0RSgpIHtcbiAgICAgIHRoaXMuU1VQRVIoKTtcbiAgICAgIGlmICggdGhpcy5zdGVwICkgdGhpcy5hdHRycyh7c3RlcDogdGhpcy5zdGVwfSk7XG4gICAgICB0aGlzLmF0dHJzKHttaW46IHRoaXMubWluVmFsdWUsIG1heDogdGhpcy5tYXhWYWx1ZSR9KTtcbiAgICB9XG4gIF1cbn0pO1xuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTUgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuLy8gVE9ETzogZG9jXG5mb2FtLkNMQVNTKHtcbiAgcGFja2FnZTogJ2ZvYW0udTInLFxuICBuYW1lOiAnUmVhZFdyaXRlVmlldycsXG4gIGV4dGVuZHM6ICdmb2FtLnUyLlZpZXcnLFxuXG4gIHJlcXVpcmVzOiBbICdmb2FtLnUyLnRhZy5JbnB1dCcgXSxcblxuICBtZXRob2RzOiBbXG4gICAgZnVuY3Rpb24gaW5pdEUoKSB7XG4gICAgICAvLyBEb24ndCBjcmVhdGUgUmVhZFZpZXcgaWYgbm8gZGF0YSAoc2F2ZXMgbWVtb3J5IGFuZCBzdGFydHVwIHRpbWUpLlxuICAgICAgaWYgKCB0aGlzLmlzTG9hZGVkKCkgKSB7XG4gICAgICAgIHRoaXMuaW5pdFJlYWRWaWV3KCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmxpc3RlbkZvckxvYWQoKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLy8gVGVtcGxhdGUgTWV0aG9kc1xuXG4gICAgZnVuY3Rpb24gaXNMb2FkZWQoKSB7XG4gICAgICAvKiogUmV0dXJuIHRydWUgaWZmIGRhdGEgaXMgYXZhaWxhYmxlIGZvciB0aGlzIHZpZXcuICoqL1xuICAgICAgcmV0dXJuIHRoaXMuZGF0YTtcbiAgICB9LFxuXG4gICAgZnVuY3Rpb24gbGlzdGVuRm9yTG9hZCgpIHtcbiAgICAgIHRoaXMuZGF0YSQuc3ViKHRoaXMub25EYXRhTG9hZCk7XG4gICAgfSxcblxuICAgIGZ1bmN0aW9uIHRvUmVhZEUoKSB7XG4gICAgICByZXR1cm4gdGhpcy5FKCdzcGFuJykuYWRkKHRoaXMuZGF0YSQpO1xuICAgIH0sXG5cbiAgICBmdW5jdGlvbiB0b1dyaXRlRSgpIHtcbiAgICAgIHRoaXMuZGF0YSQuc3ViKHRoaXMub25EYXRhTG9hZCk7XG4gICAgICByZXR1cm4gdGhpcy5JbnB1dC5jcmVhdGUoe2RhdGEkOiB0aGlzLmRhdGEkfSk7XG4gICAgfVxuICBdLFxuXG4gIGxpc3RlbmVyczogW1xuICAgIGZ1bmN0aW9uIG9uRGF0YUxvYWQocykge1xuICAgICAgcy5kZXRhY2goKTtcbiAgICAgIHRoaXMuaW5pdFJlYWRWaWV3KCk7XG4gICAgfSxcblxuICAgIGZ1bmN0aW9uIGluaXRSZWFkVmlldygpIHtcbiAgICAgIHRoaXMucmVtb3ZlQWxsQ2hpbGRyZW4oKS5hZGQodGhpcy50b1JlYWRFKCkub24oJ2NsaWNrJywgdGhpcy5pbml0V3JpdGVWaWV3KSk7XG4gICAgfSxcblxuICAgIGZ1bmN0aW9uIGluaXRXcml0ZVZpZXcoKSB7XG4gICAgICB0aGlzLnJlbW92ZUFsbENoaWxkcmVuKCkuYWRkKHRoaXMudG9Xcml0ZUUoKS5vbignYmx1cicsIHRoaXMuaW5pdFJlYWRWaWV3KS5mb2N1cygpKTtcbiAgICB9XG4gIF1cbn0pO1xuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTYgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgTGljZW5zZSk7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKi9cblxuZm9hbS5DTEFTUyh7XG4gIHBhY2thZ2U6ICdmb2FtLnUyJyxcbiAgbmFtZTogJ0hUTUxWYWxpZGF0b3InLFxuICBleHRlbmRzOiAnZm9hbS51Mi5EZWZhdWx0VmFsaWRhdG9yJyxcblxuICBheGlvbXM6IFsgZm9hbS5wYXR0ZXJuLlNpbmdsZXRvbi5jcmVhdGUoKSBdLFxuXG4gIG1ldGhvZHM6IFtcbiAgICBmdW5jdGlvbiBzYW5pdGl6ZVRleHQodGV4dCkge1xuICAgICAgLy8gVE9ETzogdmFsaWRhdGUgdGV4dFxuICAgICAgcmV0dXJuIHRleHQ7XG4gICAgfVxuICBdXG59KTtcblxuXG4vLyBBbiBFbGVtZW50IHdoaWNoIGRvZXMgbm90IGVzY2FwZSBIVE1MIGNvbnRlbnRcbmZvYW0uQ0xBU1Moe1xuICBwYWNrYWdlOiAnZm9hbS51MicsXG4gIG5hbWU6ICdIVE1MRWxlbWVudCcsXG4gIGV4dGVuZHM6ICdmb2FtLnUyLkVsZW1lbnQnLFxuXG4gIGV4cG9ydHM6IFsgJ3ZhbGlkYXRvciBhcyBlbGVtZW50VmFsaWRhdG9yJyBdLFxuXG4gIHByb3BlcnRpZXM6IFtcbiAgICB7XG4gICAgICBjbGFzczogJ1Byb3h5JyxcbiAgICAgIG9mOiAnZm9hbS51Mi5EZWZhdWx0VmFsaWRhdG9yJyxcbiAgICAgIG5hbWU6ICd2YWxpZGF0b3InLFxuICAgICAgdmFsdWU6IGZvYW0udTIuSFRNTFZhbGlkYXRvci5jcmVhdGUoKVxuICAgIH1cbiAgXVxufSk7XG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBUaGUgRk9BTSBBdXRob3JzLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKi9cblxuZm9hbS5DTEFTUyh7XG4gIHBhY2thZ2U6ICdmb2FtLnUyLnRhZycsXG4gIG5hbWU6ICdTZWxlY3QnLFxuICBleHRlbmRzOiAnZm9hbS51Mi5WaWV3JyxcblxuICBjc3M6IGBcbiAgICBeOmRpc2FibGVkIHtcbiAgICAgIGFwcGVhcmFuY2U6IG5vbmU7XG4gICAgICAtbW96LWFwcGVhcmFuY2U6bm9uZTtcbiAgICAgIC13ZWJraXQtYXBwZWFyYW5jZTpub25lO1xuICAgICAgYm9yZGVyOiBub25lO1xuICAgICAgYmFja2dyb3VuZDogcmdiYSgwLDAsMCwwKTtcbiAgICAgIGNvbG9yOiBpbml0aWFsO1xuICAgIH1cbiAgYCxcblxuICBwcm9wZXJ0aWVzOiBbXG4gICAgWyAnbm9kZU5hbWUnLCAnc2VsZWN0JyBdLFxuICAgIHtcbiAgICAgIG5hbWU6ICdjaG9pY2VzJyxcbiAgICAgIGZhY3Rvcnk6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgICB9XG4gICAgfSxcbiAgICB7XG4gICAgICBuYW1lOiAncGxhY2Vob2xkZXInLFxuICAgICAgZmFjdG9yeTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgfSxcbiAgICAnc2l6ZSdcbiAgXSxcblxuICBtZXRob2RzOiBbXG4gICAgZnVuY3Rpb24gaW5pdEUoKSB7XG4gICAgICB0aGlzLlNVUEVSKCk7XG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICAgIHRoaXNcbiAgICAgICAgLmFkZENsYXNzKHRoaXMubXlDbGFzcygpKVxuICAgICAgICAuYXR0cnMoe3NpemU6IHRoaXMuc2l6ZSR9KVxuICAgICAgICAuYXR0clNsb3QoKS5saW5rRnJvbSh0aGlzLmRhdGEkKTtcblxuICAgICAgdGhpcy5zZXRDaGlsZHJlbih0aGlzLnNsb3QoZnVuY3Rpb24oY2hvaWNlcywgcGxhY2Vob2xkZXIpIHtcbiAgICAgICAgdmFyIGNzID0gW107XG5cbiAgICAgICAgaWYgKCBwbGFjZWhvbGRlciApIHtcbiAgICAgICAgICBjcy5wdXNoKHNlbGYuRSgnb3B0aW9uJykuYXR0cnMoe1xuICAgICAgICAgICAgdmFsdWU6IC0xLFxuICAgICAgICAgICAgc2VsZWN0ZWQ6IHNlbGYuZGF0YSA9PSAtMSA/IHRydWUgOiB1bmRlZmluZWRcbiAgICAgICAgICB9KS5hZGQoc2VsZi5wbGFjZWhvbGRlcikpO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yICggdmFyIGkgPSAwIDsgaSA8IGNob2ljZXMubGVuZ3RoIDsgaSsrICkge1xuICAgICAgICAgIHZhciBjID0gY2hvaWNlc1tpXTtcbiAgICAgICAgICB2YXIgdmFsdWUgPSBjWzFdO1xuICAgICAgICAgIHZhciBlID0gc2VsZi5FKCdvcHRpb24nKS5hdHRycyh7XG4gICAgICAgICAgICB2YWx1ZTogaSxcbiAgICAgICAgICAgIHNlbGVjdGVkOiBzZWxmLmRhdGEgPT09IGkgPyB0cnVlIDogdW5kZWZpbmVkXG4gICAgICAgICAgfSkuYWRkKHZhbHVlKTtcblxuICAgICAgICAgIGlmICggdmFsdWUuaW5kZXhPZignICAnKSAhPSAtMSApIHtcbiAgICAgICAgICAgIC8vIEhhY2sgdG8gZGlzcGxheSBzcGFjZXMgYXMgbmJzcCdzXG4gICAgICAgICAgICBlLm9ubG9hZC5zdWIoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgIGUuZWwoKS5pbm5lckhUTUwgPSB2YWx1ZS5yZXBsYWNlKC8gL2csICcmbmJzcDsnKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNzLnB1c2goZSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY3M7XG4gICAgICB9KSk7XG4gICAgfSxcblxuICAgIGZ1bmN0aW9uIHVwZGF0ZU1vZGVfKG1vZGUpIHtcbiAgICAgIHRoaXMuc2V0QXR0cmlidXRlKFxuICAgICAgICAnZGlzYWJsZWQnLFxuICAgICAgICBtb2RlID09PSBmb2FtLnUyLkRpc3BsYXlNb2RlLkRJU0FCTEVEIHx8IG1vZGUgPT09IGZvYW0udTIuRGlzcGxheU1vZGUuUk8pO1xuICAgIH1cbiAgXVxufSk7XG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNSBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG4vLyBUT0RPOiBkb24ndCBpbnN0YW50aWF0ZSB0YWJzIHVudGlsIHZpZXdlZFxuXG5mb2FtLkNMQVNTKHtcbiAgcGFja2FnZTogJ2ZvYW0udTInLFxuICBuYW1lOiAnVGFiJyxcbiAgZXh0ZW5kczogJ2ZvYW0udTIuRWxlbWVudCcsXG5cbiAgcHJvcGVydGllczogW1xuICAgIHsgY2xhc3M6ICdTdHJpbmcnLCAgbmFtZTogJ2xhYmVsJyB9LFxuICAgIHsgY2xhc3M6ICdCb29sZWFuJywgbmFtZTogJ3NlbGVjdGVkJyB9XG4gIF1cbn0pO1xuXG5cbmZvYW0uQ0xBU1Moe1xuICBwYWNrYWdlOiAnZm9hbS51MicsXG4gIG5hbWU6ICdUYWJzJyxcbiAgZXh0ZW5kczogJ2ZvYW0udTIuRWxlbWVudCcsXG5cbiAgcmVxdWlyZXM6IFsgJ2ZvYW0udTIuVGFiJyBdLFxuXG4gIGNzczogYFxuICAgIF4ge1xuICAgICAgZGlzcGxheTogYmxvY2s7XG4gICAgfVxuICAgIF50YWJSb3cgeyBoZWlnaHQ6IDM3cHg7IH1cbiAgICBedGFiIHtcbiAgICAgIGJhY2tncm91bmQ6IGxpZ2h0Z3JheTtcbiAgICAgIGJvcmRlci1ib3R0b206IG5vbmU7XG4gICAgICBib3JkZXItdG9wOiAxcHggc29saWQgYmxhY2s7XG4gICAgICBib3JkZXItbGVmdDogMXB4IHNvbGlkIGJsYWNrO1xuICAgICAgYm9yZGVyLXJpZ2h0OiAxcHggc29saWQgYmxhY2s7XG4gICAgICBib3JkZXItdG9wLXJpZ2h0LXJhZGl1czogNHB4O1xuICAgICAgYm9yZGVyLXRvcC1sZWZ0LXJhZGl1czogNHB4O1xuICAgICAgZmxvYXQ6IGxlZnQ7XG4gICAgICBwYWRkaW5nOiA2cHg7XG4gICAgfVxuICAgIF50YWIuc2VsZWN0ZWQge1xuICAgICAgYmFja2dyb3VuZDogd2hpdGU7XG4gICAgICBwb3NpdGlvbjogcmVsYXRpdmU7XG4gICAgICB6LWluZGV4OiAxO1xuICAgIH1cbiAgICBeY29udGVudCB7XG4gICAgICBiYWNrZ3JvdW5kOiB3aGl0ZTtcbiAgICAgIGJvcmRlcjogMXB4IHNvbGlkIGJsYWNrO1xuICAgICAgYm94LXNoYWRvdzogM3B4IDNweCA2cHggMCBncmF5O1xuICAgICAgbGVmdDogLTRweDtcbiAgICAgIG1hcmdpbjogNHB4O1xuICAgICAgcGFkZGluZzogMDtcbiAgICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcbiAgICAgIHRvcDogLTEzcHg7XG4gICAgfVxuICBgLFxuXG4gIHByb3BlcnRpZXM6IFtcbiAgICAvKiBub3QgdXNlZFxuICAgIHtcbiAgICAgIG5hbWU6ICd0YWJzJyxcbiAgICAgIGZhY3Rvcnk6IGZ1bmN0aW9uKCkgeyByZXR1cm4gW107IH1cbiAgICB9LFxuICAgICovXG4gICAge1xuICAgICAgbmFtZTogJ3NlbGVjdGVkJyxcbiAgICAgIHBvc3RTZXQ6IGZ1bmN0aW9uKG8sIG4pIHtcbiAgICAgICAgaWYgKCBvICkgby5zZWxlY3RlZCA9IGZhbHNlO1xuICAgICAgICBuLnNlbGVjdGVkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9LFxuICAgICd0YWJSb3cnXG4gIF0sXG5cbiAgbWV0aG9kczogW1xuICAgIGZ1bmN0aW9uIGluaXQoKSB7XG4gICAgICB0aGlzLlxuICAgICAgICBhZGRDbGFzcyh0aGlzLm15Q2xhc3MoKSkuXG4gICAgICAgIHN0YXJ0KCdkaXYnLCBudWxsLCB0aGlzLnRhYlJvdyQpLlxuICAgICAgICAgIGFkZENsYXNzKHRoaXMubXlDbGFzcygndGFiUm93JykpLlxuICAgICAgICBlbmQoKS5cbiAgICAgICAgc3RhcnQoJ2RpdicsIG51bGwsIHRoaXMuY29udGVudCQpLlxuICAgICAgICAgIGFkZENsYXNzKHRoaXMubXlDbGFzcygnY29udGVudCcpKS5cbiAgICAgICAgZW5kKCk7XG4gICAgfSxcblxuICAgIGZ1bmN0aW9uIGFkZCh0YWIpIHtcbiAgICAgIGlmICggdGhpcy5UYWIuaXNJbnN0YW5jZSh0YWIpICkge1xuXG4gICAgICAgIGlmICggISB0aGlzLnNlbGVjdGVkICkgdGhpcy5zZWxlY3RlZCA9IHRhYjtcblxuICAgICAgICB0aGlzLnRhYlJvdy5zdGFydCgnc3BhbicpLlxuICAgICAgICAgIGFkZENsYXNzKHRoaXMubXlDbGFzcygndGFiJykpLlxuICAgICAgICAgIGVuYWJsZUNsYXNzKCdzZWxlY3RlZCcsIHRhYi5zZWxlY3RlZCQpLlxuICAgICAgICAgIG9uKCdjbGljaycsIGZ1bmN0aW9uKCkgeyB0aGlzLnNlbGVjdGVkID0gdGFiOyB9LmJpbmQodGhpcykpLlxuICAgICAgICAgIGFkZCh0YWIubGFiZWwpLlxuICAgICAgICBlbmQoKTtcblxuICAgICAgICB0YWIuc2hvd24kID0gdGFiLnNlbGVjdGVkJDtcbiAgICAgIH1cblxuICAgICAgdGhpcy5TVVBFUih0YWIpO1xuICAgIH1cbiAgXVxufSk7XG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxOCBUaGUgRk9BTSBBdXRob3JzLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKi9cblxuZm9hbS5DTEFTUyh7XG4gIHBhY2thZ2U6ICdmb2FtLnUyJyxcbiAgbmFtZTogJ1RpbWVWaWV3JyxcbiAgZXh0ZW5kczogJ2ZvYW0udTIudGFnLklucHV0JyxcblxuICBkb2N1bWVudGF0aW9uOiAnVmlldyBmb3IgZWRpdGluZyBUaW1lIHZhbHVlcy4nLFxuXG4gIG1ldGhvZHM6IFtcbiAgICBmdW5jdGlvbiBpbml0RSgpIHtcbiAgICAgIHRoaXMuU1VQRVIoKTtcbiAgICAgIHRoaXMuc2V0QXR0cmlidXRlKCd0eXBlJywgJ3RpbWUnKTtcbiAgICB9XG4gIF1cbn0pOy8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IFRoZSBGT0FNIEF1dGhvcnMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqL1xuXG5mb2FtLklOVEVSRkFDRSh7XG4gIHBhY2thZ2U6ICdmb2FtLnUyLmhpc3RvcnknLFxuICBuYW1lOiAnSGlzdG9yeUl0ZW1WaWV3JyxcbiAgZXh0ZW5kczogJ2ZvYW0udTIuVmlldycsXG5cbiAgZG9jdW1lbnRhdGlvbjogJ1ZpZXcgZGlzcGxheWluZyBoaXN0b3J5IGl0ZW0nLFxuXG4gIG1ldGhvZHM6IFtcbiAgICBmdW5jdGlvbiBvdXRwdXRSZWNvcmQocGFyZW50VmlldywgcmVjb3JkKSB7fVxuICBdXG59KTtcbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IFRoZSBGT0FNIEF1dGhvcnMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqL1xuXG5mb2FtLkNMQVNTKHtcbiAgcGFja2FnZTogJ2ZvYW0udTIuaGlzdG9yeScsXG4gIG5hbWU6ICdIaXN0b3J5VmlldycsXG4gIGV4dGVuZHM6ICdmb2FtLnUyLlZpZXcnLFxuICByZXF1aXJlczogWyAnZm9hbS51Mi5oaXN0b3J5Lkhpc3RvcnlJdGVtVmlldycgXSxcblxuICBkb2N1bWVudGF0aW9uOiAnVmlldyBkaXNwbGF5aW5nIGhpc3RvcnknLFxuXG4gIGNzczogYFxuICAgIF4ge1xuICAgICAgaGVpZ2h0OiAzNzBweDtcbiAgICAgIGJhY2tncm91bmQ6IHdoaXRlO1xuICAgICAgcG9zaXRpb246IHJlbGF0aXZlO1xuICAgICAgdmVydGljYWwtYWxpZ246IHRvcDtcbiAgICAgIGJvcmRlci1yYWRpdXM6IDJweDtcbiAgICAgIG92ZXJmbG93OiBhdXRvO1xuICAgICAgZm9udC1zaXplOiAxMnB4O1xuICAgICAgcGFkZGluZy1sZWZ0OiAyMHB4O1xuICAgICAgcGFkZGluZy1yaWdodDogMjBweDtcbiAgICAgIHotaW5kZXg6IDA7XG4gICAgfVxuICAgIF4gaDIge1xuICAgICAgaGVpZ2h0OiAyMHB4O1xuICAgICAgb3BhY2l0eTogMC42O1xuICAgICAgZm9udC1mYW1pbHk6IFJvYm90bztcbiAgICAgIGZvbnQtc2l6ZTogMjBweDtcbiAgICAgIGZvbnQtd2VpZ2h0OiAzMDA7XG4gICAgICBmb250LXN0eWxlOiBub3JtYWw7XG4gICAgICBmb250LXN0cmV0Y2g6IG5vcm1hbDtcbiAgICAgIGxpbmUtaGVpZ2h0OiAxO1xuICAgICAgbGV0dGVyLXNwYWNpbmc6IDAuM3B4O1xuICAgICAgdGV4dC1hbGlnbjogbGVmdDtcbiAgICAgIGNvbG9yOiAjMDkzNjQ5O1xuICAgIH1cbiAgICBeIC50aW1lbGluZVJlY29yZCB7XG4gICAgICBwb3NpdGlvbjogcmVsYXRpdmU7XG4gICAgfVxuICAgIF4gLnRpbWVsaW5lIHtcbiAgICAgIHdpZHRoOiAycHg7XG4gICAgICBoZWlnaHQ6IDEwMCU7XG4gICAgICBiYWNrZ3JvdW5kOiByZ2JhKDE2NCwgMTc5LCAxODQsIDAuMyk7XG4gICAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgICBsZWZ0OiAyM3B4O1xuICAgICAgdG9wOiA1cHg7XG4gICAgICB6LWluZGV4OiAtMTtcbiAgICAgIG1hcmdpbi1ib3R0b206IDIwcHg7XG4gICAgICBjb250ZW50OiAnJztcbiAgICB9XG4gIGAsXG5cbiAgcHJvcGVydGllczogW1xuICAgICdkYXRhJyxcbiAgICAnaGlzdG9yeUl0ZW1WaWV3JyxcbiAgICB7IGNsYXNzOiAnU3RyaW5nJywgbmFtZTogJ3RpdGxlJywgdmFsdWU6ICdIaXN0b3J5JyB9XG4gIF0sXG5cbiAgbWV0aG9kczogW1xuICAgIGZ1bmN0aW9uIGluaXRFKCkge1xuICAgICAgdmFyIHZpZXcgPSB0aGlzO1xuXG4gICAgICB0aGlzXG4gICAgICAgIC5hZGRDbGFzcyh0aGlzLm15Q2xhc3MoKSlcbiAgICAgICAgLnN0YXJ0KCdoMicpLmFkZCh0aGlzLnRpdGxlKS5lbmQoKVxuICAgICAgICAuY2FsbChmdW5jdGlvbiBvdXRwdXRSZWNvcmRzKCkge1xuICAgICAgICAgIC8vIEdldHMgcmVjb3JkcyBmcm9tIERBT1xuICAgICAgICAgIHZpZXcuZGF0YS5zZWxlY3QoKS50aGVuKGZ1bmN0aW9uKHJlY29yZHMpIHtcbiAgICAgICAgICAgIC8vIFJldmVyc2VzIHJlY29yZHMgYXJyYXkgZm9yIGNocm9ub2xvZ2ljYWwgb3V0cHV0XG4gICAgICAgICAgICB2aWV3LmZvckVhY2gocmVjb3Jkcy5hcnJheS5yZXZlcnNlKCksIGZ1bmN0aW9uKHJlY29yZCkge1xuICAgICAgICAgICAgICB2aWV3LnN0YXJ0KCdkaXYnKVxuICAgICAgICAgICAgICAgIC5hZGRDbGFzcygndGltZWxpbmVSZWNvcmQnKVxuICAgICAgICAgICAgICAgIC5zdGFydCgnZGl2JykuYWRkQ2xhc3MoJ3RpbWVsaW5lJykuZW5kKClcbiAgICAgICAgICAgICAgICAuY2FsbChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgIHZpZXcuaGlzdG9yeUl0ZW1WaWV3Lm91dHB1dFJlY29yZCh0aGlzLCByZWNvcmQpXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgLmVuZCgpO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICB9KVxuICAgICAgICB9KTtcbiAgICB9XG4gIF1cbn0pO1xuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgVGhlIEZPQU0gQXV0aG9ycy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICovXG5cbmZvYW0uQ0xBU1Moe1xuICBwYWNrYWdlOiAnZm9hbS51Mi52aWV3JyxcbiAgbmFtZTogJ0ZPYmplY3RWaWV3JyxcbiAgZXh0ZW5kczogJ2ZvYW0udTIuQ29udHJvbGxlcicsXG5cbiAgZG9jdW1lbnRhdGlvbjogJ1ZpZXcgZm9yIGVkaXRpbmcgRk9iamVjdHMuJyxcblxuICAvLyBjc3M6ICdeOnJlYWQtb25seSB7IGJvcmRlcjogbm9uZTsgYmFja2dyb3VuZDogcmdiYSgwLDAsMCwwKTsgfSdcblxuICBwcm9wZXJ0aWVzOiBbXG4gICAge1xuICAgICAgY2xhc3M6ICdTdHJpbmcnLFxuICAgICAgbmFtZTogJ29iamVjdENsYXNzJyxcbiAgICAgIGRpc3BsYXlXaWR0aDogNzAsXG4gICAgICBwb3N0U2V0OiBmdW5jdGlvbihvbGRWYWx1ZSwgbmV3VmFsdWUpIHtcbiAgICAgICAgaWYgKCBuZXdWYWx1ZSAhPT0gb2xkVmFsdWUgKSB7XG4gICAgICAgICAgdmFyIG0gPSB0aGlzLmxvb2t1cChuZXdWYWx1ZSwgdHJ1ZSk7XG4gICAgICAgICAgaWYgKCBtICkge1xuICAgICAgICAgICAgdGhpcy5kYXRhID0gbS5jcmVhdGUodGhpcy5kYXRhKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIHtcbiAgICAgIG5hbWU6ICdkYXRhJyxcbiAgICAgIHZpZXc6IHsgY2xhc3M6ICdmb2FtLnUyLkRldGFpbFZpZXcnIH0sXG4gICAgICBwb3N0U2V0OiBmdW5jdGlvbihfLCBkYXRhKSB7XG4gICAgICAgIGlmICggISBkYXRhICkge1xuICAgICAgICAgIHRoaXMub2JqZWN0Q2xhc3MgPSAnJztcbiAgICAgICAgfSBlbHNlIGlmICggZGF0YS5jbHNfLmlkICE9IHRoaXMub2JqZWN0Q2xhc3MgKSB7XG4gICAgICAgICAgdGhpcy5vYmplY3RDbGFzcyA9IGRhdGEuY2xzXy5pZDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgJ2Nob2ljZXMnXG4gIF0sXG5cbiAgbWV0aG9kczogW1xuICAgIGZ1bmN0aW9uIGluaXRFKCkge1xuICAgICAgaWYgKCB0aGlzLmNob2ljZXMgJiYgQXJyYXkuaXNBcnJheSh0aGlzLmNob2ljZXMpICkge1xuICAgICAgICB0aGlzLnRhZyh7Y2xhc3M6ICdmb2FtLnUyLnZpZXcuQ2hvaWNlVmlldycsIGNob2ljZXM6IHRoaXMuY2hvaWNlcywgZGF0YSQ6IHRoaXMub2JqZWN0Q2xhc3MkfSk7XG4gICAgICAgIC8qXG4gICAgICAgICAqIE5PVEU6XG4gICAgICAgICAqIERpc3BsYXlzIHRoZSBmaXJzdCBjaG9pY2Ugb24gaW5pdC5cbiAgICAgICAgICogQ29tcGVuc2F0ZXMgZm9yIGJvdGggdHlwZXMgb2YgY2hvaWNlcyBhY2NlcHRlZCBpbiBDaG9pY2VzVmlldy5cbiAgICAgICAgICovXG4gICAgICAgIGlmICggISB0aGlzLm9iamVjdENsYXNzICkge1xuICAgICAgICAgIGlmICggQXJyYXkuaXNBcnJheSh0aGlzLmNob2ljZXNbMF0pICkge1xuICAgICAgICAgICAgdGhpcy5vYmplY3RDbGFzcyA9IHRoaXMuY2hvaWNlc1swXVswXTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5vYmplY3RDbGFzcyA9IHRoaXMuY2hvaWNlc1swXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuYWRkKHRoaXMuT0JKRUNUX0NMQVNTKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuYWRkKHRoaXMuREFUQSk7XG4gICAgfVxuICBdXG59KTtcbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IFRoZSBGT0FNIEF1dGhvcnMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqL1xuXG5mb2FtLkNMQVNTKHtcbiAgcGFja2FnZTogJ2ZvYW0udTIudmlldycsXG4gIG5hbWU6ICdGT2JqZWN0QXJyYXlWaWV3JyxcbiAgZXh0ZW5kczogJ2ZvYW0udTIuVmlldycsXG5cbiAgZG9jdW1lbnRhdGlvbjogJ1ZpZXcgZm9yIGVkaXRpbmcgRk9iamVjdHMgaW5zaWRlIG9mIEZPYmplY3RBcnJheXMuJyxcblxuICByZXF1aXJlczogW1xuICAgICdmb2FtLmNvcmUuUHJvcGVydHknLFxuICAgICdmb2FtLnUyLkRldGFpbFByb3BlcnR5VmlldydcbiAgXSxcbiAgZXhwb3J0czogWyAnYXMgZGF0YScgXSxcblxuICBjc3M6IGBcbiAgICAucm12LWJ1dHRvbntcbiAgICAgIGJhY2tncm91bmQ6IHJnYmEoMjE2LCAzMCwgNSwgMC4zKTtcbiAgICAgIHdpZHRoOiAxMjVweDtcbiAgICAgIHRleHQtYWxpZ246IGNlbnRlcjtcbiAgICAgIGNvbG9yOiBpbmRpYW5yZWQ7XG4gICAgICBwYWRkaW5nOiAxMHB4O1xuICAgICAgZm9udC1zaXplOiAxMnB4O1xuICAgICAgYm9yZGVyLXJhZGl1czogM3B4O1xuICAgIH1cbiAgYCxcblxuICBwcm9wZXJ0aWVzOiBbXG4gICAge1xuICAgICAgY2xhc3M6ICdDbGFzcycsXG4gICAgICBuYW1lOiAnb2YnXG4gICAgfSxcbiAgICB7XG4gICAgICBuYW1lOiAnZGF0YSdcbiAgICB9LFxuICAgICdjaG9pY2VzJyxcbiAgICB7XG4gICAgICBuYW1lOiAnZGV0YWlsVmlldycsXG4gICAgICB2YWx1ZTogJ2ZvYW0udTIuRGV0YWlsVmlldydcbiAgICB9XG4gIF0sXG5cbiAgbWV0aG9kczogW1xuICAgIGZ1bmN0aW9uIGluaXRFKCkge1xuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgICB2YXIgY29udHJvbGxlck1vZGUgPSB0aGlzLm1vZGUgPT09IGZvYW0udTIuRGlzcGxheU1vZGUuUlcgJiZcbiAgICAgICAgICAodGhpcy5kYXRhLnZpc2liaWxpdHkgPT09IGZvYW0udTIuVmlzaWJpbGl0eS5SVyB8fFxuICAgICAgICAgICB0aGlzLmNvbnRyb2xsZXJNb2RlID09PSBmb2FtLnUyLkNvbnRyb2xsZXJNb2RlLkNSRUFURSkgP1xuICAgICAgICAgIHRoaXMuY29udHJvbGxlck1vZGUgOiBmb2FtLnUyLkNvbnRyb2xsZXJNb2RlLlZJRVc7XG4gICAgICB0aGlzLmFkZCh0aGlzLkFERF9JVEVNKS5hZGQodGhpcy5zbG90KGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuRSgpLmZvckVhY2goZGF0YSwgZnVuY3Rpb24obywgaW5kZXgpIHtcbiAgICAgICAgICB2YXIgdGFnID0gdGhpcy50YWcoe1xuICAgICAgICAgICAgY2xhc3M6IHNlbGYuZGV0YWlsVmlldyxcbiAgICAgICAgICAgIGNvbnRyb2xsZXJNb2RlOiBjb250cm9sbGVyTW9kZSxcbiAgICAgICAgICB9LCB7ZGF0YTogb30pO1xuICAgICAgICAgIGlmICggdGhpcy5tb2RlID09PSBmb2FtLnUyLkRpc3BsYXlNb2RlLlJXICkge1xuICAgICAgICAgICAgdGFnLnN0YXJ0KCkuYWRkKCdSZW1vdmUnKS5hZGRDbGFzcygncm12LWJ1dHRvbicpXG4gICAgICAgICAgICAgICAgLm9uKCdjbGljaycsIGZ1bmN0aW9uKCl7IHNlbGYucmVtb3ZlSXQoaW5kZXgpIH0pLmVuZCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9KSk7XG4gICAgfSxcblxuICAgIGZ1bmN0aW9uIGZyb21Qcm9wZXJ0eShwKSB7XG4gICAgICB0aGlzLlNVUEVSKHApO1xuICAgICAgY29uc29sZS5hc3NlcnQocC5vZiwgJ1Byb3BlcnR5IFwib2ZcIiByZXF1aXJlZCBmb3IgRk9iamVjdEFycmF5Vmlldy4nKTtcbiAgICAgIHRoaXMub2YgPSBwLm9mO1xuICAgIH1cbiAgXSxcblxuICBsaXN0ZW5lcnM6IFtcbiAgICBmdW5jdGlvbiByZW1vdmVJdChpbmRleCl7XG4gICAgICB2YXIgZGF0YSA9IGZvYW0uQXJyYXkuY2xvbmUodGhpcy5kYXRhKTtcbiAgICAgIGRhdGEucG9wKGluZGV4KTtcbiAgICAgIHRoaXMuZGF0YSA9IGRhdGE7XG4gICAgfVxuICBdLFxuXG4gIGFjdGlvbnM6IFtcbiAgICB7XG4gICAgICBuYW1lOiAnYWRkSXRlbScsXG4gICAgICBpc0F2YWlsYWJsZTogZnVuY3Rpb24obW9kZSkge1xuICAgICAgICByZXR1cm4gbW9kZSA9PT0gZm9hbS51Mi5EaXNwbGF5TW9kZS5SVztcbiAgICAgIH0sXG4gICAgICBjb2RlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGRhdGEgPSBmb2FtLkFycmF5LmNsb25lKHRoaXMuZGF0YSk7XG4gICAgICAgIGRhdGEucHVzaCh0aGlzLm9mLmNyZWF0ZShudWxsLCB0aGlzKSk7XG4gICAgICAgIHRoaXMuZGF0YSA9IGRhdGE7XG4gICAgICB9XG4gICAgfVxuICBdXG59KTtcbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmZvYW0uQ0xBU1Moe1xuICBwYWNrYWdlOiAnZm9hbS51Mi52aWV3JyxcbiAgbmFtZTogJ0Nob2ljZVZpZXcnLFxuICBleHRlbmRzOiAnZm9hbS51Mi5WaWV3JyxcblxuICBkb2N1bWVudGF0aW9uOiAnV3JhcHMgYSB0YWcgdGhhdCByZXByZXNlbnRzIGEgc2luZ3VsYXIgY2hvaWNlLiBUaGF0IGlzLCAnICtcbiAgICAgICd0aGlzIGNvbnRyb2xsZXIgc2hvd3MgdGhlIHVzZXIgYSBmaXhlZCwgcHJvYmFibHkgc21hbGwgc2V0IG9mICcgK1xuICAgICAgJ2Nob2ljZXMsIGFuZCB0aGUgdXNlciBwaWNrcyBvbmUuICcgK1xuICAgICAgJ1RoZSBjaG9pY2VzIGFyZSBbdmFsdWUsIGxhYmVsXSBwYWlycy4gdGhpcy5jaG9pY2UgaXMgdGhlIGN1cnJlbnQgJyArXG4gICAgICAncGFpciwgdGhpcy5kYXRhIHRoZSBjdXJyZW50IHZhbHVlLiB0aGlzLnRleHQgaXMgdGhlIGN1cnJlbnQgbGFiZWwsICcgK1xuICAgICAgJ3RoaXMubGFiZWwgaXMgdGhlIGxhYmVsIGZvciB0aGUgd2hvbGUgdmlldyAoZWcuIFwiTWVkYWwgQ29sb3JcIiwgbm90ICcgK1xuICAgICAgJ1wiR29sZFwiKS4gJyArXG4gICAgICAnVGhlIGNob2ljZXMgY2FuIGJlIHByb3ZpZGVkIGVpdGhlciBhcyBhbiBhcnJheSAodGhpcy5jaG9pY2VzKSBvciBhcyAnICtcbiAgICAgICdhIERBTyBwbHVzIHRoZSBmdW5jdGlvbiB0aGlzLm9ialRvQ2hvaWNlIHdoaWNoIHR1cm5zIG9iamVjdHMgZnJvbSB0aGUgJyArXG4gICAgICAnREFPIGludG8gW3ZhbHVlLCBsYWJlbF0gcGFpcnMuICcgK1xuICAgICAgJ3RoaXMuc2VsZWN0U3BlYyBpcyBhIFZpZXdTcGVjIGZvciB0aGUgaW5uZXIgdmlldy4gSXQgZGVmYXVsdHMgdG8gJyArXG4gICAgICAnZm9hbS51Mi50YWcuU2VsZWN0LicsXG5cbiAgcHJvcGVydGllczogW1xuICAgIHtcbiAgICAgIGNsYXNzOiAnU3RyaW5nJyxcbiAgICAgIG5hbWU6ICdsYWJlbCcsXG4gICAgICBkb2N1bWVudGF0aW9uOiAnVXNlci12aXNpYmxlIGxhYmVsLiBOb3QgdG8gYmUgY29uZnVzZWQgd2l0aCBcInRleHRcIiwgJyArXG4gICAgICAgICAgJ3doaWNoIGlzIHRoZSB1c2VyLXZpc2libGUgbmFtZSBvZiB0aGUgY3VycmVudGx5IHNlbGVjdGVkIGNob2ljZS4nXG4gICAgfSxcbiAgICB7XG4gICAgICBuYW1lOiAnY2hvaWNlJyxcbiAgICAgIC8vICdjaG9pY2UnIGlzIHRoZSBjYW5vbmljYWwgc291cmNlIG9mIHRydXRoLiBVcGRhdGluZyAnY2hvaWNlJyBpc1xuICAgICAgLy8gcmVzcG9uc2libGUgZm9yIHVwZGF0aW5nICdpbmRleCcsICdkYXRhJywgYW5kICd0ZXh0Jy4gVXBkYXRpbmcgYW55XG4gICAgICAvLyBvZiB0aG9zZSBwcm9wZXJ0aWVzIGNhbGxzIGJhY2sgdG8gdXBkYXRpbmcgJ2Nob2ljZScuXG4gICAgICBkb2N1bWVudGF0aW9uOiAnVGhlIGN1cnJlbnQgY2hvaWNlLiAoVGhhdCBpcywgYSBbdmFsdWUsIHRleHRdIHBhaXIuKScsXG4gICAgICBwb3N0U2V0OiBmdW5jdGlvbihvLCBuKSB7XG4gICAgICAgIGlmICggbyA9PT0gbiB8fCB0aGlzLmZlZWRiYWNrXyApIHJldHVybjtcblxuICAgICAgICB0aGlzLmZlZWRiYWNrXyA9IHRydWU7XG5cbiAgICAgICAgaWYgKCAhIG4gJiYgdGhpcy5wbGFjZWhvbGRlciApIHtcbiAgICAgICAgICB0aGlzLmRhdGEgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgdGhpcy50ZXh0ID0gdGhpcy5wbGFjZWhvbGRlcjtcbiAgICAgICAgICB0aGlzLmluZGV4ID0gLTE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5kYXRhICA9IG4gJiYgblswXTtcbiAgICAgICAgICB0aGlzLnRleHQgID0gbiAmJiBuWzFdO1xuICAgICAgICAgIHRoaXMuaW5kZXggPSB0aGlzLmZpbmRJbmRleE9mQ2hvaWNlKG4pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZmVlZGJhY2tfID0gZmFsc2U7XG4gICAgICB9XG4gICAgfSxcbiAgICB7XG4gICAgICBuYW1lOiAnY2hvaWNlcycsXG4gICAgICBkb2N1bWVudGF0aW9uOiAnQXJyYXkgb2YgW3ZhbHVlLCB0ZXh0XSBjaG9pY2VzLiBZb3UgY2FuIHBhc3MgaW4ganVzdCAnICtcbiAgICAgICAgICAnYW4gYXJyYXkgb2Ygc3RyaW5ncywgd2hpY2ggYXJlIGV4cGFuZGVkIHRvIFtzdHIsIHN0cl0uIENhbiBhbHNvICcgK1xuICAgICAgICAgICdiZSBhIG1hcCwgd2hpY2ggcmVzdWx0cyBpbiBba2V5LCB2YWx1ZV0gcGFpcnMgbGlzdGVkIGluICcgK1xuICAgICAgICAgICdlbnVtZXJhdGlvbiBvcmRlci4nLFxuICAgICAgZmFjdG9yeTogZnVuY3Rpb24oKSB7IHJldHVybiBbXTsgfSxcbiAgICAgIGFkYXB0OiBmdW5jdGlvbihvbGQsIG51KSB7XG4gICAgICAgIGlmICggdHlwZW9mIG51ID09PSAnb2JqZWN0JyAmJiAhIEFycmF5LmlzQXJyYXkobnUpICkge1xuICAgICAgICAgIHZhciBvdXQgPSBbXTtcbiAgICAgICAgICBmb3IgKCB2YXIga2V5IGluIG51ICkge1xuICAgICAgICAgICAgaWYgKCBudS5oYXNPd25Qcm9wZXJ0eShrZXkpICkgb3V0LnB1c2goWyBrZXksIG51W2tleV0gXSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBvdXQ7XG4gICAgICAgIH1cblxuICAgICAgICBudSA9IGZvYW0uQXJyYXkuY2xvbmUobnUpO1xuXG4gICAgICAgIC8vIFVwZ3JhZGUgc2luZ2xlIHZhbHVlcyB0byBbdmFsdWUsIHZhbHVlXS5cbiAgICAgICAgZm9yICggdmFyIGkgPSAwOyBpIDwgbnUubGVuZ3RoOyBpKysgKSB7XG4gICAgICAgICAgaWYgKCAhIEFycmF5LmlzQXJyYXkobnVbaV0pICkge1xuICAgICAgICAgICAgbnVbaV0gPSBbIG51W2ldLCBudVtpXSBdO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBudTtcbiAgICAgIH0sXG4gICAgfSxcbiAgICB7XG4gICAgICBjbGFzczogJ0ludCcsXG4gICAgICBuYW1lOiAnaW5kZXgnLFxuICAgICAgZG9jdW1lbnRhdGlvbjogJ1RoZSBpbmRleCBvZiB0aGUgY3VycmVudCBjaG9pY2UgaW4gdGhlIGNob2ljZXMgYXJyYXkuJyxcbiAgICAgIHRyYW5zaWVudDogdHJ1ZSxcbiAgICAgIHZhbHVlOiAtMSxcbiAgICAgIHByZVNldDogZnVuY3Rpb24ob2xkLCBudSkge1xuICAgICAgICBpZiAoIHRoaXMuY2hvaWNlcy5sZW5ndGggPT09IDAgJiYgdGhpcy5kYW8gKSByZXR1cm4gbnU7XG4gICAgICAgIGlmICggbnUgPCAwICYmIHRoaXMucGxhY2Vob2xkZXIgKSByZXR1cm4gbnU7XG4gICAgICAgIGlmICggbnUgPCAwIHx8IHRoaXMuY2hvaWNlcy5sZW5ndGggPT09IDAgKSByZXR1cm4gMDtcbiAgICAgICAgaWYgKCBudSA+PSB0aGlzLmNob2ljZXMubGVuZ3RoICkgcmV0dXJuIHRoaXMuY2hvaWNlcy5sZW5ndGggLSAxO1xuICAgICAgICByZXR1cm4gbnU7XG4gICAgICB9LFxuICAgICAgcG9zdFNldDogZnVuY3Rpb24obywgbikge1xuICAgICAgICBpZiAoIG8gIT09IG4gKSB0aGlzLmNob2ljZSA9IG4gPT09IC0xID8gbnVsbCA6IHRoaXMuY2hvaWNlc1tuXTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHtcbiAgICAgIGNsYXNzOiAnU3RyaW5nJyxcbiAgICAgIG5hbWU6ICdwbGFjZWhvbGRlcicsXG4gICAgICBmYWN0b3J5OiBmdW5jdGlvbigpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfSxcbiAgICAgIGRvY3VtZW50YXRpb246ICdXaGVuIHByb3ZpZGVkIHRoZSBwbGFjZWhvbGRlciB3aWxsIGJlIHByZXBlbmRlZCB0byB0aGUgc2VsZWN0aW9uIGxpc3QsIGFuZCBzZWxlY3RlZCBpZiB0aGUgY2hvaWNlcyBhcnJheSBpcyBlbXB0eSBvciBubyBjaG9pY2UgaW4gdGhlIGNob2ljZXMgYXJyYXkgaXMgc2VsZWN0ZWQuJ1xuICAgIH0sXG4gICAge1xuICAgICAgY2xhc3M6ICdGdW5jdGlvbicsXG4gICAgICBuYW1lOiAnb2JqVG9DaG9pY2UnLFxuICAgICAgZG9jdW1lbnRhdGlvbjogJ0EgZnVuY3Rpb24gd2hpY2ggYWRhcHRzIGFuIG9iamVjdCBmcm9tIHRoZSBEQU8gdG8gYSAnICtcbiAgICAgICAgICAnW2tleSwgdmFsdWVdIGNob2ljZS4gUmVxdWlyZWQgd2hlbiBhIERBTyBpcyBwcm92aWRlZC4nXG4gICAgfSxcbiAgICB7XG4gICAgICBjbGFzczogJ2ZvYW0uZGFvLkRBT1Byb3BlcnR5JyxcbiAgICAgIG5hbWU6ICdkYW8nXG4gICAgfSxcbiAgICB7XG4gICAgICBuYW1lOiAndGV4dCcsXG4gICAgICBwb3N0U2V0OiBmdW5jdGlvbihvLCBuKSB7XG4gICAgICAgIGlmICggbyAhPT0gbiApIHRoaXMuY2hvaWNlID0gdGhpcy5maW5kQ2hvaWNlQnlUZXh0KG4pO1xuICAgICAgfVxuICAgIH0sXG4gICAge1xuICAgICAgbmFtZTogJ2RhdGEnLFxuICAgICAgcG9zdFNldDogZnVuY3Rpb24obywgbikge1xuICAgICAgICBpZiAoIG8gIT09IG4gKSB0aGlzLmNob2ljZSA9IHRoaXMuZmluZENob2ljZUJ5RGF0YShuKSB8fCBbIG4sIG4gXTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHtcbiAgICAgIGNsYXNzOiAnZm9hbS51Mi5WaWV3U3BlYycsXG4gICAgICBuYW1lOiAnc2VsZWN0U3BlYycsXG4gICAgICB2YWx1ZTogeyBjbGFzczogJ2ZvYW0udTIudGFnLlNlbGVjdCcgfVxuICAgIH0sXG4gICAge1xuICAgICAgY2xhc3M6ICdCb29sZWFuJyxcbiAgICAgIG5hbWU6ICdhbHdheXNGbG9hdExhYmVsJ1xuICAgIH0sXG4gICAge1xuICAgICAgbmFtZTogJ3ZpZXdfJ1xuICAgIH0sXG4gICAgJ2ZlZWRiYWNrXycsXG4gICAgJ2RlZmF1bHRWYWx1ZScsXG4gICAgJ3NpemUnXG4gIF0sXG5cbiAgbWV0aG9kczogW1xuICAgIGZ1bmN0aW9uIGluaXQoKSB7XG4gICAgICB0aGlzLm9uRGV0YWNoKHRoaXMuY2hvaWNlcyQuc3ViKHRoaXMub25DaG9pY2VzVXBkYXRlKSk7XG4gICAgfSxcblxuICAgIGZ1bmN0aW9uIGluaXRFKCkge1xuICAgICAgLy8gSWYgbm8gaXRlbSBpcyBzZWxlY3RlZCwgYW5kIGRhdGEgaGFzIG5vdCBiZWVuIHByb3ZpZGVkLCBzZWxlY3QgdGhlIDB0aFxuICAgICAgLy8gZW50cnkuXG4gICAgICBpZiAoICEgdGhpcy5kYXRhICYmICEgdGhpcy5pbmRleCApIHtcbiAgICAgICAgdGhpcy5pbmRleCA9IDA7XG4gICAgICB9XG5cbiAgICAgIGlmICggdGhpcy5kYW8gKSB0aGlzLm9uREFPVXBkYXRlKCk7XG5cbiAgICAgIHRoaXMuc3RhcnQodGhpcy5zZWxlY3RTcGVjLCB7XG4gICAgICAgIGRhdGEkOiB0aGlzLmluZGV4JCxcbiAgICAgICAgbGFiZWwkOiB0aGlzLmxhYmVsJCxcbiAgICAgICAgYWx3YXlzRmxvYXRMYWJlbDogdGhpcy5hbHdheXNGbG9hdExhYmVsLFxuICAgICAgICBjaG9pY2VzJDogdGhpcy5jaG9pY2VzJCxcbiAgICAgICAgcGxhY2Vob2xkZXIkOiB0aGlzLnBsYWNlaG9sZGVyJCxcbiAgICAgICAgbW9kZSQ6IHRoaXMubW9kZSQsXG4gICAgICAgIHNpemU6IHRoaXMuc2l6ZVxuICAgICAgfSkuZW5kKCk7XG5cbiAgICAgIHRoaXMuZGFvJHByb3h5Lm9uLnN1Yih0aGlzLm9uREFPVXBkYXRlKTtcbiAgICB9LFxuXG4gICAgZnVuY3Rpb24gZmluZEluZGV4T2ZDaG9pY2UoY2hvaWNlKSB7XG4gICAgICBpZiAoICEgY2hvaWNlICkgcmV0dXJuIC0xO1xuICAgICAgdmFyIGNob2ljZXMgPSB0aGlzLmNob2ljZXM7XG4gICAgICB2YXIgZGF0YSA9IGNob2ljZVswXTtcbiAgICAgIGZvciAoIHZhciBpID0gMCA7IGkgPCBjaG9pY2VzLmxlbmd0aCA7IGkrKyApIHtcbiAgICAgICAgaWYgKCBmb2FtLnV0aWwuZXF1YWxzKGNob2ljZXNbaV1bMF0sIGRhdGEpICkgcmV0dXJuIGk7XG4gICAgICB9XG4gICAgICB2YXIgdGV4dCA9IGNob2ljZVsxXTtcbiAgICAgIGZvciAoIHZhciBpID0gMCA7IGkgPCBjaG9pY2VzLmxlbmd0aCA7IGkrKyApIHtcbiAgICAgICAgaWYgKCBjaG9pY2VzW2ldWzFdID09PSB0ZXh0ICkgcmV0dXJuIGk7XG4gICAgICB9XG4gICAgICByZXR1cm4gLTE7XG4gICAgfSxcblxuICAgIGZ1bmN0aW9uIGZpbmRDaG9pY2VCeURhdGEoZGF0YSkge1xuICAgICAgdmFyIGNob2ljZXMgPSB0aGlzLmNob2ljZXM7XG4gICAgICBmb3IgKCB2YXIgaSA9IDAgOyBpIDwgY2hvaWNlcy5sZW5ndGggOyBpKysgKSB7XG4gICAgICAgIGlmICggZm9hbS51dGlsLmVxdWFscyhjaG9pY2VzW2ldWzBdLCBkYXRhKSApIHJldHVybiBjaG9pY2VzW2ldO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSxcblxuICAgIGZ1bmN0aW9uIGZpbmRDaG9pY2VCeVRleHQodGV4dCkge1xuICAgICAgdmFyIGNob2ljZXMgPSB0aGlzLmNob2ljZXM7XG4gICAgICBmb3IgKCB2YXIgaSA9IDAgOyBpIDwgY2hvaWNlcy5sZW5ndGggOyBpKysgKSB7XG4gICAgICAgIGlmICggY2hvaWNlc1tpXVsxXSA9PT0gdGV4dCApIHJldHVybiBjaG9pY2VzW2ldO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSxcblxuICAgIGZ1bmN0aW9uIGZyb21Qcm9wZXJ0eShwKSB7XG4gICAgICB0aGlzLlNVUEVSKHApO1xuICAgICAgdGhpcy5kZWZhdWx0VmFsdWUgPSBwLnZhbHVlO1xuICAgIH1cbiAgXSxcblxuICBsaXN0ZW5lcnM6IFtcbiAgICB7XG4gICAgICBuYW1lOiAnb25DaG9pY2VzVXBkYXRlJyxcbiAgICAgIGlzRnJhbWVkOiB0cnVlLFxuICAgICAgY29kZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBkID0gdGhpcy5kYXRhO1xuICAgICAgICBpZiAoIHRoaXMuY2hvaWNlcy5sZW5ndGggKSB7XG4gICAgICAgICAgdGhpcy5jaG9pY2UgPSAoIGQgJiYgdGhpcy5maW5kQ2hvaWNlQnlEYXRhKGQpICkgfHwgdGhpcy5kZWZhdWx0VmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIHtcbiAgICAgIG5hbWU6ICdvbkRBT1VwZGF0ZScsXG4gICAgICBpc0ZyYW1lZDogdHJ1ZSxcbiAgICAgIGNvZGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLmRhby5zZWxlY3QoKS50aGVuKGZ1bmN0aW9uKHMpIHtcbiAgICAgICAgICB0aGlzLmNob2ljZXMgPSBzLmFycmF5Lm1hcCh0aGlzLm9ialRvQ2hvaWNlKTtcbiAgICAgICAgICBpZiAoICEgdGhpcy5kYXRhICYmIHRoaXMuaW5kZXggPT09IC0xICkgdGhpcy5pbmRleCA9IHRoaXMucGxhY2Vob2xkZXIgPyAtMSA6IDA7XG4gICAgICAgIH0uYmluZCh0aGlzKSk7XG4gICAgICB9XG4gICAgfVxuICBdXG59KTtcbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmZvYW0uQ0xBU1Moe1xuICBwYWNrYWdlOiAnZm9hbS51Mi52aWV3JyxcbiAgbmFtZTogJ1JhZGlvVmlldycsXG4gIGV4dGVuZHM6ICdmb2FtLnUyLnZpZXcuQ2hvaWNlVmlldycsXG5cbiAgYXhpb21zOiBbXG4gICAgZm9hbS51Mi5DU1MuY3JlYXRlKHtcbiAgICAgIGNvZGU6IGZ1bmN0aW9uIENTUygpIHsvKlxuICAgICAgICBeIGxhYmVsIHtcbiAgICAgICAgICBwb3NpdGlvbjogcmVsYXRpdmU7XG4gICAgICAgIH1cbiAgICAgICovfVxuICAgIH0pXG4gIF0sXG5cbiAgbWV0aG9kczogW1xuICAgIGZ1bmN0aW9uIGluaXRFKCkge1xuICAgICAgLy8gSWYgbm8gaXRlbSBpcyBzZWxlY3RlZCwgYW5kIGRhdGEgaGFzIG5vdCBiZWVuIHByb3ZpZGVkLCBzZWxlY3QgdGhlIDB0aFxuICAgICAgLy8gZW50cnkuXG4gICAgICB0aGlzLmFkZENsYXNzKHRoaXMubXlDbGFzcygpKTtcbiAgICAgIGlmICggISB0aGlzLmRhdGEgJiYgISB0aGlzLmluZGV4ICkge1xuICAgICAgICB0aGlzLmluZGV4ID0gMDtcbiAgICAgIH1cblxuICAgICAgaWYgKCB0aGlzLmRhbyApIHRoaXMub25EQU9VcGRhdGUoKTtcbiAgICAgIHRoaXMuY2hvaWNlcyQuc3ViKHRoaXMub25DaG9pY2VzVXBkYXRlKTtcbiAgICAgIHRoaXMub25DaG9pY2VzVXBkYXRlKCk7XG4gICAgfVxuICBdLFxuXG4gIGxpc3RlbmVyczogW1xuICAgIGZ1bmN0aW9uIG9uQ2hvaWNlc1VwZGF0ZSgpIHtcbiAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgIHZhciBpZDtcblxuICAgICAgdGhpcy5yZW1vdmVBbGxDaGlsZHJlbigpO1xuXG4gICAgICB0aGlzLmFkZCh0aGlzLmNob2ljZXMubWFwKGZ1bmN0aW9uKGMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuRSgnZGl2JykuXG4gICAgICAgICAgYWRkQ2xhc3ModGhpcy5teUNsYXNzKCkpLlxuICAgICAgICAgIHN0YXJ0KCdpbnB1dCcpLlxuICAgICAgICAgICAgYXR0cnMoe1xuICAgICAgICAgICAgICB0eXBlOiAncmFkaW8nLFxuICAgICAgICAgICAgICBuYW1lOiB0aGlzLmlkLFxuICAgICAgICAgICAgICB2YWx1ZTogY1swXSxcbiAgICAgICAgICAgICAgY2hlY2tlZDogc2VsZi5zbG90KGZ1bmN0aW9uIChkYXRhKSB7IHJldHVybiBkYXRhID09PSBjWzBdOyB9KVxuICAgICAgICAgICAgfSkuXG4gICAgICAgICAgICBzZXRJRChpZCA9IHNlbGYuTkVYVF9JRCgpKS5cbiAgICAgICAgICAgIG9uKCdjaGFuZ2UnLCBmdW5jdGlvbihldnQpIHtcbiAgICAgICAgICAgICAgc2VsZi5kYXRhID0gZXZ0LnNyY0VsZW1lbnQudmFsdWU7XG4gICAgICAgICAgICB9KS5cbiAgICAgICAgICBlbmQoKS5cbiAgICAgICAgICBzdGFydCgnbGFiZWwnKS5cbiAgICAgICAgICAgIGF0dHJzKHtcbiAgICAgICAgICAgICAgZm9yOiBpZFxuICAgICAgICAgICAgfSkuXG4gICAgICAgICAgICBzdGFydCgnc3BhbicpLlxuICAgICAgICAgICAgICBhZGQoY1sxXSkuXG4gICAgICAgICAgICBlbmQoKVxuICAgICAgICAgIC5lbmQoKTtcbiAgICAgIH0uYmluZCh0aGlzKSkpO1xuICAgIH1cbiAgXVxufSk7XG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5mb2FtLkNMQVNTKHtcbiAgcGFja2FnZTogJ2ZvYW0udTIudmlldycsXG4gIG5hbWU6ICdUZXh0RmllbGQnLFxuICBleHRlbmRzOiAnZm9hbS51Mi5FbGVtZW50JyxcblxuICByZXF1aXJlczogW1xuICAgICdmb2FtLnUyLnRhZy5JbnB1dCdcbiAgXSxcblxuICBwcm9wZXJ0aWVzOiBbXG4gICAgJ2RhdGEnLFxuICAgIHtcbiAgICAgIGNsYXNzOiAnQm9vbGVhbicsXG4gICAgICBuYW1lOiAnb25LZXknLFxuICAgICAgYXR0cmlidXRlOiB0cnVlXG4gICAgICAvLyBkb2N1bWVudGF0aW9uOiAnV2hlbiB0cnVlLCAkJERPQ3tyZWY6XCIuZGF0YVwifSBpcyB1cGRhdGVkIG9uIGV2ZXJ5IGtleXN0cm9rZSwgcmF0aGVyIHRoYW4gb24gYmx1ci4nXG4gICAgfSxcbiAgICB7XG4gICAgICBjbGFzczogJ2ZvYW0udTIuVmlld1NwZWMnLFxuICAgICAgbmFtZTogJ3ZpZXcnLFxuICAgICAgdmFsdWU6IHsgY2xhc3M6ICdmb2FtLnUyLnRhZy5JbnB1dCcgfVxuICAgIH0sXG4gICAgJ2xhYmVsJyxcbiAgICAnYWx3YXlzRmxvYXRMYWJlbCcsXG4gICAgJ3R5cGUnLFxuICAgICdwbGFjZWhvbGRlcicsXG4gICAgJ2F1dG9jb21wbGV0ZXInLFxuICAgICdhdXRvY29tcGxldGVMaXN0XydcbiAgXSxcblxuICBtZXRob2RzOiBbXG4gICAgZnVuY3Rpb24gaW5pdEUoKSB7XG4gICAgICB2YXIgZSA9IHRoaXMuc3RhcnQodGhpcy52aWV3LCB7XG4gICAgICAgIGRhdGEkOiAgICAgICAgICAgIHRoaXMuZGF0YSQsXG4gICAgICAgIGxhYmVsJDogICAgICAgICAgIHRoaXMubGFiZWwkLFxuICAgICAgICBhbHdheXNGbG9hdExhYmVsOiB0aGlzLmFsd2F5c0Zsb2F0TGFiZWwsXG4gICAgICAgIHR5cGU6ICAgICAgICAgICAgIHRoaXMudHlwZSxcbiAgICAgICAgb25LZXk6ICAgICAgICAgICAgdGhpcy5vbktleVxuICAgICAgfSk7XG4gICAgICBlLmF0dHJzKHtcbiAgICAgICAgcGxhY2Vob2xkZXI6IHRoaXMucGxhY2Vob2xkZXIkLFxuICAgICAgfSk7XG4gICAgICBlLmVuZCgpO1xuXG4gICAgICBpZiAoIHRoaXMuYXV0b2NvbXBsZXRlciApIHtcbiAgICAgICAgdGhpcy5vbmxvYWQuc3ViKGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHZhciBsaXN0ID0gZm9hbS51Mi5FbGVtZW50LmNyZWF0ZSh7IG5vZGVOYW1lOiAnZGF0YWxpc3QnIH0pO1xuICAgICAgICAgIHRoaXMuYXV0b2NvbXBsZXRlTGlzdF8gPSBsaXN0O1xuICAgICAgICAgIHRoaXMuYXV0b2NvbXBsZXRlci5kYW8ub24uc3ViKHRoaXMudXBkYXRlQXV0b2NvbXBsZXRlTGlzdCk7XG4gICAgICAgICAgdGhpcy51cGRhdGVBdXRvY29tcGxldGVMaXN0KCk7XG4gICAgICAgICAgdGhpcy5kb2N1bWVudC5ib2R5Lmluc2VydEFkamFjZW50SFRNTCgnYmVmb3JlZW5kJywgbGlzdC5vdXRlckhUTUwpO1xuICAgICAgICAgIGxpc3QubG9hZCgpO1xuXG4gICAgICAgICAgLy8gQWN0dWFsbHkgc2V0IHRoZSBsaXN0IGF0dHJpYnV0ZSBvbiBvdXIgaW5wdXQgZmllbGQuXG4gICAgICAgICAgZS5hdHRycyh7IGxpc3Q6IGxpc3QuaWQgfSk7XG4gICAgICAgIH0uYmluZCh0aGlzKSk7XG5cbiAgICAgICAgdGhpcy5vbnVubG9hZC5zdWIoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdGhpcy5hdXRvY29tcGxldGVMaXN0Xy5yZW1vdmUoKTtcbiAgICAgICAgfS5iaW5kKHRoaXMpKTtcbiAgICAgIH1cbiAgICB9XG4gIF0sXG5cbiAgbGlzdGVuZXJzOiBbXG4gICAge1xuICAgICAgbmFtZTogJ3VwZGF0ZUF1dG9jb21wbGV0ZUxpc3QnLFxuICAgICAgaXNGcmFtZWQ6IHRydWUsXG4gICAgICBjb2RlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGxpc3QgPSB0aGlzLmF1dG9jb21wbGV0ZUxpc3RfO1xuICAgICAgICB0aGlzLmF1dG9jb21wbGV0ZUxpc3RfLnJlbW92ZUFsbENoaWxkcmVuKCk7XG4gICAgICAgIHRoaXMuYXV0b2NvbXBsZXRlci5kYW8uc2VsZWN0KGZvYW0uZGFvLkFycmF5U2luay5jcmVhdGUoKSlcbiAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uKHNpbmspIHtcbiAgICAgICAgICAgICAgc2luay5hcnJheS5mb3JFYWNoKGZ1bmN0aW9uKHgpIHtcbiAgICAgICAgICAgICAgICBsaXN0LnN0YXJ0KCdvcHRpb24nKS5hdHRycyh7IHZhbHVlOiB4LmxhYmVsIH0pLmVuZCgpO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgXVxufSk7XG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5mb2FtLkNMQVNTKHtcbiAgcGFja2FnZTogJ2ZvYW0udTIudmlldycsXG4gIG5hbWU6ICdUcmVlVmlld1JvdycsXG4gIGV4dGVuZHM6ICdmb2FtLnUyLkVsZW1lbnQnLFxuXG4gIHJlcXVpcmVzOiBbXG4gICAgJ2ZvYW0ubWxhbmcuRXhwcmVzc2lvbnNTaW5nbGV0b24nXG4gIF0sXG5cbiAgZXhwb3J0czogW1xuICAgICdkYXRhJ1xuICBdLFxuXG4gIGltcG9ydHM6IFtcbiAgICAnc2VsZWN0aW9uJyxcbiAgICAnb25PYmpEcm9wJ1xuICBdLFxuXG4gIGF4aW9tczogW1xuICAgIGZvYW0udTIuQ1NTLmNyZWF0ZSh7XG4gICAgICBjb2RlOiBmdW5jdGlvbigpIHsvKlxuICAgICAgICBeIHsgd2hpdGUtc3BhY2U6IG5vd3JhcDsgbWFyZ2luLWxlZnQ6MTZweDsgfVxuICAgICAgICBec2VsZWN0ZWQgeyBvdXRsaW5lOiAycHggc29saWQgI2RkZGQwMDsgfVxuICAgICAgKi99XG4gICAgfSlcbiAgXSxcblxuICBwcm9wZXJ0aWVzOiBbXG4gICAge1xuICAgICAgbmFtZTogJ2RhdGEnXG4gICAgfSxcbiAgICB7XG4gICAgICBuYW1lOiAncmVsYXRpb25zaGlwJ1xuICAgIH0sXG4gICAge1xuICAgICAgY2xhc3M6ICdCb29sZWFuJyxcbiAgICAgIG5hbWU6ICdleHBhbmRlZCcsXG4gICAgICB2YWx1ZTogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgIGNsYXNzOiAnRnVuY3Rpb24nLFxuICAgICAgbmFtZTogJ2Zvcm1hdHRlcidcbiAgICB9XG4gIF0sXG5cbiAgbWV0aG9kczogW1xuICAgIGZ1bmN0aW9uIGluaXRFKCkge1xuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgdGhpcy5cbiAgICAgICAgYWRkQ2xhc3ModGhpcy5teUNsYXNzKCkpLlxuICAgICAgICBhZGRDbGFzcyh0aGlzLnNsb3QoZnVuY3Rpb24oc2VsZWN0ZWQsIGlkKSB7XG4gICAgICAgICAgaWYgKCBzZWxlY3RlZCAmJiBmb2FtLnV0aWwuZXF1YWxzKHNlbGVjdGVkLmlkLCBpZCkgKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5teUNsYXNzKCdzZWxlY3RlZCcpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgIH0sIHRoaXMuc2VsZWN0aW9uJCwgdGhpcy5kYXRhJC5kb3QoJ2lkJykpKS5cbiAgICAgICAgYXR0cnMoeyBkcmFnZ2FibGU6ICd0cnVlJyB9KS5cbiAgICAgICAgc3RhcnQoJ3NwYW4nKS5cbiAgICAgICAgICBvbignY2xpY2snLCB0aGlzLnRvZ2dsZUV4cGFuZGVkKS5cbiAgICAgICAgICBhZGQodGhpcy5leHBhbmRlZCQubWFwKGZ1bmN0aW9uKHYpIHsgcmV0dXJuIHYgPyAnXFx1MjVCRCcgOiAnXFx1MjVCNyc7IH0pKS5cbiAgICAgICAgICBlbnRpdHkoJ25ic3AnKS5cbiAgICAgICAgZW5kKCkuXG4gICAgICAgIG9uKCdjbGljaycsIHRoaXMuc2VsZWN0ZWQpLlxuICAgICAgICBvbignZHJhZ3N0YXJ0JywgdGhpcy5vbkRyYWdTdGFydCkuXG4gICAgICAgIG9uKCdkcmFnZW50ZXInLCB0aGlzLm9uRHJhZ092ZXIpLlxuICAgICAgICBvbignZHJhZ292ZXInLCB0aGlzLm9uRHJhZ092ZXIpLlxuICAgICAgICBvbignZHJvcCcsIHRoaXMub25Ecm9wKS5cbiAgICAgICAgY2FsbCh0aGlzLmZvcm1hdHRlcikuXG4gICAgICAgIGFkZCh0aGlzLnNsb3QoZnVuY3Rpb24oZSkge1xuICAgICAgICAgIGlmICggISBlICkgcmV0dXJuIHRoaXMuRSgnZGl2Jyk7XG4gICAgICAgICAgdmFyIGUyID0gdGhpcy5FKCdkaXYnKTtcbiAgICAgICAgICBlMi5zZWxlY3QodGhpcy5kYXRhW3NlbGYucmVsYXRpb25zaGlwLmZvcndhcmROYW1lXS8qLmRhbyovLCBmdW5jdGlvbihvYmopIHtcbiAgICAgICAgICAgIHJldHVybiBzZWxmLmNsc18uY3JlYXRlKHtcbiAgICAgICAgICAgICAgZGF0YTogb2JqLFxuICAgICAgICAgICAgICBmb3JtYXR0ZXI6IHNlbGYuZm9ybWF0dGVyLFxuICAgICAgICAgICAgICByZWxhdGlvbnNoaXA6IHNlbGYucmVsYXRpb25zaGlwXG4gICAgICAgICAgICB9LCB0aGlzKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZXR1cm4gZTI7XG4gICAgICAgIH0sIHRoaXMuZXhwYW5kZWQkKSk7XG4gICAgfVxuICBdLFxuXG4gIGxpc3RlbmVyczogW1xuICAgIGZ1bmN0aW9uIG9uRHJhZ1N0YXJ0KGUpIHtcbiAgICAgIGUuZGF0YVRyYW5zZmVyLnNldERhdGEoJ2FwcGxpY2F0aW9uL3gtZm9hbS1vYmotaWQnLCB0aGlzLmRhdGEuaWQpO1xuICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICB9LFxuXG4gICAgZnVuY3Rpb24gb25EcmFnT3ZlcihlKSB7XG4gICAgICBpZiAoICEgZS5kYXRhVHJhbnNmZXIudHlwZXMuc29tZShmdW5jdGlvbihtKSB7IHJldHVybiBtID09PSAnYXBwbGljYXRpb24veC1mb2FtLW9iai1pZCc7IH0pIClcbiAgICAgICAgcmV0dXJuO1xuXG4gICAgICB2YXIgaWQgPSBlLmRhdGFUcmFuc2Zlci5nZXREYXRhKCdhcHBsaWNhdGlvbi94LWZvYW0tb2JqLWlkJyk7XG5cbiAgICAgIGlmICggZm9hbS51dGlsLmVxdWFscyhpZCwgdGhpcy5kYXRhLmlkKSApXG4gICAgICAgIHJldHVybjtcblxuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICB9LFxuXG4gICAgZnVuY3Rpb24gb25Ecm9wKGUpIHtcbiAgICAgIGlmICggISBlLmRhdGFUcmFuc2Zlci50eXBlcy5zb21lKGZ1bmN0aW9uKG0pIHsgcmV0dXJuIG0gPT09ICdhcHBsaWNhdGlvbi94LWZvYW0tb2JqLWlkJzsgfSkgKVxuICAgICAgICByZXR1cm47XG5cbiAgICAgIHZhciBpZCA9IGUuZGF0YVRyYW5zZmVyLmdldERhdGEoJ2FwcGxpY2F0aW9uL3gtZm9hbS1vYmotaWQnKTtcblxuICAgICAgaWYgKCBmb2FtLnV0aWwuZXF1YWxzKGlkLCB0aGlzLmRhdGEuaWQpICkgcmV0dXJuO1xuXG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuXG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICB2YXIgZGFvICA9IHRoaXMuX19jb250ZXh0X19bdGhpcy5yZWxhdGlvbnNoaXAudGFyZ2V0REFPS2V5XTtcbiAgICAgIGRhby5maW5kKGlkKS50aGVuKGZ1bmN0aW9uKG9iaikge1xuICAgICAgICBpZiAoICEgb2JqICkgcmV0dXJuIG51bGw7XG5cbiAgICAgICAgLy8gVE9ETzogV2Ugc2hvdWxkbid0IGhhdmUgdG8gcmVtb3ZlIHRoZW4gcHV0LFxuICAgICAgICAvLyBXZSBjdXJyZW50bHkgaGF2ZSB0byBiZWNhdXNlIHRoZSBGTE9XIGVkaXRvciBpcyBub3QgdXBkYXRpbmcgcHJvcGVybHlcbiAgICAgICAgLy8gb24gYSBwdXQgZXZlbnQgZm9yIGFuIG9iamVjdCB0aGF0IGl0IGFscmVhZHkgaGFzLlxuICAgICAgICBkYW8ucmVtb3ZlKG9iaikudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgICBzZWxmLmRhdGFbc2VsZi5yZWxhdGlvbnNoaXAuZm9yd2FyZE5hbWVdLmRhby5wdXQob2JqKS50aGVuKGZ1bmN0aW9uKG9iaikge1xuICAgICAgICAgICAgc2VsZi5vbk9iakRyb3Aob2JqLCBpZCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfSxcblxuICAgIGZ1bmN0aW9uIHNlbGVjdGVkKGUpIHtcbiAgICAgIHRoaXMuc2VsZWN0aW9uID0gdGhpcy5kYXRhO1xuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICB9LFxuXG4gICAgZnVuY3Rpb24gdG9nZ2xlRXhwYW5kZWQoZSkge1xuICAgICAgdGhpcy5leHBhbmRlZCA9ICEgdGhpcy5leHBhbmRlZDtcbiAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgfVxuICBdXG59KTtcblxuXG5mb2FtLkNMQVNTKHtcbiAgcGFja2FnZTogJ2ZvYW0udTIudmlldycsXG4gIG5hbWU6ICdUcmVlVmlldycsXG4gIGV4dGVuZHM6ICdmb2FtLnUyLkVsZW1lbnQnLFxuXG4gIHJlcXVpcmVzOiBbXG4gICAgJ2ZvYW0ubWxhbmcuRXhwcmVzc2lvbnNTaW5nbGV0b24nLFxuICAgICdmb2FtLnUyLnZpZXcuVHJlZVZpZXdSb3cnXG4gIF0sXG5cbiAgZXhwb3J0czogW1xuICAgICdvbk9iakRyb3AnLFxuICAgICdzZWxlY3Rpb24nXG4gIF0sXG5cbiAgcHJvcGVydGllczogW1xuICAgIHtcbiAgICAgIGNsYXNzOiAnZm9hbS5kYW8uREFPUHJvcGVydHknLFxuICAgICAgbmFtZTogJ2RhdGEnXG4gICAgfSxcbiAgICB7XG4gICAgICBuYW1lOiAncmVsYXRpb25zaGlwJ1xuICAgIH0sXG4gICAge1xuICAgICAgbmFtZTogJ3NlbGVjdGlvbidcbiAgICB9LFxuICAgIHtcbiAgICAgIGNsYXNzOiAnRnVuY3Rpb24nLFxuICAgICAgbmFtZTogJ2Zvcm1hdHRlcidcbiAgICB9LFxuICAgIHtcbiAgICAgIGNsYXNzOiAnQm9vbGVhbicsXG4gICAgICBuYW1lOiAnc3RhcnRFeHBhbmRlZCcsXG4gICAgICB2YWx1ZTogZmFsc2VcbiAgICB9XG4gIF0sXG5cbiAgbWV0aG9kczogW1xuICAgIGZ1bmN0aW9uIGluaXRFKCkge1xuICAgICAgdmFyIE0gID0gdGhpcy5FeHByZXNzaW9uc1NpbmdsZXRvbi5jcmVhdGUoKTtcbiAgICAgIHZhciBvZiA9IHRoaXMubG9va3VwKHRoaXMucmVsYXRpb25zaGlwLnNvdXJjZU1vZGVsKTtcblxuICAgICAgdmFyIGRhbyA9IHRoaXMuZGF0YSRwcm94eS53aGVyZShcbiAgICAgICAgTS5OT1QoTS5IQVMob2YuZ2V0QXhpb21CeU5hbWUodGhpcy5yZWxhdGlvbnNoaXAuaW52ZXJzZU5hbWUpKSkpO1xuXG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICB0aGlzLmFkZENsYXNzKHRoaXMubXlDbGFzcygpKS5cbiAgICAgICAgc2VsZWN0KGRhbywgZnVuY3Rpb24ob2JqKSB7XG4gICAgICAgICAgcmV0dXJuIHNlbGYuVHJlZVZpZXdSb3cuY3JlYXRlKHtcbiAgICAgICAgICAgIGRhdGE6IG9iaixcbiAgICAgICAgICAgIHJlbGF0aW9uc2hpcDogc2VsZi5yZWxhdGlvbnNoaXAsXG4gICAgICAgICAgICBleHBhbmRlZDogc2VsZi5zdGFydEV4cGFuZGVkLFxuICAgICAgICAgICAgZm9ybWF0dGVyOiBzZWxmLmZvcm1hdHRlclxuICAgICAgICAgIH0sIHRoaXMpO1xuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgZnVuY3Rpb24gb25PYmpEcm9wKG9iaiwgdGFyZ2V0KSB7XG4gICAgICAvLyBUZW1wbGF0ZSBNZXRob2RcbiAgICB9XG4gIF1cbn0pO1xuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKi9cblxuZm9hbS5DTEFTUyh7XG4gIHBhY2thZ2U6ICdmb2FtLnUyLnZpZXcnLFxuICBuYW1lOiAnQWx0VmlldycsXG4gIGV4dGVuZHM6ICdmb2FtLnUyLlZpZXcnLFxuXG4gIGRvY3VtZW50YXRpb246IFwiUHJvdmlkZXMgdGhlIGFiaWxpdHkgdG8gc3dpdGNoIGJldHdlZW4gbXVsdGlwbGUgdmlld3MgZm9yIGRhdGEgc2V0XCIgK1xuICBcIlRha2VzIGEgdmlld3MgcHJvcGVydHkgd2hpY2ggc2hvdWxkIGJlIHRoZSB2YWx1ZSBvZiBhbiBhcnJheSBjb250YWluaW5nIGFycmF5cyB0aGF0IGNvbnRhaW4gZGVzaXJlZCB2aWV3cywgYW5kIGxhYmVsLlwiICtcbiAgXCJFeC4gdmlld3M6IFtbIHsgY2xhc3M6ICdmb2FtLnUyLnZpZXcuVGFibGVWaWV3JyB9LCAnVGFibGUnIF1dXCIsXG5cbiAgcmVxdWlyZXM6IFtcbiAgICAnZm9hbS51Mi5zdGFjay5TdGFjaydcbiAgXSxcblxuICBwcm9wZXJ0aWVzOiBbXG4gICAge1xuICAgICAgbmFtZTogJ29mJyxcbiAgICAgIGZhY3Rvcnk6IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcy5kYXRhLm9mIH1cbiAgICB9LFxuICAgIHtcbiAgICAgIG5hbWU6ICd2aWV3cycsXG4gICAgICB2YWx1ZTogW11cbiAgICB9LFxuICAgIHtcbiAgICAgIG5hbWU6ICdhbHRTdGFjaydcbiAgICB9LFxuICAgIHtcbiAgICAgIG5hbWU6ICd2aWV3Q2hvaWNlcycsXG4gICAgICB2aWV3OiBmdW5jdGlvbihfLCBYKSB7XG4gICAgICAgIHJldHVybiBmb2FtLnUyLnZpZXcuQ2hvaWNlVmlldy5jcmVhdGUoe1xuICAgICAgICAgIGNob2ljZXM6IFguZGF0YS52aWV3c1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gIF0sXG5cbiAgY3NzOiBgXG4gICAgXiB7XG4gICAgICB3aWR0aDogOTkycHg7XG4gICAgICBtYXJnaW46IGF1dG87XG4gICAgfVxuICAgIF4gLmZvYW0tdTItdGFnLVNlbGVjdHtcbiAgICAgIHdpZHRoOiAxMDBweDtcbiAgICAgIGhlaWdodDogNDBweDtcbiAgICB9XG4gICAgXiAucHJvcGVydHktdmlld0Nob2ljZXN7XG4gICAgICBtYXJnaW46IDAgMCAyNXB4IDE1cHg7XG4gICAgfVxuICBgLFxuXG4gIG1ldGhvZHM6IFtcbiAgICBmdW5jdGlvbiBpbml0RSgpIHtcbiAgICAgIHRoaXMuU1VQRVIoKTtcbiAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgIHRoaXMuYWx0U3RhY2sgPSBudWxsO1xuICAgICAgdGhpcy5hbHRTdGFjayA9IHRoaXMuU3RhY2suY3JlYXRlKCk7XG4gICAgICB0aGlzLnZpZXdDaG9pY2VzJC5zdWIodGhpcy5jaGFuZ2VWaWV3KTtcblxuICAgICAgdGhpcy52aWV3cy5mb3JFYWNoKGZ1bmN0aW9uKHZpZXcpe1xuICAgICAgICB2aWV3WzBdLmRhdGEgPSB2aWV3WzBdLmRhdGEgPyB2aWV3WzBdLmRhdGEgOiBzZWxmLmRhdGE7XG4gICAgICB9KTtcbiAgICAgIHRoaXMuYWx0U3RhY2sucHVzaCh0aGlzLnZpZXdzWzBdWzBdKTtcblxuICAgICAgdGhpcy5hZGRDbGFzcyh0aGlzLm15Q2xhc3MoKSlcbiAgICAgIHRoaXMuc3RhcnRDb250ZXh0KHtkYXRhOiB0aGlzfSlcbiAgICAgICAgdGhpcy5zdGFydCgpXG4gICAgICAgICAgLmFkZCh0aGlzLlZJRVdfQ0hPSUNFUylcbiAgICAgICAgLmVuZCgpXG4gICAgICAuZW5kQ29udGV4dCgpXG4gICAgICAuc3RhcnQoJ2RpdicpLmFkZENsYXNzKCdzdGFjay13cmFwcGVyJylcbiAgICAgICAgLnRhZyh7Y2xhc3M6ICdmb2FtLnUyLnN0YWNrLlN0YWNrVmlldycsIGRhdGE6IHRoaXMuYWx0U3RhY2ssIHNob3dBY3Rpb25zOiBmYWxzZX0pXG4gICAgICAuZW5kKCk7XG4gICAgfVxuICBdLFxuXG4gIGxpc3RlbmVyczogW1xuICAgIGZ1bmN0aW9uIGNoYW5nZVZpZXcoKXtcbiAgICAgIHRoaXMuYWx0U3RhY2sucHVzaCh0aGlzLnZpZXdDaG9pY2VzKTtcbiAgICB9XG4gIF1cbn0pO1xuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTYgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuZm9hbS5DTEFTUyh7XG4gIHBhY2thZ2U6ICdmb2FtLnUyLnZpZXcnLFxuICBuYW1lOiAnRHVhbFZpZXcnLFxuICBleHRlbmRzOiAnZm9hbS51Mi5FbGVtZW50JyxcblxuICBwcm9wZXJ0aWVzOiBbXG4gICAge1xuICAgICAgY2xhc3M6ICdmb2FtLnUyLlZpZXdTcGVjJyxcbiAgICAgIG5hbWU6ICd2aWV3YSdcbiAgICB9LFxuICAgIHtcbiAgICAgIGNsYXNzOiAnZm9hbS51Mi5WaWV3U3BlYycsXG4gICAgICBuYW1lOiAndmlld2InXG4gICAgfSxcbiAgICAnZGF0YScsXG4gICAgJ3Byb3AnXG4gIF0sXG5cbiAgbWV0aG9kczogW1xuICAgIGZ1bmN0aW9uIGluaXRFKCkge1xuICAgICAgdmFyIGEgPSBmb2FtLnUyLlZpZXdTcGVjLmNyZWF0ZVZpZXcodGhpcy52aWV3YSwge1xuICAgICAgICBkYXRhJDogdGhpcy5kYXRhJCB9LCB0aGlzLCB0aGlzKTtcbiAgICAgIHZhciBiID0gZm9hbS51Mi5WaWV3U3BlYy5jcmVhdGVWaWV3KHRoaXMudmlld2IsIHtcbiAgICAgICAgZGF0YSQ6IHRoaXMuZGF0YSQgfSwgdGhpcywgdGhpcyk7XG5cbiAgICAgIGlmICggdGhpcy5wcm9wICkge1xuICAgICAgICBhLmZyb21Qcm9wZXJ0eSAmJiBhLmZyb21Qcm9wZXJ0eSh0aGlzLnByb3ApO1xuICAgICAgICBiLmZyb21Qcm9wZXJ0eSAmJiBiLmZyb21Qcm9wZXJ0eSh0aGlzLnByb3ApO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmFkZChhKS5uYnNwKCkuYWRkKGIpO1xuICAgIH0sXG5cbiAgICBmdW5jdGlvbiBmcm9tUHJvcGVydHkocHJvcCkge1xuICAgICAgdGhpcy5wcm9wICA9IHByb3A7XG4gICAgfVxuICBdXG59KTtcbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmZvYW0uQ0xBU1Moe1xuICBwYWNrYWdlOiAnZm9hbS51Mi52aWV3JyxcbiAgbmFtZTogJ0NvbG9yUGlja2VyJyxcbiAgZXh0ZW5kczogJ2ZvYW0udTIudGFnLklucHV0JyxcblxuICBjb25zdGFudHM6IHtcbiAgICBOQU1FX1RPX0NPTE9SOiB7XG4gICAgICBibGFjazogXCIjMDAwMDAwXCIsXG4gICAgICBuYXZ5OiBcIiMwMDAwODBcIixcbiAgICAgIGRhcmtibHVlOiBcIiMwMDAwOGJcIixcbiAgICAgIG1lZGl1bWJsdWU6IFwiIzAwMDBjZFwiLFxuICAgICAgYmx1ZTogXCIjMDAwMGZmXCIsXG4gICAgICBkYXJrZ3JlZW46IFwiIzAwNjQwMFwiLFxuICAgICAgZ3JlZW46IFwiIzAwODAwMFwiLFxuICAgICAgdGVhbDogXCIjMDA4MDgwXCIsXG4gICAgICBkYXJrY3lhbjogXCIjMDA4YjhiXCIsXG4gICAgICBkZWVwc2t5Ymx1ZTogXCIjMDBiZmZmXCIsXG4gICAgICBkYXJrdHVycXVvaXNlOiBcIiMwMGNlZDFcIixcbiAgICAgIG1lZGl1bXNwcmluZ2dyZWVuOiBcIiMwMGZhOWFcIixcbiAgICAgIGxpbWU6IFwiIzAwZmYwMFwiLFxuICAgICAgc3ByaW5nZ3JlZW46IFwiIzAwZmY3ZlwiLFxuICAgICAgYXF1YTogXCIjMDBmZmZmXCIsXG4gICAgICBjeWFuOiBcIiMwMGZmZmZcIixcbiAgICAgIG1pZG5pZ2h0Ymx1ZTogXCIjMTkxOTcwXCIsXG4gICAgICBkb2RnZXJibHVlOiBcIiMxZTkwZmZcIixcbiAgICAgIGxpZ2h0c2VhZ3JlZW46IFwiIzIwYjJhYVwiLFxuICAgICAgZm9yZXN0Z3JlZW46IFwiIzIyOGIyMlwiLFxuICAgICAgc2VhZ3JlZW46IFwiIzJlOGI1N1wiLFxuICAgICAgZGFya3NsYXRlZ3JheTogXCIjMmY0ZjRmXCIsXG4gICAgICBkYXJrc2xhdGVncmV5OiBcIiMyZjRmNGZcIixcbiAgICAgIGxpbWVncmVlbjogXCIjMzJjZDMyXCIsXG4gICAgICBtZWRpdW1zZWFncmVlbjogXCIjM2NiMzcxXCIsXG4gICAgICB0dXJxdW9pc2U6IFwiIzQwZTBkMFwiLFxuICAgICAgcm95YWxibHVlOiBcIiM0MTY5ZTFcIixcbiAgICAgIHN0ZWVsYmx1ZTogXCIjNDY4MmI0XCIsXG4gICAgICBkYXJrc2xhdGVibHVlOiBcIiM0ODNkOGJcIixcbiAgICAgIG1lZGl1bXR1cnF1b2lzZTogXCIjNDhkMWNjXCIsXG4gICAgICBpbmRpZ286IFwiIzRiMDA4MlwiLFxuICAgICAgZGFya29saXZlZ3JlZW46IFwiIzU1NmIyZlwiLFxuICAgICAgY2FkZXRibHVlOiBcIiM1ZjllYTBcIixcbiAgICAgIGNvcm5mbG93ZXJibHVlOiBcIiM2NDk1ZWRcIixcbiAgICAgIHJlYmVjY2FwdXJwbGU6IFwiIzY2MzM5OVwiLFxuICAgICAgbWVkaXVtYXF1YW1hcmluZTogXCIjNjZjZGFhXCIsXG4gICAgICBkaW1ncmF5OiBcIiM2OTY5NjlcIixcbiAgICAgIGRpbWdyZXk6IFwiIzY5Njk2OVwiLFxuICAgICAgc2xhdGVibHVlOiBcIiM2YTVhY2RcIixcbiAgICAgIG9saXZlZHJhYjogXCIjNmI4ZTIzXCIsXG4gICAgICBzbGF0ZWdyYXk6IFwiIzcwODA5MFwiLFxuICAgICAgc2xhdGVncmV5OiBcIiM3MDgwOTBcIixcbiAgICAgIGxpZ2h0c2xhdGVncmF5OiBcIiM3Nzg4OTlcIixcbiAgICAgIGxpZ2h0c2xhdGVncmV5OiBcIiM3Nzg4OTlcIixcbiAgICAgIG1lZGl1bXNsYXRlYmx1ZTogXCIjN2I2OGVlXCIsXG4gICAgICBsYXduZ3JlZW46IFwiIzdjZmMwMFwiLFxuICAgICAgY2hhcnRyZXVzZTogXCIjN2ZmZjAwXCIsXG4gICAgICBhcXVhbWFyaW5lOiBcIiM3ZmZmZDRcIixcbiAgICAgIG1hcm9vbjogXCIjODAwMDAwXCIsXG4gICAgICBwdXJwbGU6IFwiIzgwMDA4MFwiLFxuICAgICAgb2xpdmU6IFwiIzgwODAwMFwiLFxuICAgICAgZ3JheTogXCIjODA4MDgwXCIsXG4gICAgICBncmV5OiBcIiM4MDgwODBcIixcbiAgICAgIHNreWJsdWU6IFwiIzg3Y2VlYlwiLFxuICAgICAgbGlnaHRza3libHVlOiBcIiM4N2NlZmFcIixcbiAgICAgIGJsdWV2aW9sZXQ6IFwiIzhhMmJlMlwiLFxuICAgICAgZGFya3JlZDogXCIjOGIwMDAwXCIsXG4gICAgICBkYXJrbWFnZW50YTogXCIjOGIwMDhiXCIsXG4gICAgICBzYWRkbGVicm93bjogXCIjOGI0NTEzXCIsXG4gICAgICBkYXJrc2VhZ3JlZW46IFwiIzhmYmM4ZlwiLFxuICAgICAgbGlnaHRncmVlbjogXCIjOTBlZTkwXCIsXG4gICAgICBtZWRpdW1wdXJwbGU6IFwiIzkzNzBkYlwiLFxuICAgICAgZGFya3Zpb2xldDogXCIjOTQwMGQzXCIsXG4gICAgICBwYWxlZ3JlZW46IFwiIzk4ZmI5OFwiLFxuICAgICAgZGFya29yY2hpZDogXCIjOTkzMmNjXCIsXG4gICAgICB5ZWxsb3dncmVlbjogXCIjOWFjZDMyXCIsXG4gICAgICBzaWVubmE6IFwiI2EwNTIyZFwiLFxuICAgICAgYnJvd246IFwiI2E1MmEyYVwiLFxuICAgICAgZGFya2dyYXk6IFwiI2E5YTlhOVwiLFxuICAgICAgZGFya2dyZXk6IFwiI2E5YTlhOVwiLFxuICAgICAgbGlnaHRibHVlOiBcIiNhZGQ4ZTZcIixcbiAgICAgIGdyZWVueWVsbG93OiBcIiNhZGZmMmZcIixcbiAgICAgIHBhbGV0dXJxdW9pc2U6IFwiI2FmZWVlZVwiLFxuICAgICAgbGlnaHRzdGVlbGJsdWU6IFwiI2IwYzRkZVwiLFxuICAgICAgcG93ZGVyYmx1ZTogXCIjYjBlMGU2XCIsXG4gICAgICBmaXJlYnJpY2s6IFwiI2IyMjIyMlwiLFxuICAgICAgZGFya2dvbGRlbnJvZDogXCIjYjg4NjBiXCIsXG4gICAgICBtZWRpdW1vcmNoaWQ6IFwiI2JhNTVkM1wiLFxuICAgICAgcm9zeWJyb3duOiBcIiNiYzhmOGZcIixcbiAgICAgIGRhcmtraGFraTogXCIjYmRiNzZiXCIsXG4gICAgICBzaWx2ZXI6IFwiI2MwYzBjMFwiLFxuICAgICAgbWVkaXVtdmlvbGV0cmVkOiBcIiNjNzE1ODVcIixcbiAgICAgIGluZGlhbnJlZDogXCIjY2Q1YzVjXCIsXG4gICAgICBwZXJ1OiBcIiNjZDg1M2ZcIixcbiAgICAgIGNob2NvbGF0ZTogXCIjZDI2OTFlXCIsXG4gICAgICB0YW46IFwiI2QyYjQ4Y1wiLFxuICAgICAgbGlnaHRncmF5OiBcIiNkM2QzZDNcIixcbiAgICAgIGxpZ2h0Z3JleTogXCIjZDNkM2QzXCIsXG4gICAgICB0aGlzdGxlOiBcIiNkOGJmZDhcIixcbiAgICAgIG9yY2hpZDogXCIjZGE3MGQ2XCIsXG4gICAgICBnb2xkZW5yb2Q6IFwiI2RhYTUyMFwiLFxuICAgICAgcGFsZXZpb2xldHJlZDogXCIjZGI3MDkzXCIsXG4gICAgICBjcmltc29uOiBcIiNkYzE0M2NcIixcbiAgICAgIGdhaW5zYm9ybzogXCIjZGNkY2RjXCIsXG4gICAgICBwbHVtOiBcIiNkZGEwZGRcIixcbiAgICAgIGJ1cmx5d29vZDogXCIjZGViODg3XCIsXG4gICAgICBsaWdodGN5YW46IFwiI2UwZmZmZlwiLFxuICAgICAgbGF2ZW5kZXI6IFwiI2U2ZTZmYVwiLFxuICAgICAgZGFya3NhbG1vbjogXCIjZTk5NjdhXCIsXG4gICAgICB2aW9sZXQ6IFwiI2VlODJlZVwiLFxuICAgICAgcGFsZWdvbGRlbnJvZDogXCIjZWVlOGFhXCIsXG4gICAgICBsaWdodGNvcmFsOiBcIiNmMDgwODBcIixcbiAgICAgIGtoYWtpOiBcIiNmMGU2OGNcIixcbiAgICAgIGFsaWNlYmx1ZTogXCIjZjBmOGZmXCIsXG4gICAgICBob25leWRldzogXCIjZjBmZmYwXCIsXG4gICAgICBhenVyZTogXCIjZjBmZmZmXCIsXG4gICAgICBzYW5keWJyb3duOiBcIiNmNGE0NjBcIixcbiAgICAgIHdoZWF0OiBcIiNmNWRlYjNcIixcbiAgICAgIGJlaWdlOiBcIiNmNWY1ZGNcIixcbiAgICAgIHdoaXRlc21va2U6IFwiI2Y1ZjVmNVwiLFxuICAgICAgbWludGNyZWFtOiBcIiNmNWZmZmFcIixcbiAgICAgIGdob3N0d2hpdGU6IFwiI2Y4ZjhmZlwiLFxuICAgICAgc2FsbW9uOiBcIiNmYTgwNzJcIixcbiAgICAgIGFudGlxdWV3aGl0ZTogXCIjZmFlYmQ3XCIsXG4gICAgICBsaW5lbjogXCIjZmFmMGU2XCIsXG4gICAgICBsaWdodGdvbGRlbnJvZHllbGxvdzogXCIjZmFmYWQyXCIsXG4gICAgICBvbGRsYWNlOiBcIiNmZGY1ZTZcIixcbiAgICAgIHJlZDogXCIjZmYwMDAwXCIsXG4gICAgICBmdWNoc2lhOiBcIiNmZjAwZmZcIixcbiAgICAgIG1hZ2VudGE6IFwiI2ZmMDBmZlwiLFxuICAgICAgZGVlcHBpbms6IFwiI2ZmMTQ5M1wiLFxuICAgICAgb3JhbmdlcmVkOiBcIiNmZjQ1MDBcIixcbiAgICAgIHRvbWF0bzogXCIjZmY2MzQ3XCIsXG4gICAgICBob3RwaW5rOiBcIiNmZjY5YjRcIixcbiAgICAgIGNvcmFsOiBcIiNmZjdmNTBcIixcbiAgICAgIGRhcmtvcmFuZ2U6IFwiI2ZmOGMwMFwiLFxuICAgICAgbGlnaHRzYWxtb246IFwiI2ZmYTA3YVwiLFxuICAgICAgb3JhbmdlOiBcIiNmZmE1MDBcIixcbiAgICAgIGxpZ2h0cGluazogXCIjZmZiNmMxXCIsXG4gICAgICBwaW5rOiBcIiNmZmMwY2JcIixcbiAgICAgIGdvbGQ6IFwiI2ZmZDcwMFwiLFxuICAgICAgcGVhY2hwdWZmOiBcIiNmZmRhYjlcIixcbiAgICAgIG5hdmFqb3doaXRlOiBcIiNmZmRlYWRcIixcbiAgICAgIG1vY2Nhc2luOiBcIiNmZmU0YjVcIixcbiAgICAgIGJpc3F1ZTogXCIjZmZlNGM0XCIsXG4gICAgICBtaXN0eXJvc2U6IFwiI2ZmZTRlMVwiLFxuICAgICAgYmxhbmNoZWRhbG1vbmQ6IFwiI2ZmZWJjZFwiLFxuICAgICAgcGFwYXlhd2hpcDogXCIjZmZlZmQ1XCIsXG4gICAgICBsYXZlbmRlcmJsdXNoOiBcIiNmZmYwZjVcIixcbiAgICAgIHNlYXNoZWxsOiBcIiNmZmY1ZWVcIixcbiAgICAgIGNvcm5zaWxrOiBcIiNmZmY4ZGNcIixcbiAgICAgIGxlbW9uY2hpZmZvbjogXCIjZmZmYWNkXCIsXG4gICAgICBmbG9yYWx3aGl0ZTogXCIjZmZmYWYwXCIsXG4gICAgICBzbm93OiBcIiNmZmZhZmFcIixcbiAgICAgIHllbGxvdzogXCIjZmZmZjAwXCIsXG4gICAgICBsaWdodHllbGxvdzogXCIjZmZmZmUwXCIsXG4gICAgICBpdm9yeTogXCIjZmZmZmYwXCIsXG4gICAgICB3aGl0ZTogXCIjZmZmZmZmXCJcbiAgICB9LFxuICAgIENPTE9SX1RPX05BTUU6IHsgJyMwMDAwMDAnOiAnYmxhY2snLFxuICAgICAgJyMwMDAwODAnOiAnbmF2eScsXG4gICAgICAnIzAwMDA4Yic6ICdkYXJrYmx1ZScsXG4gICAgICAnIzAwMDBjZCc6ICdtZWRpdW1ibHVlJyxcbiAgICAgICcjMDAwMGZmJzogJ2JsdWUnLFxuICAgICAgJyMwMDY0MDAnOiAnZGFya2dyZWVuJyxcbiAgICAgICcjMDA4MDAwJzogJ2dyZWVuJyxcbiAgICAgICcjMDA4MDgwJzogJ3RlYWwnLFxuICAgICAgJyMwMDhiOGInOiAnZGFya2N5YW4nLFxuICAgICAgJyMwMGJmZmYnOiAnZGVlcHNreWJsdWUnLFxuICAgICAgJyMwMGNlZDEnOiAnZGFya3R1cnF1b2lzZScsXG4gICAgICAnIzAwZmE5YSc6ICdtZWRpdW1zcHJpbmdncmVlbicsXG4gICAgICAnIzAwZmYwMCc6ICdsaW1lJyxcbiAgICAgICcjMDBmZjdmJzogJ3NwcmluZ2dyZWVuJyxcbiAgICAgICcjMDBmZmZmJzogJ2N5YW4nLFxuICAgICAgJyMxOTE5NzAnOiAnbWlkbmlnaHRibHVlJyxcbiAgICAgICcjMWU5MGZmJzogJ2RvZGdlcmJsdWUnLFxuICAgICAgJyMyMGIyYWEnOiAnbGlnaHRzZWFncmVlbicsXG4gICAgICAnIzIyOGIyMic6ICdmb3Jlc3RncmVlbicsXG4gICAgICAnIzJlOGI1Nyc6ICdzZWFncmVlbicsXG4gICAgICAnIzJmNGY0Zic6ICdkYXJrc2xhdGVncmV5JyxcbiAgICAgICcjMzJjZDMyJzogJ2xpbWVncmVlbicsXG4gICAgICAnIzNjYjM3MSc6ICdtZWRpdW1zZWFncmVlbicsXG4gICAgICAnIzQwZTBkMCc6ICd0dXJxdW9pc2UnLFxuICAgICAgJyM0MTY5ZTEnOiAncm95YWxibHVlJyxcbiAgICAgICcjNDY4MmI0JzogJ3N0ZWVsYmx1ZScsXG4gICAgICAnIzQ4M2Q4Yic6ICdkYXJrc2xhdGVibHVlJyxcbiAgICAgICcjNDhkMWNjJzogJ21lZGl1bXR1cnF1b2lzZScsXG4gICAgICAnIzRiMDA4Mic6ICdpbmRpZ28nLFxuICAgICAgJyM1NTZiMmYnOiAnZGFya29saXZlZ3JlZW4nLFxuICAgICAgJyM1ZjllYTAnOiAnY2FkZXRibHVlJyxcbiAgICAgICcjNjQ5NWVkJzogJ2Nvcm5mbG93ZXJibHVlJyxcbiAgICAgICcjNjYzMzk5JzogJ3JlYmVjY2FwdXJwbGUnLFxuICAgICAgJyM2NmNkYWEnOiAnbWVkaXVtYXF1YW1hcmluZScsXG4gICAgICAnIzY5Njk2OSc6ICdkaW1ncmV5JyxcbiAgICAgICcjNmE1YWNkJzogJ3NsYXRlYmx1ZScsXG4gICAgICAnIzZiOGUyMyc6ICdvbGl2ZWRyYWInLFxuICAgICAgJyM3MDgwOTAnOiAnc2xhdGVncmV5JyxcbiAgICAgICcjNzc4ODk5JzogJ2xpZ2h0c2xhdGVncmV5JyxcbiAgICAgICcjN2I2OGVlJzogJ21lZGl1bXNsYXRlYmx1ZScsXG4gICAgICAnIzdjZmMwMCc6ICdsYXduZ3JlZW4nLFxuICAgICAgJyM3ZmZmMDAnOiAnY2hhcnRyZXVzZScsXG4gICAgICAnIzdmZmZkNCc6ICdhcXVhbWFyaW5lJyxcbiAgICAgICcjODAwMDAwJzogJ21hcm9vbicsXG4gICAgICAnIzgwMDA4MCc6ICdwdXJwbGUnLFxuICAgICAgJyM4MDgwMDAnOiAnb2xpdmUnLFxuICAgICAgJyM4MDgwODAnOiAnZ3JleScsXG4gICAgICAnIzg3Y2VlYic6ICdza3libHVlJyxcbiAgICAgICcjODdjZWZhJzogJ2xpZ2h0c2t5Ymx1ZScsXG4gICAgICAnIzhhMmJlMic6ICdibHVldmlvbGV0JyxcbiAgICAgICcjOGIwMDAwJzogJ2RhcmtyZWQnLFxuICAgICAgJyM4YjAwOGInOiAnZGFya21hZ2VudGEnLFxuICAgICAgJyM4YjQ1MTMnOiAnc2FkZGxlYnJvd24nLFxuICAgICAgJyM4ZmJjOGYnOiAnZGFya3NlYWdyZWVuJyxcbiAgICAgICcjOTBlZTkwJzogJ2xpZ2h0Z3JlZW4nLFxuICAgICAgJyM5MzcwZGInOiAnbWVkaXVtcHVycGxlJyxcbiAgICAgICcjOTQwMGQzJzogJ2Rhcmt2aW9sZXQnLFxuICAgICAgJyM5OGZiOTgnOiAncGFsZWdyZWVuJyxcbiAgICAgICcjOTkzMmNjJzogJ2RhcmtvcmNoaWQnLFxuICAgICAgJyM5YWNkMzInOiAneWVsbG93Z3JlZW4nLFxuICAgICAgJyNhMDUyMmQnOiAnc2llbm5hJyxcbiAgICAgICcjYTUyYTJhJzogJ2Jyb3duJyxcbiAgICAgICcjYTlhOWE5JzogJ2RhcmtncmV5JyxcbiAgICAgICcjYWRkOGU2JzogJ2xpZ2h0Ymx1ZScsXG4gICAgICAnI2FkZmYyZic6ICdncmVlbnllbGxvdycsXG4gICAgICAnI2FmZWVlZSc6ICdwYWxldHVycXVvaXNlJyxcbiAgICAgICcjYjBjNGRlJzogJ2xpZ2h0c3RlZWxibHVlJyxcbiAgICAgICcjYjBlMGU2JzogJ3Bvd2RlcmJsdWUnLFxuICAgICAgJyNiMjIyMjInOiAnZmlyZWJyaWNrJyxcbiAgICAgICcjYjg4NjBiJzogJ2Rhcmtnb2xkZW5yb2QnLFxuICAgICAgJyNiYTU1ZDMnOiAnbWVkaXVtb3JjaGlkJyxcbiAgICAgICcjYmM4ZjhmJzogJ3Jvc3licm93bicsXG4gICAgICAnI2JkYjc2Yic6ICdkYXJra2hha2knLFxuICAgICAgJyNjMGMwYzAnOiAnc2lsdmVyJyxcbiAgICAgICcjYzcxNTg1JzogJ21lZGl1bXZpb2xldHJlZCcsXG4gICAgICAnI2NkNWM1Yyc6ICdpbmRpYW5yZWQnLFxuICAgICAgJyNjZDg1M2YnOiAncGVydScsXG4gICAgICAnI2QyNjkxZSc6ICdjaG9jb2xhdGUnLFxuICAgICAgJyNkMmI0OGMnOiAndGFuJyxcbiAgICAgICcjZDNkM2QzJzogJ2xpZ2h0Z3JleScsXG4gICAgICAnI2Q4YmZkOCc6ICd0aGlzdGxlJyxcbiAgICAgICcjZGE3MGQ2JzogJ29yY2hpZCcsXG4gICAgICAnI2RhYTUyMCc6ICdnb2xkZW5yb2QnLFxuICAgICAgJyNkYjcwOTMnOiAncGFsZXZpb2xldHJlZCcsXG4gICAgICAnI2RjMTQzYyc6ICdjcmltc29uJyxcbiAgICAgICcjZGNkY2RjJzogJ2dhaW5zYm9ybycsXG4gICAgICAnI2RkYTBkZCc6ICdwbHVtJyxcbiAgICAgICcjZGViODg3JzogJ2J1cmx5d29vZCcsXG4gICAgICAnI2UwZmZmZic6ICdsaWdodGN5YW4nLFxuICAgICAgJyNlNmU2ZmEnOiAnbGF2ZW5kZXInLFxuICAgICAgJyNlOTk2N2EnOiAnZGFya3NhbG1vbicsXG4gICAgICAnI2VlODJlZSc6ICd2aW9sZXQnLFxuICAgICAgJyNlZWU4YWEnOiAncGFsZWdvbGRlbnJvZCcsXG4gICAgICAnI2YwODA4MCc6ICdsaWdodGNvcmFsJyxcbiAgICAgICcjZjBlNjhjJzogJ2toYWtpJyxcbiAgICAgICcjZjBmOGZmJzogJ2FsaWNlYmx1ZScsXG4gICAgICAnI2YwZmZmMCc6ICdob25leWRldycsXG4gICAgICAnI2YwZmZmZic6ICdhenVyZScsXG4gICAgICAnI2Y0YTQ2MCc6ICdzYW5keWJyb3duJyxcbiAgICAgICcjZjVkZWIzJzogJ3doZWF0JyxcbiAgICAgICcjZjVmNWRjJzogJ2JlaWdlJyxcbiAgICAgICcjZjVmNWY1JzogJ3doaXRlc21va2UnLFxuICAgICAgJyNmNWZmZmEnOiAnbWludGNyZWFtJyxcbiAgICAgICcjZjhmOGZmJzogJ2dob3N0d2hpdGUnLFxuICAgICAgJyNmYTgwNzInOiAnc2FsbW9uJyxcbiAgICAgICcjZmFlYmQ3JzogJ2FudGlxdWV3aGl0ZScsXG4gICAgICAnI2ZhZjBlNic6ICdsaW5lbicsXG4gICAgICAnI2ZhZmFkMic6ICdsaWdodGdvbGRlbnJvZHllbGxvdycsXG4gICAgICAnI2ZkZjVlNic6ICdvbGRsYWNlJyxcbiAgICAgICcjZmYwMDAwJzogJ3JlZCcsXG4gICAgICAnI2ZmMDBmZic6ICdtYWdlbnRhJyxcbiAgICAgICcjZmYxNDkzJzogJ2RlZXBwaW5rJyxcbiAgICAgICcjZmY0NTAwJzogJ29yYW5nZXJlZCcsXG4gICAgICAnI2ZmNjM0Nyc6ICd0b21hdG8nLFxuICAgICAgJyNmZjY5YjQnOiAnaG90cGluaycsXG4gICAgICAnI2ZmN2Y1MCc6ICdjb3JhbCcsXG4gICAgICAnI2ZmOGMwMCc6ICdkYXJrb3JhbmdlJyxcbiAgICAgICcjZmZhMDdhJzogJ2xpZ2h0c2FsbW9uJyxcbiAgICAgICcjZmZhNTAwJzogJ29yYW5nZScsXG4gICAgICAnI2ZmYjZjMSc6ICdsaWdodHBpbmsnLFxuICAgICAgJyNmZmMwY2InOiAncGluaycsXG4gICAgICAnI2ZmZDcwMCc6ICdnb2xkJyxcbiAgICAgICcjZmZkYWI5JzogJ3BlYWNocHVmZicsXG4gICAgICAnI2ZmZGVhZCc6ICduYXZham93aGl0ZScsXG4gICAgICAnI2ZmZTRiNSc6ICdtb2NjYXNpbicsXG4gICAgICAnI2ZmZTRjNCc6ICdiaXNxdWUnLFxuICAgICAgJyNmZmU0ZTEnOiAnbWlzdHlyb3NlJyxcbiAgICAgICcjZmZlYmNkJzogJ2JsYW5jaGVkYWxtb25kJyxcbiAgICAgICcjZmZlZmQ1JzogJ3BhcGF5YXdoaXAnLFxuICAgICAgJyNmZmYwZjUnOiAnbGF2ZW5kZXJibHVzaCcsXG4gICAgICAnI2ZmZjVlZSc6ICdzZWFzaGVsbCcsXG4gICAgICAnI2ZmZjhkYyc6ICdjb3Juc2lsaycsXG4gICAgICAnI2ZmZmFjZCc6ICdsZW1vbmNoaWZmb24nLFxuICAgICAgJyNmZmZhZjAnOiAnZmxvcmFsd2hpdGUnLFxuICAgICAgJyNmZmZhZmEnOiAnc25vdycsXG4gICAgICAnI2ZmZmYwMCc6ICd5ZWxsb3cnLFxuICAgICAgJyNmZmZmZTAnOiAnbGlnaHR5ZWxsb3cnLFxuICAgICAgJyNmZmZmZjAnOiAnaXZvcnknLFxuICAgICAgJyNmZmZmZmYnOiAnd2hpdGUnXG4gICAgfVxuICB9LFxuXG4gIHByb3BlcnRpZXM6IFtcbiAgICB7XG4gICAgICBuYW1lOiAndHlwZScsXG4gICAgICB2YWx1ZTogJ2NvbG9yJ1xuICAgIH1cbiAgXSxcblxuICBtZXRob2RzOiBbXG4gICAgZnVuY3Rpb24gbGluaygpIHtcbiAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgIHRoaXMuYXR0clNsb3QobnVsbCwgdGhpcy5vbktleSA/ICdpbnB1dCcgOiBudWxsKS5yZWxhdGVGcm9tKHRoaXMuZGF0YSQsXG4gICAgICAgIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgaWYgKCB0eXBlb2YgdmFsdWUgIT09ICdzdHJpbmcnICkgcmV0dXJuIHZhbHVlO1xuXG4gICAgICAgICAgdmFyIHYgPSB2YWx1ZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgIGlmICggc2VsZi5DT0xPUl9UT19OQU1FW3ZdICkgcmV0dXJuIHNlbGYuQ09MT1JfVE9fTkFNRVt2XTtcbiAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH0sXG4gICAgICAgIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgIGlmICggdHlwZW9mIHZhbHVlICE9PSAnc3RyaW5nJyApIHJldHVybiB2YWx1ZTtcblxuICAgICAgICAgIHZhciB2ID0gdmFsdWUudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICBpZiAoIHNlbGYuTkFNRV9UT19DT0xPUlt2XSApIHJldHVybiBzZWxmLk5BTUVfVE9fQ09MT1Jbdl07XG4gICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9KTtcbiAgICB9XG4gIF1cbn0pO1xuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTYgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuZm9hbS5DTEFTUyh7XG4gIHBhY2thZ2U6ICdmb2FtLnUyLnZpZXcnLFxuICBuYW1lOiAnUGFzc3dvcmRWaWV3JyxcbiAgZXh0ZW5kczogJ2ZvYW0udTIudGFnLklucHV0JyxcblxuICBwcm9wZXJ0aWVzOiBbIFsgJ3R5cGUnLCAncGFzc3dvcmQnIF0gXVxufSk7XG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBUaGUgRk9BTSBBdXRob3JzLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKi9cblxuZm9hbS5DTEFTUyh7XG4gIHBhY2thZ2U6ICdmb2FtLnUyLnZpZXcnLFxuICBuYW1lOiAnQ2hpcFZpZXcnLFxuICBleHRlbmRzOiAnZm9hbS51Mi5WaWV3JyxcblxuICBkb2N1bWVudGF0aW9uOiAnVmlldyB0byBkaXNwbGF5IHRhZ3Mgd2l0aCBsYWJlbHMnLFxuXG4gIGltcG9ydHM6IFtcbiAgICAncmVtb3ZlQ2hpcCdcbiAgXSxcblxuICBjc3M6IGBcbiAgICBeIHtcbiAgICAgIGhlaWdodDogMzBweDtcbiAgICAgIGJvcmRlci1yYWRpdXM6IDEwMHB4O1xuICAgICAgYmFja2dyb3VuZC1jb2xvcjogI2E0YjNiODtcbiAgICAgIG1hcmdpbjogYXV0bztcbiAgICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcbiAgICAgIGZsb2F0OiBsZWZ0O1xuICAgICAgbWFyZ2luOiA1cHg7XG4gICAgfVxuXG4gICAgXiAubGFiZWwge1xuICAgICAgZm9udC1mYW1pbHk6IFJvYm90bztcbiAgICAgIGZvbnQtc2l6ZTogMTJweDtcbiAgICAgIGxpbmUtaGVpZ2h0OiAxLjMzO1xuICAgICAgbGV0dGVyLXNwYWNpbmc6IDAuMnB4O1xuICAgICAgdGV4dC1hbGlnbjogbGVmdDtcbiAgICAgIGNvbG9yOiAjZmZmZmZmO1xuICAgICAgcGFkZGluZzogOHB4IDE1cHggNnB4IDEwcHg7XG4gICAgICBkaXNwbGF5OiB0YWJsZS1jZWxsO1xuICAgIH1cblxuICAgIF4gLmZvYW0tdTItQWN0aW9uVmlldy1yZW1vdmVTZWxmIHtcbiAgICAgIHdpZHRoOiAxMHB4O1xuICAgICAgaGVpZ2h0OiAxMHB4O1xuICAgICAgb2JqZWN0LWZpdDogY29udGFpbjtcbiAgICAgIG1hcmdpbjogMDtcbiAgICAgIG1hcmdpbi10b3A6IC0xMTtcbiAgICAgIGZsb2F0OiByaWdodDtcbiAgICAgIGN1cnNvcjogcG9pbnRlcjtcbiAgICAgIGRpc3BsYXk6IGlubGluZS1ibG9jaztcbiAgICAgIG91dGxpbmU6IDA7XG4gICAgICBib3JkZXI6IG5vbmU7XG4gICAgICBiYWNrZ3JvdW5kOiB0cmFuc3BhcmVudDtcbiAgICAgIHBhZGRpbmctcmlnaHQ6IDE1eDtcbiAgICB9XG5cbiAgICBeIC5mb2FtLXUyLUFjdGlvblZpZXctcmVtb3ZlU2VsZiBpbWcge1xuICAgICAgd2lkdGg6IDE1cHg7XG4gICAgICBoZWlnaHQ6IDE1cHg7XG4gICAgfVxuXG4gICAgXiAuZm9hbS11Mi1BY3Rpb25WaWV3LXJlbW92ZVNlbGY6aG92ZXIge1xuICAgICAgYmFja2dyb3VuZDogdHJhbnNwYXJlbnQ7XG4gICAgICBiYWNrZ3JvdW5kLWNvbG9yOiB0cmFuc3BhcmVudDtcbiAgICB9XG4gIGAsXG5cbiAgbWV0aG9kczogW1xuICAgIGZ1bmN0aW9uIGluaXRFKCl7XG4gICAgICB0aGlzLlNVUEVSKCk7XG5cbiAgICAgIHRoaXNcbiAgICAgICAgLmFkZENsYXNzKHRoaXMubXlDbGFzcygpKVxuICAgICAgICAuc3RhcnQoKVxuICAgICAgICAgIC5zdGFydCgncCcpXG4gICAgICAgICAgICAuYWRkQ2xhc3MoJ2xhYmVsJylcbiAgICAgICAgICAgIC5hZGQodGhpcy5kYXRhKVxuICAgICAgICAgICAgLnN0YXJ0Q29udGV4dCh7IGRhdGE6IHRoaXMgfSlcbiAgICAgICAgICAgICAgLmFkZCh0aGlzLlJFTU9WRV9TRUxGKVxuICAgICAgICAgICAgLmVuZENvbnRleHQoKVxuICAgICAgICAgIC5lbmQoKVxuICAgICAgICAuZW5kKCk7XG4gICAgfVxuICBdLFxuXG4gIGFjdGlvbnM6IFtcbiAgICB7XG4gICAgICBuYW1lOiAncmVtb3ZlU2VsZicsXG4gICAgICBpY29uOiAnaW1hZ2VzL2ljLWNhbmNlbHdoaXRlLnN2ZycsXG4gICAgICBjb2RlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5yZW1vdmVDaGlwKHRoaXMuZGF0YSk7XG4gICAgICB9XG4gICAgfVxuICBdXG59KTtcbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmZvYW0uSU5URVJGQUNFKHtcbiAgcGFja2FnZTogJ2ZvYW0udTIudmlldycsXG4gIG5hbWU6ICdGb3JtYXR0ZXInLFxuICBtZXRob2RzOiBbXG4gICAge1xuICAgICAgbmFtZTogJ2Zvcm1hdCcsXG4gICAgICBhcmdzOiBbJ2UnLCAndmFsdWUnLCAnb2JqJywgJ2F4aW9tJ11cbiAgICB9XG4gIF1cbn0pO1xuXG5mb2FtLkNMQVNTKHtcbiAgcGFja2FnZTogJ2ZvYW0udTIudmlldycsXG4gIG5hbWU6ICdGbkZvcm1hdHRlcicsXG4gIGltcGxlbWVudHM6IFsgJ2ZvYW0udTIudmlldy5Gb3JtYXR0ZXInIF0sXG4gIHByb3BlcnRpZXM6IFtcbiAgICB7XG4gICAgICBjbGFzczogJ0Z1bmN0aW9uJyxcbiAgICAgIG5hbWU6ICdmJ1xuICAgIH1cbiAgXSxcbiAgbWV0aG9kczogW1xuICAgIGZ1bmN0aW9uIGZvcm1hdChlLCB2YWx1ZSwgb2JqLCBheGlvbSkge1xuICAgICAgdGhpcy5mLmNhbGwoZSwgdmFsdWUsIG9iaiwgYXhpb20pO1xuICAgIH1cbiAgXVxufSk7XG5cblxuZm9hbS5DTEFTUyh7XG4gIHBhY2thZ2U6ICdmb2FtLnUyLnZpZXcnLFxuICBuYW1lOiAnVGFibGVDZWxsRm9ybWF0dGVyJyxcbiAgZXh0ZW5kczogJ0ZPYmplY3RQcm9wZXJ0eScsXG4gIHByb3BlcnRpZXM6IFtcbiAgICB7XG4gICAgICBuYW1lOiAnb2YnLFxuICAgICAgdmFsdWU6ICdmb2FtLnUyLnZpZXcuRm9ybWF0dGVyJ1xuICAgIH0sXG4gICAge1xuICAgICAgbmFtZTogJ2FkYXB0JyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbihvLCBmLCBwcm9wKSB7XG4gICAgICAgIGlmICggZm9hbS5GdW5jdGlvbi5pc0luc3RhbmNlKGYpICkge1xuICAgICAgICAgIHJldHVybiBmb2FtLnUyLnZpZXcuRm5Gb3JtYXR0ZXIuY3JlYXRlKHtcbiAgICAgICAgICAgIGY6IGZcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZm9hbS5jb3JlLkZPYmplY3RQcm9wZXJ0eS5BREFQVC52YWx1ZS5jYWxsKHRoaXMsIG8sIGYsIHByb3ApO1xuICAgICAgfVxuICAgIH0sXG4gICAge1xuICAgICAgbmFtZTogJ3ZhbHVlJyxcbiAgICAgIGFkYXB0OiBmdW5jdGlvbihfLCB2KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFkYXB0LmNhbGwodGhpcywgXywgdiwgdGhpcyk7XG4gICAgICB9XG4gICAgfVxuICBdXG59KTtcblxuZm9hbS5DTEFTUyh7XG4gIHBhY2thZ2U6ICdmb2FtLnUyLnZpZXcnLFxuICBuYW1lOiAnVGFibGVDZWxsUHJvcGVydHlSZWZpbmVtZW50JyxcblxuICByZWZpbmVzOiAnZm9hbS5jb3JlLlByb3BlcnR5JyxcblxuICBwcm9wZXJ0aWVzOiBbXG4gICAge1xuICAgICAgbmFtZTogJ3RhYmxlSGVhZGVyRm9ybWF0dGVyJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbihheGlvbSkge1xuICAgICAgICB0aGlzLmFkZChheGlvbS5sYWJlbCk7XG4gICAgICB9XG4gICAgfSxcbiAgICB7XG4gICAgICBjbGFzczogJ2ZvYW0udTIudmlldy5UYWJsZUNlbGxGb3JtYXR0ZXInLFxuICAgICAgbmFtZTogJ3RhYmxlQ2VsbEZvcm1hdHRlcicsXG4gICAgICBhZGFwdDogZnVuY3Rpb24obywgZiwgcHJvcCkge1xuICAgICAgICBpZiAoIGZvYW0uRnVuY3Rpb24uaXNJbnN0YW5jZShmKSApIHtcbiAgICAgICAgICByZXR1cm4gZm9hbS51Mi52aWV3LkZuRm9ybWF0dGVyLmNyZWF0ZSh7XG4gICAgICAgICAgICBmOiBmXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZvYW0uY29yZS5GT2JqZWN0UHJvcGVydHkuQURBUFQudmFsdWUuY2FsbCh0aGlzLCBvLCBmLCBwcm9wKTtcbiAgICAgIH0sXG4gICAgICBmYWN0b3J5OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIGZvYW0udTIudmlldy5GbkZvcm1hdHRlci5jcmVhdGUoe1xuICAgICAgICAgIGNsYXNzOiAnZm9hbS51Mi52aWV3LkZuRm9ybWF0dGVyJyxcbiAgICAgICAgICBmOiBmdW5jdGlvbih2YWx1ZSwgb2JqLCBheGlvbSkge1xuICAgICAgICAgICAgdGhpcy5hZGQodmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgIH1cbiAgICB9LFxuICAgIHtcbiAgICAgIGNsYXNzOiAnSW50JyxcbiAgICAgIG5hbWU6ICd0YWJsZVdpZHRoJ1xuICAgIH1cbiAgXVxufSk7XG5cblxuZm9hbS5DTEFTUyh7XG4gIHJlZmluZXM6ICdmb2FtLmNvcmUuQWN0aW9uJyxcblxuICBwcm9wZXJ0aWVzOiBbXG4gICAge1xuICAgICAgY2xhc3M6ICdmb2FtLnUyLnZpZXcuVGFibGVDZWxsRm9ybWF0dGVyJyxcbiAgICAgIG5hbWU6ICd0YWJsZUNlbGxGb3JtYXR0ZXInLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uKF8sIG9iaiwgYXhpb20pIHtcbiAgICAgICAgdGhpcy5cbiAgICAgICAgICBzdGFydENvbnRleHQoeyBkYXRhOiBvYmogfSkuXG4gICAgICAgICAgYWRkKGF4aW9tKS5cbiAgICAgICAgICBlbmRDb250ZXh0KCk7XG4gICAgICB9XG4gICAgfSxcbiAgICB7XG4gICAgICBuYW1lOiAndGFibGVIZWFkZXJGb3JtYXR0ZXInLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uKGF4aW9tKSB7XG4gICAgICAgIHRoaXMuYWRkKGF4aW9tLmxhYmVsKTtcbiAgICAgIH1cbiAgICB9XG4gIF1cbn0pO1xuXG5cbmZvYW0uQ0xBU1Moe1xuICByZWZpbmVzOiAnZm9hbS5jb3JlLkVudW0nLFxuXG4gIHByb3BlcnRpZXM6IFtcbiAgICB7XG4gICAgICBjbGFzczogJ2ZvYW0udTIudmlldy5UYWJsZUNlbGxGb3JtYXR0ZXInLFxuICAgICAgbmFtZTogJ3RhYmxlQ2VsbEZvcm1hdHRlcicsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgdGhpcy5hZGQodmFsdWUubGFiZWwpXG4gICAgICB9XG4gICAgfVxuICBdXG59KTtcblxuXG5mb2FtLkNMQVNTKHtcbiAgcmVmaW5lczogJ2ZvYW0uY29yZS5GT2JqZWN0UHJvcGVydHknLFxuXG4gIHByb3BlcnRpZXM6IFsgWyAndGFibGVDZWxsRm9ybWF0dGVyJywgbnVsbCBdIF1cbn0pO1xuXG5cbmZvYW0uQ0xBU1Moe1xuICByZWZpbmVzOiAnZm9hbS5jb3JlLkN1cnJlbmN5JyxcblxuICBwcm9wZXJ0aWVzOiBbXG4gICAge1xuICAgICAgY2xhc3M6ICdmb2FtLnUyLnZpZXcuVGFibGVDZWxsRm9ybWF0dGVyJyxcbiAgICAgIG5hbWU6ICd0YWJsZUNlbGxGb3JtYXR0ZXInLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuc3RhcnQoKVxuICAgICAgICAgIC5zdHlsZSh7J3RleHQtYWxpZ24nOiAnbGVmdCcsICdwYWRkaW5nLXJpZ2h0JzogJzIwcHgnfSlcbiAgICAgICAgICAuYWRkKCckJyArICh2YWx1ZS8xMDApLnRvRml4ZWQoMikucmVwbGFjZSgvKFxcZCkoPz0oXFxkezN9KStcXC4pL2csICckMSwnKSlcbiAgICAgICAgLmVuZCgpO1xuICAgICAgfVxuICAgIH1cbiAgXVxufSk7XG5cblxuZm9hbS5DTEFTUyh7XG4gIHJlZmluZXM6ICdmb2FtLmNvcmUuRGF0ZScsXG5cbiAgcHJvcGVydGllczogW1xuICAgIHtcbiAgICAgIGNsYXNzOiAnZm9hbS51Mi52aWV3LlRhYmxlQ2VsbEZvcm1hdHRlcicsXG4gICAgICBuYW1lOiAndGFibGVDZWxsRm9ybWF0dGVyJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbihkYXRlKSB7XG4gICAgICAgIGlmICggZGF0ZSApIHRoaXMuYWRkKGRhdGUudG9Mb2NhbGVEYXRlU3RyaW5nKCkpO1xuICAgICAgfVxuICAgIH1cbiAgXVxufSk7XG5cblxuZm9hbS5DTEFTUyh7XG4gIHJlZmluZXM6ICdmb2FtLmNvcmUuRGF0ZVRpbWUnLFxuXG4gIHByb3BlcnRpZXM6IFtcbiAgICB7XG4gICAgICBjbGFzczogJ2ZvYW0udTIudmlldy5UYWJsZUNlbGxGb3JtYXR0ZXInLFxuICAgICAgbmFtZTogJ3RhYmxlQ2VsbEZvcm1hdHRlcicsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24oZGF0ZSkge1xuICAgICAgICBpZiAoIGRhdGUgKSB0aGlzLmFkZChkYXRlLnRvTG9jYWxlU3RyaW5nKCkpO1xuICAgICAgfVxuICAgIH1cbiAgXVxufSk7XG5cblxuZm9hbS5DTEFTUyh7XG4gIHBhY2thZ2U6ICdmb2FtLnUyLnZpZXcnLFxuICBuYW1lOiAnVGFibGVWaWV3JyxcbiAgZXh0ZW5kczogJ2ZvYW0udTIuRWxlbWVudCcsXG5cbiAgaW1wbGVtZW50czogWyAnZm9hbS5tbGFuZy5FeHByZXNzaW9ucycgXSxcblxuICByZXF1aXJlczogW1xuICAgICdmb2FtLnUyLnZpZXcuRWRpdENvbHVtbnNWaWV3JyxcbiAgICAnZm9hbS51Mi5tZC5PdmVybGF5RHJvcGRvd24nXG4gIF0sXG5cbiAgZXhwb3J0czogW1xuICAgICdjb2x1bW5zJyxcbiAgICAnc2VsZWN0aW9uJyxcbiAgICAnaG92ZXJTZWxlY3Rpb24nXG4gIF0sXG5cbiAgaW1wb3J0czogW1xuICAgICdkYmxjbGljaz8nLFxuICAgICdlZGl0UmVjb3JkPycsXG4gICAgJ3NlbGVjdGlvbj8gYXMgaW1wb3J0U2VsZWN0aW9uJ1xuICBdLFxuXG4gIGF4aW9tczogW1xuICAgIGZvYW0udTIuQ1NTLmNyZWF0ZSh7XG4gICAgICBjb2RlOiBmdW5jdGlvbiBDU1MoKSB7LypcbiAgICAgICAgXiB7XG4gICAgICAgICAgYm9yZGVyLXNwYWNpbmc6IDE0cHggOHB4O1xuICAgICAgICB9XG5cbiAgICAgICAgXiB0aCB7XG4gICAgICAgICAgdGV4dC1hbGlnbjogbGVmdDtcbiAgICAgICAgICB3aGl0ZS1zcGFjZTogbm93cmFwO1xuICAgICAgICB9XG5cbiAgICAgICAgXnJvdzpob3ZlciB7XG4gICAgICAgICAgYmFja2dyb3VuZDogI2VlZTtcbiAgICAgICAgICBjdXJzb3I6IHBvaW50ZXI7XG4gICAgICAgIH1cblxuICAgICAgICBec2VsZWN0ZWQge1xuICAgICAgICAgIGJhY2tncm91bmQ6ICNlZWU7XG4gICAgICAgIH1cblxuICAgICAgICBedmVydERvdHMge1xuICAgICAgICAgIGZvbnQtc2l6ZTogMjBweDtcbiAgICAgICAgICBmb250LXdlaWdodDogYm9sZDtcbiAgICAgICAgICBwYWRkaW5nLXJpZ2h0OiAxMnB4O1xuICAgICAgICB9XG5cbiAgICAgICAgXm5vc2VsZWN0IHtcbiAgICAgICAgICAtd2Via2l0LXRvdWNoLWNhbGxvdXQ6IG5vbmU7XG4gICAgICAgICAgLXdlYmtpdC11c2VyLXNlbGVjdDogbm9uZTtcbiAgICAgICAgICAta2h0bWwtdXNlci1zZWxlY3Q6IG5vbmU7XG4gICAgICAgICAgLW1vei11c2VyLXNlbGVjdDogbm9uZTtcbiAgICAgICAgICAtbXMtdXNlci1zZWxlY3Q6IG5vbmU7XG4gICAgICAgICAgdXNlci1zZWxlY3Q6IG5vbmU7XG4gICAgICAgIH1cbiAgICAqL31cbiAgICB9KVxuICBdLFxuXG4gIHByb3BlcnRpZXM6IFtcbiAgICB7XG4gICAgICBjbGFzczogJ0NsYXNzJyxcbiAgICAgIG5hbWU6ICdvZidcbiAgICB9LFxuICAgIHtcbiAgICAgIGNsYXNzOiAnZm9hbS5kYW8uREFPUHJvcGVydHknLFxuICAgICAgbmFtZTogJ2RhdGEnLFxuICAgICAgcG9zdFNldDogZnVuY3Rpb24oXywgZGF0YSkge1xuICAgICAgICBpZiAoICEgdGhpcy5vZiAmJiBkYXRhICkgdGhpcy5vZiA9IGRhdGEub2Y7XG4gICAgICB9XG4gICAgfSxcbiAgICB7XG4gICAgICBjbGFzczogJ2ZvYW0uZGFvLkRBT1Byb3BlcnR5JyxcbiAgICAgIG5hbWU6ICdvcmRlcmVkREFPJyxcbiAgICAgIGV4cHJlc3Npb246IGZ1bmN0aW9uKGRhdGEsIG9yZGVyKSB7XG4gICAgICAgIHJldHVybiBkYXRhID8gZGF0YS5vcmRlckJ5KG9yZGVyKSA6IGZvYW0uZGFvLk51bGxEQU8uY3JlYXRlKCk7XG4gICAgICB9XG4gICAgfSxcbiAgICB7XG4gICAgICBuYW1lOiAnb3JkZXInXG4gICAgfSxcbiAgICB7XG4gICAgICBuYW1lOiAnY29sdW1uc18nLFxuICAgICAgZXhwcmVzc2lvbjogZnVuY3Rpb24oY29sdW1ucywgb2YpIHtcbiAgICAgICAgdmFyIG9mID0gdGhpcy5vZjtcbiAgICAgICAgaWYgKCAhIG9mICkgcmV0dXJuIFtdO1xuXG4gICAgICAgIHJldHVybiBjb2x1bW5zLm1hcChmdW5jdGlvbihwKSB7XG4gICAgICAgICAgdmFyIGMgPSB0eXBlb2YgcCA9PSAnc3RyaW5nJyA/XG4gICAgICAgICAgICBvZi5nZXRBeGlvbUJ5TmFtZShwKSA6XG4gICAgICAgICAgICBwIDtcblxuICAgICAgICAgICBpZiAoICEgYyApIHtcbiAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCdVbmtub3duIHRhYmxlIGNvbHVtbjogJywgcCk7XG4gICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBjO1xuICAgICAgICB9KS5maWx0ZXIoZnVuY3Rpb24oYykgeyByZXR1cm4gYzsgfSk7XG4gICAgICB9XG4gICAgfSxcbiAgICB7XG4gICAgICBuYW1lOiAnY29sdW1ucycsXG4gICAgICBleHByZXNzaW9uOiBmdW5jdGlvbihvZikge1xuICAgICAgICB2YXIgb2YgPSB0aGlzLm9mO1xuICAgICAgICBpZiAoICEgb2YgKSByZXR1cm4gW107XG5cbiAgICAgICAgdmFyIHRhYmxlQ29sdW1ucyA9IG9mLmdldEF4aW9tQnlOYW1lKCd0YWJsZUNvbHVtbnMnKTtcblxuICAgICAgICBpZiAoIHRhYmxlQ29sdW1ucyApIHJldHVybiB0YWJsZUNvbHVtbnMuY29sdW1ucztcblxuICAgICAgICByZXR1cm4gb2YuZ2V0QXhpb21zQnlDbGFzcyhmb2FtLmNvcmUuUHJvcGVydHkpLlxuICAgICAgICAgICAgZmlsdGVyKGZ1bmN0aW9uKHApIHsgcmV0dXJuIHAudGFibGVDZWxsRm9ybWF0dGVyICYmICEgcC5oaWRkZW47IH0pLlxuICAgICAgICAgICAgbWFwKGZvYW0uY29yZS5Qcm9wZXJ0eS5OQU1FLmYpO1xuICAgICAgfVxuICAgIH0sXG4gICAge1xuICAgICAgY2xhc3M6ICdCb29sZWFuJyxcbiAgICAgIG5hbWU6ICdlZGl0Q29sdW1uc0VuYWJsZWQnLFxuICAgICAgdmFsdWU6IHRydWUsXG4gICAgICBkb2N1bWVudGF0aW9uOiAnU2V0IHRoaXMgdG8gdHJ1ZSB0byBsZXQgdGhlIHVzZXIgc2VsZWN0IGNvbHVtbnMuJ1xuICAgIH0sXG4gICAge1xuICAgICAgbmFtZTogJ2FzY0ljb24nLFxuICAgICAgZG9jdW1lbnRhdGlvbjogJ0hUTUwgZW50aXR5IHJlcHJlc2VudGluZyB1bmljb2RlIFVwLVBvaW50aW5nIFRyaWFuZ2xlJyxcbiAgICAgIGZhY3Rvcnk6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5FbnRpdHkuY3JlYXRlKHsgbmFtZTogJyM5NjUwJyB9KTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHtcbiAgICAgIG5hbWU6ICdkZXNjSWNvbicsXG4gICAgICBkb2N1bWVudGF0aW9uOiAnSFRNTCBlbnRpdHkgcmVwcmVzZW50aW5nIHVuaWNvZGUgRG93bi1Qb2ludGluZyBUcmlhbmdsZScsXG4gICAgICBmYWN0b3J5OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuRW50aXR5LmNyZWF0ZSh7IG5hbWU6ICcjOTY2MCcgfSk7XG4gICAgICB9XG4gICAgfSxcbiAgICB7XG4gICAgICBuYW1lOiAndmVydE1lbnVJY29uJyxcbiAgICAgIGRvY3VtZW50YXRpb246ICdIVE1MIGVudGl0eSByZXByZXNlbnRpbmcgdW5pY29kZSBWZXJ0aWNhbCBFbGxpcHNpcycsXG4gICAgICBmYWN0b3J5OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuRW50aXR5LmNyZWF0ZSh7IG5hbWU6ICcjODk0MicgfSk7XG4gICAgICB9XG4gICAgfSxcbiAgICB7XG4gICAgICBuYW1lOiAnc2VsZWN0aW9uJyxcbiAgICAgIGV4cHJlc3Npb246IGZ1bmN0aW9uKGltcG9ydFNlbGVjdGlvbikgeyByZXR1cm4gaW1wb3J0U2VsZWN0aW9uIHx8IG51bGw7IH0sXG4gICAgfSxcbiAgICAnaG92ZXJTZWxlY3Rpb24nLFxuICAgICdkcm9wZG93bk9yaWdpbicsXG4gICAgJ292ZXJsYXlPcmlnaW4nXG4gIF0sXG5cbiAgbWV0aG9kczogW1xuICAgIGZ1bmN0aW9uIHNvcnRCeShjb2x1bW4pIHtcbiAgICAgIHRoaXMub3JkZXIgPSB0aGlzLm9yZGVyID09PSBjb2x1bW4gP1xuICAgICAgICB0aGlzLkRFU0MoY29sdW1uKSA6XG4gICAgICAgIGNvbHVtbjtcbiAgICB9LFxuXG4gICAgZnVuY3Rpb24gY3JlYXRlQ29sdW1uU2VsZWN0aW9uKCkge1xuICAgICAgdmFyIGVkaXRvciA9IHRoaXMuRWRpdENvbHVtbnNWaWV3LmNyZWF0ZSh7XG4gICAgICAgIGNvbHVtbnM6IHRoaXMuY29sdW1ucyxcbiAgICAgICAgY29sdW1uc18kOiB0aGlzLmNvbHVtbnNfJCxcbiAgICAgICAgdGFibGU6IHRoaXMub2ZcbiAgICAgIH0pO1xuXG4gICAgICByZXR1cm4gdGhpcy5PdmVybGF5RHJvcGRvd24uY3JlYXRlKCkuYWRkKGVkaXRvcik7XG4gICAgfSxcblxuICAgIC8qKiBBZGRzIG9mZnNldCBmb3IgZWRpdCBjb2x1bW5zIG92ZXJsYXkgZHJvcGRvd25cbiAgICAgKiBPdmVybGF5RHJvcGRvd24gYWRkcyBlbGVtZW50IHRvIHRvcCByaWdodCBvZiBwYXJlbnQgY29udGFpbmVyLlxuICAgICAqIFdlIHdhbnQgdGhlIHRhYmxlIGRyb3Bkb3duIHRvIGFwcGVhciBiZWxvdyB0aGUgZHJvcGRvd24gaWNvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBwb3NpdGlvbk92ZXJsYXlEcm9wZG93bihjb2x1bW5TZWxlY3Rpb25FKSB7XG4gICAgICAvLyBEeW5hbWljIHBvc2l0aW9uIGNhbGN1bGF0aW9uXG4gICAgICB2YXIgb3JpZ2luICA9IHRoaXMuZHJvcGRvd25PcmlnaW4uZWwoKTtcbiAgICAgIHZhciBjdXJyZW50ID0gdGhpcy5vdmVybGF5T3JpZ2luLmVsKCk7XG5cbiAgICAgIHZhciBib3VuZGluZ0JveCA9IG9yaWdpbi5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgIHZhciBkcm9wZG93bk1lbnUgPSBjdXJyZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuXG4gICAgICBjb2x1bW5TZWxlY3Rpb25FLnN0eWxlKHsgdG9wOiBib3VuZGluZ0JveC50b3AgLSBkcm9wZG93bk1lbnUudG9wICsgJ3B4J30pO1xuICAgIH0sXG5cbiAgICBmdW5jdGlvbiBpbml0RSgpIHtcbiAgICAgIHZhciB2aWV3ID0gdGhpcztcbiAgICAgIHZhciBjb2x1bW5TZWxlY3Rpb25FO1xuXG4gICAgICBpZiAoIHZpZXcuZWRpdENvbHVtbnNFbmFibGVkICkge1xuICAgICAgICBjb2x1bW5TZWxlY3Rpb25FID0gdmlldy5jcmVhdGVDb2x1bW5TZWxlY3Rpb24oKTtcbiAgICAgICAgdGhpcy5zdGFydCgnZGl2JywgbnVsbCwgdGhpcy5vdmVybGF5T3JpZ2luJCkuYWRkKGNvbHVtblNlbGVjdGlvbkUpLmVuZCgpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLlxuICAgICAgICBhZGRDbGFzcyh0aGlzLm15Q2xhc3MoKSkuXG4gICAgICAgIGFkZENsYXNzKHRoaXMubXlDbGFzcyh0aGlzLm9mLmlkLnJlcGxhY2UoL1xcLi9nLCctJykpKS5cbiAgICAgICAgc2V0Tm9kZU5hbWUoJ3RhYmxlJykuXG4gICAgICAgIHN0YXJ0KCd0aGVhZCcpLlxuICAgICAgICAgIGFkZCh0aGlzLnNsb3QoZnVuY3Rpb24oY29sdW1uc18pIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLkUoJ3RyJykuXG4gICAgICAgICAgICAgIGZvckVhY2goY29sdW1uc18sIGZ1bmN0aW9uKGNvbHVtbikge1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhcnQoJ3RoJykuXG4gICAgICAgICAgICAgICAgICBhZGRDbGFzcyh2aWV3Lm15Q2xhc3MoJ3RoLScgKyBjb2x1bW4ubmFtZSkpLlxuICAgICAgICAgICAgICAgICAgY2FsbElmKGNvbHVtbi50YWJsZVdpZHRoLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdHlsZSh7d2lkdGg6IGNvbHVtbi50YWJsZVdpZHRofSk7XG4gICAgICAgICAgICAgICAgICB9KS5cbiAgICAgICAgICAgICAgICAgIG9uKCdjbGljaycsIGZ1bmN0aW9uKGUpIHsgdmlldy5zb3J0QnkoY29sdW1uKTsgfSkuXG4gICAgICAgICAgICAgICAgICBjYWxsKGNvbHVtbi50YWJsZUhlYWRlckZvcm1hdHRlciwgW2NvbHVtbl0pLlxuICAgICAgICAgICAgICAgICAgYWRkKCcgJywgdGhpcy5zbG90KGZ1bmN0aW9uKG9yZGVyKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjb2x1bW4gPT09IG9yZGVyID8gdmlldy5hc2NJY29uIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICh2aWV3LkRlc2MuaXNJbnN0YW5jZShvcmRlcikgJiYgb3JkZXIuYXJnMSA9PT0gY29sdW1uKSA/IHZpZXcuZGVzY0ljb24gOiAnJ1xuICAgICAgICAgICAgICAgICAgfSwgdmlldy5vcmRlciQpKS5cbiAgICAgICAgICAgICAgICBlbmQoKTtcbiAgICAgICAgICAgICAgfSkuXG4gICAgICAgICAgICAgIGNhbGwoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgaWYgKCB2aWV3LmVkaXRDb2x1bW5zRW5hYmxlZCApIHtcbiAgICAgICAgICAgICAgICAgIHRoaXMuc3RhcnQoJ3RoJykuXG4gICAgICAgICAgICAgICAgICAgIGFkZENsYXNzKHZpZXcubXlDbGFzcygndGgtZWRpdENvbHVtbnMnKSkuXG4gICAgICAgICAgICAgICAgICAgIG9uKCdjbGljaycsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICB2aWV3LnBvc2l0aW9uT3ZlcmxheURyb3Bkb3duKGNvbHVtblNlbGVjdGlvbkUpO1xuICAgICAgICAgICAgICAgICAgICAgIGNvbHVtblNlbGVjdGlvbkUub3BlbigpO1xuICAgICAgICAgICAgICAgICAgICB9KS5cbiAgICAgICAgICAgICAgICAgICAgYWRkKCcgJywgdmlldy52ZXJ0TWVudUljb24pLlxuICAgICAgICAgICAgICAgICAgICBhZGRDbGFzcyh2aWV3Lm15Q2xhc3MoJ3ZlcnREb3RzJykpLlxuICAgICAgICAgICAgICAgICAgICBhZGRDbGFzcyh2aWV3Lm15Q2xhc3MoJ25vc2VsZWN0JykpLlxuICAgICAgICAgICAgICAgICAgICB0YWcoJ2RpdicsIG51bGwsIHZpZXcuZHJvcGRvd25PcmlnaW4kKVxuICAgICAgICAgICAgICAgICAgLmVuZCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSlcbiAgICAgICAgICB9KSkuXG4gICAgICAgICAgYWRkKHRoaXMuc2xvdChmdW5jdGlvbihjb2x1bW5zXykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuXG4gICAgICAgICAgICAgIEUoJ3Rib2R5JykuXG4gICAgICAgICAgICAgIHNlbGVjdCh0aGlzLm9yZGVyZWREQU8kcHJveHksIGZ1bmN0aW9uKG9iaikge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLkUoJ3RyJykuXG4gICAgICAgICAgICAgICAgICBvbignbW91c2VvdmVyJywgZnVuY3Rpb24oKSB7IHZpZXcuaG92ZXJTZWxlY3Rpb24gPSBvYmo7IH0pLlxuICAgICAgICAgICAgICAgICAgY2FsbElmKHZpZXcuZGJsY2xpY2ssIGZ1bmN0aW9uKCkgeyB0aGlzLm9uKCdkYmxjbGljaycsIGZ1bmN0aW9uKCkgeyB2aWV3LmRibGNsaWNrICYmIHZpZXcuZGJsY2xpY2sob2JqKTsgfSk7IH0pLlxuICAgICAgICAgICAgICAgICAgb24oJ2NsaWNrJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHZpZXcuc2VsZWN0aW9uID0gb2JqO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIHZpZXcuaW1wb3J0U2VsZWN0aW9uJCApIHZpZXcuaW1wb3J0U2VsZWN0aW9uID0gb2JqO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIHZpZXcuZWRpdFJlY29yZCQgKSB2aWV3LmVkaXRSZWNvcmQob2JqKTtcbiAgICAgICAgICAgICAgICAgIH0pLlxuICAgICAgICAgICAgICAgICAgYWRkQ2xhc3Modmlldy5zbG90KGZ1bmN0aW9uKHNlbGVjdGlvbikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2VsZWN0aW9uICYmIGZvYW0udXRpbC5lcXVhbHMob2JqLmlkLCBzZWxlY3Rpb24uaWQpID9cbiAgICAgICAgICAgICAgICAgICAgICAgIHZpZXcubXlDbGFzcygnc2VsZWN0ZWQnKSA6ICcnO1xuICAgICAgICAgICAgICAgICAgfSkpLlxuICAgICAgICAgICAgICAgICAgYWRkQ2xhc3Modmlldy5teUNsYXNzKCdyb3cnKSkuXG4gICAgICAgICAgICAgICAgICBmb3JFYWNoKGNvbHVtbnNfLCBmdW5jdGlvbihjb2x1bW4pIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5cbiAgICAgICAgICAgICAgICAgICAgICBzdGFydCgndGQnKS5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxPbihjb2x1bW4udGFibGVDZWxsRm9ybWF0dGVyLCAnZm9ybWF0JywgW1xuICAgICAgICAgICAgICAgICAgICAgICAgICBjb2x1bW4uZiA/IGNvbHVtbi5mKG9iaikgOiBudWxsLCBvYmosIGNvbHVtblxuICAgICAgICAgICAgICAgICAgICAgICAgXSkuXG4gICAgICAgICAgICAgICAgICAgICAgZW5kKCk7XG4gICAgICAgICAgICAgICAgICB9KS5cbiAgICAgICAgICAgICAgICAgIGNhbGwoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICggdmlldy5lZGl0Q29sdW1uc0VuYWJsZWQgKSByZXR1cm4gdGhpcy50YWcoJ3RkJyk7XG4gICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICB9KSk7XG4gICAgfVxuICBdXG59KTtcbi8qKiBcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBUaGUgRk9BTSBBdXRob3JzLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKi9cblxuZm9hbS5DTEFTUyh7XG4gIHBhY2thZ2U6ICdmb2FtLnUyLnZpZXcnLFxuICBuYW1lOiAnRWRpdENvbHVtbnNWaWV3JyxcbiAgZXh0ZW5kczogJ2ZvYW0udTIuRWxlbWVudCcsXG5cbiAgcmVxdWlyZXM6IFtcbiAgICAnZm9hbS51Mi5tZC5DaGVja0JveCdcbiAgXSxcblxuICBwcm9wZXJ0aWVzOiBbXG4gICAge1xuICAgICAgbmFtZTogJ2NvbHVtbnMnXG4gICAgfSxcbiAgICB7XG4gICAgICBuYW1lOiAndGFibGUnXG4gICAgfSxcbiAgICB7XG4gICAgICBuYW1lOiAnY29sdW1uc18nXG4gICAgfSxcbiAgICB7XG4gICAgICBuYW1lOiAnc2VsZWN0ZWQnXG4gICAgfSxcbiAgICB7XG4gICAgICBjbGFzczogJ0Jvb2xlYW4nLFxuICAgICAgbmFtZTogJ2Rpc3BsYXlTb3J0ZWQnLFxuICAgICAgdmFsdWU6IGZhbHNlXG4gICAgfVxuICBdLFxuICBcbiAgbWV0aG9kczogW1xuICAgIGZ1bmN0aW9uIGluaXRFKCkge1xuICAgICAgLy8gaWYgKCB0aGlzLmRpc3BsYXlTb3J0ZWQgKSB7XG4gICAgICAvLyAgIC8vIFRPRE86IEhvdyBzaG91bGQgdGhpcyBibG9jayBiZSB0ZXN0ZWQ/XG4gICAgICAvLyAgIHZhciBwcm9wcyA9IHRoaXMucHJvcGVydGllcztcbiAgICAgIC8vICAgcHJvcHMgPSB0aGlzLnByb3BlcnRpZXMuc2xpY2UoKTtcbiAgICAgIC8vICAgcHJvcHMuc29ydChmdW5jdGlvbihhLCBiKSB7XG4gICAgICAvLyAgICAgcmV0dXJuIGEubGFiZWwudG9Mb3dlckNhc2UoKS5jb21wYXJlVG8oYi5sYWJlbC50b0xvd2VyQ2FzZSgpKTtcbiAgICAgIC8vICAgfSk7XG4gICAgICAvLyB9IGVsc2UgeyAuLi5cblxuICAgICAgdGhpcy5zZWxlY3RlZCA9IFtdXG5cbiAgICAgIGZvciAoIHZhciBpID0gMCA7IGkgPCB0aGlzLmNvbHVtbnNfLmxlbmd0aCA7IGkrKyApIHtcbiAgICAgICAgdmFyIGNiID0gdGhpcy5DaGVja0JveC5jcmVhdGUoe1xuICAgICAgICAgIGxhYmVsOiB0aGlzLmNvbHVtbnNfW2ldLmxhYmVsLFxuICAgICAgICAgIGRhdGE6IHRydWVcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy5zZWxlY3RlZC5wdXNoKGNiLmRhdGEkKTtcbiAgICAgICAgdmFyIG5hbWUgPSB0aGlzLmNvbHVtbnNfW2ldLm5hbWU7XG5cbiAgICAgICAgLy8gU3Vic2NyaWJlcyB1cGRhdGVUYWJsZSBsaXN0ZW5lciB0byBjaGVja2JveCBkYXRhXG4gICAgICAgIGNiLmRhdGEkLnN1Yih0aGlzLnVwZGF0ZVRhYmxlLmJpbmQodGhpcywgbmFtZSkpO1xuXG4gICAgICAgIHRoaXMuYWRkKGNiKTtcblxuICAgICAgICAvLyBFbnN1cmVzIGVhY2ggc2VsZWN0aW9uIGlzIG9uIGEgbmV3IGxpbmVcbiAgICAgICAgaWYgKCBpICE9IHRoaXMuY29sdW1uc18ubGVuZ3RoIC0gMSApIHRoaXMuc3RhcnQoJ2JyJykuZW5kKCk7XG4gICAgICB9XG4gICAgfVxuICBdLFxuXG4gIGxpc3RlbmVyczogW1xuICAgIGZ1bmN0aW9uIHVwZGF0ZVRhYmxlKGNoYW5nZWRQcm9wKSB7XG4gICAgICB2YXIgY29scyA9IFtdO1xuXG4gICAgICAvLyBpZiAoIHRoaXMuZGlzcGxheVNvcnRlZCApIHtcbiAgICAgIC8vICAgLy8gVE9ETzogSG93IHNob3VsZCB0aGlzIGJsb2NrIGJlIHRlc3RlZD9cbiAgICAgIC8vICAgb3V0ID0gdGhpcy5zZWxlY3RlZFByb3BlcnRpZXMuc2xpY2UoKTtcbiAgICAgIC8vICAgaWYgKCBudSAmJiAhc2VsZWN0ZWRbY2hhbmdlZFByb3AubmFtZV0gKSB7XG4gICAgICAvLyAgICAgb3V0LnB1c2goY2hhbmdlZFByb3ApO1xuICAgICAgLy8gICB9XG4gICAgICAvLyAgIGlmICggIW51ICYmIHNlbGVjdGVkW2NoYW5nZWRQcm9wLm5hbWVdICkge1xuICAgICAgLy8gICAgIG91dC5zcGxpY2Uob3V0LmluZGV4T2YoY2hhbmdlZFByb3ApLCAxKTtcbiAgICAgIC8vICAgfVxuICAgICAgLy8gfVxuICAgICAgLy8gZWxzZSB7IC4uLlxuXG4gICAgICBmb3IgKCB2YXIgaSA9IDAgOyBpIDwgdGhpcy5jb2x1bW5zLmxlbmd0aCA7IGkrKyApIHtcbiAgICAgICAgdmFyIGNiRGF0YSA9IHRoaXMuc2VsZWN0ZWRbaV0ub2JqLmRhdGE7XG4gICAgICAgIHZhciBpc0NvbFNob3duID0gdGhpcy5jb2x1bW5zXy5zb21lKGMgPT4gYy5uYW1lID09PSB0aGlzLmNvbHVtbnNbaV0pO1xuICAgICAgICB2YXIgY3VyUHJvcCA9IHRoaXMuY29sdW1uc1tpXTtcblxuICAgICAgICAvLyBEZXRlcm1pbmVzIGlmIHRoZSBjdXJQcm9wIGlzIHRoZSBvbmUgd2hpY2ggaGFzIGNoYW5nZWQsXG4gICAgICAgIC8vIGlmIHNvIGFkZHMgY29sIGlmIGNiIGlzIGNoZWNrZWQuIE90aGVyd2lzZSBpZiBjdXJQcm9wIGhhc24ndFxuICAgICAgICAvLyBjaGFuZ2VkLCB0aGVuIGNoZWNrcyBpZiBpdCB3YXMgcHJldmlvdXNseSBzaG93biwgaWYgc28sIGtlZXBzIGluIHZpZXcuXG4gICAgICAgIGlmICggKChjaGFuZ2VkUHJvcCA9PSBjdXJQcm9wKSAmJiBjYkRhdGEpIHx8XG4gICAgICAgICAgICAgKChjaGFuZ2VkUHJvcCAhPSBjdXJQcm9wKSAmJiBpc0NvbFNob3duKSApIHtcbiAgICAgICAgICAvLyBHZXRzIHRoZSB0YWJsZSBjb2x1bW4gZnJvbSB0aGUgY29sdW1uIG5hbWUsIGFuZCBwdXNoZXMgdG8gY29scyBhcnJheVxuICAgICAgICAgIGNvbHMucHVzaCh0aGlzLnRhYmxlLmdldEF4aW9tQnlOYW1lKGN1clByb3ApKVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHRoaXMuY29sdW1uc18gPSBjb2xzO1xuICAgIH1cbiAgXVxufSk7XG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBUaGUgRk9BTSBBdXRob3JzLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKi9cblxuZm9hbS5DTEFTUyh7XG4gIHBhY2thZ2U6ICdmb2FtLnUyLm1kJyxcbiAgbmFtZTogJ092ZXJsYXlEcm9wZG93bicsXG4gIGV4dGVuZHM6ICdmb2FtLnUyLkVsZW1lbnQnLFxuXG4gIGltcG9ydHM6IFtcbiAgICAnd2luZG93J1xuICBdLFxuXG4gIGV4cG9ydHM6IFtcbiAgICAnYXMgZHJvcGRvd24nXG4gIF0sXG5cbiAgZG9jdW1lbnRhdGlvbjogJ0EgcG9wdXAgb3ZlcmxheSB0aGF0IGdyb3dzIGZyb20gdGhlIHRvcC1yaWdodCBjb3JuZXIgb2YgJyArXG4gICAgICAnaXRzIGNvbnRhaW5lci4gVXNlZnVsIGZvciBlLmcuIFwiLi4uXCIgb3ZlcmZsb3cgbWVudXMgaW4gYWN0aW9uIGJhcnMuICcgK1xuICAgICAgJ0p1c3QgJCRET0N7cmVmOlwiLmFkZFwifSB0aGluZ3MgdG8gdGhpcyBjb250YWluZXIuJyxcblxuICBjc3M6IGBcbiAgICBeb3ZlcmxheSB7XG4gICAgICBwb3NpdGlvbjogZml4ZWQ7XG4gICAgICB6LWluZGV4OiAxMDA5O1xuICAgIH1cblxuICAgIF5jb250YWluZXIge1xuICAgICAgcG9zaXRpb246IGFic29sdXRlO1xuICAgICAgcmlnaHQ6IDA7XG4gICAgICB0b3A6IDA7XG4gICAgICB6LWluZGV4OiAxMDA7XG4gICAgfVxuXG4gICAgXiB7XG4gICAgICBiYWNrZ3JvdW5kOiB3aGl0ZTtcbiAgICAgIGJveC1zaGFkb3c6IDAgMXB4IDNweCByZ2JhKDAsIDAsIDAsIDAuMzgpO1xuICAgICAgZGlzcGxheTogYmxvY2s7XG4gICAgICBmb250LXNpemU6IDEzcHg7XG4gICAgICBmb250LXdlaWdodDogNDAwO1xuICAgICAgb3ZlcmZsb3cteDogaGlkZGVuO1xuICAgICAgb3ZlcmZsb3cteTogaGlkZGVuO1xuICAgICAgcG9zaXRpb246IGFic29sdXRlO1xuICAgICAgd2lkdGg6IDEyNXB4O1xuICAgICAgcGFkZGluZzogMTBweDtcbiAgICAgIHBhZGRpbmctYm90dG9tOiAtMjBweDtcbiAgICAgIG1hcmdpbi1ib3R0b206IC0yMHB4O1xuICAgICAgcmlnaHQ6IDNweDtcbiAgICAgIHRvcDogNHB4O1xuICAgICAgdHJhbnNpdGlvbjogaGVpZ2h0IDAuMjVzIGN1YmljLWJlemllcigwLCAuMywgLjgsIDEpO1xuICAgICAgei1pbmRleDogMTAxMDtcbiAgICB9XG5cbiAgICBeb3BlbiB7XG4gICAgICBvdmVyZmxvdy15OiBhdXRvO1xuICAgIH1cblxuICAgIF56ZXJvT3ZlcmxheSB7XG4gICAgICB0b3A6IDA7XG4gICAgICBib3R0b206IDA7XG4gICAgICBsZWZ0OiAwO1xuICAgICAgcmlnaHQ6IDA7XG4gICAgfVxuXG4gICAgXmluaXRpYWxPdmVybGF5IHtcbiAgICAgIHRvcDogaW5pdGlhbDtcbiAgICAgIGJvdHRvbTogaW5pdGlhbDtcbiAgICAgIGxlZnQ6IGluaXRpYWw7XG4gICAgICByaWdodDogaW5pdGlhbDtcbiAgICB9XG5cbiAgICBecGFyZW50cyB7XG4gICAgICB6LWluZGV4OiAxMDAwICFpbXBvcnRhbnQ7XG4gICAgfVxuICBgLFxuXG4gIGNvbnN0YW50czoge1xuICAgIEJPVFRPTV9PRkZTRVQ6IC0yNSxcbiAgfSxcblxuICBwcm9wZXJ0aWVzOiBbXG4gICAge1xuICAgICAgY2xhc3M6ICdGbG9hdCcsXG4gICAgICBuYW1lOiAnaGVpZ2h0JyxcbiAgICAgIHZhbHVlOiAwXG4gICAgfSxcbiAgICB7XG4gICAgICBjbGFzczogJ0Jvb2xlYW4nLFxuICAgICAgbmFtZTogJ29wZW5lZCcsXG4gICAgICBkb2N1bWVudGF0aW9uOiAnVHJ1ZSB3aGVuIHRoZSBvdmVybGF5IGhhcyBiZWVuIGNvbW1hbmRlZCB0byBiZSBvcGVuLiAnICtcbiAgICAgICAgICAnSXQgbWlnaHQgc3RpbGwgYmUgYW5pbWF0aW5nOyBzZWUgJCRET0N7cmVmOlwiLmFuaW1hdGlvbkNvbXBsZXRlXCJ9LicsXG4gICAgfSxcbiAgICB7XG4gICAgICBjbGFzczogJ0Jvb2xlYW4nLFxuICAgICAgbmFtZTogJ2FuaW1hdGlvbkNvbXBsZXRlJyxcbiAgICAgIGRvY3VtZW50YXRpb246ICdUcnVlIHdoZW4gYW4gYW5pbWF0aW9uIGlzIHJ1bm5pbmcuIFRoZSBvdmVybGF5IGhhc25cXCd0ICcgK1xuICAgICAgICAgICdyZWFsbHkgcmVhY2hlZCB0aGUgc3RhdGUgY29tbWFuZGVkIGJ5ICQkRE9De3JlZjpcIi5vcGVuZWRcIn0gdW50aWwgJyArXG4gICAgICAgICAgJ3RoaXMgaXMgdHJ1ZS4nLFxuICAgICAgdmFsdWU6IHRydWVcbiAgICB9LFxuICAgIHtcbiAgICAgIG5hbWU6ICdkcm9wZG93bkVfJyxcbiAgICAgIGZhY3Rvcnk6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5FKCdkcm9wZG93bicpO1xuICAgICAgfVxuICAgIH0sXG4gICAge1xuICAgICAgbmFtZTogJ2FkZFRvU2VsZl8nLFxuICAgICAgdmFsdWU6IGZhbHNlXG4gICAgfVxuICBdLFxuXG4gIG1ldGhvZHM6IFtcbiAgICBmdW5jdGlvbiBhZGQoKSB7XG4gICAgICAvLyBUT0RPOiBSZXBsYWNlIHdpdGggY29udGVudCBAa2dyXG4gICAgICBpZiAoIHRoaXMuYWRkVG9TZWxmXyApIHtcbiAgICAgICAgdGhpcy5TVVBFUi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5kcm9wZG93bkVfLmFkZC5hcHBseSh0aGlzLmRyb3Bkb3duRV8sIGFyZ3VtZW50cyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBmdW5jdGlvbiBvcGVuKCkge1xuICAgICAgaWYgKCB0aGlzLm9wZW5lZCApIHJldHVybjtcblxuICAgICAgdGhpcy5vbk9wZW5TdGFydCgpO1xuXG4gICAgICB0aGlzLmFuaW1hdGlvbkNvbXBsZXRlID0gZmFsc2U7XG4gICAgICB0aGlzLm9wZW5lZCA9IHRydWU7XG4gICAgICB0aGlzLmRyb3Bkb3duRV8uc3R5bGUoeyBoZWlnaHQ6IHRoaXMuZ2V0RnVsbEhlaWdodCgpICsgJ3B4JyB9KTtcbiAgICB9LFxuXG4gICAgZnVuY3Rpb24gY2xvc2UoKSB7XG4gICAgICBpZiAoICEgdGhpcy5vcGVuZWQgKSByZXR1cm47XG4gICAgICB0aGlzLmhlaWdodCA9IDA7XG4gICAgICB0aGlzLmFuaW1hdGlvbkNvbXBsZXRlID0gZmFsc2U7XG4gICAgICB0aGlzLm9wZW5lZCA9IGZhbHNlO1xuICAgICAgdGhpcy5kcm9wZG93bkVfLnN0eWxlKHsgaGVpZ2h0OiAwICsgJ3B4JyB9KTtcbiAgICB9LFxuXG4gICAgZnVuY3Rpb24gZ2V0RnVsbEhlaWdodCgpIHtcbiAgICAgIGlmICggdGhpcy5zdGF0ZSAhPT0gdGhpcy5MT0FERUQgKSByZXR1cm4gMDtcblxuICAgICAgdmFyIG15U3R5bGUgPSB0aGlzLndpbmRvdy5nZXRDb21wdXRlZFN0eWxlKHRoaXMuZHJvcGRvd25FXy5lbCgpKTtcblxuICAgICAgdmFyIGZpcnN0ID0gdGhpcy5kcm9wZG93bkVfLmNoaWxkcmVuWzBdLmVsKCk7XG4gICAgICB2YXIgdG9wID0gZmlyc3Qub2Zmc2V0VG9wO1xuICAgICAgdmFyIGxhc3QgPSB0aGlzLmRyb3Bkb3duRV8uY2hpbGRyZW5bdGhpcy5kcm9wZG93bkVfLmNoaWxkcmVuLmxlbmd0aCAtIDFdXG4gICAgICAgICAgLmVsKCk7XG4gICAgICB2YXIgbWFyZ2luID0gcGFyc2VJbnQoXG4gICAgICAgICAgdGhpcy53aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShsYXN0KVsnbWFyZ2luLWJvdHRvbSddKTtcbiAgICAgIGlmICggTnVtYmVyLmlzTmFOKG1hcmdpbikgKSBtYXJnaW4gPSAwO1xuICAgICAgdmFyIGJvdHRvbSA9IGxhc3Qub2Zmc2V0VG9wICsgbGFzdC5vZmZzZXRIZWlnaHQgKyBtYXJnaW47XG5cbiAgICAgIHZhciBjaGlsZHJlbkhlaWdodCA9IGJvdHRvbSAtIHRvcDtcbiAgICAgIHZhciBtYXhIZWlnaHQgPSB0aGlzLndpbmRvdy5pbm5lckhlaWdodCAtXG4gICAgICAgICAgICB0aGlzLmRyb3Bkb3duRV8uZWwoKS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS50b3AgK1xuICAgICAgICAgICAgdGhpcy5CT1RUT01fT0ZGU0VUO1xuXG4gICAgICByZXR1cm4gTWF0aC5taW4oY2hpbGRyZW5IZWlnaHQsIG1heEhlaWdodCk7XG4gICAgfSxcblxuICAgIGZ1bmN0aW9uIGluaXRFKCkge1xuICAgICAgdGhpcy5hZGRUb1NlbGZfID0gdHJ1ZTtcbiAgICAgIHRoaXMuYWRkQ2xhc3ModGhpcy5teUNsYXNzKCdjb250YWluZXInKSk7XG4gICAgICB2YXIgdmlldyA9IHRoaXM7XG5cbiAgICAgIHRoaXMuYWRkQ2xhc3ModGhpcy5zbG90KGZ1bmN0aW9uKG9wZW4sIGFuaW1hdGlvbkNvbXBsZXRlKSB7XG4gICAgICAgIHRoaXMuc2hvd24gPSBvcGVuIHx8ICEgYW5pbWF0aW9uQ29tcGxldGU7XG4gICAgICB9LCB0aGlzLm9wZW5lZCQsIHRoaXMuYW5pbWF0aW9uQ29tcGxldGUkKSk7XG5cbiAgICAgIHRoaXMuc3RhcnQoJ2Ryb3Bkb3duLW92ZXJsYXknKVxuICAgICAgICAuYWRkQ2xhc3ModGhpcy5teUNsYXNzKCdvdmVybGF5JykpXG4gICAgICAgIC5hZGRDbGFzcyh0aGlzLnNsb3QoZnVuY3Rpb24ob3Blbikge1xuICAgICAgICAgIHJldHVybiBvcGVuID8gdmlldy5teUNsYXNzKCd6ZXJvT3ZlcmxheScpIDpcbiAgICAgICAgICAgICAgdmlldy5teUNsYXNzKCdpbml0aWFsT3ZlcmxheScpO1xuICAgICAgICB9LCB0aGlzLm9wZW5lZCQpKVxuICAgICAgICAub24oJ2NsaWNrJywgdGhpcy5vbkNhbmNlbClcbiAgICAgIC5lbmQoKTtcblxuICAgICAgdGhpcy5kcm9wZG93bkVfLmFkZENsYXNzKHRoaXMubXlDbGFzcygpKS5zdHlsZSh7aGVpZ2h0OiAnMHB4J30pXG4gICAgICAgIC5hZGRDbGFzcyh0aGlzLnNsb3QoZnVuY3Rpb24ob3BlbmVkLCBhbmltYXRpb25Db21wbGV0ZSkge1xuICAgICAgICAgIHZhciBvcGVuQ29tcGxldGUgPSBvcGVuZWQgJiYgYW5pbWF0aW9uQ29tcGxldGU7XG4gICAgICAgICAgcmV0dXJuIG9wZW5Db21wbGV0ZSA/IHRoaXMubXlDbGFzcygnb3BlbicpIDogJyc7XG4gICAgICAgIH0sIHRoaXMub3BlbmVkJCwgdGhpcy5hbmltYXRpb25Db21wbGV0ZSQpKVxuICAgICAgICAub24oJ3RyYW5zaXRpb25lbmQnLCB0aGlzLm9uVHJhbnNpdGlvbkVuZClcbiAgICAgICAgLm9uKCdtb3VzZWxlYXZlJywgdGhpcy5vbk1vdXNlTGVhdmUpXG4gICAgICAgIC5vbignY2xpY2snLCB0aGlzLm9uQ2xpY2spO1xuXG4gICAgICB0aGlzLmFkZCh0aGlzLmRyb3Bkb3duRV8pO1xuXG4gICAgICB0aGlzLmFkZFRvU2VsZl8gPSBmYWxzZTtcbiAgICB9XG4gIF0sXG5cbiAgbGlzdGVuZXJzOiBbXG4gICAgZnVuY3Rpb24gb25DYW5jZWwoKSB7XG4gICAgICB0aGlzLmNsb3NlKCk7XG4gICAgfSxcblxuICAgIGZ1bmN0aW9uIG9uVHJhbnNpdGlvbkVuZCgpIHtcbiAgICAgIHRoaXMuYW5pbWF0aW9uQ29tcGxldGUgPSB0cnVlO1xuICAgICAgaWYgKCF0aGlzLm9wZW5lZCkgdGhpcy5vbkNsb3NlQ29tcGxldGUoKTtcbiAgICB9LFxuXG4gICAgZnVuY3Rpb24gb25Nb3VzZUxlYXZlKGUpIHtcbiAgICAgIGNvbnNvbGUuYXNzZXJ0KGUudGFyZ2V0ID09PSB0aGlzLmRyb3Bkb3duRV8uZWwoKSxcbiAgICAgICAgICAnbW91c2VsZWF2ZSBzaG91bGQgb25seSBmaXJlIG9uIHRoaXMsIG5vdCBvbiBjaGlsZHJlbicpO1xuICAgICAgdGhpcy5jbG9zZSgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBQcmV2ZW50IGNsaWNrcyBpbnNpZGUgdGhlIGRyb3Bkb3duIGZyb20gY2xvc2luZyBpdC5cbiAgICAgKiBCbG9jayB0aGVtIGJlZm9yZSB0aGV5IHJlYWNoIHRoZSBvdmVybGF5LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG9uQ2xpY2soZSkge1xuICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICB9LFxuXG4gICAgZnVuY3Rpb24gb25PcGVuU3RhcnQoKSB7XG4gICAgICB2YXIgcGFyZW50ID0gdGhpcy5lbCgpLnBhcmVudEVsZW1lbnQ7XG4gICAgICB2YXIgcGFyZW50Q2xhc3MgPSB0aGlzLm15Q2xhc3MoJ3BhcmVudHMnKTtcbiAgICAgIHdoaWxlIChwYXJlbnQpIHtcbiAgICAgICAgcGFyZW50LmNsYXNzTGlzdC5hZGQocGFyZW50Q2xhc3MpO1xuICAgICAgICBwYXJlbnQgPSBwYXJlbnQucGFyZW50RWxlbWVudDtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgZnVuY3Rpb24gb25DbG9zZUNvbXBsZXRlKCkge1xuICAgICAgdmFyIHBhcmVudCA9IHRoaXMuZWwoKS5wYXJlbnRFbGVtZW50O1xuICAgICAgdmFyIHBhcmVudENsYXNzID0gdGhpcy5teUNsYXNzKCdwYXJlbnRzJyk7XG4gICAgICB3aGlsZSAocGFyZW50KSB7XG4gICAgICAgIHBhcmVudC5jbGFzc0xpc3QucmVtb3ZlKHBhcmVudENsYXNzKTtcbiAgICAgICAgcGFyZW50ID0gcGFyZW50LnBhcmVudEVsZW1lbnQ7XG4gICAgICB9XG4gICAgfVxuICBdXG59KTtcbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IFRoZSBGT0FNIEF1dGhvcnMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqL1xuXG4gZm9hbS5DTEFTUyh7XG4gIHBhY2thZ2U6ICdmb2FtLnUyLnZpZXcnLFxuICBuYW1lOiAnU2Nyb2xsVGFibGVWaWV3JyxcbiAgZXh0ZW5kczogJ2ZvYW0udTIuRWxlbWVudCcsXG5cbiAgcmVxdWlyZXM6IFtcbiAgICAnZm9hbS5kYW8uRm5TaW5rJyxcbiAgICAnZm9hbS5ncmFwaGljcy5TY3JvbGxDVmlldycsXG4gICAgJ2ZvYW0ubWxhbmcuc2luay5Db3VudCcsXG4gICAgJ2ZvYW0udTIudmlldy5UYWJsZVZpZXcnXG4gIF0sXG5cbiAgcHJvcGVydGllczogW1xuICAgIHtcbiAgICAgIGNsYXNzOiAnZm9hbS5kYW8uREFPUHJvcGVydHknLFxuICAgICAgbmFtZTogJ2RhdGEnXG4gICAgfSxcbiAgICB7XG4gICAgICBjbGFzczogJ0ludCcsXG4gICAgICBuYW1lOiAnbGltaXQnLFxuICAgICAgdmFsdWU6IDE4LFxuICAgICAgLy8gVE9ETyBtYWtlIHRoaXMgYSBmdW5jaXRvbiBvZiB0aGUgaGVpZ2h0LlxuICAgIH0sXG4gICAge1xuICAgICAgY2xhc3M6ICdJbnQnLFxuICAgICAgbmFtZTogJ3NraXAnLFxuICAgIH0sXG4gICAge1xuICAgICAgY2xhc3M6ICdmb2FtLmRhby5EQU9Qcm9wZXJ0eScsXG4gICAgICBuYW1lOiAnc2Nyb2xsZWREYW8nLFxuICAgICAgZXhwcmVzc2lvbjogZnVuY3Rpb24oZGF0YSwgbGltaXQsIHNraXApIHtcbiAgICAgICAgcmV0dXJuIGRhdGEubGltaXQobGltaXQpLnNraXAoc2tpcCk7XG4gICAgICB9LFxuICAgIH0sXG4gICAgJ2NvbHVtbnMnLFxuICAgIHtcbiAgICAgIGNsYXNzOiAnSW50JyxcbiAgICAgIG5hbWU6ICdkYW9Db3VudCdcbiAgICB9LFxuICAgICdzZWxlY3Rpb24nXG4gIF0sXG5cbiAgbWV0aG9kczogW1xuICAgIGZ1bmN0aW9uIGluaXQoKSB7XG4gICAgICB0aGlzLm9uRGV0YWNoKHRoaXMuZGF0YSRwcm94eS5saXN0ZW4odGhpcy5GblNpbmsuY3JlYXRlKHtmbjp0aGlzLm9uRGFvVXBkYXRlfSkpKTtcbiAgICAgIHRoaXMub25EYW9VcGRhdGUoKTtcbiAgICB9LFxuXG4gICAgZnVuY3Rpb24gaW5pdEUoKSB7XG4gICAgICAvLyBUT0RPIHByb2JhYmx5IHNob3VsZG4ndCBiZSB1c2luZyBhIHRhYmxlLlxuICAgICAgdGhpcy5zdGFydCgndGFibGUnKS5cbiAgICAgICAgb24oJ3doZWVsJywgdGhpcy5vbldoZWVsKS5cbiAgICAgICAgc3RhcnQoJ3RyJykuXG4gICAgICAgICAgc3RhcnQoJ3RkJykuXG4gICAgICAgICAgICBzdHlsZSh7ICd2ZXJ0aWNhbC1hbGlnbic6ICd0b3AnIH0pLlxuICAgICAgICAgICAgc3RhcnQodGhpcy5UYWJsZVZpZXcsIHtkYXRhJDogdGhpcy5zY3JvbGxlZERhbyQsIGNvbHVtbnM6IHRoaXMuY29sdW1ucywgc2VsZWN0aW9uJDogdGhpcy5zZWxlY3Rpb24kfSkuXG4gICAgICAgICAgICBlbmQoKS5cbiAgICAgICAgICBlbmQoKS5cbiAgICAgICAgICBzdGFydCgndGQnKS5zdHlsZSh7ICd2ZXJ0aWNhbC1hbGlnbic6ICd0b3AnIH0pLlxuICAgICAgICAgICAgYWRkKHRoaXMuU2Nyb2xsQ1ZpZXcuY3JlYXRlKHtcbiAgICAgICAgICAgICAgdmFsdWUkOiB0aGlzLnNraXAkLFxuICAgICAgICAgICAgICBleHRlbnQkOiB0aGlzLmxpbWl0JCxcbiAgICAgICAgICAgICAgaGVpZ2h0OiA0MCoxOCs0MSwgLy8gVE9ETyB1c2Ugd2luZG93IGhlaWdodC5cbiAgICAgICAgICAgICAgd2lkdGg6IDE1LFxuICAgICAgICAgICAgICBzaXplJDogdGhpcy5kYW9Db3VudCQsXG4gICAgICAgICAgICB9KSkuXG4gICAgICAgICAgZW5kKCkuXG4gICAgICAgIGVuZCgpLlxuICAgICAgZW5kKCk7XG4gICAgfVxuICBdLFxuXG4gIGxpc3RlbmVyczogW1xuICAgIHtcbiAgICAgIG5hbWU6ICdvbldoZWVsJyxcbiAgICAgIGNvZGU6IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgdmFyIG5lZ2F0aXZlID0gZS5kZWx0YVkgPCAwO1xuICAgICAgICAvLyBDb252ZXJ0IHRvIHJvd3MsIHJvdW5kaW5nIHVwLiAoVGhlcmVmb3JlIG1pbnVtdW0gMS4pXG4gICAgICAgIHZhciByb3dzID0gTWF0aC5jZWlsKE1hdGguYWJzKGUuZGVsdGFZKSAvIC8qc2VsZi5yb3dIZWlnaHQqLyA0MCk7XG4gICAgICAgIHRoaXMuc2tpcCArPSBuZWdhdGl2ZSA/IC1yb3dzIDogcm93cztcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgfVxuICAgIH0sXG4gICAge1xuICAgICAgLy8gVE9ETyBBdm9pZCBvbkRhb1VwZGF0ZSBhcHByb2FjaGVzLlxuICAgICAgbmFtZTogJ29uRGFvVXBkYXRlJyxcbiAgICAgIGlzRnJhbWVkOiB0cnVlLFxuICAgICAgY29kZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgdGhpcy5kYXRhJHByb3h5LnNlbGVjdCh0aGlzLkNvdW50LmNyZWF0ZSgpKS50aGVuKGZ1bmN0aW9uKHMpIHtcbiAgICAgICAgICBzZWxmLmRhb0NvdW50ID0gcy52YWx1ZTtcbiAgICAgICAgfSlcbiAgICAgIH0sXG4gICAgfSxcbiAgXVxufSk7XG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBUaGUgRk9BTSBBdXRob3JzLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5mb2FtLkNMQVNTKHtcbiAgcGFja2FnZTogJ2ZvYW0udTIudmlldycsXG4gIG5hbWU6ICdTY3JvbGxEQU9WaWV3JyxcbiAgZXh0ZW5kczogJ2ZvYW0udTIuRWxlbWVudCcsXG4gIGltcGxlbWVudHM6IFsgJ2ZvYW0ubWxhbmcuRXhwcmVzc2lvbnMnIF0sXG5cbiAgZG9jdW1lbnRhdGlvbjogJ0EgRE9NLWJhc2VkIG5hdGl2ZSBzY3JvbGxpbmcgdmlldyBvdmVyIGZvciBhIERBTy4nLFxuXG4gIGNzczogYFxuICAgIF4ge1xuICAgICAgbWFyZ2luOiAwO1xuICAgICAgcGFkZGluZzogMDtcbiAgICAgIG92ZXJmbG93LXg6IGhpZGRlbjtcbiAgICAgIG92ZXJmbG93LXk6IHNjcm9sbDtcbiAgICAgIC13ZWJraXQtb3ZlcmZsb3ctc2Nyb2xsaW5nOiB0b3VjaDtcbiAgICAgIHdpZHRoOiAxMDAlO1xuICAgICAgaGVpZ2h0OiAxMDAlO1xuICAgICAgcG9zaXRpb246IGFic29sdXRlO1xuICAgICAgYm94LXNpemluZzogYm9yZGVyLWJveDtcbiAgICAgIGNvbnRhaW46IGxheW91dDtcbiAgICAgIHdpbGwtY2hhbmdlOiB0cmFuc2Zvcm07XG4gICAgfVxuICBgLFxuXG4gIHJlcXVpcmVzOiBbXG4gICAgJ2ZvYW0uZGFvLlF1aWNrU2luaycsXG4gICAgJ2ZvYW0udTIuVmlld1NwZWMnXG4gIF0sXG4gIGltcG9ydHM6IFtcbiAgICAnc2VsZWN0aW9uIGFzIGltcG9ydGVkU2VsZWN0aW9uJyxcbiAgICAnc2VsZWN0aW9uRW5hYmxlZCBhcyBpbXBvcnRlZFNlbGVjdGlvbkVuYWJsZWQnXG4gIF0sXG4gIC8vIFByb3ZpZGUgbW9zdCBzdGF0ZSB0byBpbm5lciBjb250cm9sbGVyIGFuZCB2aWV3cy5cbiAgZXhwb3J0czogW1xuICAgICdhbmNob3JEQU9JZHhfJyxcbiAgICAnYW5jaG9yUm93SWR4XycsXG4gICAgJ2JhdGNoU2l6ZScsXG4gICAgJ2NvdW50XycsXG4gICAgJ2RhdGEnLFxuICAgICdtb2ROdW1Sb3dzXycsXG4gICAgJ25lZ2F0aXZlUnVud2F5JyxcbiAgICAnbnVtUm93cycsXG4gICAgJ3Bvc2l0aXZlUnVud2F5JyxcbiAgICAncm93c18nLFxuICAgICdyb3dGb3JtYXR0ZXInLFxuICAgICdzZWxlY3Rpb24nLFxuICAgICdzZWxlY3Rpb25FbmFibGVkJ1xuICBdLFxuXG4gIHByb3BlcnRpZXM6IFtcbiAgICB7XG4gICAgICBjbGFzczogJ2ZvYW0uZGFvLkRBT1Byb3BlcnR5JyxcbiAgICAgIG5hbWU6ICdkYXRhJyxcbiAgICAgIGRvY3VtZW50YXRpb246ICdUaGUgREFPIHRvIHRoZSBmdWxsIHNldCBvZiBkYXRhIHZpc2libGUgdG8gdGhpcyB2aWV3LicsXG4gICAgICBwb3N0U2V0OiBmdW5jdGlvbihvbGQsIG51KSB7XG4gICAgICAgIGlmICggb2xkID09PSBudSApIHJldHVybjtcbiAgICAgICAgdGhpcy5saXN0ZW5TdWJfICYmIHRoaXMubGlzdGVuU3ViXy5kZXRhY2goKTtcbiAgICAgICAgaWYgKCAhIG51ICkgcmV0dXJuO1xuXG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgc2VsZi5saXN0ZW5TdWJfID0gbnUubGlzdGVuKHRoaXMuUXVpY2tTaW5rLmNyZWF0ZSh7XG4gICAgICAgICAgLy8gVE9ETyhtYXJrZGl0dG1lcik6IE1vZGVsIHRoaXM/XG4gICAgICAgICAgcmVzZXRGbjogZnVuY3Rpb24oKSB7IHNlbGYuY291bnRSZWNvcmRzXygpOyB9XG4gICAgICAgIH0pKTtcbiAgICAgICAgc2VsZi5jb3VudFJlY29yZHNfKCk7XG4gICAgICB9LFxuICAgICAgcmVxdWlyZWQ6IHRydWVcbiAgICB9LFxuICAgIHtcbiAgICAgIGNsYXNzOiAnRk9iamVjdFByb3BlcnR5JyxcbiAgICAgIG9mOiAnZm9hbS51Mi5Sb3dGb3JtYXR0ZXInLFxuICAgICAgbmFtZTogJ3Jvd0Zvcm1hdHRlcicsXG4gICAgICBkb2N1bWVudGF0aW9uOiBgZGF0YSA9PiBIVE1MLW1hcmt1cC1zdHJpbmcgZm9ybWF0dGVyIGZvciBpbmRpdmlkdWFsIHJvd3MuXG4gICAgICAgICAgVGhpcyBzdHJhdGVneSBpcyB1c2VkIGluc3RlYWQgb2YgRWxlbWVudHMgdG8gbWF4aW1pemUgc2Nyb2xsXG4gICAgICAgICAgcGVyZm9ybWFuY2UuYCxcbiAgICAgIHByZVNldDogZnVuY3Rpb24oXywgbnUpIHtcbiAgICAgICAgcmV0dXJuIG51ICYmIG51LmNsb25lID8gbnUuY2xvbmUodGhpcykgOiBudTtcbiAgICAgIH0sXG4gICAgICByZXF1aXJlZDogdHJ1ZVxuICAgIH0sXG4gICAge1xuICAgICAgY2xhc3M6ICdJbnQnLFxuICAgICAgbmFtZTogJ3Jvd0hlaWdodCcsXG4gICAgICBkb2N1bWVudGF0aW9uOiAnRml4ZWQgb2YgcGl4ZWxzIHBlciByb3cuJyxcbiAgICAgIHZhbHVlOiA0MCxcbiAgICAgIHJlcXVpcmVkOiB0cnVlLFxuICAgICAgZmluYWw6IHRydWVcbiAgICB9LFxuICAgIHtcbiAgICAgIGNsYXNzOiAnSW50JyxcbiAgICAgIG5hbWU6ICdudW1Sb3dzJyxcbiAgICAgIGRvY3VtZW50YXRpb246ICdGaXhlZCBudW1iZXIgb2Ygcm93cyB0byByZWN5Y2xlIHdpdGhpbiB0aGlzIHZpZXcuJyxcbiAgICAgIHZhbHVlOiAyMCxcbiAgICAgIHJlcXVpcmVkOiB0cnVlLFxuICAgICAgZmluYWw6IHRydWVcbiAgICB9LFxuICAgIHtcbiAgICAgIGNsYXNzOiAnSW50JyxcbiAgICAgIG5hbWU6ICduZWdhdGl2ZVJ1bndheScsXG4gICAgICBkb2N1bWVudGF0aW9uOiAnTnVtYmVyIG9mIHJlY29yZHMgdG8gbG9hZCBiZWZvcmUgYW5jaG9yIHJvdy4nLFxuICAgICAgdmFsdWU6IDUwMFxuICAgIH0sXG4gICAge1xuICAgICAgY2xhc3M6ICdJbnQnLFxuICAgICAgbmFtZTogJ3Bvc2l0aXZlUnVud2F5JyxcbiAgICAgIGRvY3VtZW50YXRpb246ICdOdW1iZXIgb2YgcmVjb3JkcyB0byBsb2FkIGFmdGVyK2luY2x1ZGluZyBhbmNob3Igcm93LicsXG4gICAgICB2YWx1ZTogNTAwXG4gICAgfSxcbiAgICB7XG4gICAgICBjbGFzczogJ0ludCcsXG4gICAgICBuYW1lOiAncm93T2Zmc2V0JyxcbiAgICAgIGV4cHJlc3Npb246IGZ1bmN0aW9uKG51bVJvd3MpIHsgcmV0dXJuIE1hdGguZmxvb3IobnVtUm93cyAqIDAuNCk7IH1cbiAgICB9LFxuICAgIHtcbiAgICAgIGNsYXNzOiAnSW50JyxcbiAgICAgIG5hbWU6ICdiYXRjaFNpemUnLFxuICAgICAgZG9jdW1lbnRhdGlvbjogYFNpemUgZm9yIGJhdGNoIG9mIGRhdGEgdG8gZmV0Y2ggZnJvbSBEQU8uIFRoaXMgdmlldyB3aWxsXG4gICAgICAgICAga2VlcCBmZXRjaGluZyBiYXRjaGVzIHVudGlsIGl0IGZpbGxzIG91dCBhbGwgcm93cywgYnV0IHJlcXVlc3RpbmdcbiAgICAgICAgICBiYXRjaGVzIGxpbWl0cyB0aGUgbnVtYmVyIG9mIHJvd3MgdG8gYmUgcHJvY2Vzc2VkIHBlciBhbmltYXRpb25cbiAgICAgICAgICBmcmFtZS5gLFxuICAgICAgdmFsdWU6IDI1XG4gICAgfSxcbiAgICB7XG4gICAgICBjbGFzczogJ0Jvb2xlYW4nLFxuICAgICAgbmFtZTogJ3NlbGVjdGlvbkVuYWJsZWQnLFxuICAgICAgZmFjdG9yeTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiAhISB0aGlzLmltcG9ydGVkU2VsZWN0aW9uRW5hYmxlZDtcbiAgICAgIH1cbiAgICB9LFxuICAgIHtcbiAgICAgIGNsYXNzOiAnQXJyYXknLFxuICAgICAgbmFtZTogJ3NlbGVjdGlvbicsXG4gICAgICBhZGFwdDogZnVuY3Rpb24oXywgbnUpIHtcbiAgICAgICAgaWYgKCBmb2FtLk51bGwuaXNJbnN0YW5jZShudSkgfHwgZm9hbS5VbmRlZmluZWQuaXNJbnN0YW5jZShudSkgKVxuICAgICAgICAgIHJldHVybiBbXTtcblxuICAgICAgICByZXR1cm4gZm9hbS5BcnJheS5pc0luc3RhbmNlKG51KSA/IG51IDogW251XTtcbiAgICAgIH0sXG4gICAgfSxcbiAgICB7XG4gICAgICBjbGFzczogJ0ZPYmplY3RQcm9wZXJ0eScsXG4gICAgICAvLyBvZjogJ0RBT0NvbnRyb2xsZXInLFxuICAgICAgbmFtZTogJ2Rhb0NvbnRyb2xsZXJfJyxcbiAgICAgIGRvY3VtZW50YXRpb246IGBQcml2YXRlIGNvbXBvbmVudCByZXNwb25zaWJsZSBmb3IgZmV0Y2hpbmcgYmF0Y2hlcyBvZiBkYXRhXG4gICAgICAgICAgYW5kIGVmZmljaWVudGx5IHJlbmRlcmluZyBpbi12aWV3IGRhdGEgYXMgaXQgYXJyaXZlcy5gLFxuICAgICAgZmFjdG9yeTogZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLkRBT0NvbnRyb2xsZXIuY3JlYXRlKCk7IH1cbiAgICB9LFxuICAgIHtcbiAgICAgIG5hbWU6ICdsaXN0ZW5TdWJfJyxcbiAgICAgIGRvY3VtZW50YXRpb246ICdTdWJzY3JpcHRpb24gdXNlZCB0byBsaXN0ZW4gZm9yIERBTyByZXNldC4nLFxuICAgICAgdmFsdWU6IG51bGwsXG4gICAgICB0cmFuc2llbnQ6IHRydWVcbiAgICB9LFxuICAgIHtcbiAgICAgIGNsYXNzOiAnSW50JyxcbiAgICAgIG5hbWU6ICdhbmNob3JSb3dJZHhfJyxcbiAgICAgIGRvY3VtZW50YXRpb246ICdBbmNob3IgaW5kZXggaW4gXCJyb3dzX1wiIGFycmF5LicsXG4gICAgICBmYWN0b3J5OiBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMubmVnYXRpdmVSdW53YXk7IH0sXG4gICAgICB0cmFuc2llbnQ6IHRydWVcbiAgICB9LFxuICAgIHtcbiAgICAgIGNsYXNzOiAnSW50JyxcbiAgICAgIG5hbWU6ICdhbmNob3JEQU9JZHhfJyxcbiAgICAgIGRvY3VtZW50YXRpb246IGBBbmNob3IgaW5kZXggcmVsYXRpdmUgdG8gdG9wIG9mIHZpZXcgKGkuZS4sIHRvIGZpcnN0XG4gICAgICAgICAgcmVjb3JkIGluIFwiZGFvXCIpLmAsXG4gICAgICB0cmFuc2llbnQ6IHRydWVcbiAgICB9LFxuICAgIHtcbiAgICAgIGNsYXNzOiAnSW50JyxcbiAgICAgIG5hbWU6ICdjb3VudF8nLFxuICAgICAgZG9jdW1lbnRhdGlvbjogJ0NvdW50IG9mIHJlY29yZHMgdG8gZGlzcGxheSBpbiB0aGlzIHZpZXcuJ1xuICAgIH0sXG4gICAge1xuICAgICAgY2xhc3M6ICdGT2JqZWN0QXJyYXknLFxuICAgICAgb2Y6ICdmb2FtLnUyLkVsZW1lbnQnLFxuICAgICAgbmFtZTogJ3Jvd3NfJyxcbiAgICAgIGRvY3VtZW50YXRpb246ICdEaXJlY3QgY2hpbGQgdmlld3Mgb2YgdGhpcyB2aWV3IHRvIHJlY3ljbGUuJyxcbiAgICAgIGZhY3Rvcnk6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgcm93cyA9IG5ldyBBcnJheSh0aGlzLm51bVJvd3MpO1xuICAgICAgICBmb3IgKCB2YXIgaSA9IDA7IGkgPCByb3dzLmxlbmd0aDsgaSsrICkge1xuICAgICAgICAgIHJvd3NbaV0gPSB0aGlzLlJvdy5jcmVhdGUoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcm93cztcbiAgICAgIH0sXG4gICAgICB0cmFuc2llbnQ6IHRydWVcbiAgICB9LFxuICAgIHtcbiAgICAgIGNsYXNzOiAnRk9iamVjdFByb3BlcnR5JyxcbiAgICAgIG9mOiAnZm9hbS51Mi5FbGVtZW50JyxcbiAgICAgIG5hbWU6ICdzZW50aW5lbF8nLFxuICAgICAgZG9jdW1lbnRhdGluOiBgQWJzb2x1dGVseSBwb3NpdGlvbmVkIHNpbmdsZSBwaXhlbCB0aGF0IGVzdGFibGlzaGVzIHRoZVxuICAgICAgICAgIGhlaWdodCBvZiB0aGUgc2Nyb2xsIGNvbnRhaW5lci5gLFxuICAgICAgZmFjdG9yeTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLkUoJ2RpdicpLnN0eWxlKHtcbiAgICAgICAgICB3aWR0aDogJzFweCcsXG4gICAgICAgICAgaGVpZ2h0OiAnMXB4JyxcbiAgICAgICAgICAnZm9udC1zaXplJzogJzFweCcsXG4gICAgICAgICAgcG9zaXRpb246ICdhYnNvbHV0ZScsXG4gICAgICAgICAgdHJhbnNmb3JtOiB0aGlzLnNlbnRpbmVsVHJhbnNmb3JtXyRcbiAgICAgICAgfSkuZW50aXR5KCduYnNwJyk7XG4gICAgICB9LFxuICAgICAgdHJhbnNpZW50OiB0cnVlXG4gICAgfSxcbiAgICB7XG4gICAgICBjbGFzczogJ0ludCcsXG4gICAgICBuYW1lOiAnc2VudGluZWxZXycsXG4gICAgICBkb2N1bWVudGF0aW9uOiBgWS1pbmRleCAoaW4gcGl4ZWxzKSBvZiBcInNlbnRpbmVsX1wiLCByZWxhdGl2ZSB0byB0b3Agb2ZcbiAgICAgICAgICB0aGlzIHZpZXcgKHRoZSBzY3JvbGwgY29udGFpbmVyKS5gLFxuICAgICAgZXhwcmVzc2lvbjogZnVuY3Rpb24ocm93SGVpZ2h0LCBjb3VudF8pIHtcbiAgICAgICAgcmV0dXJuICggY291bnRfICogcm93SGVpZ2h0ICkgLSAxO1xuICAgICAgfSxcbiAgICAgIHRyYW5zaWVudDogdHJ1ZVxuICAgIH0sXG4gICAge1xuICAgICAgY2xhc3M6ICdTdHJpbmcnLFxuICAgICAgbmFtZTogJ3NlbnRpbmVsVHJhbnNmb3JtXycsXG4gICAgICBkb2N1bWVudGF0aW9uOiAnQ1NTIHRyYW5zZm9ybSBmb3IgXCJzZW50aW5lbF9cIi4nLFxuICAgICAgZXhwcmVzc2lvbjogZnVuY3Rpb24oc2VudGluZWxZXykge1xuICAgICAgICByZXR1cm4gJ3RyYW5zbGF0ZSgwcHgsICcgKyBzZW50aW5lbFlfICsgJ3B4KSc7XG4gICAgICB9LFxuICAgICAgdHJhbnNpZW50OiB0cnVlXG4gICAgfSxcbiAgICB7XG4gICAgICBjbGFzczogJ0Jvb2xlYW4nLFxuICAgICAgbmFtZTogJ2FuY2hvckxvY2tfJyxcbiAgICAgIGRvY3VtZW50YXRpb246IGBBIHN5bmNocm9uaXphdGlvbiB2YXJpYWJsZSB0byBwcmV2ZW50IHVuaGFuZGxlZCBzY3JvbGxcbiAgICAgICAgICBldmVudHMgZnJvbSBmaXJpbmcgd2hlbiBcImNvdW50X1wiIChhbmQgdGhlcmVmb3JlIFwic2VudGluZWxfXCIgbG9jYXRpb24pXG4gICAgICAgICAgY2hhbmdlcy5gLFxuICAgICAgdHJhbnNpZW50OiB0cnVlXG4gICAgfSxcbiAgICB7XG4gICAgICBjbGFzczogJ0ludCcsXG4gICAgICBuYW1lOiAnZmV0Y2hJZF8nLFxuICAgICAgZG9jdW1lbnRhdGlvbjogYEEgc3luY2hyb25pemF0aW9uIHZhcmlhYmxlIHRvIHByZXZlbnQgaGFsdCBiYXRjaCBmZXRjaGluZ1xuICAgICAgICAgIG9mIHJlc3VsdHMgaWYgZmV0Y2hpbmcgZnJvbSBhIG5ldyBzdGFydGluZyBwb2ludCBoYXMgYWxyZWFkeVxuICAgICAgICAgIGNvbW1lbmNlZC5gLFxuICAgICAgdHJhbnNpZW50OiB0cnVlXG4gICAgfSxcbiAgICB7XG4gICAgICBjbGFzczogJ0Z1bmN0aW9uJyxcbiAgICAgIG5hbWU6ICdtb2ROdW1Sb3dzXycsXG4gICAgICBkb2N1bWVudGF0aW9uOiBgSGVscGVyIGZ1bmN0aW9uIGZvciByb3cgYXJpdGhtZXRpYy4gQSBwcm9wZXJ0eSByYXRoZXIgdGhhblxuICAgICAgICAgIGEgbWV0aG9kIGZvciBlYXN5IGV4cG9ydCB0byBpbm5lciBjbGFzcyBpbnN0YW5jZXMgdGhhdCB1c2UgaXQuYCxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbihudW0pIHtcbiAgICAgICAgaWYgKCB0aGlzLm51bVJvd3MgPT09IDAgKSByZXR1cm4gMDtcbiAgICAgICAgdmFyIHJldCA9IG51bSAlIHRoaXMubnVtUm93cztcbiAgICAgICAgaWYgKCByZXQgPCAwICkgcmV0ID0gcmV0ICsgdGhpcy5udW1Sb3dzO1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgfSxcbiAgICAgIHRyYW5zaWVudDogdHJ1ZVxuICAgIH1cbiAgXSxcblxuICBjbGFzc2VzOiBbXG4gICAge1xuICAgICAgbmFtZTogJ1JvdycsXG4gICAgICBleHRlbmRzOiAnZm9hbS51Mi5FbGVtZW50JyxcblxuICAgICAgZG9jdW1lbnRhdGlvbjogYFJlY3ljbGVkIERPTSByb3dzLiBUaGUgXCJ2aWV3XCIgVmlld1NwZWMgaXMgdXNlZCB0byBtYW51YWxseVxuICAgICAgICAgIHRlYXIgZG93biBhbmQgcmVidWlsZCByb3cgY29udGVudHMgd2hlbmV2ZXIgXCJkYXRhXCIgY2hhbmdlcy4gU2Nyb2xsXG4gICAgICAgICAgcGVyZm9ybWFuY2UgaXMgb3B0aW1pemVkIGJ5IHVzaW5nIGFuIGlubmVyIHZpZXcgd2l0aCBubyBkeW5hbWljXG4gICAgICAgICAgYmluZGluZ3Mgc28gdGhhdCB0aGUgb25seSBET00gb3BlcmF0aW9uIGlzIHRoZSByb3cgY29tcGxldGVseVxuICAgICAgICAgIHJlcGxhY2luZyBpdHMgY29udGVudHMuYCxcblxuICAgICAgaW1wb3J0czogW1xuICAgICAgICAnY29sdW1ucz8nLFxuICAgICAgICAncm93Rm9ybWF0dGVyJyxcbiAgICAgICAgJ3NlbGVjdGlvbicsXG4gICAgICAgICdzZWxlY3Rpb25FbmFibGVkJ1xuICAgICAgXSxcblxuICAgICAgYXhpb21zOiBbXG4gICAgICAgIGZvYW0udTIuQ1NTLmNyZWF0ZSh7XG4gICAgICAgICAgY29kZTogZnVuY3Rpb24gQ1NTKCkgey8qXG4gICAgICAgICAgICBeIHtcbiAgICAgICAgICAgICAgZGlzcGxheTogYmxvY2s7XG4gICAgICAgICAgICAgIGNvbnRhaW46IGxheW91dDtcbiAgICAgICAgICAgICAgd2lsbC1jaGFuZ2U6IHRyYW5zZm9ybTtcbiAgICAgICAgICAgICAgcGFkZGluZzogNXB4O1xuICAgICAgICAgICAgICBib3gtc2l6aW5nOiBib3JkZXItYm94O1xuICAgICAgICAgICAgICAtd2Via2l0LXVzZXItc2VsZWN0OiBub25lO1xuICAgICAgICAgICAgICAtbW96LXVzZXItc2VsZWN0OiBub25lO1xuICAgICAgICAgICAgICAtbXMtdXNlci1zZWxlY3Q6IG5vbmU7XG4gICAgICAgICAgICAgIHVzZXItc2VsZWN0OiBub25lO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXnNlbGVjdGFibGU6aG92ZXIge1xuICAgICAgICAgICAgICBmaWx0ZXI6IG9wYWNpdHkoMC44KTtcbiAgICAgICAgICAgICAgY3Vyc29yOiBwb2ludGVyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXnNlbGVjdGVkIHtcbiAgICAgICAgICAgICAgZmlsdGVyOiBvcGFjaXR5KDAuNykgIWltcG9ydGFudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgKi99XG4gICAgICAgIH0pXG4gICAgICBdLFxuXG4gICAgICBwcm9wZXJ0aWVzOiBbXG4gICAgICAgIFsgJ25vZGVOYW1lJywgJ2xpJyBdLFxuICAgICAgICB7XG4gICAgICAgICAgbmFtZTogJ2RhdGEnLFxuICAgICAgICAgIHBvc3RTZXQ6IGZ1bmN0aW9uKG9sZCwgbnUpIHtcbiAgICAgICAgICAgIGlmICggdGhpcy5zdGF0ZSAhPT0gdGhpcy5MT0FERUQgKSByZXR1cm47XG4gICAgICAgICAgICBjb25zdCBodG1sU3RyID0gdGhpcy5yb3dGb3JtYXR0ZXIuZm9ybWF0KFxuICAgICAgICAgICAgICBudSwgdGhpcy5jb2x1bW5zKTtcbiAgICAgICAgICAgIHRoaXMuZWwoKS5pbm5lckhUTUwgPSBodG1sU3RyO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgXSxcblxuICAgICAgbWV0aG9kczogW1xuICAgICAgICBmdW5jdGlvbiBpbml0KCkge1xuICAgICAgICAgIHRoaXMub25sb2FkLnN1Yih0aGlzLnJlbmRlcik7XG4gICAgICAgIH0sXG4gICAgICAgIGZ1bmN0aW9uIGluaXRFKCkge1xuICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgICB0aGlzLmFkZENsYXNzKHRoaXMubXlDbGFzcygpKTtcbiAgICAgICAgICB0aGlzLmVuYWJsZUNsYXNzKHRoaXMubXlDbGFzcygnc2VsZWN0YWJsZScpLCB0aGlzLnNlbGVjdGlvbkVuYWJsZWQkKTtcbiAgICAgICAgICB0aGlzLmVuYWJsZUNsYXNzKFxuICAgICAgICAgICAgICB0aGlzLm15Q2xhc3MoJ3NlbGVjdGVkJyksXG4gICAgICAgICAgICAgIHRoaXMuc2xvdChmdW5jdGlvbihzZWxlY3Rpb25FbmFibGVkLCBkYXRhLCBzZWxlY3Rpb24pIHtcbiAgICAgICAgICAgICAgICBpZiAoICEgZGF0YSB8fCAhIHNlbGVjdGlvbkVuYWJsZWQgfHxcbiAgICAgICAgICAgICAgICAgICAgIHNlbGVjdGlvbi5sZW5ndGggPT09IDAgKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHNlbGVjdGlvbi5zb21lKGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBkLmlkID09PSBkYXRhLmlkO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9LCB0aGlzLnNlbGVjdGlvbkVuYWJsZWQkLCB0aGlzLmRhdGEkLCB0aGlzLnNlbGVjdGlvbiQpKTtcbiAgICAgICAgICB0aGlzLm9uKCdjbGljaycsIGZ1bmN0aW9uKGV2dCkge1xuICAgICAgICAgICAgaWYgKCAhIHNlbGYuZGF0YSApIHJldHVybjtcblxuICAgICAgICAgICAgdmFyIG9sZE51bSA9IHNlbGYuc2VsZWN0aW9uLmxlbmd0aDtcbiAgICAgICAgICAgIHZhciBuZXdTZWxlY3Rpb24gPSBzZWxmLnNlbGVjdGlvbi5maWx0ZXIoZnVuY3Rpb24oZCkge1xuICAgICAgICAgICAgICByZXR1cm4gISBmb2FtLnV0aWwuZXF1YWxzKGQuaWQsIHNlbGYuZGF0YS5pZCk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgLy8gSWYgbGVuZ3RoIGRpZG4ndCBjaGFuZ2UsIGFkZCB0byBzZWxlY3Rpb24uIE90aGVyd2lzZSwgZmlsdGVyKClcbiAgICAgICAgICAgIC8vIGFscmVhZHkgY29tbWl0dGVkIHJlbW92YWwgYWN0aW9uLlxuICAgICAgICAgICAgaWYgKCBuZXdTZWxlY3Rpb24ubGVuZ3RoID09PSBvbGROdW0gKSB7XG4gICAgICAgICAgICAgIG5ld1NlbGVjdGlvbi5wdXNoKHNlbGYuZGF0YSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHNlbGYuc2VsZWN0aW9uID0gbmV3U2VsZWN0aW9uO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHRoaXMuY29sdW1ucyQgJiYgdGhpcy5jb2x1bW5zJC5zdWIodGhpcy5yZW5kZXIpO1xuICAgICAgICB9XG4gICAgICBdLFxuXG4gICAgICBsaXN0ZW5lcnM6IFtcbiAgICAgICAgZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgICAgICAgIHRoaXMuZWwoKS5pbm5lckhUTUwgPSB0aGlzLnJvd0Zvcm1hdHRlci5mb3JtYXQodGhpcy5kYXRhLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jb2x1bW5zKTtcbiAgICAgICAgfVxuICAgICAgXVxuICAgIH0sXG4gICAge1xuICAgICAgbmFtZTogJ0RBT0NvbnRyb2xsZXInLFxuXG4gICAgICBkb2N1bWVudGF0aW9uOiBgQ29udHJvbGxlciByZXNwb25zaWJsZSBmb3IgZmV0Y2hpbmcgYmF0Y2hlcyBvZiBkYXRhIGZvclxuICAgICAgICAgIFNjcm9sbERBT1ZpZXcuIERhdGEgYXJlIGZldGNoZWQgaW4gbXVsdGlwbGUgc21hbGwgYmF0Y2ggdG8gYXZvaWRcbiAgICAgICAgICBibG9ja2luZyB0aGUgbWFpbiB0aHJlYWQgdG8gcGFyc2UgbGFyZ2UgYW1vdW50cyBvZiBkYXRhLlxuXG4gICAgICAgICAgRGF0YSBhcmUgZmV0Y2hlZCBpbiBhIHdpbmRvdyBhcm91bmQgdGhlIGN1cnJlbnQgc2Nyb2xsIHBvc2l0aW9uIGFuZFxuICAgICAgICAgIGluc2VydGVkIGludG8gcm93IHZpZXdzIGFzIHNvb24gYXMgdGhleSBhcmUgYXZhaWxhYmxlLiBTaW5jZSB0aGUgdXNlclxuICAgICAgICAgIG1heSBcImp1bXBcIiB0byBhIGZhciBhd2F5IHNjcm9sbCBwb3NpdGlvbiwgdGhpcyBjb250cm9sbGVyIGtlZXBzIHRyYWNrXG4gICAgICAgICAgb2YgYSBsaXN0IG9mIHJhbmdlcywgYW5kIG9ubHkgZmV0Y2hlcyBtaXNzaW5nIGRhdGEgaW4gdGhlIGN1cnJlbnRcbiAgICAgICAgICBzY3JvbGwgd2luZG93LiBUaGUgb25SZXNldCgpIGxpc3RlbmVyIHRocm93cyBhd2F5IGRhdGEgYW5kIHJhbmdlcy5cblxuICAgICAgICAgIEEgc21hbGxlciB3aW5kb3cgKHRoZSBcImJ1ZmZlclwiKSBtdXN0IGNvbnRhaW4gZ2FwcyB0byB0cmlnZ2VyIGEgZGF0YVxuICAgICAgICAgIGZldGNoLiBXaGVuIGEgZmV0Y2ggaXMgdHJpZ2dlcmVkIGEgbGFyZ2VyIHdpbmRvdyAodGhlIFwicnVud2F5XCIpXG4gICAgICAgICAgZGVmaW5lcyB3aGljaCByZWNvcmRzIHRvIGZldGNoOlxuXG4gICAgICAgICAgICAgICAgICAgIGFuY2hvckRBT0lkeF8gLS0tLXZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC0tIG51bVJvd3MgLS0+XG4gICAgICAgICAgICAgICAgICA8LSBuZWdhdGl2ZUJ1ZmZlciAtPiAgICAgICAgICAgICAgIDwtIHBvc2l0aXZlQnVmZmVyIC0+XG4gICAgICAgICAgICA8LS0tLS0tLSBuZWdhdGl2ZVJ1bndheSAtPiAgICAgICAgICAgICAgIDwtLSBwb3NpdGl2ZVJ1bndheSAtLS0tLS0tPlxuICAgICAgICAgICAgfHx8fHx8fHx8fHx8fHx8fCByZWNvcmRzIGZpbGxlZCBhZnRlciBiYXRjaGVkIGZldGNoIHx8fHx8fHx8fHx8fHx8fHxcbiAgICAgICAgICBgLFxuXG4gICAgICAvLyBTY3JvbGxEQU9WaWV3IHN0YXRlIG5lZWRlZCBmb3IgZGF0YSBmZXRjaGluZyBhbmQgaW1tZWRpYXRlIHJvd1xuICAgICAgLy8gaW5zZXJ0aW9uLlxuICAgICAgaW1wb3J0czogW1xuICAgICAgICAnYW5jaG9yREFPSWR4XycsXG4gICAgICAgICdhbmNob3JSb3dJZHhfJyxcbiAgICAgICAgJ2JhdGNoU2l6ZScsXG4gICAgICAgICdjb3VudF8nLFxuICAgICAgICAnZGF0YSBhcyBkYW8nLFxuICAgICAgICAnbW9kTnVtUm93c18nLFxuICAgICAgICAnbmVnYXRpdmVSdW53YXknLFxuICAgICAgICAnbnVtUm93cycsXG4gICAgICAgICdwb3NpdGl2ZVJ1bndheScsXG4gICAgICAgICdyb3dzXydcbiAgICAgIF0sXG5cbiAgICAgIHByb3BlcnRpZXM6IFtcbiAgICAgICAge1xuICAgICAgICAgIGNsYXNzOiAnSW50JyxcbiAgICAgICAgICBuYW1lOiAnbmVnYXRpdmVCdWZmZXInLFxuICAgICAgICAgIGRvY3VtZW50YXRpb246IGBUaGUgYXJlYSBiZWhpbmQgdGhlIGN1cnJlbnQgYW5jaG9yIHdoZXJlIGEgZ2FwIG1heVxuICAgICAgICAgICAgICB0cmlnZ2VyIGEgZGF0YSBmZXRjaGAsXG4gICAgICAgICAgZXhwcmVzc2lvbjogZnVuY3Rpb24obmVnYXRpdmVSdW53YXksIG51bVJvd3MpIHtcbiAgICAgICAgICAgIHJldHVybiBNYXRoLm1heChNYXRoLmNlaWwobmVnYXRpdmVSdW53YXkgLyA1LCBudW1Sb3dzKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgY2xhc3M6ICdJbnQnLFxuICAgICAgICAgIG5hbWU6ICdwb3NpdGl2ZUJ1ZmZlcicsXG4gICAgICAgICAgZG9jdW1lbnRhdGlvbjogYFRoZSBhcmVhIGluIGZyb250IG9mIHRoZSBjdXJyZW50IGFuY2hvciB3aGVyZSBhIGdhcFxuICAgICAgICAgICAgICBtYXkgdHJpZ2dlciBhIGRhdGEgZmV0Y2hgLFxuICAgICAgICAgIGV4cHJlc3Npb246IGZ1bmN0aW9uKHBvc2l0aXZlUnVud2F5LCBudW1Sb3dzKSB7XG4gICAgICAgICAgICByZXR1cm4gTWF0aC5tYXgoTWF0aC5jZWlsKHBvc2l0aXZlUnVud2F5IC8gNSwgbnVtUm93cykpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIG5hbWU6ICdkYXRhJyxcbiAgICAgICAgICBmYWN0b3J5OiBmdW5jdGlvbigpIHsgcmV0dXJuIHt9OyB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICBjbGFzczogJ0FycmF5JyxcbiAgICAgICAgICBuYW1lOiAncmFuZ2VzJ1xuICAgICAgICB9XG4gICAgICBdLFxuXG4gICAgICBtZXRob2RzOiBbXG4gICAgICAgIGZ1bmN0aW9uIGluaXQoKSB7XG4gICAgICAgICAgdGhpcy5hbmNob3JEQU9JZHhfJC5zdWIodGhpcy5vbk1vdmUpO1xuICAgICAgICAgIHRoaXMubmVnYXRpdmVSdW53YXkkLnN1Yih0aGlzLm9uTW92ZSk7XG4gICAgICAgICAgdGhpcy5udW1Sb3dzJC5zdWIodGhpcy5vbk1vdmUpO1xuICAgICAgICAgIHRoaXMucG9zaXRpdmVSdW53YXkkLnN1Yih0aGlzLm9uTW92ZSk7XG4gICAgICAgICAgdGhpcy5vbk1vdmUoKTtcbiAgICAgICAgICB0aGlzLlNVUEVSKCk7XG4gICAgICAgIH0sXG4gICAgICAgIGZ1bmN0aW9uIG1pc3NpbmdEYXRhXyhzdGFydCwgZW5kKSB7XG4gICAgICAgICAgdmFyIHJhbmdlcyA9IHRoaXMucmFuZ2VzO1xuICAgICAgICAgIHZhciBpdGVyQWZ0ZXJSYW5nZSA9IHRydWU7XG4gICAgICAgICAgdmFyIGk7XG4gICAgICAgICAgZm9yICggaSA9IHRoaXMucmFuZ2VzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tICkge1xuICAgICAgICAgICAgaWYgKCByYW5nZXNbaV1bMF0gPD0gZW5kICkgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICggaSA8IDAgKSByZXR1cm4gWyBbIHN0YXJ0LCBlbmQgXSBdO1xuICAgICAgICAgIGlmICggcmFuZ2VzW2ldWzBdIDw9IHN0YXJ0ICYmIHJhbmdlc1tpXVsxXSA+PSBlbmQgKSByZXR1cm4gbnVsbDtcbiAgICAgICAgICB2YXIgZm91bmRHYXBzID0gcmFuZ2VzW2ldWzFdIDwgZW5kID8gWyBbIHJhbmdlc1tpXVsxXSwgZW5kIF0gXSA6IFtdO1xuICAgICAgICAgIHZhciBnYXBFbmQgPSByYW5nZXNbaV1bMF07XG4gICAgICAgICAgZm9yICggaS0tOyBpID49IDA7IGktLSApIHtcbiAgICAgICAgICAgIHZhciByYW5nZSA9IHJhbmdlc1tpXTtcbiAgICAgICAgICAgIGlmICggcmFuZ2VbMV0gPCBzdGFydCApIHtcbiAgICAgICAgICAgICAgZm91bmRHYXBzLnB1c2goWyBzdGFydCwgZ2FwRW5kIF0pO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvdW5kR2Fwcy5wdXNoKFsgcmFuZ2VbMV0sIGdhcEVuZCBdKTtcbiAgICAgICAgICAgIGdhcEVuZCA9IHJhbmdlWzBdO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gZm91bmRHYXBzO1xuICAgICAgICB9LFxuICAgICAgICBmdW5jdGlvbiBmZXRjaERhdGFfKHN0YXJ0LCBlbmQsIGdhcHMpIHtcbiAgICAgICAgICB2YXIgdmlld1N0YXJ0ID0gdGhpcy5hbmNob3JEQU9JZHhfO1xuICAgICAgICAgIHZhciB2aWV3RW5kID0gdmlld1N0YXJ0ICsgdGhpcy5udW1Sb3dzO1xuICAgICAgICAgIHZhciBydW53YXlTdGFydCA9IE1hdGgubWF4KDAsIHZpZXdTdGFydCAtIHRoaXMubmVnYXRpdmVSdW53YXkpO1xuICAgICAgICAgIHZhciBydW53YXlFbmQgPSBNYXRoLm1pbih0aGlzLmNvdW50Xywgdmlld0VuZCArIHRoaXMucG9zaXRpdmVSdW53YXkpO1xuXG4gICAgICAgICAgaWYgKCBydW53YXlTdGFydCA8IHN0YXJ0ICkge1xuICAgICAgICAgICAgdmFyIGJlZm9yZSA9IHRoaXMubWlzc2luZ0RhdGFfKHJ1bndheVN0YXJ0LCBnYXBzWzBdWzFdKTtcbiAgICAgICAgICAgIGdhcHMgPSBiZWZvcmUgPyBiZWZvcmUuY29uY2F0KGdhcHMuc2xpY2UoMSkpIDogZ2FwcztcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCBydW53YXlFbmQgPiBlbmQgKSB7XG4gICAgICAgICAgICB2YXIgYWZ0ZXIgPSB0aGlzLm1pc3NpbmdEYXRhXyhnYXBzW2dhcHMubGVuZ3RoIC0gMV1bMF0sIHJ1bndheUVuZCk7XG4gICAgICAgICAgICBnYXBzID0gYWZ0ZXIgPyBnYXBzLnNsaWNlKDAsIC0xKS5jb25jYXQoYWZ0ZXIpIDogZ2FwcztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aGlzLmZldGNoQ2h1bmtzXyhnYXBzKTtcblxuICAgICAgICAgIHZhciBhID0gdGhpcy5yYW5nZXM7XG4gICAgICAgICAgdmFyIGIgPSBnYXBzO1xuICAgICAgICAgIHZhciBpID0gMDtcbiAgICAgICAgICB2YXIgaiA9IDA7XG4gICAgICAgICAgd2hpbGUgKCBpIDwgYS5sZW5ndGggfHwgaiA8IGIubGVuZ3RoICkge1xuICAgICAgICAgICAgaWYgKCBqID49IGIubGVuZ3RoICkgYnJlYWs7XG4gICAgICAgICAgICBpZiAoIGkgPj0gYS5sZW5ndGggKSB7XG4gICAgICAgICAgICAgIGEgPSBhLmNvbmNhdChiLnNsaWNlKGopKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIGFbaV1bMF0gPD0gYltqXVswXSApIHtcbiAgICAgICAgICAgICAgaWYgKCBiW2pdWzBdIDw9IGFbaV1bMV0gKSB7XG4gICAgICAgICAgICAgICAgYVtpXVsxXSA9IE1hdGgubWF4KGFbaV1bMV0sIGJbal1bMV0pO1xuICAgICAgICAgICAgICAgIGorKztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgaWYgKCBhW2ldWzBdIDw9IGJbal1bMV0gKSB7XG4gICAgICAgICAgICAgICAgYVtpXVswXSA9IGJbal1bMF07XG4gICAgICAgICAgICAgICAgYVtpXVsxXSA9IE1hdGgubWF4KGFbaV1bMV0sIGJbal1bMV0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGorKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAoIHZhciBrID0gaSArIDE7IGsgPCBhLmxlbmd0aDsgaysrICkge1xuICAgICAgICAgICAgICBpZiAoIGFbaV1bMV0gPCBhW2tdWzBdICkgYnJlYWs7XG4gICAgICAgICAgICAgIGFbaV1bMV0gPSBhW2tdWzFdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaSA9IGs7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGhpcy5yYW5nZXMgPSBhO1xuICAgICAgICB9LFxuICAgICAgICBmdW5jdGlvbiBmZXRjaENodW5rc18oY2h1bmtzKSB7XG4gICAgICAgICAgZm9yICggdmFyIGkgPSAwOyBpIDwgY2h1bmtzLmxlbmd0aDsgaSsrICkge1xuICAgICAgICAgICAgdGhpcy5mZXRjaEJhdGNoZXNfKGNodW5rc1tpXVswXSwgY2h1bmtzW2ldWzFdKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGZ1bmN0aW9uIGZldGNoQmF0Y2hlc18oc3RhcnQsIGVuZCkge1xuICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgICB2YXIgYmF0Y2hTaXplID0gc2VsZi5iYXRjaFNpemU7XG4gICAgICAgICAgdmFyIHNraXAgPSBzdGFydDtcbiAgICAgICAgICB2YXIgbGltaXQgPSBNYXRoLm1pbihzdGFydCArIHNlbGYuYmF0Y2hTaXplLCBlbmQpO1xuICAgICAgICAgIHZhciBmZXRjaEJhdGNoID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBzZWxmLmRhby5za2lwKHNraXApLmxpbWl0KGxpbWl0KS5cbiAgICAgICAgICAgICAgc2VsZWN0KCkudGhlbihmdW5jdGlvbihzaW5rKSB7XG4gICAgICAgICAgICAgICAgd2hpbGUgKCAhIHNpbmsuYXJyYXkgKSB7XG4gICAgICAgICAgICAgICAgICBzaW5rID0gc2luay5kZWxlZ2F0ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIGFycmF5ID0gc2luay5hcnJheTtcbiAgICAgICAgICAgICAgICB2YXIgZGFvU3RhcnQgPSBzZWxmLmFuY2hvckRBT0lkeF87XG4gICAgICAgICAgICAgICAgdmFyIGRhb0VuZCA9IE1hdGgubWluKHNlbGYuY291bnRfLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmFuY2hvckRBT0lkeF8gKyBzZWxmLm51bVJvd3MpO1xuICAgICAgICAgICAgICAgIGZvciAoIHZhciBpID0gMDsgaSA8IGFycmF5Lmxlbmd0aDsgaSsrICkge1xuICAgICAgICAgICAgICAgICAgdmFyIGRhb0lkeCA9IHNraXAgKyBpO1xuICAgICAgICAgICAgICAgICAgc2VsZi5kYXRhW2Rhb0lkeF0gPSBhcnJheVtpXTtcbiAgICAgICAgICAgICAgICAgIGlmICggZGFvSWR4ID49IGRhb1N0YXJ0ICYmIGRhb0lkeCA8IGRhb0VuZCApIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGFuY2hvclJlbGF0aXZlSWR4ID0gZGFvSWR4IC0gZGFvU3RhcnQ7XG4gICAgICAgICAgICAgICAgICAgIHZhciByb3dJZHggPSBzZWxmLm1vZE51bVJvd3NfKHNlbGYuYW5jaG9yUm93SWR4XyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFuY2hvclJlbGF0aXZlSWR4KTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJvdyA9IHNlbGYucm93c19bcm93SWR4XTtcbiAgICAgICAgICAgICAgICAgICAgcm93LmRhdGEgPSBhcnJheVtpXTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBza2lwICs9IGJhdGNoU2l6ZTtcbiAgICAgICAgICAgICAgICBsaW1pdCA9IE1hdGgubWluKGJhdGNoU2l6ZSwgZW5kIC0gc2tpcCk7XG4gICAgICAgICAgICAgICAgLy8gVE9ETyhtYXJrZGl0dG1lcik6IEltcG9ydCByQUYuXG4gICAgICAgICAgICAgICAgaWYgKCBsaW1pdCA+IDAgKSB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZldGNoQmF0Y2gpO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICB9O1xuICAgICAgICAgIGZldGNoQmF0Y2goKTtcbiAgICAgICAgfVxuICAgICAgXSxcblxuICAgICAgbGlzdGVuZXJzOiBbXG4gICAgICAgIGZ1bmN0aW9uIG9uTW92ZSgpIHtcbiAgICAgICAgICB2YXIgdmlld1N0YXJ0ID0gdGhpcy5hbmNob3JEQU9JZHhfO1xuICAgICAgICAgIHZhciB2aWV3RW5kID0gdmlld1N0YXJ0ICsgdGhpcy5udW1Sb3dzO1xuICAgICAgICAgIHZhciBidWZmZXJTdGFydCA9IE1hdGgubWF4KDAsIHZpZXdTdGFydCAtXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCB0aGlzLm5lZ2F0aXZlUnVud2F5IC8gNCApKTtcbiAgICAgICAgICB2YXIgYnVmZmVyRW5kID0gTWF0aC5taW4odGhpcy5jb3VudF8sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZpZXdFbmQgKyAoIHRoaXMucG9zaXRpdmVSdW53YXkgLyA0ICkpO1xuXG4gICAgICAgICAgdmFyIGdhcHMgPSB0aGlzLm1pc3NpbmdEYXRhXyhidWZmZXJTdGFydCwgYnVmZmVyRW5kKTtcbiAgICAgICAgICBpZiAoICEgZ2FwcyApIHJldHVybjtcbiAgICAgICAgICB0aGlzLmZldGNoRGF0YV8oYnVmZmVyU3RhcnQsIGJ1ZmZlckVuZCwgZ2Fwcyk7XG4gICAgICAgIH0sXG4gICAgICAgIGZ1bmN0aW9uIG9uUmVzZXQoKSB7XG4gICAgICAgICAgdGhpcy5kYXRhID0ge307XG4gICAgICAgICAgdGhpcy5yYW5nZXMgPSBbXTtcbiAgICAgICAgICB0aGlzLm9uTW92ZSgpO1xuICAgICAgICB9XG4gICAgICBdXG4gICAgfVxuICBdLFxuXG4gIG1ldGhvZHM6IFtcbiAgICBmdW5jdGlvbiBpbml0KCkge1xuICAgICAgaWYgKCB0aGlzLmltcG9ydGVkU2VsZWN0aW9uJCApIHtcbiAgICAgICAgdGhpcy5zZWxlY3Rpb24kLmxpbmtGcm9tKHRoaXMuaW1wb3J0ZWRTZWxlY3Rpb24kKTtcbiAgICAgIH1cbiAgICAgIGlmICggdGhpcy5kYXRhICkgdGhpcy5jb3VudFJlY29yZHNfKCk7XG4gICAgICB0aGlzLlNVUEVSKCk7XG4gICAgfSxcbiAgICBmdW5jdGlvbiBpbml0RSgpIHtcbiAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgdGhpcy5vblNjcm9sbCk7XG4gICAgICB0aGlzLlxuICAgICAgICBzZXROb2RlTmFtZSgndWwnKS5cbiAgICAgICAgYWRkKHRoaXMuc2VudGluZWxfKS5cbiAgICAgICAgYWRkQ2xhc3ModGhpcy5teUNsYXNzKCkpLlxuICAgICAgICBmb3JFYWNoKHRoaXMucm93c18sIGZ1bmN0aW9uKHJvdywgaWR4KSB7XG4gICAgICAgICAgdGhpcy5hZGQocm93KTtcbiAgICAgICAgICAvLyBMYXkgb3V0IHJvdyBlaXRoZXI6XG4gICAgICAgICAgLy8gKDEpIFdoZXJlIGl0IGJlbG9uZ3MgaW4gcG9zaXRpdmUgcnVud2F5LFxuICAgICAgICAgIC8vIG9yXG4gICAgICAgICAgLy8gKDIpIEp1c3QgYWJvdmUgZmlyc3QgcmVjb3JkLlxuICAgICAgICAgIHZhciB5ID0gaWR4IDwgdGhpcy5jb3VudF8gP1xuICAgICAgICAgICAgICAgICggaWR4IC0gdGhpcy5uZWdhdGl2ZVJ1bndheSApICogdGhpcy5yb3dIZWlnaHQgOlxuICAgICAgICAgICAgICAgIC10aGlzLnJvd0hlaWdodDtcbiAgICAgICAgICByb3cuc3R5bGUoe1xuICAgICAgICAgICAgcG9zaXRpb246ICdhYnNvbHV0ZScsXG4gICAgICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGVZKCcgKyB5ICsncHgpJyxcbiAgICAgICAgICAgIGhlaWdodDogdGhpcy5yb3dIZWlnaHQgKyAncHgnLFxuICAgICAgICAgICAgd2lkdGg6ICcxMDAlJ1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcblxuICAgICAgdGhpcy5TVVBFUigpO1xuICAgIH0sXG4gICAge1xuICAgICAgbmFtZTogJ21vdmVBbmNob3JfJyxcbiAgICAgIGRvY3VtZW50YXRpb246IGBMYXlvdXQgcm93cyBhY2NvcmRpbmcgdG8gbmV3IGFuY2hvciBcIkRBTyBpZHhcIiAoaS5lLixcbiAgICAgICAgICBpZHggcmVsYXRpdmUgdG8gZmlyc3QgcmVjb3JkIGluIHZpZXcpLmAsXG4gICAgICBjb2RlOiBmdW5jdGlvbihhbmNob3JEQU9JZHgpIHtcbiAgICAgICAgdmFyIGRhb0lkeERlbHRhID0gYW5jaG9yREFPSWR4IC0gdGhpcy5hbmNob3JEQU9JZHhfO1xuICAgICAgICBpZiAoIE1hdGguYWJzKGRhb0lkeERlbHRhKSA+PSB0aGlzLm51bVJvd3MgKVxuICAgICAgICAgIHJldHVybiB0aGlzLnJlc2V0QW5jaG9yXyhhbmNob3JEQU9JZHgpO1xuXG4gICAgICAgIGlmICggZGFvSWR4RGVsdGEgPj0gMCApIHJldHVybiB0aGlzLm1vdmVBbmNob3JGb3J3YXJkXyhhbmNob3JEQU9JZHgpO1xuICAgICAgICByZXR1cm4gdGhpcy5tb3ZlQW5jaG9yQmFja3dhcmRfKGFuY2hvckRBT0lkeCk7XG4gICAgICB9XG4gICAgfSxcbiAgICB7XG4gICAgICBuYW1lOiAncmVzZXRBbmNob3JfJyxcbiAgICAgIGRvY3VtZW50YXRpb246IGBMYXlvdXQgYWxsIHJvd3MgYWNjb3JkaW5nIHRvIG5ldyBhbmNob3IgREFPIGlkeC4gR2VuZXJhbGx5XG4gICAgICAgICAgdXNlZCB3aGVuIHNjcm9sbCBqdW1wIGV4Y2VlZHMgcm93IHdpbmRvdyBzaXplIG9yIG9uIGRhdGEgcmVzZXQuYCxcbiAgICAgIGNvZGU6IGZ1bmN0aW9uKGFuY2hvckRBT0lkeCkge1xuICAgICAgICB2YXIgYmFzZURBT0lkeCA9IGFuY2hvckRBT0lkeDtcbiAgICAgICAgZm9yICggdmFyIGkgPSAwOyBpIDwgdGhpcy5udW1Sb3dzOyBpKysgKSB7XG4gICAgICAgICAgdmFyIHJvdyA9IHRoaXMucm93c19baV07XG4gICAgICAgICAgdmFyIGlkeCA9IGJhc2VEQU9JZHggKyBpO1xuICAgICAgICAgIHJvdy5kYXRhID0gdGhpcy5kYW9Db250cm9sbGVyXy5kYXRhW2lkeF0gfHwgbnVsbDtcbiAgICAgICAgICB0aGlzLnRyYW5zbGF0ZVJvd1RvXyhpZHggPCB0aGlzLmNvdW50XyA/IGlkeCA6IC0xLCByb3cpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5hbmNob3JEQU9JZHhfID0gYW5jaG9yREFPSWR4O1xuICAgICAgICB0aGlzLmFuY2hvclJvd0lkeF8gPSAwO1xuICAgICAgfVxuICAgIH0sXG4gICAge1xuICAgICAgbmFtZTogJ21vdmVBbmNob3JGb3J3YXJkXycsXG4gICAgICBkb2N1bWVudGF0aW9uOiBgTGF5b3V0IG5lY2Vzc2FyeSByb3dzIGZvciBhbmNob3IgbW92aW5nIGZvcndhcmQgd2l0aGluIHJvd1xuICAgICAgICAgIHdpbmRvdy5gLFxuICAgICAgY29kZTogZnVuY3Rpb24oYW5jaG9yREFPSWR4KSB7XG4gICAgICAgIHZhciBkZWx0YSA9IGFuY2hvckRBT0lkeCAtIHRoaXMuYW5jaG9yREFPSWR4XztcbiAgICAgICAgdmFyIGRhb1N0YXJ0ID0gdGhpcy5hbmNob3JEQU9JZHhfICsgdGhpcy5udW1Sb3dzO1xuICAgICAgICBmb3IgKCB2YXIgaSA9IDA7IGkgPCBkZWx0YTsgaSsrICkge1xuICAgICAgICAgIHZhciByb3dJZHggPSB0aGlzLm1vZE51bVJvd3NfKHRoaXMuYW5jaG9yUm93SWR4XyArIGkpO1xuICAgICAgICAgIHZhciByb3cgPSB0aGlzLnJvd3NfW3Jvd0lkeF07XG4gICAgICAgICAgdmFyIGlkeCA9IGRhb1N0YXJ0ICsgaSA8IHRoaXMuY291bnRfID8gZGFvU3RhcnQgKyBpIDogLTE7XG4gICAgICAgICAgcm93LmRhdGEgPSB0aGlzLmRhb0NvbnRyb2xsZXJfLmRhdGFbaWR4XSB8fCBudWxsO1xuICAgICAgICAgIHRoaXMudHJhbnNsYXRlUm93VG9fKGlkeCwgcm93KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmFuY2hvckRBT0lkeF8gPSBhbmNob3JEQU9JZHg7XG4gICAgICAgIHRoaXMuYW5jaG9yUm93SWR4XyA9IHRoaXMubW9kTnVtUm93c18odGhpcy5hbmNob3JSb3dJZHhfICsgZGVsdGEpO1xuICAgICAgfVxuICAgIH0sXG4gICAge1xuICAgICAgbmFtZTogJ21vdmVBbmNob3JCYWNrd2FyZF8nLFxuICAgICAgZG9jdW1lbnRhdGlvbjogYExheW91dCBuZWNlc3Nhcnkgcm93cyBmb3IgYW5jaG9yIG1vdmluZyBiYWNrd2FyZCB3aXRoaW5cbiAgICAgICAgICByb3cgd2luZG93LmAsXG4gICAgICBjb2RlOiBmdW5jdGlvbihhbmNob3JEQU9JZHgpIHtcbiAgICAgICAgdmFyIGRlbHRhID0gdGhpcy5hbmNob3JEQU9JZHhfIC0gYW5jaG9yREFPSWR4O1xuICAgICAgICB2YXIgcm93U3RhcnQgPSB0aGlzLmFuY2hvclJvd0lkeF8gKyB0aGlzLm51bVJvd3M7XG4gICAgICAgIGZvciAoIHZhciBpID0gMTsgaSA8PSBkZWx0YTsgaSsrICkge1xuICAgICAgICAgIHZhciByb3dJZHggPSB0aGlzLm1vZE51bVJvd3NfKHJvd1N0YXJ0IC0gaSk7XG4gICAgICAgICAgdmFyIHJvdyA9IHRoaXMucm93c19bcm93SWR4XTtcbiAgICAgICAgICB2YXIgaWR4ID0gdGhpcy5hbmNob3JEQU9JZHhfIC0gaSA+PSAwID9cbiAgICAgICAgICAgICAgdGhpcy5hbmNob3JEQU9JZHhfIC0gaSA6IC0xO1xuICAgICAgICAgIHJvdy5kYXRhID0gdGhpcy5kYW9Db250cm9sbGVyXy5kYXRhW2lkeF0gfHwgbnVsbDtcbiAgICAgICAgICB0aGlzLnRyYW5zbGF0ZVJvd1RvXyhpZHgsIHJvdyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5hbmNob3JEQU9JZHhfID0gYW5jaG9yREFPSWR4O1xuICAgICAgICB0aGlzLmFuY2hvclJvd0lkeF8gPSB0aGlzLm1vZE51bVJvd3NfKHRoaXMuYW5jaG9yUm93SWR4XyAtIGRlbHRhKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHtcbiAgICAgIG5hbWU6ICd0cmFuc2xhdGVSb3dUb18nLFxuICAgICAgZG9jdW1lbnRhdGlvbjogJ0hlbHBlciB0byBjaGFuZ2Ugcm93IENTUyB0cmFuc2Zvcm0gdG8gYSBuZXcgREFPIGlkeC4nLFxuICAgICAgY29kZTogZnVuY3Rpb24oZGFvSWR4LCByb3cpIHtcbiAgICAgICAgcm93LnN0eWxlKHtcbiAgICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGVZKCcgKyAoIGRhb0lkeCAqIHRoaXMucm93SGVpZ2h0ICkgKyAncHgpJ1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHtcbiAgICAgIG5hbWU6ICdjb3VudFJlY29yZHNfJyxcbiAgICAgIGRvY3VtZW50YXRpb246IGBDb3VudCByZWNvcmRzIGluIFwiZGFvXCIsIHRoZW4gdXBkYXRlIHZpZXcgYWNjb3JkaW5nbHkuXG4gICAgICAgICAgQXNzdW1lIHRoYXQgYSAocmUpY291bnQgaW1wbGllcyBhbnkgZGF0YSBtYXkgY2hhbmdlIChhbmQgdGhlcmVmb3JlXG4gICAgICAgICAgZGF0YSBzaG91bGQgYmUgcmUtZmV0Y2hlZCkuIEFueSBjaGFuZ2UgaW4gdGhlIGxvY2F0aW9uIG9mIFwiY291bnRfXCJcbiAgICAgICAgICB3aXRoaW4gdGhlIHJvdyB3aW5kb3cgdHJpZ2dlcnMgbGF5b3V0IG9mIGFsbCByb3dzLmAsXG4gICAgICBjb2RlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICByZXR1cm4gc2VsZi5kYXRhLnNlbGVjdChzZWxmLkNPVU5UKCkpLnRoZW4oZnVuY3Rpb24oY291bnQpIHtcbiAgICAgICAgICAvLyBQcmV2ZW50IHVuaGFuZGxlZCBzY3JvbGwgZXZlbnRzIGZyb20gZmlyaW5nIGFuZCBwb3RlbnRpYWxseSBsYXlpbmdcbiAgICAgICAgICAvLyBvdXQgcm93cyBwYXN0IHRoZSBuZXcgXCJzZW50aW5lbF9cIiBsb2NhdGlvbi5cbiAgICAgICAgICBzZWxmLmFuY2hvckxvY2tfID0gdHJ1ZTtcblxuICAgICAgICAgIHZhciBvbGRDb3VudCA9IHNlbGYuY291bnRfO1xuICAgICAgICAgIHZhciBuZXdDb3VudCA9IHNlbGYuY291bnRfID0gY291bnQudmFsdWU7XG4gICAgICAgICAgdmFyIGVuZElkeCA9IHNlbGYuYW5jaG9yREFPSWR4XyArIHNlbGYubnVtUm93cztcblxuICAgICAgICAgIC8vIENob29zZSBhIHJlYXNvbmFibGUgYW5jaG9yIGZvciBuZXcgY291bnQuXG4gICAgICAgICAgdmFyIGFuY2hvckRBT0lkeCA9IE1hdGgubWluKFxuICAgICAgICAgICAgc2VsZi5hbmNob3JEQU9JZHhfLFxuICAgICAgICAgICAgTWF0aC5tYXgoMCwgc2VsZi5jb3VudF8gLSBzZWxmLm51bVJvd3MpKTtcblxuICAgICAgICAgIC8vIFVwZGF0ZSBzY3JvbGwtaW5kaWNhdGluZyBzdGF0ZSBmaXJzdCwgdGhlbiByZXNldCBEQU9Db250cm9sbGVyLlxuICAgICAgICAgIHNlbGYuYW5jaG9yREFPSWR4XyA9IGFuY2hvckRBT0lkeDtcbiAgICAgICAgICBzZWxmLmFuY2hvclJvd0lkeF8gPSAwO1xuICAgICAgICAgIHNlbGYuZGFvQ29udHJvbGxlcl8ub25SZXNldCgpO1xuXG4gICAgICAgICAgLy8gTGlrZSByZXNldEFuY2hvcl8sIGJ1dCBsYXkgb3V0IGFsbCByb3dzLlxuICAgICAgICAgIHZhciBiYXNlREFPSWR4ID0gYW5jaG9yREFPSWR4O1xuICAgICAgICAgIGZvciAoIHZhciBpID0gMDsgaSA8IHNlbGYubnVtUm93czsgaSsrICkge1xuICAgICAgICAgICAgdmFyIHJvdyA9IHNlbGYucm93c19baV07XG4gICAgICAgICAgICB2YXIgaWR4ID0gYmFzZURBT0lkeCArIGk7XG4gICAgICAgICAgICByb3cuZGF0YSA9IHNlbGYuZGFvQ29udHJvbGxlcl8uZGF0YVtpZHhdIHx8IG51bGw7XG4gICAgICAgICAgICBzZWxmLnRyYW5zbGF0ZVJvd1RvXyhpZHggPCBzZWxmLmNvdW50XyA/IGlkeCA6IC0xLCByb3cpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICBdLFxuXG4gIGFjdGlvbnM6IFtcbiAgICB7XG4gICAgICBuYW1lOiAnY2xlYXJTZWxlY3Rpb24nLFxuICAgICAgaXNFbmFibGVkOiBmdW5jdGlvbihzZWxlY3Rpb25FbmFibGVkKSB7IHJldHVybiBzZWxlY3Rpb25FbmFibGVkOyB9LFxuICAgICAga2V5Ym9hcmRTaG9ydGN1dHM6IFsyN10sIC8vIEVzY2FwZS5cbiAgICAgIGNvZGU6IGZ1bmN0aW9uKCkgeyB0aGlzLnNlbGVjdGlvbiA9IFtdOyB9XG4gICAgfVxuICBdLFxuXG4gIGxpc3RlbmVyczogW1xuICAgIHtcbiAgICAgIG5hbWU6ICdvblNjcm9sbCcsXG4gICAgICBkb2N1bWVudGF0aW9uOiAnUmVzcG9uZCB0byBzY3JvbGw6IE1vdmUgdGhlIGFuY2hvci4nLFxuICAgICAgaXNGcmFtZWQ6IHRydWUsXG4gICAgICBjb2RlOiBmdW5jdGlvbihkb21FdnQpIHtcbiAgICAgICAgaWYgKCB0aGlzLmFuY2hvckxvY2tfICkge1xuICAgICAgICAgIHRoaXMuYW5jaG9yTG9ja18gPSBmYWxzZTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgdG9wID0gZG9tRXZ0LnRhcmdldC5zY3JvbGxUb3A7XG4gICAgICAgIHZhciByZWNvcmRUb3AgPSBNYXRoLmZsb29yKHRvcCAvIHRoaXMucm93SGVpZ2h0KTtcblxuICAgICAgICAvLyBTaXR1YXRlIGFuY2hvciB3aXRoIDQwJSBvZiByb3dzIHNjcm9sbGVkIGFib3ZlLiBUaGlzIG1ha2VzIGFueSBsYWdcbiAgICAgICAgLy8gZnJvbSBmYXN0IHNjcm9sbGluZyByb3VnaGx5IHN5bW1ldHJpY2FsIG9uIHNjcm9sbC11cC9zY3JvbGwtZG93bi5cbiAgICAgICAgdmFyIHJvd3NBYm92ZSA9IDAuNCAqIHRoaXMubnVtUm93cztcbiAgICAgICAgdmFyIGFuY2hvckRBT0lkeDtcbiAgICAgICAgaWYgKCByZWNvcmRUb3AgPCByb3dzQWJvdmUgKSB7XG4gICAgICAgICAgYW5jaG9yREFPSWR4ID0gMDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBhbmNob3JEQU9JZHggPSByZWNvcmRUb3AgLSByb3dzQWJvdmU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCBhbmNob3JEQU9JZHggPT09IHRoaXMuYW5jaG9yREFPSWR4XyApIHJldHVybjtcblxuICAgICAgICB0aGlzLm1vdmVBbmNob3JfKGFuY2hvckRBT0lkeCk7XG4gICAgICB9XG4gICAgfVxuICBdXG59KTtcbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IFRoZSBGT0FNIEF1dGhvcnMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmZvYW0uQ0xBU1Moe1xuICBwYWNrYWdlOiAnZm9hbS51Mi52aWV3JyxcbiAgbmFtZTogJ0Jsb2JWaWV3JyxcbiAgZXh0ZW5kczogJ2ZvYW0udTIuRWxlbWVudCcsXG4gIHJlcXVpcmVzOiBbXG4gICAgJ2ZvYW0uYmxvYi5CbG9iQmxvYidcbiAgXSxcbiAgaW1wb3J0czogW1xuICAgICdibG9iU2VydmljZSdcbiAgXSxcbiAgcHJvcGVydGllczogW1xuICAgICdkYXRhJyxcbiAgICB7XG4gICAgICBjbGFzczogJ1N0cmluZycsXG4gICAgICBuYW1lOiAnZmlsZW5hbWUnXG4gICAgfSxcbiAgICB7XG4gICAgICBjbGFzczogJ1N0cmluZycsXG4gICAgICBuYW1lOiAndHlwZSdcbiAgICB9LFxuICAgIHtcbiAgICAgIGNsYXNzOiAnRGF0ZVRpbWUnLFxuICAgICAgbmFtZTogJ3RpbWVzdGFtcCdcbiAgICB9XG4gIF0sXG4gIG1ldGhvZHM6IFtcbiAgICBmdW5jdGlvbiBpbml0RSgpIHtcbiAgICAgIHZhciB2aWV3ID0gdGhpcztcbiAgICAgIHRoaXMuXG4gICAgICAgIHNldE5vZGVOYW1lKCdzcGFuJykuXG4gICAgICAgIHN0YXJ0KCdpbnB1dCcpLmF0dHJzKHsgdHlwZTogJ2ZpbGUnIH0pLm9uKCdjaGFuZ2UnLCB0aGlzLm9uQ2hhbmdlKS5lbmQoKS5cbiAgICAgICAgYWRkKHRoaXMuc2xvdChmdW5jdGlvbihkYXRhKSB7XG4gICAgICAgICAgdmFyIHVybCA9IGRhdGEgJiYgdmlldy5ibG9iU2VydmljZS51cmxGb3IoZGF0YSk7XG4gICAgICAgICAgcmV0dXJuICEgdXJsID8gdGhpcy5FKCdzcGFuJykgOlxuICAgICAgICAgICAgdGhpcy5FKCdhJykuYXR0cnMoeyBocmVmOiB1cmwgfSkuYWRkKCdEb3dubG9hZCcpXG4gICAgICAgIH0sIHRoaXMuZGF0YSQpKTtcbiAgICB9XG4gIF0sXG4gIGxpc3RlbmVyczogW1xuICAgIGZ1bmN0aW9uIG9uQ2hhbmdlKGUpIHtcbiAgICAgIHZhciBmaWxlID0gZS50YXJnZXQuZmlsZXNbMF07XG5cbiAgICAgIHRoaXMuZGF0YSA9IHRoaXMuQmxvYkJsb2IuY3JlYXRlKHtcbiAgICAgICAgYmxvYjogZmlsZVxuICAgICAgfSk7XG4gICAgICB0aGlzLmZpbGVuYW1lID0gZmlsZS5uYW1lO1xuICAgICAgdGhpcy50aW1lc3RhbXAgPSBuZXcgRGF0ZShmaWxlLmxhc3RNb2RpZmllZCk7XG4gICAgICB0aGlzLnR5cGUgPSBmaWxlLnR5cGU7XG4gICAgfVxuICBdXG59KTtcbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE4IFRoZSBGT0FNIEF1dGhvcnMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqL1xuXG5mb2FtLkNMQVNTKHtcbiAgcGFja2FnZTogJ2ZvYW0udTIudmlldycsXG4gIG5hbWU6ICdGaWxlVmlldycsXG4gIGV4dGVuZHM6ICdmb2FtLnUyLkVsZW1lbnQnLFxuXG4gIHJlcXVpcmVzOiBbXG4gICAgJ2ZvYW0uYmxvYi5CbG9iQmxvYicsXG4gICAgJ2ZvYW0ubmFub3MuZnMuRmlsZSdcbiAgXSxcblxuICBpbXBvcnRzOiBbXG4gICAgJ2Jsb2JTZXJ2aWNlJ1xuICBdLFxuXG4gIHByb3BlcnRpZXM6IFtcbiAgICAnZGF0YSdcbiAgXSxcblxuICBtZXRob2RzOiBbXG4gICAgZnVuY3Rpb24gaW5pdEUoKSB7XG4gICAgICB2YXIgdmlldyA9IHRoaXM7XG4gICAgICB0aGlzLnNldE5vZGVOYW1lKCdzcGFuJylcbiAgICAgICAgLnN0YXJ0KCdpbnB1dCcpLmF0dHJzKHsgdHlwZTogJ2ZpbGUnIH0pLm9uKCdjaGFuZ2UnLCB0aGlzLm9uQ2hhbmdlKS5lbmQoKVxuICAgICAgICAuYWRkKHRoaXMuc2xvdChmdW5jdGlvbihkYXRhKSB7XG4gICAgICAgICAgdmFyIGZpbGUgPSBkYXRhICYmIGRhdGEuZGF0YTtcbiAgICAgICAgICB2YXIgdXJsID0gZmlsZSAmJiB2aWV3LmJsb2JTZXJ2aWNlLnVybEZvcihmaWxlKTtcbiAgICAgICAgICByZXR1cm4gISB1cmwgPyB0aGlzLkUoJ3NwYW4nKSA6IHRoaXMuRSgnYScpLmF0dHJzKHsgaHJlZjogdXJsIH0pLmFkZCgnRG93bmxvYWQnKVxuICAgICAgICB9LCB0aGlzLmRhdGEkKSk7XG4gICAgfVxuICBdLFxuXG4gIGxpc3RlbmVyczogW1xuICAgIGZ1bmN0aW9uIG9uQ2hhbmdlIChlKSB7XG4gICAgICB2YXIgZmlsZSA9IGUudGFyZ2V0LmZpbGVzWzBdO1xuXG4gICAgICB0aGlzLmRhdGEgPSB0aGlzLkZpbGUuY3JlYXRlKHtcbiAgICAgICAgZmlsZW5hbWU6IGZpbGUubmFtZSxcbiAgICAgICAgZmlsZXNpemU6IGZpbGUuc2l6ZSxcbiAgICAgICAgbWltZVR5cGU6IGZpbGUudHlwZSxcbiAgICAgICAgZGF0YTogdGhpcy5CbG9iQmxvYi5jcmVhdGUoe1xuICAgICAgICAgIGJsb2I6IGZpbGVcbiAgICAgICAgfSlcbiAgICAgIH0pO1xuICAgIH1cbiAgXVxufSk7XG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBUaGUgRk9BTSBBdXRob3JzLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKi9cblxuZm9hbS5DTEFTUyh7XG4gIHBhY2thZ2U6ICdmb2FtLnUyLnZpZXcnLFxuICBuYW1lOiAnSW1hZ2VCbG9iVmlldycsXG4gIGV4dGVuZHM6ICdmb2FtLnUyLlZpZXcnLFxuICByZXF1aXJlczogW1xuICAgICdmb2FtLmJsb2IuQmxvYkJsb2InXG4gIF0sXG4gIGltcG9ydHM6IFtcbiAgICAnYmxvYlNlcnZpY2UnXG4gIF0sXG4gIHByb3BlcnRpZXM6IFtcbiAgICAnZGF0YScsXG4gIF0sXG4gIG1ldGhvZHM6IFtcbiAgICBmdW5jdGlvbiBpbml0RSgpIHtcbiAgICAgIHZhciB2aWV3ID0gdGhpcztcbiAgICAgIHRoaXMuXG4gICAgICAgIHN0YXJ0KCdpbWcnKS5cbiAgICAgICAgYXR0cnMoe1xuICAgICAgICAgIHNyYzogdGhpcy5kYXRhJC5tYXAoZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICAgICAgcmV0dXJuIHZpZXcuQmxvYkJsb2IuaXNJbnN0YW5jZShkYXRhKSA/XG4gICAgICAgICAgICAgIFVSTC5jcmVhdGVPYmplY3RVUkwoZGF0YS5ibG9iKSA6XG4gICAgICAgICAgICAgICggdmlldy5ibG9iU2VydmljZS51cmxGb3IoZGF0YSkgfHwgJycgKTtcbiAgICAgICAgICB9KVxuICAgICAgICB9KS5cbiAgICAgICAgZW5kKCkuXG4gICAgICAgIGFkZCh0aGlzLnNsb3QoZnVuY3Rpb24obW9kZSkge1xuICAgICAgICAgIGlmICggbW9kZSA9PSBmb2FtLnUyLkRpc3BsYXlNb2RlLlJXICkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuXG4gICAgICAgICAgICAgIEUoJ2lucHV0JykuXG4gICAgICAgICAgICAgIGF0dHJzKHsgdHlwZTogJ2ZpbGUnIH0pLlxuICAgICAgICAgICAgICBvbignY2hhbmdlJywgdGhpcy5vbkNoYW5nZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB0aGlzLkUoJ3NwYW4nKTtcbiAgICAgICAgfSwgdGhpcy5tb2RlJCkpO1xuICAgIH1cbiAgXSxcbiAgbGlzdGVuZXJzOiBbXG4gICAgZnVuY3Rpb24gb25DaGFuZ2UoZSkge1xuICAgICAgdmFyIGZpbGUgPSBlLnRhcmdldC5maWxlc1swXTtcblxuICAgICAgdGhpcy5kYXRhID0gdGhpcy5CbG9iQmxvYi5jcmVhdGUoe1xuICAgICAgICBibG9iOiBmaWxlXG4gICAgICB9KTtcbiAgICB9XG4gIF1cbn0pO1xuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgVGhlIEZPQU0gQXV0aG9ycy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICovXG5cbmZvYW0uQ0xBU1Moe1xuICBwYWNrYWdlOiAnZm9hbS51Mi52aWV3JyxcbiAgbmFtZTogJ1N0cmluZ0FycmF5VmlldycsXG4gIGV4dGVuZHM6ICdmb2FtLnUyLnRhZy5JbnB1dCcsXG5cbiAgcHJvcGVydGllczogW1xuICAgIHtcbiAgICAgIG5hbWU6ICdkYXRhJyxcbiAgICAgIHByZVNldDogZnVuY3Rpb24obywgZCkgeyByZXR1cm4gZDsgfVxuICAgIH0sXG4gICAge1xuICAgICAgY2xhc3M6ICdGdW5jdGlvbicsXG4gICAgICBuYW1lOiAndmFsdWVUb1RleHQnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZS5tYXAoZnVuY3Rpb24obSkge1xuICAgICAgICAgIHJldHVybiBtLnJlcGxhY2UoXCJcXFxcXCIsIFwiXFxcXFxcXFxcIikucmVwbGFjZShcIixcIiwgXCJcXFxcLFwiKTtcbiAgICAgICAgfSkuam9pbignLCcpO1xuICAgICAgfVxuICAgIH0sXG4gICAge1xuICAgICAgY2xhc3M6ICdGdW5jdGlvbicsXG4gICAgICBuYW1lOiAndGV4dFRvVmFsdWUnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uKHRleHQpIHtcbiAgICAgICAgaWYgKCAhIHRleHQgKSByZXR1cm4gW107XG5cbiAgICAgICAgdmFyIHZhbHVlICA9IFtdO1xuICAgICAgICB2YXIgZXNjYXBlID0gZmFsc2U7XG4gICAgICAgIHZhciBzdGFydCAgPSAwO1xuICAgICAgICBmb3IgKCB2YXIgaSA9IDAgOyBpIDwgdGV4dC5sZW5ndGggOyBpKysgKSB7XG4gICAgICAgICAgaWYgKCBlc2NhcGUgKSB7XG4gICAgICAgICAgICBlc2NhcGUgPSBmYWxzZTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICggaSA9PSB0ZXh0Lmxlbmd0aCAtIDEgKSB7XG4gICAgICAgICAgICB2YWx1ZS5wdXNoKHRleHQuc3Vic3RyaW5nKHN0YXJ0LCBpKzEpLnJlcGxhY2UoL1xcXFwoLikvLCBcIiQwXCIpKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKCB0ZXh0W2ldID09ICcsJyB8fCBpID09IHRleHQubGVuZ3RoIC0gMSApIHtcbiAgICAgICAgICAgIHZhbHVlLnB1c2godGV4dC5zdWJzdHJpbmcoc3RhcnQsIGkpLnJlcGxhY2UoL1xcXFwoLikvLCBcIiQwXCIpKTtcbiAgICAgICAgICAgIHN0YXJ0ID0gaSArIDE7XG4gICAgICAgICAgfSBlbHNlIGlmICggdGV4dFtpXSA9PSAnXFxcXCcgKSB7XG4gICAgICAgICAgICBlc2NhcGUgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgIH1cbiAgICB9XG4gIF0sXG5cbiAgbWV0aG9kczogW1xuICAgIGZ1bmN0aW9uIGxpbmsoKSB7XG4gICAgICB0aGlzLmF0dHJTbG90KCkucmVsYXRlRnJvbSh0aGlzLmRhdGEkLCB0aGlzLnRleHRUb1ZhbHVlLCB0aGlzLnZhbHVlVG9UZXh0KTtcbiAgICB9XG4gIF1cbn0pO1xuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgVGhlIEZPQU0gQXV0aG9ycy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuZm9hbS5DTEFTUyh7XG4gIHBhY2thZ2U6ICdmb2FtLnUyLnZpZXcnLFxuICBuYW1lOiAnSW1hZ2VWaWV3JyxcbiAgZXh0ZW5kczogJ2ZvYW0udTIuRWxlbWVudCcsXG4gIHByb3BlcnRpZXM6IFtcbiAgICAnZGF0YScsXG4gICAgWydub2RlTmFtZScsICdpbWcnXVxuICBdLFxuICBtZXRob2RzOiBbXG4gICAgZnVuY3Rpb24gaW5pdEUoKSB7XG4gICAgICB0aGlzLmF0dHJzKHsgc3JjOiB0aGlzLmRhdGEkIH0pO1xuICAgIH1cbiAgXVxufSk7XG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBUaGUgRk9BTSBBdXRob3JzLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKi9cblxuZm9hbS5DTEFTUyh7XG4gIHBhY2thZ2U6ICdmb2FtLnUyJyxcbiAgbmFtZTogJ0VudW1WaWV3JyxcbiAgZXh0ZW5kczogJ2ZvYW0udTIudmlldy5DaG9pY2VWaWV3JyxcblxuICBwcm9wZXJ0aWVzOiBbXG4gICAge1xuICAgICAgY2xhc3M6ICdDbGFzcycsXG4gICAgICBuYW1lOiAnb2YnLFxuICAgICAgcmVxdWlyZWQ6IHRydWVcbiAgICB9LFxuICAgIHtcbiAgICAgIG5hbWU6ICdjaG9pY2VzJyxcbiAgICAgIGV4cHJlc3Npb246IGZ1bmN0aW9uKG9mKSB7XG4gICAgICAgIHJldHVybiBvZiA/IG9mLlZBTFVFUy5tYXAoZnVuY3Rpb24odikgeyByZXR1cm4gWyB2LCB2LmxhYmVsIF07IH0pIDogW107XG4gICAgICB9XG4gICAgfVxuICBdLFxuXG4gIG1ldGhvZHM6IFtcbiAgICBmdW5jdGlvbiBmcm9tUHJvcGVydHkocCkge1xuICAgICAgdGhpcy5TVVBFUihwKTtcbiAgICAgIGlmICggISB0aGlzLm9mICkgdGhpcy5vZiA9IHAub2Y7XG4gICAgfVxuICBdXG59KVxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuZm9hbS5DTEFTUyh7XG4gIHBhY2thZ2U6ICdmb2FtLnUyJyxcbiAgbmFtZTogJ0NsYXNzVmlldycsXG4gIGV4dGVuZHM6ICdmb2FtLnUyLlRleHRGaWVsZCcsXG5cbiAgZG9jdW1lbnRhdGlvbjogJ1ZpZXcgZm9yIGVkaXRpbmcgYSBDbGFzcyBQcm9wZXJ0eS4nLFxuXG4gIHByb3BlcnRpZXM6IFtcbiAgICB7IGNsYXNzOiAnQ2xhc3MnLCBuYW1lOiAnZGF0YScgfVxuICBdLFxuXG4gIG1ldGhvZHM6IFtcbiAgICBmdW5jdGlvbiBsaW5rKCkge1xuICAgICAgdGhpcy5hdHRyU2xvdChudWxsLCBudWxsKS5yZWxhdGVGcm9tKFxuICAgICAgICAgIHRoaXMuZGF0YSQsXG4gICAgICAgICAgdGhpcy50ZXh0VG9EYXRhLmJpbmQodGhpcyksXG4gICAgICAgICAgdGhpcy5kYXRhVG9UZXh0LmJpbmQodGhpcykpO1xuICAgIH0sXG5cbiAgICBmdW5jdGlvbiBkYXRhVG9UZXh0KGMpIHtcbiAgICAgIHJldHVybiBjID8gYy5pZCA6ICcnO1xuICAgIH0sXG5cbiAgICBmdW5jdGlvbiB0ZXh0VG9EYXRhKHRleHQpIHtcbiAgICAgIHJldHVybiB0ZXh0LnRyaW0oKTtcbiAgICB9XG4gIF1cbn0pO1xuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTYgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuZm9hbS5DTEFTUyh7XG4gIHBhY2thZ2U6ICdmb2FtLnUyLnZpZXcnLFxuICBuYW1lOiAnUmVmZXJlbmNlVmlldycsXG4gIGV4dGVuZHM6ICdmb2FtLnUyLnZpZXcuQ2hvaWNlVmlldycsXG5cbiAgaW1wb3J0czogW1xuICAgICdkYXRhIGFzIHBhcmVudE9iaidcbiAgXSxcblxuICBwcm9wZXJ0aWVzOiBbXG4gICAge1xuICAgICAgbmFtZTogJ29ialRvQ2hvaWNlJyxcbiAgICAgIGZhY3Rvcnk6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgZjtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKG9iaikge1xuICAgICAgICAgIGlmICggZiApIHJldHVybiBmKG9iaik7XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuICBdLFxuXG4gIG1ldGhvZHM6IFtcbiAgICBmdW5jdGlvbiBmcm9tUHJvcGVydHkocHJvcCkge1xuICAgICAgdGhpcy5TVVBFUihwcm9wKTtcblxuICAgICAgaWYgKCAhIHRoaXMuaGFzT3duUHJvcGVydHkoJ29ialRvQ2hvaWNlJykgKSB7XG4gICAgICAgIHZhciBvZiA9IHByb3Aub2Y7XG5cbiAgICAgICAgdmFyIHByb3BzID0gb2YuZ2V0QXhpb21zQnlDbGFzcyhmb2FtLmNvcmUuU3RyaW5nKTtcbiAgICAgICAgdmFyIGY7XG5cbiAgICAgICAgLy8gRmluZCB0aGUgZmlyc3Qgbm9uLWhpZGRlbiBzdHJpbmcgcHJvcGVydHkuXG4gICAgICAgIGZvciAoIHZhciBpID0gMCA7IGkgPCBwcm9wcy5sZW5ndGggOyBpKysgKSB7XG4gICAgICAgICAgdmFyIHAgPSBwcm9wc1tpXTtcbiAgICAgICAgICBpZiAoICEgcC5oaWRkZW4gKSB7XG4gICAgICAgICAgICB0aGlzLm9ialRvQ2hvaWNlID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgICAgICAgICAgIHJldHVybiBbb2JqLmlkLCBwLmYob2JqKV07XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCBpID09PSBwcm9wcy5sZW5ndGggKSB7XG4gICAgICAgICAgdGhpcy5vYmpUb0Nob2ljZSA9IGZ1bmN0aW9uKG9iaikge1xuICAgICAgICAgICAgcmV0dXJuIFtvYmouaWQsIG9iai5pZF07XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgZGFvID0gdGhpcy5wYXJlbnRPYmouX19jb250ZXh0X19bcHJvcC50YXJnZXREQU9LZXldO1xuICAgICAgdGhpcy5kYW8gPSBkYW87XG4gICAgfVxuICBdXG59KTtcbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4gXG5mb2FtLkNMQVNTKHtcbiAgcGFja2FnZTogJ2ZvYW0udTIudGFnJyxcbiAgbmFtZTogJ0NhcmQnLFxuICBleHRlbmRzOiAnZm9hbS51Mi5FbGVtZW50JyxcblxuICBkb2N1bWVudGF0aW9uOiAnVGhpcyBpcyBhIHNpbXBsZSBkaXYgaW4gbm9uLU1ELiBMaWtlbHkgdG8gYmUgb3ZlcnJpZGRlbiAnICtcbiAgICAgICdsYXRlciB3aXRoIFBvbHltZXJcXCdzIDxwYXBlci1jYXJkPiBvciBzaW1pbGFyLidcbn0pO1xuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuZm9hbS5DTEFTUyh7XG4gIHBhY2thZ2U6ICdmb2FtLnUyLmRpYWxvZycsXG4gIG5hbWU6ICdQb3B1cCcsXG4gIGV4dGVuZHM6ICdmb2FtLnUyLkVsZW1lbnQnLFxuXG4gIGRvY3VtZW50YXRpb246ICdUaGlzIGlzIGEgY29udGFpbmVyIGZvciBhIHdob2xlLXNjcmVlbiwgbW9kYWwgb3ZlcmxheS4gSXQgJyArXG4gICAgICAnZmlsbHMgdGhlIHZpZXdwb3J0IHdpdGggYSB0cmFuc3BhcmVudCBncmV5IGJhY2tncm91bmQsIGFuZCB0aGVuICcgK1xuICAgICAgJ2NlbnRlcnMgdGhlIFwiY29udGVudFwiIGVsZW1lbnQuIENsaWNraW5nIHRoZSBiYWNrZ3JvdW5kIGNsb3NlcyB0aGUgJyArXG4gICAgICAnZGlhbG9nLiBFeHBvcnRzIGl0c2VsZiBhcyBcIm92ZXJsYXlcIiwgZm9yIHVzZSBieSBPSyBhbmQgQ0FOQ0VMIGJ1dHRvbnMuJyxcblxuICBleHBvcnRzOiBbXG4gICAgJ2Nsb3NlIGFzIGNsb3NlRGlhbG9nJ1xuICBdLFxuXG4gIGF4aW9tczogW1xuICAgIGZvYW0udTIuQ1NTLmNyZWF0ZSh7XG4gICAgICBjb2RlOiBmdW5jdGlvbigpIHsvKlxuICAgICAgICBeIHtcbiAgICAgICAgICBhbGlnbi1pdGVtczogY2VudGVyO1xuICAgICAgICAgIGJvdHRvbTogMDtcbiAgICAgICAgICBkaXNwbGF5OiBmbGV4O1xuICAgICAgICAgIGp1c3RpZnktY29udGVudDogc3BhY2UtYXJvdW5kO1xuICAgICAgICAgIGxlZnQ6IDA7XG4gICAgICAgICAgcG9zaXRpb246IGZpeGVkO1xuICAgICAgICAgIHJpZ2h0OiAwO1xuICAgICAgICAgIHRvcDogMDtcbiAgICAgICAgICB6LWluZGV4OiAxMDAwO1xuICAgICAgICB9XG4gICAgICAgIF5jb250YWluZXIge1xuICAgICAgICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG4gICAgICAgICAgZGlzcGxheTogZmxleDtcbiAgICAgICAgICBoZWlnaHQ6IDEwMCU7XG4gICAgICAgICAganVzdGlmeS1jb250ZW50OiBzcGFjZS1hcm91bmQ7XG4gICAgICAgICAgcG9zaXRpb246IHJlbGF0aXZlO1xuICAgICAgICAgIHdpZHRoOiAxMDAlO1xuICAgICAgICB9XG4gICAgICAgIF5iYWNrZ3JvdW5kIHtcbiAgICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjMDAwO1xuICAgICAgICAgIGJvdHRvbTogMDtcbiAgICAgICAgICBsZWZ0OiAwO1xuICAgICAgICAgIG9wYWNpdHk6IDAuNDtcbiAgICAgICAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgICAgICAgcmlnaHQ6IDA7XG4gICAgICAgICAgdG9wOiAwO1xuICAgICAgICB9XG4gICAgICAgIF5pbm5lciB7XG4gICAgICAgICAgei1pbmRleDogMztcbiAgICAgICAgfVxuICAgICAgKi99XG4gICAgfSlcbiAgXSxcblxuICBwcm9wZXJ0aWVzOiBbXG4gICAgWyAnYmFja2dyb3VuZENvbG9yJywgJyNmZmYnIF1cbiAgXSxcblxuICBtZXRob2RzOiBbXG4gICAgZnVuY3Rpb24gaW5pdCgpIHtcbiAgICAgIHRoaXMuU1VQRVIoKTtcbiAgICAgIHZhciBjb250ZW50O1xuXG4gICAgICB0aGlzLmFkZENsYXNzKHRoaXMubXlDbGFzcygpKVxuICAgICAgICAgIC5zdGFydCgpXG4gICAgICAgICAgLmFkZENsYXNzKHRoaXMubXlDbGFzcygnY29udGFpbmVyJykpXG4gICAgICAgICAgLnN0YXJ0KClcbiAgICAgICAgICAgICAgLmFkZENsYXNzKHRoaXMubXlDbGFzcygnYmFja2dyb3VuZCcpKVxuICAgICAgICAgICAgICAub24oJ2NsaWNrJywgdGhpcy5jbG9zZSlcbiAgICAgICAgICAuZW5kKClcbiAgICAgICAgICAuc3RhcnQoKVxuICAgICAgICAgICAgICAuY2FsbChmdW5jdGlvbigpIHsgY29udGVudCA9IHRoaXM7IH0pXG4gICAgICAgICAgICAgIC5hZGRDbGFzcyh0aGlzLm15Q2xhc3MoJ2lubmVyJykpXG4gICAgICAgICAgICAgIC5zdHlsZSh7ICdiYWNrZ3JvdW5kLWNvbG9yJzogdGhpcy5iYWNrZ3JvdW5kQ29sb3IgfSlcbiAgICAgICAgICAuZW5kKClcbiAgICAgIC5lbmQoKTtcblxuICAgICAgdGhpcy5jb250ZW50ID0gY29udGVudDtcbiAgICB9LFxuXG4gICAgZnVuY3Rpb24gb3BlbigpIHtcbiAgICAgIHRoaXMuZG9jdW1lbnQuYm9keS5pbnNlcnRBZGphY2VudEhUTUwoJ2JlZm9yZWVuZCcsIHRoaXMub3V0ZXJIVE1MKTtcbiAgICAgIHRoaXMubG9hZCgpO1xuICAgIH1cbiAgXSxcblxuICBsaXN0ZW5lcnM6IFtcbiAgICBmdW5jdGlvbiBjbG9zZSgpIHtcbiAgICAgIHRoaXMucmVtb3ZlKCk7XG4gICAgfVxuICBdXG59KTtcbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE4IFRoZSBGT0FNIEF1dGhvcnMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmZvYW0uQ0xBU1Moe1xuICBwYWNrYWdlOiAnZm9hbS51Mi5kaWFsb2cnLFxuICBuYW1lOiAnTm90aWZpY2F0aW9uTWVzc2FnZScsXG4gIGV4dGVuZHM6ICdmb2FtLnUyLlZpZXcnLFxuXG4gIGRvY3VtZW50YXRpb246ICdlcnJvciBtZXNzYWdlIGhhbmRsZXIgZm9yIG1lcmNoYW50IGFwcC4nLFxuXG4gIHByb3BlcnRpZXM6IFtcbiAgICB7XG4gICAgICBjbGFzczogJ1N0cmluZycsXG4gICAgICBuYW1lOiAndHlwZSdcbiAgICB9LFxuICAgICdtZXNzYWdlJyxcbiAgICAnZGF0YSdcbiAgXSxcblxuICBheGlvbXM6IFtcbiAgICBmb2FtLnUyLkNTUy5jcmVhdGUoe1xuICAgICAgY29kZTogZnVuY3Rpb24gQ1NTKCkgeyAvKlxuICAgICAgICBeIHtcbiAgICAgICAgICB3aWR0aDogMjUwcHg7XG4gICAgICAgICAgcGFkZGluZzogMjBweCA2MHB4O1xuICAgICAgICAgIGJhY2tncm91bmQ6ICNjZmYwZTE7XG4gICAgICAgICAgcG9zaXRpb246IGZpeGVkO1xuICAgICAgICAgIHRvcDogMTAwcHg7XG4gICAgICAgICAgcmlnaHQ6IDEwMHB4O1xuICAgICAgICAgIGJvcmRlcjogMXB4IHNvbGlkICMyY2FiNzA7XG4gICAgICAgICAgYW5pbWF0aW9uLW5hbWU6IGZhZGU7XG4gICAgICAgICAgYW5pbWF0aW9uLWR1cmF0aW9uOiA0cztcbiAgICAgICAgICBmb250LXNpemU6IDEycHg7XG4gICAgICAgICAgbGluZS1oZWlnaHQ6IDEuMzM7XG4gICAgICAgICAgbGV0dGVyLXNwYWNpbmc6IDAuMnB4O1xuICAgICAgICAgIHRleHQtYWxpZ246IGNlbnRlcjtcbiAgICAgICAgICB6LWluZGV4OiAxNTAwMDtcbiAgICAgICAgfVxuICAgICAgICBAa2V5ZnJhbWVzIGZhZGUge1xuICAgICAgICAgIDAlIHsgb3BhY2l0eTogMDsgfVxuICAgICAgICAgIDEwJSB7IG9wYWNpdHk6IDE7IH1cbiAgICAgICAgICA4MCUgeyBvcGFjaXR5OiAxOyB9XG4gICAgICAgICAgMTAwJSB7IG9wYWNpdHk6IDA7IH1cbiAgICAgICAgfVxuICAgICAgICBeZXJyb3ItYmFja2dyb3VuZHtcbiAgICAgICAgICBiYWNrZ3JvdW5kOiAjZjRjY2NjO1xuICAgICAgICAgIGJvcmRlcjogMXB4IHNvbGlkICNmMzNkM2Q7XG4gICAgICAgIH1cbiAgICAgICAgXiAuY2xvc2UteHtcbiAgICAgICAgICByaWdodDogNXB4O1xuICAgICAgICAgIHRvcDogMTBweDtcbiAgICAgICAgfVxuICAgICAgICBeIC5mb2FtLXUyLUFjdGlvblZpZXctY2xvc2V7XG4gICAgICAgICAgd2lkdGg6IDMwcHg7XG4gICAgICAgICAgaGVpZ2h0OiAzMHB4O1xuICAgICAgICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICAgICAgICBsZWZ0OiAwcHg7XG4gICAgICAgICAgdG9wOiAtNXB4O1xuICAgICAgICAgIHotaW5kZXg6IDEwMTtcbiAgICAgICAgICBvcGFjaXR5OiAwLjAxO1xuICAgICAgICB9XG4gICAgICAgIF4gLmNsb3NlLXgge1xuICAgICAgICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICAgICAgICB3aWR0aDogMzJweDtcbiAgICAgICAgICBoZWlnaHQ6IDMycHg7XG4gICAgICAgICAgb3BhY2l0eTogMC4zO1xuICAgICAgICB9XG4gICAgICAgIF4gLmNsb3NlLXg6aG92ZXIge1xuICAgICAgICAgIG9wYWNpdHk6IDE7XG4gICAgICAgIH1cbiAgICAgICAgXiAuY2xvc2UteDpiZWZvcmUsIC5jbG9zZS14OmFmdGVyIHtcbiAgICAgICAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgICAgICAgY29udGVudDogJyAnO1xuICAgICAgICAgIGhlaWdodDogMjBweDtcbiAgICAgICAgICB3aWR0aDogMnB4O1xuICAgICAgICAgIGJhY2tncm91bmQtY29sb3I6ICMzMzM7XG4gICAgICAgIH1cbiAgICAgICAgXiAuY2xvc2UteDpiZWZvcmUge1xuICAgICAgICAgIHRyYW5zZm9ybTogcm90YXRlKDQ1ZGVnKTtcbiAgICAgICAgfVxuICAgICAgICBeIC5jbG9zZS14OmFmdGVyIHtcbiAgICAgICAgICB0cmFuc2Zvcm06IHJvdGF0ZSgtNDVkZWcpO1xuICAgICAgICB9XG4gICAgICAqL1xuICAgICAgfVxuICAgIH0pXG4gIF0sXG5cbiAgbWV0aG9kczogW1xuICAgIGZ1bmN0aW9uIGluaXRFKCl7XG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICAgIHRoaXNcbiAgICAgICAgLmFkZENsYXNzKHRoaXMubXlDbGFzcygpKS5lbmFibGVDbGFzcyh0aGlzLm15Q2xhc3MoJ2Vycm9yLWJhY2tncm91bmQnKSwgdGhpcy50eXBlID09PSAnZXJyb3InKVxuICAgICAgICAuc3RhcnQoKVxuICAgICAgICAgIC5hZGQodGhpcy5tZXNzYWdlKVxuICAgICAgICAuZW5kKClcbiAgICAgICAgLnN0YXJ0Q29udGV4dCh7IGRhdGE6IHRoaXMgfSlcbiAgICAgICAgICAuc3RhcnQoKS5hZGRDbGFzcygnY2xvc2UteCcpLmFkZCh0aGlzLkNMT1NFKS5lbmQoKVxuICAgICAgICAuZW5kQ29udGV4dCgpXG5cbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpeyBzZWxmLnJlbW92ZSgpIH0sIDM5MDApO1xuICAgIH1cbiAgXSxcblxuICBhY3Rpb25zOiBbXG4gICAge1xuICAgICAgbmFtZTogJ2Nsb3NlJyxcbiAgICAgIGxhYmVsOiAnJyxcbiAgICAgIGNvZGU6IGZ1bmN0aW9uKFgpe1xuICAgICAgICBYLmRhdGEucmVtb3ZlKCk7XG4gICAgICB9XG4gICAgfVxuICBdXG59KTtcbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmZvYW0uQ0xBU1Moe1xuICBwYWNrYWdlOiAnZm9hbS51MicsXG4gIG5hbWU6ICdBdXRvY29tcGxldGVyJyxcblxuICBkb2N1bWVudGF0aW9uOiAnQmFzaWMgYXV0b2NvbXBsZXRlIGNvbnRyb2xsZXIuIFN1cHBvcnRzIHNpbXBsZSAnICtcbiAgICAgICdhdXRvY29tcGxldGUsIGRlZmF1bHRpbmcgdG8gcXVlcnlpbmcgYnkgS2V5d29yZC4gVXNlIHRoaXMgYXMgYSBiYXNlICcgK1xuICAgICAgJ2NsYXNzIGZvciBvdGhlciwgbW9yZSBzb3BoaXN0aWNhdGVkIGF1dG9jb21wbGV0ZXJzLicsXG5cbiAgcHJvcGVydGllczogW1xuICAgIHtcbiAgICAgIG5hbWU6ICdkYW8nLFxuICAgICAgcmVxdWlyZWQ6IHRydWUsXG4gICAgICBkb2N1bWVudGF0aW9uOiAnVGhlIERBTyB0byBjb21wbGV0ZSBhZ2FpbnN0LidcbiAgICB9LFxuICAgIHtcbiAgICAgIGNsYXNzOiAnU3RyaW5nJyxcbiAgICAgIG5hbWU6ICdwYXJ0aWFsJyxcbiAgICAgIGRvY3VtZW50YXRpb246ICdUaGUgc3RyaW5nIHRoZSB1c2VyIGhhcyBlbnRlcmVkIHNvIGZhci4gVXN1YWxseSBib3VuZCAnICtcbiAgICAgICAgICAndG8gc29tZSB0ZXh0IGZpZWxkLidcbiAgICB9LFxuICAgIHtcbiAgICAgIG5hbWU6ICdxdWVyeUZhY3RvcnknLFxuICAgICAgZG9jdW1lbnRhdGlvbjogJ1R1cm5zIHRoZSB1c2VyXFwncyBzdHJpbmcgaW50byBhbiBtTGFuZyBxdWVyeS4gRGVmYXVsdHMgJyArXG4gICAgICAgICAgJ3RvIEtleXdvcmQuJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbihzdHIpIHtcbiAgICAgICAgcmV0dXJuIGZvYW0ubWxhbmcucHJlZGljYXRlLktleXdvcmQuY3JlYXRlKHsgYXJnMTogc3RyIH0pO1xuICAgICAgfVxuICAgIH0sXG4gICAge1xuICAgICAgY2xhc3M6ICdGdW5jdGlvbicsXG4gICAgICBuYW1lOiAnb2JqVG9TdHJpbmcnLFxuICAgICAgZG9jdW1lbnRhdGlvbjogJ1doZW4gdGhlIHVzZXIgaGFzIHNlbGVjdGVkIGFuIG9iamVjdCBmcm9tIHRoZSBEQU8gYXMgJyArXG4gICAgICAgICAgJ3RoZSBjaG9zZW4gY29tcGxldGlvbiwgd2UgbmVlZCB0byB0dXJuIGl0IGJhY2sgaW50byBhIHN0cmluZyBmb3IgJyArXG4gICAgICAgICAgJ3RoZSB0ZXh0IGZpZWxkLicsXG4gICAgICByZXF1aXJlZDogdHJ1ZVxuICAgIH0sXG4gICAgJ2ZpbHRlcmVkREFPJ1xuICBdLFxuXG4gIG1ldGhvZHM6IFtcbiAgICBmdW5jdGlvbiBpbml0KCkge1xuICAgICAgdGhpcy5TVVBFUigpO1xuICAgICAgdGhpcy5zbG90KGZ1bmN0aW9uKGRhbywgcGFydGlhbCkge1xuICAgICAgICB0aGlzLm9uVXBkYXRlKCk7XG4gICAgICB9LmJpbmQodGhpcyksIHRoaXMuZGFvJCwgdGhpcy5wYXJ0aWFsJCk7XG4gICAgfVxuICBdLFxuXG4gIGxpc3RlbmVyczogW1xuICAgIHtcbiAgICAgIG5hbWU6ICdvblVwZGF0ZScsXG4gICAgICBpc0ZyYW1lZDogdHJ1ZSxcbiAgICAgIGNvZGU6IGZ1bmN0aW9uIG9uVXBkYXRlKCkge1xuICAgICAgICBpZiAoICEgdGhpcy5kYW8gKSByZXR1cm47XG4gICAgICAgIHRoaXMuZmlsdGVyZWREQU8gPSB0aGlzLnBhcnRpYWwgP1xuICAgICAgICAgICAgdGhpcy5kYW8ud2hlcmUodGhpcy5xdWVyeUZhY3RvcnkodGhpcy5wYXJ0aWFsKSkgOiB0aGlzLmRhbztcbiAgICAgIH1cbiAgICB9XG4gIF1cbn0pO1xuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTYgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuZm9hbS5DTEFTUyh7XG4gIHBhY2thZ2U6ICdmb2FtLnUyLnNlYXJjaCcsXG4gIG5hbWU6ICdGaWx0ZXJDb250cm9sbGVyJyxcbiAgZXh0ZW5kczogJ2ZvYW0udTIuVmlldycsXG5cbiAgcmVxdWlyZXM6IFtcbiAgICAnZm9hbS5tbGFuZy5zaW5rLkNvdW50JyxcbiAgICAnZm9hbS51Mi5UYWJsZVZpZXcnLFxuICAgICdmb2FtLnUyLlZpZXdTcGVjJyxcbiAgICAnZm9hbS51Mi50YWcuQ2FyZCcsXG4gICAgJ2ZvYW0udTIudGFnLklucHV0JyxcbiAgICAnZm9hbS51Mi52aWV3LkNob2ljZVZpZXcnLFxuICAgIC8vJ2ZvYW0udTIuc2VhcmNoLkRhdGVGaWVsZFNlYXJjaFZpZXcnLFxuICAgICdmb2FtLnUyLnNlYXJjaC5Cb29sZWFuUmVmaW5lbWVudCcsXG4gICAgJ2ZvYW0udTIuc2VhcmNoLkVudW1SZWZpbmVtZW50JyxcbiAgICAnZm9hbS51Mi5zZWFyY2guR3JvdXBBdXRvY29tcGxldGVTZWFyY2hWaWV3JyxcbiAgICAnZm9hbS51Mi5zZWFyY2guR3JvdXBCeVNlYXJjaFZpZXcnLFxuICAgICdmb2FtLnUyLnNlYXJjaC5Qcm9wZXJ0eVJlZmluZW1lbnQnLFxuICAgICdmb2FtLnUyLnNlYXJjaC5TZWFyY2hNYW5hZ2VyJyxcbiAgICAnZm9hbS51Mi5zZWFyY2guVGV4dFNlYXJjaFZpZXcnXG4gIF0sXG5cbiAgZXhwb3J0czogW1xuICAgICdhcyBmaWx0ZXJDb250cm9sbGVyJyxcbiAgICAnZGF0YSBhcyB1bmZpbHRlcmVkREFPJ1xuICBdLFxuXG4gIGF4aW9tczogW1xuICAgIGZvYW0udTIuQ1NTLmNyZWF0ZSh7XG4gICAgICBjb2RlOiBmdW5jdGlvbiBDU1MoKSB7LypcbiAgICAgICAgXiB7XG4gICAgICAgICAgZGlzcGxheTogZmxleDtcbiAgICAgICAgICBvdmVyZmxvdzogaGlkZGVuO1xuICAgICAgICAgIGZsZXgtZ3JvdzogMTtcbiAgICAgICAgICB3aWR0aDogMTAwJTtcbiAgICAgICAgfVxuICAgICAgICBec2VhcmNoLXBhbmVsIHtcbiAgICAgICAgICBkaXNwbGF5OiBmbGV4O1xuICAgICAgICAgIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XG4gICAgICAgICAgZmxleC1zaHJpbms6IDA7XG4gICAgICAgICAgb3ZlcmZsb3c6IGhpZGRlbjtcbiAgICAgICAgICBtaW4td2lkdGg6IDI1MHB4O1xuICAgICAgICB9XG4gICAgICAgIF5hZGRpbmcge1xuICAgICAgICAgIGJvcmRlcjogbm9uZTtcbiAgICAgICAgICBmbGV4LXNocmluazogMDtcbiAgICAgICAgICBmbGV4LWdyb3c6IDA7XG4gICAgICAgICAgcGFkZGluZzogOHB4O1xuICAgICAgICB9XG4gICAgICAgIF5hZGQtZmlsdGVyIHtcbiAgICAgICAgICBhbGlnbi1pdGVtczogY2VudGVyO1xuICAgICAgICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgICAgICAganVzdGlmeS1jb250ZW50OiBzcGFjZS1iZXR3ZWVuO1xuICAgICAgICB9XG4gICAgICAgIF5jb3VudCB7XG4gICAgICAgICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbiAgICAgICAgICBkaXNwbGF5OiBmbGV4O1xuICAgICAgICAgIGp1c3RpZnktY29udGVudDogc3BhY2UtYmV0d2VlbjtcbiAgICAgICAgfVxuICAgICAgICBecmVzdWx0cyB7XG4gICAgICAgICAgZGlzcGxheTogZmxleDtcbiAgICAgICAgICBmbGV4LWdyb3c6IDE7XG4gICAgICAgICAgb3ZlcmZsb3c6IGhpZGRlbjtcbiAgICAgICAgfVxuICAgICAgICBeZmlsdGVyLWFyZWEge1xuICAgICAgICAgIGZsZXgtZ3JvdzogMTtcbiAgICAgICAgICBvdmVyZmxvdy15OiBhdXRvO1xuICAgICAgICB9XG4gICAgICAgIF5maWx0ZXItaGVhZGVyIHtcbiAgICAgICAgICBhbGlnbi1pdGVtczogY2VudGVyO1xuICAgICAgICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgICAgIH1cbiAgICAgICAgXmZpbHRlci1sYWJlbCB7XG4gICAgICAgICAgZmxleC1ncm93OiAxO1xuICAgICAgICB9XG4gICAgICAgIF5maWx0ZXItY29udGFpbmVyIHtcbiAgICAgICAgICBtYXJnaW46IDZweCA4cHggMHB4O1xuICAgICAgICB9XG4gICAgICAqL31cbiAgICB9KVxuICBdLFxuXG4gIHByb3BlcnRpZXM6IFtcbiAgICAnY291bnQnLFxuICAgICd0b3RhbENvdW50JyxcbiAgICB7XG4gICAgICBuYW1lOiAnY291bnRTdHJpbmcnLFxuICAgICAgZXhwcmVzc2lvbjogZnVuY3Rpb24oY291bnQsIHRvdGFsQ291bnQpIHtcbiAgICAgICAgcmV0dXJuIChjb3VudCB8fCAnMCcpICsgJyBvZiAnICsgKHRvdGFsQ291bnQgfHwgJzAnKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHtcbiAgICAgIGNsYXNzOiAnZm9hbS5kYW8uREFPUHJvcGVydHknLFxuICAgICAgbmFtZTogJ2RhdGEnLFxuICAgICAgcmVxdWlyZWQ6IHRydWVcbiAgICB9LFxuICAgICdmaWx0ZXJlZERBTycsXG4gICAge1xuICAgICAgbmFtZTogJ2ZpbHRlckNob2ljZScsXG4gICAgICBsYWJlbDogJ05ldyBGaWx0ZXInLFxuICAgICAgZmFjdG9yeTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRlZmF1bHRGaWx0ZXI7XG4gICAgICB9XG4gICAgfSxcbiAgICB7XG4gICAgICBuYW1lOiAnZmlsdGVycycsXG4gICAgICBhZGFwdDogZnVuY3Rpb24ob2xkLCBudSkge1xuICAgICAgICAvLyBDb252ZXJ0IGZyb20gYSBsaXN0IG9mIHN0cmluZ3MgdG8gdGhlIGZ1bGwgc2V0IG9mIGZpbHRlcnMuXG4gICAgICAgIGlmICggbnUgJiYgbnUubGVuZ3RoICYmIHR5cGVvZiBudVswXSA9PT0gJ3N0cmluZycgKSB7XG4gICAgICAgICAgdmFyIG91dCA9IFtdO1xuICAgICAgICAgIGZvciAoIHZhciBpID0gMDsgaSA8IG51Lmxlbmd0aDsgaSsrICkge1xuICAgICAgICAgICAgdmFyIGYgPSB0aGlzLmRhdGEub2YuZ2V0QXhpb21CeU5hbWUobnVbaV0pO1xuICAgICAgICAgICAgb3V0LnB1c2goWyBmLm5hbWUsIGYubGFiZWwgXSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBvdXQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbnU7XG4gICAgICB9LFxuICAgICAgZmFjdG9yeTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBwcm9wcyA9IHRoaXMuZGF0YS5vZi5nZXRBeGlvbXNCeUNsYXNzKGZvYW0uY29yZS5Qcm9wZXJ0eSlcbiAgICAgICAgICAgIC5maWx0ZXIoZnVuY3Rpb24ocCkgeyByZXR1cm4gISBwLmhpZGRlbjsgfSk7XG4gICAgICAgIHJldHVybiBwcm9wcy5zb3J0KGZ1bmN0aW9uKGEsIGIpIHtcbiAgICAgICAgICByZXR1cm4gYS5MQUJFTC5jb21wYXJlKGEsIGIpO1xuICAgICAgICB9KS5tYXAoZnVuY3Rpb24ocCkge1xuICAgICAgICAgIHJldHVybiBbIHAubmFtZSwgcC5sYWJlbCBdO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHtcbiAgICAgIGNsYXNzOiAnQm9vbGVhbicsXG4gICAgICBuYW1lOiAnYWxsb3dEdXBsaWNhdGVGaWx0ZXJzJyxcbiAgICAgIGhlbHA6ICdXaGVuIHRoaXMgaXMgdHJ1ZSwgeW91IGNhbiBjcmVhdGUgbXVsdGlwbGUgZmlsdGVycyBmb3Igb25lICcgK1xuICAgICAgICAgICdwcm9wZXJ0eS4nLFxuICAgICAgdmFsdWU6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICBjbGFzczogJ0Jvb2xlYW4nLFxuICAgICAgbmFtZTogJ2FsbG93QWRkaW5nRmlsdGVycycsXG4gICAgICBoZWxwOiAnV2hlbiB0aGlzIGlzIHRydWUsIHRoZSBjb250cm9scyBmb3IgYWRkaW5nIG5ldyBmaWx0ZXJzIGlzIHNob3duICcgK1xuICAgICAgICAgICdhdCB0aGUgdG9wLiBXaGVuIGl0IGlzIGZhbHNlLCBqdXN0IHRoZSBDTEVBUiBidXR0b24gYW5kIGNvdW50IGFyZSAnICtcbiAgICAgICAgICAncHJlc2VudC4nLFxuICAgICAgdmFsdWU6IHRydWVcbiAgICB9LFxuICAgIHtcbiAgICAgIGNsYXNzOiAnZm9hbS51Mi5WaWV3U3BlYycsXG4gICAgICBuYW1lOiAnZmlsdGVyQXJlYVNwZWMnLFxuICAgICAgdmFsdWU6ICdkaXYnXG4gICAgfSxcbiAgICB7XG4gICAgICBjbGFzczogJ0Jvb2xlYW4nLFxuICAgICAgbmFtZTogJ3RleHRTZWFyY2gnLFxuICAgICAgaGVscDogJ1NldCB0aGlzIHRvIHRydWUgdG8gZW5hYmxlIGZyZWVmb3JtIHRleHQgc2VhcmNoLicsXG4gICAgICB2YWx1ZTogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgIGNsYXNzOiAnRnVuY3Rpb24nLFxuICAgICAgbmFtZTogJ2J1aWxkRmlsdGVyJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBidWlsZEZpbHRlcihhcmdzKSB7XG4gICAgICAgIHZhciBlID0gdGhpcy5DYXJkLmNyZWF0ZSgpO1xuICAgICAgICBlLnN0eWxlKHtcbiAgICAgICAgICAnbWFyZ2luLWJvdHRvbSc6ICcwJyxcbiAgICAgICAgICBvdmVyZmxvdzogJ3Zpc2libGUnXG4gICAgICAgIH0pLmFkZENsYXNzKHRoaXMubXlDbGFzcygnZmlsdGVyLWNvbnRhaW5lcicpKVxuICAgICAgICAgICAgLnN0YXJ0KCdkaXYnKVxuICAgICAgICAgICAgICAgIC5hZGRDbGFzcyh0aGlzLm15Q2xhc3MoJ2ZpbHRlci1oZWFkZXInKSlcbiAgICAgICAgICAgICAgICAuYWRkKGFyZ3MubGFiZWwpXG4gICAgICAgICAgICAuZW5kKClcbiAgICAgICAgICAgIC5zdGFydENvbnRleHQoeyBkYXRhOiBhcmdzLmtleSB9KVxuICAgICAgICAgICAgICAgIC5hZGQoYXJncy5zaG93UmVtb3ZlID8gdGhpcy5SRU1PVkVfRklMVEVSIDogdW5kZWZpbmVkKVxuICAgICAgICAgICAgLmVuZENvbnRleHQoKVxuICAgICAgICAuZW5kKCk7XG5cbiAgICAgICAgZS5zdGFydCgnZGl2JylcbiAgICAgICAgICAgIC5hZGRDbGFzcyh0aGlzLm15Q2xhc3MoJ2ZpbHRlci1ib2R5JykpXG4gICAgICAgICAgICAuYWRkKGFyZ3MudmlldylcbiAgICAgICAgLmVuZCgpO1xuICAgICAgICByZXR1cm4gZTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHtcbiAgICAgIG5hbWU6ICdzZWFyY2hNZ3JfJyxcbiAgICAgIGZhY3Rvcnk6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5TZWFyY2hNYW5hZ2VyLmNyZWF0ZSh7XG4gICAgICAgICAgZGFvJDogdGhpcy5kYXRhJCxcbiAgICAgICAgICBmaWx0ZXJlZERBTyQ6IHRoaXMuZmlsdGVyZWREQU8kXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0sXG4gICAge1xuICAgICAgY2xhc3M6ICdTdHJpbmdBcnJheScsXG4gICAgICBuYW1lOiAnc2VhcmNoRmllbGRzJyxcbiAgICAgIGRvY3VtZW50YXRpb246ICdQcm9wZXJ0eSBuYW1lcyB0aGF0IGFyZSBjdXJyZW50bHkgc2VsZWN0ZWQgYXMgZmlsdGVycy4nLFxuICAgICAgZmFjdG9yeTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiAoIHRoaXMuZGF0YSAmJiB0aGlzLmRhdGEub2YgJiYgdGhpcy5kYXRhLm9mLnRhYmxlQ29sdW1ucyApIHx8IFtdO1xuICAgICAgfVxuICAgIH0sXG4gICAge1xuICAgICAgbmFtZTogJ3NlYXJjaFZpZXdzXycsXG4gICAgICBmYWN0b3J5OiBmdW5jdGlvbigpIHsgcmV0dXJuIHt9OyB9XG4gICAgfSxcbiAgICB7XG4gICAgICBuYW1lOiAnc2VhcmNoJyxcbiAgICAgIGZhY3Rvcnk6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgb2YgPSB0aGlzLmRhdGEub2Y7XG4gICAgICAgIGlmICggb2YuaWQgKSBvZiA9IG9mLmlkO1xuICAgICAgICByZXR1cm4gdGhpcy5UZXh0U2VhcmNoVmlldy5jcmVhdGUoe1xuICAgICAgICAgIG9mOiBvZixcbiAgICAgICAgICByaWNoU2VhcmNoOiB0cnVlLFxuICAgICAgICAgIGtleXdvcmRTZWFyY2g6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSxcbiAgICB7XG4gICAgICBuYW1lOiAnZmlsdGVyc0VfJ1xuICAgIH0sXG4gICAge1xuICAgICAgY2xhc3M6ICdmb2FtLnUyLlZpZXdTcGVjJyxcbiAgICAgIG5hbWU6ICd0YWJsZVZpZXcnLFxuICAgICAgdmFsdWU6IHsgY2xhc3M6ICdmb2FtLnUyLlRhYmxlVmlldycgfVxuICAgIH0sXG4gICAge1xuICAgICAgbmFtZTogJ3RhYmxlJ1xuICAgIH0sXG4gICAge1xuICAgICAgbmFtZTogJ2xvYWRlZF8nLFxuICAgICAgdmFsdWU6IGZhbHNlXG4gICAgfSxcbiAgICBbICdvbGRTZWFyY2hGaWVsZHNfJywgbnVsbCBdLFxuICAgIFsgJ2FkZGluZ1NwZWMnLCB1bmRlZmluZWQgXVxuICBdLFxuXG4gIG1ldGhvZHM6IFtcbiAgICBmdW5jdGlvbiBpbml0RSgpIHtcbiAgICAgIC8vIEFzc2lnbmluZyB0byB1bnVzZWQgdmFyaWFibGUgdG8ga2VlcCBDbG9zdXJlIGhhcHB5LlxuICAgICAgdmFyIF8gPSB0aGlzLnNlYXJjaE1ncl87IC8vIEZvcmNlIHRoZSBmYWN0b3J5IHRvIHJ1bi5cbiAgICAgIHRoaXMuZmlsdGVyZWREQU8kLnN1Yih0aGlzLm9uUHJlZGljYXRlQ2hhbmdlKTtcbiAgICAgIHRoaXMub25QcmVkaWNhdGVDaGFuZ2UoKTtcblxuICAgICAgdGhpcy5hZGRDbGFzcyh0aGlzLm15Q2xhc3MoKSk7XG4gICAgICB0aGlzLnN0YXJ0Q29udGV4dCh7IGRhdGE6IHRoaXMgfSk7XG4gICAgICB2YXIgc2VhcmNoUGFuZWwgPSB0aGlzLnN0YXJ0KCkuYWRkQ2xhc3ModGhpcy5teUNsYXNzKCdzZWFyY2gtcGFuZWwnKSk7XG4gICAgICB2YXIgdG9wUGFuZWwgPSBzZWFyY2hQYW5lbC5zdGFydCh0aGlzLmFkZGluZ1NwZWMpXG4gICAgICAgICAgLmFkZENsYXNzKHRoaXMubXlDbGFzcygnYWRkaW5nJykpO1xuICAgICAgaWYgKCB0aGlzLmFsbG93QWRkaW5nRmlsdGVycyApIHtcbiAgICAgICAgdG9wUGFuZWwuc3RhcnQoKVxuICAgICAgICAgICAgLmFkZENsYXNzKHRoaXMubXlDbGFzcygnYWRkLWZpbHRlcicpKVxuICAgICAgICAgICAgLnN0YXJ0KHRoaXMuQ2hvaWNlVmlldywge1xuICAgICAgICAgICAgICBkYXRhJDogdGhpcy5maWx0ZXJDaG9pY2UkLFxuICAgICAgICAgICAgICBjaG9pY2VzOiB0aGlzLmZpbHRlcnNcbiAgICAgICAgICAgIH0pLmVuZCgpXG4gICAgICAgICAgICAuYWRkKHRoaXMuTkVXX0ZJTFRFUilcbiAgICAgICAgLmVuZCgpO1xuICAgICAgfVxuXG4gICAgICB0b3BQYW5lbC5zdGFydCgpXG4gICAgICAgICAgLmFkZENsYXNzKHRoaXMubXlDbGFzcygnY291bnQnKSlcbiAgICAgICAgICAuc3RhcnQoJ3NwYW4nKVxuICAgICAgICAgICAgICAuYWRkQ2xhc3ModGhpcy5teUNsYXNzKCdjb3VudC10ZXh0JykpXG4gICAgICAgICAgICAgIC5hZGQodGhpcy5jb3VudFN0cmluZyQpXG4gICAgICAgICAgLmVuZCgpXG4gICAgICAgICAgLnN0YXJ0KHRoaXMuQ0xFQVIsIHsgcmFpc2VkOiB0cnVlIH0pLmVuZCgpXG4gICAgICAuZW5kKCk7XG4gICAgICB0aGlzLmZpbHRlcnNFXyA9IHNlYXJjaFBhbmVsLnN0YXJ0KHRoaXMuZmlsdGVyQXJlYVNwZWMpXG4gICAgICAgICAgLmFkZENsYXNzKHRoaXMubXlDbGFzcygnZmlsdGVyLWFyZWEnKSk7XG4gICAgICB0aGlzLmZpbHRlcnNFXy5lbmQoKTtcbiAgICAgIHRoaXMuZW5kQ29udGV4dCgpO1xuICAgICAgc2VhcmNoUGFuZWwuZW5kKCk7XG5cbiAgICAgIHRoaXMuc3RhcnQoKS5hZGRDbGFzcyh0aGlzLm15Q2xhc3MoJ3Jlc3VsdHMnKSlcbiAgICAgICAgICAuc3RhcnQodGhpcy50YWJsZVZpZXcsIHsgb2Y6IHRoaXMuZGF0YS5vZiwgZGF0YSQ6IHRoaXMuZmlsdGVyZWREQU8kIH0pXG4gICAgICAgICAgLmVuZCgpXG4gICAgICAuZW5kKCk7XG5cbiAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgIHRoaXMub25sb2FkLnN1YihmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKCBzZWxmLnRleHRTZWFyY2ggKSB7XG4gICAgICAgICAgc2VsZi5maWx0ZXJzRV8uYWRkKHNlbGYuYnVpbGRGaWx0ZXIoe1xuICAgICAgICAgICAgbGFiZWw6ICdTZWFyY2gnLFxuICAgICAgICAgICAgc2hvd1JlbW92ZTogZmFsc2UsXG4gICAgICAgICAgICB2aWV3OiBzZWxmLnNlYXJjaFxuICAgICAgICAgIH0pKTtcbiAgICAgICAgICBzZWxmLnNlYXJjaE1ncl8uYWRkKHNlbGYuc2VhcmNoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHNlbGYubG9hZGVkXyA9IHRydWU7XG4gICAgICB9KTtcblxuICAgICAgdGhpcy5kYXRhJC5zdWIodGhpcy51cGRhdGVTZWFyY2hGaWVsZHMpO1xuICAgICAgdGhpcy5sb2FkZWRfJC5zdWIodGhpcy51cGRhdGVTZWFyY2hGaWVsZHMpO1xuICAgICAgdGhpcy5zZWFyY2hGaWVsZHMkLnN1Yih0aGlzLnVwZGF0ZVNlYXJjaEZpZWxkcyk7XG5cbiAgICAgIHRoaXMuZGF0YSRwcm94eS5vbi5yZXNldC5zdWIodGhpcy51cGRhdGVDb3VudCk7XG4gICAgICBpZiAoIHRoaXMuZGF0YSApIHRoaXMudXBkYXRlQ291bnQoKTtcbiAgICB9LFxuXG4gICAgZnVuY3Rpb24gYWRkR3JvdXAoc3BlYywgcHJvcCwgb3B0X21hcCkge1xuICAgICAgdmFyIG1hcCA9IG9wdF9tYXAgfHwge307XG4gICAgICBtYXAucHJvcGVydHkgPSBwcm9wO1xuICAgICAgbWFwLnNpemUgPSBtYXAuc2l6ZSB8fCAxO1xuICAgICAgbWFwLmRhbyA9IHRoaXMuZGF0YTtcblxuICAgICAgdmFyIGUgPSB0aGlzLlZpZXdTcGVjLmNyZWF0ZVZpZXcoc3BlYywgbWFwLCB0aGlzLCB0aGlzLnNlYXJjaE1ncl8pO1xuICAgICAgdmFyIHZpZXcgPSB0aGlzLnNlYXJjaE1ncl8uYWRkKGUpO1xuICAgICAgdmFyIGZpbHRlclZpZXcgPSB0aGlzLmJ1aWxkRmlsdGVyKHtcbiAgICAgICAga2V5OiB2aWV3Lm5hbWUsXG4gICAgICAgIGxhYmVsOiBwcm9wLmxhYmVsLFxuICAgICAgICBwcm9wOiBwcm9wLFxuICAgICAgICBzaG93UmVtb3ZlOiB0aGlzLmFsbG93QWRkaW5nRmlsdGVycyxcbiAgICAgICAgdmlldzogdmlld1xuICAgICAgfSk7XG5cbiAgICAgIHRoaXMuc2VhcmNoVmlld3NfW3ZpZXcubmFtZV0gPSBmaWx0ZXJWaWV3O1xuICAgICAgcmV0dXJuIGZpbHRlclZpZXc7XG4gICAgfSxcblxuICAgIGZ1bmN0aW9uIHJlbmRlckZpbHRlcihrZXkpIHtcbiAgICAgIHRoaXMuZmlsdGVyc0VfLmFkZCh0aGlzLnNlYXJjaFZpZXdzX1trZXldKTtcbiAgICB9LFxuXG4gICAgZnVuY3Rpb24gYWRkRmlsdGVyXyhuYW1lKSB7XG4gICAgICAvLyBMb29rIGZvciBleGlzdGluZyBmaWx0ZXJzIGZvciB0aGlzIHByb3BlcnR5LCBhbmQgY291bnQgdGhlIHRvdGFsXG4gICAgICAvLyBmaWx0ZXJzIHRvIGVuc3VyZSB3ZSBjYW4gYnVpbGQgYSB1bmlxdWUga2V5LlxuICAgICAgLy8gVGhpcyBpcyBob3cgdGhlIG11bHRpcGxlLWZpZWxkcy1mb3Itb25lLXByb3BlcnR5IHN1cHBvcnQgaXMgYWNoaWV2ZWQuXG4gICAgICB2YXIgaGlnaGVzdENvdW50ID0gMDtcbiAgICAgIHZhciBhbHJlYWR5RXhpc3RzID0gZmFsc2U7XG4gICAgICBmb3IgKCB2YXIgaSA9IDA7IGkgPCB0aGlzLnNlYXJjaEZpZWxkcy5sZW5ndGg7IGkrKyApIHtcbiAgICAgICAgdmFyIHNwbGl0ID0gdGhpcy5zcGxpdE5hbWUodGhpcy5zZWFyY2hGaWVsZHNbaV0pO1xuICAgICAgICBpZiAoIHNwbGl0LmNvdW50ID4gaGlnaGVzdENvdW50ICkgaGlnaGVzdENvdW50ID0gc3BsaXQuY291bnQ7XG4gICAgICAgIGlmICggc3BsaXQubmFtZSA9PT0gbmFtZSApIGFscmVhZHlFeGlzdHMgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAoIGFscmVhZHlFeGlzdHMgJiYgISB0aGlzLmFsbG93RHVwbGljYXRlRmlsdGVycyApIHJldHVybiB1bmRlZmluZWQ7XG5cbiAgICAgIHZhciBrZXkgPSBuYW1lICsgKGhpZ2hlc3RDb3VudCA9PT0gMCA/ICcnIDogJ18nICsgKCtoaWdoZXN0Q291bnQgKyAxKSk7XG4gICAgICB2YXIgdGVtcCA9IGZvYW0uQXJyYXkuY2xvbmUodGhpcy5zZWFyY2hGaWVsZHMpO1xuICAgICAgdGVtcC5wdXNoKGtleSk7XG4gICAgICB0aGlzLnNlYXJjaEZpZWxkcyA9IHRlbXA7XG4gICAgICByZXR1cm4ga2V5O1xuICAgIH0sXG5cbiAgICBmdW5jdGlvbiBhZGRGaWx0ZXIobmFtZSkge1xuICAgICAgdmFyIGtleSA9IHRoaXMuYWRkRmlsdGVyXyhuYW1lKTtcbiAgICB9LFxuXG4gICAgZnVuY3Rpb24gcmVtb3ZlRmlsdGVyKGtleSkge1xuICAgICAgdmFyIHRlbXAgPSBmb2FtLkFycmF5LmNsb25lKHRoaXMuc2VhcmNoRmllbGRzKTtcbiAgICAgIGZvciAoIHZhciBpID0gMDsgaSA8IHRlbXAubGVuZ3RoOyBpKysgKSB7XG4gICAgICAgIGlmICggdGVtcFtpXSA9PT0ga2V5ICkge1xuICAgICAgICAgIHRlbXAuc3BsaWNlKGksIDEpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLnNlYXJjaEZpZWxkcyA9IHRlbXA7XG4gICAgfSxcblxuICAgIGZ1bmN0aW9uIHNwbGl0TmFtZShrZXkpIHtcbiAgICAgIHZhciBtYXRjaCA9IGtleS5tYXRjaCgvXiguKilfKFxcZCspJC8pO1xuICAgICAgcmV0dXJuIG1hdGNoID9cbiAgICAgICAgICB7IG5hbWU6IG1hdGNoWzFdLCBjb3VudDogbWF0Y2hbMl0gfSA6XG4gICAgICAgICAgeyBuYW1lOiBrZXksIGNvdW50OiAxIH07XG4gICAgfVxuICBdLFxuXG4gIGxpc3RlbmVyczogW1xuICAgIHtcbiAgICAgIG5hbWU6ICdvblByZWRpY2F0ZUNoYW5nZScsXG4gICAgICBpc0ZyYW1lZDogdHJ1ZSxcbiAgICAgIGNvZGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLmZpbHRlcmVkREFPLnNlbGVjdCh0aGlzLkNvdW50LmNyZWF0ZSgpKVxuICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24oYykgeyB0aGlzLmNvdW50ID0gYy52YWx1ZTsgfS5iaW5kKHRoaXMpKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHtcbiAgICAgIG5hbWU6ICd1cGRhdGVDb3VudCcsXG4gICAgICBpc0ZyYW1lZDogdHJ1ZSxcbiAgICAgIGNvZGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLmRhdGEuc2VsZWN0KHRoaXMuQ291bnQuY3JlYXRlKCkpLnRoZW4oZnVuY3Rpb24oYykge1xuICAgICAgICAgIHRoaXMudG90YWxDb3VudCA9IGMudmFsdWU7XG4gICAgICAgIH0uYmluZCh0aGlzKSk7XG4gICAgICAgIHRoaXMub25QcmVkaWNhdGVDaGFuZ2UoKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHtcbiAgICAgIG5hbWU6ICd1cGRhdGVTZWFyY2hGaWVsZHMnLFxuICAgICAgaXNGcmFtZWQ6IHRydWUsXG4gICAgICBjb2RlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKCAhIHRoaXMubG9hZGVkXyB8fCAhIHRoaXMuZGF0YSApIHJldHVybjtcbiAgICAgICAgdmFyIGZpZWxkcyA9IHRoaXMuc2VhcmNoRmllbGRzO1xuICAgICAgICB2YXIgb2xkRmllbGRzID0gdGhpcy5vbGRTZWFyY2hGaWVsZHNfO1xuXG4gICAgICAgIC8vIENoZWNrIGZvciBldmVyeSBmaWx0ZXIgdGhhdCBoYXMgYmVlbiByZW1vdmVkLCBhbmQgZXZlcnkgZmlsdGVyIHRoYXRcbiAgICAgICAgLy8gaXMgZnJlc2hseSBhZGRlZC5cbiAgICAgICAgLy8gVGhpcyBmdW5jdGlvbiBpcyByZXNwb25zaWJsZSBmb3IgY2hvb3NpbmcgdGhlIHZpZXcgZm9yIGVhY2ggcHJvcGVydHkuXG4gICAgICAgIC8vIEVnLiBkcm9wLWRvd25zIGZvciBCb29sZWFucyBhbmQgRW51bXMsIGJlZm9yZS9hZnRlciBmb3IgZGF0ZXMsIGV0Yy5cbiAgICAgICAgaWYgKCBvbGRGaWVsZHMgKSB7XG4gICAgICAgICAgZm9yICggdmFyIGkgPSAwOyBpIDwgb2xkRmllbGRzLmxlbmd0aDsgaSsrICkge1xuICAgICAgICAgICAgaWYgKCAhIGZpZWxkcyB8fCBmaWVsZHMuaW5kZXhPZihvbGRGaWVsZHNbaV0pIDwgMCApIHtcbiAgICAgICAgICAgICAgdGhpcy5zZWFyY2hNZ3JfLnJlbW92ZShvbGRGaWVsZHNbaV0pO1xuICAgICAgICAgICAgICB0aGlzLnNlYXJjaFZpZXdzX1tvbGRGaWVsZHNbaV1dLnJlbW92ZSgpO1xuICAgICAgICAgICAgICBkZWxldGUgdGhpcy5zZWFyY2hWaWV3c19bb2xkRmllbGRzW2ldXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIGZpZWxkcyApIHtcbiAgICAgICAgICBmb3IgKCB2YXIgaSA9IDA7IGkgPCBmaWVsZHMubGVuZ3RoOyBpKysgKSB7XG4gICAgICAgICAgICBpZiAoICEgb2xkRmllbGRzIHx8IG9sZEZpZWxkcy5pbmRleE9mKGZpZWxkc1tpXSkgPCAwICkge1xuICAgICAgICAgICAgICB2YXIgc3BsaXQgPSB0aGlzLnNwbGl0TmFtZShmaWVsZHNbaV0pO1xuICAgICAgICAgICAgICB2YXIgcHJvcCA9IHRoaXMuZGF0YS5vZi5nZXRBeGlvbUJ5TmFtZShzcGxpdC5uYW1lKTtcbiAgICAgICAgICAgICAgdmFyIHNwZWMgPSBwcm9wLnNlYXJjaFZpZXc7XG4gICAgICAgICAgICAgIC8vIFRPRE8oYnJhZGVuKTogQnJpbmcgaW4gZGF0ZSBzdXBwb3J0IHdoZW4gaXQncyByZWFkeS5cbiAgICAgICAgICAgICAgdmFyIG9wdGlvbnMgPSB7XG4gICAgICAgICAgICAgICAgbmFtZTogZmllbGRzW2ldXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIGlmICggcHJvcC50YWJsZVNlcGFyYXRvciApIHtcbiAgICAgICAgICAgICAgICBvcHRpb25zLnNwbGl0ID0gcHJvcC50YWJsZVNlcGFyYXRvcjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB0aGlzLmFkZEdyb3VwKHNwZWMsIHByb3AsIG9wdGlvbnMpO1xuICAgICAgICAgICAgICB0aGlzLnJlbmRlckZpbHRlcihmaWVsZHNbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMub2xkU2VhcmNoRmllbGRzXyA9IGZpZWxkcztcbiAgICAgIH1cbiAgICB9XG4gIF0sXG5cbiAgYWN0aW9uczogW1xuICAgIHtcbiAgICAgIG5hbWU6ICdjbGVhcicsXG4gICAgICBjb2RlOiBmdW5jdGlvbigpIHsgdGhpcy5zZWFyY2hNZ3JfLmNsZWFyKCk7IH1cbiAgICB9LFxuICAgIHtcbiAgICAgIG5hbWU6ICduZXdGaWx0ZXInLFxuICAgICAgY29kZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuYWRkRmlsdGVyXyh0aGlzLmZpbHRlckNob2ljZSk7XG4gICAgICB9XG4gICAgfVxuICBdXG59KTtcblxuXG5mb2FtLkNMQVNTKHtcbiAgcGFja2FnZTogJ2ZvYW0udTIuc2VhcmNoJyxcbiAgbmFtZTogJ1Byb3BlcnR5UmVmaW5lbWVudCcsXG4gIHJlZmluZXM6ICdmb2FtLmNvcmUuUHJvcGVydHknLFxuXG4gIHByb3BlcnRpZXM6IFtcbiAgICB7XG4gICAgICAvLyBTZXQgdGhpcyBmaWVsZCB0byBvdmVycmlkZSB0aGUgZGVmYXVsdCBsb2dpYyBmb3IgY2hvb3NpbmcgYSB2aWV3LlxuICAgICAgY2xhc3M6ICdmb2FtLnUyLlZpZXdTcGVjJyxcbiAgICAgIG5hbWU6ICdzZWFyY2hWaWV3JyxcbiAgICAgIHZhbHVlOiB7IGNsYXNzOiAnZm9hbS51Mi5zZWFyY2guR3JvdXBBdXRvY29tcGxldGVTZWFyY2hWaWV3JyB9XG4gICAgfVxuICBdXG59KTtcblxuXG5mb2FtLkNMQVNTKHtcbiAgcGFja2FnZTogJ2ZvYW0udTIuc2VhcmNoJyxcbiAgbmFtZTogJ0Jvb2xlYW5SZWZpbmVtZW50JyxcbiAgcmVmaW5lczogJ2ZvYW0uY29yZS5Cb29sZWFuJyxcblxuICBwcm9wZXJ0aWVzOiBbXG4gICAge1xuICAgICAgY2xhc3M6ICdmb2FtLnUyLlZpZXdTcGVjJyxcbiAgICAgIG5hbWU6ICdzZWFyY2hWaWV3JyxcbiAgICAgIHZhbHVlOiB7XG4gICAgICAgIGNsYXNzOiAnZm9hbS51Mi5zZWFyY2guR3JvdXBCeVNlYXJjaFZpZXcnLFxuICAgICAgICB2aWV3U3BlYzogeyBjbGFzczogJ2ZvYW0udTIudmlldy5DaG9pY2VWaWV3Jywgc2l6ZTogMyB9XG4gICAgICB9XG4gICAgfVxuICBdXG59KTtcblxuXG5mb2FtLkNMQVNTKHtcbiAgcGFja2FnZTogJ2ZvYW0udTIuc2VhcmNoJyxcbiAgbmFtZTogJ0VudW1SZWZpbmVtZW50JyxcbiAgcmVmaW5lczogJ2ZvYW0uY29yZS5FbnVtJyxcblxuICBwcm9wZXJ0aWVzOiBbXG4gICAge1xuICAgICAgY2xhc3M6ICdmb2FtLnUyLlZpZXdTcGVjJyxcbiAgICAgIG5hbWU6ICdzZWFyY2hWaWV3JyxcbiAgICAgIHZhbHVlOiB7IGNsYXNzOiAnZm9hbS51Mi5zZWFyY2guR3JvdXBCeVNlYXJjaFZpZXcnIH1cbiAgICB9XG4gIF1cbn0pO1xuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTYgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuZm9hbS5DTEFTUyh7XG4gIHBhY2thZ2U6ICdmb2FtLnUyLnNlYXJjaCcsXG4gIG5hbWU6ICdHcm91cENvbXBsZXRlcicsXG4gIGV4dGVuZHM6ICdmb2FtLnUyLkF1dG9jb21wbGV0ZXInLFxuXG4gIHJlcXVpcmVzOiBbXG4gICAgJ2ZvYW0uZGFvLk1EQU8nLFxuICAgICdmb2FtLmRhby5Qcm94eURBTycsXG4gICAgJ2ZvYW0ubWxhbmcuTGFiZWxlZFZhbHVlJyxcbiAgICAnZm9hbS5tbGFuZy5wcmVkaWNhdGUuQ29udGFpbnNJQydcbiAgXSxcblxuICBkb2N1bWVudGF0aW9uOiAnRXhwZWN0cyBcImdyb3Vwc1wiIHRvIGJlIGFuIGFycmF5IG9mIHN0cmluZ3MsIGFuZCAnICtcbiAgICAgICdhdXRvY29tcGxldGVzIG9uIHRoZW0uJyxcblxuICBwcm9wZXJ0aWVzOiBbXG4gICAgJ2dyb3VwcycsXG4gICAge1xuICAgICAgbmFtZTogJ2RhbycsXG4gICAgICBmYWN0b3J5OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuUHJveHlEQU8uY3JlYXRlKHtcbiAgICAgICAgICBvZjogdGhpcy5MYWJlbGVkVmFsdWUsXG4gICAgICAgICAgZGVsZWdhdGUkOiB0aGlzLmlubmVyREFPXyRcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSxcbiAgICB7XG4gICAgICBuYW1lOiAnaW5uZXJEQU9fJyxcbiAgICAgIGV4cHJlc3Npb246IGZ1bmN0aW9uKGdyb3Vwcykge1xuICAgICAgICB2YXIgZGFvID0gdGhpcy5NREFPLmNyZWF0ZSh7IG9mOiB0aGlzLkxhYmVsZWRWYWx1ZSB9KTtcbiAgICAgICAgaWYgKCAhIGdyb3VwcyB8fCAhIGdyb3Vwcy5sZW5ndGggKSByZXR1cm4gZGFvO1xuXG4gICAgICAgIGZvciAoIHZhciBpID0gMDsgaSA8IGdyb3Vwcy5sZW5ndGg7IGkrKyApIHtcbiAgICAgICAgICB2YXIgc3RyID0gJycgKyBncm91cHNbaV07XG4gICAgICAgICAgaWYgKCAhIHN0ciApIGNvbnRpbnVlO1xuICAgICAgICAgIGRhby5wdXQodGhpcy5MYWJlbGVkVmFsdWUuY3JlYXRlKHtcbiAgICAgICAgICAgIGlkOiBzdHIsXG4gICAgICAgICAgICBsYWJlbDogc3RyLFxuICAgICAgICAgICAgdmFsdWU6IGdyb3Vwc1tpXVxuICAgICAgICAgIH0pKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGFvO1xuICAgICAgfVxuICAgIH0sXG4gICAge1xuICAgICAgbmFtZTogJ3F1ZXJ5RmFjdG9yeScsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24oc3RyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLkNvbnRhaW5zSUMuY3JlYXRlKHtcbiAgICAgICAgICBhcmcxOiB0aGlzLkxhYmVsZWRWYWx1ZS5MQUJFTCxcbiAgICAgICAgICBhcmcyOiBzdHJcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSxcbiAgICB7XG4gICAgICBuYW1lOiAnb2JqVG9TdHJpbmcnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uKGx2KSB7XG4gICAgICAgIHJldHVybiBsdi52YWx1ZTtcbiAgICAgIH1cbiAgICB9XG4gIF1cbn0pO1xuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTYgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuZm9hbS5DTEFTUyh7XG4gIHBhY2thZ2U6ICdmb2FtLnUyLnNlYXJjaCcsXG4gIG5hbWU6ICdHcm91cEF1dG9jb21wbGV0ZVNlYXJjaFZpZXcnLFxuICBleHRlbmRzOiAnZm9hbS51Mi5WaWV3JyxcblxuICBkb2N1bWVudGF0aW9uOiAnVXNlcyBhIFRleHRGaWVsZCB3aXRoIGF1dG9jb21wbGV0ZSBkcml2ZW4gYnkgYSBsaXN0LiBUaGlzICcgK1xuICAgICAgJ2RlcGVuZHMgb24gdGhlIGJyb3dzZXJcXCdzIG5hdGl2ZSBzdXBwb3J0IGZvciB0aGUgaW5wdXQubGlzdCAnICtcbiAgICAgICdhdHRyaWJ1dGUsIHdoaWNoIGlzIGFsc28gcG9seWZpbGxlZCBieSBQb2x5bWVyLicsXG5cbiAgcmVxdWlyZXM6IFtcbiAgICAnZm9hbS5tbGFuZy5wcmVkaWNhdGUuVHJ1ZScsXG4gICAgJ2ZvYW0udTIuc2VhcmNoLkdyb3VwQ29tcGxldGVyJyxcbiAgICAvLyBUT0RPKGJyYWRlbik6IEltcGxlbWVudCBhbmQgdW5jb21tZW50IHRoZSBzcGxpdC1jb21wbGV0ZXIuXG4gICAgLy8nZm9hbS51Mi5zZWFyY2guR3JvdXBTcGxpdENvbXBsZXRlcicsXG4gICAgJ2ZvYW0udTIudmlldy5UZXh0RmllbGQnXG4gIF0sXG5cbiAgcHJvcGVydGllczogW1xuICAgIHtcbiAgICAgIGNsYXNzOiAnU3RyaW5nJyxcbiAgICAgIG5hbWU6ICdzcGxpdCcsXG4gICAgICBkb2N1bWVudGF0aW9uOiAnU2V0IHRoaXMgdG8gYSBzdHJpbmcsIGFuZCBncm91cCB2YWx1ZXMgd2lsbCBiZSBzcGxpdCAnICtcbiAgICAgICAgICAnb24gaXQuIFRoaXMgY2FuIGJlIHVzZWQgdG8gc3BsaXQgYSBjb21tYS1zZXBhcmF0ZWQgc3RyaW5nIGludG8gJyArXG4gICAgICAgICAgJ2l0cyBjb21wb25lbnQgcGFydHMuJyxcbiAgICAgIHZhbHVlOiAnJ1xuICAgIH0sXG4gICAge1xuICAgICAgY2xhc3M6ICdmb2FtLnUyLlZpZXdTcGVjJyxcbiAgICAgIG5hbWU6ICd2aWV3U3BlYycsXG4gICAgICB2YWx1ZTogeyBjbGFzczogJ2ZvYW0udTIudmlldy5UZXh0RmllbGQnLCBvbktleTogdHJ1ZSB9XG4gICAgfSxcbiAgICB7XG4gICAgICBuYW1lOiAnZGFvJyxcbiAgICAgIGxhYmVsOiAnREFPJyxcbiAgICAgIHJlcXVpcmVkOiB0cnVlLFxuICAgICAgcG9zdFNldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMudXBkYXRlREFPKCk7XG4gICAgICB9XG4gICAgfSxcbiAgICB7XG4gICAgICBuYW1lOiAncHJvcGVydHknLFxuICAgICAgcmVxdWlyZWQ6IHRydWUsXG4gICAgICBwb3N0U2V0OiBmdW5jdGlvbihvLCBwcm9wZXJ0eSkge1xuICAgICAgICBpZiAoICEgdGhpcy5vcCApIHRoaXMub3AgPSBmb2FtLmNvcmUuSW50LmlzSW5zdGFuY2UocHJvcGVydHkpID8gZm9hbS5tbGFuZy5wcmVkaWNhdGUuRXEgOiBmb2FtLm1sYW5nLnByZWRpY2F0ZS5Db250YWluc0lDO1xuICAgICAgfVxuICAgIH0sXG4gICAge1xuICAgICAgbmFtZTogJ25hbWUnLFxuICAgICAgZG9jdW1lbnRhdGlvbjogJ0FsbCBTZWFyY2hWaWV3cyByZXF1aXJlIGEgbmFtZS4gRGVmYXVsdHMgdG8gdGhlICcgK1xuICAgICAgICAgICdwcm9wZXJ0eSBuYW1lLicsXG4gICAgICBleHByZXNzaW9uOiBmdW5jdGlvbihwcm9wZXJ0eSkge1xuICAgICAgICByZXR1cm4gcHJvcGVydHkubmFtZTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHtcbiAgICAgIGNsYXNzOiAnQ2xhc3MnLFxuICAgICAgbmFtZTogJ29wJy8qLFxuICAgICAgZXhwcmVzc2lvbjogZnVuY3Rpb24ocHJvcGVydHkpIHtcbiAgICAgICAgLy8gVE9ETzogYnJva2VuIGJ5IENMQVNTLCBmaXhcbiAgICAgICAgLy8gQWxsIHRoZSBudW1lcmljIHR5cGVzIGV4dGVuZCBmcm9tIEludCwgc28gSSdsbCB1c2UgdGhhdCBhcyBteSBiYXNlLlxuICAgICAgICByZXR1cm4gZm9hbS5jb3JlLkludC5pc0luc3RhbmNlKHByb3BlcnR5KSA/IGZvYW0ubWxhbmcucHJlZGljYXRlLkVxIDpcbiAgICAgICAgICAgIGZvYW0ubWxhbmcucHJlZGljYXRlLkNvbnRhaW5zSUM7XG4gICAgICB9Ki9cbiAgICB9LFxuICAgIHtcbiAgICAgIG5hbWU6ICdwcmVkaWNhdGUnLFxuICAgICAgZG9jdW1lbnRhdGlvbjogJ015IGZpbHRlciBmb3IgdGhlIFNlYXJjaE1hbmFnZXIgdG8gcmVhZC4nLFxuICAgICAgZmFjdG9yeTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLlRydWUuY3JlYXRlKCk7XG4gICAgICB9XG4gICAgfSxcbiAgICB7XG4gICAgICBuYW1lOiAnbGFiZWwnLFxuICAgICAgZXhwcmVzc2lvbjogZnVuY3Rpb24ocHJvcGVydHkpIHtcbiAgICAgICAgcmV0dXJuIHByb3BlcnR5LmxhYmVsO1xuICAgICAgfVxuICAgIH0sXG4gICAge1xuICAgICAgbmFtZTogJ2dyb3VwcycsXG4gICAgICBkb2N1bWVudGF0aW9uOiAnTGlzdCBvZiBncm91cHMgZm91bmQgdGhlIGxhc3QgdGltZSB0aGUgREFPIHdhcyB1cGRhdGVkLidcbiAgICB9LFxuICAgIHtcbiAgICAgIG5hbWU6ICdhdXRvY29tcGxldGVyJyxcbiAgICAgIGZhY3Rvcnk6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgbW9kZWwgPSB0aGlzLkdyb3VwQ29tcGxldGVyO1xuICAgICAgICB2YXIgYXJncyA9IHsgZ3JvdXBzJDogdGhpcy5ncm91cHMkIH07XG4gICAgICAgIGlmICggdGhpcy5zcGxpdCApIHtcbiAgICAgICAgICBtb2RlbCA9IHRoaXMuR3JvdXBTcGxpdENvbXBsZXRlcjtcbiAgICAgICAgICBhcmdzLnNwbGl0ID0gdGhpcy5zcGxpdDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBtb2RlbC5jcmVhdGUoYXJncywgdGhpcyk7XG4gICAgICB9XG4gICAgfSxcbiAgICB7XG4gICAgICBuYW1lOiAndmlldydcbiAgICB9XG4gIF0sXG5cbiAgbWV0aG9kczogW1xuICAgIGZ1bmN0aW9uIGNsZWFyKCkge1xuICAgICAgdGhpcy52aWV3LmRhdGEgPSAnJztcbiAgICB9LFxuXG4gICAgZnVuY3Rpb24gaW5pdEUoKSB7XG4gICAgICB0aGlzLnZpZXcgPSB0aGlzLnN0YXJ0KHRoaXMudmlld1NwZWMsIHtcbiAgICAgICAgcHJvcDogdGhpcy5wcm9wZXJ0eSxcbiAgICAgICAgbGFiZWwkOiB0aGlzLmxhYmVsJCxcbiAgICAgICAgYWx3YXlzRmxvYXRMYWJlbDogdHJ1ZSxcbiAgICAgICAgYXV0b2NvbXBsZXRlcjogdGhpcy5hdXRvY29tcGxldGVyXG4gICAgICB9KTtcblxuICAgICAgdGhpcy5kYW8ub24uc3ViKHRoaXMudXBkYXRlREFPKTtcbiAgICAgIHRoaXMudmlldy5kYXRhJC5zdWIodGhpcy51cGRhdGVQcmVkaWNhdGUpO1xuICAgIH1cbiAgXSxcblxuICBsaXN0ZW5lcnM6IFtcbiAgICB7XG4gICAgICBuYW1lOiAndXBkYXRlREFPJyxcbiAgICAgIGlzTWVyZ2VkOiB0cnVlLFxuICAgICAgbWVyZ2VEZWxheTogMTAwLFxuICAgICAgY29kZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIC8vIE1ha2VzIGEgc2VsZWN0IHF1ZXJ5LCBncm91cGluZyBieSB0aGUgdmFsdWUgb2YgdGhpcy5wcm9wZXJ0eS5cbiAgICAgICAgLy8gVGhhdCBidWlsZHMgdGhlIHRoaXMuZ3JvdXBzIGxpc3QsIHdoaWNoIGlzIHdoYXQgd2UncmUgYXV0b2NvbXBsZXRpbmdcbiAgICAgICAgLy8gYWdhaW5zdC5cbiAgICAgICAgdGhpcy5kYW8uc2VsZWN0KGZvYW0ubWxhbmcuc2luay5Hcm91cEJ5LmNyZWF0ZSh7XG4gICAgICAgICAgYXJnMTogdGhpcy5wcm9wZXJ0eSxcbiAgICAgICAgICBhcmcyOiBmb2FtLm1sYW5nLnNpbmsuQ291bnQuY3JlYXRlKClcbiAgICAgICAgfSkpLnRoZW4oZnVuY3Rpb24oZ3JvdXBzKSB7XG4gICAgICAgICAgdGhpcy5ncm91cHMgPSBncm91cHMuc29ydGVkS2V5cygpO1xuICAgICAgICB9LmJpbmQodGhpcykpO1xuICAgICAgfVxuICAgIH0sXG4gICAge1xuICAgICAgbmFtZTogJ3VwZGF0ZVByZWRpY2F0ZScsXG4gICAgICBjb2RlOiBmdW5jdGlvbihzdWIsIF8sIF9fLCBzbG90KSB7XG4gICAgICAgIHZhciBzdHIgPSBzbG90LmdldCgpO1xuICAgICAgICB0aGlzLnByZWRpY2F0ZSA9IHN0ciA/IHRoaXMub3AuY3JlYXRlKHtcbiAgICAgICAgICBhcmcxOiB0aGlzLnByb3BlcnR5LFxuICAgICAgICAgIGFyZzI6IHRoaXMucHJvcGVydHkuZnJvbVN0cmluZyA/IHRoaXMucHJvcGVydHkuZnJvbVN0cmluZyhzdHIpIDogc3RyXG4gICAgICAgIH0pIDogdGhpcy5UcnVlLmNyZWF0ZSgpO1xuICAgICAgfVxuICAgIH1cbiAgXVxufSk7XG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5mb2FtLkNMQVNTKHtcbiAgcGFja2FnZTogJ2ZvYW0udTIuc2VhcmNoJyxcbiAgbmFtZTogJ0dyb3VwQnlTZWFyY2hWaWV3JyxcbiAgZXh0ZW5kczogJ2ZvYW0udTIuVmlldycsXG5cbiAgcmVxdWlyZXM6IFtcbiAgICAnZm9hbS5tbGFuZy5Db25zdGFudCcsXG4gICAgJ2ZvYW0ubWxhbmcucHJlZGljYXRlLlRydWUnLFxuICAgICdmb2FtLm1sYW5nLnNpbmsuQ291bnQnLFxuICAgICdmb2FtLm1sYW5nLnNpbmsuR3JvdXBCeScsXG4gICAgJ2ZvYW0uZGFvLkZuU2luaycsXG4gICAgJ2ZvYW0udTIudmlldy5DaG9pY2VWaWV3J1xuICBdLFxuXG4gIGNzczogXCJeIHNlbGVjdCB7IG1pbi13aWR0aDogMjIwcHg7IH1cIixcblxuICBwcm9wZXJ0aWVzOiBbXG4gICAge1xuICAgICAgbmFtZTogJ3ZpZXcnXG4gICAgfSxcbiAgICB7XG4gICAgICBjbGFzczogJ2ZvYW0udTIuVmlld1NwZWMnLFxuICAgICAgbmFtZTogJ3ZpZXdTcGVjJyxcbiAgICAgIHZhbHVlOiB7IGNsYXNzOiAnZm9hbS51Mi52aWV3LkNob2ljZVZpZXcnLCBzaXplOiAxMCB9XG4gICAgfSxcbiAgICB7XG4gICAgICBjbGFzczogJ2ZvYW0uZGFvLkRBT1Byb3BlcnR5JyxcbiAgICAgIG5hbWU6ICdkYW8nLFxuICAgICAgcmVxdWlyZWQ6IHRydWUsXG4gICAgfSxcbiAgICB7XG4gICAgICBuYW1lOiAncHJvcGVydHknLFxuICAgICAgcmVxdWlyZWQ6IHRydWVcbiAgICB9LFxuICAgIHtcbiAgICAgIG5hbWU6ICduYW1lJyxcbiAgICAgIGV4cHJlc3Npb246IGZ1bmN0aW9uKHByb3BlcnR5KSB7IHJldHVybiBwcm9wZXJ0eS5uYW1lOyB9XG4gICAgfSxcbiAgICB7XG4gICAgICBjbGFzczogJ0NsYXNzJyxcbiAgICAgIG5hbWU6ICdvcCcsXG4gICAgICB2YWx1ZTogJ2ZvYW0ubWxhbmcucHJlZGljYXRlLkVxJ1xuICAgIH0sXG4gICAge1xuICAgICAgbmFtZTogJ3ByZWRpY2F0ZScsXG4gICAgICBmYWN0b3J5OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuVHJ1ZS5jcmVhdGUoKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHtcbiAgICAgIGNsYXNzOiAnSW50JyxcbiAgICAgIG5hbWU6ICd3aWR0aCcsXG4gICAgICB2YWx1ZTogMTdcbiAgICB9LFxuICAgIHtcbiAgICAgIGNsYXNzOiAnU3RyaW5nJyxcbiAgICAgIG5hbWU6ICdsYWJlbCcsXG4gICAgICBleHByZXNzaW9uOiBmdW5jdGlvbihwcm9wZXJ0eSkge1xuICAgICAgICByZXR1cm4gcHJvcGVydHkubGFiZWw7XG4gICAgICB9XG4gICAgfSxcbiAgICB7XG4gICAgICBjbGFzczogJ0Z1bmN0aW9uJyxcbiAgICAgIG5hbWU6ICdhRm9ybWF0TGFiZWwnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uKGtleSkgeyByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCcnK2tleSk7IH1cbiAgICB9LFxuICAgICdwcmV2aWV3TW9kZScsXG4gICAgJ2hhcmREYXRhJ1xuICBdLFxuXG4gIG1ldGhvZHM6IFtcbiAgICBmdW5jdGlvbiBjbGVhcigpIHtcbiAgICAgIHRoaXMudmlldy5kYXRhID0gJyc7XG4gICAgfSxcblxuICAgIGZ1bmN0aW9uIGluaXRFKCkge1xuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgICB0aGlzXG4gICAgICAgIC5hZGRDbGFzcyh0aGlzLm15Q2xhc3MoKSlcbiAgICAgICAgLnRhZyh0aGlzLnZpZXdTcGVjLCB7XG4gICAgICAgICAgbGFiZWwkOiB0aGlzLmxhYmVsJCxcbiAgICAgICAgICBhbHdheXNGbG9hdExhYmVsOiB0cnVlXG4gICAgICAgIH0sIHRoaXMudmlldyQpXG4gICAgICAgIC5vbignY2xpY2snLCBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHNlbGYucHJldmlld01vZGUgPSBmYWxzZTtcbiAgICAgICAgICAgIHZhciBkYXRhICAgICAgICAgPSBzZWxmLnZpZXcuY2hvaWNlc1tlLnRhcmdldC52YWx1ZV1bMF07XG4gICAgICAgICAgICBzZWxmLmhhcmREYXRhICAgID0gZGF0YTtcbiAgICAgICAgICB9IGNhdGNoKHgpIHt9XG4gICAgICAgIH0pXG4gICAgICAgIC5vbignbW91c2VvdmVyJywgZnVuY3Rpb24oZSkge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICB2YXIgZGF0YSA9IHNlbGYudmlldy5jaG9pY2VzW2UudGFyZ2V0LnZhbHVlXVswXTtcblxuICAgICAgICAgICAgaWYgKCAhIHNlbGYucHJldmlld01vZGUgKSB7XG4gICAgICAgICAgICAgIHNlbGYucHJldmlld01vZGUgPSB0cnVlO1xuICAgICAgICAgICAgICBzZWxmLmhhcmREYXRhID0gc2VsZi52aWV3LmRhdGE7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHNlbGYudmlldy5kYXRhID0gZGF0YTtcbiAgICAgICAgICB9IGNhdGNoKHgpIHt9XG4gICAgICAgIH0pXG4gICAgICAgIC5vbignbW91c2VvdXQnLCBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgc2VsZi52aWV3LmRhdGEgPSBzZWxmLmhhcmREYXRhO1xuICAgICAgICAgIGlmICggISBzZWxmLmhhcmREYXRhICkgc2VsZi52aWV3LmRhdGEgPSAnJztcbiAgICAgICAgfSlcbiAgICAgICAgLm9uRGV0YWNoKFxuICAgICAgICAgIHRoaXMuZGFvJHByb3h5Lmxpc3RlbihcbiAgICAgICAgICAgIHRoaXMuRm5TaW5rLmNyZWF0ZSh7Zm46IHRoaXMudXBkYXRlREFPfSlcbiAgICAgICAgICApXG4gICAgICAgICk7XG5cbiAgICAgIHRoaXMudXBkYXRlREFPKCk7XG5cbiAgICAgIHRoaXMudmlldy5kYXRhJC5zdWIodGhpcy51cGRhdGVQcmVkaWNhdGUpO1xuICAgIH0sXG5cbiAgICBmdW5jdGlvbiB1cGRhdGVQcmVkaWNhdGVfKGNob2ljZSkge1xuICAgICAgdmFyIGV4aXN0cyA9IHR5cGVvZiBjaG9pY2UgIT09ICd1bmRlZmluZWQnICYmIGNob2ljZSAhPT0gJyc7XG4gICAgICB0aGlzLnByZWRpY2F0ZSA9IGV4aXN0cyA/IHRoaXMub3AuY3JlYXRlKHtcbiAgICAgICAgYXJnMTogdGhpcy5wcm9wZXJ0eSxcbiAgICAgICAgYXJnMjogdGhpcy5Db25zdGFudC5jcmVhdGUoeyB2YWx1ZTogY2hvaWNlIH0pXG4gICAgICB9KSA6IHRoaXMuVHJ1ZS5jcmVhdGUoKTtcbiAgICB9LFxuXG4gICAgZnVuY3Rpb24gZm9ybWF0TGFiZWxzKGtleXMpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLmFsbChrZXlzLm1hcCh0aGlzLmFGb3JtYXRMYWJlbC5iaW5kKHRoaXMpKSk7XG4gICAgfVxuICBdLFxuXG4gIGxpc3RlbmVyczogW1xuICAgIHtcbiAgICAgIG5hbWU6ICd1cGRhdGVEQU8nLFxuICAgICAgaXNNZXJnZWQ6IHRydWUsXG4gICAgICBtZXJnZURlbGF5OiAxMDAsXG4gICAgICBjb2RlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICB0aGlzLmRhby5zZWxlY3QodGhpcy5Hcm91cEJ5LmNyZWF0ZSh7XG4gICAgICAgICAgYXJnMTogdGhpcy5wcm9wZXJ0eSxcbiAgICAgICAgICBhcmcyOiB0aGlzLkNvdW50LmNyZWF0ZSgpXG4gICAgICAgIH0pKS50aGVuKGZ1bmN0aW9uKGdyb3Vwcykge1xuICAgICAgICAgIHZhciBvcHRpb25zID0gW107XG4gICAgICAgICAgdmFyIHNlbGVjdGVkO1xuICAgICAgICAgIHZhciBzb3J0ZWRLZXlzID0gZ3JvdXBzLnNvcnRlZEtleXMoKTtcbiAgICAgICAgICBzZWxmLmZvcm1hdExhYmVscyhzb3J0ZWRLZXlzKS50aGVuKGZ1bmN0aW9uIChsYWJlbHMpIHtcbiAgICAgICAgICAgIGZvciAoIHZhciBpID0gMCA7IGkgPCBzb3J0ZWRLZXlzLmxlbmd0aCA7IGkrKyApIHtcbiAgICAgICAgICAgICAgdmFyIGtleSA9IHNvcnRlZEtleXNbaV07XG4gICAgICAgICAgICAgIGlmICggdHlwZW9mIGtleSA9PT0gJ3VuZGVmaW5lZCcgKSBjb250aW51ZTtcbiAgICAgICAgICAgICAgaWYgKCBrZXkgPT09ICcnICkgY29udGludWU7XG4gICAgICAgICAgICAgIHZhciBjb3VudCA9IGZvYW0uU3RyaW5nLmludGVybihcbiAgICAgICAgICAgICAgICAgICcoJyArIGdyb3Vwcy5ncm91cHNba2V5XS52YWx1ZSArICcpJyk7XG4gICAgICAgICAgICAgIHZhciBzdWJLZXkgPSBsYWJlbHNbaV0uc3Vic3RyaW5nKDAsIHNlbGYud2lkdGggLSBjb3VudC5sZW5ndGggLSAzKTtcbiAgICAgICAgICAgICAgLy8gPz8/OiBXaHkgZG8gd2UgbmVlZCB0byBjbGVhbiB0aGUga2V5P1xuICAgICAgICAgICAgICB2YXIgY2xlYW5LZXkgPSBmb2FtLmNvcmUuRW51bS5pc0luc3RhbmNlKHNlbGYucHJvcGVydHkpID9cbiAgICAgICAgICAgICAgICAgIHNlbGYucHJvcGVydHkub2Zba2V5XS5sYWJlbCA6XG4gICAgICAgICAgICAgICAgICBzdWJLZXkucmVwbGFjZSgvPC9nLCAnJmx0OycpLnJlcGxhY2UoLz4vZywgJyZndDsnKVxuICAgICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9cIi9nLCAnJnF1b3Q7Jyk7XG5cbiAgICAgICAgICAgICAgaWYgKCBzZWxmLnZpZXcgJiYgc2VsZi52aWV3LmRhdGEgPT09IGtleSApIHtcbiAgICAgICAgICAgICAgICBzZWxlY3RlZCA9IGtleTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIG9wdGlvbnMucHVzaChbXG4gICAgICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgICAgIGNsZWFuS2V5ICsgZm9hbS5TdHJpbmcuaW50ZXJuKFxuICAgICAgICAgICAgICAgICAgICBBcnJheShzZWxmLndpZHRoIC0gc3ViS2V5Lmxlbmd0aCAtIGNvdW50Lmxlbmd0aCkuam9pbignICcpKSArXG4gICAgICAgICAgICAgICAgICAgIGNvdW50XG4gICAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBvcHRpb25zLnNwbGljZSgwLCAwLCBbICcnLCAnLS0nIF0pO1xuXG4gICAgICAgICAgICBzZWxmLnZpZXcuY2hvaWNlcyA9IG9wdGlvbnM7XG4gICAgICAgICAgICBpZiAoIHR5cGVvZiBzZWxlY3RlZCAhPT0gJ3VuZGVmaW5lZCcgKSB7XG4gICAgICAgICAgICAgIHZhciBvbGREYXRhID0gc2VsZi52aWV3LmRhdGE7XG4gICAgICAgICAgICAgIHNlbGYudmlldy5kYXRhID0gc2VsZWN0ZWQ7XG4gICAgICAgICAgICAgIGlmICggdHlwZW9mIG9sZERhdGEgPT09ICd1bmRlZmluZWQnIHx8IG9sZERhdGEgPT09ICcnICkge1xuICAgICAgICAgICAgICAgIHNlbGYudXBkYXRlUHJlZGljYXRlXyhzZWxlY3RlZCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSxcbiAgICB7XG4gICAgICBuYW1lOiAndXBkYXRlUHJlZGljYXRlJyxcbiAgICAgIGNvZGU6IGZ1bmN0aW9uKF8sIF9fLCBfX18sIHNsb3QpIHtcbiAgICAgICAgdGhpcy51cGRhdGVQcmVkaWNhdGVfKHNsb3QuZ2V0KCkpO1xuICAgICAgfVxuICAgIH1cbiAgXVxufSk7XG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5mb2FtLkNMQVNTKHtcbiAgcGFja2FnZTogJ2ZvYW0udTIuc2VhcmNoJyxcbiAgbmFtZTogJ1NlYXJjaE1hbmFnZXInLFxuXG4gIHJlcXVpcmVzOiBbXG4gICAgJ2ZvYW0ubWxhbmcucHJlZGljYXRlLkFuZCcsXG4gICAgJ2ZvYW0ubWxhbmcucHJlZGljYXRlLlRydWUnXG4gIF0sXG5cbiAgcHJvcGVydGllczogW1xuICAgIHtcbiAgICAgIG5hbWU6ICd2aWV3cycsXG4gICAgICBmYWN0b3J5OiBmdW5jdGlvbigpIHsgcmV0dXJuIHt9OyB9XG4gICAgfSxcbiAgICB7XG4gICAgICBuYW1lOiAnc3Vic18nLFxuICAgICAgZmFjdG9yeTogZnVuY3Rpb24oKSB7IHJldHVybiB7fTsgfVxuICAgIH0sXG4gICAgLy8gVE9ETyhicmFkZW4pOiBTZWUgaWYgdGhlcmUncyBhIGNsZXZlciB3YXkgdG8gd3JpdGUgdGhlIG1lbWVudG8gbG9naWMgYXNcbiAgICAvLyBhbiBleHByZXNzaW9uLCBpbnN0ZWFkIG9mIGEgc2V0IG9mIGNsZXZlciBwb3N0U2V0cy5cbiAgICB7XG4gICAgICBuYW1lOiAncHJlZGljYXRlJyxcbiAgICAgIGZhY3Rvcnk6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gZm9hbS5tbGFuZy5wcmVkaWNhdGUuVHJ1ZS5jcmVhdGUoKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHtcbiAgICAgIG5hbWU6ICdkYW8nXG4gICAgfSxcbiAgICB7XG4gICAgICBuYW1lOiAnZmlsdGVyZWREQU8nLFxuICAgICAgZXhwcmVzc2lvbjogZnVuY3Rpb24oZGFvLCBwcmVkaWNhdGUpIHtcbiAgICAgICAgaWYgKCAhIGRhbyApIHJldHVybjtcbiAgICAgICAgdmFyIGQgPSBkYW8ud2hlcmUocHJlZGljYXRlKTtcbiAgICAgICAgdGhpcy51cGRhdGVWaWV3cygpO1xuICAgICAgICByZXR1cm4gZDtcbiAgICAgIH1cbiAgICB9XG4gIF0sXG5cbiAgbWV0aG9kczogW1xuICAgIGZ1bmN0aW9uIGFuZCh2aWV3cykge1xuICAgICAgcmV0dXJuIHRoaXMuQW5kLmNyZWF0ZSh7XG4gICAgICAgIGFyZ3M6IE9iamVjdC5rZXlzKHZpZXdzKS5tYXAoZnVuY3Rpb24oaykgeyByZXR1cm4gdmlld3Nba10ucHJlZGljYXRlOyB9KVxuICAgICAgfSkucGFydGlhbEV2YWwoKTtcbiAgICB9LFxuXG4gICAgZnVuY3Rpb24gYWRkKHZpZXcpIHtcbiAgICAgIC8vIENoZWNrIHRoZSB2aWV3J3MgbmFtZSwgYW5kIGlmIGl0J3MgYSBkdXBsaWNhdGUsIGNoYW5nZSBpdHMgbmFtZSB0byBhZGRcbiAgICAgIC8vIGEgbnVtYmVyLlxuICAgICAgaWYgKCB0aGlzLnZpZXdzW3ZpZXcubmFtZV0gKSB7XG4gICAgICAgIHZhciBudW0gPSAyO1xuICAgICAgICB3aGlsZSAoIHRoaXMudmlld3Nbdmlldy5uYW1lICsgJ18nICsgbnVtXSApIHtcbiAgICAgICAgICBudW0rKztcbiAgICAgICAgfVxuICAgICAgICB2aWV3Lm5hbWUgPSB2aWV3Lm5hbWUgKyAnXycgKyBudW07XG4gICAgICB9XG5cbiAgICAgIHRoaXMudmlld3Nbdmlldy5uYW1lXSA9IHZpZXc7XG4gICAgICB0aGlzLnN1YnNfW3ZpZXcubmFtZV0gPSB2aWV3LnByZWRpY2F0ZSQuc3ViKHRoaXMub25WaWV3VXBkYXRlKTtcbiAgICAgIHRoaXMudXBkYXRlVmlld3MoKTtcbiAgICAgIHJldHVybiB2aWV3O1xuICAgIH0sXG5cbiAgICBmdW5jdGlvbiByZW1vdmUodmlld09yTmFtZSkge1xuICAgICAgdmFyIHZpZXc7XG4gICAgICB2YXIgbmFtZTtcbiAgICAgIGlmICggdHlwZW9mIHZpZXdPck5hbWUgPT09ICdzdHJpbmcnICkge1xuICAgICAgICBuYW1lID0gdmlld09yTmFtZTtcbiAgICAgICAgdmlldyA9IHRoaXMudmlld3Nbdmlld09yTmFtZV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2aWV3ID0gdmlld09yTmFtZTtcbiAgICAgICAgbmFtZSA9IHZpZXcubmFtZTtcbiAgICAgIH1cblxuICAgICAgaWYgKCAhIHRoaXMudmlld3NbbmFtZV0gKSByZXR1cm47XG5cbiAgICAgIHZpZXcuY2xlYXIoKTtcbiAgICAgIHRoaXMuc3Vic19bbmFtZV0uZGV0YWNoKCk7XG4gICAgICBkZWxldGUgdGhpcy52aWV3c1tuYW1lXTtcbiAgICAgIGRlbGV0ZSB0aGlzLnN1YnNfW25hbWVdO1xuICAgIH0sXG5cbiAgICBmdW5jdGlvbiByZW1vdmVBbGwoKSB7XG4gICAgICB0aGlzLmNsZWFyKCk7XG4gICAgICBmb2FtLk9iamVjdC5mb3JFYWNoKHRoaXMuc3Vic18sIGZ1bmN0aW9uKHN1Yikge1xuICAgICAgICBzdWIuZGV0YWNoKCk7XG4gICAgICB9KTtcbiAgICAgIHRoaXMudmlld3MgPSB7fTtcbiAgICAgIHRoaXMuc3Vic18gPSB7fTtcbiAgICB9LFxuXG4gICAgZnVuY3Rpb24gY2xlYXIoKSB7XG4gICAgICBmb2FtLk9iamVjdC5mb3JFYWNoKHRoaXMudmlld3MsIGZ1bmN0aW9uKHZpZXcpIHsgdmlldy5jbGVhcigpOyB9KTtcbiAgICB9XG4gIF0sXG5cbiAgbGlzdGVuZXJzOiBbXG4gICAge1xuICAgICAgbmFtZTogJ29uVmlld1VwZGF0ZScsXG4gICAgICBpc01lcmdlZDogdHJ1ZSxcbiAgICAgIG1lcmdlRGVsYXk6IDEwLFxuICAgICAgY29kZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMucHJlZGljYXRlID0gdGhpcy5hbmQodGhpcy52aWV3cyk7XG4gICAgICAgIC8vIFRoYXQgd2lsbCB0aWNrbGUgdGhlIGV4cHJlc3Npb24gZm9yIGZpbHRlcmVkREFPLlxuICAgICAgICB0aGlzLnVwZGF0ZVZpZXdzKCk7XG4gICAgICB9XG4gICAgfSxcbiAgICB7XG4gICAgICBuYW1lOiAndXBkYXRlVmlld3MnLFxuICAgICAgaXNNZXJnZWQ6IHRydWUsXG4gICAgICBtZXJnZURlbGF5OiAyMCxcbiAgICAgIGNvZGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAvLyBEZWxpYmVyYXRlbHkgYSBsb25nZXIgZGVsYXkgdGhhbiBvblZpZXdVcGRhdGUsIHNpbmNlIHVwZGF0aW5nIHRoZVxuICAgICAgICAvLyB2aWV3cyBpcyBsZXNzIGltcG9ydGFudC5cbiAgICAgICAgZm9hbS5PYmplY3QuZm9yRWFjaCh0aGlzLnZpZXdzLCBmdW5jdGlvbih2aWV3LCBuYW1lKSB7XG4gICAgICAgICAgdmFyIHRlbXAgPSB7fTtcbiAgICAgICAgICBmb2FtLk9iamVjdC5mb3JFYWNoKHRoaXMudmlld3MsIGZ1bmN0aW9uKHYsIG4pIHtcbiAgICAgICAgICAgIGlmICggbmFtZSA9PT0gbiApIHJldHVybjtcbiAgICAgICAgICAgIHRlbXBbbl0gPSB2O1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIC8vIFRlbXAgbm93IGhvbGRzIGFsbCB0aGUgb3RoZXIgdmlld3MuIENvbWJpbmUgYWxsIHRoZWlyIHByZWRpY2F0ZXMgdG9cbiAgICAgICAgICAvLyBnZXQgdGhlIHJlY2lwcm9jYWwgcHJlZGljYXRlIGZvciB0aGlzIHZpZXcuXG4gICAgICAgICAgdGhpcy52aWV3c1tuYW1lXS5kYW8gPSB0aGlzLmRhby53aGVyZSh0aGlzLmFuZCh0ZW1wKSk7XG4gICAgICAgIH0uYmluZCh0aGlzKSk7XG4gICAgICB9XG4gICAgfVxuICBdXG59KTtcbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmZvYW0uQ0xBU1Moe1xuICBwYWNrYWdlOiAnZm9hbS51Mi5zZWFyY2gnLFxuICBuYW1lOiAnVGV4dFNlYXJjaFZpZXcnLFxuICBleHRlbmRzOiAnZm9hbS51Mi5WaWV3JyxcblxuICByZXF1aXJlczogW1xuICAgICdmb2FtLm1sYW5nLnByZWRpY2F0ZS5Db250YWluc0lDJyxcbiAgICAnZm9hbS5tbGFuZy5wcmVkaWNhdGUuVHJ1ZScsXG4gICAgJ2ZvYW0ucGFyc2UuUXVlcnlQYXJzZXInLFxuICAgICdmb2FtLnUyLnRhZy5JbnB1dCdcbiAgXSxcblxuICBwcm9wZXJ0aWVzOiBbXG4gICAge1xuICAgICAgY2xhc3M6ICdDbGFzcycsXG4gICAgICBuYW1lOiAnb2YnXG4gICAgfSxcbiAgICB7XG4gICAgICBjbGFzczogJ0Jvb2xlYW4nLFxuICAgICAgbmFtZTogJ3JpY2hTZWFyY2gnLFxuICAgICAgdmFsdWU6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICBjbGFzczogJ0Jvb2xlYW4nLFxuICAgICAgbmFtZTogJ2tleXdvcmRTZWFyY2gnLFxuICAgICAgdmFsdWU6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICBuYW1lOiAncXVlcnlQYXJzZXInLFxuICAgICAgZmFjdG9yeTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLlF1ZXJ5UGFyc2VyLmNyZWF0ZSh7IG9mOiB0aGlzLm9mIH0pO1xuICAgICAgfVxuICAgIH0sXG4gICAge1xuICAgICAgY2xhc3M6ICdJbnQnLFxuICAgICAgbmFtZTogJ3dpZHRoJyxcbiAgICAgIHZhbHVlOiA0N1xuICAgIH0sXG4gICAgJ3Byb3BlcnR5JyxcbiAgICB7XG4gICAgICBuYW1lOiAncHJlZGljYXRlJyxcbiAgICAgIGZhY3Rvcnk6IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcy5UcnVlLmNyZWF0ZSgpOyB9XG4gICAgfSxcbiAgICB7XG4gICAgICBjbGFzczogJ2ZvYW0udTIuVmlld1NwZWMnLFxuICAgICAgbmFtZTogJ3ZpZXdTcGVjJyxcbiAgICAgIHZhbHVlOiB7IGNsYXNzOiAnZm9hbS51Mi50YWcuSW5wdXQnIH1cbiAgICB9LFxuICAgIHtcbiAgICAgIG5hbWU6ICd2aWV3J1xuICAgIH0sXG4gICAge1xuICAgICAgbmFtZTogJ2xhYmVsJyxcbiAgICAgIGV4cHJlc3Npb246IGZ1bmN0aW9uKHByb3BlcnR5KSB7XG4gICAgICAgIHJldHVybiBwcm9wZXJ0eSAmJiBwcm9wZXJ0eS5sYWJlbCA/IHByb3BlcnR5LmxhYmVsIDogJ1NlYXJjaCc7XG4gICAgICB9XG4gICAgfSxcbiAgICB7XG4gICAgICAvLyBBbGwgc2VhcmNoIHZpZXdzIChpbiB0aGUgU2VhcmNoTWFuYWdlcikgbmVlZCBhIG5hbWUuXG4gICAgICAvLyBUaGlzIGRlZmF1bHRzIHRvICdxdWVyeScuXG4gICAgICBuYW1lOiAnbmFtZScsXG4gICAgICB2YWx1ZTogJ3F1ZXJ5J1xuICAgIH1cbiAgXSxcblxuICBtZXRob2RzOiBbXG4gICAgZnVuY3Rpb24gaW5pdEUoKSB7XG4gICAgICB0aGlzXG4gICAgICAgIC5hZGRDbGFzcyh0aGlzLm15Q2xhc3MoKSlcbiAgICAgICAgLnRhZyh0aGlzLnZpZXdTcGVjLCB7IGFsd2F5c0Zsb2F0TGFiZWw6IHRydWUsIGxhYmVsJDogdGhpcy5sYWJlbCQgfSwgdGhpcy52aWV3JCk7XG5cbiAgICAgIHRoaXMudmlldy5kYXRhJC5zdWIodGhpcy51cGRhdGVWYWx1ZSk7XG4gICAgfSxcblxuICAgIGZ1bmN0aW9uIGNsZWFyKCkge1xuICAgICAgdGhpcy52aWV3LmRhdGEgPSAnJztcbiAgICAgIHRoaXMucHJlZGljYXRlID0gdGhpcy5UcnVlLmNyZWF0ZSgpO1xuICAgIH1cbiAgXSxcblxuICBsaXN0ZW5lcnM6IFtcbiAgICB7XG4gICAgICBuYW1lOiAndXBkYXRlVmFsdWUnLFxuICAgICAgY29kZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IHRoaXMudmlldy5kYXRhO1xuICAgICAgICB0aGlzLnByZWRpY2F0ZSA9ICEgdmFsdWUgP1xuICAgICAgICAgICAgdGhpcy5UcnVlLmNyZWF0ZSgpIDpcbiAgICAgICAgICAgIHRoaXMucmljaFNlYXJjaCA/XG4gICAgICAgICAgICAgICAgdGhpcy5xdWVyeVBhcnNlci5wYXJzZVN0cmluZyh2YWx1ZSkgOlxuICAgICAgICAgICAgICAgIHRoaXMuQ29udGFpbnNJQyh0aGlzLnByb3BlcnR5LCB2YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICBdXG59KTtcbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmZvYW0uQ0xBU1Moe1xuICBwYWNrYWdlOiAnZm9hbS51Mi5zdGFjaycsXG4gIG5hbWU6ICdTdGFjaycsXG5cbiAgcHJvcGVydGllczogW1xuICAgIHtcbiAgICAgIG5hbWU6ICdzdGFja18nLFxuICAgICAgaGlkZGVuOiB0cnVlLFxuICAgICAgZmFjdG9yeTogZnVuY3Rpb24oKSB7IHJldHVybiBbXTsgfVxuICAgIH0sXG4gICAge1xuICAgICAgY2xhc3M6ICdJbnQnLFxuICAgICAgbmFtZTogJ2RlcHRoJyxcbiAgICAgIHZhbHVlOiAwXG4gICAgfSxcbiAgICB7XG4gICAgICBjbGFzczogJ0ludCcsXG4gICAgICBuYW1lOiAncG9zJyxcbiAgICAgIHZhbHVlOiAtMSxcbiAgICAgIHByZVNldDogZnVuY3Rpb24oXywgcCkge1xuICAgICAgICBpZiAoIGlzTmFOKHApIHx8IHAgPiB0aGlzLmRlcHRoICkgcmV0dXJuIHRoaXMuZGVwdGggLSAxO1xuICAgICAgICBpZiAoIHAgPCAwICkgcmV0dXJuIDA7XG4gICAgICAgIHJldHVybiBwO1xuICAgICAgfVxuICAgIH0sXG4gICAge1xuICAgICAgY2xhc3M6ICdmb2FtLnUyLlZpZXdTcGVjJyxcbiAgICAgIG5hbWU6ICd0b3AnLFxuICAgICAgaGlkZGVuOiB0cnVlLFxuICAgICAgZXhwcmVzc2lvbjogZnVuY3Rpb24ocG9zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0YWNrX1twb3NdIHx8IG51bGw7XG4gICAgICB9XG4gICAgfVxuICBdLFxuXG4gIG1ldGhvZHM6IFtcbiAgICBmdW5jdGlvbiBzbG90QXQoaSkge1xuICAgICAgcmV0dXJuIHRoaXMuU3RhY2tTbG90LmNyZWF0ZSh7XG4gICAgICAgIHBvczogaSxcbiAgICAgICAgc3RhY2s6IHRoaXNcbiAgICAgIH0pO1xuICAgIH0sXG5cbiAgICBmdW5jdGlvbiBhdChpKSB7XG4gICAgICByZXR1cm4gaSA8IDAgPyB0aGlzLnN0YWNrX1t0aGlzLnBvcyArIGkgKyAxXSA6IHRoaXMuc3RhY2tfW2ldO1xuICAgIH0sXG5cbiAgICBmdW5jdGlvbiBwdXNoKHYsIHBhcmVudCkge1xuICAgICAgaWYgKCBmb2FtLnUyLkVsZW1lbnQuaXNJbnN0YW5jZSh2KSApIHtcbiAgICAgICAgY29uc29sZS53YXJuKFwiVmlld3MgYXJlIG5vdCByZWNvbW1lbmRlZCB0byBiZSBwdXNoZWQgdG8gYSBzdGFjay4gUGxlYXNlIHVzZSBhIHZpZXdTcGVjLlwiKTtcbiAgICAgIH1cbiAgICAgIC8vIFwicGFyZW50XCIgaXMgdGhlIHBhcmVudCBvYmplY3QgZm9yIHRoaXMgdmlldyBzcGVjLiAgQSB2aWV3IG9mIHRoaXMgc3RhY2tcbiAgICAgIC8vIHNob3VsZCBlbnN1cmUgdGhhdCB0aGUgY29udGV4dCB0aGF0IFwidlwiIGlzIHJlbmRlcmVkIGluIGV4dGVuZHMgZnJvbVxuICAgICAgLy8gYm90aCB0aGUgdTIuRWxlbWVudCBpcyBpdCBiZWluZyByZW5kZXJlZCB1bmRlciwgYW5kIGZyb20gdGhlIFwicGFyZW50XCJcbiAgICAgIC8vIHBhcmFtZXRlci4gIFRoaXMgd2F5IHZpZXdzIG9uIHRoZSBzdGFjayBjYW4gZXhwb3J0IHZhbHVlcyB0byB2aWV3c1xuICAgICAgLy8gdGhhdCBnZXQgcmVuZGVyZWQgYWZ0ZXIgdGhlbS5cbiAgICAgIHZhciBwb3MgPSB0aGlzLnBvcyArIDE7XG5cbiAgICAgIHRoaXMuZGVwdGggPSBwb3MgKyAxO1xuICAgICAgdGhpcy5zdGFja18ubGVuZ3RoID0gdGhpcy5kZXB0aDtcbiAgICAgIHRoaXMuc3RhY2tfW3Bvc10gPSBbdiwgcGFyZW50XTtcbiAgICAgIHRoaXMucG9zID0gcG9zO1xuICAgIH1cbiAgXSxcblxuICBhY3Rpb25zOiBbXG4gICAge1xuICAgICAgbmFtZTogJ2JhY2snLFxuICAgICAgaWNvbjogJ2Fycm93X2JhY2snLFxuICAgICAgaXNFbmFibGVkOiBmdW5jdGlvbihwb3MpIHsgcmV0dXJuIHBvcyA+IDA7IH0sXG4gICAgICBjb2RlOiBmdW5jdGlvbigpIHsgdGhpcy5wb3MtLTsgfVxuICAgIH0sXG4gICAge1xuICAgICAgbmFtZTogJ2ZvcndhcmQnLFxuICAgICAgaWNvbjogJ2Fycm93X2ZvcndhcmQnLFxuICAgICAgaXNFbmFibGVkOiBmdW5jdGlvbihwb3MsIGRlcHRoKSB7IHJldHVybiBwb3MgPCBkZXB0aCAtIDE7IH0sXG4gICAgICBjb2RlOiBmdW5jdGlvbigpIHsgdGhpcy5wb3MrKzsgfVxuICAgIH1cbiAgXSxcblxuICBjbGFzc2VzOiBbXG4gICAge1xuICAgICAgbmFtZTogJ1N0YWNrU2xvdCcsXG5cbiAgICAgIGltcGxlbWVudHM6IFsgJ2ZvYW0uY29yZS5TbG90JyBdLFxuXG4gICAgICBwcm9wZXJ0aWVzOiBbXG4gICAgICAgIHtcbiAgICAgICAgICBuYW1lOiAnc3RhY2snXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICBjbGFzczogJ0ludCcsXG4gICAgICAgICAgbmFtZTogJ3BvcydcbiAgICAgICAgfVxuICAgICAgXSxcblxuICAgICAgbWV0aG9kczogW1xuICAgICAgICBmdW5jdGlvbiBpbml0KCkge1xuICAgICAgICAgIHRoaXMub25EZXRhY2godGhpcy5zdGFjay5wb3MkLnN1Yih0aGlzLm9uU3RhY2tDaGFuZ2UpKTtcbiAgICAgICAgfSxcblxuICAgICAgICBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuc3RhY2suYXQodGhpcy5wb3MpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGZ1bmN0aW9uIHNldCgpIHtcbiAgICAgICAgICAvLyB1bmltcGxlbW50ZWQuXG4gICAgICAgIH0sXG5cbiAgICAgICAgZnVuY3Rpb24gc3ViKGwpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5TVVBFUigndXBkYXRlJywgbCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgICAgICAgcmV0dXJuICdTdGFja1Nsb3QoJyArIHRoaXMucG9zICsgJyknO1xuICAgICAgICB9XG4gICAgICBdLFxuXG4gICAgICBsaXN0ZW5lcnM6IFtcbiAgICAgICAgZnVuY3Rpb24gb25TdGFja0NoYW5nZShzKSB7XG4gICAgICAgICAgaWYgKCB0aGlzLnBvcyA8IDAgfHwgdGhpcy5wb3MgPT09IHRoaXMuc3RhY2sucG9zICkge1xuICAgICAgICAgICAgdGhpcy5wdWIoJ3VwZGF0ZScpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgXVxuICAgIH1cbiAgXVxufSk7XG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5mb2FtLkNMQVNTKHtcbiAgcGFja2FnZTogJ2ZvYW0udTIuc3RhY2snLFxuICBuYW1lOiAnU3RhY2tWaWV3JyxcbiAgZXh0ZW5kczogJ2ZvYW0udTIuVmlldycsXG5cbiAgcmVxdWlyZXM6IFtcbiAgICAnZm9hbS51Mi5zdGFjay5TdGFjaydcbiAgXSxcblxuICBleHBvcnRzOiBbICdkYXRhIGFzIHN0YWNrJyBdLFxuXG4gIHByb3BlcnRpZXM6IFtcbiAgICB7XG4gICAgICBuYW1lOiAnZGF0YScsXG4gICAgICBmYWN0b3J5OiBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMuU3RhY2suY3JlYXRlKCk7IH1cbiAgICB9LFxuICAgIHtcbiAgICAgIGNsYXNzOiAnQm9vbGVhbicsXG4gICAgICBuYW1lOiAnc2hvd0FjdGlvbnMnLFxuICAgICAgdmFsdWU6IHRydWVcbiAgICB9XG4gIF0sXG5cbiAgbWV0aG9kczogW1xuICAgIGZ1bmN0aW9uIGluaXRFKCkge1xuICAgICAgdGhpcy5zZXROb2RlTmFtZSgnZGl2Jyk7XG4gICAgICB0aGlzLmFkZENsYXNzKHRoaXMubXlDbGFzcygpKTtcblxuICAgICAgaWYgKCB0aGlzLnNob3dBY3Rpb25zICkge1xuICAgICAgICB0aGlzLnN0YXJ0KCdhY3Rpb25zJylcbiAgICAgICAgICAgIC5hZGQodGhpcy5kYXRhLmNsc18uZ2V0QXhpb21zQnlDbGFzcyhmb2FtLmNvcmUuQWN0aW9uKSlcbiAgICAgICAgICAgIC5lbmQoKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5hZGQodGhpcy5zbG90KGZ1bmN0aW9uKHMpIHtcbiAgICAgICAgaWYgKCAhIHMgKSByZXR1cm4gdGhpcy5FKCdzcGFuJyk7XG5cbiAgICAgICAgdmFyIHZpZXcgPSBzWzBdO1xuICAgICAgICB2YXIgcGFyZW50ID0gc1sxXTtcblxuXG4gICAgICAgIC8vIERvIGEgYml0IG9mIGEgZGFuY2Ugd2l0aCB0aGUgY29udGV4dCwgdG8gZW5zdXJlIHRoYXQgZXhwb3J0cyBmcm9tIFwicGFyZW50XCJcbiAgICAgICAgLy8gYXJlIGF2YWlsYWJsZSB0byBcInZpZXdcIlxuICAgICAgICB2YXIgWCA9IHBhcmVudCA/IHRoaXMuX19zdWJTdWJDb250ZXh0X18uY3JlYXRlU3ViQ29udGV4dChwYXJlbnQpIDogdGhpcy5fX3N1YlN1YkNvbnRleHRfXztcblxuICAgICAgICByZXR1cm4gZm9hbS51Mi5WaWV3U3BlYy5jcmVhdGVWaWV3KHZpZXcsIG51bGwsIHRoaXMsIFgpO1xuXG4gICAgICB9LCB0aGlzLmRhdGEkLmRvdCgndG9wJykpKTtcbiAgICB9XG4gIF1cbn0pO1xuZm9hbS5DTEFTUyh7XG4gIHBhY2thZ2U6ICdmb2FtLmFwcGxvYWRlcicsXG4gIG5hbWU6ICdNb2RlbFJlZmluZXMnLFxuICByZWZpbmVzOiAnZm9hbS5jb3JlLk1vZGVsJyxcbiAgbWV0aG9kczogW1xuICAgIHtcbiAgICAgIG5hbWU6ICdnZXRDbGFzc0RlcHMnLFxuICAgICAgY29kZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBkZXBzID0gdGhpcy5yZXF1aXJlcyA/XG4gICAgICAgICAgICB0aGlzLnJlcXVpcmVzLm1hcChmdW5jdGlvbihyKSB7IHJldHVybiByLnBhdGggfSkgOlxuICAgICAgICAgICAgW107XG5cbiAgICAgICAgZGVwcyA9IGRlcHMuY29uY2F0KHRoaXMuaW1wbGVtZW50cyA/XG4gICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmltcGxlbWVudHMubWFwKGZ1bmN0aW9uKGkpIHsgcmV0dXJuIGkucGF0aCB9KSA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICBbXSk7XG5cbiAgICAgICAgaWYgKCB0aGlzLmV4dGVuZHMgKSBkZXBzLnB1c2godGhpcy5leHRlbmRzKTtcbiAgICAgICAgcmV0dXJuIGRlcHM7XG4gICAgICB9XG4gICAgfSxcbiAgXSxcbn0pO1xuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTggVGhlIEZPQU0gQXV0aG9ycy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICovXG5cbi8qXG5UT0RPOlxuXG4gLSBSZW1vdmUgZm9hbS5jbGFzc2xvYWRlciBjbGFzc2VzXG4gLSBSZW1vdmUgYXJlcXVpcmUsIG9yIGNoYW5nZSBpdCB0byB1c2UgY2xhc3Nsb2FkZXIubG9hZFxuIC0gTWFrZSBHRU5NT0RFTCB3b3JrIHdoZW4gcnVubmluZyB3aXRob3V0IGEgY2xhc3Nsb2FkZXJcbiAtIEZpeCBXZWJTb2NrZXRCb3ggcG9ydCBhdXRvZGV0ZWN0aW9uIHRvIHdvcmsgd2hlbiBydW5uaW5nIHdpdGggdG9tY2F0IGFuZCBhbHNvIHdpdGhvdXRcblxuXG4qL1xuXG5mb2FtLkNMQVNTKHtcbiAgcGFja2FnZTogJ2ZvYW0uYXBwbG9hZGVyJyxcbiAgbmFtZTogJ0NsYXNzTG9hZGVyJyxcbiAgLyogdG9kbzogW1xuICAgIGBEb24ndCByZWdpc3RlciBjbGFzc2VzIGdsb2JhbGx5LCByZWdpc3RlciBpbiBhIHN1YmNvbnRleHQgc28gd2UgY2FuXG5oYXZlIG11bHRpcGxlIGNsYXNzbG9hZGVycyBydW5uaW5nIGFsb25nc2lkZSBlYWNob3RoZXJgXG5dLCovXG4gIHJlcXVpcmVzOiBbXG4gICAgJ2ZvYW0uY2xhc3Nsb2FkZXIuT3JEQU8nXG4gIF0sXG4gIHByb3BlcnRpZXM6IFtcbiAgICB7XG4gICAgICBjbGFzczogJ01hcCcsXG4gICAgICBuYW1lOiAncGVuZGluZydcbiAgICB9LFxuICAgIHtcbiAgICAgIGNsYXNzOiAnTWFwJyxcbiAgICAgIG5hbWU6ICdsYXRjaGVkJ1xuICAgIH0sXG4gICAge1xuICAgICAgY2xhc3M6ICdmb2FtLmRhby5EQU9Qcm9wZXJ0eScsXG4gICAgICBuYW1lOiAnbW9kZWxEQU8nXG4gICAgfVxuICBdLFxuICBtZXRob2RzOiBbXG4gICAge1xuICAgICAgbmFtZTogJ2FkZENsYXNzUGF0aCcsXG4gICAgICBjb2RlOiBmdW5jdGlvbihwYXRoLCBqc29uMikge1xuICAgICAgICB2YXIgY2xzID0gZm9hbS5sb29rdXAoZm9hbS5pc1NlcnZlciA/XG4gICAgICAgICAgICAnZm9hbS5hcHBsb2FkZXIuTm9kZU1vZGVsRmlsZURBTycgOlxuICAgICAgICAgICAgJ2ZvYW0uYXBwbG9hZGVyLldlYk1vZGVsRmlsZURBTycpO1xuICAgICAgICB2YXIgbW9kZWxEQU8gPSBjbHMuY3JlYXRlKHtyb290OiBwYXRoLCBqc29uMjoganNvbjJ9LCB0aGlzKTtcblxuICAgICAgICBpZiAoIHRoaXMubW9kZWxEQU8gKSB7XG4gICAgICAgICAgbW9kZWxEQU8gPSB0aGlzLk9yREFPLmNyZWF0ZSh7XG4gICAgICAgICAgICBwcmltYXJ5OiB0aGlzLm1vZGVsREFPLFxuICAgICAgICAgICAgZGVsZWdhdGU6IG1vZGVsREFPXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5tb2RlbERBTyA9IG1vZGVsREFPO1xuICAgICAgfVxuICAgIH0sXG4gICAge1xuICAgICAgbmFtZTogJ2xvYWQnLFxuICAgICAgcmV0dXJuczogJ1Byb21pc2UnLFxuICAgICAgYXJnczogWyB7IGNsYXNzOiAnU3RyaW5nJywgbmFtZTogJ2lkJyB9IF0sXG4gICAgICBjb2RlOiBmdW5jdGlvbihpZCkge1xuICAgICAgICByZXR1cm4gdGhpcy5sb2FkXyhpZCwgW10pO1xuICAgICAgfVxuICAgIH0sXG4gICAge1xuICAgICAgbmFtZTogJ21heWJlTG9hZCcsXG4gICAgICByZXR1cm5zOiAnUHJvbWlzZScsXG4gICAgICBkb2N1bWVudGF0aW9uOiBcIkxpa2UgbG9hZCwgYnV0IGRvbid0IHRocm93IGlmIG5vdCBmb3VuZC5cIixcbiAgICAgIGFyZ3M6IFsgeyBuYW1lOiAnaWQnLCBvZjogJ1N0cmluZycgfSBdLFxuICAgICAgY29kZTogZnVuY3Rpb24oaWQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubG9hZChpZCkuY2F0Y2goZnVuY3Rpb24oKSB7IHJldHVybiBudWxsOyB9KTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHtcbiAgICAgIG5hbWU6ICdtYXliZUxvYWRfJyxcbiAgICAgIHJldHVybnM6ICdQcm9taXNlJyxcbiAgICAgIGFyZ3M6IFsgeyBuYW1lOiAnaWQnLCBvZjogJ1N0cmluZycgfSxcbiAgICAgICAgICAgICAgeyBuYW1lOiAncGF0aCcsIG9mOiAnQXJyYXknIH0gXSxcbiAgICAgIGNvZGU6IGZ1bmN0aW9uKGlkLCBwYXRoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxvYWRfKGlkLCBwYXRoKS5jYXRjaChmdW5jdGlvbigpIHsgcmV0dXJuIG51bGw7IH0pO1xuICAgICAgfVxuICAgIH0sXG4gICAge1xuICAgICAgbmFtZTogJ2xhdGNoJyxcbiAgICAgIHJldHVybnM6ICdQcm9taXNlJyxcbiAgICAgIGFyZ3M6IFsgeyBuYW1lOiAnanNvbicgfSBdLFxuICAgICAgY29kZTogZnVuY3Rpb24oanNvbikge1xuICAgICAgICB2YXIgaWQgPSBqc29uLnBhY2thZ2UgP1xuICAgICAgICAgICAganNvbi5wYWNrYWdlICsgJy4nICsganNvbi5uYW1lIDpcbiAgICAgICAgICAgIGpzb24ubmFtZTtcblxuICAgICAgICB0aGlzLmxhdGNoZWRbaWRdID0ganNvbjtcbiAgICAgIH1cbiAgICB9LFxuICAgIHtcbiAgICAgIG5hbWU6ICdsb2FkXycsXG4gICAgICByZXR1cm5zOiAnUHJvbWlzZScsXG4gICAgICBhcmdzOiBbIHsgY2xhc3M6ICdTdHJpbmcnLCBuYW1lOiAnaWQnIH0sXG4gICAgICAgICAgICAgIHsgY2xhc3M6ICdTdHJpbmdBcnJheScsIG5hbWU6ICdwYXRoJyB9IF0sXG4gICAgICBjb2RlOiBmdW5jdGlvbihpZCwgcGF0aCkge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICAgICAgaWYgKCBmb2FtLlN0cmluZy5pc0luc3RhbmNlKGlkKSApIHtcbiAgICAgICAgICAvLyBQcmV2ZW50IGluZmluaXRlIGxvb3BzLCBpZiB3ZSdyZSBsb2FkaW5nIHRoaXMgY2xhc3MgYXMgYVxuICAgICAgICAgIC8vIGRlcGVuZGVuY3kgdG8gc29tZXRoaW5nIHRoYXQgdGhpcyBjbGFzcyBkZXBlbmRzIHVwb24gdGhlblxuICAgICAgICAgIC8vIHdlIGNhbiBqdXN0IHJlc29sdmUgcmlnaHQgYXdheS5cbiAgICAgICAgICBmb3IgKCB2YXIgaSA9IDAgOyBpIDwgcGF0aC5sZW5ndGggOyBpKysgKSB7XG4gICAgICAgICAgICBpZiAoIHBhdGhbaV0uaWQgPT09IGlkICkgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICggdGhpcy5wZW5kaW5nW2lkXSApIHJldHVybiB0aGlzLnBlbmRpbmdbaWRdO1xuXG4gICAgICAgICAgLy8gTGF0Y2hlZCBtb2RlbHMgY29tZSBmcm9tIHdoZW4gc29tZW9uZSBkZWZpbmVzIGEgY2xhc3NcbiAgICAgICAgICAvLyB3aXRoIGZvYW0uQ0xBU1MgZHVyaW5nIHJlZ3VsYXIgZXhlY3V0aW9uIChsaWtlIGEgc2NyaXB0XG4gICAgICAgICAgLy8gdGFnKS4gIFdlIGhvb2sgaW50byB0aG9zZSBzbyB0aGF0IHRoZXkgY2FuIHN0aWxsIHVzZSB0aGVcbiAgICAgICAgICAvLyBjbGFzc2xvYWRlciB0byBlbnN1cmUgYW55IGRlcGVuZGVuY2llcyBvZiB0aGF0IG1vZGVsIGFyZVxuICAgICAgICAgIC8vIGxvYWRlZCBiZWZvcmUgdGhleSB1c2UgaXQuXG4gICAgICAgICAgaWYgKCB0aGlzLmxhdGNoZWRbaWRdICkge1xuICAgICAgICAgICAgdmFyIGpzb24gPSB0aGlzLmxhdGNoZWRbaWRdO1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMubGF0Y2hlZFtpZF07XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wZW5kaW5nW2lkXSA9IFByb21pc2UuYWxsKGZvYW0uanNvbi5yZWZlcmVuY2VzKHRoaXMuX19jb250ZXh0X18sIGpzb24pKS50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICB2YXIgY2xzID0ganNvbi5jbGFzcyA/IGZvYW0ubG9va3VwKGpzb24uY2xhc3MpIDogZm9hbS5jb3JlLk1vZGVsO1xuICAgICAgICAgICAgICByZXR1cm4gc2VsZi5tb2RlbERlcHNfKGNscy5jcmVhdGUoanNvbiksIHBhdGgpO1xuICAgICAgICAgICAgfSkudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgLy8gTGF0Y2hlZCBtb2RlbHMgd2lsbCBhbHJlYWR5IGJlIHJlZ2lzdGVyZWQgaW4gdGhlXG4gICAgICAgICAgICAgIC8vIGNvbnRleHQgdmlhIGZvYW0uQ0xBU1MgYXMgZGVmaW5lZCBpbiBFbmRCb290LmpzXG4gICAgICAgICAgICAgIHJldHVybiBmb2FtLmxvb2t1cChpZCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoIGZvYW0ubG9va3VwKGlkLCB0cnVlKSApIHJldHVybiBQcm9taXNlLnJlc29sdmUoZm9hbS5sb29rdXAoaWQpKTtcblxuICAgICAgICAgIHJldHVybiB0aGlzLnBlbmRpbmdbaWRdID0gdGhpcy5tb2RlbERBTy5maW5kKGlkKS50aGVuKGZ1bmN0aW9uKG0pIHtcbiAgICAgICAgICAgIGlmICggISBtICkgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcignQ2xhc3MgTm90IEZvdW5kOiAnICsgaWQpKTtcblxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYnVpbGRDbGFzc18obSwgcGF0aCk7XG4gICAgICAgICAgfS5iaW5kKHRoaXMpLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkZhaWxlZCB0byBsb2FkIGNsYXNzIFwiICsgaWQpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCBmb2FtLmNvcmUuTW9kZWwuaXNJbnN0YW5jZShpZCkgKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMucGVuZGluZ1tpZF0gPSB0aGlzLmJ1aWxkQ2xhc3NfKGlkLCBwYXRoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgcGFyYW1ldGVyIHRvIENsYXNzTG9hZGVyLmxvYWRfXCIpO1xuICAgICAgfVxuICAgIH0sXG4gICAge1xuICAgICAgbmFtZTogJ21vZGVsRGVwc18nLFxuICAgICAgYXJnczogWyB7IG5hbWU6ICdtb2RlbCcsIG9mOiAnZm9hbS5jb3JlLk1vZGVsJyB9LFxuICAgICAgICAgICAgICB7IG5hbWU6ICdwYXRoJyB9IF0sXG4gICAgICBjb2RlOiBmdW5jdGlvbihtb2RlbCwgcGF0aCkge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIHJldHVybiBQcm9taXNlLmFsbChtb2RlbC5nZXRDbGFzc0RlcHMoKS5tYXAoZnVuY3Rpb24oZCkge1xuICAgICAgICAgIHJldHVybiBzZWxmLm1heWJlTG9hZF8oZCwgcGF0aCk7XG4gICAgICAgIH0pKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHtcbiAgICAgIG5hbWU6ICdidWlsZENsYXNzXycsXG4gICAgICBhcmdzOiBbIHsgbmFtZTogJ21vZGVsJywgb2Y6ICdmb2FtLmNvcmUuTW9kZWwnIH0sXG4gICAgICAgICAgICAgIHsgbmFtZTogJ3BhdGgnLCBvZjogJ0FycmF5JyB9IF0sXG4gICAgICBjb2RlOiBmdW5jdGlvbihtb2RlbCwgcGF0aCkge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICAgICAgcGF0aCA9IHBhdGguY29uY2F0KG1vZGVsKTtcblxuICAgICAgICB2YXIgZGVwcyA9IHRoaXMubW9kZWxEZXBzXyhtb2RlbCwgcGF0aCk7XG5cbiAgICAgICAgcmV0dXJuIGRlcHMudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgICBtb2RlbC52YWxpZGF0ZSgpO1xuICAgICAgICAgIGNscyA9IG1vZGVsLmJ1aWxkQ2xhc3MoKTtcbiAgICAgICAgICBjbHMudmFsaWRhdGUoKTtcblxuICAgICAgICAgIGlmICggISBtb2RlbC5yZWZpbmVzICkge1xuICAgICAgICAgICAgLy8gUmVnaXN0ZXIgY2xhc3MgaW4gZ2xvYmFsIGNvbnRleHQuXG4gICAgICAgICAgICBmb2FtLnJlZ2lzdGVyKGNscyk7XG5cbiAgICAgICAgICAgIC8vIFJlZ2lzdGVyIHRoZSBjbGFzcyBpbiB0aGUgZ2xvYmFsIHBhY2thZ2UgcGF0aC5cbiAgICAgICAgICAgIGZvYW0ucGFja2FnZS5yZWdpc3RlckNsYXNzKGNscyk7XG4gICAgICAgICAgfSBlbHNlIGlmICggbW9kZWwubmFtZSApIHtcbiAgICAgICAgICAgIC8vIFJlZ2lzdGVyIHJlZmluZW1lbnQgaWQgaW4gZ2xvYmFsIGNvbnRleHQuXG4gICAgICAgICAgICBmb2FtLnJlZ2lzdGVyKGNscywgKCBtb2RlbC5wYWNrYWdlIHx8ICdmb2FtLmNvcmUnICkgKyAnLicgKyBtb2RlbC5uYW1lKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gVE9ETyhtYXJrZGl0dG1lcik6IElkZW50aWZ5IGFuZCBuYW1lIGFub255bW91cyByZWZpbmVtZW50cyB3aXRoOlxuICAgICAgICAgIC8vIGVsc2Uge1xuICAgICAgICAgIC8vICAgY29uc29sZS53YXJuKCdSZWZpbmVtZW50IHdpdGhvdXQgdW5pcXVlIGlkJywgY2xzKTtcbiAgICAgICAgICAvLyAgIGRlYnVnZ2VyO1xuICAgICAgICAgIC8vIH1cblxuICAgICAgICAgIHJldHVybiBjbHM7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgXVxufSk7XG5mb2FtLkNMQVNTKHtcbiAgcGFja2FnZTogJ2ZvYW0uYXBwbG9hZGVyJyxcbiAgbmFtZTogJ0pTT04yTW9kZWxGaWxlREFPJyxcbiAgZG9jdW1lbnRhdGlvbjogJ01vZGVsIERBTyB0aGF0IHJlYWRzIGpzb24yIG1vZGVscy4nLFxuICBleHRlbmRzOiAnZm9hbS5kYW8uQWJzdHJhY3REQU8nLFxuICByZXF1aXJlczogW1xuICAgICdmb2FtLmpzb24yLkRlc2VyaWFsaXplcicsXG4gIF0sXG4gIHByb3BlcnRpZXM6IFtcbiAgICB7XG4gICAgICBuYW1lOiAnZCcsXG4gICAgICBmYWN0b3J5OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuRGVzZXJpYWxpemVyLmNyZWF0ZSh7cGFyc2VGdW5jdGlvbnM6IHRydWV9KTtcbiAgICAgIH0sXG4gICAgfSxcbiAgICAnZmV0Y2hlcicsXG4gIF0sXG4gIG1ldGhvZHM6IFtcbiAgICB7XG4gICAgICBuYW1lOiAnZmluZF8nLFxuICAgICAgY29kZTogZnVuY3Rpb24oeCwgaWQpIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICB2YXIgcHJvbWlzZSA9IHNlbGYuZmV0Y2hlci5nZXRGaWxlKGlkKTtcbiAgICAgICAgcmV0dXJuIHByb21pc2UudGhlbihmdW5jdGlvbih0ZXh0KSB7XG4gICAgICAgICAgcmV0dXJuIHNlbGYuZC5hcGFyc2VTdHJpbmcoeCwgdGV4dCk7XG4gICAgICAgIH0sIGZ1bmN0aW9uKCkgeyByZXR1cm4gbnVsbCB9KTtcbiAgICAgIH1cbiAgICB9XG4gIF1cbn0pO1xuZm9hbS5DTEFTUyh7XG4gIHBhY2thZ2U6ICdmb2FtLmFwcGxvYWRlcicsXG4gIG5hbWU6ICdXZWJNb2RlbEZpbGVGZXRjaGVyJyxcbiAgcmVxdWlyZXM6IFtcbiAgICAnZm9hbS5uZXQuSFRUUFJlcXVlc3QnXG4gIF0sXG4gIHByb3BlcnRpZXM6IFtcbiAgICAncm9vdCcsXG4gIF0sXG4gIG1ldGhvZHM6IFtcbiAgICBmdW5jdGlvbiBnZXRGaWxlKGlkKSB7XG4gICAgICByZXR1cm4gdGhpcy5IVFRQUmVxdWVzdC5jcmVhdGUoe1xuICAgICAgICBtZXRob2Q6ICdHRVQnLFxuICAgICAgICB1cmw6IHRoaXMucm9vdCArICcvJyArIGlkLnJlcGxhY2UoL1xcLi9nLCAnLycpICsgJy5qcydcbiAgICAgIH0pLnNlbmQoKS50aGVuKGZ1bmN0aW9uKHBheWxvYWQpIHtcbiAgICAgICAgcmV0dXJuIHBheWxvYWQucmVzcC50ZXh0KCk7XG4gICAgICB9KVxuICAgIH0sXG4gIF1cbn0pO1xuZm9hbS5DTEFTUyh7XG4gIHBhY2thZ2U6ICdmb2FtLmFwcGxvYWRlcicsXG4gIG5hbWU6ICdNb2RlbEZpbGVEQU8nLFxuICBkb2N1bWVudGF0aW9uOiAnTW9kZWxEQU8gd2hpY2ggcmVhZHMgaGFuZCB3cml0dGVuIG1vZGVscy4nLFxuICBleHRlbmRzOiAnZm9hbS5kYW8uQWJzdHJhY3REQU8nLFxuICBwcm9wZXJ0aWVzOiBbXG4gICAge1xuICAgICAgY2xhc3M6ICdNYXAnLFxuICAgICAgbmFtZTogJ2NhY2hlJ1xuICAgIH0sXG4gICAgJ2ZldGNoZXInLFxuICBdLFxuICBtZXRob2RzOiBbXG4gICAge1xuICAgICAgbmFtZTogJ2ZpbmRfJyxcbiAgICAgIGNvZGU6IGZ1bmN0aW9uKHgsIGlkKSB7XG4gICAgICAgIHZhciBwcm9taXNlO1xuICAgICAgICBpZiAoIHRoaXMuY2FjaGVbaWRdICkge1xuICAgICAgICAgIHByb21pc2UgPSBQcm9taXNlLnJlc29sdmUodGhpcy5jYWNoZVtpZF0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHByb21pc2UgPSB0aGlzLmZldGNoZXIuZ2V0RmlsZShpZCk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICAgICAgcmV0dXJuIHByb21pc2UudGhlbihmdW5jdGlvbih0ZXh0KSB7XG4gICAgICAgICAgaWYgKCAhIHRleHQgKSByZXR1cm4gbnVsbDtcbiAgICAgICAgICB2YXIganNvbjtcbiAgICAgICAgICB2YXIgZ2VubW9kZWwgPSBmYWxzZTtcbiAgICAgICAgICB2YXIgcmVsYXRpb25zaGlwID0gZmFsc2U7XG5cbiAgICAgICAgICB2YXIgY29udGV4dCA9IHtcbiAgICAgICAgICAgIGZvYW06IE9iamVjdC5jcmVhdGUoZm9hbSlcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgY29udGV4dC5mb2FtLkdFTk1PREVMID0gZnVuY3Rpb24obSkge1xuICAgICAgICAgICAganNvbiA9IG07XG4gICAgICAgICAgICBnZW5tb2RlbCA9IHRydWU7XG4gICAgICAgICAgfTtcblxuICAgICAgICAgIGNvbnRleHQuZm9hbS5DTEFTUyA9IGZ1bmN0aW9uKG0pIHtcbiAgICAgICAgICAgIHZhciBqc29uSWQgPSBtLnBhY2thZ2UgP1xuICAgICAgICAgICAgICAgIG0ucGFja2FnZSArICcuJyArIG0ubmFtZSA6XG4gICAgICAgICAgICAgICAgbS5uYW1lO1xuXG4gICAgICAgICAgICBpZiAoIGpzb25JZCAhPT0gaWQgKSB7XG4gICAgICAgICAgICAgIHNlbGYuY2FjaGVbanNvbklkXSA9IG07XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAganNvbiA9IG07XG4gICAgICAgICAgfTtcblxuICAgICAgICAgIGNvbnRleHQuZm9hbS5JTlRFUkZBQ0UgPSBmdW5jdGlvbihqc29uKSB7XG4gICAgICAgICAgICBqc29uLmNsYXNzID0ganNvbi5jbGFzcyB8fCAnZm9hbS5jb3JlLkludGVyZmFjZU1vZGVsJyxcbiAgICAgICAgICAgIGNvbnRleHQuZm9hbS5DTEFTUyhqc29uKTtcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgY29udGV4dC5mb2FtLkVOVU0gPSBmdW5jdGlvbihqc29uKSB7XG4gICAgICAgICAgICBqc29uLmNsYXNzID0ganNvbi5jbGFzcyB8fCAnZm9hbS5jb3JlLkVudW1Nb2RlbCc7XG4gICAgICAgICAgICBjb250ZXh0LmZvYW0uQ0xBU1MoanNvbik7XG4gICAgICAgICAgfTtcblxuICAgICAgICAgIGNvbnRleHQuZm9hbS5SRUxBVElPTlNISVAgPSBmdW5jdGlvbihyKSB7XG4gICAgICAgICAgICB2YXIgcmVmZXJlbmNlcyA9IGZvYW0uanNvbi5yZWZlcmVuY2VzKHgsIHIpO1xuXG4gICAgICAgICAgICBQcm9taXNlLmFsbChyZWZlcmVuY2VzLmNvbmNhdChbXG4gICAgICAgICAgICAgIGZvYW0ucGFja2FnZS53YWl0Rm9yQ2xhc3Moci5zb3VyY2VNb2RlbCksXG4gICAgICAgICAgICAgIGZvYW0ucGFja2FnZS53YWl0Rm9yQ2xhc3Moci50YXJnZXRNb2RlbClcbiAgICAgICAgICAgIF0pKS50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICB2YXIgb2JqID0gZm9hbS5kYW8uUmVsYXRpb25zaGlwLmNyZWF0ZShyLCB4KTtcblxuICAgICAgICAgICAgICBvYmoudmFsaWRhdGUgJiYgb2JqLnZhbGlkYXRlKCk7XG4gICAgICAgICAgICAgIGZvYW0ucGFja2FnZS5yZWdpc3RlckNsYXNzKG9iaik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgd2l0aCAoIGNvbnRleHQgKSB7IGV2YWwodGV4dCk7IH1cblxuICAgICAgICAgIGlmICggISBqc29uICkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBtb2RlbCBmb3VuZCBmb3IgJyArIGlkKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgcmVmZXJlbmNlcyA9IGZvYW0uanNvbi5yZWZlcmVuY2VzKHgsIGpzb24pO1xuXG4gICAgICAgICAgaWYgKCBnZW5tb2RlbCApIHtcbiAgICAgICAgICAgIHJlZmVyZW5jZXMgPSByZWZlcmVuY2VzLmNvbmNhdChqc29uLnJlcXVpcmVzLm1hcCh4LmNsYXNzbG9hZGVyLmxvYWQuYmluZCh4LmNsYXNzbG9hZGVyKSkpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBQcm9taXNlLmFsbChyZWZlcmVuY2VzKS50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgaWYgKCBnZW5tb2RlbCApIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGpzb24uYnVpbGQoeCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBmb2FtLmxvb2t1cChqc29uLmNsYXNzIHx8ICdNb2RlbCcpLmNyZWF0ZShqc29uLCB4KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgXVxufSk7XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE4IFRoZSBGT0FNIEF1dGhvcnMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmZvYW0uQ0xBU1Moe1xuICBwYWNrYWdlOiAnZm9hbS5hcHBsb2FkZXInLFxuICBuYW1lOiAnV2ViTW9kZWxGaWxlREFPJyxcbiAgZXh0ZW5kczogJ2ZvYW0uZGFvLlByb3h5REFPJyxcbiAgcmVxdWlyZXM6IFtcbiAgICAnZm9hbS5hcHBsb2FkZXIuSlNPTjJNb2RlbEZpbGVEQU8nLFxuICAgICdmb2FtLmFwcGxvYWRlci5Nb2RlbEZpbGVEQU8nLFxuICAgICdmb2FtLmFwcGxvYWRlci5XZWJNb2RlbEZpbGVGZXRjaGVyJyxcbiAgICAnZm9hbS5uZXQuSFRUUFJlcXVlc3QnLFxuICBdLFxuICBpbXBvcnRzOiBbXG4gICAgJ3dpbmRvdycsXG4gIF0sXG4gIHByb3BlcnRpZXM6IFtcbiAgICAncm9vdCcsXG4gICAgJ2pzb24yJyxcbiAgICB7XG4gICAgICBuYW1lOiAnZGVsZWdhdGUnLFxuICAgICAgZmFjdG9yeTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBjbHMgPSB0aGlzLmpzb24yID8gdGhpcy5KU09OMk1vZGVsRmlsZURBTyA6IHRoaXMuTW9kZWxGaWxlREFPO1xuICAgICAgICByZXR1cm4gY2xzLmNyZWF0ZSh7XG4gICAgICAgICAgZmV0Y2hlcjogdGhpcy5XZWJNb2RlbEZpbGVGZXRjaGVyLmNyZWF0ZSh7cm9vdDogdGhpcy5yb290fSksIH0pO1xuICAgICAgfSxcbiAgICB9LFxuICBdLFxufSk7XG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxOCBUaGUgRk9BTSBBdXRob3JzLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKi9cblxuZm9hbS5DTEFTUyh7XG4gIHBhY2thZ2U6IFwiZm9hbS5hcHBsb2FkZXJcIixcbiAgbmFtZTogXCJDbGFzc0xvYWRlckNvbnRleHRcIixcbiAgcmVxdWlyZXM6IFtcbiAgICBcImZvYW0uYXBwbG9hZGVyLkNsYXNzTG9hZGVyXCIsXG4gICAgXCJmb2FtLmFwcGxvYWRlci5XZWJNb2RlbEZpbGVEQU9cIlxuICBdLFxuICBleHBvcnRzOiBbXG4gICAgJ2NsYXNzbG9hZGVyJ1xuICBdLFxuICBwcm9wZXJ0aWVzOiBbXG4gICAge1xuICAgICAgbmFtZTogXCJjbGFzc2xvYWRlclwiLFxuICAgICAgZmFjdG9yeTogZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLkNsYXNzTG9hZGVyLmNyZWF0ZSgpIH0sXG4gICAgfVxuICBdXG59KTtcbihmdW5jdGlvbigpIHtcbiAgdmFyIGNsYXNzTG9hZGVyQ29udGV4dCA9IGZvYW0uYXBwbG9hZGVyLkNsYXNzTG9hZGVyQ29udGV4dC5jcmVhdGUoXG4gICAgICBudWxsLCBmb2FtLl9fY29udGV4dF9fKTtcbiAgY2xhc3NMb2FkZXJDb250ZXh0LmNsYXNzbG9hZGVyLmFkZENsYXNzUGF0aChnbG9iYWwuRk9BTV9ST09UKTtcbiAgZm9hbS5fX2NvbnRleHRfXyA9IGNsYXNzTG9hZGVyQ29udGV4dC5fX3N1YkNvbnRleHRfXztcblxuICB2YXIgQ0xBU1MgPSBmb2FtLkNMQVNTO1xuICBmb2FtLkNMQVNTID0gZnVuY3Rpb24obSkge1xuICAgIGZvYW0uX19jb250ZXh0X18uY2xhc3Nsb2FkZXIubGF0Y2gobSk7XG4gICAgQ0xBU1MobSk7XG4gIH07XG59KSgpO1xuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTYgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIENvcHlyaWdodCAyMDE4IFRoZSBGT0FNIEF1dGhvcnMuICBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKi9cblxuZm9hbS5DTEFTUyh7XG4gIHBhY2thZ2U6ICdmb2FtLnUyJyxcbiAgbmFtZTogJ0ZvYW1UYWdMb2FkZXInLFxuXG4gIGRvY3VtZW50YXRpb246ICdDb252ZXJ0cyA8Zm9hbT4gdGFncyBpbiBkb2N1bWVudCBpbnRvIFZpZXdzLicsXG5cbiAgaW1wb3J0czogWyAnZG9jdW1lbnQnLCAnd2luZG93JywgJ2NsYXNzbG9hZGVyJyBdLFxuXG4gIG1ldGhvZHM6IFtcbiAgICBmdW5jdGlvbiBpbml0KCkge1xuICAgICAgdGhpcy53aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignbG9hZCcsIHRoaXMub25Mb2FkLCBmYWxzZSk7XG4gICAgfSxcblxuICAgIGZ1bmN0aW9uIGZpbmRQcm9wZXJ0eUlDKGNscywgbmFtZSkge1xuICAgICAgdmFyIHBzID0gY2xzLmdldEF4aW9tc0J5Q2xhc3MoZm9hbS5jb3JlLlByb3BlcnR5KTtcbiAgICAgIGZvciAoIHZhciBpID0gMCA7IGkgPCBwcy5sZW5ndGggOyBpKysgKSB7XG4gICAgICAgIGlmICggbmFtZSA9PT0gcHNbaV0ubmFtZS50b0xvd2VyQ2FzZSgpICkgcmV0dXJuIHBzW2ldO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBmdW5jdGlvbiBsb2FkVGFnKGVsKSB7XG4gICAgICB2YXIgY2xzTmFtZSA9IGVsLmdldEF0dHJpYnV0ZSgnY2xhc3MnKTtcblxuICAgICAgdGhpcy5jbGFzc2xvYWRlci5sb2FkKGNsc05hbWUpLnRoZW4oZnVuY3Rpb24oY2xzKSB7XG4gICAgICAgIHZhciBpZCAgPSBlbC5pZDtcblxuICAgICAgICB2YXIgdmlldyA9IGNscy5jcmVhdGUobnVsbCwgZm9hbS5fX2NvbnRleHRfXyk7XG5cbiAgICAgICAgaWYgKCB2aWV3LnRvRSApIHtcbiAgICAgICAgICB2aWV3ID0gdmlldy50b0Uoe30sIGZvYW0uX19jb250ZXh0X18pO1xuICAgICAgICB9IGVsc2UgaWYgKCAhIGZvYW0udTIuRWxlbWVudC5pc0luc3RhbmNlKHZpZXcpICkgIHtcbiAgICAgICAgICB2aWV3ID0gZm9hbS51Mi5EZXRhaWxWaWV3LmNyZWF0ZSh7ZGF0YTogdmlldywgc2hvd0FjdGlvbnM6IHRydWV9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoIHZhciBqID0gMCA7IGogPCBlbC5hdHRyaWJ1dGVzLmxlbmd0aCA7IGorKyApIHtcbiAgICAgICAgICB2YXIgYXR0ciA9IGVsLmF0dHJpYnV0ZXNbal07XG4gICAgICAgICAgdmFyIHAgICAgPSB0aGlzLmZpbmRQcm9wZXJ0eUlDKHZpZXcuY2xzXywgYXR0ci5uYW1lKTtcbiAgICAgICAgICBpZiAoIHAgKSBwLnNldCh2aWV3LCBhdHRyLnZhbHVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGVsLm91dGVySFRNTCA9IHZpZXcub3V0ZXJIVE1MO1xuICAgICAgICB2aWV3LmxvYWQoKTtcblxuICAgICAgICAvLyBTdG9yZSB2aWV3IGluIGdsb2JhbCB2YXJpYWJsZSBpZiBuYW1lZC4gVXNlZnVsIGZvciB0ZXN0aW5nLlxuICAgICAgICBpZiAoIGlkICkgZ2xvYmFsW2lkXSA9IHZpZXc7XG5cbiAgICAgIH0uYmluZCh0aGlzKSwgZnVuY3Rpb24oZSkge1xuICAgICAgICBjb25zb2xlLmVycm9yKGUpO1xuICAgICAgICBjb25zb2xlLmVycm9yKCdGYWlsZWQgdG8gbG9hZCBjbGFzczogJywgY2xzTmFtZSk7XG4gICAgICB9KTtcbiAgICB9XG4gIF0sXG5cbiAgbGlzdGVuZXJzOiBbXG4gICAgZnVuY3Rpb24gb25Mb2FkKCkge1xuICAgICAgdmFyIGVscyA9IEFycmF5LmZyb20odGhpcy5kb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnZm9hbScpKTtcbiAgICAgIHRoaXMud2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2xvYWQnLCB0aGlzLm9uTG9hZCk7XG5cbiAgICAgIC8vIEluc3RhbGwgbGFzdCB0byBmaXJzdCB0byBhdm9pZCBtZXNzaW5nIHVwIHRoZSAnZWxzJyBsaXN0LlxuICAgICAgZWxzLmZvckVhY2godGhpcy5sb2FkVGFnLmJpbmQodGhpcykpO1xuICAgIH1cbiAgXVxufSk7XG5cbmZvYW0udTIuRm9hbVRhZ0xvYWRlci5jcmVhdGUoKTtcbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmZvYW0uQ0xBU1Moe1xuICBwYWNrYWdlOiAnZm9hbS5ncmFwaGljcycsXG4gIG5hbWU6ICdUcmFuc2Zvcm0nLFxuXG4gIGRvY3VtZW50YXRpb246ICdBZmZpbmUgdHJhbnNmb3JtLicsXG5cbiAgcHJvcGVydGllczogW1xuICAgIHsgY2xhc3M6ICdTaW1wbGUnLCBuYW1lOiAnYScgfSxcbiAgICB7IGNsYXNzOiAnU2ltcGxlJywgbmFtZTogJ2InIH0sXG4gICAgeyBjbGFzczogJ1NpbXBsZScsIG5hbWU6ICdjJyB9LFxuICAgIHsgY2xhc3M6ICdTaW1wbGUnLCBuYW1lOiAnZCcgfSxcbiAgICB7IGNsYXNzOiAnU2ltcGxlJywgbmFtZTogJ2UnIH0sXG4gICAgeyBjbGFzczogJ1NpbXBsZScsIG5hbWU6ICdmJyB9LFxuICAgIHsgY2xhc3M6ICdTaW1wbGUnLCBuYW1lOiAnZycgfSxcbiAgICB7IGNsYXNzOiAnU2ltcGxlJywgbmFtZTogJ2gnIH0sXG4gICAgeyBjbGFzczogJ1NpbXBsZScsIG5hbWU6ICdpJyB9LFxuICAgIHtcbiAgICAgIG5hbWU6ICdpbnZlcnNlXycsXG4gICAgICBmYWN0b3J5OiBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMuY2xzXy5jcmVhdGUoKTsgfSxcbiAgICAgIC8vIEV4Y2x1ZGUgZnJvbSBjb21wYXJlVG8oKVxuICAgICAgY29tcGFyZTogZnVuY3Rpb24oKSB7IHJldHVybiAwOyB9XG4gICAgfVxuICBdLFxuXG4gIG1ldGhvZHM6IFtcbiAgICBmdW5jdGlvbiBpbml0QXJncygpIHtcbiAgICAgIHRoaXMuYSA9IDE7IHRoaXMuYiA9IDA7IHRoaXMuYyA9IDA7XG4gICAgICB0aGlzLmQgPSAwOyB0aGlzLmUgPSAxOyB0aGlzLmYgPSAwO1xuICAgICAgdGhpcy5nID0gMDsgdGhpcy5oID0gMDsgdGhpcy5pID0gMTtcbiAgICB9LFxuXG4gICAgZnVuY3Rpb24gbXVsKGEsIGIsIGMsIGQsIGUsIGYsIGcsIGgsIGkpIHtcbiAgICAgIHZhciB0YSA9IHRoaXMuYSwgdGIgPSB0aGlzLmIsIHRjID0gdGhpcy5jLFxuICAgICAgICAgIHRkID0gdGhpcy5kLCB0ZSA9IHRoaXMuZSwgdGYgPSB0aGlzLmYsXG4gICAgICAgICAgdGcgPSB0aGlzLmcsIHRoID0gdGhpcy5oLCB0aSA9IHRoaXMuaTtcblxuICAgICAgdGhpcy5hID0gdGEgKiBhICsgdGIgKiBkICsgdGMgKiBnO1xuICAgICAgdGhpcy5iID0gdGEgKiBiICsgdGIgKiBlICsgdGMgKiBoO1xuICAgICAgdGhpcy5jID0gdGEgKiBjICsgdGIgKiBmICsgdGMgKiBpO1xuXG4gICAgICB0aGlzLmQgPSB0ZCAqIGEgKyB0ZSAqIGQgKyB0ZiAqIGc7XG4gICAgICB0aGlzLmUgPSB0ZCAqIGIgKyB0ZSAqIGUgKyB0ZiAqIGg7XG4gICAgICB0aGlzLmYgPSB0ZCAqIGMgKyB0ZSAqIGYgKyB0ZiAqIGk7XG5cbiAgICAgIHRoaXMuZyA9IHRnICogYSArIHRoICogZCArIHRpICogZztcbiAgICAgIHRoaXMuaCA9IHRnICogYiArIHRoICogZSArIHRpICogaDtcbiAgICAgIHRoaXMuaSA9IHRnICogYyArIHRoICogZiArIHRpICogaTtcblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIGZ1bmN0aW9uIG11bFQodCkge1xuICAgICAgcmV0dXJuIHRoaXMubXVsKHQuYSwgdC5iLCB0LmMsIHQuZCwgdC5lLCB0LmYsIHQuZywgdC5oLCB0LmkpO1xuICAgIH0sXG5cbiAgICBmdW5jdGlvbiBtdWxQKHApIHtcbiAgICAgIHZhciB0YSA9IHRoaXMuYSwgdGIgPSB0aGlzLmIsIHRjID0gdGhpcy5jLFxuICAgICAgICAgIHRkID0gdGhpcy5kLCB0ZSA9IHRoaXMuZSwgdGYgPSB0aGlzLmYsXG4gICAgICAgICAgdGcgPSB0aGlzLmcsIHRoID0gdGhpcy5oLCB0aSA9IHRoaXMuaTtcblxuICAgICAgdmFyIGEgPSBwLng7XG4gICAgICB2YXIgZCA9IHAueTtcbiAgICAgIHZhciBnID0gcC53O1xuXG4gICAgICBwLnggPSB0YSAqIGEgKyB0YiAqIGQgKyB0YyAqIGc7XG4gICAgICBwLnkgPSB0ZCAqIGEgKyB0ZSAqIGQgKyB0ZiAqIGc7XG4gICAgICBwLncgPSB0ZyAqIGEgKyB0aCAqIGQgKyB0aSAqIGc7XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBmdW5jdGlvbiBhZmZpbmUobSkge1xuICAgICAgcmV0dXJuIHRoaXMubXVsKG0uYSwgbS5iLCBtLmMsIG0uZCwgbS5lLCBtLmYsIG0uZywgbS5oLCBtLmkpO1xuICAgIH0sXG5cbiAgICBmdW5jdGlvbiB0cmFuc3Bvc2UoKSB7XG4gICAgICAvLyBhIGIgYyAgICBhIGQgZ1xuICAgICAgLy8gZCBlIGYgLT4gYiBlIGhcbiAgICAgIC8vIGcgaCBpICAgIGMgZiBpXG4gICAgICB2YXIgdG1wID0gdGhpcy5iO1xuICAgICAgdGhpcy5iID0gdGhpcy5kO1xuICAgICAgdGhpcy5kID0gdG1wO1xuXG4gICAgICB0bXAgPSB0aGlzLmM7XG4gICAgICB0aGlzLmMgPSB0aGlzLmc7XG4gICAgICB0aGlzLmcgPSB0bXA7XG5cbiAgICAgIHRtcCA9IHRoaXMuZjtcbiAgICAgIHRoaXMuZiA9IHRoaXMuaDtcbiAgICAgIHRoaXMuaCA9IHRtcDtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBmdW5jdGlvbiBpbnZlcnQoKSB7XG4gICAgICB2YXIgdGEgPSB0aGlzLmEsIHRiID0gdGhpcy5iLCB0YyA9IHRoaXMuYyxcbiAgICAgICAgICB0ZCA9IHRoaXMuZCwgdGUgPSB0aGlzLmUsIHRmID0gdGhpcy5mLFxuICAgICAgICAgIHRnID0gdGhpcy5nLCB0aCA9IHRoaXMuaCwgdGkgPSB0aGlzLmk7XG5cbiAgICAgIHZhciBkZXQgPSB0YSoodGUqdGkgIC0gdGYqdGgpIC0gdGIqKHRkKnRpIC0gdGYqdGcpICsgdGMqKHRkKnRoLXRlKnRnKTtcbiAgICAgIHZhciBkZXRpbnYgPSAxIC8gZGV0O1xuXG4gICAgICB2YXIgaW52ID0gdGhpcy5pbnZlcnNlXztcblxuICAgICAgaW52LmEgPSBkZXRpbnYgKiAodGUqdGkgLSB0Zip0aCk7XG4gICAgICBpbnYuYiA9IGRldGludiAqICh0Yyp0aCAtIHRiKnRpKTtcbiAgICAgIGludi5jID0gZGV0aW52ICogKHRiKnRmIC0gdGMqdGUpO1xuXG4gICAgICBpbnYuZCA9IGRldGludiAqICh0Zip0ZyAtIHRkKnRpKTtcbiAgICAgIGludi5lID0gZGV0aW52ICogKHRhKnRpIC0gdGMqdGcpO1xuICAgICAgaW52LmYgPSBkZXRpbnYgKiAodGMqdGQgLSB0YSp0Zik7XG5cbiAgICAgIGludi5nID0gZGV0aW52ICogKHRkKnRoIC0gdGUqdGcpO1xuICAgICAgaW52LmggPSBkZXRpbnYgKiAodGIqdGcgLSB0YSp0aCk7XG4gICAgICBpbnYuaSA9IGRldGludiAqICh0YSp0ZSAtIHRiKnRkKTtcblxuICAgICAgcmV0dXJuIGludjtcbiAgICB9LFxuXG4gICAgZnVuY3Rpb24gZGV0KCkge1xuICAgICAgLy8gQ29tcHV0ZSB0aGUgZGV0ZXJtaW5hbnRcbiAgICAgIHZhciBhID0gdGhpcy5hLCBiID0gdGhpcy5iLCBjID0gdGhpcy5jLFxuICAgICAgICAgIGQgPSB0aGlzLmQsIGUgPSB0aGlzLmUsIGYgPSB0aGlzLmYsXG4gICAgICAgICAgZyA9IHRoaXMuZywgaCA9IHRoaXMuaCwgaSA9IHRoaXMuaTtcblxuICAgICAgcmV0dXJuIGEqKGUqaSAgLSBmKmgpIC0gYiooZCppIC0gZipnKSArIGMqKGQqaC1lKmcpO1xuICAgIH0sXG5cbiAgICBmdW5jdGlvbiByZXNldCgpIHtcbiAgICAgIHRoaXMuaW5pdEFyZ3MoKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBmdW5jdGlvbiB0cmFuc2xhdGUoZHgsIGR5KSB7XG4gICAgICBpZiAoIGR4IHx8IGR5ICkgdGhpcy5tdWwoMSwgMCwgZHgsIDAsIDEsIGR5LCAwLCAwLCAxKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBmdW5jdGlvbiBza2V3KHgsIHkpIHtcbiAgICAgIGlmICggeCB8fCB5ICkgdGhpcy5tdWwoMSwgeCwgMCwgeSwgMSwgMCwgMCwgMCwgMSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgZnVuY3Rpb24gc2NhbGUoeCwgeSkge1xuICAgICAgaWYgKCB5ID09PSB1bmRlZmluZWQgKSB5ID0geDtcbiAgICAgIGlmICggeCAhPSAxIHx8IHkgIT0gMSApIHRoaXMubXVsKHgsIDAsIDAsIDAsIHksIDAsIDAsIDAsIDEpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIGZ1bmN0aW9uIHJvdGF0ZShhKSB7XG4gICAgICBpZiAoIGEgKSB0aGlzLm11bChNYXRoLmNvcyhhKSwgTWF0aC5zaW4oYSksIDAsIC1NYXRoLnNpbihhKSwgTWF0aC5jb3MoYSksIDAsIDAsIDAsIDEpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIGZ1bmN0aW9uIHJvdGF0ZUFyb3VuZChhLCB4LCB5KSB7XG4gICAgICByZXR1cm4gdGhpcy50cmFuc2xhdGUoLXgsIC15KS5yb3RhdGUoYSkudHJhbnNsYXRlKHgsIHkpO1xuICAgIH1cbiAgXVxufSk7XG5cblxuZm9hbS5DTEFTUyh7XG4gIHBhY2thZ2U6ICdmb2FtLmdyYXBoaWNzJyxcbiAgbmFtZTogJ1RyYW5zZm9ybTNEJyxcblxuICBkb2N1bWVudGF0aW9uOiAnVGhyZWUtZGltZW5zaW9uYWwgYWZmaW5lIHRyYW5zZm9ybS4nLFxuXG4gIHByb3BlcnRpZXM6IFtcbiAgICB7IGNsYXNzOiAnU2ltcGxlJywgbmFtZTogJ2EnIH0sXG4gICAgeyBjbGFzczogJ1NpbXBsZScsIG5hbWU6ICdiJyB9LFxuICAgIHsgY2xhc3M6ICdTaW1wbGUnLCBuYW1lOiAnYycgfSxcbiAgICB7IGNsYXNzOiAnU2ltcGxlJywgbmFtZTogJ2QnIH0sXG5cbiAgICB7IGNsYXNzOiAnU2ltcGxlJywgbmFtZTogJ2UnIH0sXG4gICAgeyBjbGFzczogJ1NpbXBsZScsIG5hbWU6ICdmJyB9LFxuICAgIHsgY2xhc3M6ICdTaW1wbGUnLCBuYW1lOiAnZycgfSxcbiAgICB7IGNsYXNzOiAnU2ltcGxlJywgbmFtZTogJ2gnIH0sXG5cbiAgICB7IGNsYXNzOiAnU2ltcGxlJywgbmFtZTogJ2knIH0sXG4gICAgeyBjbGFzczogJ1NpbXBsZScsIG5hbWU6ICdqJyB9LFxuICAgIHsgY2xhc3M6ICdTaW1wbGUnLCBuYW1lOiAnaycgfSxcbiAgICB7IGNsYXNzOiAnU2ltcGxlJywgbmFtZTogJ2wnIH0sXG5cbiAgICB7IGNsYXNzOiAnU2ltcGxlJywgbmFtZTogJ20nIH0sXG4gICAgeyBjbGFzczogJ1NpbXBsZScsIG5hbWU6ICduJyB9LFxuICAgIHsgY2xhc3M6ICdTaW1wbGUnLCBuYW1lOiAnbycgfSxcbiAgICB7IGNsYXNzOiAnU2ltcGxlJywgbmFtZTogJ3AnIH1cbiAgXSxcblxuICBtZXRob2RzOiBbXG4gICAgZnVuY3Rpb24gaW5pdCgpIHtcbiAgICAgIHRoaXMuYSA9IDE7IHRoaXMuYiA9IDA7IHRoaXMuYyA9IDA7IHRoaXMuZCA9IDA7XG4gICAgICB0aGlzLmUgPSAwOyB0aGlzLmYgPSAxOyB0aGlzLmcgPSAwOyB0aGlzLmggPSAwO1xuICAgICAgdGhpcy5pID0gMDsgdGhpcy5qID0gMDsgdGhpcy5rID0gMTsgdGhpcy5sID0gMDtcbiAgICAgIHRoaXMubSA9IDA7IHRoaXMubiA9IDA7IHRoaXMubyA9IDA7IHRoaXMucCA9IDE7XG4gICAgfSxcblxuICAgIGZ1bmN0aW9uIG11bE0obykge1xuICAgICAgcmV0dXJuIHRoaXMubXVsKFxuICAgICAgICBvLmEsIG8uYiwgby5jLCBvLmQsXG4gICAgICAgIG8uZSwgby5mLCBvLmgsIG8uaSxcbiAgICAgICAgby5qLCBvLmosIG8uaywgby5sLFxuICAgICAgICBvLm0sIG8ubiwgby5vLCBvLnApO1xuICAgIH0sXG5cbiAgICBmdW5jdGlvbiBtdWxQKHApIHtcbiAgICAgIHZhciB0YSA9IHRoaXMuYSwgdGIgPSB0aGlzLmIsIHRjID0gdGhpcy5jLCB0ZCA9IHRoaXMuZCxcbiAgICAgICAgICB0ZSA9IHRoaXMuZSwgdGYgPSB0aGlzLmYsIHRnID0gdGhpcy5nLCB0aCA9IHRoaXMuaCxcbiAgICAgICAgICB0aSA9IHRoaXMuaSwgdGogPSB0aGlzLmosIHRrID0gdGhpcy5rLCB0bCA9IHRoaXMubCxcbiAgICAgICAgICB0bSA9IHRoaXMubSwgdG4gPSB0aGlzLm4sIHRvID0gdGhpcy5vLCB0cCA9IHRoaXMucDtcblxuICAgICAgdmFyIGEgPSBwLng7XG4gICAgICB2YXIgYiA9IHAueTtcbiAgICAgIHZhciBjID0gcC56XG4gICAgICB2YXIgZCA9IHAudztcblxuICAgICAgcC54ID0gdGEgKiBhICsgdGIgKiBiICsgdGMgKiBjICsgdGQgKiBkO1xuICAgICAgcC55ID0gdGUgKiBhICsgdGYgKiBiICsgdGcgKiBjICsgdGggKiBkO1xuICAgICAgcC56ID0gdGkgKiBhICsgdGogKiBiICsgdGsgKiBjICsgdGwgKiBkO1xuICAgICAgcC53ID0gdG0gKiBhICsgdG4gKiBiICsgdG8gKiBjICsgdHAgKiBkO1xuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgZnVuY3Rpb24gbXVsKGEsIGIsIGMsIGQsIGUsIGYsIGcsIGgsIGksIGosIGssIGwsIG0sIG4sIG8sIHApIHtcbiAgICAgIHZhciB0YSA9IHRoaXMuYSwgdGIgPSB0aGlzLmIsIHRjID0gdGhpcy5jLCB0ZCA9IHRoaXMuZCxcbiAgICAgICAgICB0ZSA9IHRoaXMuZSwgdGYgPSB0aGlzLmYsIHRnID0gdGhpcy5nLCB0aCA9IHRoaXMuaCxcbiAgICAgICAgICB0aSA9IHRoaXMuaSwgdGogPSB0aGlzLmosIHRrID0gdGhpcy5rLCB0bCA9IHRoaXMubCxcbiAgICAgICAgICB0bSA9IHRoaXMubSwgdG4gPSB0aGlzLm4sIHRvID0gdGhpcy5vLCB0cCA9IHRoaXMucDtcblxuICAgICAgdGhpcy5hID0gdGEgKiBhICsgdGIgKiBlICsgdGMgKiBpICsgdGQgKiBtO1xuICAgICAgdGhpcy5iID0gdGEgKiBiICsgdGIgKiBmICsgdGMgKiBqICsgdGQgKiBuO1xuICAgICAgdGhpcy5jID0gdGEgKiBjICsgdGIgKiBnICsgdGMgKiBrICsgdGQgKiBvO1xuICAgICAgdGhpcy5kID0gdGEgKiBkICsgdGIgKiBoICsgdGMgKiBsICsgdGQgKiBwO1xuXG4gICAgICB0aGlzLmUgPSB0ZSAqIGEgKyB0ZiAqIGUgKyB0ZyAqIGkgKyB0aCAqIG07XG4gICAgICB0aGlzLmYgPSB0ZSAqIGIgKyB0ZiAqIGYgKyB0ZyAqIGogKyB0aCAqIG47XG4gICAgICB0aGlzLmcgPSB0ZSAqIGMgKyB0ZiAqIGcgKyB0ZyAqIGsgKyB0aCAqIG87XG4gICAgICB0aGlzLmggPSB0ZSAqIGQgKyB0ZiAqIGggKyB0ZyAqIGwgKyB0aCAqIHA7XG5cbiAgICAgIHRoaXMuaSA9IHRpICogYSArIHRqICogZSArIHRrICogaSArIHRsICogbTtcbiAgICAgIHRoaXMuaiA9IHRpICogYiArIHRqICogZiArIHRrICogaiArIHRsICogbjtcbiAgICAgIHRoaXMuayA9IHRpICogYyArIHRqICogZyArIHRrICogayArIHRsICogbztcbiAgICAgIHRoaXMubCA9IHRpICogZCArIHRqICogaCArIHRrICogbCArIHRsICogcDtcblxuICAgICAgdGhpcy5tID0gdG0gKiBhICsgdG4gKiBlICsgdG8gKiBpICsgdHAgKiBtO1xuICAgICAgdGhpcy5uID0gdG0gKiBiICsgdG4gKiBmICsgdG8gKiBqICsgdHAgKiBuO1xuICAgICAgdGhpcy5vID0gdG0gKiBjICsgdG4gKiBnICsgdG8gKiBrICsgdHAgKiBvO1xuICAgICAgdGhpcy5wID0gdG0gKiBkICsgdG4gKiBoICsgdG8gKiBsICsgdHAgKiBwO1xuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgZnVuY3Rpb24gYWZmaW5lKG0pIHtcbiAgICAgIHJldHVybiB0aGlzLm11bChtLmEsIG0uYiwgbS5jLCBtLmQsXG4gICAgICAgICAgICAgICAgICAgICAgbS5lLCBtLmYsIG0uZywgbS5oLFxuICAgICAgICAgICAgICAgICAgICAgIG0uaSwgbS5qLCBtLmssIG0ubCxcbiAgICAgICAgICAgICAgICAgICAgICBtLm0sIG0ubiwgbS5vLCBtLnApO1xuICAgIH0sXG5cbiAgICBmdW5jdGlvbiBpbnZlcnQoKSB7XG4gICAgICAvLyBhIGIgYyBkICAgIGEgZSBpIG1cbiAgICAgIC8vIGUgZiBnIGggLT4gYiBmIGogblxuICAgICAgLy8gaSBqIGsgbCAgICBjIGcgayBvXG4gICAgICAvLyBtIG4gbyBwICAgIGQgaCBsIHBcbiAgICAgIHZhciB0bXAgPSB0aGlzLmI7XG4gICAgICB0aGlzLmIgPSB0aGlzLmU7XG4gICAgICB0aGlzLmUgPSB0bXA7XG5cbiAgICAgIHRtcCA9IHRoaXMuYztcbiAgICAgIHRoaXMuYyA9IHRoaXMuaTtcbiAgICAgIHRoaXMuaSA9IHRtcDtcblxuICAgICAgdG1wID0gdGhpcy5kO1xuICAgICAgdGhpcy5kID0gdGhpcy5tO1xuICAgICAgdGhpcy5tID0gdG1wO1xuXG4gICAgICB0bXAgPSB0aGlzLmc7XG4gICAgICB0aGlzLmcgPSB0aGlzLmo7XG4gICAgICB0aGlzLmogPSB0bXA7XG5cbiAgICAgIHRtcCA9IHRoaXMuaDtcbiAgICAgIHRoaXMuaCA9IHRoaXMubjtcbiAgICAgIHRoaXMubiA9IHRtcDtcblxuICAgICAgdG1wID0gdGhpcy5sO1xuICAgICAgdGhpcy5sID0gdGhpcy5vO1xuICAgICAgdGhpcy5vID0gdG1wO1xuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgZnVuY3Rpb24gcmVzZXQoKSB7XG4gICAgICB0aGlzLmluaXQoKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBmdW5jdGlvbiB0cmFuc2xhdGUoZHgsIGR5LCBkeikge1xuICAgICAgaWYgKCAhIGR4ICYmICEgZHkgJiYgISBkeiApIHJldHVybjtcbiAgICAgIHRoaXMubXVsKDEsIDAsIDAsIGR4LFxuICAgICAgICAgICAgICAgMCwgMSwgMCwgZHksXG4gICAgICAgICAgICAgICAwLCAwLCAxLCBkeixcbiAgICAgICAgICAgICAgIDAsIDAsIDAsIDEpO1xuICAgIH0sXG5cbiAgICBmdW5jdGlvbiBza2V3KHgsIHksIHopIHtcbiAgICAgIGlmICggISB4ICYmICEgeSAmJiAhIHogKSByZXR1cm47XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ25vdCBpbXBsZW1lbnRlZCB5ZXQuJyk7XG4gICAgfSxcblxuICAgIGZ1bmN0aW9uIHNjYWxlKHgsIHksIHopIHtcbiAgICAgIGlmICggeCA9PT0gMSAmJiB5ID09PSAxICYmIHogPT0gMSApIHJldHVybjtcbiAgICAgIHRoaXMubXVsKHgsIDAsIDAsIDAsXG4gICAgICAgICAgICAgICAwLCB5LCAwLCAwLFxuICAgICAgICAgICAgICAgMCwgMCwgeiwgMCxcbiAgICAgICAgICAgICAgIDAsIDAsIDAsIDEpO1xuICAgIH0sXG5cbiAgICBmdW5jdGlvbiByb3RhdGVYKGEpIHtcbiAgICAgIGlmICggISBhICkgcmV0dXJuO1xuICAgICAgdmFyIGMgPSBNYXRoLmNvcyhhKTtcbiAgICAgIHZhciBzID0gTWF0aC5zaW4oYSk7XG5cbiAgICAgIHRoaXMubXVsKFxuICAgICAgICAxLCAgMCwgIDAsICAwLFxuICAgICAgICAwLCAgYywgLXMsICAwLFxuICAgICAgICAwLCAgcywgIGMsICAwLFxuICAgICAgICAwLCAgMCwgIDAsICAxKTtcbiAgICB9LFxuXG4gICAgZnVuY3Rpb24gcm90YXRlWShhKSB7XG4gICAgICBpZiAoICEgYSApIHJldHVybjtcbiAgICAgIHZhciBjID0gTWF0aC5jb3MoYSk7XG4gICAgICB2YXIgcyA9IE1hdGguc2luKGEpO1xuXG4gICAgICB0aGlzLm11bChcbiAgICAgICAgYywgIDAsICBzLCAgMCxcbiAgICAgICAgMCwgIDEsICAwLCAgMCxcbiAgICAgICAtcywgIDAsICBjLCAgMCxcbiAgICAgICAgMCwgIDAsICAwLCAgMSk7XG4gICAgfSxcblxuXG4gICAgZnVuY3Rpb24gcm90YXRlWihhKSB7XG4gICAgICBpZiAoICEgYSApIHJldHVybjtcbiAgICAgIHZhciBjID0gTWF0aC5jb3MoYSk7XG4gICAgICB2YXIgcyA9IE1hdGguc2luKGEpO1xuXG4gICAgICB0aGlzLm11bChcbiAgICAgICAgYywgLXMsICAwLCAgMCxcbiAgICAgICAgcywgIGMsICAwLCAgMCxcbiAgICAgICAgMCwgIDAsICAxLCAgMCxcbiAgICAgICAgMCwgIDAsICAwLCAgMSk7XG4gICAgfSxcblxuICAgIGZ1bmN0aW9uIHJvdGF0ZSh4LCB5LCB6LCByKSB7XG4gICAgICB2YXIgZCA9IE1hdGguc3FydCh4KnggKyB5KnkgKyB6KnopO1xuICAgICAgeCAvPSBkO1xuICAgICAgeSAvPSBkO1xuICAgICAgeiAvPSBkO1xuXG4gICAgICB2YXIgY29zID0gTWF0aC5jb3Mocik7XG4gICAgICB2YXIgc2luID0gTWF0aC5zaW4ocik7XG5cbiAgICAgIHRoaXMubXVsKFxuICAgICAgICBjb3MgKyB4KngqKDEgLSBjb3MpLCAgICAgeCp5KigxIC0gY29zKSAtIHoqc2luLCAgIHgqeiooMSAtIGNvcykgKyB5KnNpbiwgIDAsXG4gICAgICAgIHkqeCooMSAtIGNvcykgKyB6KnNpbiwgICBjb3MgKyB5KnkqKDEtY29zKSwgICAgICAgeSp6KigxIC0gY29zKSAtIHgqc2luLCAgMCxcbiAgICAgICAgeip4KigxIC0gY29zKSAtIHkqc2luLCAgIHoqeSooMSAtIGNvcykgKyB4KnNpbiwgICBjb3MgKyB6KnoqKDEgLSBjb3MpLCAgICAwLFxuICAgICAgICAwLCAgICAgICAgICAgICAgICAgICAgICAgMCwgICAgICAgICAgICAgICAgICAgICAgIDAsICAgICAgICAgICAgICAgICAgICAgIDEpO1xuXG4gICAgfVxuICBdXG59KTtcblxuXG5mb2FtLkNMQVNTKHtcbiAgcGFja2FnZTogJ2ZvYW0uZ3JhcGhpY3MnLFxuICBuYW1lOiAnQ1ZpZXcnLFxuXG4gIGRvY3VtZW50YXRpb246ICdBIENhbnZhcy1WaWV3OyBiYXNlLWNsYXNzIGZvciBhbGwgZ3JhcGhpY2FsIHZpZXcgY29tcG9uZW50cy4nLFxuXG4gIHJlcXVpcmVzOiBbXG4gICAgJ2ZvYW0uZ3JhcGhpY3MuQ2FudmFzJyxcbiAgICAnZm9hbS5ncmFwaGljcy5UcmFuc2Zvcm0nXG4gIF0sXG5cbiAgLy8gRmlyZXMgd2hlbiB0aGlzIENWaWV3IGlzIGludmFsaWRhdGVkIGFuZCBuZWVkcyBhIHJlcGFpbnQuXG4gIC8vIElzIGxpc3RlbmVkIHRvIGEgZm9hbS51Mi5DYW52YXMoKSBpZiBvbmUgd2FzIGNyZWF0ZWQgZm9yXG4gIC8vIHRoaXMgQ1ZpZXcuXG4gIHRvcGljczogWyAnaW52YWxpZGF0ZWQnIF0sXG5cbiAgcHJvcGVydGllczogW1xuICAgIHtcbiAgICAgIGNsYXNzOiAnRmxvYXQnLFxuICAgICAgbmFtZTogJ3dpZHRoJ1xuICAgIH0sXG4gICAge1xuICAgICAgY2xhc3M6ICdGbG9hdCcsXG4gICAgICBuYW1lOiAnaGVpZ2h0J1xuICAgIH0sXG4gICAge1xuICAgICAgY2xhc3M6ICdGbG9hdCcsXG4gICAgICBuYW1lOiAncm90YXRpb24nLFxuICAgICAgcHJlU2V0OiBmdW5jdGlvbihfLCByKSB7XG4gICAgICAgIGlmICggciA+IDIgKiBNYXRoLlBJICApIHJldHVybiByIC0gMiAqIE1hdGguUEk7XG4gICAgICAgIGlmICggciA8IC0yICogTWF0aC5QSSApIHJldHVybiByICsgMiAqIE1hdGguUEk7XG4gICAgICAgIHJldHVybiByO1xuICAgICAgfSxcbiAgICAgIHZpZXc6IHtcbiAgICAgICAgY2xhc3M6ICdmb2FtLnUyLnZpZXcuRHVhbFZpZXcnLFxuICAgICAgICB2aWV3YTogeyBjbGFzczogJ2ZvYW0udTIuRmxvYXRWaWV3JywgcHJlY2lzaW9uOiA0LCBvbktleTogdHJ1ZSB9LFxuICAgICAgICB2aWV3YjogeyBjbGFzczogJ2ZvYW0udTIuUmFuZ2VWaWV3Jywgc3RlcDogMC4wMDAwMSwgbWluVmFsdWU6IC1NYXRoLlBJKjIsIG1heFZhbHVlOiBNYXRoLlBJKjIsIG9uS2V5OiB0cnVlIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIHtcbiAgICAgIG5hbWU6ICdvcmlnaW5YJyxcbiAgICAgIGNsYXNzOiAnRmxvYXQnXG4gICAgfSxcbiAgICB7XG4gICAgICBuYW1lOiAnb3JpZ2luWScsXG4gICAgICBjbGFzczogJ0Zsb2F0J1xuICAgIH0sXG4gICAge1xuICAgICAgbmFtZTogJ3NjYWxlWCcsXG4gICAgICBjbGFzczogJ0Zsb2F0JyxcbiAgICAgIHZhbHVlOiAxXG4gICAgfSxcbiAgICB7XG4gICAgICBuYW1lOiAnc2NhbGVZJyxcbiAgICAgIGNsYXNzOiAnRmxvYXQnLFxuICAgICAgdmFsdWU6IDFcbiAgICB9LFxuICAgIHtcbiAgICAgIG5hbWU6ICdza2V3WCcsXG4gICAgICBjbGFzczogJ0Zsb2F0JyxcbiAgICAgIGhpZGRlbjogdHJ1ZVxuICAgIH0sXG4gICAge1xuICAgICAgbmFtZTogJ3NrZXdZJyxcbiAgICAgIGNsYXNzOiAnRmxvYXQnLFxuICAgICAgaGlkZGVuOiB0cnVlXG4gICAgfSxcbiAgICB7XG4gICAgICBuYW1lOiAneCcsXG4gICAgICBjbGFzczogJ0Zsb2F0J1xuICAgIH0sXG4gICAge1xuICAgICAgbmFtZTogJ3knLFxuICAgICAgY2xhc3M6ICdGbG9hdCdcbiAgICB9LFxuICAgIHtcbiAgICAgIG5hbWU6ICdhbHBoYScsXG4gICAgICBjbGFzczogJ0Zsb2F0JyxcbiAgICAgIHZpZXc6IHtcbiAgICAgICAgY2xhc3M6ICdmb2FtLnUyLnZpZXcuRHVhbFZpZXcnLFxuICAgICAgICB2aWV3YTogeyBjbGFzczogJ2ZvYW0udTIuRmxvYXRWaWV3JywgcHJlY2lzaW9uOiA0LCBvbktleTogdHJ1ZSB9LFxuICAgICAgICB2aWV3YjogeyBjbGFzczogJ2ZvYW0udTIuUmFuZ2VWaWV3Jywgc3RlcDogMC4wMDAxLCBtYXhWYWx1ZTogMSwgb25LZXk6IHRydWUgfVxuICAgICAgfSxcbiAgICAgIHZhbHVlOiAxXG4gICAgfSxcbiAgICB7XG4gICAgICBjbGFzczogJ0NvbG9yJyxcbiAgICAgIG5hbWU6ICdib3JkZXInXG4gICAgfSxcbiAgICB7XG4gICAgICBjbGFzczogJ0NvbG9yJyxcbiAgICAgIG5hbWU6ICdjb2xvcidcbiAgICB9LFxuICAgIHtcbiAgICAgIGNsYXNzOiAnQ29sb3InLFxuICAgICAgbmFtZTogJ3NoYWRvd0NvbG9yJ1xuICAgIH0sXG4gICAge1xuICAgICAgY2xhc3M6ICdJbnQnLFxuICAgICAgbmFtZTogJ3NoYWRvd0JsdXInLFxuICAgICAgdW5pdHM6ICdwaXhlbHMnXG4gICAgfSxcbiAgICB7XG4gICAgICBuYW1lOiAnY2hpbGRyZW4nLFxuICAgICAgZmFjdG9yeTogZnVuY3Rpb24oKSB7IHJldHVybiBbXTsgfSxcbiAgICAgIHBvc3RTZXQ6IGZ1bmN0aW9uKG8sIG4pIHtcbiAgICAgICAgZm9yICggdmFyIGkgPSAwIDsgbyAmJiBpIDwgby5sZW5ndGggOyBpKysgKSB0aGlzLnJlbW92ZUNoaWxkXyhvW2ldKTtcbiAgICAgICAgZm9yICggdmFyIGkgPSAwIDsgbiAmJiBpIDwgbi5sZW5ndGggOyBpKysgKSB0aGlzLmFkZENoaWxkXyhuW2ldKTtcbiAgICAgIH0sXG4gICAgICBoaWRkZW46IHRydWVcbiAgICB9LFxuICAgIHtcbiAgICAgIG5hbWU6ICdzdGF0ZScsXG4gICAgICB2YWx1ZTogJ2luaXRpYWwnLFxuICAgICAgaGlkZGVuOiAndHJ1ZScsXG4gICAgICB0cmFuc2llbnQ6IHRydWVcbiAgICB9LFxuICAgIHtcbiAgICAgIG5hbWU6ICdwYXJlbnQnLFxuICAgICAgaGlkZGVuOiAndHJ1ZScsXG4gICAgICB0cmFuc2llbnQ6IHRydWVcbiAgICB9LFxuICAgIHtcbiAgICAgIG5hbWU6ICdjYW52YXMnLFxuICAgICAgaGlkZGVuOiAndHJ1ZScsXG4gICAgICB0cmFuc2llbnQ6IHRydWVcbiAgICB9LFxuICAgIHtcbiAgICAgIG5hbWU6ICd0cmFuc2Zvcm1fJyxcbiAgICAgIGhpZGRlbjogJ3RydWUnLFxuICAgICAgdHJhbnNpZW50OiB0cnVlLFxuICAgICAgZmFjdG9yeTogZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLlRyYW5zZm9ybS5jcmVhdGUoKTsgfVxuICAgIH0sXG4gICAge1xuICAgICAgbmFtZTogJ3RyYW5zZm9ybScsXG4gICAgICBoaWRkZW46ICd0cnVlJyxcbiAgICAgIGV4cHJlc3Npb246IGZ1bmN0aW9uIGdldFRyYW5zZm9ybSh4LCBvcmlnaW5YLCB5LCBvcmlnaW5ZLCByb3RhdGlvbiwgc2tld1gsIHNrZXdZLCBzY2FsZVgsIHNjYWxlWSkge1xuICAgICAgICB2YXIgdCA9IHRoaXMudHJhbnNmb3JtXy5yZXNldCgpO1xuXG4gICAgICAgIHQudHJhbnNsYXRlKHgrb3JpZ2luWCwgeStvcmlnaW5ZKTtcbiAgICAgICAgdC5yb3RhdGUocm90YXRpb24pO1xuICAgICAgICB0LnNrZXcoc2tld1gsIHNrZXdZKTtcbiAgICAgICAgdC5zY2FsZShzY2FsZVgsIHNjYWxlWSk7XG4gICAgICAgIHQudHJhbnNsYXRlKC1vcmlnaW5YLCAtb3JpZ2luWSk7XG5cbiAgICAgICAgcmV0dXJuIHQ7XG4gICAgICB9XG4gICAgfSxcbiAgICB7XG4gICAgICAvLyBJZiBzZXQgdG8gdHJ1ZSwgdGhlbiB0aGlzIENWaWV3IHdpbGwgYXV0b21hdGljYWxseSByZXBhaW50XG4gICAgICAvLyB3aGVuZXZlciBhIGNoaWxkIGlzIGFkZGVkIG9yIHJlbW92ZWQsIGEgcHJvcGVydHkgY2hhbmdlcywgb3JcbiAgICAgIC8vIGEgcHJvcGVydHkgb2YgYSBjaGlsZCBjaGFuZ2VzLiBPbmx5IHdvcmtzIGlmIHRoaXMgQ1ZpZXcgaGFzXG4gICAgICAvLyBhbiBhc3NvY2lhdGVkIENhbnZhcyAoYnkgY2FsbGluZyB0b0UoKSkuXG4gICAgICBjbGFzczogJ0Jvb2xlYW4nLFxuICAgICAgbmFtZTogJ2F1dG9SZXBhaW50JyxcbiAgICAgIGhpZGRlbjogdHJ1ZSxcbiAgICAgIHZhbHVlOiB0cnVlXG4gICAgfSxcbiAgICB7IG5hbWU6ICd0b3BfJywgICAgaGlkZGVuOiB0cnVlLCB0cmFuc2llbnQ6IHRydWUsIGdldHRlcjogZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLnk7IH0gfSxcbiAgICB7IG5hbWU6ICdsZWZ0XycsICAgaGlkZGVuOiB0cnVlLCB0cmFuc2llbnQ6IHRydWUsIGdldHRlcjogZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLng7IH0gfSxcbiAgICB7IG5hbWU6ICdib3R0b21fJywgaGlkZGVuOiB0cnVlLCB0cmFuc2llbnQ6IHRydWUsIGdldHRlcjogZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLnkrdGhpcy5oZWlnaHQ7IH0gfSxcbiAgICB7IG5hbWU6ICdyaWdodF8nLCAgaGlkZGVuOiB0cnVlLCB0cmFuc2llbnQ6IHRydWUsIGdldHRlcjogZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLngrdGhpcy53aWR0aDsgfSB9LFxuICAgIHtcbiAgICAgIG5hbWU6ICdpbnZhbGlkYXRlXycsXG4gICAgICB0cmFuc2llbnQ6IHRydWUsXG4gICAgICBoaWRkZW46IHRydWUsXG4gICAgICAvLyBUT0RPOiBXb3VsZCBiZSBtb3JlIGVmZmljaWVudCB0byBiZSBhIGZhY3RvcnksIGJ1dCBkb2Vzbid0IHdvcmsuIEludmVzdGlnYXRlLlxuICAgICAgZ2V0dGVyOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyZW50ID8gdGhpcy5wYXJlbnQuaW52YWxpZGF0ZV8gOlxuICAgICAgICAgIHRoaXMuYXV0b1JlcGFpbnQgPyB0aGlzLmludmFsaWRhdGVkLnB1YiAgICA6XG4gICAgICAgICAgbnVsbCA7XG4gICAgICB9XG4gICAgfVxuICBdLFxuXG4gIG1ldGhvZHM6IFtcbiAgICBmdW5jdGlvbiBpbml0Q1ZpZXcoKSB7XG4gICAgICB0aGlzLmludmFsaWRhdGVfICYmIHRoaXMucHJvcGVydHlDaGFuZ2Uuc3ViKHRoaXMuaW52YWxpZGF0ZV8pO1xuICAgIH0sXG5cbiAgICBmdW5jdGlvbiBpbnZhbGlkYXRlKCkge1xuICAgICAgdGhpcy5pbnZhbGlkYXRlXyAmJiB0aGlzLmludmFsaWRhdGVfKCk7XG4gICAgfSxcblxuICAgIGZ1bmN0aW9uIHBhcmVudFRvTG9jYWxDb29yZGluYXRlcyhwKSB7XG4gICAgICB0aGlzLnRyYW5zZm9ybS5pbnZlcnQoKS5tdWxQKHApO1xuICAgICAgcC54IC89IHAudztcbiAgICAgIHAueSAvPSBwLnc7XG4gICAgICBwLncgPSAxO1xuICAgIH0sXG5cbiAgICBmdW5jdGlvbiBnbG9iYWxUb0xvY2FsQ29vcmRpbmF0ZXMocCkge1xuICAgICAgaWYgKCB0aGlzLnBhcmVudCApIHRoaXMucGFyZW50Lmdsb2JhbFRvTG9jYWxDb29yZGluYXRlcyhwKTtcbiAgICAgIHRoaXMucGFyZW50VG9Mb2NhbENvb3JkaW5hdGVzKHApO1xuICAgIH0sXG5cbiAgICBmdW5jdGlvbiBmaW5kRmlyc3RDaGlsZEF0KHApIHtcbiAgICAgIGlmICggYXJndW1lbnRzLmxlbmd0aCA+IDEgKSB7XG4gICAgICAgIHZhciB0bXAgPSBmb2FtLmdyYXBoaWNzLlBvaW50LmNyZWF0ZSgpO1xuICAgICAgICB0bXAueCA9IGFyZ3VtZW50c1swXTtcbiAgICAgICAgdG1wLnkgPSBhcmd1bWVudHNbMV07XG4gICAgICAgIHRtcC53ID0gMTtcbiAgICAgICAgcCA9IHRtcDtcbiAgICAgIH1cblxuICAgICAgdGhpcy5wYXJlbnRUb0xvY2FsQ29vcmRpbmF0ZXMocCk7XG5cbiAgICAgIGlmICggdGhpcy5jaGlsZHJlbi5sZW5ndGggKSB7XG4gICAgICAgIHZhciBwMiA9IGZvYW0uZ3JhcGhpY3MuUG9pbnQuY3JlYXRlKCk7XG5cbiAgICAgICAgZm9yICggdmFyIGkgPSAwIDsgaSA8IHRoaXMuY2hpbGRyZW4ubGVuZ3RoIDsgaSsrICkge1xuICAgICAgICAgIHAyLnggPSBwLng7XG4gICAgICAgICAgcDIueSA9IHAueTtcbiAgICAgICAgICBwMi53ID0gcC53O1xuXG4gICAgICAgICAgdmFyIGMgPSB0aGlzLmNoaWxkcmVuW2ldLmZpbmRGaXJzdENoaWxkQXQocDIpO1xuICAgICAgICAgIGlmICggYyApIHJldHVybiBjO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICggdGhpcy5oaXRUZXN0KHApICkgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8vIHAgbXVzdCBiZSBpbiBsb2NhbCBjb29yZGluYXRlcy5cbiAgICBmdW5jdGlvbiBoaXRUZXN0KHApIHtcbiAgICAgIHJldHVybiBwLnggPj0gMCAmJiBwLnkgPj0gMCAmJiBwLnggPCB0aGlzLndpZHRoICYmIHAueSA8IHRoaXMuaGVpZ2h0O1xuICAgIH0sXG5cbiAgICBmdW5jdGlvbiBtYXliZUluaXRDVmlldyh4KSB7XG4gICAgICBpZiAoIHRoaXMuc3RhdGUgPT09ICdpbml0aWFsJyApIHtcbiAgICAgICAgdGhpcy5zdGF0ZSA9ICdpbml0YWlsaXplZCdcbiAgICAgICAgdGhpcy5pbml0Q1ZpZXcoeCk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIGZ1bmN0aW9uIHBhaW50KHgpIHtcbiAgICAgIHRoaXMubWF5YmVJbml0Q1ZpZXcoeCk7XG5cbiAgICAgIHguc2F2ZSgpO1xuXG4gICAgICB2YXJcbiAgICAgICAgYWxwaGEgICAgICAgPSB0aGlzLmFscGhhLFxuICAgICAgICBib3JkZXIgICAgICA9IHRoaXMuYm9yZGVyLFxuICAgICAgICBjb2xvciAgICAgICA9IHRoaXMuY29sb3IsXG4gICAgICAgIHNoYWRvd0NvbG9yID0gdGhpcy5zaGFkb3dDb2xvcixcbiAgICAgICAgc2hhZG93Qmx1ciAgPSB0aGlzLnNoYWRvd0JsdXI7XG5cbiAgICAgIGlmICggYWxwaGEgIT09IDEgKSB7XG4gICAgICAgIHguZ2xvYmFsQWxwaGEgKj0gYWxwaGE7XG4gICAgICB9XG5cbiAgICAgIGlmICggYm9yZGVyICkge1xuICAgICAgICB4LnN0cm9rZVN0eWxlID0gYm9yZGVyLnRvQ2FudmFzU3R5bGUgP1xuICAgICAgICAgIGJvcmRlci50b0NhbnZhc1N0eWxlKHgpIDpcbiAgICAgICAgICBib3JkZXIgO1xuICAgICAgfVxuXG4gICAgICBpZiAoIGNvbG9yICkge1xuICAgICAgICB4LmZpbGxTdHlsZSA9IGNvbG9yLnRvQ2FudmFzU3R5bGUgP1xuICAgICAgICAgIGNvbG9yLnRvQ2FudmFzU3R5bGUoeCkgOlxuICAgICAgICAgIGNvbG9yIDtcbiAgICAgIH1cblxuICAgICAgdGhpcy5kb1RyYW5zZm9ybSh4KTtcblxuICAgICAgaWYgKCBzaGFkb3dDb2xvciAmJiBzaGFkb3dCbHVyICkge1xuICAgICAgICB4LnNoYWRvd0NvbG9yID0gc2hhZG93Q29sb3I7XG4gICAgICAgIHguc2hhZG93Qmx1ciAgPSBzaGFkb3dCbHVyO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnBhaW50U2VsZih4KTtcbiAgICAgIHRoaXMucGFpbnRDaGlsZHJlbih4KTtcblxuICAgICAgeC5yZXN0b3JlKCk7XG4gICAgfSxcblxuICAgIGZ1bmN0aW9uIGRvVHJhbnNmb3JtKHgpIHtcbiAgICAgIHZhciB0ID0gdGhpcy50cmFuc2Zvcm07XG4gICAgICB4LnRyYW5zZm9ybSh0LmEsIHQuZCwgdC5iLCB0LmUsIHQuYywgdC5mKTtcbiAgICB9LFxuXG4gICAgZnVuY3Rpb24gcGFpbnRDaGlsZHJlbih4KSB7XG4gICAgICBmb3IgKCB2YXIgaSA9IDAgOyBpIDwgdGhpcy5jaGlsZHJlbi5sZW5ndGggOyBpKysgKSB7XG4gICAgICAgIHRoaXMuY2hpbGRyZW5baV0ucGFpbnQoeCk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIGZ1bmN0aW9uIHJlbW92ZShjKSB7XG4gICAgICBmb3IgKCB2YXIgaSA9IDAgOyBpIDwgdGhpcy5jaGlsZHJlbi5sZW5ndGggOyBpKysgKSB7XG4gICAgICAgIGlmICggdGhpcy5jaGlsZHJlbltpXSA9PT0gYyApIHtcbiAgICAgICAgICB0aGlzLmNoaWxkcmVuLnNwbGljZShpLCAxKTtcbiAgICAgICAgICB0aGlzLnJlbW92ZUNoaWxkXyhjKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgZnVuY3Rpb24gcmVtb3ZlQWxsQ2hpbGRyZW4oKSB7XG4gICAgICB2YXIgY2hpbGRyZW4gPSB0aGlzLmNoaWxkcmVuO1xuICAgICAgdGhpcy5jaGlsZHJlbiA9IFtdO1xuICAgICAgZm9yICggdmFyIGkgPSAwIDsgaSA8IGNoaWxkcmVuLmxlbmd0aCA7IGkrKyApIHtcbiAgICAgICAgdGhpcy5yZW1vdmVDaGlsZF8oY2hpbGRyZW5baV0pO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBmdW5jdGlvbiByZW1vdmVDaGlsZChjKSB7XG4gICAgICBjb25zb2xlLmxvZygnRGVwcmVjYXRlZCB1c2Ugb2YgQ1ZpZXcucmVtb3ZlQ2hpbGQoKS4gVXNlIC5yZW1vdmUoKSBpbnN0ZWFkLicpO1xuICAgICAgdGhpcy5yZW1vdmUoYyk7XG4gICAgfSxcblxuICAgIGZ1bmN0aW9uIGFkZENoaWxkXyhjKSB7XG4gICAgICBjLnBhcmVudCA9IHRoaXM7XG4gICAgICBjLmNhbnZhcyA9IHRoaXMuY2FudmFzO1xuICAgICAgcmV0dXJuIGM7XG4gICAgfSxcblxuICAgIGZ1bmN0aW9uIHJlbW92ZUNoaWxkXyhjKSB7XG4gICAgICBjLnBhcmVudCA9IHVuZGVmaW5lZDtcbiAgICAgIGMuY2FudmFzID0gdW5kZWZpbmVkO1xuICAgICAgdGhpcy5pbnZhbGlkYXRlKCk7XG4gICAgICByZXR1cm4gYztcbiAgICB9LFxuXG4gICAgZnVuY3Rpb24gYWRkKCkge1xuICAgICAgZm9yICggdmFyIGkgPSAwIDsgaSA8IGFyZ3VtZW50cy5sZW5ndGggOyBpKysgKSB7XG4gICAgICAgIHRoaXMuY2hpbGRyZW4ucHVzaChhcmd1bWVudHNbaV0pO1xuICAgICAgICB0aGlzLmFkZENoaWxkXyhhcmd1bWVudHNbaV0pO1xuICAgICAgfVxuICAgICAgdGhpcy5pbnZhbGlkYXRlKCk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgZnVuY3Rpb24gYWRkQ2hpbGRyZW4oKSB7XG4gICAgICBjb25zb2xlLndhcm4oJ0RlcHJlY2F0ZWQgdXNlIG9mIENWaWV3LmFkZENoaWxkcmVuKCkuIFVzZSBhZGQoKSBpbnN0ZWFkLicpO1xuICAgICAgcmV0dXJuIHRoaXMuYWRkLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfSxcblxuICAgIGZ1bmN0aW9uIHBhaW50U2VsZih4KSB7fSxcblxuICAgIGZ1bmN0aW9uIGhzbChoLCBzLCBsKSB7XG4gICAgICByZXR1cm4gJ2hzbCgnICsgaCArICcsJyArIHMgKyAnJSwnICsgbCArICclKSc7XG4gICAgfSxcblxuICAgIGZ1bmN0aW9uIHdyaXRlKCkge1xuICAgICAgcmV0dXJuIHRoaXMudG9FKCkud3JpdGUoKTtcbiAgICB9LFxuXG4gICAgZnVuY3Rpb24gdG9FKGFyZ3MsIFgpIHtcbiAgICAgIHJldHVybiB0aGlzLkNhbnZhcy5jcmVhdGUoeyBjdmlldzogdGhpcyB9LCBYKS5hdHRycyh7XG4gICAgICAgIHdpZHRoOiAgdGhpcy5zbG90KGZ1bmN0aW9uKHgsIHdpZHRoLCAgc2NhbGVYKSB7IHJldHVybiB4ICsgd2lkdGgqc2NhbGVYOyB9KSxcbiAgICAgICAgaGVpZ2h0OiB0aGlzLnNsb3QoZnVuY3Rpb24oeSwgaGVpZ2h0LCBzY2FsZVkpIHsgcmV0dXJuIHkgKyBoZWlnaHQqc2NhbGVZOyB9KVxuICAgICAgfSk7XG4gICAgfSxcblxuICAgIGZ1bmN0aW9uIGludGVyc2VjdHMoYykge1xuICAgICAgaWYgKCBjLnJhZGl1cyApIHtcbiAgICAgICAgcmV0dXJuICEgKFxuICAgICAgICAgICAgdGhpcy54ICsgdGhpcy53aWR0aCAgPCBjLnggLSBjLnJhZGl1cyB8fFxuICAgICAgICAgICAgdGhpcy55ICsgdGhpcy5oZWlnaHQgPCBjLnkgLSBjLnJhZGl1cyB8fFxuICAgICAgICAgICAgYy54ICAgICsgYy5yYWRpdXMgICAgPCB0aGlzLnggICAgICAgICB8fFxuICAgICAgICAgICAgYy55ICAgICsgYy5yYWRpdXMgICAgPCB0aGlzLnkgKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiAhIChcbiAgICAgICAgICB0aGlzLnggKyB0aGlzLndpZHRoICA8IGMueCB8fFxuICAgICAgICAgIHRoaXMueSArIHRoaXMuaGVpZ2h0IDwgYy55IHx8XG4gICAgICAgICAgYy54ICAgICsgYy53aWR0aCAgPCB0aGlzLnggfHxcbiAgICAgICAgICBjLnkgICAgKyBjLmhlaWdodCA8IHRoaXMueSApO1xuICAgIH0sXG5cbiAgICBmdW5jdGlvbiBlcXVhbHMoYikgeyByZXR1cm4gdGhpcyA9PT0gYjsgfVxuICBdXG59KTtcblxuXG5mb2FtLkNMQVNTKHtcbiAgcGFja2FnZTogJ2ZvYW0uZ3JhcGhpY3MnLFxuICBuYW1lOiAnQ1ZpZXczRCcsXG5cbiAgcmVxdWlyZXM6IFtcbiAgICAnZm9hbS5ncmFwaGljcy5UcmFuc2Zvcm0zRCdcbiAgXSxcblxuICBwcm9wZXJ0aWVzOiBbXG4gICAgeyBjbGFzczogJ0Zsb2F0JywgbmFtZTogJ3gnIH0sXG4gICAgeyBjbGFzczogJ0Zsb2F0JywgbmFtZTogJ3knIH0sXG4gICAgeyBjbGFzczogJ0Zsb2F0JywgbmFtZTogJ3onIH0sXG4gICAgeyBjbGFzczogJ0Zsb2F0JywgbmFtZTogJ3JvdGF0ZVgnIH0sXG4gICAgeyBjbGFzczogJ0Zsb2F0JywgbmFtZTogJ3JvdGF0ZVknIH0sXG4gICAgeyBjbGFzczogJ0Zsb2F0JywgbmFtZTogJ3JvdGF0ZVonIH0sXG4gICAgeyBjbGFzczogJ0Zsb2F0JywgbmFtZTogJ3NjYWxlWCcsIHZhbHVlOiAxIH0sXG4gICAgeyBjbGFzczogJ0Zsb2F0JywgbmFtZTogJ3NjYWxlWScsIHZhbHVlOiAxIH0sXG4gICAgeyBjbGFzczogJ0Zsb2F0JywgbmFtZTogJ3NjYWxlWicsIHZhbHVlOiAxIH0sXG4gICAge1xuICAgICAgbmFtZTogJ3RyYW5zZm9ybV8nLFxuICAgICAgZmFjdG9yeTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLlRyYW5zZm9ybTNELmNyZWF0ZSgpO1xuICAgICAgfVxuICAgIH0sXG4gICAge1xuICAgICAgbmFtZTogJ3RyYW5zZm9ybScsXG4gICAgICBnZXR0ZXI6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgdCA9IHRoaXMudHJhbnNmb3JtXy5yZXNldCgpO1xuXG4gICAgICAgIHQudHJhbnNsYXRlKHRoaXMueCwgdGhpcy55LCB0aGlzLnopO1xuICAgICAgICB0LnJvdGF0ZVgodGhpcy5yb3RhdGVYKTtcbiAgICAgICAgdC5yb3RhdGVZKHRoaXMucm90YXRlWSk7XG4gICAgICAgIHQucm90YXRlWih0aGlzLnJvdGF0ZVopO1xuICAgICAgICB0LnNjYWxlKHRoaXMuc2NhbGVYLCB0aGlzLnNjYWxlWSwgdGhpcy5zY2FsZVopO1xuXG4gICAgICAgIHJldHVybiB0O1xuICAgICAgfVxuICAgIH1cbiAgXSxcblxuICBtZXRob2RzOiBbXG4gICAgZnVuY3Rpb24gcGFpbnQzRChnbCkge1xuICAgICAgLy8gVE9ETzogdHJhbnNmb3JtXG4gICAgICB0aGlzLnBhaW50U2VsZihnbCk7XG4gICAgfSxcblxuICAgIGZ1bmN0aW9uIHBhaW50U2VsZihnbCkge1xuICAgICAgZ2wuYmluZEJ1ZmZlcihnbC5BUlJBWV9CVUZGRVIsIHRoaXMudmVydGV4QnVmZmVyKTtcbiAgICAgIGdsLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KHRoaXMucG9zaXRpb25BdHRyaWJ1dGUpO1xuICAgICAgZ2wudmVydGV4QXR0cmliUG9pbnQodGhpcy5wb3NpdGlvbkF0dHJpYnV0ZSk7XG4gICAgICBnbC5kcmF3QXJyYXlzKHRoaXMuZHJhd1R5cGUsIDAsIHRoaXMudmVydGV4Q291bnQpO1xuICAgIH1cbiAgXVxufSk7XG5cblxuZm9hbS5DTEFTUyh7XG4gIHBhY2thZ2U6ICdmb2FtLmdyYXBoaWNzJyxcbiAgbmFtZTogJ0JveCcsXG4gIGV4dGVuZHM6ICdmb2FtLmdyYXBoaWNzLkNWaWV3JyxcblxuICBkb2N1bWVudGF0aW9uOiAnQSBDVmlldyBmb3IgZHJhd2luZyBhIHJlY3Rhbmd1bGFyIGJveC4nLFxuXG4gIHByb3BlcnRpZXM6IFtcbiAgICB7XG4gICAgICBjbGFzczogJ0Zsb2F0JyxcbiAgICAgIG5hbWU6ICd3aWR0aCdcbiAgICB9LFxuICAgIHtcbiAgICAgIGNsYXNzOiAnRmxvYXQnLFxuICAgICAgbmFtZTogJ2hlaWdodCdcbiAgICB9LFxuICAgIHtcbiAgICAgIGNsYXNzOiAnRmxvYXQnLFxuICAgICAgbmFtZTogJ2JvcmRlcldpZHRoJyxcbiAgICAgIHZhbHVlOiAxXG4gICAgfSxcbiAgICB7XG4gICAgICBuYW1lOiAnYm9yZGVyJyxcbiAgICAgIHZhbHVlOiAnIzAwMDAwMCdcbiAgICB9XG4gIF0sXG5cbiAgbWV0aG9kczogW1xuICAgIGZ1bmN0aW9uIHBhaW50U2VsZih4KSB7XG4gICAgICB4LmJlZ2luUGF0aCgpO1xuICAgICAgeC5yZWN0KDAsIDAsIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0KTtcbiAgICAgIGlmICggdGhpcy5ib3JkZXIgJiYgdGhpcy5ib3JkZXJXaWR0aCApIHtcbiAgICAgICAgeC5saW5lV2lkdGggPSB0aGlzLmJvcmRlcldpZHRoO1xuICAgICAgICB4LnN0cm9rZSgpO1xuICAgICAgfVxuICAgICAgaWYgKCB0aGlzLmNvbG9yICApIHguZmlsbCgpO1xuICAgIH1cbiAgXVxufSk7XG5cblxuZm9hbS5DTEFTUyh7XG4gIHBhY2thZ2U6ICdmb2FtLmdyYXBoaWNzJyxcbiAgbmFtZTogJ0xpbmUnLFxuICBleHRlbmRzOiAnZm9hbS5ncmFwaGljcy5DVmlldycsXG5cbiAgZG9jdW1lbnRhdGlvbjogJ0EgQ1ZpZXcgZm9yIGRyYXdpbmcgYSBsaW5lLicsXG5cbiAgcHJvcGVydGllczogW1xuICAgIHtcbiAgICAgIGNsYXNzOiAnRmxvYXQnLFxuICAgICAgbmFtZTogJ3N0YXJ0WCcsXG4gICAgICBnZXR0ZXI6IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcy54OyB9LFxuICAgICAgc2V0dGVyOiBmdW5jdGlvbih2KSB7IHRoaXMueCA9IHY7IH1cbiAgICB9LFxuICAgIHtcbiAgICAgIGNsYXNzOiAnRmxvYXQnLFxuICAgICAgbmFtZTogJ3N0YXJ0WScsXG4gICAgICBnZXR0ZXI6IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcy55OyB9LFxuICAgICAgc2V0dGVyOiBmdW5jdGlvbih2KSB7IHRoaXMueSA9IHY7IH1cbiAgICB9LFxuICAgIHsgY2xhc3M6ICdGbG9hdCcsICBuYW1lOiAnZW5kWCcgfSxcbiAgICB7IGNsYXNzOiAnRmxvYXQnLCAgbmFtZTogJ2VuZFknIH0sXG4gICAgeyBjbGFzczogJ0Zsb2F0JywgIG5hbWU6ICdsaW5lV2lkdGgnLCB2YWx1ZTogMSB9LFxuICAgIHsgY2xhc3M6ICdTdHJpbmcnLCBuYW1lOiAnY29sb3InLCAgICAgdmFsdWU6ICcjMDAwMDAwJyB9LFxuICAgIHsgbmFtZTogJ2xpbmVEYXNoJywgZG9jdW1lbnRhdGlvbjogJ0FuIEFycmF5IG9mIG51bWJlcnMgd2hpY2ggc3BlY2lmeSBkaXN0YW5jZXMgdG8gYWx0ZXJuYXRlbHkgZHJhdyBsaW5lcyBhbmQgZ2Fwcy4gRnVsbCBsaW5lIGlmIG5vdCBzZXQuJyB9LFxuICBdLFxuXG4gIG1ldGhvZHM6IFtcbiAgICBmdW5jdGlvbiBwYWludFNlbGYoeCkge1xuICAgICAgeC5iZWdpblBhdGgoKTtcbiAgICAgIGlmICggdGhpcy5saW5lRGFzaCApIHguc2V0TGluZURhc2godGhpcy5saW5lRGFzaCk7XG4gICAgICB4Lm1vdmVUbygwLCAwKTtcbiAgICAgIHgubGluZVRvKHRoaXMuZW5kWC10aGlzLngsIHRoaXMuZW5kWS10aGlzLnkpO1xuICAgICAgeC5saW5lV2lkdGggPSB0aGlzLmxpbmVXaWR0aDtcbiAgICAgIHguc3Ryb2tlU3R5bGUgPSB0aGlzLmNvbG9yO1xuICAgICAgeC5zdHJva2UoKTtcbiAgICB9LFxuXG4gICAgZnVuY3Rpb24gaGl0VGVzdChwKSB7XG4gICAgICAvLyBUaGVyZSBpcyBwcm9iYWJseSBhIGJldHRlciB3YXkgdG8gZG8gdGhpcy5cbiAgICAgIC8vIFRoaXMgY2hlY2tzIGlmIHRoZSBnaXZlbiBwb2ludCBpc1xuXG4gICAgICAvLyBBIGlzIHRoZSB2ZWN0b3IgZnJvbSB0aGUgc3RhcnQgb2YgdGhlIGxpbmUgdG8gcG9pbnQgcFxuICAgICAgdmFyIGF4ID0gcC54IC0gdGhpcy5zdGFydFg7XG4gICAgICB2YXIgYXkgPSBwLnkgLSB0aGlzLnN0YXJ0WTtcblxuICAgICAgLy8gQiBhIHZlY3RvciByZXByZXNlbnRpbmcgdGhlIGxpbmUgKGZyb20gc3RhcnQgdG8gZW5kKS5cbiAgICAgIHZhciBieCA9IHRoaXMuZW5kWCAtIHRoaXMuc3RhcnRYO1xuICAgICAgdmFyIGJ5ID0gdGhpcy5lbmRZIC0gdGhpcy5zdGFydFk7XG4gICAgICB2YXIgYmxlbiA9IE1hdGguc3FydChieCAqIGJ4ICsgYnkgKiBieSk7XG5cbiAgICAgIC8vIFByb2plY3QgQSBvbnRvIEJcbiAgICAgIHZhciBzY2FsYXJQcm9qID0gKGF4ICogYnggKyBheSAqIGJ5ICkgLyBibGVuO1xuICAgICAgdmFyIGZhY3RvciA9IHNjYWxhclByb2ogLyBibGVuO1xuICAgICAgdmFyIHByb2pYID0gYnggKiBmYWN0b3I7XG4gICAgICB2YXIgcHJvalkgPSBieSAqIGZhY3RvcjtcblxuICAgICAgLy8gQ2FsY3VsYXRlIHZlY3RvciByZWplY3Rpb24gXCJwZXJwZW5kaWN1bGFyIGRpc3RhbmNlXCJcbiAgICAgIHZhciByZWpYID0gYXggLSBwcm9qWDtcbiAgICAgIHZhciByZWpZID0gYXkgLSBwcm9qWTtcblxuICAgICAgLy8gSGl0J3MgaWYgdGhlIHBlcnBlbmRpY3VsYXIgZGlzdGFuY2UgaXMgbGVzcyB0aGFuIHNvbWUgZmFjdG9yLFxuICAgICAgLy8gYW5kIHRoZSBwb2ludCBpcyB3aXRoaW4gc29tZSBmYWN0b3Igb2YgdGhlIGxpbmUgc3RhcnQvZmluaXNoXG5cbiAgICAgIHZhciBkaXN0YW5jZSA9IE1hdGguc3FydChyZWpYICogcmVqWCArIHJlalkgKiByZWpZKTtcbiAgICAgIHZhciBwb3MgPSBzY2FsYXJQcm9qO1xuXG4gICAgICByZXR1cm4gZGlzdGFuY2UgPCA1ICYmIHBvcyA+IC01ICYmIHBvcyA8IChibGVuICsgNSlcblxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgXVxufSk7XG5cblxuZm9hbS5DTEFTUyh7XG4gIHBhY2thZ2U6ICdmb2FtLmdyYXBoaWNzJyxcbiAgbmFtZTogJ1BvbHlnb24nLFxuICBleHRlbmRzOiAnZm9hbS5ncmFwaGljcy5DVmlldycsXG5cbiAgZG9jdW1lbnRhdGlvbjogJ0EgQ1ZpZXcgZm9yIGRyYXdpbmcgYSBwb2x5Z29uLicsXG5cbiAgcHJvcGVydGllczogW1xuICAgIHsgY2xhc3M6ICdBcnJheScsIG9mOiAnRmxvYXQnLCBuYW1lOiAneENvb3JkaW5hdGVzJyB9LFxuICAgIHsgY2xhc3M6ICdBcnJheScsIG9mOiAnRmxvYXQnLCBuYW1lOiAneUNvb3JkaW5hdGVzJyB9LFxuICAgIHsgY2xhc3M6ICdTdHJpbmcnLCBuYW1lOiAnY29sb3InLCB2YWx1ZTogJyMwMDAnIH0sXG4gICAgeyBjbGFzczogJ0Zsb2F0JywgbmFtZTogJ2xpbmVXaWR0aCcsIHZhbHVlOiAxIH1cbiAgXSxcblxuICBtZXRob2RzOiBbXG4gICAgZnVuY3Rpb24gcGFpbnRTZWxmKHgpIHtcbiAgICAgIHguYmVnaW5QYXRoKCk7XG4gICAgICB4Lm1vdmVUbyh0aGlzLnhDb29yZGluYXRlc1swXSwgdGhpcy55Q29vcmRpbmF0ZXNbMF0pO1xuICAgICAgZm9yICggdmFyIGkgPSAxOyBpIDwgdGhpcy54Q29vcmRpbmF0ZXMubGVuZ3RoOyBpKysgKSB7XG4gICAgICAgIHgubGluZVRvKHRoaXMueENvb3JkaW5hdGVzW2ldLCB0aGlzLnlDb29yZGluYXRlc1tpXSk7XG4gICAgICB9XG4gICAgICB4LmxpbmVXaWR0aCA9IHRoaXMubGluZVdpZHRoO1xuICAgICAgeC5zdHJva2VTdHlsZSA9IHRoaXMuY29sb3I7XG4gICAgICB4LnN0cm9rZSgpO1xuICAgIH1cbiAgXVxufSk7XG5cblxuZm9hbS5DTEFTUyh7XG4gIHBhY2thZ2U6ICdmb2FtLmdyYXBoaWNzJyxcbiAgbmFtZTogJ0FyYycsXG4gIGV4dGVuZHM6ICdmb2FtLmdyYXBoaWNzLkNWaWV3JyxcblxuICBkb2N1bWVudGF0aW9uOiAnQSBDVmlldyBmb3IgZHJhd2luZyBhbiBhcmMuJyxcblxuICBwcm9wZXJ0aWVzOiBbXG4gICAge1xuICAgICAgbmFtZTogJ3JhZGl1cycsXG4gICAgICBjbGFzczogJ0Zsb2F0JyxcbiAgICAgIHByZVNldDogZnVuY3Rpb24oXywgcikgeyByZXR1cm4gTWF0aC5tYXgoMCwgcik7IH1cbiAgICB9LFxuICAgIHtcbiAgICAgIG5hbWU6ICdzdGFydCcsXG4gICAgICBjbGFzczogJ0Zsb2F0J1xuICAgIH0sXG4gICAge1xuICAgICAgbmFtZTogJ2VuZCcsXG4gICAgICBjbGFzczogJ0Zsb2F0J1xuICAgIH0sXG4gICAge1xuICAgICAgLy8gVE9ETzogcmVuYW1lIHRoaXNcbiAgICAgIG5hbWU6ICdhcmNXaWR0aCcsXG4gICAgICBjbGFzczogJ0Zsb2F0J1xuICAgIH0sXG4gICAge1xuICAgICAgbmFtZTogJ2JvcmRlcicsXG4gICAgICB2YWx1ZTogJyMwMDAwMDAnXG4gICAgfSxcbiAgICB7IG5hbWU6ICd0b3BfJywgICAgaGlkZGVuOiB0cnVlLCB0cmFuc2llbnQ6IHRydWUsIGdldHRlcjogZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLnktdGhpcy5yYWRpdXM7IH0gfSxcbiAgICB7IG5hbWU6ICdsZWZ0XycsICAgaGlkZGVuOiB0cnVlLCB0cmFuc2llbnQ6IHRydWUsIGdldHRlcjogZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLngtdGhpcy5yYWRpdXM7IH0gfSxcbiAgICB7IG5hbWU6ICdib3R0b21fJywgaGlkZGVuOiB0cnVlLCB0cmFuc2llbnQ6IHRydWUsIGdldHRlcjogZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLnkrdGhpcy5yYWRpdXM7IH0gfSxcbiAgICB7IG5hbWU6ICdyaWdodF8nLCAgaGlkZGVuOiB0cnVlLCB0cmFuc2llbnQ6IHRydWUsIGdldHRlcjogZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLngrdGhpcy5yYWRpdXM7IH0gfVxuICBdLFxuXG4gIG1ldGhvZHM6IFtcbiAgICBmdW5jdGlvbiBwYWludFNlbGYoeCkge1xuICAgICAgeC5iZWdpblBhdGgoKTtcbiAgICAgIHguYXJjKDAsIDAsIHRoaXMucmFkaXVzLCB0aGlzLnN0YXJ0LCB0aGlzLmVuZCk7XG5cdCAgeC5saW5lVG8oMCwwKTtcblxuICAgICAgaWYgKCB0aGlzLmNvbG9yICkgeC5maWxsKCk7XG5cbiAgICAgIGlmICggdGhpcy5ib3JkZXIgKSB7XG4gICAgICAgIHgubGluZVdpZHRoID0gdGhpcy5hcmNXaWR0aDtcbiAgICAgICAgeC5zdHJva2UoKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgZnVuY3Rpb24gdG9FKFgpIHtcbiAgICAgIHJldHVybiB0aGlzLkNhbnZhcy5jcmVhdGUoeyBjdmlldzogdGhpcyB9LCBYKS5hdHRycyh7XG4gICAgICAgIHdpZHRoOiB0aGlzLnggKyB0aGlzLnJhZGl1cyArIHRoaXMuYXJjV2lkdGgsXG4gICAgICAgIGhlaWdodDogdGhpcy55ICsgdGhpcy5yYWRpdXMgKyB0aGlzLmFyY1dpZHRoXG4gICAgICB9KTtcbiAgICB9XG4gIF1cbn0pO1xuXG5cbmZvYW0uQ0xBU1Moe1xuICBwYWNrYWdlOiAnZm9hbS5ncmFwaGljcycsXG4gIG5hbWU6ICdDaXJjbGUnLFxuICBleHRlbmRzOiAnZm9hbS5ncmFwaGljcy5BcmMnLFxuXG4gIGRvY3VtZW50YXRpb246ICdBIENWaWV3IGZvciBkcmF3aW5nIGEgQ2lyY2xlLicsXG5cbiAgcHJvcGVydGllczogW1xuICAgIHtcbiAgICAgIG5hbWU6ICdzdGFydCcsXG4gICAgICB2YWx1ZTogMCxcbiAgICAgIHZpZXc6IHtcbiAgICAgICAgY2xhc3M6ICdmb2FtLnUyLnZpZXcuRHVhbFZpZXcnLFxuICAgICAgICB2aWV3YTogeyBjbGFzczogJ2ZvYW0udTIuRmxvYXRWaWV3JywgcHJlY2lzaW9uOiA0LCBvbktleTogdHJ1ZSB9LFxuICAgICAgICB2aWV3YjogeyBjbGFzczogJ2ZvYW0udTIuUmFuZ2VWaWV3JywgbWF4VmFsdWU6IE1hdGguUEkqMiwgc3RlcDogMC4wMSwgb25LZXk6IHRydWUgfVxuICAgICAgfVxuICAgIH0sXG4gICAge1xuICAgICAgbmFtZTogJ2VuZCcsXG4gICAgICB2YWx1ZTogMipNYXRoLlBJLFxuICAgICAgdmlldzoge1xuICAgICAgICBjbGFzczogJ2ZvYW0udTIudmlldy5EdWFsVmlldycsXG4gICAgICAgIHZpZXdhOiB7IGNsYXNzOiAnZm9hbS51Mi5GbG9hdFZpZXcnLCBwcmVjaXNpb246IDQsIG9uS2V5OiB0cnVlIH0sXG4gICAgICAgIHZpZXdiOiB7IGNsYXNzOiAnZm9hbS51Mi5SYW5nZVZpZXcnLCBtYXhWYWx1ZTogTWF0aC5QSSoyLCBzdGVwOiAwLjAxLCBvbktleTogdHJ1ZSB9XG4gICAgICB9XG4gICAgfVxuICBdLFxuXG4gIG1ldGhvZHM6IFtcbiAgICBmdW5jdGlvbiBoaXRUZXN0KHApIHtcbiAgICAgIHZhciByID0gdGhpcy5yYWRpdXMgKyB0aGlzLmFyY1dpZHRoLzIgLSAxO1xuICAgICAgcmV0dXJuIHAueCpwLnggKyBwLnkqcC55IDw9IHIqcjtcbiAgICB9LFxuXG4gICAgZnVuY3Rpb24gaW50ZXJzZWN0cyhjKSB7XG4gICAgICBpZiAoICEgYy5yYWRpdXMgKSByZXR1cm4gYy5pbnRlcnNlY3RzKHRoaXMpO1xuICAgICAgdmFyIHIgPSB0aGlzLnJhZGl1cyArIGMucmFkaXVzO1xuICAgICAgaWYgKCB0aGlzLmJvcmRlciApIHIgKz0gdGhpcy5hcmNXaWR0aC8yLTE7XG4gICAgICBpZiAoIGMuYm9yZGVyICAgICkgciArPSBjLmFyY1dpZHRoLzItMTtcbiAgICAgIHZhciBkeCA9IHRoaXMueC1jLng7XG4gICAgICB2YXIgZHkgPSB0aGlzLnktYy55O1xuICAgICAgcmV0dXJuIGR4ICogZHggKyBkeSAqIGR5IDw9IHIgKiByO1xuICAgIH1cbiAgXVxufSk7XG5cblxuZm9hbS5DTEFTUyh7XG4gIHBhY2thZ2U6ICdmb2FtLmdyYXBoaWNzJyxcbiAgbmFtZTogJ0VsbGlwc2UnLFxuICBleHRlbmRzOiAnZm9hbS5ncmFwaGljcy5DVmlldycsXG5cbiAgZG9jdW1lbnRhdGlvbjogJ0EgQ1ZpZXcgZm9yIGRyYXdpbmcgYW4gZWxsaXBzZS4nLFxuXG4gIHByb3BlcnRpZXM6IFtcbiAgICB7XG4gICAgICBjbGFzczogJ0Zsb2F0JyxcbiAgICAgIG5hbWU6ICdyYWRpdXNYJyxcbiAgICAgIHByZVNldDogZnVuY3Rpb24oXywgcikgeyByZXR1cm4gTWF0aC5tYXgoMCwgcik7IH1cbiAgICB9LFxuICAgIHtcbiAgICAgIGNsYXNzOiAnRmxvYXQnLFxuICAgICAgbmFtZTogJ3JhZGl1c1knLFxuICAgICAgcHJlU2V0OiBmdW5jdGlvbihfLCByKSB7IHJldHVybiBNYXRoLm1heCgwLCByKTsgfVxuICAgIH0sXG4gICAge1xuICAgICAgbmFtZTogJ3N0YXJ0JyxcbiAgICAgIHZhbHVlOiAwLFxuICAgICAgdmlldzoge1xuICAgICAgICBjbGFzczogJ2ZvYW0udTIudmlldy5EdWFsVmlldycsXG4gICAgICAgIHZpZXdhOiB7IGNsYXNzOiAnZm9hbS51Mi5GbG9hdFZpZXcnLCBwcmVjaXNpb246IDQsIG9uS2V5OiB0cnVlIH0sXG4gICAgICAgIHZpZXdiOiB7IGNsYXNzOiAnZm9hbS51Mi5SYW5nZVZpZXcnLCBtYXhWYWx1ZTogTWF0aC5QSSoyLCBzdGVwOiAwLjAxLCBvbktleTogdHJ1ZSB9XG4gICAgICB9XG4gICAgfSxcbiAgICB7XG4gICAgICBuYW1lOiAnZW5kJyxcbiAgICAgIHZhbHVlOiAyKk1hdGguUEksXG4gICAgICB2aWV3OiB7XG4gICAgICAgIGNsYXNzOiAnZm9hbS51Mi52aWV3LkR1YWxWaWV3JyxcbiAgICAgICAgdmlld2E6IHsgY2xhc3M6ICdmb2FtLnUyLkZsb2F0VmlldycsIHByZWNpc2lvbjogNCwgb25LZXk6IHRydWUgfSxcbiAgICAgICAgdmlld2I6IHsgY2xhc3M6ICdmb2FtLnUyLlJhbmdlVmlldycsIG1heFZhbHVlOiBNYXRoLlBJKjIsIHN0ZXA6IDAuMDEsIG9uS2V5OiB0cnVlIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIHtcbiAgICAgIG5hbWU6ICdib3JkZXJXaWR0aCcsXG4gICAgICBjbGFzczogJ0Zsb2F0J1xuICAgIH0sXG4gICAge1xuICAgICAgbmFtZTogJ2JvcmRlcicsXG4gICAgICB2YWx1ZTogJyMwMDAwMDAnXG4gICAgfSxcbiAgICB7XG4gICAgICBjbGFzczogJ0Zsb2F0JyxcbiAgICAgIG5hbWU6ICd3aWR0aCcsXG4gICAgICBnZXR0ZXI6IGZ1bmN0aW9uKCkgeyByZXR1cm4gMiAqIHRoaXMucmFkaXVzWDsgfSxcbiAgICAgIHNldHRlcjogZnVuY3Rpb24odykgeyB0aGlzLnJhZGl1c1ggPSB3IC8gMjsgfVxuICAgIH0sXG4gICAge1xuICAgICAgY2xhc3M6ICdGbG9hdCcsXG4gICAgICBuYW1lOiAnaGVpZ2h0JyxcbiAgICAgIGdldHRlcjogZnVuY3Rpb24oKSB7IHJldHVybiAyICogdGhpcy5yYWRpdXNZOyB9LFxuICAgICAgc2V0dGVyOiBmdW5jdGlvbihoKSB7IHRoaXMucmFkaXVzWSA9IGggLyAyOyB9XG4gICAgfSxcbiAgICB7IG5hbWU6ICd0b3BfJywgICAgaGlkZGVuOiB0cnVlLCB0cmFuc2llbnQ6IHRydWUsIGdldHRlcjogZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLnk7IH0gfSxcbiAgICB7IG5hbWU6ICdsZWZ0XycsICAgaGlkZGVuOiB0cnVlLCB0cmFuc2llbnQ6IHRydWUsIGdldHRlcjogZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLng7IH0gfSxcbiAgICB7IG5hbWU6ICdib3R0b21fJywgaGlkZGVuOiB0cnVlLCB0cmFuc2llbnQ6IHRydWUsIGdldHRlcjogZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLnkrMip0aGlzLnJhZGl1c1k7IH0gfSxcbiAgICB7IG5hbWU6ICdyaWdodF8nLCAgaGlkZGVuOiB0cnVlLCB0cmFuc2llbnQ6IHRydWUsIGdldHRlcjogZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLngrMip0aGlzLnJhZGl1c1g7IH0gfSxcbiAgXSxcblxuICBtZXRob2RzOiBbXG4gICAgZnVuY3Rpb24gcGFpbnRTZWxmKHgpIHtcbiAgICAgIHguYmVnaW5QYXRoKCk7XG4gICAgICB4LmVsbGlwc2UodGhpcy5yYWRpdXNYLCB0aGlzLnJhZGl1c1ksIHRoaXMucmFkaXVzWCwgdGhpcy5yYWRpdXNZLCAwLCB0aGlzLnN0YXJ0LCB0aGlzLmVuZCk7XG5cbiAgICAgIGlmICggdGhpcy5jb2xvciApIHguZmlsbCgpO1xuXG4gICAgICBpZiAoIHRoaXMuYm9yZGVyICkge1xuICAgICAgICB4LmxpbmVXaWR0aCA9IHRoaXMuYm9yZGVyV2lkdGg7XG4gICAgICAgIHguc3Ryb2tlKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gVE9ETzogaW1wbGVtZW50IGludGVyc2VjdHMoKVxuICBdXG59KTtcblxuXG5mb2FtLkNMQVNTKHtcbiAgcGFja2FnZTogJ2ZvYW0uZ3JhcGhpY3MnLFxuICBuYW1lOiAnUG9pbnQnLFxuXG4gIC8vIFRPRE86IHdoZXJlL2hvdyBpcyB0aGlzIHVzZWQ/XG4gIC8vIGRvY3VtZW50YXRpb246ICcnLFxuXG4gIHByb3BlcnRpZXM6IFtcbiAgICB7XG4gICAgICBjbGFzczogJ1NpbXBsZScsXG4gICAgICBuYW1lOiAneCdcbiAgICB9LFxuICAgIHtcbiAgICAgIGNsYXNzOiAnU2ltcGxlJyxcbiAgICAgIG5hbWU6ICd5J1xuICAgIH0sXG4gICAge1xuICAgICAgY2xhc3M6ICdTaW1wbGUnLFxuICAgICAgbmFtZTogJ3cnXG4gICAgfVxuICBdLFxuXG4gIG1ldGhvZHM6IFtcbiAgICBmdW5jdGlvbiBjbG9uZSgpIHtcbiAgICAgIHZhciBwID0gdGhpcy5jbHNfLmNyZWF0ZSgpO1xuICAgICAgcC54ID0gdGhpcy54O1xuICAgICAgcC55ID0gdGhpcy55O1xuICAgICAgcC53ID0gdGhpcy53O1xuICAgICAgcmV0dXJuIHA7XG4gICAgfSxcblxuICAgIGZ1bmN0aW9uIHRvQ2FydGVzaWFuKCkge1xuICAgICAgLy8gVE9ETzogV2hhdCBpcyB0aGUgcmlnaHQgbmFtZSBmb3IgdGhpcyBmdW5jdGlvbj9cbiAgICAgIC8vIEl0J3MgcmVsYXRlZCB0byBwZXJzcGVjdGl2ZSB0cmFuc2Zvcm1hdGlvbnNcbiAgICAgIC8vIEl0IHRyYW5zZm9ybXMgdGhpcyBwb2ludCBmcm9tIHRoZSBob21vZ2VuZW91cyBjb29yZGluYXRlIHNwYWNlXG4gICAgICAvLyB0byB0aGUgY2FydGVzaWFuIGNvb3JkaWF0ZSBzcGFjZS5cblxuICAgICAgdGhpcy54ID0gdGhpcy54IC8gdGhpcy53O1xuICAgICAgdGhpcy55ID0gdGhpcy55IC8gdGhpcy53O1xuICAgICAgdGhpcy53ID0gMTtcbiAgICB9XG4gIF1cbn0pO1xuXG5cbmZvYW0uQ0xBU1Moe1xuICBwYWNrYWdlOiAnZm9hbS5ncmFwaGljcycsXG4gIG5hbWU6ICdDYW52YXMnLFxuICBleHRlbmRzOiAnZm9hbS51Mi5FbGVtZW50JyxcblxuICBkb2N1bWVudGF0aW9uOiAnQSBDYW52YXMgVTIgRWxlbWVudCBmb3IgZHJhd2luZyBDVmlld3MgaW4uIERvblxcJ3QgY3JlYXRlIGRpcmVjdGx5LCB1c2UgQ1ZpZXcudG9FKCkgaW5zdGVhZC4nLFxuXG4gIHJlcXVpcmVzOiBbXG4gICAgJ2ZvYW0uaW5wdXQuUG9pbnRlcidcbiAgXSxcblxuICBwcm9wZXJ0aWVzOiBbXG4gICAgWyAnbm9kZU5hbWUnLCAnQ0FOVkFTJyBdLFxuICAgIHtcbiAgICAgIG5hbWU6ICdjb250ZXh0JyxcbiAgICAgIGZhY3Rvcnk6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5lbCgpLmdldENvbnRleHQoJzJkJyk7XG4gICAgICB9XG4gICAgfSxcbiAgICB7XG4gICAgICBuYW1lOiAnY29udGV4dDNEJyxcbiAgICAgIGZhY3Rvcnk6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5lbCgpLmdldENvbnRleHQoJ3dlYmdsJyk7XG4gICAgICB9XG4gICAgfSxcbiAgICB7XG4gICAgICBuYW1lOiAnY3ZpZXcnLFxuICAgICAgcG9zdFNldDogZnVuY3Rpb24obywgbikge1xuICAgICAgICBuLmNhbnZhcyA9IHRoaXM7XG5cbiAgICAgICAgaWYgKCB0aGlzLmF0dHJpYnV0ZU1hcC53aWR0aCA9PT0gdW5kZWZpbmVkIHx8IHRoaXMuYXR0cmlidXRlTWFwLmhlaWdodCA9PT0gdW5kZWZpbmVkICkge1xuICAgICAgICAgIHRoaXMuc2V0QXR0cmlidXRlKCd3aWR0aCcsICBuLndpZHRoKTtcbiAgICAgICAgICB0aGlzLnNldEF0dHJpYnV0ZSgnaGVpZ2h0Jywgbi5oZWlnaHQpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5wYWludCgpO1xuICAgICAgfVxuICAgIH0sXG4gICAge1xuICAgICAgbmFtZTogJ3BvaW50ZXInLFxuICAgICAgZmFjdG9yeTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLlBvaW50ZXIuY3JlYXRlKHsgZWxlbWVudDogdGhpcyB9KTtcbiAgICAgIH1cbiAgICB9XG4gIF0sXG5cbiAgbWV0aG9kczogW1xuICAgIGZ1bmN0aW9uIGluaXRFKCkge1xuICAgICAgdGhpcy5TVVBFUigpO1xuICAgICAgdGhpcy5vbignbG9hZCcsIHRoaXMucGFpbnQpO1xuICAgICAgdGhpcy5jdmlldyQudmFsdWVTdWIoJ2ludmFsaWRhdGVkJywgdGhpcy5wYWludCk7XG4gICAgfSxcblxuICAgIGZ1bmN0aW9uIGVyYXNlKCkge1xuICAgICAgdGhpcy5lbCgpLndpZHRoID0gdGhpcy5lbCgpLndpZHRoO1xuICAgIH1cbiAgXSxcblxuICBsaXN0ZW5lcnM6IFtcbiAgICB7XG4gICAgICBuYW1lOiAncGFpbnQnLFxuICAgICAgaXNGcmFtZWQ6IHRydWUsXG4gICAgICBjb2RlOiBmdW5jdGlvbiBwYWludENhbnZhcygpIHtcbiAgICAgICAgLy8gT25seSBwYWludCBhZnRlciBiZWluZyBsb2FkZWRcbiAgICAgICAgaWYgKCB0aGlzLnN0YXRlICE9PSB0aGlzLkxPQURFRCB8fCAhIHRoaXMuY3ZpZXcgKSByZXR1cm47XG5cbiAgICAgICAgdmFyIGN0eCA9IHRoaXMuY3ZpZXcucGFpbnQzRCA/IHRoaXMuY29udGV4dDNEIDogdGhpcy5jb250ZXh0O1xuICAgICAgICB0aGlzLmVyYXNlKGN0eCk7XG4gICAgICAgIGlmICggdGhpcy5jdmlldy5wYWludDNEICkge1xuICAgICAgICAgIHRoaXMuY3ZpZXcucGFpbnQzRChjdHgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuY3ZpZXcucGFpbnQoY3R4KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgXVxufSk7XG5cblxuZm9hbS5DTEFTUyh7XG4gIHBhY2thZ2U6ICdmb2FtLmdyYXBoaWNzJyxcbiAgbmFtZTogJ0dyYWRpZW50JyxcblxuICAvLyBUT0RPOiB3aGVyZS9ob3cgaXMgdGhpcyB1c2VkP1xuLy8gICBkb2N1bWVudGF0aW9uOiAnJyxcblxuICBwcm9wZXJ0aWVzOiBbXG4gICAgJ3gwJywgJ3kwJywgJ3IwJyxcbiAgICAneDEnLCAneTEnLCAncjEnLFxuICAgIHtcbiAgICAgIG5hbWU6ICdyYWRpYWwnLFxuICAgICAgY2xhc3M6ICdCb29sZWFuJyxcbiAgICAgIHZhbHVlOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgbmFtZTogJ2NvbG9ycycsXG4gICAgICBmYWN0b3J5OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuICAgIH1cbiAgXSxcblxuICBtZXRob2RzOiBbXG4gICAgZnVuY3Rpb24gdG9DYW52YXNTdHlsZSh4KSB7XG4gICAgICB2YXIgdCA9IHRoaXM7XG4gICAgICB2YXIgZyA9IHRoaXMucmFkaWFsID9cbiAgICAgICAgeC5jcmVhdGVSYWRpYWxHcmFkaWVudCh0LngwLCB0LnkwLCB0LnIwLCB0LngxLCB0LnkxLCB0LnIxKSA6XG4gICAgICAgIHguY3JlYXRlTGluZWFyR3JhZGllbnQodC54MCwgdC55MCwgdC54MSwgdC55MSkgO1xuXG4gICAgICBmb3IgKCB2YXIgaSA9IDAgOyBpIDwgdC5jb2xvcnMubGVuZ3RoIDsgaSsrIClcbiAgICAgICAgZy5hZGRDb2xvclN0b3AodC5jb2xvcnNbaV1bMF0sIHQuY29sb3JzW2ldWzFdKTtcblxuICAgICAgcmV0dXJuIGc7XG4gICAgfVxuICBdXG59KTtcblxuLy8gVE9ETzogYWRkIGNvbmZpZ3VyYWJsZSByZXBhaW50IHN0cmF0ZWd5LiBFeC4gZXhwbGljaXQsIG9uIHByb3BlcnR5IGNoYW5nZSwgb24gY2hpbGQgY2hhbmdlXG5cblxuZm9hbS5DTEFTUyh7XG4gIHBhY2thZ2U6ICdmb2FtLmdyYXBoaWNzJyxcbiAgbmFtZTogICdMYWJlbCcsXG4gIGV4dGVuZHM6ICdmb2FtLmdyYXBoaWNzLkNWaWV3JyxcblxuICBkb2N1bWVudGF0aW9uOiAnQSBDVmlldyBkcmF3aW5nIHRleHQuJyxcblxuICBwcm9wZXJ0aWVzOiBbXG4gICAge1xuICAgICAgY2xhc3M6ICdTdHJpbmcnLFxuICAgICAgbmFtZTogICd0ZXh0JyxcbiAgICAgIHZpZXc6IHsgY2xhc3M6ICdmb2FtLnUyLlRleHRGaWVsZCcsIG9uS2V5OiB0cnVlIH1cbiAgICB9LFxuICAgIHtcbiAgICAgIG5hbWU6ICAnYWxpZ24nLFxuICAgICAgbGFiZWw6ICdBbGlnbm1lbnQnLFxuICAgICAgdmFsdWU6ICdzdGFydCcsXG4gICAgICB2aWV3OiB7XG4gICAgICAgIGNsYXNzOiAnZm9hbS51Mi52aWV3LlJhZGlvVmlldycsXG4gICAgICAgIGNob2ljZXM6IFsgJ3N0YXJ0JywgLyonbGVmdCcsKi8gJ2NlbnRlcicsIC8qJ3JpZ2h0JywqLyAnZW5kJyBdXG4gICAgICB9XG4gICAgfSxcbiAgICB7XG4gICAgICBjbGFzczogJ1N0cmluZycsXG4gICAgICBuYW1lOiAgJ2ZvbnQnXG4gICAgfSxcbiAgICB7XG4gICAgICBjbGFzczogJ0NvbG9yJyxcbiAgICAgIG5hbWU6ICAnY29sb3InLFxuICAgICAgdmFsdWU6ICcjMDAwMDAwJ1xuICAgIH0sXG4gICAge1xuICAgICAgY2xhc3M6ICdDb2xvcicsXG4gICAgICBuYW1lOiAnYm9yZGVyJyxcbiAgICAgIGxhYmVsOiAnQm9yZGVyIENvbG9yJ1xuICAgIH0sXG4gICAge1xuICAgICAgY2xhc3M6ICdGbG9hdCcsXG4gICAgICBuYW1lOiAgJ21heFdpZHRoJyxcbiAgICAgIGxhYmVsOiAnTWF4aW11bSBXaWR0aCcsXG4gICAgICB2YWx1ZTogLTFcbiAgICB9XG4gIF0sXG5cbiAgbWV0aG9kczogW1xuICAgIGZ1bmN0aW9uIHBhaW50U2VsZihjKSB7XG4gICAgICBpZiAoIHRoaXMuZm9udCApIGMuZm9udCA9IHRoaXMuZm9udDtcblxuICAgICAgYy50ZXh0QWxpZ24gPSB0aGlzLmFsaWduO1xuICAgICAgYy5maWxsU3R5bGUgPSB0aGlzLmNvbG9yO1xuXG4gICAgICBjLmZpbGxUZXh0KFxuICAgICAgICB0aGlzLnRleHQsXG4gICAgICAgICAgdGhpcy5hbGlnbiA9PT0gJ3N0YXJ0JyAgPyAwIDpcbiAgICAgICAgICB0aGlzLmFsaWduID09PSAnY2VudGVyJyA/IHRoaXMud2lkdGgvMiA6XG4gICAgICAgICAgdGhpcy53aWR0aCxcbiAgICAgICAgdGhpcy5oZWlnaHQvMisxMCk7XG5cbiAgICAgIGlmICggdGhpcy5ib3JkZXIgKSB7XG4gICAgICAgIGMuc3Ryb2tlU3R5bGUgPSB0aGlzLmJvcmRlcjtcbiAgICAgICAgYy5zdHJva2VSZWN0KDAsIDAsIHRoaXMud2lkdGgtMSwgdGhpcy5oZWlnaHQtMSk7XG4gICAgICB9XG4gICAgfVxuICBdXG59KTtcblxuLypcbmEgOiAxIC8vIEggc2NhbGVcbmIgOiAwIC8vIFYgc2tld1xuYyA6IDM4MjEuMTQyNDA3ODc3MzM0IC8vIEggbW92ZVxuZCA6IDAgLy8gSCBza2V3XG5lIDogMSAvLyBWIHNjYWxlXG5mIDogLTY3OTYuMTc2MjE5NjQwMzIyIC8vIFYgbW92ZVxuZyA6IDBcbmggOiAwXG5pIDogMVxuKi9cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmZvYW0uQ0xBU1Moe1xuICBwYWNrYWdlOiAnZm9hbS5ncmFwaGljcycsXG4gIG5hbWU6ICdTY3JvbGxDVmlldycsXG4gIGV4dGVuZHM6ICdmb2FtLmdyYXBoaWNzLkNWaWV3JyxcblxuICBwcm9wZXJ0aWVzOiBbXG4gICAge1xuICAgICAgY2xhc3M6ICdGbG9hdCcsXG4gICAgICBuYW1lOiAnd2lkdGgnLFxuICAgICAgdmFsdWU6IDIwXG4gICAgfSxcbiAgICB7XG4gICAgICBjbGFzczogJ0Zsb2F0JyxcbiAgICAgIG5hbWU6ICdoZWlnaHQnLFxuICAgICAgdmFsdWU6IDEwMFxuICAgIH0sXG4gICAge1xuICAgICAgY2xhc3M6ICdCb29sZWFuJyxcbiAgICAgIG5hbWU6ICd2ZXJ0aWNhbCcsXG4gICAgICB2YWx1ZTogdHJ1ZVxuICAgIH0sXG4gICAge1xuICAgICAgY2xhc3M6ICdJbnQnLFxuICAgICAgbmFtZTogJ3ZhbHVlJyxcbi8vICAgICAgaGVscDogJ1RoZSBmaXJzdCBlbGVtZW50IGJlaW5nIHNob3duLCBzdGFydGluZyBhdCB6ZXJvLicsXG4gICAgICBwcmVTZXQ6IGZ1bmN0aW9uKF8sIHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBNYXRoLm1heCgwLCBNYXRoLm1pbih0aGlzLnNpemUtdGhpcy5leHRlbnQsIHZhbHVlKSk7XG4gICAgICB9LFxuICAgICAgcG9zdFNldDogZnVuY3Rpb24ob2xkLCBudSkge1xuICAgICAgICBpZiAoIG9sZCAhPT0gbnUgKSB0aGlzLmludmFsaWRhdGVkLnB1YigpO1xuICAgICAgfVxuICAgIH0sXG4gICAge1xuICAgICAgY2xhc3M6ICdJbnQnLFxuICAgICAgbmFtZTogJ2V4dGVudCcsXG4vLyAgICAgIGhlbHA6ICdOdW1iZXIgb2YgZWxlbWVudHMgc2hvd24uJyxcbi8vICAgICAgbWluVmFsdWU6IDEsIC8vIFRPRE86IGFkZCBiYWNrIHdoZW4gbWluVmFsdWUgc3VwcG9ydGVkXG4gICAgICB2YWx1ZTogMTAsXG4gICAgICBwb3N0U2V0OiBmdW5jdGlvbihvbGQsIG51KSB7XG4gICAgICAgIGlmICggb2xkICE9PSBudSApIHRoaXMuaW52YWxpZGF0ZWQucHViKCk7XG4gICAgICB9XG4gICAgfSxcbiAgICB7XG4gICAgICBjbGFzczogJ0ludCcsXG4gICAgICBuYW1lOiAnc2l6ZScsXG4vLyAgICAgIGhlbHA6ICdUb3RhbCBudW1iZXIgb2YgZWxlbWVudHMgYmVpbmcgc2Nyb2xsZWQgdGhyb3VnaC4nLFxuICAgICAgdmFsdWU6IDAsXG4gICAgICBwb3N0U2V0OiBmdW5jdGlvbihvbGQsIHNpemUpIHtcbiAgICAgICAgaWYgKCBvbGQgIT09IHNpemUgKSB0aGlzLmludmFsaWRhdGVkLnB1YigpO1xuICAgICAgICAvLyBUcmlnZ2VyIHRoZSBwcmVTZXQgZm9yIHZhbHVlLCBzbyBpdCBzdGF5cyB3aXRoaW4gcmFuZ2UuXG4gICAgICAgIHRoaXMudmFsdWUgPSB0aGlzLnZhbHVlO1xuICAgICAgfVxuICAgIH0sXG4gICAge1xuICAgICAgY2xhc3M6ICdJbnQnLFxuICAgICAgbmFtZTogJ21pbkhhbmRsZVNpemUnLFxuLy8gICAgICBoZWxwOiAnTWluaW11bSBzaXplIHRvIG1ha2UgdGhlIGRyYWcgaGFuZGxlLidcbiAgICAgIHZhbHVlOiAxMFxuICAgIH0sXG4gICAge1xuICAgICAgY2xhc3M6ICdGbG9hdCcsXG4gICAgICBuYW1lOiAnaGFuZGxlU2l6ZScsXG4gICAgICBleHByZXNzaW9uOiBmdW5jdGlvbihtaW5IYW5kbGVTaXplLCBzaXplLCBleHRlbnQsIGhlaWdodCwgaW5uZXJCb3JkZXIpIHtcbiAgICAgICAgdmFyIGggID0gaGVpZ2h0IC0gMiAqIGlubmVyQm9yZGVyO1xuICAgICAgICB2YXIgaHMgPSBzaXplID4gMCA/IGV4dGVudCAqIGggLyBzaXplIDogMDtcblxuICAgICAgICByZXR1cm4gaHMgPCBtaW5IYW5kbGVTaXplID8gbWluSGFuZGxlU2l6ZSA6IGhzO1xuICAgICAgfVxuICAgIH0sXG4gICAge1xuICAgICAgY2xhc3M6ICdJbnQnLFxuICAgICAgbmFtZTogJ2lubmVyQm9yZGVyJyxcbiAgICAgIHZhbHVlOiAyXG4gICAgfSxcbiAgICB7XG4gICAgICBjbGFzczogJ1N0cmluZycsXG4gICAgICBuYW1lOiAnaGFuZGxlQ29sb3InLFxuICAgICAgdmFsdWU6ICdyZ2IoMTA3LDEzNiwxNzMpJ1xuICAgIH0sXG4gICAge1xuICAgICAgY2xhc3M6ICdTdHJpbmcnLFxuICAgICAgbmFtZTogJ2JvcmRlckNvbG9yJyxcbiAgICAgIHZhbHVlOiAnIzk5OSdcbiAgICB9LFxuICAgIHtcbiAgICAgIG5hbWU6ICd5TWF4JyxcbiAgICAgIGV4cHJlc3Npb246IGZ1bmN0aW9uKGhlaWdodCwgaW5uZXJCb3JkZXIsIGhhbmRsZVNpemUpICB7XG4gICAgICAgIHJldHVybiBoZWlnaHQgLSBpbm5lckJvcmRlciAtIGhhbmRsZVNpemU7XG4gICAgICB9XG4gICAgfSxcbiAgICB7XG4gICAgICBuYW1lOiAncmF0ZScsXG4gICAgICBleHByZXNzaW9uOiBmdW5jdGlvbihzaXplLCBleHRlbnQsIHlNYXgsIGlubmVyQm9yZGVyKSB7XG4gICAgICAgIHJldHVybiBzaXplID8gKCB5TWF4IC0gaW5uZXJCb3JkZXIgKSAvIChzaXplIC0gZXh0ZW50KSA6IDA7XG4gICAgICB9XG4gICAgfSxcbiAgXSxcblxuICBtZXRob2RzOiBbXG4gICAgZnVuY3Rpb24gaW5pdENWaWV3KCkge1xuICAgICAgdGhpcy5vbkRldGFjaCh0aGlzLmNhbnZhcy5wb2ludGVyLnRvdWNoLnN1Yih0aGlzLm9uVG91Y2gpKTtcblxuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgdmFyIG1vdXNlSW5wdXQgPSB0aGlzLmNhbnZhcy5wb2ludGVyLm1vdXNlSW5wdXQ7XG4gICAgICB0aGlzLm9uRGV0YWNoKG1vdXNlSW5wdXQuZG93bi5zdWIoZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBtb3ZlU3ViID0gbW91c2VJbnB1dC5tb3ZlLnN1YihmdW5jdGlvbigpIHtcbiAgICAgICAgICBzZWxmLnZhbHVlID0gc2VsZi55VG9WYWx1ZShtb3VzZUlucHV0LnkpO1xuICAgICAgICB9KTtcbiAgICAgICAgbW91c2VJbnB1dC51cC5zdWIoZnVuY3Rpb24ocykge1xuICAgICAgICAgIG1vdmVTdWIuZGV0YWNoKCk7XG4gICAgICAgICAgcy5kZXRhY2goKTtcbiAgICAgICAgfSk7XG4gICAgICB9KSk7XG4gICAgfSxcblxuICAgIGZ1bmN0aW9uIHlUb1ZhbHVlKHkpIHtcbiAgICAgIHJldHVybiAoIHkgLSB0aGlzLmlubmVyQm9yZGVyICkgLyB0aGlzLnJhdGU7XG4gICAgfSxcblxuICAgIGZ1bmN0aW9uIHZhbHVlVG9ZKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdmFsdWUgKiB0aGlzLnJhdGUgKyB0aGlzLmlubmVyQm9yZGVyO1xuICAgIH0sXG5cbiAgICBmdW5jdGlvbiBwYWludFNlbGYoYykge1xuICAgICAgaWYgKCAhIHRoaXMuc2l6ZSApIHJldHVybjtcblxuICAgICAgaWYgKCAhIGMgKSByZXR1cm47XG5cbiAgICAgIGlmICggdGhpcy5leHRlbnQgPj0gdGhpcy5zaXplICkgcmV0dXJuO1xuXG4gICAgICBjLnN0cm9rZVN0eWxlID0gdGhpcy5ib3JkZXJDb2xvcjtcbiAgICAgIGMubGluZVdpZHRoID0gMC40O1xuICAgICAgYy5zdHJva2VSZWN0KDAsIDAsIHRoaXMud2lkdGgtNywgdGhpcy5oZWlnaHQpO1xuXG4gICAgICBjLmZpbGxTdHlsZSA9IHRoaXMuaGFuZGxlQ29sb3I7XG5cbiAgICAgIGMuZmlsbFJlY3QoXG4gICAgICAgIDIsXG4gICAgICAgIHRoaXMudmFsdWVUb1kodGhpcy52YWx1ZSksXG4gICAgICAgIHRoaXMud2lkdGggLSAxMSxcbiAgICAgICAgdGhpcy5oYW5kbGVTaXplKTtcbiAgICB9XG4gIF0sXG5cbiAgbGlzdGVuZXJzOiBbXG4gICAge1xuICAgICAgbmFtZTogJ29uVG91Y2gnLFxuICAgICAgY29kZTogZnVuY3Rpb24oXywgX18sIHRvdWNoKSB7XG4gICAgICAgIHRoaXMudmFsdWUgPSB0aGlzLnlUb1ZhbHVlKHRvdWNoLnkpO1xuXG4gICAgICAgIC8vIHByZXZlbnRzIGhpZ2hsaWdodGluZyBvZiBvdGhlciBlbGVtZW50cyB3aGlsZSBzY3JvbGxpbmdcbiAgICAgICAgdG91Y2guY2xhaW1lZCA9IHRydWU7XG4gICAgICB9XG4gICAgfSxcbiAgXVxufSk7XG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNSBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5mb2FtLkNMQVNTKHtcbiAgcGFja2FnZTogJ2ZvYW0ucGh5c2ljcycsXG4gIG5hbWU6ICdQaHlzaWNhbENpcmNsZScsXG4gIGV4dGVuZHM6ICdmb2FtLmdyYXBoaWNzLkNpcmNsZScsXG4gIGltcGxlbWVudHM6IFsgJ2ZvYW0ucGh5c2ljcy5QaHlzaWNhbCcgXSxcblxuICBkb2N1bWVudGF0aW9uOiAnQSBDaXJjbGUgd2l0aCBQaHlzaWNhbCBzdXBwb3J0Lidcbn0pO1xuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTYgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIENvcHlyaWdodCAyMDE3IFRoZSBGT0FNIEF1dGhvcnMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmZvYW0uQ0xBU1Moe1xuICBwYWNrYWdlOiAnZm9hbS5jb21pY3MnLFxuICBuYW1lOiAnREFPQ29udHJvbGxlcicsXG5cbiAgdG9waWNzOiBbXG4gICAgJ2ZpbmlzaGVkJ1xuICBdLFxuXG4gIHByb3BlcnRpZXM6IFtcbiAgICB7XG4gICAgICBuYW1lOiAnZGF0YScsXG4gICAgICBoaWRkZW46IHRydWVcbiAgICB9LFxuICAgIHtcbiAgICAgIG5hbWU6ICdwcmVkaWNhdGUnLFxuICAgICAgdmlldzogeyBjbGFzczogJ2ZvYW0udTIudmlldy5SZWNpcHJvY2FsU2VhcmNoJyB9XG4gICAgfSxcbiAgICB7XG4gICAgICBuYW1lOiAnZmlsdGVyZWREQU8nLFxuICAgICAgdmlldzogeyBjbGFzczogJ2ZvYW0udTIudmlldy5TY3JvbGxUYWJsZVZpZXcnIH0sXG4gICAgICBleHByZXNzaW9uOiBmdW5jdGlvbihkYXRhLCBwcmVkaWNhdGUpIHtcbiAgICAgICAgcmV0dXJuIHByZWRpY2F0ZSA/IGRhdGEud2hlcmUocHJlZGljYXRlKSA6IGRhdGE7XG4gICAgICB9XG4gICAgfSxcbiAgICB7XG4gICAgICBuYW1lOiAncmVsYXRpb25zaGlwJ1xuICAgIH0sXG4gICAge1xuICAgICAgbmFtZTogJ3NlbGVjdGlvbicsXG4gICAgICBoaWRkZW46IHRydWVcbiAgICB9LFxuICAgIHtcbiAgICAgIGNsYXNzOiAnQm9vbGVhbicsXG4gICAgICBuYW1lOiAnY3JlYXRlRW5hYmxlZCcsXG4gICAgICBkb2N1bWVudGF0aW9uOiAnVHJ1ZSB0byBlbmFibGUgdGhlIGNyZWF0ZSBidXR0b24uJyxcbiAgICAgIHZhbHVlOiB0cnVlXG4gICAgfSxcbiAgICB7XG4gICAgICBjbGFzczogJ0Jvb2xlYW4nLFxuICAgICAgbmFtZTogJ2VkaXRFbmFibGVkJyxcbiAgICAgIGRvY3VtZW50YXRpb246ICdUcnVlIHRvIGVuYWJsZSB0aGUgZWRpdCBidXR0b24nLFxuICAgICAgdmFsdWU6IHRydWVcbiAgICB9LFxuICAgIHtcbiAgICAgIGNsYXNzOiAnQm9vbGVhbicsXG4gICAgICBuYW1lOiAnc2VsZWN0RW5hYmxlZCcsXG4gICAgICBkb2N1bWVudGF0aW9uOiAnVHJ1ZSB0byBlbmFibGUgdGhlIHNlbGVjdCBidXR0b24uJyxcbiAgICAgIHZhbHVlOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgY2xhc3M6ICdCb29sZWFuJyxcbiAgICAgIG5hbWU6ICdhZGRFbmFibGVkJyxcbiAgICAgIGRvY3VtZW50YXRpb246ICdUcnVlIHRvIGVuYWJsZSB0aGUgQWRkIGJ1dHRvbiBmb3IgYWRkaW5nIHRvIGEgcmVsYXRpb25zaGlwJyxcbiAgICAgIHZhbHVlOiBmYWxzZVxuICAgIH1cbiAgXSxcblxuICBhY3Rpb25zOiBbXG4gICAge1xuICAgICAgbmFtZTogJ2NyZWF0ZScsXG4gICAgICBpc0F2YWlsYWJsZTogZnVuY3Rpb24oY3JlYXRlRW5hYmxlZCkgeyByZXR1cm4gY3JlYXRlRW5hYmxlZDsgfSxcbiAgICAgIGNvZGU6IGZ1bmN0aW9uKCkgeyB9XG4gICAgfSxcbiAgICB7XG4gICAgICBuYW1lOiAnZWRpdCcsXG4gICAgICBpc0VuYWJsZWQ6IGZ1bmN0aW9uKHNlbGVjdGlvbikgeyByZXR1cm4gISEgc2VsZWN0aW9uOyB9LFxuICAgICAgaXNBdmFpbGFibGU6IGZ1bmN0aW9uKGVkaXRFbmFibGVkKSB7IHJldHVybiBlZGl0RW5hYmxlZDsgfSxcbiAgICAgIGNvZGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLnB1YignZWRpdCcsIHRoaXMuc2VsZWN0aW9uLmlkKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHtcbiAgICAgIG5hbWU6ICdmaW5kUmVsYXRlZE9iamVjdCcsXG4gICAgICBsYWJlbDogJ0FkZCcsXG4gICAgICBpc0F2YWlsYWJsZTogZnVuY3Rpb24ocmVsYXRpb25zaGlwLCBhZGRFbmFibGVkKSB7XG4gICAgICAgIC8vIE9ubHkgZW5hYmxlIHRoZSBBZGQgYnV0dG9uIGlmIHdlJ3JlIG5vdCBhbHJlYWR5IHRyeWluZyB0byBjaG9vc2UgYSBzZWxlY3RlZCBpdGVtIGZvciBhIHJlbGF0aW9uc2hpcC5cbiAgICAgICAgcmV0dXJuICEhICggcmVsYXRpb25zaGlwICYmIHJlbGF0aW9uc2hpcC5qdW5jdGlvbkRBTyApICYmICEgYWRkRW5hYmxlZDtcbiAgICAgIH0sXG4gICAgICBjb2RlOiBmdW5jdGlvbigpIHsgfVxuICAgIH0sXG4gICAge1xuICAgICAgbmFtZTogJ2FkZFNlbGVjdGlvbicsXG4gICAgICBsYWJlbDogJ0FkZCcsXG4gICAgICBpc0F2YWlsYWJsZTogZnVuY3Rpb24oYWRkRW5hYmxlZCkgeyByZXR1cm4gYWRkRW5hYmxlZDsgfSxcbiAgICAgIGNvZGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIHRoaXMucmVsYXRpb25zaGlwLmFkZCh0aGlzLnNlbGVjdGlvbikudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgICBzZWxmLmZpbmlzaGVkLnB1YigpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHtcbiAgICAgIG5hbWU6ICdzZWxlY3QnLFxuICAgICAgaXNBdmFpbGFibGU6IGZ1bmN0aW9uKHNlbGVjdEVuYWJsZWQpIHsgcmV0dXJuIHNlbGVjdEVuYWJsZWQ7IH0sXG4gICAgICBpc0VuYWJsZWQ6IGZ1bmN0aW9uKHNlbGVjdGlvbikgeyByZXR1cm4gISEgc2VsZWN0aW9uOyB9LFxuICAgICAgY29kZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMucHViKCdzZWxlY3QnLCB0aGlzLnNlbGVjdGlvbi5pZCk7XG4gICAgICAgIHRoaXMuZmluaXNoZWQucHViKCk7XG4gICAgICB9XG4gICAgfVxuICBdXG59KTtcbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IFRoZSBGT0FNIEF1dGhvcnMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqL1xuXG5mb2FtLkNMQVNTKHtcbiAgcGFja2FnZTogJ2ZvYW0uY29taWNzJyxcbiAgbmFtZTogJ0RBT0NvbnRyb2xsZXJWaWV3JyxcbiAgZXh0ZW5kczogJ2ZvYW0udTIuVmlldycsXG5cbiAgcmVxdWlyZXM6IFtcbiAgICAnZm9hbS5jb21pY3MuREFPQ29udHJvbGxlcicsXG4gICAgJ2ZvYW0udTIudmlldy5TY3JvbGxUYWJsZVZpZXcnXG4gIF0sXG5cbiAgaW1wb3J0czogW1xuICAgICdzdGFjaycsXG4gICAgJ3N1bW1hcnlWaWV3PyBhcyBpbXBvcnRlZFN1bW1hcnlWaWV3JyxcbiAgICAnZGF0YT8gYXMgaW1wb3J0ZWREYXRhJyxcbiAgICAnd2luZG93J1xuICBdLFxuXG4gIGV4cG9ydHM6IFtcbiAgICAnZGF0YS5zZWxlY3Rpb24gYXMgc2VsZWN0aW9uJyxcbiAgICAnZGF0YS5kYXRhIGFzIGRhbycsXG4gICAgJ2RibGNsaWNrJ1xuICBdLFxuXG4gIC8vIFRPRE86IHdyb25nIGNsYXNzIG5hbWUsIGZpeCB3aGVuIEFjdGlvblZpZXcgZml4ZWQuXG4gIGNzczogYFxuICAgIF4gLm5ldC1uYW5vcGF5LXVpLUFjdGlvblZpZXcge1xuICAgICAgYmFja2dyb3VuZDogIzU5YWFkZDtcbiAgICAgIGNvbG9yOiB3aGl0ZTtcbiAgICAgIG1hcmdpbi1yaWdodDogNHB4O1xuICAgIH1cbiAgYCxcblxuICBwcm9wZXJ0aWVzOiBbXG4gICAge1xuICAgICAgY2xhc3M6ICdGT2JqZWN0UHJvcGVydHknLFxuICAgICAgb2Y6ICdmb2FtLmNvbWljcy5EQU9Db250cm9sbGVyJyxcbiAgICAgIG5hbWU6ICdkYXRhJyxcbiAgICAgIGV4cHJlc3Npb246IGZ1bmN0aW9uKGltcG9ydGVkRGF0YSkgeyByZXR1cm4gaW1wb3J0ZWREYXRhOyB9XG4gICAgfSxcbiAgICB7XG4gICAgICBuYW1lOiAnY2xzJyxcbiAgICAgIGV4cHJlc3Npb246IGZ1bmN0aW9uKGRhdGEpIHsgcmV0dXJuIGRhdGEuY2xzXzsgfVxuICAgIH0sXG4gICAge1xuICAgICAgbmFtZTogJ3N1bW1hcnlWaWV3JyxcbiAgICAgIGZhY3Rvcnk6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pbXBvcnRlZFN1bW1hcnlWaWV3JCA/XG4gICAgICAgICAgICB0aGlzLmltcG9ydGVkU3VtbWFyeVZpZXcgOlxuICAgICAgICAgICAgeyBjbGFzczogJ2ZvYW0udTIudmlldy5TY3JvbGxUYWJsZVZpZXcnIH07XG4gICAgICB9XG4gICAgfSxcbiAgICB7XG4gICAgICBjbGFzczogJ1N0cmluZycsXG4gICAgICBuYW1lOiAndGl0bGUnLFxuICAgICAgZXhwcmVzc2lvbjogZnVuY3Rpb24oZGF0YSRkYXRhJG9mKSB7XG4gICAgICAgIHJldHVybiAnQnJvd3NlICcgKyBkYXRhJGRhdGEkb2YubmFtZTtcbiAgICAgIH1cbiAgICB9XG4gIF0sXG5cbiAgcmVhY3Rpb25zOiBbXG4gICAgWyAnZGF0YScsICdhY3Rpb24uY3JlYXRlJywgJ29uQ3JlYXRlJyBdLFxuICAgIFsgJ2RhdGEnLCAnZWRpdCcsICdvbkVkaXQnIF0sXG4gICAgWyAnZGF0YScsICdhY3Rpb24uZmluZFJlbGF0ZWRPYmplY3QnLCAnb25GaW5kUmVsYXRlZCcgXSxcbiAgICBbICdkYXRhJywgJ2ZpbmlzaGVkJywgJ29uRmluaXNoZWQnIF1cbiAgXSxcblxuICBtZXRob2RzOiBbXG4gICAgZnVuY3Rpb24gaW5pdEUoKSB7XG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICAgIHRoaXMuXG4gICAgICAgIGFkZENsYXNzKHRoaXMubXlDbGFzcygpKS5cbiAgICAgICAgc3RhcnQoJ3RhYmxlJykuXG4gICAgICAgICAgc3RhcnQoJ3RyJykuXG4gICAgICAgICAgICBzdGFydCgndGQnKS5zdHlsZSh7ZGlzcGxheTogJ2Jsb2NrJywgcGFkZGluZzogJzhweCd9KS5hZGQodGhpcy5jbHMuUFJFRElDQVRFKS5lbmQoKS5cbiAgICAgICAgICAgIHN0YXJ0KCd0ZCcpLnN0eWxlKHsndmVydGljYWwtYWxpZ24nOiAndG9wJywgJ3dpZHRoJzogJzEwMCUnfSkuXG4gICAgICAgICAgICAgIHN0YXJ0KCdzcGFuJykuXG4gICAgICAgICAgICAgICAgc3R5bGUoe2JhY2tncm91bmQ6ICdyZ2JhKDAsMCwwLDApJ30pLlxuICAgICAgICAgICAgICAgIHNob3coc2VsZi5tb2RlJC5tYXAoZnVuY3Rpb24obSkgeyByZXR1cm4gbSA9PSBmb2FtLnUyLkRpc3BsYXlNb2RlLlJXOyB9KSkuXG4gICAgICAgICAgICAgICAgICBzdGFydCgpLlxuICAgICAgICAgICAgICAgICAgICBzdHlsZSh7cGFkZGluZzogJzRweCA0cHggNHB4IDFweCd9KS5cbiAgICAgICAgICAgICAgICAgICAgYWRkKHNlbGYuY2xzLmdldEF4aW9tc0J5Q2xhc3MoZm9hbS5jb3JlLkFjdGlvbikpLlxuICAgICAgICAgICAgICAgICAgZW5kKCkuXG4gICAgICAgICAgICAgICAgZW5kKCkuXG4gICAgICAgICAgICAgIHRhZyh0aGlzLnN1bW1hcnlWaWV3LCB7ZGF0YSQ6IHRoaXMuZGF0YS5maWx0ZXJlZERBTyR9KS5cbiAgICAgICAgICAgIGVuZCgpLlxuICAgICAgICAgIGVuZCgpLlxuICAgICAgICBlbmQoKTtcbiAgICB9LFxuXG4gICAgZnVuY3Rpb24gZGJsY2xpY2sob2JqKSB7XG4gICAgICB0aGlzLm9uRWRpdChudWxsLCBudWxsLCBvYmouaWQpO1xuICAgIH1cbiAgXSxcblxuICBsaXN0ZW5lcnM6IFtcbiAgICBmdW5jdGlvbiBvbkNyZWF0ZSgpIHtcbiAgICAgIHRoaXMuc3RhY2sucHVzaCh7XG4gICAgICAgIGNsYXNzOiAnZm9hbS5jb21pY3MuREFPQ3JlYXRlQ29udHJvbGxlclZpZXcnXG4gICAgICB9LCB0aGlzKTtcbiAgICB9LFxuXG4gICAgZnVuY3Rpb24gb25FZGl0KHMsIGVkaXQsIGlkKSB7XG4gICAgICB0aGlzLnN0YWNrLnB1c2goe1xuICAgICAgICBjbGFzczogJ2ZvYW0uY29taWNzLkRBT1VwZGF0ZUNvbnRyb2xsZXJWaWV3JyxcbiAgICAgICAga2V5OiBpZFxuICAgICAgfSwgdGhpcyk7XG4gICAgfSxcblxuICAgIGZ1bmN0aW9uIG9uRmluZFJlbGF0ZWQoKSB7XG4gICAgICB2YXIgZGF0YSA9IHRoaXMuREFPQ29udHJvbGxlci5jcmVhdGUoe1xuICAgICAgICBkYXRhOiB0aGlzLmRhdGEucmVsYXRpb25zaGlwLnRhcmdldERBTyxcbiAgICAgICAgYWRkRW5hYmxlZDogdHJ1ZSxcbiAgICAgICAgcmVsYXRpb25zaGlwOiB0aGlzLmRhdGEucmVsYXRpb25zaGlwXG4gICAgICB9KTtcblxuICAgICAgdGhpcy5zdGFjay5wdXNoKHtcbiAgICAgICAgY2xhc3M6ICdmb2FtLmNvbWljcy5EQU9Db250cm9sbGVyVmlldycsXG4gICAgICAgIGRhdGE6IGRhdGFcbiAgICAgIH0sIHRoaXMpO1xuICAgIH0sXG5cbiAgICBmdW5jdGlvbiBvbkZpbmlzaGVkKCkge1xuICAgICAgdGhpcy5zdGFjay5iYWNrKCk7XG4gICAgfVxuICBdXG59KTtcbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IFRoZSBGT0FNIEF1dGhvcnMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmZvYW0uQ0xBU1Moe1xuICBwYWNrYWdlOiAnZm9hbS5jb21pY3MnLFxuICBuYW1lOiAnSW5saW5lREFPQ29udHJvbGxlclZpZXcnLFxuICBleHRlbmRzOiAnZm9hbS5jb21pY3MuREFPQ29udHJvbGxlclZpZXcnLFxuICBcbiAgbWV0aG9kczogW1xuICAgIGZ1bmN0aW9uIGluaXRFKCkge1xuICAgICAgdGhpcy5cbiAgICAgICAgYWRkKHRoaXMuY2xzLkZJTFRFUkVEX0RBTykuXG4gICAgICAgIHN0YXJ0KCdzcGFuJykuXG4gICAgICAgICAgc2hvdyh0aGlzLm1vZGUkLm1hcChmdW5jdGlvbihtKSB7IHJldHVybiBtID09IGZvYW0udTIuRGlzcGxheU1vZGUuUlc7IH0pKS5cbiAgICAgICAgICBhZGQodGhpcy5jbHMuZ2V0QXhpb21zQnlDbGFzcyhmb2FtLmNvcmUuQWN0aW9uKSkuXG4gICAgICAgIGVuZCgpO1xuICAgIH1cbiAgXVxufSk7XG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogQ29weXJpZ2h0IDIwMTcgVGhlIEZPQU0gQXV0aG9ycy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuZm9hbS5DTEFTUyh7XG4gIHBhY2thZ2U6ICdmb2FtLmNvbWljcycsXG4gIG5hbWU6ICdEQU9DcmVhdGVDb250cm9sbGVyJyxcblxuICB0b3BpY3M6IFtcbiAgICAnZmluaXNoZWQnXG4gIF0sXG5cbiAgcHJvcGVydGllczogW1xuICAgIHtcbiAgICAgIG5hbWU6ICdkYW8nXG4gICAgfSxcbiAgICB7XG4gICAgICBjbGFzczogJ0Jvb2xlYW4nLFxuICAgICAgbmFtZTogJ2luUHJvZ3Jlc3MnXG4gICAgfSxcbiAgICB7XG4gICAgICBuYW1lOiAnZXhjZXB0aW9uJ1xuICAgIH0sXG4gICAge1xuICAgICAgbmFtZTogJ2RhdGEnLFxuICAgICAgdmlldzogeyBjbGFzczogJ2ZvYW0udTIuRGV0YWlsVmlldycgfSxcbiAgICAgIGZhY3Rvcnk6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kYW8gPyB0aGlzLmRhby5vZi5jcmVhdGUoe30sIHRoaXMpIDogbnVsbDtcbiAgICAgIH1cbiAgICB9XG4gIF0sXG5cbiAgYWN0aW9uczogW1xuICAgIHtcbiAgICAgIG5hbWU6ICdzYXZlJyxcbiAgICAgIGlzRW5hYmxlZDogZnVuY3Rpb24oZGFvLCBkYXRhJGVycm9yc18sIGluUHJvZ3Jlc3MpIHsgcmV0dXJuICEhIGRhbyAmJiAhIGluUHJvZ3Jlc3MgJiYgISBkYXRhJGVycm9yc187IH0sXG4gICAgICBjb2RlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5pblByb2dyZXNzID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5jbGVhclByb3BlcnR5KCdleGNlcHRpb24nKTtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICB0aGlzLmRhby5wdXQodGhpcy5kYXRhLmNsb25lKCkpLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgc2VsZi5pblByb2dyZXNzID0gZmFsc2U7XG4gICAgICAgICAgc2VsZi5maW5pc2hlZC5wdWIoKTtcbiAgICAgICAgfSwgZnVuY3Rpb24oZSkge1xuICAgICAgICAgIHNlbGYuaW5Qcm9ncmVzcyA9IGZhbHNlO1xuICAgICAgICAgIHNlbGYuZXhjZXB0aW9uID0gZTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSxcbiAgICB7XG4gICAgICBuYW1lOiAnY2FuY2VsJyxcbiAgICAgIGNvZGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLmZpbmlzaGVkLnB1YigpO1xuICAgICAgfVxuICAgIH1cbiAgXVxufSk7XG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBUaGUgRk9BTSBBdXRob3JzLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5mb2FtLkNMQVNTKHtcbiAgcGFja2FnZTogJ2ZvYW0uY29taWNzJyxcbiAgbmFtZTogJ0RBT0NyZWF0ZUNvbnRyb2xsZXJWaWV3JyxcbiAgZXh0ZW5kczogJ2ZvYW0udTIuVmlldycsXG5cbiAgcmVxdWlyZXM6IFtcbiAgICAnZm9hbS5jb21pY3MuREFPQ3JlYXRlQ29udHJvbGxlcidcbiAgXSxcblxuICBpbXBvcnRzOiBbXG4gICAgJ3N0YWNrJyxcbiAgICAnZGFvJ1xuICBdLFxuXG4gIGV4cG9ydHM6IFtcbiAgICAnZGF0YSdcbiAgXSxcblxuICBjc3M6IGBcbiAgICBeIC5uZXQtbmFub3BheS11aS1BY3Rpb25WaWV3IHtcbiAgICAgIGJhY2tncm91bmQ6ICM1OWFhZGQ7XG4gICAgICBjb2xvcjogd2hpdGU7XG4gICAgICBtYXJnaW4tcmlnaHQ6IDRweDtcbiAgICB9XG4gIGAsXG5cbiAgcHJvcGVydGllczogW1xuICAgIHtcbiAgICAgIGNsYXNzOiAnRk9iamVjdFByb3BlcnR5JyxcbiAgICAgIG9mOiAnZm9hbS5jb21pY3MuREFPQ3JlYXRlQ29udHJvbGxlcicsXG4gICAgICBuYW1lOiAnZGF0YScsXG4gICAgICBmYWN0b3J5OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuREFPQ3JlYXRlQ29udHJvbGxlci5jcmVhdGUoeyBkYW86IHRoaXMuZGFvIH0pO1xuICAgICAgfVxuICAgIH0sXG4gICAge1xuICAgICAgY2xhc3M6ICdTdHJpbmcnLFxuICAgICAgbmFtZTogJ3RpdGxlJyxcbiAgICAgIGV4cHJlc3Npb246IGZ1bmN0aW9uKGRhdGEkZGFvJG9mKSB7XG4gICAgICAgIHJldHVybiAnQ3JlYXRlICcgKyBkYXRhJGRhbyRvZi5uYW1lO1xuICAgICAgfVxuICAgIH1cbiAgXSxcblxuICByZWFjdGlvbnM6IFtcbiAgICBbICdkYXRhJywgJ2ZpbmlzaGVkJywgJ29uRmluaXNoZWQnIF1cbiAgXSxcblxuICBtZXRob2RzOiBbXG4gICAgZnVuY3Rpb24gaW5pdEUoKSB7XG4gICAgICB0aGlzLlxuICAgICAgYWRkQ2xhc3ModGhpcy5teUNscygpKS5cbiAgICAgIHN0YXJ0KCd0YWJsZScpLlxuICAgICAgICBzdGFydCgndHInKS5cbiAgICAgICAgICBzdGFydCgndGQnKS5zdHlsZSh7J3ZlcnRpY2FsLWFsaWduJzogJ3RvcCcsICd3aWR0aCc6ICcxMDAlJ30pLlxuICAgICAgICAgICAgc3RhcnQoJ3NwYW4nKS5cbiAgICAgICAgICAgICAgc3R5bGUoe2JhY2tncm91bmQ6ICdyZ2JhKDAsMCwwLDApJ30pLlxuICAgICAgICAgICAgICBzaG93KHRoaXMubW9kZSQubWFwKGZ1bmN0aW9uKG0pIHsgcmV0dXJuIG0gPT0gZm9hbS51Mi5EaXNwbGF5TW9kZS5SVzsgfSkpLlxuICAgICAgICAgICAgICBzdGFydCgpLlxuICAgICAgICAgICAgICAgIHN0eWxlKHsncGFkZGluZy1ib3R0b20nOiAnNHB4J30pLlxuICAgICAgICAgICAgICAgIGFkZCh0aGlzLmRhdGEuY2xzXy5nZXRBeGlvbXNCeUNsYXNzKGZvYW0uY29yZS5BY3Rpb24pKS5cbiAgICAgICAgICAgICAgZW5kKCkuXG4gICAgICAgICAgICBlbmQoKS5cbiAgICAgICAgICAgIGFkZCh0aGlzLkRBT0NyZWF0ZUNvbnRyb2xsZXIuREFUQSkuXG4gICAgICAgICAgZW5kKCkuXG4gICAgICAgIGVuZCgpLlxuICAgICAgZW5kKCk7XG4gICAgICAvKlxuICAgICAgdGhpcy5cbiAgICAgICAgYWRkKHRoaXMuREFPQ3JlYXRlQ29udHJvbGxlci5EQVRBLFxuICAgICAgICAgICAgdGhpcy5kYXRhLmNsc18uZ2V0QXhpb21zQnlDbGFzcyhmb2FtLmNvcmUuQWN0aW9uKSlcbiAgICAgICAgICAgICovXG4gICAgfVxuICBdLFxuXG4gIGxpc3RlbmVyczogW1xuICAgIGZ1bmN0aW9uIG9uRmluaXNoZWQoKSB7XG4gICAgICB0aGlzLnN0YWNrLmJhY2soKTtcbiAgICB9XG4gIF1cbn0pO1xuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgVGhlIEZPQU0gQXV0aG9ycy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuZm9hbS5DTEFTUyh7XG4gIHBhY2thZ2U6ICdmb2FtLmNvbWljcycsXG4gIG5hbWU6ICdEQU9VcGRhdGVDb250cm9sbGVyJyxcblxuICB0b3BpY3M6IFtcbiAgICAnZmluaXNoZWQnXG4gIF0sXG5cbiAgcHJvcGVydGllczogW1xuICAgIHtcbiAgICAgIG5hbWU6ICdkYW8nXG4gICAgfSxcbiAgICB7XG4gICAgICBuYW1lOiAnZGF0YSdcbiAgICB9LFxuICAgIHtcbiAgICAgIG5hbWU6ICdvYmonLFxuICAgICAgdmlldzogeyBjbGFzczogJ2ZvYW0udTIuRGV0YWlsVmlldycsIHNob3dBY3Rpb25zOiB0cnVlIH0sXG4gICAgICBmYWN0b3J5OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICB0aGlzLmRhby5maW5kKHRoaXMuZGF0YSkudGhlbihmdW5jdGlvbihvYmopIHtcbiAgICAgICAgICBzZWxmLm9iaiA9IG9iai5jbG9uZSgpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgfVxuICBdLFxuXG4gIGFjdGlvbnM6IFtcbiAgICBmdW5jdGlvbiBjYW5jZWwoKSB7XG4gICAgICB0aGlzLmZpbmlzaGVkLnB1YigpO1xuICAgIH0sXG4gICAge1xuICAgICAgbmFtZTogJ3NhdmUnLFxuICAgICAgaXNFbmFibGVkOiBmdW5jdGlvbihvYmopIHsgcmV0dXJuICEhIG9iajsgfSxcbiAgICAgIGNvZGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIHRoaXMuZGFvLnB1dCh0aGlzLm9iai5jbG9uZSgpKS50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHNlbGYuZmluaXNoZWQucHViKCk7XG4gICAgICAgIH0sIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAvLyBUT0RPOiBEaXNwbGF5IGVycm9yIGluIHZpZXcuXG4gICAgICAgICAgY29uc29sZS5lcnJvcihlKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSxcbiAgICB7XG4gICAgICBuYW1lOiAnZGVsZXRlJyxcbiAgICAgIGlzRW5hYmxlZDogZnVuY3Rpb24ob2JqKSB7IHJldHVybiAhISBvYmo7IH0sXG4gICAgICBjb25maXJtYXRpb25SZXF1aXJlZDogdHJ1ZSxcbiAgICAgIGNvZGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIHRoaXMuZGFvLnJlbW92ZSh0aGlzLm9iaikudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgICBzZWxmLmZpbmlzaGVkLnB1YigpO1xuICAgICAgICB9LCBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgLy8gVE9ETzogRGlzcGxheSBlcnJvciBpbiB2aWV3LlxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgXVxufSk7XG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBUaGUgRk9BTSBBdXRob3JzLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5mb2FtLkNMQVNTKHtcbiAgcGFja2FnZTogJ2ZvYW0uY29taWNzJyxcbiAgbmFtZTogJ0RBT1VwZGF0ZUNvbnRyb2xsZXJWaWV3JyxcbiAgZXh0ZW5kczogJ2ZvYW0udTIuVmlldycsXG5cbiAgcmVxdWlyZXM6IFtcbiAgICAnZm9hbS5jb21pY3MuREFPVXBkYXRlQ29udHJvbGxlcidcbiAgXSxcblxuICBpbXBvcnRzOiBbXG4gICAgJ3N0YWNrJyxcbiAgICAnZGFvJ1xuICBdLFxuXG4gIGV4cG9ydHM6IFtcbiAgICAnZGF0YSdcbiAgXSxcblxuICBjc3M6IGBcbiAgICBeIC5uZXQtbmFub3BheS11aS1BY3Rpb25WaWV3IHtcbiAgICAgIGJhY2tncm91bmQ6ICM1OWFhZGQ7XG4gICAgICBjb2xvcjogd2hpdGU7XG4gICAgICBtYXJnaW4tcmlnaHQ6IDRweDtcbiAgICB9XG4gICAgXiAubmV0LW5hbm9wYXktdWktQWN0aW9uVmlldy1kZWxldGUge1xuICAgICAgYmFja2dyb3VuZDogI2Q1NTtcbiAgICB9XG4gIGAsXG5cbiAgcHJvcGVydGllczogW1xuICAgIHtcbiAgICAgIG5hbWU6ICdrZXknXG4gICAgfSxcbiAgICB7XG4gICAgICBjbGFzczogJ0ZPYmplY3RQcm9wZXJ0eScsXG4gICAgICBvZjogJ2ZvYW0uY29taWNzLkRBT1VwZGF0ZUNvbnRyb2xsZXInLFxuICAgICAgbmFtZTogJ2RhdGEnLFxuICAgICAgZmFjdG9yeTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLkRBT1VwZGF0ZUNvbnRyb2xsZXIuY3JlYXRlKHtcbiAgICAgICAgICBkYXRhOiB0aGlzLmtleSxcbiAgICAgICAgICBkYW86IHRoaXMuZGFvXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0sXG4gICAge1xuICAgICAgY2xhc3M6ICdTdHJpbmcnLFxuICAgICAgbmFtZTogJ3RpdGxlJyxcbiAgICAgIGV4cHJlc3Npb246IGZ1bmN0aW9uKGRhdGEkZGFvJG9mKSB7XG4gICAgICAgIHJldHVybiAnRWRpdCAnICsgZGF0YSRkYW8kb2YubmFtZTtcbiAgICAgIH1cbiAgICB9XG4gIF0sXG5cbiAgcmVhY3Rpb25zOiBbXG4gICAgWyAnZGF0YScsICdmaW5pc2hlZCcsICdvbkZpbmlzaGVkJyBdXG4gIF0sXG5cbiAgbWV0aG9kczogW1xuICAgIGZ1bmN0aW9uIGluaXRFKCkge1xuICAgICAgLyogRG9lc24ndCB3b3JrIGJlY2F1c2Ugb2JqIGlzbid0IGtub3duIHlldC5cbiAgICAgIHRoaXMuc3RhcnRDb250ZXh0KHtkYXRhOiB0aGlzLmRhdGEub2JqfSlcbiAgICAgICAgLmFkZCh0aGlzLmRhdGEuZGFvLm9mLmdldEF4aW9tc0J5Q2xhc3MoZm9hbS5jb3JlLkFjdGlvbikpXG4gICAgICAuZW5kQ29udGV4dCgpXG4gICAgICAqL1xuICAgICAgdGhpcy5cbiAgICAgIGFkZENsYXNzKHRoaXMubXlDbHMoKSkuXG4gICAgICBzdGFydCgndGFibGUnKS5cbiAgICAgICAgc3RhcnQoJ3RyJykuXG4gICAgICAgICAgc3RhcnQoJ3RkJykuc3R5bGUoeyd2ZXJ0aWNhbC1hbGlnbic6ICd0b3AnLCAnd2lkdGgnOiAnMTAwJSd9KS5cbiAgICAgICAgICAgIHN0YXJ0KCdzcGFuJykuXG4gICAgICAgICAgICAgIHN0eWxlKHtiYWNrZ3JvdW5kOiAncmdiYSgwLDAsMCwwKSd9KS5cbiAgICAgICAgICAgICAgc2hvdyh0aGlzLm1vZGUkLm1hcChmdW5jdGlvbihtKSB7IHJldHVybiBtID09IGZvYW0udTIuRGlzcGxheU1vZGUuUlc7IH0pKS5cbiAgICAgICAgICAgICAgc3RhcnQoKS5cbiAgICAgICAgICAgICAgICBzdHlsZSh7J3BhZGRpbmctYm90dG9tJzogJzRweCd9KS5cbiAgICAgICAgICAgICAgICBhZGQodGhpcy5kYXRhLmNsc18uZ2V0QXhpb21zQnlDbGFzcyhmb2FtLmNvcmUuQWN0aW9uKSkuXG4gICAgICAgICAgICAgIGVuZCgpLlxuICAgICAgICAgICAgZW5kKCkuXG4gICAgICAgICAgICBhZGQodGhpcy5EQU9VcGRhdGVDb250cm9sbGVyLk9CSikuXG4gICAgICAgICAgZW5kKCkuXG4gICAgICAgIGVuZCgpLlxuICAgICAgZW5kKCk7XG4gICAgfVxuICBdLFxuXG4gIGxpc3RlbmVyczogW1xuICAgIGZ1bmN0aW9uIG9uRmluaXNoZWQoKSB7XG4gICAgICB0aGlzLnN0YWNrLmJhY2soKTtcbiAgICB9XG4gIF1cbn0pO1xuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgVGhlIEZPQU0gQXV0aG9ycy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuZm9hbS5DTEFTUyh7XG4gIHBhY2thZ2U6ICdmb2FtLmNvbWljcycsXG4gIG5hbWU6ICdCcm93c2VyVmlldycsXG4gIGV4dGVuZHM6ICdmb2FtLnUyLlZpZXcnLFxuXG4gIHJlcXVpcmVzOiBbXG4gICAgJ2ZvYW0uY29taWNzLkRBT0NvbnRyb2xsZXInLFxuICAgICdmb2FtLmNvbWljcy5EQU9Db250cm9sbGVyVmlldydcbiAgXSxcblxuICBleHBvcnRzOiBbXG4gICAgJ2NvbnRyb2xsZXIgYXMgZGF0YScsXG4gICAgJ3N1bW1hcnlWaWV3J1xuICBdLFxuXG4gIHByb3BlcnRpZXM6IFtcbiAgICB7XG4gICAgICBuYW1lOiAnZGF0YSdcbiAgICB9LFxuICAgIHtcbiAgICAgIG5hbWU6ICd0aXRsZScsXG4gICAgICBleHByZXNzaW9uOiBmdW5jdGlvbihkYXRhJG9mKSB7XG4gICAgICAgIHJldHVybiAnQnJvd3NlICcgKyBkYXRhJG9mLm5hbWU7XG4gICAgICB9XG4gICAgfSxcbiAgICB7XG4gICAgICBuYW1lOiAnY29udHJvbGxlcicsXG4gICAgICBleHByZXNzaW9uOiBmdW5jdGlvbihkYXRhKSB7XG4gICAgICAgIHJldHVybiB0aGlzLkRBT0NvbnRyb2xsZXIuY3JlYXRlKHsgZGF0YTogZGF0YSB9KTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHtcbiAgICAgIGNsYXNzOiAnZm9hbS51Mi5WaWV3U3BlYycsXG4gICAgICBuYW1lOiAnc3VtbWFyeVZpZXcnLFxuICAgICAgdmFsdWU6IHsgY2xhc3M6ICdmb2FtLnUyLnZpZXcuU2Nyb2xsVGFibGVWaWV3JyB9LFxuICAgICAgLy8gVE9ETzogcmVtb3ZlIG5leHQgbGluZSB3aGVuIHBlcm1hbmVudGx5IGZpeGVkIGluIFZpZXdTcGVjXG4gICAgICBmcm9tSlNPTjogZnVuY3Rpb24gZnJvbUpTT04odmFsdWUsIGN0eCwgcHJvcCwganNvbikgeyByZXR1cm4gdmFsdWU7IH1cbiAgICB9XG4gIF0sXG5cbiAgbWV0aG9kczogW1xuICAgIGZ1bmN0aW9uIGluaXRFKCkge1xuICAgICAgdGhpc1xuICAgICAgICAuYWRkQ2xhc3ModGhpcy5teUNsYXNzKCkpXG4gICAgICAgIC5hZGRDbGFzcyh0aGlzLm15Q2xhc3ModGhpcy5kYXRhLm9mLmlkLnJlcGxhY2UoL1xcLi9nLCAnLScpKSlcbiAgICAgICAgLnRhZyh0aGlzLkRBT0NvbnRyb2xsZXJWaWV3KTtcbiAgICB9XG4gIF1cbn0pO1xuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgVGhlIEZPQU0gQXV0aG9ycy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuZm9hbS5DTEFTUyh7XG4gIHBhY2thZ2U6ICdmb2FtLmNvbWljcycsXG4gIG5hbWU6ICdJbmxpbmVCcm93c2VyVmlldycsXG4gIGV4dGVuZHM6ICdmb2FtLmNvbWljcy5Ccm93c2VyVmlldycsXG5cbiAgcmVxdWlyZXM6IFtcbiAgICAnZm9hbS5jb21pY3MuSW5saW5lREFPQ29udHJvbGxlclZpZXcgYXMgREFPQ29udHJvbGxlclZpZXcnXG4gIF1cbn0pO1xuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgVGhlIEZPQU0gQXV0aG9ycy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuZm9hbS5DTEFTUyh7XG4gIHBhY2thZ2U6ICdmb2FtLmNvbWljcycsXG4gIG5hbWU6ICdSZWxhdGlvbnNoaXBWaWV3JyxcbiAgZXh0ZW5kczogJ2ZvYW0uY29taWNzLklubGluZUJyb3dzZXJWaWV3JyxcbiAgXG4gIHByb3BlcnRpZXM6IFtcbiAgICB7XG4gICAgICBuYW1lOiAnY29udHJvbGxlcicsXG4gICAgICBleHByZXNzaW9uOiBmdW5jdGlvbihkYXRhKSB7XG4gICAgICAgIHJldHVybiB0aGlzLkRBT0NvbnRyb2xsZXIuY3JlYXRlKHtcbiAgICAgICAgICBkYXRhOiBkYXRhLmRhbyxcbiAgICAgICAgICByZWxhdGlvbnNoaXA6IGRhdGFcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICBdXG59KTtcbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IFRoZSBGT0FNIEF1dGhvcnMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqL1xuXG5mb2FtLkNMQVNTKHtcbiAgcGFja2FnZTogJ2ZvYW0udTIudmlldycsXG4gIG5hbWU6ICdSZWNpcHJvY2FsU2VhcmNoJyxcbiAgZXh0ZW5kczogJ2ZvYW0udTIuRWxlbWVudCcsIC8vIFRPRE86IG1ha2UgYmUgYSBWaWV3XG5cbiAgcmVxdWlyZXM6IFtcbiAgICAnZm9hbS51Mi5zZWFyY2guU2VhcmNoTWFuYWdlcidcbiAgXSxcblxuICBpbXBvcnRzOiBbXG4gICAgJ2RhbydcbiAgXSxcblxuICBleHBvcnRzOiBbXG4gICAgJ2FzIGZpbHRlckNvbnRyb2xsZXInLFxuICAgICdhcyBkYXRhJ1xuICBdLFxuXG4gIC8vIFRPRE86IENTUyBjbGFzc25hbWUgc2hvdWxkbid0IGJlIC5uZXQtbmFub3BheS11aS1BY3Rpb25WaWV3LCBmaXguXG4gIGNzczogYFxuICAgIF4ge1xuICAgICAgbWluLXdpZHRoOiAxODBweDtcbiAgICAgIGZvbnQtc2l6ZTogbWVkaXVtO1xuICAgIH1cblxuICAgIF4gaW5wdXQge1xuICAgICAgZm9udC1zaXplOiBtZWRpdW07XG4gICAgfVxuXG4gICAgXmNvdW50IHtcbiAgICAgIGZvbnQtc2l6ZTogMTRwdDtcbiAgICAgIGNvbG9yOiAjNTU1O1xuICAgIH1cblxuICAgIF4gLm5ldC1uYW5vcGF5LXVpLUFjdGlvblZpZXctY2xlYXIge1xuICAgICAgYmFja2dyb3VuZDogIzU5YWFkZDtcbiAgICAgIGNvbG9yOiB3aGl0ZTtcbiAgICAgIG1hcmdpbi10b3A6IDE0cHg7XG4gICAgICBwYWRkaW5nOiAxMnB4O1xuICAgICAgd2lkdGg6IGF1dG87XG4gICAgfVxuICBgLFxuXG4gIHByb3BlcnRpZXM6IFtcbiAgICB7XG4gICAgICBjbGFzczogJ0NsYXNzJyxcbiAgICAgIG5hbWU6ICdvZidcbiAgICB9LFxuICAgIHtcbiAgICAgIG5hbWU6ICdkYXRhJ1xuICAgIH0sXG4gICAge1xuICAgICAgY2xhc3M6ICdBcnJheScsXG4gICAgICBuYW1lOiAnZmlsdGVycycsXG4gICAgICBmYWN0b3J5OiBudWxsLFxuICAgICAgZXhwcmVzc2lvbjogZnVuY3Rpb24oZGFvKSB7XG4gICAgICAgIHZhciBvZiA9IGRhbyAmJiBkYW8ub2Y7XG5cbiAgICAgICAgaWYgKCAhIG9mICkgcmV0dXJuIFtdO1xuXG4gICAgICAgIGlmICggb2YubW9kZWxfLnNlYXJjaENvbHVtbnMgKVxuICAgICAgICAgIHJldHVybiBvZi5tb2RlbF8uc2VhcmNoQ29sdW1ucztcblxuICAgICAgICBpZiAoIG9mLm1vZGVsXy50YWJsZUNvbHVtbnMgKVxuICAgICAgICAgIHJldHVybiBvZi5tb2RlbF8udGFibGVDb2x1bW5zLmZpbHRlcihmdW5jdGlvbihjKSB7XG4gICAgICAgICAgICB2YXIgYXhpb20gPSBvZi5nZXRBeGlvbUJ5TmFtZShjKTtcbiAgICAgICAgICAgIHJldHVybiBheGlvbSAmJiBheGlvbS5zZWFyY2hWaWV3O1xuICAgICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBvZi5nZXRBeGlvbXNCeUNsYXNzKGZvYW0uY29yZS5Qcm9wZXJ0eSlcbiAgICAgICAgICAgIC5maWx0ZXIoZnVuY3Rpb24ocCkgeyByZXR1cm4gcC5zZWFyY2hWaWV3ICYmICEgcC5oaWRkZW4gfSlcbiAgICAgICAgICAgIC5tYXAoZm9hbS5jb3JlLlByb3BlcnR5Lk5BTUUuZik7XG4gICAgICB9XG4gICAgfSxcbiAgICB7XG4gICAgICBjbGFzczogJ0ludCcsXG4gICAgICBuYW1lOiAnc2VsZWN0ZWRDb3VudCdcbiAgICB9LFxuICAgIHtcbiAgICAgIGNsYXNzOiAnSW50JyxcbiAgICAgIG5hbWU6ICd0b3RhbENvdW50J1xuICAgIH0sXG4gIF0sXG5cbiAgbWV0aG9kczogW1xuICAgIGZ1bmN0aW9uIGluaXRFKCkge1xuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgICB0aGlzLmRhby5vbi5zdWIodGhpcy51cGRhdGVUb3RhbENvdW50KTtcbiAgICAgIHRoaXMudXBkYXRlVG90YWxDb3VudCgpO1xuXG4gICAgICB0aGlzLlxuICAgICAgICBhZGRDbGFzcyhzZWxmLm15Q2xhc3MoKSkuXG4gICAgICAgIGFkZCh0aGlzLnNsb3QoZnVuY3Rpb24oZmlsdGVycykge1xuICAgICAgICAgIHNlbGYuc2hvdyhmaWx0ZXJzLmxlbmd0aCk7XG5cbiAgICAgICAgICB2YXIgc2VhcmNoTWFuYWdlciA9IHNlbGYuU2VhcmNoTWFuYWdlci5jcmVhdGUoe1xuICAgICAgICAgICAgZGFvJDogc2VsZi5kYW8kLFxuICAgICAgICAgICAgcHJlZGljYXRlJDogc2VsZi5kYXRhJFxuICAgICAgICAgIH0pO1xuXG4vLyAgICAgICAgICBzZWFyY2hNYW5hZ2VyLmZpbHRlcmVkREFPLm9uLnN1YihzZWxmLnVwZGF0ZVNlbGVjdGVkQ291bnQpO1xuICAgICAgICAgIHNlYXJjaE1hbmFnZXIuZmlsdGVyZWREQU8kLnN1YihzZWxmLnVwZGF0ZVNlbGVjdGVkQ291bnQpO1xuICAgICAgICAgIHNlbGYudXBkYXRlU2VsZWN0ZWRDb3VudCgwLDAsMCxzZWFyY2hNYW5hZ2VyLmZpbHRlcmVkREFPJCk7XG5cbiAgICAgICAgICB2YXIgZSA9IHRoaXMuRSgnZGl2Jyk7XG5cbiAgICAgICAgICBlLm9uRGV0YWNoKHNlYXJjaE1hbmFnZXIpO1xuXG4gICAgICAgICAgZS5mb3JFYWNoKGZpbHRlcnMsIGZ1bmN0aW9uKGYpIHtcbiAgICAgICAgICAgIC8vIFRPRE86IFNlZSBpZiB0aGlzIGNhbiBiZSBjbGVhbmVkIHVwIHNvbWVob3csIGlmIHNlYXJjaFZpZXcgZGlkbid0IHJlcXVpcmUgdGhlIHByb3ByZXR5IGV4cGxpY2l0bHksIG9yXG4gICAgICAgICAgICAvLyBjb3VsZCBmaW5kIHRoZSBzZWFyY2ggbWFuYWdlciB2aWEgdGhlIGNvbnRleHQgYW5kIGFkZCBpdHNlbGYgdG8gdGhhdC5cbiAgICAgICAgICAgIHZhciBheGlvbSA9IHNlbGYuZGFvLm9mLmdldEF4aW9tQnlOYW1lKGYpO1xuICAgICAgICAgICAgdmFyIHNwZWMgID0gYXhpb20uc2VhcmNoVmlldztcbiAgICAgICAgICAgIHZhciB2aWV3ICA9IGZvYW0udTIuVmlld1NwZWMuY3JlYXRlVmlldyhzcGVjLCB7IHByb3BlcnR5OiBheGlvbSwgZGFvOiBzZWxmLmRhbyB9LCB0aGlzLCB0aGlzLl9fc3ViU3ViQ29udGV4dF9fKTtcblxuICAgICAgICAgICAgc2VhcmNoTWFuYWdlci5hZGQodmlldyk7XG4gICAgICAgICAgICB0aGlzXG4gICAgICAgICAgICAgIC5zdGFydCgpXG4gICAgICAgICAgICAgICAgLmFkZENsYXNzKHNlbGYubXlDbGFzcygnZmlsdGVyLWhlYWRlcicpKVxuICAgICAgICAgICAgICAgIC5hZGQoYXhpb20ubGFiZWwpXG4gICAgICAgICAgICAgIC5lbmQoKVxuICAgICAgICAgICAgICAuc3RhcnQodmlldylcbiAgICAgICAgICAgICAgICAuYWRkQ2xhc3Moc2VsZi5teUNsYXNzKCdmaWx0ZXInKSlcbiAgICAgICAgICAgICAgLmVuZCgpO1xuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgcmV0dXJuIGU7XG4gICAgICAgIH0sIHRoaXMuZmlsdGVycyQpKVxuICAgICAgICAuc3RhcnQoKVxuICAgICAgICAgIC5hZGRDbGFzcyhzZWxmLm15Q2xhc3MoJ2NvdW50JykpXG4gICAgICAgICAgLy8gVE9ETzogbW92ZSBmb3JtYXR0aW5nIGZ1bmN0aW9uIHRvIHN0ZGxpYlxuICAgICAgICAgIC5hZGQoc2VsZi5zZWxlY3RlZENvdW50JC5tYXAoZnVuY3Rpb24oYSkgeyByZXR1cm4gYS50b1N0cmluZygpLnJlcGxhY2UoL1xcQig/PShcXGR7M30pKyg/IVxcZCkpL2csIFwiLFwiKTsgfSkpXG4gICAgICAgICAgLmVudGl0eSgnbmJzcCcpXG4gICAgICAgICAgLmFkZCgnb2YnKVxuICAgICAgICAgIC5lbnRpdHkoJ25ic3AnKVxuICAgICAgICAgIC5hZGQoc2VsZi50b3RhbENvdW50JC5tYXAoZnVuY3Rpb24oYSkgeyByZXR1cm4gYS50b1N0cmluZygpLnJlcGxhY2UoL1xcQig/PShcXGR7M30pKyg/IVxcZCkpL2csIFwiLFwiKTsgfSkpXG4gICAgICAgICAgLmVudGl0eSgnbmJzcCcpXG4gICAgICAgICAgLmFkZCgnc2VsZWN0ZWQnKVxuICAgICAgICAuZW5kKClcbiAgICAgICAgLnRhZyh0aGlzLkNMRUFSKTtcbiAgICB9LFxuXG4gICAgZnVuY3Rpb24gYWRkRmlsdGVyKGtleSkge1xuICAgICAgdGhpcy5maWx0ZXJzID0gdGhpcy5maWx0ZXJzLmNvbmNhdChrZXkpO1xuICAgIH0sXG5cbiAgICBmdW5jdGlvbiByZW1vdmVGaWx0ZXIoa2V5KSB7XG4gICAgICB0aGlzLmZpbHRlcnMgPSB0aGlzLmZpbHRlcnMuZmlsdGVyKGZ1bmN0aW9uKGspIHtcbiAgICAgICAgcmV0dXJuIGtleSAhPT0gaztcbiAgICAgIH0pO1xuICAgIH1cbiAgXSxcblxuICBhY3Rpb25zOiBbXG4gICAge1xuICAgICAgbmFtZTogJ2NsZWFyJyxcbiAgICAgIGNvZGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLmRhdGEgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMuZmlsdGVycyA9IHRoaXMuZmlsdGVycy5zbGljZSgpO1xuICAgICAgfVxuICAgIH1cbiAgXSxcblxuICAvKlxuICByZWFjdGlvbnM6IFtcbiAgICBbICdkYXRhJywgJ29uJywgJ3VwZGF0ZVRvdGFsQ291bnQnIF1cbiAgXSxcbiAgKi9cblxuICBsaXN0ZW5lcnM6IFtcbiAgICB7XG4gICAgICBuYW1lOiAndXBkYXRlVG90YWxDb3VudCcsXG4gICAgICBpc0ZyYW1lZDogdHJ1ZSxcbiAgICAgIGNvZGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLmRhby5zZWxlY3QoZm9hbS5tbGFuZy5zaW5rLkNvdW50LmNyZWF0ZSgpKS50aGVuKGZ1bmN0aW9uKGMpIHtcbiAgICAgICAgICB0aGlzLnRvdGFsQ291bnQgPSBjLnZhbHVlO1xuICAgICAgICB9LmJpbmQodGhpcykpO1xuICAgICAgfVxuICAgIH0sXG4gICAge1xuICAgICAgbmFtZTogJ3VwZGF0ZVNlbGVjdGVkQ291bnQnLFxuICAgICAgaXNGcmFtZWQ6IHRydWUsXG4gICAgICBjb2RlOiBmdW5jdGlvbihfLCBfXywgX19fLCBkYW8pIHtcbiAgICAgICAgZGFvLmdldCgpLnNlbGVjdChmb2FtLm1sYW5nLnNpbmsuQ291bnQuY3JlYXRlKCkpLnRoZW4oZnVuY3Rpb24oYykge1xuICAgICAgICAgIHRoaXMuc2VsZWN0ZWRDb3VudCA9IGMudmFsdWU7XG4gICAgICAgIH0uYmluZCh0aGlzKSk7XG4gICAgICB9XG4gICAgfVxuICBdXG59KTtcbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmZvYW0uQ0xBU1Moe1xuICBwYWNrYWdlOiAnZm9hbS5uZXQnLFxuICBuYW1lOiAnSFRUUE1ldGhvZCcsXG4gIGV4dGVuZHM6ICdmb2FtLmNvcmUuTWV0aG9kJyxcblxuICBkb2N1bWVudGF0aW9uOiBgXG4gIEEgbWV0aG9kIHRoYXQgaXMgY29uZmlndXJlZCB0byBjYWxsIGEgc2VydmljZSBvdmVyIEhUVFAuXG4gIE5vIGNvZGUgb3IgZnVuY3Rpb24gYm9keSBpcyByZXF1aXJlZCBoZXJlLCBhcyB0aGUgYWN0dWFsIGJvZHkgaXMgZ2VuZXJhdGVkIHRvXG4gIGNhbGwgdGhlIHJlbW90ZSBzZXJ2aWNlLiBUaGlzIHdpbGwgYWx3YXlzIHJldHVybiBhIHByb21pc2UgdGhhdCBzdXBwbGllcyB0aGVcbiAgcmV0dXJuIHZhbHVlIG9mIHRoZSBzZXJ2aWNlIGNhbGwuXG5cbiAgPHA+T3ZlcnJpZGluZyBieSBhbiBIVFRQTWV0aG9kIGlzIG5vdCBzdXBwb3J0ZWQuIFlvdSBjYW4gb3ZlcnJpZGUgYW5cbiAgSFRUUE1ldGhvZCB3aXRoIGEgbm9ybWFsIG9uZS5cbiAgYCxcblxuICByZXF1aXJlczogW1xuICAgICdmb2FtLm5ldC5IVFRQQXJndW1lbnQnLFxuICAgICdmb2FtLmNvcmUuSW1wb3J0cydcbiAgXSxcblxuICBjb25zdGFudHM6IHtcbiAgICBPVVRQVVRURVI6IHtcbiAgICAgIF9fcHJvdG9fXzogZm9hbS5qc29uLlN0cmljdCxcbiAgICAgIG91dHB1dERlZmF1bHRWYWx1ZXM6IGZhbHNlLFxuICAgICAgb3V0cHV0Q2xhc3NOYW1lczogZmFsc2VcbiAgICB9XG4gIH0sXG5cbiAgcHJvcGVydGllczogW1xuICAgIHtcbiAgICAgIC8qKiBUaGUgcGF0aCBwcmVmaXguIFBhcmFtZXRlcnMgbWF5IGFkZCB0byB0aGUgcGF0aCAqL1xuICAgICAgbmFtZTogJ3BhdGgnXG4gICAgfSxcbiAgICB7XG4gICAgICBuYW1lOiAnaHR0cE1ldGhvZCcsXG4gICAgICB2YWx1ZTogJ0dFVCcsXG4gICAgfSxcbiAgICB7XG4gICAgICAvKiogVGhlIGFyZ3MgdG8gY2FsbCB3aXRoLCBpbiBvcmRlciAqL1xuICAgICAgY2xhc3M6ICdGT2JqZWN0QXJyYXknLFxuICAgICAgbmFtZTogJ2FyZ3MnLFxuICAgICAgb2Y6ICdmb2FtLm5ldC5IVFRQQXJndW1lbnQnLFxuICAgICAgZmFjdG9yeTogZnVuY3Rpb24oKSB7IHJldHVybiBbXTsgfVxuICAgIH0sXG4gICAge1xuICAgICAgLyoqIElmIHRoZSByZXF1ZXN0IHNob3VsZCBidWlsZCBhIHJlcXVlc3QgYm9keSBvYmplY3QgYW5kIGZpbGwgaW4gdGhlXG4gICAgICAgIHN1cHBsaWVkIGFyZ3MsIHRoZSByZXF1ZXN0IG9iamVjdCdzIENsYXNzIGlzIHNwZWNpZmllZCBoZXJlLiAqL1xuICAgICAgY2xhc3M6ICdDbGFzcycsXG4gICAgICBuYW1lOiAnYnVpbGRSZXF1ZXN0VHlwZScsXG4gICAgfSxcbiAgICB7XG4gICAgICAvKiogSFRUUE1ldGhvZHMgd2lsbCBhbHdheXMgcmV0dXJuIGEgUHJvbWlzZSwgYnV0IHRoZSBQcm9taXNlIHdpbGwgcGFzc1xuICAgICAgICBhbG9uZyBhIHBhcmFtZXRlciBvZiB0aGUgdHlwZSBzcGVjaWZpZWQgaGVyZS4gKi9cbiAgICAgIG5hbWU6ICdwcm9taXNlZFR5cGUnLFxuICAgICAgb2Y6ICdmb2FtLmNvcmUuQXJndW1lbnQnXG4gICAgfSxcbiAgICBbICdyZXR1cm5zJywgJ1Byb21pc2UnIF0sXG4gICAge1xuICAgICAgLyoqIFRoZSBuYW1lIG9mIHRoZSBIVFRQIGZhY3RvcnkgdG8gaW1wb3J0IGF0IHJ1biB0aW1lLiBJbnN0YW5jZXMgb2ZcbiAgICAgICAgSFRUUE1ldGhvZCBvbiBhIGNsYXNzIHdpbGwgY2F1c2UgdGhlIGNsYXNzIHRvIGltcG9ydCB0aGlzIG5hbWUsIGFuZFxuICAgICAgICB3aGVuIGNhbGxlZCB3aWxsIGNhbGwgaG9zdEluc3RhbmNlLnlvdXJIdHRwRmFjdG9yeU5hbWUuY3JlYXRlKCkgdG9cbiAgICAgICAgY3JlYXRlIGEgcGFydGlhbGx5IGZpbGxlZCByZXF1ZXN0IG9iamVjdC4gKi9cbiAgICAgIG5hbWU6ICdIVFRQUmVxdWVzdEZhY3RvcnlOYW1lJyxcbiAgICAgIHZhbHVlOiAnSFRUUFJlcXVlc3RGYWN0b3J5J1xuICAgIH0sXG4gICAge1xuICAgICAgbmFtZTogJ2NvZGUnLFxuICAgICAgcmVxdWlyZWQ6IGZhbHNlLFxuICAgICAgdHJhbnNpZW50OiB0cnVlLFxuICAgICAgZXhwcmVzc2lvbjogZnVuY3Rpb24oYXJncykge1xuICAgICAgICAvLyBzZXQgdXAgZnVuY3Rpb24gd2l0aCBjb3JyZWN0IGFyZ3MsIHBhc3MgdGhlbSBpbnRvIHRoZVxuICAgICAgICAvLyBhY3R1YWwgaW1wbGVtZW50YXRpb24sIGNhbGxSZW1vdGVfKClcbiAgICAgICAgdmFyIGF4aW9tID0gdGhpcztcbiAgICAgICAgLy8gR2V0IGxpc3Qgb2YgYXJndW1lbnQgbmFtZXNcbiAgICAgICAgdmFyIGFyZ05hbWVzID0gYXJncy5tYXAoYXhpb20uSFRUUEFyZ3VtZW50Lk5BTUUuZik7XG4gICAgICAgIC8vIGxvYWQgbmFtZWQgdmFsdWVzIGludG8gb3B0X2FyZ3Mgb2JqZWN0IGFuZCBwYXNzIHRvIHRoZSBnZW5lcmljIGNhbGxSZW1vdGVfKClcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHZhciBvcHRfYXJncyA9IHt9O1xuICAgICAgICAgIGZvciAoIHZhciBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGggJiYgaSA8IGFyZ05hbWVzLmxlbmd0aDsgaSArKyApIHtcbiAgICAgICAgICAgIG9wdF9hcmdzW2FyZ05hbWVzW2ldXSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGF4aW9tLmNhbGxSZW1vdGVfKG9wdF9hcmdzLCB0aGlzKTtcbiAgICAgICAgfVxuXG4gICAgICB9XG4gICAgfVxuICBdLFxuXG4gIG1ldGhvZHM6IFtcbiAgICBmdW5jdGlvbiBpbnN0YWxsSW5DbGFzcyhjKSB7XG4gICAgICAvLyBhZGQgYW4gaW1wb3J0IGZvciB0aGUgSFRUUFJlcXVlc3RGYWN0b3J5IG9uIG91ciBob3N0IGNsYXNzXG5cbiAgICAgIC8vIE1heSBoYXZlIG1hbnkgSFRUUE1ldGhvZHMgaW4gYSBob3N0IGNsYXNzLCBidXQgb25seSBkbyBzZXJ2aWNlIGltcG9ydCBvbmNlLlxuICAgICAgdmFyIGV4aXN0aW5nID0gYy5nZXRBeGlvbUJ5TmFtZSh0aGlzLkhUVFBSZXF1ZXN0RmFjdG9yeU5hbWUpO1xuICAgICAgZm9hbS5hc3NlcnQoIGV4aXN0aW5nLFxuICAgICAgICBcIkhUVFBNZXRob2QgaW5zdGFsbEluQ2xhc3MgZGlkIG5vdCBmaW5kIGFuIGltcG9ydCBvciBwcm9wZXJ0eVwiLCB0aGlzLkhUVFBSZXF1ZXN0RmFjdG9yeU5hbWUsIFwiLlwiLFxuICAgICAgICBcIlByb3ZpZGUgb25lLCBvciBzZXQgSFRUUE1ldGhvZC5IVFRQUmVxdWVzdEZhY3RvcnlOYW1lIHRvIHRoZSBuYW1lIG9mIHlvdXIgcmVxdWVzdCBmYWN0b3J5IGZ1bmN0aW9uLlwiKTtcbiAgICB9LFxuXG4gICAgZnVuY3Rpb24gaW5zdGFsbEluUHJvdG8ocCkge1xuICAgICAgLy8gc2V0IGNvZGUgb24gcHJvdG9cbiAgICAgIHBbdGhpcy5uYW1lXSA9IHRoaXMuY29kZTtcbiAgICB9LFxuXG4gICAgZnVuY3Rpb24gY2FsbFJlbW90ZV8ob3B0X2FyZ3MsIGhvc3QpIHtcbiAgICAgIGZvYW0uYXNzZXJ0KCB0eXBlb2YgaG9zdFt0aGlzLkhUVFBSZXF1ZXN0RmFjdG9yeU5hbWVdID09PSAnZnVuY3Rpb24nLFxuICAgICAgICBcIkhUVFBNZXRob2QgY2FsbCBjYW4ndCBmaW5kIEhUVFBSZXF1ZXN0RmFjdG9yeVwiLFxuICAgICAgICB0aGlzLkhUVFBSZXF1ZXN0RmFjdG9yeU5hbWUsIFwib25cIiwgaG9zdCk7XG5cbiAgICAgIC8vICd0aGlzJyBpcyB0aGUgYXhpb20gaW5zdGFuY2VcbiAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgIHZhciBwYXRoID0gdGhpcy5wYXRoO1xuICAgICAgdmFyIHF1ZXJ5ID0gXCJcIjtcbiAgICAgIHZhciByZXF1ZXN0ID0gaG9zdFt0aGlzLkhUVFBSZXF1ZXN0RmFjdG9yeU5hbWVdKCk7XG5cbiAgICAgIC8vIGlmIGJ1aWxkaW5nIGEgcmVxdWVzdCBvYmplY3QsIHN0YXJ0IHdpdGggYW4gZW1wdHkgaW5zdGFuY2VcbiAgICAgIHZhciByZXF1ZXN0T2JqZWN0ID0gc2VsZi5idWlsZFJlcXVlc3RUeXBlID9cbiAgICAgICAgc2VsZi5idWlsZFJlcXVlc3RUeXBlLmNyZWF0ZSh1bmRlZmluZWQsIGZvYW0uX19jb250ZXh0X18pIDogbnVsbDtcblxuICAgICAgLy8gYWRkIG9uIGFyZ3MgcGFzc2VkIGFzIHBhcnQgb2YgdGhlIHBhdGggb3IgcXVlcnlcbiAgICAgIHNlbGYuYXJncy5mb3JFYWNoKGZ1bmN0aW9uKHBhcmFtKSB7XG4gICAgICAgIHZhciB2YWwgPSBvcHRfYXJnc1twYXJhbS5uYW1lXTtcbiAgICAgICAgaWYgKCB0eXBlb2YgdmFsID09PSAndW5kZWZpbmVkJyApIHJldHVybjsgLy8gc2tpcCBtaXNzaW5nIGFyZ3MgLy8gVE9ETzogYXNzZXJ0IG5vbi1vcHRpb25hbFxuXG4gICAgICAgIC8vIHB1dCB0aGUgZG90IGJhY2sgaWYgd2UgcmVtb3ZlZCBvbmUgZnJvbSB0aGUgbmFtZVxuICAgICAgICB2YXIgcG5hbWUgPSBwYXJhbS5uYW1lLnJlcGxhY2UoJ19fZG90X18nLCcuJyk7XG4gICAgICAgIGlmICggcGFyYW0ubG9jYXRpb24gPT09ICdib2R5JyApIHtcbiAgICAgICAgICAvLyBzZXQgdGhlIHJlcXVlc3QgYm9keSBjb250ZW50XG4gICAgICAgICAgLy8gVE9ETzogYXNzZXJ0IGl0J3MgdGhlIGZpcnN0IHBhcmFtLCBubyBtb3JlIHRoYW4gb25lIGJvZHlcbiAgICAgICAgICBpZiAoIHJlcXVlc3RPYmplY3QgKSB7XG4gICAgICAgICAgICB0aHJvdyBcIkNhbid0IHNldCBib3RoIFJlcXVlc3RPYmplY3QgXCIgK1xuICAgICAgICAgICAgICBzZWxmLmJ1aWxkUmVxdWVzdFR5cGUgKyBcIiBhbmQgcGFyYW0ubG9jYXRpb249PWJvZHkgZm9yIFwiICsgcG5hbWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJlcXVlc3QucGF5bG9hZCA9IHNlbGYuT1VUUFVUVEVSLnN0cmluZ2lmeSh2YWwpO1xuICAgICAgICB9IGVsc2UgaWYgKCBwYXJhbS5sb2NhdGlvbiA9PT0gJ3BhdGgnICkge1xuICAgICAgICAgIC8vIGZpbmQgdGhlIHBsYWNlaG9sZGVyIGFuZCByZXBsYWNlIGl0XG4gICAgICAgICAgcGF0aCA9IHBhdGgucmVwbGFjZShcIntcIitwbmFtZStcIn1cIiwgdmFsLnRvU3RyaW5nKCkpO1xuICAgICAgICAgIGlmICggcmVxdWVzdE9iamVjdCApIHJlcXVlc3RPYmplY3RbcG5hbWVdID0gdmFsO1xuICAgICAgICB9IGVsc2UgaWYgKCBwYXJhbS5sb2NhdGlvbiA9PT0gJ3F1ZXJ5JyApIHtcbiAgICAgICAgICAvLyBhZGQgdG8gcXVlcnkgc3RyaW5nXG4gICAgICAgICAgcXVlcnkgKz0gXCImXCIgKyBwbmFtZSArIFwiPVwiICsgdmFsLnRvU3RyaW5nKCk7XG4gICAgICAgICAgaWYgKCByZXF1ZXN0T2JqZWN0ICkgcmVxdWVzdE9iamVjdFtwbmFtZV0gPSB2YWw7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcGF0aCA9IHBhdGggKyAoIHF1ZXJ5ID8gXCI/XCIgKyBxdWVyeS5zdWJzdHJpbmcoMSkgOiBcIlwiICk7XG4gICAgICByZXF1ZXN0LnBhdGggKz0gcGF0aDtcbiAgICAgIHJlcXVlc3QubWV0aG9kID0gc2VsZi5odHRwTWV0aG9kO1xuICAgICAgaWYgKCByZXF1ZXN0T2JqZWN0ICkge1xuICAgICAgICByZXF1ZXN0LnBheWxvYWQgPSBzZWxmLk9VVFBVVFRFUi5zdHJpbmdpZnkocmVxdWVzdE9iamVjdCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXF1ZXN0LnNlbmQoKS50aGVuKGZ1bmN0aW9uKHJlc3BvbnNlKSB7XG4gICAgICAgIGlmICggcmVzcG9uc2Uuc3RhdHVzID49IDQwMCApIHtcbiAgICAgICAgICB0aHJvdyBcIkhUVFAgZXJyb3Igc3RhdHVzOiBcIiArIHJlc3BvbnNlLnN0YXR1cztcbiAgICAgICAgfVxuICAgICAgICBmb2FtLmFzc2VydChyZXNwb25zZS5yZXNwb25zZVR5cGUgPT09ICdqc29uJywgXCJIVFRQTWV0aG9kIGdpdmVuIGEgcmVxdWVzdCBub3QgY29uZmlndXJlZCB0byByZXR1cm4gSlNPTlwiLCByZXF1ZXN0KTtcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlLnBheWxvYWQudGhlbihmdW5jdGlvbihqc29uKSB7XG4gICAgICAgICAgaWYgKCAhIHNlbGYucHJvbWlzZWRUeXBlICkge1xuICAgICAgICAgICAgLy8gbm8gcmV0dXJuXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICggISBzZWxmLnByb21pc2VkVHlwZS50eXBlICkgeyAvLyBUT0RPOiBzaG91bGQgbm90IG5lZWQgdGhpcyBjaGVjay4gR2V0dGVyIGluIEFyZy50eXBlP1xuICAgICAgICAgICAgc2VsZi5wcm9taXNlZFR5cGUudHlwZSA9IHRoaXMubG9va3VwKHNlbGYucHJvbWlzZWRUeXBlLnR5cGVOYW1lLCB0cnVlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCBzZWxmLnByb21pc2VkVHlwZS50eXBlICkge1xuICAgICAgICAgICAgLy8gYSBtb2RlbGxlZCByZXR1cm4gdHlwZVxuICAgICAgICAgICAgcmV0dXJuIHNlbGYucHJvbWlzZWRUeXBlLnR5cGUuY3JlYXRlKGpzb24sIGhvc3QpO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBlbHNlIHJldHVybiByYXcganNvblxuICAgICAgICAgIHJldHVybiBqc29uO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH1cbiAgXVxufSk7XG5cblxuZm9hbS5DTEFTUyh7XG4gIHBhY2thZ2U6ICdmb2FtLm5ldCcsXG4gIG5hbWU6ICdIVFRQQXJndW1lbnQnLFxuICBleHRlbmRzOiAnZm9hbS5jb3JlLkFyZ3VtZW50JyxcblxuICBwcm9wZXJ0aWVzOiBbXG4gICAge1xuICAgICAgLyoqIFRoZSBsb2NhdGlvbiB0byBwdXQgdGhpcyB2YWx1ZSBpbiB0aGUgcmVxdWVzdDogJ3F1ZXJ5JywgJ3BhdGgnLCBvciAnYm9keScgKi9cbiAgICAgIG5hbWU6ICdsb2NhdGlvbicsXG4gICAgICB2YWx1ZTogJ3F1ZXJ5JyxcbiAgICB9XG4gIF1cbn0pO1xuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTYgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuKGZ1bmN0aW9uKCkge1xuICB2YXIgcGtnID0gJ2ZvYW0ubmV0LicgKyAoZm9hbS5pc1NlcnZlciA/ICdub2RlJyA6ICd3ZWInKTtcbiAgdmFyIGNsc3MgPSBbXG4gICAgJ0Jhc2VIVFRQUmVxdWVzdCcsXG4gICAgJ0hUVFBSZXF1ZXN0JyxcbiAgICAnSFRUUFJlc3BvbnNlJyxcbiAgICAnV2ViU29ja2V0JyxcbiAgICAnV2ViU29ja2V0U2VydmljZSdcbiAgXTtcblxuICAvLyBGb3IgZWFjaCBjbGFzcyB3aXRoIGEgXCJ3ZWJcIiAoYnJvd3NlcikgYW5kIFwibm9kZVwiIChOb2RlIEpTKVxuICAvLyBpbXBsZW1lbnRhdGlvbiwgcmVnaXN0ZXIgXCJmb2FtLm5ldC5bZW52aXJvbm1lbnRdLltjbGFzc11cIiBhc1xuICAvLyBcImZvYW0ubmV0LltjbGFzc11cIi5cbiAgLy9cbiAgLy8gVE9ETzogVGhpcyBzaG91bGQgYmUgcHJvdmlkZWQgdmlhIGEgc29ydCBvZiBcIkNvbnRleHRGYWN0b3J5XCIgb3Igc2ltaWxhci5cbiAgZm9yICggdmFyIGkgPSAwOyBpIDwgY2xzcy5sZW5ndGg7IGkrKyApIHtcbiAgICBmb2FtLnJlZ2lzdGVyKGZvYW0ubG9va3VwKHBrZyArICcuJyArIGNsc3NbaV0pLCAnZm9hbS5uZXQuJyArIGNsc3NbaV0pO1xuICB9XG59KSgpO1xuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgVGhlIEZPQU0gQXV0aG9ycy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuZm9hbS5DTEFTUyh7XG4gIHBhY2thZ2U6ICdmb2FtLm5ldCcsXG4gIG5hbWU6ICdSZXRyeUhUVFBSZXF1ZXN0JyxcbiAgZXh0ZW5kczogJ2ZvYW0ubmV0LkJhc2VIVFRQUmVxdWVzdCcsXG5cbiAgZG9jdW1lbnRhdGlvbjogYEhUVFAgcmVxdWVzdCBmb3IgcmV0cnlpbmcgcmVxdWVzdHMgdGhhdCBmYWlsIGF0IHRoZSBzZXJ2aWNlXG4gICAgICBsZXZlbDsgZS5nLiwgbmV0d29yayB0aW1lb3V0LCBjb25uZWN0aW9uIHJlc2V0LiBUaGlzIGNsYXNzIGRvZXMgbm90IGNoZWNrXG4gICAgICBIVFRQIHN0YXR1cyBjb2RlcywgaXQgc2ltcGx5IHJldHJpZXMgcmVxdWVzdHMgdGhhdCByZWplY3Qtb24tc2VuZCgpLmAsXG5cbiAgcmVxdWlyZXM6IFsgJ2ZvYW0ubmV0LkJhc2VIVFRQUmVxdWVzdCcgXSxcbiAgaW1wb3J0czogWyAnZXJyb3InLCAnd2FybicgXSxcblxuICBwcm9wZXJ0aWVzOiBbXG4gICAge1xuICAgICAgY2xhc3M6ICdJbnQnLFxuICAgICAgbmFtZTogJ251bVRyaWVzJyxcbiAgICAgIHZhbHVlOiA0XG4gICAgfSxcbiAgICB7XG4gICAgICBjbGFzczogJ1Byb3h5JyxcbiAgICAgIG9mOiAnZm9hbS5uZXQuQmFzZUhUVFBSZXF1ZXN0JyxcbiAgICAgIG5hbWU6ICdkZWxlZ2F0ZScsXG4gICAgICBmYWN0b3J5OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuQmFzZUhUVFBSZXF1ZXN0LmNyZWF0ZSh0aGlzKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHtcbiAgICAgIGNsYXNzOiAnSW50JyxcbiAgICAgIG5hbWU6ICdjdXJyZW50VHJ5XydcbiAgICB9XG4gIF0sXG5cbiAgbWV0aG9kczogW1xuICAgIGZ1bmN0aW9uIHNlbmQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5kZWxlZ2F0ZS5zZW5kKCkuY2F0Y2godGhpcy5vbkVycm9yKTtcbiAgICB9XG4gIF0sXG5cbiAgbGlzdGVuZXJzOiBbXG4gICAgZnVuY3Rpb24gb25FcnJvcihlcnJvcikge1xuICAgICAgdGhpcy5jdXJyZW50VHJ5XysrO1xuICAgICAgdGhpcy53YXJuKCdSZXRyeUhUVFBSZXF1ZXN0OiBUcnkgIycgKyB0aGlzLmN1cnJlbnRUcnlfICtcbiAgICAgICAgICAgICAgICAnIGZhaWxlZCBvbiAnICsgZXJyb3IpO1xuICAgICAgaWYgKCB0aGlzLmN1cnJlbnRUcnlfIDwgdGhpcy5udW1UcmllcyApIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VuZCgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5lcnJvcignUmV0cnlIVFRQUmVxdWVzdDogTWF4IHRyaWVzIHJlYWNoZWQnKTtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdSZXRyeUhUVFBSZXF1ZXN0OiBNYXggdHJpZXMgcmVhY2hlZCcpO1xuICAgICAgfVxuICAgIH1cbiAgXVxufSk7XG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBUaGUgRk9BTSBBdXRob3JzLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5mb2FtLkNMQVNTKHtcbiAgcGFja2FnZTogJ2ZvYW0ubmV0LmF1dGgnLFxuICBuYW1lOiAnVG9rZW5CZWFyZXJDcmVkZW50aWFsJyxcblxuICBkb2N1bWVudGF0aW9uOiBgRGF0YSBjbGFzcyBmb3IgXCJBdXRob3JpemF0aW9uOiBCZWFyZXIgPGFjY2VzcyB0b2tlbj5cIi1zdHlsZVxuICAgICAgYXV0aGVudGljYXRpb24uYCxcblxuICBwcm9wZXJ0aWVzOiBbXG4gICAge1xuICAgICAgY2xhc3M6ICdTdHJpbmcnLFxuICAgICAgZG9jdW1lbnRhdGlvbjogYFRva2VuIHVzZWQgZm9yIFwiQXV0aG9yaXphdGlvbjogQmVhcmVyIDx0b2tlbj5cIi1zdHlsZSBIVFRQXG4gICAgICAgICAgcmVxdWVzdCBhdXRoZW50aWNhdGlvbi5gLFxuICAgICAgbmFtZTogJ2FjY2Vzc1Rva2VuJ1xuICAgIH0sXG4gICAge1xuICAgICAgY2xhc3M6ICdJbnQnLFxuICAgICAgZG9jdW1lbnRhdGlvbjogYGRhdGUuZ2V0VGltZSgpLXN0eWxlIHRpbWUgc3RhbXAgb2YgXCJhY2Nlc3NUb2tlblwiXG4gICAgICAgICAgZXhwaXJhdGlvbi5gLFxuICAgICAgbmFtZTogJ2V4cGlyeSdcbiAgICB9XG4gIF1cbn0pO1xuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgVGhlIEZPQU0gQXV0aG9ycy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuZm9hbS5DTEFTUyh7XG4gIHBhY2thZ2U6ICdmb2FtLm5ldC5hdXRoJyxcbiAgbmFtZTogJ0F1dGhBd2FyZUhUVFBSZXF1ZXN0JyxcbiAgZXh0ZW5kczogJ2ZvYW0ubmV0LkJhc2VIVFRQUmVxdWVzdCcsXG5cbiAgZG9jdW1lbnRhdGlvbjogJ0Fic3RyYWN0IGNsYXNzIGZvciBIVFRQIHJlcXVlc3RzIHRoYXQgcmVxdWlyZSBhdXRob3JpemF0aW9uLicsXG5cbiAgcmVxdWlyZXM6IFsgJ2ZvYW0ubmV0LkJhc2VIVFRQUmVxdWVzdCcgXSxcbiAgaW1wb3J0czogWyAnYXV0aEFnZW50PyBhcyBjdHhBdXRoQWdlbnQnIF0sXG5cbiAgcHJvcGVydGllczogW1xuICAgIHtcbiAgICAgIGNsYXNzOiAnUHJveHknLFxuICAgICAgb2Y6ICdmb2FtLm5ldC5CYXNlSFRUUFJlcXVlc3QnLFxuICAgICAgbmFtZTogJ2RlbGVnYXRlJyxcbiAgICAgIGZhY3Rvcnk6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5CYXNlSFRUUFJlcXVlc3QuY3JlYXRlKHRoaXMpO1xuICAgICAgfVxuICAgIH0sXG4gICAge1xuICAgICAgY2xhc3M6ICdGT2JqZWN0UHJvcGVydHknLFxuICAgICAgb2Y6ICdmb2FtLm5ldC5hdXRoLkF1dGhBZ2VudCcsXG4gICAgICBuYW1lOiAnYXV0aEFnZW50JyxcbiAgICAgIGZhY3Rvcnk6IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcy5jdHhBdXRoQWdlbnQgfHwgbnVsbDsgfVxuICAgIH1cbiAgXSxcblxuICBtZXRob2RzOiBbXG4gICAgZnVuY3Rpb24gc2VuZCgpIHtcbiAgICAgIHZhciBzZW5kID0gdGhpcy5kZWxlZ2F0ZS5zZW5kLmJpbmQodGhpcy5kZWxlZ2F0ZSk7XG4gICAgICBpZiAoICEgdGhpcy5hdXRoQWdlbnQgKSByZXR1cm4gc2VuZCgpO1xuICAgICAgaWYgKCAhIHRoaXMuYXV0aEFnZW50LnJlcXVpcmVzQXV0aG9yaXphdGlvbih0aGlzKSApIHJldHVybiBzZW5kKCk7XG5cbiAgICAgIHJldHVybiB0aGlzLmF1dGhBZ2VudC5nZXRDcmVkZW50aWFsKCkudGhlbih0aGlzLm9uR2V0Q3JlZGVudGlhbClcbiAgICAgICAgICAudGhlbihzZW5kKS50aGVuKHRoaXMub25BdXRob3JpemVkUmVzcG9uc2UpO1xuICAgIH1cbiAgXSxcblxuICBsaXN0ZW5lcnM6IFtcbiAgICB7XG4gICAgICBuYW1lOiAnb25HZXRDcmVkZW50aWFsJyxcbiAgICAgIGRvY3VtZW50YXRpb246ICdQcmVwYXJlIHJlcXVlc3QgdXNpbmcgY3JlZGVudGlhbCBmcm9tIFwiYXV0aEFnZW50XCIuJyxcbiAgICAgIGNvZGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJBYnN0cmFjdCBBdXRoQXdhcmVIVFRQUmVxdWVzdCBkb2Vzbid0IHVuZGVyc3RhbmQgXCIgK1xuICAgICAgICAgICAgJ2NyZWRlbnRpYWxzJyk7XG4gICAgICB9XG4gICAgfSxcbiAgICB7XG4gICAgICBuYW1lOiAnb25BdXRob3JpemVkUmVzcG9uc2UnLFxuICAgICAgZG9jdW1lbnRhdGlvbjogYENoZWNrIHJlc3BvbnNlIG9uIGF1dGhvcml6ZWQgcmVxdWVzdCBmb3IgSFRUUCA0MDEsIGluXG4gICAgICAgICAgd2hpY2ggY2FzZSwgcmV0cnkuYCxcbiAgICAgIGNvZGU6IGZ1bmN0aW9uKHJlc3BvbnNlKSB7XG4gICAgICAgIGlmICggcmVzcG9uc2Uuc3RhdHVzICE9PSA0MDEgKSByZXR1cm4gcmVzcG9uc2U7XG5cbiAgICAgICAgdmFyIHNlbmQgPSB0aGlzLmRlbGVnYXRlLnNlbmQuYmluZCh0aGlzLmRlbGVnYXRlKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXV0aEFnZW50LnJlZnJlc2hDcmVkZW50aWFsKCkudGhlbih0aGlzLm9uR2V0Q3JlZGVudGlhbClcbiAgICAgICAgICAgIC50aGVuKHNlbmQpLnRoZW4odGhpcy5vblJldHJ5UmVzcG9uc2UpO1xuICAgICAgfVxuICAgIH0sXG4gICAge1xuICAgICAgbmFtZTogJ29uUmV0cnlSZXNwb25zZScsXG4gICAgICBkb2N1bWVudGF0aW9uOiBgQ2hlY2sgcmVzcG9uc2Ugb24gYXV0aG9yaXplZCByZXF1ZXN0IGZvciBIVFRQIDQwMSwgaW5cbiAgICAgICAgICB3aGljaCBjYXNlLCB0aHJvdzogZm9yY2VkICBjcmVkZW50aWFsIHJlZnJlc2ggZGlkbid0IHdvcmsuYCxcbiAgICAgIGNvZGU6IGZ1bmN0aW9uKHJlc3BvbnNlKSB7XG4gICAgICAgIGlmICggcmVzcG9uc2Uuc3RhdHVzICE9PSA0MDEgKSByZXR1cm4gcmVzcG9uc2U7XG5cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdBdXRob3JpemF0aW9uIGZhaWxlZDogUmVxdWVzdCByZWplY3RlZCBhZnRlciBmb3JjZWQgY3JlZGVudGlhbCByZWZyZXNoJyk7XG4gICAgICB9XG4gICAgfVxuICBdXG59KTtcbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IFRoZSBGT0FNIEF1dGhvcnMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmZvYW0uQ0xBU1Moe1xuICBwYWNrYWdlOiAnZm9hbS5uZXQuYXV0aCcsXG4gIG5hbWU6ICdUb2tlbkJlYXJlckhUVFBSZXF1ZXN0JyxcbiAgZXh0ZW5kczogJ2ZvYW0ubmV0LmF1dGguQXV0aEF3YXJlSFRUUFJlcXVlc3QnLFxuXG4gIGRvY3VtZW50YXRpb246IGBBdXRoLWF3YXJlIEhUVFAgcmVxdWVzdCB0aGF0IHVzZXMgdGhlIFRPS0VOX0JFQVJFUlxuICAgICAgQ3JlZGVudGlhbFR5cGUgZm9yIFwiQXV0aG9yaXphdGlvbjogQmVhcmVyIDxhY2Nlc3MgdG9rZW4+XCItc3R5bGVcbiAgICAgIGF1dGhvcml6YXRpb24uYCxcblxuICBsaXN0ZW5lcnM6IFtcbiAgICBmdW5jdGlvbiBvbkdldENyZWRlbnRpYWwoY3JlZGVudGlhbCkge1xuICAgICAgdGhpcy5kZWxlZ2F0ZS5oZWFkZXJzWydBdXRob3JpemF0aW9uJ10gPVxuICAgICAgICAgICdCZWFyZXIgJyArIGNyZWRlbnRpYWwuYWNjZXNzVG9rZW47XG4gICAgfVxuICBdXG59KTtcbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IFRoZSBGT0FNIEF1dGhvcnMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmZvYW0uQ0xBU1Moe1xuICBwYWNrYWdlOiAnZm9hbS5uZXQuYXV0aCcsXG4gIG5hbWU6ICdBdXRoQWdlbnQnLFxuXG4gIGRvY3VtZW50YXRpb246IGBBbiBhZ2VudCB0aGF0IGlzIGFibGUgdG8gYXV0aGVudGljYXRlIG9uIGFwcGxpY2F0aW9uJ3MgYmVoYWxmXG4gICAgICBmb3IgSFRUUCByZXF1ZXN0cyB0aGF0IHJlcXVpcmUgYXV0aG9yaXphdGlvbi4gSW1wbGVtZW50YXRpb25zIG11c3QgZG8gdGhlXG4gICAgICBmb2xsb3dpbmc6XG5cbiAgICAgICgwKSBFeHBvcnQgc2VsZiBhcyBcImF1dGhBZ2VudFwiIChhbHJlYWR5IGRvbmUgaW4gYmFzZSBjbGFzcyk7XG4gICAgICAoMSkgUmVnaXN0ZXIgYW4gYXV0by1hdXRoZW50aWNhdGluZyBIVFRQUmVxdWVzdCBhcyAnZm9hbS5uZXQuSFRUUFJlcXVlc3QnXG4gICAgICAgICAgaW4gYWdlbnRzJyBzdWItY29udGV4dHM7XG4gICAgICAoMikgSW1wbGVtZW50IGdldENyZWRlbnRpYWwoKSBhbmQgcmVmcmVzaENyZWRlbnRpYWwoKS5cblxuICAgICAgQ2xpZW50cyBpbnN0YW50aWF0aW5nIGFnZW50cyBtdXN0IHByb3ZpZGUgYSByZXF1aXJlc0F1dGhvcml6YXRpb24ocmVxdWVzdClcbiAgICAgIGltcGxlbWVudGF0aW9uOyB0aGlzIGFsbG93cyBhdXRoZW50aWNhdGluZyBIVFRQUmVxdWVzdHMgdG8gZGV0ZXJtaW5lXG4gICAgICB3aGV0aGVyIG9yIG5vdCB0byBhdXRoZW50aWNhdGUgYmVmb3JlIGF0dGVtcHRpbmcgYSByZXF1ZXN0LmAsXG5cbiAgZXhwb3J0czogWyAnYXMgYXV0aEFnZW50JyBdLFxuXG4gIHByb3BlcnRpZXM6IFtcbiAgICB7XG4gICAgICBjbGFzczogJ0Z1bmN0aW9uJyxcbiAgICAgIGRvY3VtZW50YXRpb246IGBEZXRlcm1pbmUgd2hldGhlciBvciBub3QgYSBVUkwgcmVxdWlyZXMgYXV0aG9yaXphdGlvblxuICAgICAgICAgIHZpYSBhbiBhdXRoZW50aWNhdGlvbiBzdGVwIG1hbmFnZWQgYnkgdGhpcyBhZ2VudC4gVGhpcyBwcm9jZWR1cmUgaXNcbiAgICAgICAgICB0cmVhdGVkIGFzIGRhdGEgcmF0aGVyIHRoYW4gYSBtZXRob2QgYmVjYXVzZSBpdCBpcyB0eXBpY2FsbHkgaW5qZWN0ZWRcbiAgICAgICAgICBmb3IgYW4gYWdlbnQgYXQgcnVudGltZS4gRS5nLiwgYSBwYXJ0aWN1bGFyIEdvb2dsZSAyTE8gYWdlbnQgd291bGQgYmVcbiAgICAgICAgICBib3VuZCB0byBwYXJ0aWN1bGFyIFVSTHMgYW5kIHBhcnRpY3VsYXIgc2NvcGVzLmAsXG4gICAgICBuYW1lOiAncmVxdWlyZXNBdXRob3JpemF0aW9uJyxcbiAgICAgIHJlcXVpcmVkOiB0cnVlXG4gICAgfSxcbiAgXSxcblxuICBtZXRob2RzOiBbXG4gICAgZnVuY3Rpb24gaW5pdCgpIHtcbiAgICAgIHRoaXMudmFsaWRhdGUoKTtcbiAgICAgIHRoaXMuU1VQRVIoKTtcbiAgICB9LFxuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKCkge1xuICAgICAgdGhpcy5TVVBFUigpO1xuICAgICAgZm9hbS5hc3NlcnQoXG4gICAgICAgICAgdGhpcy5fX2NvbnRleHRfXy5sb29rdXAoJ2ZvYW0ubmV0LkJhc2VIVFRQUmVxdWVzdCcpICE9PVxuICAgICAgICAgICAgICB0aGlzLl9fc3ViQ29udGV4dF9fLmxvb2t1cCgnZm9hbS5uZXQuSFRUUFJlcXVlc3QnKSxcbiAgICAgICAgICAnQXV0aEFnZW50IGltcGxlbWVudGF0aW9uIG11c3QgcmVnaXN0ZXIgaXRzIEhUVFBSZXF1ZXN0IGRlY29yYXRvciAnICtcbiAgICAgICAgICAgICAgJ2FzIGZvYW0ubmV0LkhUVFBSZXF1ZXN0Jyk7XG4gICAgfSxcbiAgICB7XG4gICAgICBuYW1lOiAnZ2V0Q3JlZGVudGlhbCcsXG4gICAgICBkb2N1bWVudGF0aW9uOiAnQXluY2hyb25vdXNseSBnZXQgYW4gdW5leHBpcmVkIGNyZWRlbnRpYWwuJyxcbiAgICAgIGNvZGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKCdVbmFibGUgdG8gZ2V0IGNyZWRlbnRpYWwnKSk7XG4gICAgICB9XG4gICAgfSxcbiAgICB7XG4gICAgICBuYW1lOiAncmVmcmVzaENyZWRlbnRpYWwnLFxuICAgICAgZG9jdW1lbnRhdGlvbjogJ0F5bmNocm9ub3VzbHkgZ2V0IGEgbmV3IGNyZWRlbnRpYWwuJyxcbiAgICAgIGNvZGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKCdVbmFibGUgdG8gcmVmcmVzaCBjcmVkZW50aWFsJykpO1xuICAgICAgfVxuICAgIH1cbiAgXVxufSk7XG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG4vL1xuLy8gUmVmaW5lIHN0ZGxpYiB0eXBlcyB0byBpbXBsZW1lbnQgdG9EYXRhc3RvcmVWYWx1ZShvKS5cbi8vXG5cbmZvYW0uTElCKHtcbiAgbmFtZTogJ2ZvYW0uVW5kZWZpbmVkJyxcblxuICBtZXRob2RzOiBbXG4gICAgZnVuY3Rpb24gdG9EYXRhc3RvcmVWYWx1ZSgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQXR0ZW1wdCB0byB1c2UgdW5kZWZpbmVkIGFzIGRhdGFzdG9yZSB2YWx1ZScpO1xuICAgIH1cbiAgXVxufSk7XG5cbmZvYW0uTElCKHtcbiAgbmFtZTogJ2ZvYW0uTnVsbCcsXG5cbiAgbWV0aG9kczogW1xuICAgIHtcbiAgICAgIG5hbWU6ICd0b0RhdGFzdG9yZVZhbHVlJyxcbiAgICAgIGNvZGU6IChmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIE5VTEwgPSB7IG51bGxWYWx1ZTogbnVsbCB9O1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gdG9EYXRhc3RvcmVWYWx1ZSgpIHsgcmV0dXJuIE5VTEw7IH07XG4gICAgICB9KSgpXG4gICAgfSxcbiAgICBmdW5jdGlvbiBmcm9tRGF0YXN0b3JlVmFsdWUoKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIF1cbn0pO1xuXG5mb2FtLkxJQih7XG4gIG5hbWU6ICdmb2FtLkJvb2xlYW4nLFxuXG4gIG1ldGhvZHM6IFtcbiAgICB7XG4gICAgICBuYW1lOiAndG9EYXRhc3RvcmVWYWx1ZScsXG4gICAgICBjb2RlOiAoZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBUUlVFID0geyBib29sZWFuVmFsdWU6IHRydWUgfTtcbiAgICAgICAgdmFyIEZBTFNFID0geyBib29sZWFuVmFsdWU6IGZhbHNlIH07XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiB0b0RhdGFzdG9yZVZhbHVlKGIpIHsgcmV0dXJuIGIgPyBUUlVFIDogRkFMU0U7IH07XG4gICAgICB9KSgpXG4gICAgfSxcbiAgICBmdW5jdGlvbiBmcm9tRGF0YXN0b3JlVmFsdWUodikge1xuICAgICAgcmV0dXJuIHYuYm9vbGVhblZhbHVlO1xuICAgIH1cbiAgXVxufSk7XG5cbmZvYW0uTElCKHtcbiAgbmFtZTogJ2ZvYW0uRnVuY3Rpb24nLFxuXG4gIG1ldGhvZHM6IFtcbiAgICBmdW5jdGlvbiB0b0RhdGFzdG9yZVZhbHVlKGYpIHsgcmV0dXJuIHsgc3RyaW5nVmFsdWU6IGYudG9TdHJpbmcoKSB9OyB9XG4gIF1cbn0pO1xuXG5mb2FtLkxJQih7XG4gIG5hbWU6ICdmb2FtLk51bWJlcicsXG5cbiAgbWV0aG9kczogW1xuICAgIGZ1bmN0aW9uIHRvRGF0YXN0b3JlVmFsdWUobikge1xuICAgICAgcmV0dXJuIE51bWJlci5pc0ludGVnZXIobikgPyB7IGludGVnZXJWYWx1ZTogbi50b1N0cmluZygxMCkgfSA6XG4gICAgICAgICAgeyBkb3VibGVWYWx1ZTogbiB9O1xuICAgIH0sXG4gICAgZnVuY3Rpb24gZnJvbURhdGFzdG9yZVZhbHVlKHYpIHtcbiAgICAgIGlmICggdi52YWx1ZV90eXBlID09PSAnZG91YmxlVmFsdWUnIHx8IHYuaW50ZWdlclZhbHVlID09PSB1bmRlZmluZWQgKSB7XG4gICAgICAgIGZvYW0uYXNzZXJ0KHYuZG91YmxlVmFsdWUgIT09IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICAgICAgJ05vbi1pbnRlZ2VyIG51bWJlciBleHBlY3RzIGRvdWJsZVZhbHVlJyk7XG4gICAgICAgIHJldHVybiB2LmRvdWJsZVZhbHVlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcGFyc2VJbnQodi5pbnRlZ2VyVmFsdWUpO1xuICAgIH1cbiAgXVxufSk7XG5cbmZvYW0uTElCKHtcbiAgbmFtZTogJ2ZvYW0uU3RyaW5nJyxcblxuICBtZXRob2RzOiBbXG4gICAgZnVuY3Rpb24gdG9EYXRhc3RvcmVWYWx1ZShzKSB7IHJldHVybiB7IHN0cmluZ1ZhbHVlOiBzIH07IH0sXG4gICAgZnVuY3Rpb24gZnJvbURhdGFzdG9yZVZhbHVlKHYpIHsgcmV0dXJuIHYuc3RyaW5nVmFsdWU7IH1cbiAgXVxufSk7XG5cbmZvYW0uTElCKHtcbiAgbmFtZTogJ2ZvYW0uQXJyYXknLFxuXG4gIG1ldGhvZHM6IFtcbiAgICBmdW5jdGlvbiB0b0RhdGFzdG9yZVZhbHVlKGEpIHtcbiAgICAgIHZhciB2YWx1ZXMgPSBuZXcgQXJyYXkoYS5sZW5ndGgpO1xuICAgICAgZm9yICggdmFyIGkgPSAwOyBpIDwgYS5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YWx1ZXNbaV0gPSBjb20uZ29vZ2xlLmNsb3VkLmRhdGFzdG9yZS50b0RhdGFzdG9yZVZhbHVlKGFbaV0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHsgYXJyYXlWYWx1ZTogeyB2YWx1ZXM6IHZhbHVlcyB9IH07XG4gICAgfSxcbiAgICBmdW5jdGlvbiBmcm9tRGF0YXN0b3JlVmFsdWUodiwgb3B0X2N0eCkge1xuICAgICAgdmFyIHZhbHVlcyA9IHYuYXJyYXlWYWx1ZS52YWx1ZXMgfHwgW107XG4gICAgICB2YXIgYXJyID0gbmV3IEFycmF5KHZhbHVlcy5sZW5ndGgpO1xuICAgICAgZm9yICggdmFyIGkgPSAwOyBpIDwgdmFsdWVzLmxlbmd0aDsgaSsrICkge1xuICAgICAgICBhcnJbaV0gPSBjb20uZ29vZ2xlLmNsb3VkLmRhdGFzdG9yZS5mcm9tRGF0YXN0b3JlVmFsdWUoXG4gICAgICAgICAgICB2YWx1ZXNbaV0sIG9wdF9jdHgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGFycjtcbiAgICB9XG4gIF1cbn0pO1xuXG5mb2FtLkxJQih7XG4gIG5hbWU6ICdmb2FtLkRhdGUnLFxuXG4gIG1ldGhvZHM6IFtcbiAgICBmdW5jdGlvbiB0b0RhdGFzdG9yZVZhbHVlKGQpIHtcbiAgICAgIHJldHVybiB7IHRpbWVzdGFtcFZhbHVlOiBkLnRvSVNPU3RyaW5nKCkgfTtcbiAgICB9LFxuICAgIGZ1bmN0aW9uIGZyb21EYXRhc3RvcmVWYWx1ZSh2KSB7XG4gICAgICB2YXIgdHYgPSB2LnRpbWVzdGFtcFZhbHVlO1xuICAgICAgaWYgKCB0eXBlb2YgdHYgPT09ICdzdHJpbmcnIClcbiAgICAgICAgcmV0dXJuIG5ldyBEYXRlKERhdGUucGFyc2UodHYpKTtcblxuICAgICAgdmFyIHNlY29uZHMgPSBwYXJzZUludCh0di5zZWNvbmRzKTtcbiAgICAgIHZhciBuYW5vcyA9IHR2Lm5hbm9zO1xuICAgICAgZm9hbS5hc3NlcnQoICEgaXNOYU4oc2Vjb25kcyksXG4gICAgICAgICAgICAgICAgICAgJ0V4cGVjdGVkIG5vbi1zdHJpbmcgRGF0YXN0b3JlIHRpbWVzdGFtcFZhbHVlIHRvIGNvbnRhaW46ICcgK1xuICAgICAgICAgICAgICAgICAgICd7IHNlY29uZHM6IFwiPHNlY29uZHMtc2luY2UtZXBvY2g+XCIsIG5hbm9zOiA8bmFub3M+IH0nKTtcblxuICAgICAgcmV0dXJuIG5ldyBEYXRlKCAoIHNlY29uZHMgKiAxMDAwICkgKyBNYXRoLmZsb29yKG5hbm9zIC8gMTAwMDAwMCkgKTtcbiAgICB9XG4gIF1cbn0pO1xuXG4oZnVuY3Rpb24oKSB7XG4gIHZhciBNdWx0aVBhcnRJRCA9IGZvYW0uY29yZS5NdWx0aVBhcnRJRDtcblxuICBmb2FtLkxJQih7XG4gICAgbmFtZTogJ2ZvYW0uY29yZS5GT2JqZWN0JyxcblxuICAgIG1ldGhvZHM6IFtcbiAgICAgIGZ1bmN0aW9uIHRvRGF0YXN0b3JlVmFsdWUobykgeyByZXR1cm4gby50b0RhdGFzdG9yZVZhbHVlKCk7IH0sXG4gICAgICBmdW5jdGlvbiBmcm9tRGF0YXN0b3JlVmFsdWUodiwgb3B0X2N0eCkge1xuICAgICAgICByZXR1cm4gdGhpcy5mcm9tRGF0YXN0b3JlRW50aXR5KHYuZW50aXR5VmFsdWUsIG9wdF9jdHgpO1xuICAgICAgfSxcbiAgICAgIGZ1bmN0aW9uIGZyb21EYXRhc3RvcmVFbnRpdHkoZW50aXR5LCBvcHRfY3R4KSB7XG4gICAgICAgIHZhciBrZXlzID0gZW50aXR5LmtleS5wYXRoO1xuICAgICAgICB2YXIga2V5ID0ga2V5c1trZXlzLmxlbmd0aCAtIDFdO1xuICAgICAgICB2YXIgY2xzID0gZm9hbS5sb29rdXAoa2V5LmtpbmQpO1xuICAgICAgICB2YXIgaWQgPSBrZXkubmFtZTtcbiAgICAgICAgdmFyIGlkUHJvcCA9IGNscy5pZHMgJiYgY2xzLmlkcy5sZW5ndGggPT09IDEgP1xuICAgICAgICAgICAgY2xzLmdldEF4aW9tQnlOYW1lKGNscy5pZHNbMF0pIDpcbiAgICAgICAgICAgIGNscy5nZXRBeGlvbUJ5TmFtZSgnaWQnKTtcbiAgICAgICAgdmFyIG9wdHMgPSB7fTtcblxuICAgICAgICBpZiAoIGlkUHJvcCAmJiAhIE11bHRpUGFydElELmlzSW5zdGFuY2UoaWRQcm9wKSApXG4gICAgICAgICAgb3B0c1tpZFByb3AubmFtZV0gPSBpZFByb3AuZnJvbURhdGFzdG9yZUtleU5hbWUoaWQpO1xuXG4gICAgICAgIHZhciBwcm9wcyA9IGVudGl0eS5wcm9wZXJ0aWVzO1xuICAgICAgICBmb3IgKCB2YXIgbmFtZSBpbiBwcm9wcyApIHtcbiAgICAgICAgICBpZiAoIHByb3BzLmhhc093blByb3BlcnR5KG5hbWUpICkge1xuICAgICAgICAgICAgb3B0c1tuYW1lXSA9IGNvbS5nb29nbGUuY2xvdWQuZGF0YXN0b3JlLmZyb21EYXRhc3RvcmVWYWx1ZShcbiAgICAgICAgICAgICAgICBwcm9wc1tuYW1lXSwgb3B0X2N0eCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGNscy5jcmVhdGUob3B0cywgb3B0X2N0eCk7XG4gICAgICB9LFxuICAgICAgZnVuY3Rpb24gZ2V0T3duQ2xhc3NEYXRhc3RvcmVLaW5kKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pZDtcbiAgICAgIH0sXG4gICAgICBmdW5jdGlvbiBnZXRDbGFzc0RhdGFzdG9yZUtpbmQoKSB7XG4gICAgICAgIHJldHVybiB7IG5hbWU6IHRoaXMuZ2V0T3duQ2xhc3NEYXRhc3RvcmVLaW5kKCkgfTtcbiAgICAgIH1cbiAgICBdXG4gIH0pO1xufSkoKTtcblxuLy9cbi8vIFByb3ZpZGUgYmFzZSB0by9mcm9tIGRhdGFzdG9yZSB2YWx1ZSBvcGVyYXRpb25zLlxuLy9cblxuZm9hbS5MSUIoe1xuICBuYW1lOiAnY29tLmdvb2dsZS5jbG91ZC5kYXRhc3RvcmUnLFxuXG4gIG1ldGhvZHM6IFtcbiAgICBmdW5jdGlvbiB0b0RhdGFzdG9yZVZhbHVlKG8pIHtcbiAgICAgIHZhciB0ID0gZm9hbS50eXBlT2Yobyk7XG4gICAgICBpZiAoICEgKCB0ICYmIHQudG9EYXRhc3RvcmVWYWx1ZSApICkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0F0dGVtcHQgdG8gY29tcHV0ZSBkYXRhc3RvcmUgdmFsdWUgZnJvbSAnICtcbiAgICAgICAgICAgICdpbmNvbXBhdGlibGUgdHlwZScpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdC50b0RhdGFzdG9yZVZhbHVlKG8pO1xuICAgIH0sXG4gICAgZnVuY3Rpb24gZnJvbURhdGFzdG9yZVZhbHVlKHYsIG9wdF9jdHgpIHtcbiAgICAgIHJldHVybiB0aGlzLnR5cGVPZkRhdGFzdG9yZVZhbHVlKHYpLmZyb21EYXRhc3RvcmVWYWx1ZSh2LCBvcHRfY3R4KTtcbiAgICB9LFxuICAgIGZ1bmN0aW9uIGZyb21EYXRhc3RvcmVFbnRpdHkodiwgb3B0X2N0eCkge1xuICAgICAgcmV0dXJuIGZvYW0uY29yZS5GT2JqZWN0LmZyb21EYXRhc3RvcmVFbnRpdHkodiwgb3B0X2N0eCk7XG4gICAgfSxcbiAgICB7XG4gICAgICBuYW1lOiAndHlwZU9mRGF0YXN0b3JlVmFsdWUnLFxuICAgICAgZG9jdW1lbnRhdGlvbjogZnVuY3Rpb24oKSB7LypcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgRGV0ZXJtaW5lIHRoZSBwcmltaXRpdmUgdHlwZSBvZiBWYWx1ZSBmcm9tXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEdvb2dsZSBDbG91ZCBEYXRhc3RvcmUgUkVTVCBBUEkuIFRoZXNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlcyBhcmUgb2JqZWN0cyB3aXRoIG9uZSBrZXkgZGVub3RpbmdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhlaXIgRGF0YXN0b3JlIHJlcHJlc2VudGF0aW9uOyBlLmcuLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImJvb2xlYW5WYWx1ZVwiLCBcImludGVnZXJWYWx1ZVwiLCBldGMuLlxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGh0dHBzOi8vY2xvdWQuZ29vZ2xlLmNvbS9kYXRhc3RvcmUvZG9jcy9yZWZlcmVuY2UvcmVzdC92MS9wcm9qZWN0cy9ydW5RdWVyeSN2YWx1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICovfSxcbiAgICAgIGNvZGU6IChmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHR5cGVNYXAgPSB7XG4gICAgICAgICAgbnVsbFZhbHVlOiBmb2FtLk51bGwsXG4gICAgICAgICAgYm9vbGVhblZhbHVlOiBmb2FtLkJvb2xlYW4sXG4gICAgICAgICAgaW50ZWdlclZhbHVlOiBmb2FtLk51bWJlcixcbiAgICAgICAgICBkb3VibGVWYWx1ZTogZm9hbS5OdW1iZXIsXG4gICAgICAgICAgdGltZXN0YW1wVmFsdWU6IGZvYW0uRGF0ZSxcbiAgICAgICAgICBzdHJpbmdWYWx1ZTogZm9hbS5TdHJpbmcsXG4gICAgICAgICAgYXJyYXlWYWx1ZTogZm9hbS5BcnJheSxcbiAgICAgICAgICBlbnRpdHlWYWx1ZTogZm9hbS5jb3JlLkZPYmplY3RcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIHR5cGVPZkRhdGFzdG9yZVZhbHVlKHYpIHtcbiAgICAgICAgICBpZiAoIHYuaGFzT3duUHJvcGVydHkoJ3ZhbHVlX3R5cGUnKSApIHtcbiAgICAgICAgICAgIGZvYW0uYXNzZXJ0KHR5cGVNYXBbdi52YWx1ZV90eXBlXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICdFeHBlY3RlZCBkYXRhc3RvcmUgdmFsdWUgd2l0aCBcInZhbHVlX3R5cGVcIiB0byBoYXZlICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgJ2tub3duIHR5cGU7IHZhbHVlX3R5cGUgPSAnICsgdi52YWx1ZV90eXBlKTtcbiAgICAgICAgICAgIHJldHVybiB0eXBlTWFwW3YudmFsdWVfdHlwZV07XG4gICAgICAgICAgfVxuICAgICAgICAgIGZvciAoIHZhciBrZXkgaW4gdiApIHtcbiAgICAgICAgICAgIGlmICggdHlwZU1hcFtrZXldICYmIHYuaGFzT3duUHJvcGVydHkoa2V5KSApIHJldHVybiB0eXBlTWFwW2tleV07XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdGYWlsZWQgdG8gaWRlbnRpZnkgdHlwZSBvZiBkYXRhc3RvcmUgdmFsdWU6ICcgK1xuICAgICAgICAgICAgICBKU09OLnN0cmluZ2lmeSh2KSk7XG4gICAgICAgIH07XG4gICAgICB9KSgpXG4gICAgfSxcbiAgICB7XG4gICAgICBuYW1lOiAndG9EYXRhc3RvcmVLZXlOYW1lJyxcbiAgICAgIGNvZGU6IGZvYW0ubW1ldGhvZCh7XG4gICAgICAgIE51bWJlcjogZnVuY3Rpb24obikgeyByZXR1cm4gbiArICcnOyB9LFxuICAgICAgICBTdHJpbmc6IGZ1bmN0aW9uKHN0cikgeyByZXR1cm4gc3RyOyB9LFxuICAgICAgICBGT2JqZWN0OiBmdW5jdGlvbihvKSB7XG4gICAgICAgICAgdmFyIGlkUHJvcCA9IG8uY2xzXy5JRDtcbiAgICAgICAgICBpZiAoICEgaWRQcm9wICkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdBdHRlbXB0IHRvIGNvbnN0cnVjdCBkYXRhc3RvcmUga2V5IGZyb20gJyArXG4gICAgICAgICAgICAgICAgJ3VuaWRlbnRpZmllZCBvYmplY3QnKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGlkUHJvcC50b0RhdGFzdG9yZUtleU5hbWUobyk7XG4gICAgICAgIH0sXG4gICAgICAgIEFycmF5OiBmdW5jdGlvbihhKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNdWx0aS1wYXJ0IGtleXMgbXVzdCBiZSBkZXJpdmVkIGZyb20gb2JqZWN0cywgbm90IHZhbHVlcycpO1xuICAgICAgICB9LFxuICAgICAgICBPYmplY3Q6IGZ1bmN0aW9uKG8pIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBjb252ZXJ0IHBsYWluIG9iamVjdCB0byBkYXRhc3RvcmUga2V5IG5hbWUnKTtcbiAgICAgICAgfVxuICAgICAgfSwgZnVuY3Rpb24obykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBjb252ZXJ0ICcgKyBvICsgJyB0byBkYXRhc3RvcmUga2V5IG5hbWUnKTtcbiAgICAgIH0pXG4gICAgfVxuICBdXG59KTtcblxuLy9cbi8vIFJlZmluZSBwcm9wZXJ0aWVzIGFuZCBtdWx0aS1wYXJ0IGlkcyB0byBzdXBwb3J0IGNvbnZlcnNpb246XG4vLyBwcm9wZXJ0eS1vbi1vYmplY3QgPT4gZGF0YXN0b3JlLWtleS1uYW1lXG4vL1xuXG5mb2FtLkNMQVNTKHtcbiAgcmVmaW5lczogJ2ZvYW0uY29yZS5Qcm9wZXJ0eScsXG5cbiAgbWV0aG9kczogW1xuICAgIHtcbiAgICAgIG5hbWU6ICd0b0RhdGFzdG9yZUtleU5hbWUnLFxuICAgICAgZG9jdW1lbnRhdGlvbjogYENvbnN0cnVjdCBhIERhdGFzdG9yZSBLZXkgUGF0aEVsZW1lbnQgXCJuYW1lXCIgZnJvbSB0aGlzXG4gICAgICAgIHByb3BlcnR5LiBJLmUuLFxuICAgICAgICBodHRwczovL2Nsb3VkLmdvb2dsZS5jb20vZGF0YXN0b3JlL2RvY3MvcmVmZXJlbmNlL3Jlc3QvdjEvS2V5I1BhdGhFbGVtZW50XG4gICAgICAgIFwibmFtZVwiIHByb3BlcnR5LmAsXG4gICAgICBjb2RlOiBmdW5jdGlvbihvKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRvRGF0YXN0b3JlS2V5TmFtZVBhcnQobyk7XG4gICAgICB9XG4gICAgfSxcbiAgICB7XG4gICAgICBuYW1lOiAndG9EYXRhc3RvcmVLZXlOYW1lUGFydCcsXG4gICAgICBkb2N1bWVudGF0aW9uOiBgUHJvdmlkZSB0aGlzIHByb3BlcnR5J3MgY29udHJpYnV0aW9uIHRvIGEgY29tcG9zaXRlXG4gICAgICAgIERhdGFzdG9yZSBLZXkgUGF0aEVsZW1lbnQgXCJuYW1lXCIgZnJvbSB0aGlzIHByb3BlcnR5LiBUaGlzIGlzIHVzZWQgYnlcbiAgICAgICAgTXVsdGlQYXJ0SURzIHRvIGdhdGhlciBzdHJpbmcgZnJhZ21lbnRzIGZyb20gbXVsdGlwbGUgcHJvcGVyaWVzLiBTZWVcbiAgICAgICAgaHR0cHM6Ly9jbG91ZC5nb29nbGUuY29tL2RhdGFzdG9yZS9kb2NzL3JlZmVyZW5jZS9yZXN0L3YxL0tleSNQYXRoRWxlbWVudFxuICAgICAgICBcIm5hbWVcIiBwcm9wZXJ0eSBmb3IgRGF0YXN0b3JlIEFQSSB1c2FnZSBkZXRhaWxzLmAsXG4gICAgICBjb2RlOiBmdW5jdGlvbihvKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmYobykudG9TdHJpbmcoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudG9EYXRhc3RvcmVLZXlOYW1lUGFydChvKTtcbiAgICAgIH1cbiAgICB9XG4gIF1cbn0pO1xuXG5mb2FtLkNMQVNTKHtcbiAgcmVmaW5lczogJ2ZvYW0uY29yZS5EYXRlJyxcblxuICBtZXRob2RzOiBbXG4gICAgZnVuY3Rpb24gdG9EYXRhc3RvcmVLZXlOYW1lUGFydChvKSB7XG4gICAgICByZXR1cm4gdGhpcy5mKG8pLnRvSVNPU3RyaW5nKCk7XG4gICAgfVxuICBdXG59KTtcblxuZm9hbS5DTEFTUyh7XG4gIHJlZmluZXM6ICdmb2FtLmNvcmUuTXVsdGlQYXJ0SUQnLFxuXG4gIHByb3BlcnRpZXM6IFtcbiAgICB7XG4gICAgICBjbGFzczogJ1N0cmluZycsXG4gICAgICBuYW1lOiAnc3RyaW5nU2VwYXJhdG9yJyxcbiAgICAgIHZhbHVlOiAnOidcbiAgICB9XG4gIF0sXG5cbiAgbWV0aG9kczogW1xuICAgIGZ1bmN0aW9uIHRvRGF0YXN0b3JlS2V5TmFtZShvKSB7XG4gICAgICB2YXIgc2VwID0gdGhpcy5zdHJpbmdTZXBhcmF0b3I7XG4gICAgICB2YXIgcHJvcHMgPSB0aGlzLnByb3BzO1xuICAgICAgdmFyIHN0ciA9ICcnO1xuICAgICAgZm9yICggdmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKysgKSB7XG4gICAgICAgIHN0ciArPSBwcm9wc1tpXS50b0RhdGFzdG9yZUtleU5hbWVQYXJ0KG8pO1xuICAgICAgICBpZiAoIGkgIT09IHByb3BzLmxlbmd0aCAtIDEgKSBzdHIgKz0gc2VwO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHN0cjtcbiAgICB9LFxuICAgIGZ1bmN0aW9uIGZyb21EYXRhc3RvcmVLZXlOYW1lKG5hbWUpIHtcbiAgICAgIHJldHVybiBuYW1lLnNwbGl0KHRoaXMuc3RyaW5nU2VwYXJhdG9yKTtcbiAgICB9XG4gIF1cbn0pO1xuXG4vL1xuLy8gUmVmaW5lIEVudW0gdmFsdWVzIHRvIG91dHB1dCBpbnRlZ2VyOiBlbnVtVmFsdWUub3JkaW5hbC5cbi8vXG5cbmZvYW0uQ0xBU1Moe1xuICByZWZpbmVzOiAnZm9hbS5jb3JlLkFic3RyYWN0RW51bScsXG5cbiAgbWV0aG9kczogW1xuICAgIGZ1bmN0aW9uIHRvRGF0YXN0b3JlVmFsdWUoKSB7XG4gICAgICByZXR1cm4geyBpbnRlZ2VyVmFsdWU6IHRoaXMub3JkaW5hbCB9O1xuICAgIH1cbiAgXVxufSk7XG5cbi8vXG4vLyBSZWZpbmUgZm9hbS5jb3JlLkZPYmplY3QgdG8gc3VwcG9ydCBkYXRhc3RvcmUnczpcbi8vICgxKSBcImtpbmRzXCIgKGkuZS4sIHR5cGVzKTtcbi8vICgyKSBcImtleXNcIiAoaS5lLiwgPHR5cGUsIG5hbWV8YXV0by1nZW5lcmF0ZWQtaWQ+IHBhaXJzKTtcbi8vICgzKSBcImVudGl0aWVzXCIgKGkuZS4sIG9iamVjdHMpO1xuLy8gKDQpIFwidmFsdWVzXCIgKGkuZS4sIHByaW1pdGl2ZXMgb3IgZW50aXRpZXMpLlxuLy9cblxuZm9hbS5DTEFTUyh7XG4gIHJlZmluZXM6ICdmb2FtLmNvcmUuRk9iamVjdCcsXG5cbiAgbWV0aG9kczogW1xuICAgIGZ1bmN0aW9uIGdldE93bkRhdGFzdG9yZUtpbmQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5jbHNfLmdldE93bkNsYXNzRGF0YXN0b3JlS2luZCgpO1xuICAgIH0sXG4gICAgZnVuY3Rpb24gZ2V0RGF0YXN0b3JlS2luZCgpIHtcbiAgICAgIHJldHVybiB0aGlzLmNsc18uZ2V0Q2xhc3NEYXRhc3RvcmVLaW5kKCk7XG4gICAgfSxcbiAgICBmdW5jdGlvbiBnZXRPd25EYXRhc3RvcmVLZXkoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBraW5kOiB0aGlzLmdldE93bkRhdGFzdG9yZUtpbmQoKSxcbiAgICAgICAgbmFtZTogY29tLmdvb2dsZS5jbG91ZC5kYXRhc3RvcmUudG9EYXRhc3RvcmVLZXlOYW1lKHRoaXMpXG4gICAgICB9O1xuICAgIH0sXG4gICAgZnVuY3Rpb24gZ2V0RGF0YXN0b3JlS2V5KHBhcnRpdGlvbklkLCBvcHRfcHJvcGVydHlQYXRoKSB7XG4gICAgICBpZiAoICEgb3B0X3Byb3BlcnR5UGF0aCApIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBwYXJ0aXRpb25JZDogcGFydGl0aW9uSWQsXG4gICAgICAgICAgcGF0aDogWyB0aGlzLmdldE93bkRhdGFzdG9yZUtleSgpIF1cbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgdmFyIG8gPSB0aGlzO1xuICAgICAgdmFyIHBhdGggPSBuZXcgQXJyYXkob3B0X3Byb3BlcnR5UGF0aC5sZW5ndGggKyAxKTtcblxuICAgICAgcGF0aFswXSA9IHRoaXMuZ2V0T3duRGF0YXN0b3JlS2V5KCk7XG5cbiAgICAgIGZvciAoIHZhciBpID0gMDsgaSA8IG9wdF9wcm9wZXJ0eVBhdGgubGVuZ3RoOyBpKysgKSB7XG4gICAgICAgIHZhciBuZXh0ID0gb3B0X3Byb3BlcnR5UGF0aFtpXTtcbiAgICAgICAgdmFyIG8gPSAoIHR5cGVvZiBuZXh0ID09PSAnc3RyaW5nJyApID8gb1tuZXh0XSA6IG5leHQuZihvKTtcblxuICAgICAgICBpZiAoICEgZm9hbS5jb3JlLkZPYmplY3QuaXNJbnN0YW5jZShvKSApIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0F0dGVtcHQgdG8gZ2V0IGRhdGFzdG9yZSBrZXkgZnJvbSBub24ta2V5YWJsZSAnICtcbiAgICAgICAgICAgICAgJ29iamVjdCcpO1xuICAgICAgICB9XG5cbiAgICAgICAgcGF0aFtpICsgMV0gPSBvLmdldE93bkRhdGFzdG9yZUtleSgpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4geyBwYXJ0aXRpb25JZDogcGFydGl0aW9uSWQsIHBhdGg6IHBhdGggfTtcbiAgICB9LFxuICAgIGZ1bmN0aW9uIHRvRGF0YXN0b3JlRW50aXR5KHBhcnRpdGlvbklkKSB7XG4gICAgICB2YXIgcHJvcGVydGllcyA9IHt9O1xuICAgICAgdmFyIHBzID0gdGhpcy5jbHNfLmdldEF4aW9tc0J5Q2xhc3MoZm9hbS5jb3JlLlByb3BlcnR5KTtcblxuICAgICAgZm9yICggdmFyIGkgPSAwOyBpIDwgcHMubGVuZ3RoOyBpKysgKSB7XG4gICAgICAgIC8vIFRPRE8obWFya2RpdHRtZXIpOiBNTGFuZ3MgdGhhdCByZWZlciB0byBzdG9yYWdlVHJhbnNpZW50XG4gICAgICAgIC8vIHByb3BlcnRpZXMgY291bGQgY2F1c2UgdGhlIERhdGFzdG9yZURBTyB0byBtaXNiZWhhdmUuIFRoaXMgY291bGQgYmVcbiAgICAgICAgLy8gZml4ZWQgYnkgYXVkaXRpbmcgcHJlZGljYXRlcyBhbmQgdGhyb3dpbmcgYW4gZXJyb3Igd2hlbiB0aGV5IGNvbnRhaW5cbiAgICAgICAgLy8gcHJvcGVydGllcyB0aGF0IGFyZSBkcm9wcGVkIGJ5IHRoZSBEQU8gcHJvY2Vzc2luZyB0aGUgcHJlZGljYXRlLlxuICAgICAgICBpZiAoIHBzW2ldLnN0b3JhZ2VUcmFuc2llbnQgKSBjb250aW51ZTtcblxuICAgICAgICB2YXIgdmFsdWUgPSBwc1tpXS5mKHRoaXMpO1xuICAgICAgICBwcm9wZXJ0aWVzW3BzW2ldLm5hbWVdID0gY29tLmdvb2dsZS5jbG91ZC5kYXRhc3RvcmUudG9EYXRhc3RvcmVWYWx1ZShcbiAgICAgICAgICAgIHZhbHVlKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHsga2V5OiB0aGlzLmdldERhdGFzdG9yZUtleShwYXJ0aXRpb25JZCksIHByb3BlcnRpZXM6IHByb3BlcnRpZXMgfTtcbiAgICB9LFxuICAgIGZ1bmN0aW9uIHRvRGF0YXN0b3JlVmFsdWUoKSB7XG4gICAgICByZXR1cm4geyBlbnRpdHlWYWx1ZTogdGhpcy50b0RhdGFzdG9yZUVudGl0eSgpIH07XG4gICAgfSxcbiAgICBmdW5jdGlvbiBmcm9tRGF0YXN0b3JlS2V5TmFtZShuYW1lKSB7IHJldHVybiBuYW1lOyB9XG4gIF1cbn0pO1xuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuLy9cbi8vIFJlZmluZSBDT1VOVCB0byBwZXJmb3JtIHR3byBvcHRpbWl6YXRpb25zOlxuLy8gKDEpIFBlcmZvcm0gYSBrZXktb25seSBxdWVyeSB3aGVuIHRoZSBzaW5rIGlzIGEgQ09VTlQ7XG4vLyAoMikgRG8gbm90IGJvdGhlciBjb25zdHJ1Y3Rpb24gRk9iamVjdHMgb24gcXVlcnkgcmVzdWx0IGJhdGNoZXMuXG4vL1xuXG5mb2FtLkNMQVNTKHtcbiAgcmVmaW5lczogJ2ZvYW0ubWxhbmcuc2luay5Db3VudCcsXG5cbiAgbWV0aG9kczogW1xuICAgIHtcbiAgICAgIG5hbWU6ICdkZWNvcmF0ZURhdGFzdG9yZVF1ZXJ5JyxcbiAgICAgIGRvY3VtZW50YXRpb246IGBPcHRpbWl6ZSBwbGFpbiBDT1VOVCgpIHF1ZXJpZXMgYnkgcmVxdWVzdGluZyBrZXlzIG9ubHkuXG4gICAgICAgICAgVGhpcyBlbnRhaWxzIGZpbGxpbmcgaW4gcnVuUXVlcnkucHJvamVjdGlvbiBbMV0gd2l0aCB0aGUgbWFnaWNcbiAgICAgICAgICBcIl9fa2V5X19cIiBrZXkuXG5cbiAgICAgICAgICBbMV0gaHR0cHM6Ly9jbG91ZC5nb29nbGUuY29tL2RhdGFzdG9yZS9kb2NzL3JlZmVyZW5jZS9yZXN0L3YxL3Byb2plY3RzL3J1blF1ZXJ5I1Byb2plY3Rpb25gLFxuICAgICAgY29kZTogZnVuY3Rpb24ocXVlcnkpIHtcbiAgICAgICAgcXVlcnkucHJvamVjdGlvbiA9IFsgeyBwcm9wZXJ0eTogeyBuYW1lOiBcIl9fa2V5X19cIiB9IH0gXTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHtcbiAgICAgIG5hbWU6ICdmcm9tRGF0YXN0b3JlRW50aXR5UmVzdWx0cycsXG4gICAgICBkb2N1bWVudGF0aW9uOiBgT3B0aW1pemUgcGxhaW4gQ09VTlQoKSBxdWVyaWVzIGJ5IG5vdCBjb25zdHJ1Y3RpbmdcbiAgICAgICAgICBGT2JqZWN0cyB0byBzdG9yZSByZXN1bHRzLiBJbnB1dCBwYXJhbXRlciBpc1xuICAgICAgICAgIFF1ZXJ5UmVzdWx0QmF0Y2guZW50aXR5UmVzdWx0cyBbMV0uXG5cbiAgICAgICAgICBbMV0gaHR0cHM6Ly9jbG91ZC5nb29nbGUuY29tL2RhdGFzdG9yZS9kb2NzL3JlZmVyZW5jZS9yZXN0L3YxL3Byb2plY3RzL3J1blF1ZXJ5I1F1ZXJ5UmVzdWx0QmF0Y2hgLFxuICAgICAgY29kZTogZnVuY3Rpb24oZW50aXR5UmVzdWx0cykgeyB0aGlzLnZhbHVlICs9IGVudGl0eVJlc3VsdHMubGVuZ3RoOyB9XG4gICAgfVxuICBdXG59KTtcblxuLy9cbi8vIFJlZmluZSBQcm9wZXJ0eSBhbmQgRE9UIHRvIHByb2R1Y2UgZGF0YXN0b3JlIHByb3BlcnR5LlxuLy9cblxuZm9hbS5DTEFTUyh7XG4gIHJlZmluZXM6ICdmb2FtLmNvcmUuUHJvcGVydHknLFxuXG4gIG1ldGhvZHM6IFtcbiAgICB7XG4gICAgICBuYW1lOiAndG9EYXRhc3RvcmVQcm9wZXJ0eVJlZmVyZW5jZScsXG4gICAgICBkb2N1bWVudGF0aW9uOlxuICAgICAgZnVuY3Rpb24oKSB7LypcbiAgICAgICAgICAgICAgICAgICAgUHJvdmlkZXMgYSBQcm9wZXJ0eVJlZmVyZW5jZSBmb3IgdGhlIENsb3VkIERhdGFzdG9yZSBSRVNUXG4gICAgICAgICAgICAgICAgICAgIEFQSS5cbiAgICAgICAgICAgICAgICAgICAgaHR0cHM6Ly9jbG91ZC5nb29nbGUuY29tL2RhdGFzdG9yZS9kb2NzL3JlZmVyZW5jZS9yZXN0L3YxL3Byb2plY3RzL3J1blF1ZXJ5I1Byb3BlcnR5UmVmZXJlbmNlXG4gICAgICAgICAgICAgICAgICAqL30sXG4gICAgICBjb2RlOiBmdW5jdGlvbigpIHsgcmV0dXJuIHsgbmFtZTogdGhpcy5uYW1lIH07IH1cbiAgICB9XG4gIF1cbn0pO1xuXG5cbmZvYW0uQ0xBU1Moe1xuICByZWZpbmVzOiAnZm9hbS5tbGFuZy5leHByLkRvdCcsXG5cbiAgbWV0aG9kczogW1xuICAgIHtcbiAgICAgIG5hbWU6ICd0b0RhdGFzdG9yZVByb3BlcnR5UmVmZXJlbmNlJyxcbiAgICAgIGNvZGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4geyBuYW1lOiB0aGlzLmFyZzEubmFtZSArICcuJyArIHRoaXMuYXJnMi5uYW1lIH07XG4gICAgICB9XG4gICAgfVxuICBdXG59KTtcblxuXG4vL1xuLy8gUmVmaW5lIGNvbnN0YW50cyB0byBwcm9kdWNlIGRhdGFzdG9yZSB2YWx1ZXMuIFRoaXMgaXMgbmVlZGVkIGJlY2F1c2Vcbi8vIG1MYW5ncyB3aWxsIGF0dGVtcHQgdG8gYWNjZXNzIGRhdGFzdG9yZSB2YWx1ZXMgb24gdGhlIGFyZ3VtZW50cy5cbi8vXG5cbmZvYW0uQ0xBU1Moe1xuICByZWZpbmVzOiAnZm9hbS5tbGFuZy5Db25zdGFudCcsXG5cbiAgbWV0aG9kczogW1xuICAgIHtcbiAgICAgIG5hbWU6ICd0b0RhdGFzdG9yZVZhbHVlJyxcbiAgICAgIGRvY3VtZW50YXRpb246XG4gICAgICBmdW5jdGlvbigpIHsvKlxuICAgICAgICAgICAgICAgICAgICBQcm92aWRlcyBWYWx1ZSBmb3IgdGhlIENsb3VkIERhdGFzdG9yZSBSRVNUIEFQSS5cbiAgICAgICAgICAgICAgICAgICAgaHR0cHM6Ly9jbG91ZC5nb29nbGUuY29tL2RhdGFzdG9yZS9kb2NzL3JlZmVyZW5jZS9yZXN0L3YxL3Byb2plY3RzL3J1blF1ZXJ5I1ZhbHVlXG4gICAgICAgICAgICAgICAgICAqL30sXG4gICAgICBjb2RlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIGNvbS5nb29nbGUuY2xvdWQuZGF0YXN0b3JlLnRvRGF0YXN0b3JlVmFsdWUodGhpcy52YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICBdXG59KTtcblxuXG4vL1xuLy8gUmVmaW5lIEFORCBhbmQgc3Vic2V0IG9mIGJpbmFyeSBvcHMgdG8gc3VwcG9ydCB0b0RhdGFzdG9yZUZpbHRlcigpLlxuLy9cblxuZm9hbS5DTEFTUyh7XG4gIHJlZmluZXM6ICdmb2FtLm1sYW5nLnByZWRpY2F0ZS5BYnN0cmFjdFByZWRpY2F0ZScsXG5cbiAgbWV0aG9kczogW1xuICAgIHtcbiAgICAgIG5hbWU6ICd0b0RhdGFzdG9yZUZpbHRlcicsXG4gICAgICBkb2N1bWVudGF0aW9uOlxuICAgICAgZnVuY3Rpb24oKSB7LypcbiAgICAgICAgICAgICAgICAgICAgUHJvdmlkZXMgRmlsdGVyIGZvciB0aGUgQ2xvdWQgRGF0YXN0b3JlIFJFU1QgQVBJLlxuICAgICAgICAgICAgICAgICAgICBodHRwczovL2Nsb3VkLmdvb2dsZS5jb20vZGF0YXN0b3JlL2RvY3MvcmVmZXJlbmNlL3Jlc3QvdjEvcHJvamVjdHMvcnVuUXVlcnkjZmlsdGVyXG4gICAgICAgICAgICAgICAgICAqL30sXG4gICAgICBjb2RlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdQcmVkaWNhdGUgbm90IHN1cHBvcnRlZCBpbiBkYXRhc3RvcmUgJyArXG4gICAgICAgICAgICAnaW1wbGVtZW50YXRpb246ICcgKyB0aGlzLmNsc18uaWQpO1xuICAgICAgfVxuICAgIH1cbiAgXVxufSk7XG5cblxuZm9hbS5DTEFTUyh7XG4gIHJlZmluZXM6ICdmb2FtLm1sYW5nLnByZWRpY2F0ZS5BbmQnLFxuXG4gIG1ldGhvZHM6IFtcbiAgICB7XG4gICAgICBuYW1lOiAndG9Pd25EYXRhc3RvcmVGaWx0ZXInLFxuICAgICAgZG9jdW1lbnRhdGlvbjpcbiAgICAgIGZ1bmN0aW9uKCkgey8qXG4gICAgICAgICAgICAgICAgICAgIFByb3ZpZGVzIChDb21wb3NpdGVGaWx0ZXJ8UHJvcGVydHlGaWx0ZXIpIGZvciBhIEZpbHRlciBpblxuICAgICAgICAgICAgICAgICAgICB0aGUgQ2xvdWQgRGF0YXN0b3JlIFJFU1QgQVBJLlxuICAgICAgICAgICAgICAgICAgICBodHRwczovL2Nsb3VkLmdvb2dsZS5jb20vZGF0YXN0b3JlL2RvY3MvcmVmZXJlbmNlL3Jlc3QvdjEvcHJvamVjdHMvcnVuUXVlcnkjZmlsdGVyXG4gICAgICAgICAgICAgICAgICAqL30sXG4gICAgICBjb2RlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGZpbHRlcnMgPSBuZXcgQXJyYXkodGhpcy5hcmdzLmxlbmd0aCk7XG5cbiAgICAgICAgZm9yICggdmFyIGkgPSAwOyBpIDwgdGhpcy5hcmdzLmxlbmd0aDsgaSsrICkge1xuICAgICAgICAgIGZpbHRlcnNbaV0gPSB0aGlzLmFyZ3NbaV0udG9EYXRhc3RvcmVGaWx0ZXIoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7IG9wOiAnQU5EJywgZmlsdGVyczogZmlsdGVycyB9O1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBmdW5jdGlvbiB0b0RhdGFzdG9yZUZpbHRlcigpIHtcbiAgICAgIHJldHVybiB7IGNvbXBvc2l0ZUZpbHRlcjogdGhpcy50b093bkRhdGFzdG9yZUZpbHRlcigpIH07XG4gICAgfVxuICBdXG59KTtcblxuXG5mb2FtLkNMQVNTKHtcbiAgcmVmaW5lczogJ2ZvYW0ubWxhbmcucHJlZGljYXRlLkJpbmFyeScsXG5cbiAgcHJvcGVydGllczogW1xuICAgIHtcbiAgICAgIGNsYXNzOiAnU3RyaW5nJyxcbiAgICAgIGRvY3VtZW50YXRpb246IGBQcm92aWRlcyBPcGVyYXRvciBmb3IgdGhlIENsb3VkIERhdGFzdG9yZSBSRVNUIEFQSS5cbiAgICAgICAgICBodHRwczovL2Nsb3VkLmdvb2dsZS5jb20vZGF0YXN0b3JlL2RvY3MvcmVmZXJlbmNlL3Jlc3QvdjEvcHJvamVjdHMvcnVuUXVlcnkjT3BlcmF0b3JfMWAsXG4gICAgICBuYW1lOiAnZGF0YXN0b3JlT3BOYW1lJ1xuICAgIH1cbiAgXSxcblxuICBtZXRob2RzOiBbXG4gICAgZnVuY3Rpb24gdG9Pd25EYXRhc3RvcmVGaWx0ZXIoKSB7XG4gICAgICBmb2FtLmFzc2VydChmb2FtLmNvcmUuUHJvcGVydHkuaXNJbnN0YW5jZSh0aGlzLmFyZzEpLFxuICAgICAgICAgICdMZWZ0LWhhbmQtc2lkZSBvZiBkYXRhc3RvcmUgYmluYXJ5IG9wIGlzIG5vdCBhIHByb3BlcnR5Jyk7XG4gICAgICBmb2FtLmFzc2VydCh0aGlzLmRhdGFzdG9yZU9wTmFtZSxcbiAgICAgICAgICAnUHJlZGljYXRlIGhhcyBubyBkYXRhc3RvcmUgb3AgbmFtZTonLCB0aGlzLmNsc18uaWQpO1xuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBwcm9wZXJ0eTogdGhpcy5hcmcxLnRvRGF0YXN0b3JlUHJvcGVydHlSZWZlcmVuY2UoKSxcbiAgICAgICAgb3A6IHRoaXMuZGF0YXN0b3JlT3BOYW1lLFxuICAgICAgICB2YWx1ZTogY29tLmdvb2dsZS5jbG91ZC5kYXRhc3RvcmUudG9EYXRhc3RvcmVWYWx1ZSh0aGlzLmFyZzIpXG4gICAgICB9O1xuICAgIH0sXG5cbiAgICBmdW5jdGlvbiB0b0RhdGFzdG9yZUZpbHRlcigpIHtcbiAgICAgIHJldHVybiB7IHByb3BlcnR5RmlsdGVyOiB0aGlzLnRvT3duRGF0YXN0b3JlRmlsdGVyKCkgfTtcbiAgICB9XG4gIF1cbn0pO1xuXG5cbi8vXG4vLyBVc2UgYWJvdmUgQmluYXJ5IGltcGxlbWVudGF0aW9uIG9uIEdvb2dsZSBDbG91ZCBEYXRhc3RvcmUtc3VwcG9ydGVkXG4vLyBwcmVkaWNhdGVzIGJ5IHJlZmluaW5nIHRoZW0gd2l0aCBhIHBhcnRpY3VsYXIgXCJkYXRhc3RvcmVPcE5hbWVcIiB2YWx1ZS5cbi8vXG5cbmZvYW0uQ0xBU1Moe3JlZmluZXM6ICdmb2FtLm1sYW5nLnByZWRpY2F0ZS5FcScsICBwcm9wZXJ0aWVzOiBbIHtjbGFzczogJ1N0cmluZycsIG5hbWU6ICdkYXRhc3RvcmVPcE5hbWUnLCB2YWx1ZTogJ0VRVUFMJyB9XSB9KTtcbmZvYW0uQ0xBU1Moe3JlZmluZXM6ICdmb2FtLm1sYW5nLnByZWRpY2F0ZS5MdCcsICBwcm9wZXJ0aWVzOiBbIHtjbGFzczogJ1N0cmluZycsIG5hbWU6ICdkYXRhc3RvcmVPcE5hbWUnLCB2YWx1ZTogJ0xFU1NfVEhBTicgfV0gfSk7XG5mb2FtLkNMQVNTKHtyZWZpbmVzOiAnZm9hbS5tbGFuZy5wcmVkaWNhdGUuTHRlJywgcHJvcGVydGllczogWyB7Y2xhc3M6ICdTdHJpbmcnLCBuYW1lOiAnZGF0YXN0b3JlT3BOYW1lJywgdmFsdWU6ICdMRVNTX1RIQU5fT1JfRVFVQUwnIH1dIH0pO1xuZm9hbS5DTEFTUyh7cmVmaW5lczogJ2ZvYW0ubWxhbmcucHJlZGljYXRlLkd0JywgIHByb3BlcnRpZXM6IFsge2NsYXNzOiAnU3RyaW5nJywgbmFtZTogJ2RhdGFzdG9yZU9wTmFtZScsIHZhbHVlOiAnR1JFQVRFUl9USEFOJyB9XSB9KTtcbmZvYW0uQ0xBU1Moe3JlZmluZXM6ICdmb2FtLm1sYW5nLnByZWRpY2F0ZS5HdGUnLCBwcm9wZXJ0aWVzOiBbIHtjbGFzczogJ1N0cmluZycsIG5hbWU6ICdkYXRhc3RvcmVPcE5hbWUnLCB2YWx1ZTogJ0dSRUFURVJfVEhBTl9PUl9FUVVBTCcgfV0gfSk7XG5cblxuLy9cbi8vIFJlZmluZSBwcm9wZXJ0aWVzIGFuZCBUaGVuQnkgbUxhbmcgdG8gYmVoYXZlIGFzIG9yZGVyaW5ncy5cbi8vXG5cbmZvYW0uQ0xBU1Moe1xuICByZWZpbmVzOiAnZm9hbS5jb3JlLlByb3BlcnR5JyxcblxuICBtZXRob2RzOiBbXG4gICAge1xuICAgICAgbmFtZTogJ3RvRGF0YXN0b3JlT3JkZXInLFxuICAgICAgZG9jdW1lbnRhdGlvbjpcbiAgICAgIGZ1bmN0aW9uKCkgey8qXG4gICAgICAgICAgICAgICAgICAgIFByb3ZpZGVzIFByb3BlcnR5T3JkZXIgZm9yIHRoZSBDbG91ZCBEYXRhc3RvcmUgUkVTVCBBUEkuXG4gICAgICAgICAgICAgICAgICAgIGh0dHBzOi8vY2xvdWQuZ29vZ2xlLmNvbS9kYXRhc3RvcmUvZG9jcy9yZWZlcmVuY2UvcmVzdC92MS9wcm9qZWN0cy9ydW5RdWVyeSNwcm9wZXJ0eW9yZGVyXG4gICAgICAgICAgICAgICAgICAqL30sXG4gICAgICBjb2RlOiBmdW5jdGlvbihvcHRfb3JkZXJEaXJlY3Rpb24pIHtcbiAgICAgICAgdmFyIG9yZGVyRGlyZWN0aW9uID0gb3B0X29yZGVyRGlyZWN0aW9uIHx8IDE7XG4gICAgICAgIHJldHVybiBvcmRlckRpcmVjdGlvbiA9PT0gMSA/XG4gICAgICAgICAgICBbIHsgcHJvcGVydHk6IHsgbmFtZTogdGhpcy5uYW1lIH0gfSBdIDpcbiAgICAgICAgICAgIFsgeyBwcm9wZXJ0eTogeyBuYW1lOiB0aGlzLm5hbWUgfSwgZGlyZWN0aW9uOiAnREVTQ0VORElORycgfSBdO1xuICAgICAgfVxuICAgIH1cbiAgXVxufSk7XG5cblxuZm9hbS5DTEFTUyh7XG4gIHJlZmluZXM6ICdmb2FtLm1sYW5nLm9yZGVyLkRlc2MnLFxuXG4gIG1ldGhvZHM6IFtcbiAgICBmdW5jdGlvbiB0b0RhdGFzdG9yZU9yZGVyKG9wdF9vcmRlckRpcmVjdGlvbikge1xuICAgICAgdmFyIG9yZGVyRGlyZWN0aW9uID0gLTEgKiAob3B0X29yZGVyRGlyZWN0aW9uIHx8IDEpO1xuICAgICAgcmV0dXJuIHRoaXMuYXJnMS50b0RhdGFzdG9yZU9yZGVyKG9yZGVyRGlyZWN0aW9uKTtcbiAgICB9XG4gIF1cbn0pO1xuXG5cbmZvYW0uQ0xBU1Moe1xuICByZWZpbmVzOiAnZm9hbS5tbGFuZy5vcmRlci5UaGVuQnknLFxuXG4gIG1ldGhvZHM6IFtcbiAgICBmdW5jdGlvbiB0b0RhdGFzdG9yZU9yZGVyKG9wdF9vcmRlckRpcmVjdGlvbikge1xuICAgICAgdmFyIG9yZGVyMSA9IHRoaXMuYXJnMS50b0RhdGFzdG9yZU9yZGVyKG9wdF9vcmRlckRpcmVjdGlvbik7XG4gICAgICB2YXIgb3JkZXIyID0gdGhpcy5hcmcyLnRvRGF0YXN0b3JlT3JkZXIob3B0X29yZGVyRGlyZWN0aW9uKTtcbiAgICAgIHJldHVybiBvcmRlcjEuY29uY2F0KG9yZGVyMik7XG4gICAgfVxuICBdXG59KTtcbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmZvYW0uQ0xBU1Moe1xuICBwYWNrYWdlOiAnY29tLmdvb2dsZS5jbG91ZC5kYXRhc3RvcmUnLFxuICBuYW1lOiAnU2VsZWN0RGF0YScsXG5cbiAgZG9jdW1lbnRhdGlvbjogYFN0YXRlIHBhc3NlZCBhcm91bmQgYnkgaW50ZXJtZWRpYXRlIGNhbGxiYWNrcyBkdXJpbmcgYVxuICAgICAgc2VsZWN0KCkgaW4gcHJvZ3Jlc3MuIFRoZXNlIGRhdGEgbXVzdCBiZSByZXRhaW5lZCB0byBub3RpZnkgdGhlIHNpbmssIHNlbmRcbiAgICAgIHRoZSBjb3JyZWN0IHBheWxvYWQgdG8gc3Vic2VxdWVudCBBUEkgY2FsbHMsIGFuZCByZXR1cm4gcmVzdWx0cyBpbiB0aGVcbiAgICAgIFByb21pc2UuYCxcblxuICBwcm9wZXJ0aWVzOiBbXG4gICAge1xuICAgICAgbmFtZTogJ2N0eCdcbiAgICB9LFxuICAgIHtcbiAgICAgIG5hbWU6ICdzaW5rJ1xuICAgIH0sXG4gICAge1xuICAgICAgbmFtZTogJ3JlcXVlc3RQYXlsb2FkJ1xuICAgIH0sXG4gICAge1xuICAgICAgY2xhc3M6ICdBcnJheScsXG4gICAgICBuYW1lOiAncmVzdWx0cydcbiAgICB9LFxuICAgIHtcbiAgICAgIGNsYXNzOiAnQm9vbGVhbicsXG4gICAgICBuYW1lOiAnaGFsdGVkJ1xuICAgIH0sXG4gICAge1xuICAgICAgbmFtZTogJ3N1YicsXG4gICAgICBmYWN0b3J5OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHN1YiA9IGZvYW0uY29yZS5GT2JqZWN0LmNyZWF0ZSgpO1xuICAgICAgICBzdWIub25EZXRhY2goZnVuY3Rpb24oKSB7IHRoaXMuaGFsdGVkID0gdHJ1ZTsgfS5iaW5kKHRoaXMpKTtcbiAgICAgICAgcmV0dXJuIHN1YjtcbiAgICAgIH1cbiAgICB9XG4gIF1cbn0pO1xuXG5mb2FtLkNMQVNTKHtcbiAgcGFja2FnZTogJ2NvbS5nb29nbGUuY2xvdWQuZGF0YXN0b3JlJyxcbiAgbmFtZTogJ0RhdGFzdG9yZURBTycsXG4gIGV4dGVuZHM6ICdmb2FtLmRhby5BYnN0cmFjdERBTycsXG5cbiAgZG9jdW1lbnRhdGlvbjogYERBTyBpbXBsZW1lbnRhdGlvbiBmb3IgdGhlIEdvb2dsZSBDbG91ZCBEYXRhc3RvcmUgdjEgUkVTVCBBUEkuXG5cbiAgICAgIGh0dHBzOi8vY2xvdWQuZ29vZ2xlLmNvbS9kYXRhc3RvcmUvZG9jcy9yZWZlcmVuY2UvcmVzdC9cblxuICAgICAgVGhpcyBpbXBsZW1lbnRhdGlvbiB1c2VzIHN0cnVjdHVyZWQgcXVlcmllcywgbm90IEdRTCBxdWVyaWVzLmAsXG5cbiAgcmVxdWlyZXM6IFtcbiAgICAnY29tLmdvb2dsZS5jbG91ZC5kYXRhc3RvcmUuU2VsZWN0RGF0YScsXG4gICAgJ2ZvYW0uZGFvLkFycmF5U2luaycsXG4gICAgJ2ZvYW0ubmV0LkhUVFBSZXF1ZXN0J1xuICBdLFxuICBpbXBvcnRzOiBbXG4gICAgJ2djbG91ZFByb2plY3RJZD8nLFxuICAgICdkYXRhc3RvcmVOYW1lc3BhY2VJZD8nXG4gIF0sXG5cbiAgY29uc3RhbnRzOiB7XG4gICAgSU5UMzJfTUFYOiBNYXRoLnBvdygyLCAzMSkgLSAxXG4gIH0sXG5cbiAgcHJvcGVydGllczogW1xuICAgIHtcbiAgICAgIGNsYXNzOiAnU3RyaW5nJyxcbiAgICAgIG5hbWU6ICdwcm9qZWN0SWQnLFxuICAgICAgZmFjdG9yeTogZnVuY3Rpb24oKSB7XG4gICAgICAgIGZvYW0uYXNzZXJ0KHRoaXMuZ2Nsb3VkUHJvamVjdElkLCAnRGF0YXN0b3JlREFPIG1pc3NpbmcgJyArXG4gICAgICAgICAgICAnXCJnY2xvdWRQcm9qZWN0SWRcIiBmcm9tIGNvbnRleHQgb3IgXCJwcm9qZWN0SWRcIiBvbiBjb25zdHJ1Y3Rpb24nKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2Nsb3VkUHJvamVjdElkO1xuICAgICAgfSxcbiAgICAgIGZpbmFsOiB0cnVlXG4gICAgfSxcbiAgICB7XG4gICAgICBjbGFzczogJ1N0cmluZycsXG4gICAgICBuYW1lOiAnbmFtZXNwYWNlSWQnLFxuICAgICAgZmFjdG9yeTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGFzdG9yZU5hbWVzcGFjZUlkIHx8ICcnO1xuICAgICAgfSxcbiAgICAgIGZpbmFsOiB0cnVlXG4gICAgfSxcbiAgICB7XG4gICAgICBjbGFzczogJ1N0cmluZycsXG4gICAgICBuYW1lOiAncHJvdG9jb2wnLFxuICAgICAgdmFsdWU6ICdodHRwcycsXG4gICAgICBmaW5hbDogdHJ1ZVxuICAgIH0sXG4gICAge1xuICAgICAgY2xhc3M6ICdTdHJpbmcnLFxuICAgICAgbmFtZTogJ2hvc3QnLFxuICAgICAgdmFsdWU6ICdkYXRhc3RvcmUuZ29vZ2xlYXBpcy5jb20nLFxuICAgICAgZmluYWw6IHRydWVcbiAgICB9LFxuICAgIHtcbiAgICAgIGNsYXNzOiAnSW50JyxcbiAgICAgIG5hbWU6ICdwb3J0JyxcbiAgICAgIHZhbHVlOiA0NDMsXG4gICAgICBmaW5hbDogdHJ1ZVxuICAgIH0sXG4gICAge1xuICAgICAgY2xhc3M6ICdTdHJpbmcnLFxuICAgICAgbmFtZTogJ2Jhc2VVUkwnLFxuICAgICAgZmFjdG9yeTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnByb3RvY29sICsgJzovLycgKyB0aGlzLmhvc3QgKyAnOicgKyB0aGlzLnBvcnQgK1xuICAgICAgICAgICAgJy92MS9wcm9qZWN0cy8nICsgdGhpcy5wcm9qZWN0SWQ7XG4gICAgICB9XG4gICAgfSxcbiAgICB7XG4gICAgICBuYW1lOiAncGFydGl0aW9uSWRfJyxcbiAgICAgIGZhY3Rvcnk6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5uYW1lc3BhY2VJZCA/XG4gICAgICAgICAgICB7IHByb2plY3RJZDogdGhpcy5wcm9qZWN0SWQsIG5hbWVzcGFjZUlkOiB0aGlzLm5hbWVzcGFjZUlkIH0gOlxuICAgICAgICAgICAgeyBwcm9qZWN0SWQ6IHRoaXMucHJvamVjdElkIH07XG4gICAgICB9XG4gICAgfVxuICBdLFxuXG4gIG1ldGhvZHM6IFtcbiAgICBmdW5jdGlvbiBzZW5kUmVxdWVzdChuYW1lLCBvYmpQYXlsb2FkKSB7XG4gICAgICByZXR1cm4gdGhpcy5nZXRSZXF1ZXN0KG5hbWUsIG9ialBheWxvYWQgJiYgSlNPTi5zdHJpbmdpZnkob2JqUGF5bG9hZCkpXG4gICAgICAgICAgLnNlbmQoKTtcbiAgICB9LFxuICAgIGZ1bmN0aW9uIGdldFJlcXVlc3QobmFtZSwgcGF5bG9hZCkge1xuICAgICAgdmFyIGhlYWRlcnMgPSB7IEFjY2VwdDogJ2FwcGxpY2F0aW9uL2pzb24nIH07XG4gICAgICBpZiAoIHBheWxvYWQgKSBoZWFkZXJzWydDb250ZW50LVR5cGUnXSA9ICdhcHBsaWNhdGlvbi9qc29uJztcbiAgICAgIHJldHVybiB0aGlzLkhUVFBSZXF1ZXN0LmNyZWF0ZSh7XG4gICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICB1cmw6IHRoaXMuYmFzZVVSTCArICc6JyArIG5hbWUsXG4gICAgICAgIGhlYWRlcnM6IGhlYWRlcnMsXG4gICAgICAgIHJlc3BvbnNlVHlwZTogJ2pzb24nLFxuICAgICAgICBwYXlsb2FkOiBwYXlsb2FkXG4gICAgICB9KTtcbiAgICB9LFxuXG4gICAgZnVuY3Rpb24gZmluZF8oeCwgaWRPck9iaikge1xuICAgICAgdmFyIGtleSA9IGZvYW0uY29yZS5GT2JqZWN0LmlzSW5zdGFuY2UoaWRPck9iaikgP1xuICAgICAgICAgIGlkT3JPYmouZ2V0RGF0YXN0b3JlS2V5KHRoaXMucGFydGl0aW9uSWRfKSA6XG4gICAgICAgICAgdGhpcy5nZXREYXRhc3RvcmVLZXlGcm9tSWRfKGlkT3JPYmosIHRoaXMucGFydGl0aW9uSWRfKTtcbiAgICAgIHJldHVybiB0aGlzLnNlbmRSZXF1ZXN0KCdsb29rdXAnLCB7IGtleXM6IFsga2V5IF0gfSlcbiAgICAgICAgICAudGhlbih0aGlzLm9uUmVzcG9uc2UuYmluZCh0aGlzLCAnZmluZCcpKVxuICAgICAgICAgIC50aGVuKHRoaXMub25GaW5kUmVzcG9uc2UuYmluZCh0aGlzLCB4KSk7XG4gICAgfSxcbiAgICBmdW5jdGlvbiBwdXRfKHgsIG8pIHtcbiAgICAgIHJldHVybiB0aGlzLnNlbmRSZXF1ZXN0KCdjb21taXQnLCB7XG4gICAgICAgIG1vZGU6ICdOT05fVFJBTlNBQ1RJT05BTCcsXG4gICAgICAgIG11dGF0aW9uczogWyB7IHVwc2VydDogby50b0RhdGFzdG9yZUVudGl0eSh0aGlzLnBhcnRpdGlvbklkXykgfSBdXG4gICAgICB9KS50aGVuKHRoaXMub25SZXNwb25zZS5iaW5kKHRoaXMsICdwdXQnKSlcbiAgICAgICAgICAudGhlbih0aGlzLm9uUHV0UmVzcG9uc2UuYmluZCh0aGlzLCB4LCBvKSk7XG4gICAgfSxcbiAgICBmdW5jdGlvbiByZW1vdmVfKHgsIG8pIHtcbiAgICAgIHJldHVybiB0aGlzLnNlbmRSZXF1ZXN0KCdjb21taXQnLCB7XG4gICAgICAgIG1vZGU6ICdOT05fVFJBTlNBQ1RJT05BTCcsXG4gICAgICAgIG11dGF0aW9uczogWyB7IGRlbGV0ZTogby5nZXREYXRhc3RvcmVLZXkodGhpcy5wYXJ0aXRpb25JZF8pIH0gXVxuICAgICAgfSkudGhlbih0aGlzLm9uUmVzcG9uc2UuYmluZCh0aGlzLCAncmVtb3ZlJykpXG4gICAgICAgICAgLnRoZW4odGhpcy5vblJlbW92ZVJlc3BvbnNlLmJpbmQodGhpcywgeCwgbykpO1xuICAgIH0sXG4gICAgZnVuY3Rpb24gc2VsZWN0Xyh4LCBzaW5rLCBza2lwLCBsaW1pdCwgb3JkZXIsIHByZWRpY2F0ZSkge1xuICAgICAgc2luayA9IHNpbmsgfHwgdGhpcy5BcnJheVNpbmsuY3JlYXRlKCk7XG4gICAgICB2YXIgcGF5bG9hZCA9IHsgcXVlcnk6IHsga2luZDogW1xuICAgICAgICB0aGlzLm9mLmdldENsYXNzRGF0YXN0b3JlS2luZCgpXG4gICAgICBdIH0gfTtcbiAgICAgIHZhciBxdWVyeSA9IHBheWxvYWQucXVlcnk7XG4gICAgICBwYXlsb2FkLnBhcnRpdGlvbklkID0gdGhpcy5wYXJ0aXRpb25JZF87XG4gICAgICBpZiAoIHByZWRpY2F0ZSApIHF1ZXJ5LmZpbHRlciA9IHByZWRpY2F0ZS50b0RhdGFzdG9yZUZpbHRlcigpO1xuICAgICAgaWYgKCBvcmRlciApIHF1ZXJ5Lm9yZGVyID0gb3JkZXIudG9EYXRhc3RvcmVPcmRlcigpO1xuICAgICAgaWYgKCBza2lwICkgcXVlcnkub2Zmc2V0ID0gTWF0aC5taW4oc2tpcCwgdGhpcy5JTlQzMl9NQVgpO1xuICAgICAgaWYgKCBsaW1pdCApIHF1ZXJ5LmxpbWl0ID0gTWF0aC5taW4obGltaXQsIHRoaXMuSU5UMzJfTUFYKTtcbiAgICAgIC8vIE9wdGlvbmFsIFNpbmsgaW50ZXJmYWNlIGV4dGVuc2lvbjpcbiAgICAgIC8vIEFsbG93IGRhdGFzdG9yZS1hd2FyZSBzaW5rcyB0byBkZWNvcmF0ZSBxdWVyeS5cbiAgICAgIGlmICggc2luay5kZWNvcmF0ZURhdGFzdG9yZVF1ZXJ5IClcbiAgICAgICAgc2luay5kZWNvcmF0ZURhdGFzdG9yZVF1ZXJ5KHF1ZXJ5KTtcblxuICAgICAgcmV0dXJuIHRoaXMuc2VuZFJlcXVlc3QoJ3J1blF1ZXJ5JywgcGF5bG9hZClcbiAgICAgICAgICAudGhlbih0aGlzLm9uUmVzcG9uc2UuYmluZCh0aGlzLCAnc2VsZWN0JykpXG4gICAgICAgICAgLnRoZW4odGhpcy5vblNlbGVjdFJlc3BvbnNlLmJpbmQoXG4gICAgICAgICAgICAgIHRoaXMsIHRoaXMuU2VsZWN0RGF0YS5jcmVhdGUoe1xuICAgICAgICAgICAgICAgIGN0eDogeCxcbiAgICAgICAgICAgICAgICBzaW5rOiBzaW5rLFxuICAgICAgICAgICAgICAgIHJlcXVlc3RQYXlsb2FkOiBwYXlsb2FkXG4gICAgICAgICAgICAgIH0pKSk7XG4gICAgfSxcbiAgICBmdW5jdGlvbiByZW1vdmVBbGxfKHgsIHNraXAsIGxpbWl0LCBvcmRlciwgcHJlZGljYXRlKSB7XG4gICAgICByZXR1cm4gdGhpcy5zZWxlY3RfKHgsIHVuZGVmaW5lZCwgc2tpcCwgbGltaXQsIG9yZGVyLCBwcmVkaWNhdGUpXG4gICAgICAgICAgLnRoZW4odGhpcy5vblJlbW92ZUFsbCk7XG4gICAgfSxcblxuICAgIHtcbiAgICAgIG5hbWU6ICdnZXREYXRhc3RvcmVLZXlGcm9tSWRfJyxcbiAgICAgIGRvY3VtZW50YXRpb246IGBIZWxwZXIgZm9yIGZpbmQoKSB0byBjb25zdHJ1Y3QgdGhlIGFwcHJvcHJpYXRlIDpsb29rdXBcbiAgICAgICAgRGF0YXN0b3JlIHF1ZXJ5LmAsXG4gICAgICBjb2RlOiBmdW5jdGlvbihpZCwgcGFydGl0aW9uSWQpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBwYXJ0aXRpb25JZDogcGFydGl0aW9uSWQsXG4gICAgICAgICAgcGF0aDogWyB7XG4gICAgICAgICAgICBraW5kOiB0aGlzLm9mLmdldE93bkNsYXNzRGF0YXN0b3JlS2luZCgpLFxuICAgICAgICAgICAgbmFtZTogY29tLmdvb2dsZS5jbG91ZC5kYXRhc3RvcmUudG9EYXRhc3RvcmVLZXlOYW1lKGlkKVxuICAgICAgICAgIH0gXVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH0sXG4gICAge1xuICAgICAgbmFtZTogJ3NlbGVjdE5leHRCYXRjaF8nLFxuICAgICAgZG9jdW1lbnRhdGlvbjogYE1hc3NhZ2UgZGF0YS5xdWVyeSBhbmQgcmUtaXNzdWUgRGF0YXN0b3JlIDpydW5RdWVyeSB0byBnZXRcbiAgICAgICAgdGhlIG5leHQgYmF0Y2ggb2YgcmVzdWx0cyByZXF1ZXN0ZWQgYnkgc2VsZWN0KCkuYCxcbiAgICAgIGNvZGU6IGZ1bmN0aW9uKGRhdGEsIGJhdGNoKSB7XG4gICAgICAgIHZhciBwYXlsb2FkID0gZGF0YS5yZXF1ZXN0UGF5bG9hZDtcbiAgICAgICAgdmFyIHF1ZXJ5ID0gcGF5bG9hZC5xdWVyeTtcblxuICAgICAgICBwYXlsb2FkLnBhcnRpdGlvbklkID0gdGhpcy5wYXJ0aXRpb25JZF87XG5cbiAgICAgICAgLy8gVXBkYXRlIHF1ZXJ5IHRvIGdldCBuZXh0IGJhdGNoIG9mIHJlc3VsdHMuXG4gICAgICAgIGlmICggcXVlcnkub2Zmc2V0IClcbiAgICAgICAgICBxdWVyeS5vZmZzZXQgPSBxdWVyeS5vZmZzZXQgLSAoIGJhdGNoLnNraXBwZWRSZXN1bHRzIHx8IDAgKTtcbiAgICAgICAgaWYgKCBxdWVyeS5saW1pdCApIHtcbiAgICAgICAgICBxdWVyeS5saW1pdCA9IHF1ZXJ5LmxpbWl0IC1cbiAgICAgICAgICAgICAgKCBiYXRjaC5lbnRpdHlSZXN1bHRzID8gYmF0Y2guZW50aXR5UmVzdWx0cy5sZW5ndGggOiAwICk7XG4gICAgICAgIH1cbiAgICAgICAgcXVlcnkuc3RhcnRDdXJzb3IgPSBiYXRjaC5lbmRDdXJzb3I7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuc2VuZFJlcXVlc3QoJ3J1blF1ZXJ5JywgcGF5bG9hZClcbiAgICAgICAgICAgIC50aGVuKHRoaXMub25SZXNwb25zZS5iaW5kKHRoaXMsICdzZWxlY3QnKSlcbiAgICAgICAgICAgIC50aGVuKHRoaXMub25TZWxlY3RSZXNwb25zZS5iaW5kKHRoaXMsIGRhdGEpKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHtcbiAgICAgIG5hbWU6ICdyZXN1bHRzQXJlSW5jb21wbGV0ZV8nLFxuICAgICAgZG9jdW1lbnRhdGlvbjogYERldGVybWluZSB3aGV0aGVyIG9yIG5vdCBhIGJhdGNoIGNvbnRhaW5zIHRoZSBsYXN0IHJlc3VsdHNcbiAgICAgICAgaW4gYSAocG90ZW50aWFsbHkgXCJsaW1pdFwiZWQpIHF1ZXJ5IHJlc3VsdC4gQWJzdHJhY3RlZCBvdXQgb2ZcbiAgICAgICAgb25TZWxlY3RSZXNwb25zZSgpIHRvIHN1cHBvcnQgZmFrZWQgYmF0Y2hpbmcgaW4gdGVzdHMuYCxcbiAgICAgIGNvZGU6IGZ1bmN0aW9uKGJhdGNoLCBkYXRhKSB7XG4gICAgICAgIHJldHVybiAoICEgZGF0YS5oYWx0ZWQgKSAmJiBiYXRjaC5lbnRpdHlSZXN1bHRzICYmXG4gICAgICAgICAgICBiYXRjaC5lbnRpdHlSZXN1bHRzLmxlbmd0aCA+IDAgJiZcbiAgICAgICAgICAgICggYmF0Y2gubW9yZVJlc3VsdHMgPT09ICdOT1RfRklOSVNIRUQnIHx8XG4gICAgICAgICAgICAgIGJhdGNoLm1vcmVSZXN1bHRzID09PSAnTU9SRV9SRVNVTFRTX0FGVEVSX0NVUlNPUicgKTtcbiAgICAgIH1cbiAgICB9XG4gIF0sXG5cbiAgbGlzdGVuZXJzOiBbXG4gICAgZnVuY3Rpb24gb25SZW1vdmVBbGwoYXJyYXlTaW5rKSB7XG4gICAgICB2YXIgYXJyID0gYXJyYXlTaW5rLmFycmF5O1xuICAgICAgaWYgKCBhcnIubGVuZ3RoID09PSAwICkgcmV0dXJuIHVuZGVmaW5lZDtcblxuICAgICAgcmV0dXJuIHRoaXMuc2VuZFJlcXVlc3QoJ2JlZ2luVHJhbnNhY3Rpb24nKVxuICAgICAgICAgIC50aGVuKHRoaXMub25SZXNwb25zZS5iaW5kKHRoaXMsICdyZW1vdmVBbGwgdHJhbnNhY3Rpb24nKSlcbiAgICAgICAgICAudGhlbih0aGlzLm9uUmVtb3ZlQWxsVHJhbnNhY3Rpb25SZXNwb25zZS5iaW5kKHRoaXMsIGFycikpO1xuICAgIH0sXG5cbiAgICBmdW5jdGlvbiBvblJlc3BvbnNlKG5hbWUsIHJlc3BvbnNlKSB7XG4gICAgICBpZiAoIHJlc3BvbnNlLnN0YXR1cyAhPT0gMjAwICkge1xuICAgICAgICByZXR1cm4gcmVzcG9uc2UucGF5bG9hZC50aGVuKGZ1bmN0aW9uKHBheWxvYWQpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VuZXhwZWN0ZWQgJyArIG5hbWUgKyAnIHJlc3BvbnNlIGNvZGUgZnJvbSBDbG91ZCAnICtcbiAgICAgICAgICAgICAgJ0RhdGFzdG9yZSBlbmRwb2ludDogJyArIHJlc3BvbnNlLnN0YXR1cyArICdcXG5QYXlsb2FkOiAnICtcbiAgICAgICAgICAgICAgSlNPTi5zdHJpbmdpZnkocGF5bG9hZCwgbnVsbCwgMikpO1xuICAgICAgICB9LCBmdW5jdGlvbihlcnJvcikge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVW5leHBlY3RlZCAnICsgbmFtZSArICcgcmVzcG9uc2UgY29kZSBmcm9tIENsb3VkICcgK1xuICAgICAgICAgICAgICAnRGF0YXN0b3JlIGVuZHBvaW50OiAnICsgcmVzcG9uc2Uuc3RhdHVzICtcbiAgICAgICAgICAgICAgJ1xcbkVycm9yIHJldHJpZXZpbmcgcGF5bG9hZDogJyArIGVycm9yKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXNwb25zZS5wYXlsb2FkO1xuICAgIH0sXG4gICAgZnVuY3Rpb24gb25GaW5kUmVzcG9uc2UoeCwganNvbikge1xuICAgICAgaWYgKCAhICgganNvbi5mb3VuZCAmJiBqc29uLmZvdW5kWzBdICYmIGpzb24uZm91bmRbMF0uZW50aXR5ICkgKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIGlmICgganNvbi5mb3VuZC5sZW5ndGggPiAxICkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ011bHRpcGxlIENsb3VkIERhdGFzdG9yZSBlbnRpdGllcyBtYXRjaCAnICtcbiAgICAgICAgICAgICd1bmlxdWUgaWQnKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGNvbS5nb29nbGUuY2xvdWQuZGF0YXN0b3JlLmZyb21EYXRhc3RvcmVFbnRpdHkoXG4gICAgICAgICAganNvbi5mb3VuZFswXS5lbnRpdHksIHgpO1xuICAgIH0sXG4gICAgZnVuY3Rpb24gb25QdXRSZXNwb25zZSh4LCBvLCBqc29uKSB7XG4gICAgICB2YXIgcmVzdWx0cyA9IGpzb24ubXV0YXRpb25SZXN1bHRzO1xuICAgICAgZm9yICggdmFyIGkgPSAwOyBpIDwgcmVzdWx0cy5sZW5ndGg7IGkrKyApIHtcbiAgICAgICAgaWYgKCByZXN1bHRzW2ldLmNvbmZsaWN0RGV0ZWN0ZWQgKVxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignUHV0IHRvIENsb3VkIERhdGFzdG9yZSB5aWVsZGVkIGNvbmZsaWN0Jyk7XG4gICAgICB9XG5cbiAgICAgIHZhciBuZXdPID0gby5jbHNfLmNyZWF0ZShvLCB4KTtcbiAgICAgIHRoaXMucHViKCdvbicsICdwdXQnLCBuZXdPKTtcbiAgICAgIHJldHVybiBuZXdPO1xuICAgIH0sXG4gICAgZnVuY3Rpb24gb25SZW1vdmVSZXNwb25zZSh4LCBvLCBqc29uKSB7XG4gICAgICB2YXIgcmVzdWx0cyA9IGpzb24ubXV0YXRpb25SZXN1bHRzO1xuICAgICAgZm9yICggdmFyIGkgPSAwOyBpIDwgcmVzdWx0cy5sZW5ndGg7IGkrKyApIHtcbiAgICAgICAgaWYgKCByZXN1bHRzW2ldLmNvbmZsaWN0RGV0ZWN0ZWQgKVxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignUmVtb3ZlIGZyb20gQ2xvdWQgRGF0YXN0b3JlIHlpZWxkZWQgY29uZmxpY3QnKTtcbiAgICAgIH1cblxuICAgICAgdmFyIG5ld08gPSBvLmNsc18uY3JlYXRlKG8sIHgpO1xuXG4gICAgICAvLyBDbG91ZCBEYXRhc3RvcmUgd2lsbCBwcm92aWRlIHJlc3VsdHMgd2l0aCB2ZXJzaW9uIG51bWJlcnMgZXZlbiBpZlxuICAgICAgLy8gdGhlIGVudGl0eSBkaWQgbm90IGV4aXN0LiBVc2UgaW5kZXhVcGRhdGVzIGRlZmluZWQtYW5kLW5vbi0wIGFzIGFcbiAgICAgIC8vIHByb3h5IGZvdW5kLWFuZC1kZWxldGVkLlxuICAgICAgaWYgKCBqc29uLmluZGV4VXBkYXRlcyApIHtcbiAgICAgICAgdGhpcy5wdWIoJ29uJywgJ3JlbW92ZScsIG5ld08pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5ld087XG4gICAgfSxcbiAgICBmdW5jdGlvbiBvblNlbGVjdFJlc3BvbnNlKGRhdGEsIGpzb24pIHtcbiAgICAgIHZhciBiYXRjaCA9IGpzb24uYmF0Y2g7XG4gICAgICB2YXIgZW50aXRpZXMgPSBiYXRjaC5lbnRpdHlSZXN1bHRzO1xuXG4gICAgICBpZiAoICEgZW50aXRpZXMgKSB7XG4gICAgICAgIGRhdGEuc2luayAmJiBkYXRhLnNpbmsuZW9mICYmIGRhdGEuc2luay5lb2YoKTtcbiAgICAgICAgcmV0dXJuIGRhdGEuc2luaztcbiAgICAgIH1cblxuICAgICAgLy8gT3B0aW9uYWwgU2luayBpbnRlcmZhY2UgZXh0ZW5zaW9uOlxuICAgICAgLy8gQWxsb3cgZGF0YXN0b3JlLWF3YXJlIHNpbmtzIHRvIHVucGFjayBxdWVyeSByZXN1bHQgYmF0Y2hlcyBtYW51YWxseVxuICAgICAgLy8gaW5zdGVhZCBvZiBEQU8gcHV0KClpbmcgdG8gdGhlbS5cbiAgICAgIGlmICggZGF0YS5zaW5rICYmIGRhdGEuc2luay5mcm9tRGF0YXN0b3JlRW50aXR5UmVzdWx0cyApIHtcbiAgICAgICAgZGF0YS5zaW5rLmZyb21EYXRhc3RvcmVFbnRpdHlSZXN1bHRzKGVudGl0aWVzLCBkYXRhLmN0eCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgZnJvbURhdGFzdG9yZUVudGl0eSA9XG4gICAgICAgICAgICBjb20uZ29vZ2xlLmNsb3VkLmRhdGFzdG9yZS5mcm9tRGF0YXN0b3JlRW50aXR5O1xuICAgICAgICBmb3IgKCB2YXIgaSA9IDA7IGkgPCBlbnRpdGllcy5sZW5ndGg7IGkrKyApIHtcbiAgICAgICAgICB2YXIgb2JqID0gZnJvbURhdGFzdG9yZUVudGl0eShlbnRpdGllc1tpXS5lbnRpdHksIGRhdGEuY3R4KTtcbiAgICAgICAgICBkYXRhLnJlc3VsdHMucHVzaChvYmopO1xuICAgICAgICAgIGRhdGEuc2luayAmJiBkYXRhLnNpbmsucHV0ICYmIGRhdGEuc2luay5wdXQob2JqLCBkYXRhLnN1Yik7XG4gICAgICAgICAgaWYgKCBkYXRhLmhhbHRlZCApIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICggdGhpcy5yZXN1bHRzQXJlSW5jb21wbGV0ZV8oYmF0Y2gsIGRhdGEpICkge1xuICAgICAgICByZXR1cm4gdGhpcy5zZWxlY3ROZXh0QmF0Y2hfKGRhdGEsIGJhdGNoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRhdGEuc2luayAmJiBkYXRhLnNpbmsuZW9mICYmIGRhdGEuc2luay5lb2YoKTtcbiAgICAgICAgcmV0dXJuIGRhdGEuc2luaztcbiAgICAgIH1cbiAgICB9LFxuICAgIGZ1bmN0aW9uIG9uUmVtb3ZlQWxsVHJhbnNhY3Rpb25SZXNwb25zZShhcnIsIGpzb24pIHtcbiAgICAgIHZhciB0cmFuc2FjdGlvbiA9IGpzb24udHJhbnNhY3Rpb247XG4gICAgICB2YXIgZGVsZXRlcyA9IG5ldyBBcnJheShhcnIubGVuZ3RoKTtcbiAgICAgIGZvciAoIHZhciBpID0gMDsgaSA8IGRlbGV0ZXMubGVuZ3RoOyBpKysgKSB7XG4gICAgICAgIGRlbGV0ZXNbaV0gPSB7IGRlbGV0ZTogYXJyW2ldLmdldERhdGFzdG9yZUtleSh0aGlzLnBhcnRpdGlvbklkXykgfTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMuc2VuZFJlcXVlc3QoJ2NvbW1pdCcsIHtcbiAgICAgICAgbW9kZTogJ1RSQU5TQUNUSU9OQUwnLFxuICAgICAgICBtdXRhdGlvbnM6IGRlbGV0ZXMsXG4gICAgICAgIHRyYW5zYWN0aW9uOiB0cmFuc2FjdGlvblxuICAgICAgfSkudGhlbih0aGlzLm9uUmVzcG9uc2UuYmluZCh0aGlzLCAncmVtb3ZlQWxsIGNvbW1pdCcpKVxuICAgICAgICAgIC50aGVuKHRoaXMub25SZW1vdmVBbGxSZXNwb25zZSk7XG4gICAgfSxcbiAgICBmdW5jdGlvbiBvblJlbW92ZUFsbFJlc3BvbnNlKGpzb24pIHtcbiAgICAgIHZhciByZXN1bHRzID0ganNvbi5tdXRhdGlvblJlc3VsdHM7XG4gICAgICBmb3IgKCB2YXIgaSA9IDA7IGkgPCByZXN1bHRzLmxlbmd0aDsgaSsrICkge1xuICAgICAgICBpZiAoIHJlc3VsdHNbaV0uY29uZmxpY3REZXRlY3RlZCApXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdSZW1vdmUgZnJvbSBDbG91ZCBEYXRhc3RvcmUgeWllbGRlZCBjb25mbGljdCcpO1xuICAgICAgfVxuICAgIH1cbiAgXVxufSk7XG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5mb2FtLkVOVU0oe1xuICBwYWNrYWdlOiAnY29tLmdvb2dsZS5jbG91ZC5kYXRhc3RvcmUnLFxuICBuYW1lOiAnRGF0YXN0b3JlTXV0YXRpb25UeXBlJyxcblxuICBwcm9wZXJ0aWVzOiBbXG4gICAge1xuICAgICAgY2xhc3M6ICdTdHJpbmcnLFxuICAgICAgZG9jdW1lbnRhdGlvbjogYFwia2V5XCIgaW4gRGF0YXN0b3JlIEFQSSdzIG11dGF0aW9uczogW3s8a2V5PjogPGRhdGE+fV0uYCxcbiAgICAgIG5hbWU6ICdkYXRhc3RvcmVNdXRhdGlvbktleSdcbiAgICB9XG4gIF0sXG5cbiAgdmFsdWVzOiBbXG4gICAge1xuICAgICAgbmFtZTogJ1VQU0VSVCcsXG4gICAgICBkYXRhc3RvcmVNdXRhdGlvbktleTogJ3Vwc2VydCdcbiAgICB9LFxuICAgIHtcbiAgICAgIG5hbWU6ICdERUxFVEUnLFxuICAgICAgZGF0YXN0b3JlTXV0YXRpb25LZXk6ICdkZWxldGUnXG4gICAgfVxuICBdXG59KTtcblxuZm9hbS5DTEFTUyh7XG4gIHBhY2thZ2U6ICdjb20uZ29vZ2xlLmNsb3VkLmRhdGFzdG9yZScsXG4gIG5hbWU6ICdEYXRhc3RvcmVNdXRhdGlvbicsXG5cbiAgcHJvcGVydGllczogW1xuICAgIHtcbiAgICAgIGNsYXNzOiAnRW51bScsXG4gICAgICBvZjogJ2NvbS5nb29nbGUuY2xvdWQuZGF0YXN0b3JlLkRhdGFzdG9yZU11dGF0aW9uVHlwZScsXG4gICAgICBuYW1lOiAndHlwZSdcbiAgICB9LFxuICAgIHtcbiAgICAgIGRvY3VtZW50YXRpb246IGBcImRhdGFcIiBpbiBEYXRhc3RvcmUgQVBJJ3MgbXV0YXRpb25zOiBbezxrZXk+OiA8ZGF0YT59XS5gLFxuICAgICAgbmFtZTogJ2RhdGEnXG4gICAgfSxcbiAgICB7XG4gICAgICBjbGFzczogJ0Z1bmN0aW9uJyxcbiAgICAgIGRvY3VtZW50YXRpb246IGBSZXNvbHZlIGZ1bmN0aW9uIGZvciBkYXRhc3RvcmUgb3BlcmF0aW9uIHByb21pc2UsXG4gICAgICAgICAgcHJlLWJvdW5kIHRvIHJldHVybiBwYXlsb2FkLmAsXG4gICAgICBuYW1lOiAncmVzb2x2ZSdcbiAgICB9LFxuICAgIHtcbiAgICAgIGNsYXNzOiAnRnVuY3Rpb24nLFxuICAgICAgZG9jdW1lbnRhdGlvbjogYFJlamVjdCBmdW5jdGlvbiBmb3IgZGF0YXN0b3JlIG9wZXJhdGlvbiBwcm9taXNlLCxcbiAgICAgICAgICBwcmUtYm91bmQgdG8gZXJyb3IgcmVwb3J0aW5nIHBheWxvYWQuYCxcbiAgICAgIG5hbWU6ICdyZWplY3QnXG4gICAgfVxuICBdXG59KTtcblxuZm9hbS5DTEFTUyh7XG4gIHBhY2thZ2U6ICdjb20uZ29vZ2xlLmNsb3VkLmRhdGFzdG9yZScsXG4gIG5hbWU6ICdCYXRjaE11dGF0aW9uRGF0YXN0b3JlREFPJyxcbiAgZXh0ZW5kczogJ2NvbS5nb29nbGUuY2xvdWQuZGF0YXN0b3JlLkRhdGFzdG9yZURBTycsXG5cbiAgZG9jdW1lbnRhdGlvbjogYERhdGFzdG9yZSBEQU8gdGhhdCBiYXRjaGVzIHB1dCgpIGFuZCByZW1vdmUoKS4gVGhpcyBjYW4gYmVcbiAgICAgIGNydWNpYWwgdG8gYXZvaWQgYmxvd2luZyBBUEkgcXVvdGEgd2hlbiBwZXJmb3JtaW5nIGJ1bGsgdXBkYXRlcy5gLFxuXG4gIHJlcXVpcmVzOiBbXG4gICAgJ2NvbS5nb29nbGUuY2xvdWQuZGF0YXN0b3JlLkRhdGFzdG9yZU11dGF0aW9uJyxcbiAgICAnY29tLmdvb2dsZS5jbG91ZC5kYXRhc3RvcmUuRGF0YXN0b3JlTXV0YXRpb25UeXBlJ1xuICBdLFxuICBpbXBvcnRzOiBbICdpbmZvJyBdLFxuXG4gIHByb3BlcnRpZXM6IFtcbiAgICB7XG4gICAgICBjbGFzczogJ0ludCcsXG4gICAgICBkb2N1bWVudGF0aW9uOiBgTWF4aW11bSBudW1iZXIgb2Ygb3BlcmF0aW9ucyB0byBpbmNsdWRlIGluIGEgYmF0Y2guXG4gICAgICAgICAgU2luY2UgZWFjaCBlbnRpdHkgbWF5IGJlIGluIGEgZGlmZmVyZW50IGVudGl0eSBncm91cCwgZGVmYXVsdCB0b1xuICAgICAgICAgIHRyYW5zYWN0aW9uIGVudGl0eSBncm91cCBsaW1pdCBvZiAyNSBbMV0uXG5cbiAgICAgICAgICBbMV0gaHR0cHM6Ly9jbG91ZC5nb29nbGUuY29tL2RhdGFzdG9yZS9kb2NzL2NvbmNlcHRzL3RyYW5zYWN0aW9ucyN0cmFuc2FjdGlvbnNfYW5kX2VudGl0eV9ncm91cHNgLFxuICAgICAgbmFtZTogJ2JhdGNoU2l6ZScsXG4gICAgICB2YWx1ZTogMjVcbiAgICB9LFxuICAgIHtcbiAgICAgIGNsYXNzOiAnSW50JyxcbiAgICAgIGRvY3VtZW50YXRpb246IGBNYXhpbXVtIG51bWJlciBvZiBpbi1mbGlnaHQgYmF0Y2hlc1xuICAgICAgICAgIChpLmUuLCB0cmFuc2FjdGlvbnMpLiBEZWZhdWx0IHRvIDEgaW4gY2FzZSBjbGllbnRzIGV4cGVjdCBzdHJpY3RcbiAgICAgICAgICBvcmRlcmluZyBvZiBvcGVyYXRpb25zLiBJbmNyZWFzaW5nIHRvIH4yNSBzZWVtcyB0byB3b3JrIHdlbGwgZm9yIGJ1bGtcbiAgICAgICAgICB1cGRhdGVzIHdoZXJlIG9yZGVyLW9mLW9wZXJhdGlvbnMgZG9lc24ndCBtYXR0ZXIuYCxcbiAgICAgIG5hbWU6ICdudW1CYXRjaGVzJyxcbiAgICAgIHZhbHVlOiAxXG4gICAgfSxcbiAgICB7XG4gICAgICBjbGFzczogJ0ZPYmplY3RBcnJheScsXG4gICAgICBvZjogJ2NvbS5nb29nbGUuY2xvdWQuZGF0YXN0b3JlLkRhdGFzdG9yZU11dGF0aW9uJyxcbiAgICAgIG5hbWU6ICdtdXRhdGlvbnNfJ1xuICAgIH0sXG4gICAge1xuICAgICAgY2xhc3M6ICdJbnQnLFxuICAgICAgZG9jdW1lbnRhdGlvbjogJ051bWJlciBvZiBpbi1mbGlnaHQgdHJhbnNhY3Rpb25zLicsXG4gICAgICBuYW1lOiAnbnVtQWN0aXZlVHJhbnNhY3Rpb25zXydcbiAgICB9XG4gIF0sXG5cbiAgbWV0aG9kczogW1xuICAgIGZ1bmN0aW9uIHB1dF8oeCwgbykge1xuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBzZWxmLm11dGF0aW9uc18ucHVzaChzZWxmLkRhdGFzdG9yZU11dGF0aW9uLmNyZWF0ZSh7XG4gICAgICAgICAgdHlwZTogc2VsZi5EYXRhc3RvcmVNdXRhdGlvblR5cGUuVVBTRVJULFxuICAgICAgICAgIGRhdGE6IG8udG9EYXRhc3RvcmVFbnRpdHkodGhpcy5wYXJ0aXRpb25JZF8pLFxuICAgICAgICAgIHJlc29sdmU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgc2VsZi5wdWIoJ29uJywgJ3B1dCcsIG8pO1xuICAgICAgICAgICAgcmVzb2x2ZShvKTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIHJlamVjdDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZWplY3QobmV3IEVycm9yKCdDbG91ZCBEYXRhc3RvcmUgdHJhbnNhY3Rpb24gZm9yIHB1dCgpIGZhaWxlZCcpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pKTtcbiAgICAgICAgc2VsZi5vbkJhdGNoZWRPcGVyYXRpb24oKTtcbiAgICAgIH0pO1xuICAgIH0sXG4gICAgZnVuY3Rpb24gcmVtb3ZlXyh4LCBvKSB7XG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIHNlbGYubXV0YXRpb25zXy5wdXNoKHNlbGYuRGF0YXN0b3JlTXV0YXRpb24uY3JlYXRlKHtcbiAgICAgICAgICB0eXBlOiBzZWxmLkRhdGFzdG9yZU11dGF0aW9uVHlwZS5ERUxFVEUsXG4gICAgICAgICAgZGF0YTogby5nZXREYXRhc3RvcmVLZXkodGhpcy5wYXJ0aXRpb25JZF8pLFxuICAgICAgICAgIHJlc29sdmU6IGZ1bmN0aW9uKGRpZFJlbW92ZSkge1xuICAgICAgICAgICAgaWYgKCBkaWRSZW1vdmUgKSBzZWxmLnB1Yignb24nLCAncmVtb3ZlJywgbyk7XG4gICAgICAgICAgICByZXNvbHZlKG8pO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgcmVqZWN0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoJ0Nsb3VkIERhdGFzdG9yZSB0cmFuc2FjdGlvbiBmb3IgcmVtb3ZlKCkgZmFpbGVkJykpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSkpO1xuICAgICAgICBzZWxmLm9uQmF0Y2hlZE9wZXJhdGlvbigpO1xuICAgICAgfSk7XG4gICAgfSxcbiAgICBmdW5jdGlvbiBiZWdpbkJhdGNoVHJhbnNhY3Rpb24oKSB7XG4gICAgICBpZiAoIHRoaXMubXV0YXRpb25zXy5sZW5ndGggPT09IDAgKSByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG5cbiAgICAgIHRoaXMuaW5mbyhgQmF0Y2hlZE11dGF0aW9uRGF0YXN0b3JlREFPOiBTZW5kaW5nIGJhdGNoIGZyb20gJHt0aGlzLm11dGF0aW9uc18ubGVuZ3RofSBiYWNrbG9nYCk7XG5cbiAgICAgIHZhciBtdXRhdGlvbnMgPSB0aGlzLm11dGF0aW9uc18uc2xpY2UoMCwgdGhpcy5iYXRjaFNpemUpO1xuICAgICAgdGhpcy5tdXRhdGlvbnNfID0gdGhpcy5tdXRhdGlvbnNfLnNsaWNlKHRoaXMuYmF0Y2hTaXplKTtcblxuICAgICAgdGhpcy5udW1BY3RpdmVUcmFuc2FjdGlvbnNfKys7XG5cbiAgICAgIHJldHVybiB0aGlzLmdldFJlcXVlc3QoJ2JlZ2luVHJhbnNhY3Rpb24nKS5zZW5kKClcbiAgICAgICAgICAudGhlbih0aGlzLm9uUmVzcG9uc2UuYmluZCh0aGlzLCAnYmF0Y2ggdHJhbnNhY3Rpb24nKSlcbiAgICAgICAgICAudGhlbih0aGlzLm9uQmF0Y2hUcmFuc2FjdGlvblJlc3BvbnNlLmJpbmQodGhpcywgbXV0YXRpb25zKSk7XG4gICAgfVxuICBdLFxuXG4gIGxpc3RlbmVyczogW1xuICAgIHtcbiAgICAgIG5hbWU6ICdvbkJhdGNoZWRPcGVyYXRpb24nLFxuICAgICAgaXNNZXJnZWQ6IHRydWUsXG4gICAgICBtZXJnZURlbGF5OiAxNTAsXG4gICAgICBjb2RlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgZm9hbS5hc3NlcnQoXG4gICAgICAgICAgdGhpcy5tdXRhdGlvbnNfLmxlbmd0aCA+IDAsXG4gICAgICAgICAgJ0JhdGNoZWRNdXRhdGlvbkRhdGFzdG9yZURBTzogQXR0ZW1wdCB0byBiYXRjaCBubyBvcGVyYXRpb25zJyk7XG5cbiAgICAgICAgdmFyIHByb21pc2VzID0gW107XG4gICAgICAgIGZvciAoIHZhciBpID0gdGhpcy5udW1BY3RpdmVUcmFuc2FjdGlvbnNfOyBpIDwgdGhpcy5udW1CYXRjaGVzOyBpKysgKSB7XG4gICAgICAgICAgdGhpcy5iZWdpbkJhdGNoVHJhbnNhY3Rpb24oKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBQcm9taXNlLmFsbChwcm9taXNlcyk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIGZ1bmN0aW9uIG9uQmF0Y2hUcmFuc2FjdGlvblJlc3BvbnNlKG11dGF0aW9ucywganNvbikge1xuICAgICAgdmFyIG11dGF0aW9uRGF0YSA9IG5ldyBBcnJheShtdXRhdGlvbnMubGVuZ3RoKTtcbiAgICAgIHZhciB0cmFuc2FjdGlvbiA9IGpzb24udHJhbnNhY3Rpb247XG5cbiAgICAgIGZvciAoIHZhciBpID0gMDsgaSA8IG11dGF0aW9ucy5sZW5ndGg7IGkrKyApIHtcbiAgICAgICAgbXV0YXRpb25EYXRhW2ldID0ge307XG4gICAgICAgIG11dGF0aW9uRGF0YVtpXVttdXRhdGlvbnNbaV0udHlwZS5kYXRhc3RvcmVNdXRhdGlvbktleV0gPVxuICAgICAgICAgIG11dGF0aW9uc1tpXS5kYXRhO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5nZXRSZXF1ZXN0KCdjb21taXQnLCBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgIG1vZGU6ICdUUkFOU0FDVElPTkFMJyxcbiAgICAgICAgbXV0YXRpb25zOiBtdXRhdGlvbkRhdGEsXG4gICAgICAgIHRyYW5zYWN0aW9uOiB0cmFuc2FjdGlvblxuICAgICAgfSkpLnNlbmQoKS50aGVuKHRoaXMub25SZXNwb25zZS5iaW5kKHRoaXMsICdiYXRjaCBjb21taXQnKSlcbiAgICAgICAgICAudGhlbih0aGlzLm9uQmF0Y2hSZXNwb25zZS5iaW5kKHRoaXMsIG11dGF0aW9ucykpXG4gICAgICAgICAgLmNhdGNoKHRoaXMub25CYXRjaEZhaWx1cmUuYmluZCh0aGlzLCBtdXRhdGlvbnMpKTtcbiAgICB9LFxuICAgIGZ1bmN0aW9uIG9uQmF0Y2hSZXNwb25zZShtdXRhdGlvbnMsIGpzb24pIHtcbiAgICAgIHZhciByZXN1bHRzID0ganNvbi5tdXRhdGlvblJlc3VsdHM7XG4gICAgICBmb3IgKCB2YXIgaSA9IDA7IGkgPCByZXN1bHRzLmxlbmd0aDsgaSsrICkge1xuICAgICAgICBpZiAoIHJlc3VsdHNbaV0uY29uZmxpY3REZXRlY3RlZCApXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdCYXRjaGVkIG11dGF0aW9ucyBpbiBDbG91ZCBEYXRhc3RvcmUgeWllbGRlZCBjb25mbGljdCcpO1xuICAgICAgfVxuXG4gICAgICAvLyBDbG91ZCBEYXRhc3RvcmUgd2lsbCBwcm92aWRlIHJlc3VsdHMgd2l0aCB2ZXJzaW9uIG51bWJlcnMgZXZlbiBpZlxuICAgICAgLy8gdGhlIGVudGl0eSBkaWQgbm90IGV4aXN0LiBVc2UgaW5kZXhVcGRhdGVzIGRlZmluZWQtYW5kLW5vbi0wIGFzIGFcbiAgICAgIC8vIHByb3h5IGZvdW5kLWFuZC1kZWxldGVkLlxuICAgICAgLy9cbiAgICAgIC8vIFRPRE8obWFya2RpdHRtZXIpOiBUaGlzIGlzIGEgcG9vciBwcm94eSB3aGVuIG9wZXJhdGlvbnMgYXJlIGJhdGNoZWQuXG4gICAgICB2YXIgb3BlcmF0aW9uQ29tcGxldGUgPSAhISBqc29uLmluZGV4VXBkYXRlcztcbiAgICAgIGZvciAoIHZhciBpID0gMDsgaSA8IG11dGF0aW9ucy5sZW5ndGg7IGkrKyApIHtcbiAgICAgICAgbXV0YXRpb25zW2ldLnJlc29sdmUob3BlcmF0aW9uQ29tcGxldGUpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLm51bUFjdGl2ZVRyYW5zYWN0aW9uc18tLTtcblxuICAgICAgLy8gUmVwbGFjZSB0aGlzIHRyYW5zYWN0aW9uIHdpdGggYSBuZXcgb25lLlxuICAgICAgdGhpcy5iZWdpbkJhdGNoVHJhbnNhY3Rpb24oKTtcbiAgICB9LFxuICAgIGZ1bmN0aW9uIG9uQmF0Y2hGYWlsdXJlKG11dGF0aW9ucykge1xuICAgICAgZm9yICggdmFyIGkgPSAwOyBpIDwgbXV0YXRpb25zLmxlbmd0aDsgaSsrICkge1xuICAgICAgICBtdXRhdGlvbnNbaV0ucmVqZWN0KCk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMubnVtQWN0aXZlVHJhbnNhY3Rpb25zXy0tO1xuXG4gICAgICAvLyBSZXBsYWNlIHRoaXMgdHJhbnNhY3Rpb24gd2l0aCBhIG5ldyBvbmUuXG4gICAgICB0aGlzLmJlZ2luQmF0Y2hUcmFuc2FjdGlvbigpO1xuICAgIH1cbiAgXVxufSk7XG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG4oZnVuY3Rpb24oKSB7XG4gIC8vIEJ5IGRlY3JlZSBvZjpcbiAgLy8gaHR0cDovL3hhaGxlZS5pbmZvL2pzL2h0bWw1X25vbi1jbG9zaW5nX3RhZy5odG1sXG4gIHZhciBzZWxmQ2xvc2luZ05vZGVOYW1lcyA9IHtcbiAgICBhcmVhOiB0cnVlLFxuICAgIGJhc2U6IHRydWUsXG4gICAgYnI6IHRydWUsXG4gICAgY29sOiB0cnVlLFxuICAgIGNvbW1hbmQ6IHRydWUsXG4gICAgZW1iZWQ6IHRydWUsXG4gICAgaHI6IHRydWUsXG4gICAgaW1nOiB0cnVlLFxuICAgIGlucHV0OiB0cnVlLFxuICAgIGtleWdlbjogdHJ1ZSxcbiAgICBsaW5rOiB0cnVlLFxuICAgIG1ldGE6IHRydWUsXG4gICAgcGFyYW06IHRydWUsXG4gICAgc291cmNlOiB0cnVlLFxuICAgIHRyYWNrOiB0cnVlLFxuICAgIHdicjogdHJ1ZVxuICB9O1xuXG4gIC8vIEJ5IGRlY3JlZSBvZjpcbiAgLy8gaHR0cDovL3d3dy50aGV1a3dlYmRlc2lnbmNvbXBhbnkuY29tL2FydGljbGVzL2VudGl0eS1lc2NhcGUtY2hhcmFjdGVycy5waHBcbiAgdmFyIHVuZXNjYXBlTWFwID0ge1xuICAgICcjMTAwJzogJ2QnLFxuICAgICcjMTAxJzogJ2UnLFxuICAgICcjMTAyJzogJ2YnLFxuICAgICcjMTAzJzogJ2cnLFxuICAgICcjMTA0JzogJ2gnLFxuICAgICcjMTA1JzogJ2knLFxuICAgICcjMTA2JzogJ2onLFxuICAgICcjMTA3JzogJ2snLFxuICAgICcjMTA4JzogJ2wnLFxuICAgICcjMTA5JzogJ20nLFxuICAgICcjMTEwJzogJ24nLFxuICAgICcjMTExJzogJ28nLFxuICAgICcjMTEyJzogJ3AnLFxuICAgICcjMTEzJzogJ3EnLFxuICAgICcjMTE0JzogJ3InLFxuICAgICcjMTE1JzogJ3MnLFxuICAgICcjMTE2JzogJ3QnLFxuICAgICcjMTE3JzogJ3UnLFxuICAgICcjMTE4JzogJ3YnLFxuICAgICcjMTE5JzogJ3cnLFxuICAgICcjMTIwJzogJ3gnLFxuICAgICcjMTIxJzogJ3knLFxuICAgICcjMTIyJzogJ3onLFxuICAgICcjMTIzJzogJ3snLFxuICAgICcjMTI0JzogJ3wnLFxuICAgICcjMTI1JzogJ30nLFxuICAgICcjMTI2JzogJ34nLFxuICAgICcjMTYwJzogJyAnLFxuICAgICcjMTYxJzogJ8KhJyxcbiAgICAnIzE2Mic6ICfCoicsXG4gICAgJyMxNjMnOiAnwqMnLFxuICAgICcjMTY0JzogJ8KkJyxcbiAgICAnIzE2NSc6ICfCpScsXG4gICAgJyMxNjYnOiAnwqYnLFxuICAgICcjMTY3JzogJ8KnJyxcbiAgICAnIzE2OCc6ICfCqCcsXG4gICAgJyMxNjknOiAnwqknLFxuICAgICcjMTcwJzogJ8KqJyxcbiAgICAnIzE3MSc6ICfCqycsXG4gICAgJyMxNzInOiAnwqwnLFxuICAgICcjMTc0JzogJ8KuJyxcbiAgICAnIzE3NSc6ICfCrycsXG4gICAgJyMxNzYnOiAnwrAnLFxuICAgICcjMTc3JzogJ8KxJyxcbiAgICAnIzE3OCc6ICfCsicsXG4gICAgJyMxNzknOiAnwrMnLFxuICAgICcjMTgwJzogJ8K0JyxcbiAgICAnIzE4MSc6ICfCtScsXG4gICAgJyMxODInOiAnwrYnLFxuICAgICcjMTgzJzogJ8K3JyxcbiAgICAnIzE4NCc6ICfCuCcsXG4gICAgJyMxODUnOiAnwrknLFxuICAgICcjMTg2JzogJ8K6JyxcbiAgICAnIzE4Nyc6ICfCuycsXG4gICAgJyMxODgnOiAnwrwnLFxuICAgICcjMTg5JzogJ8K9JyxcbiAgICAnIzE5JzogJ8OFJyxcbiAgICAnIzE5MCc6ICfCvicsXG4gICAgJyMxOTEnOiAnwr8nLFxuICAgICcjMTkyJzogJ8OAJyxcbiAgICAnIzE5Myc6ICfDgScsXG4gICAgJyMxOTQnOiAnw4InLFxuICAgICcjMTk1JzogJ8ODJyxcbiAgICAnIzE5Nic6ICfDhCcsXG4gICAgJyMxOTgnOiAnw4YnLFxuICAgICcjMTk5JzogJ8OHJyxcbiAgICAnIzIwMCc6ICfDiCcsXG4gICAgJyMyMDEnOiAnw4knLFxuICAgICcjMjAyJzogJ8OKJyxcbiAgICAnIzIwMyc6ICfDiycsXG4gICAgJyMyMDQnOiAnw4wnLFxuICAgICcjMjA1JzogJ8ONJyxcbiAgICAnIzIwNic6ICfDjicsXG4gICAgJyMyMDcnOiAnw48nLFxuICAgICcjMjA4JzogJ8OQJyxcbiAgICAnIzIwOSc6ICfDkScsXG4gICAgJyMyMTAnOiAnw5InLFxuICAgICcjMjExJzogJ8OTJyxcbiAgICAnIzIxMic6ICfDlCcsXG4gICAgJyMyMTMnOiAnw5UnLFxuICAgICcjMjE0JzogJ8OWJyxcbiAgICAnIzIxNSc6ICfDlycsXG4gICAgJyMyMTYnOiAnw5gnLFxuICAgICcjMjE3JzogJ8OZJyxcbiAgICAnIzIxOCc6ICfDmicsXG4gICAgJyMyMTknOiAnw5snLFxuICAgICcjMjIwJzogJ8OcJyxcbiAgICAnIzIyMSc6ICfDnScsXG4gICAgJyMyMjInOiAnw54nLFxuICAgICcjMjIzJzogJ8OfJyxcbiAgICAnIzIyNCc6ICfDoCcsXG4gICAgJyMyMjUnOiAnw6EnLFxuICAgICcjMjI2JzogJ8OiJyxcbiAgICAnIzIyNyc6ICfDoycsXG4gICAgJyMyMjgnOiAnw6QnLFxuICAgICcjMjI5JzogJ8OlJyxcbiAgICAnIzIzJzogJ8OtJyxcbiAgICAnIzIzMCc6ICfDpicsXG4gICAgJyMyMzEnOiAnw6cnLFxuICAgICcjMjMyJzogJ8OoJyxcbiAgICAnIzIzMyc6ICfDqScsXG4gICAgJyMyMzQnOiAnw6onLFxuICAgICcjMjM1JzogJ8OrJyxcbiAgICAnIzIzNic6ICfDrCcsXG4gICAgJyMyMzgnOiAnw64nLFxuICAgICcjMjM5JzogJ8OvJyxcbiAgICAnIzI0MCc6ICfDsCcsXG4gICAgJyMyNDEnOiAnw7EnLFxuICAgICcjMjQyJzogJ8OyJyxcbiAgICAnIzI0Myc6ICfDsycsXG4gICAgJyMyNDQnOiAnw7QnLFxuICAgICcjMjQ1JzogJ8O1JyxcbiAgICAnIzI0Nic6ICfDticsXG4gICAgJyMyNDcnOiAnw7cnLFxuICAgICcjMjQ4JzogJ8O4JyxcbiAgICAnIzI0OSc6ICfDuScsXG4gICAgJyMyNTAnOiAnw7onLFxuICAgICcjMjUxJzogJ8O7JyxcbiAgICAnIzI1Mic6ICfDvCcsXG4gICAgJyMyNTMnOiAnw70nLFxuICAgICcjMjU0JzogJ8O+JyxcbiAgICAnIzI1NSc6ICfDvycsXG4gICAgJyMyNTYnOiAnxIAnLFxuICAgICcjMjU3JzogJ8SBJyxcbiAgICAnIzI1OCc6ICfEgicsXG4gICAgJyMyNTknOiAnxIMnLFxuICAgICcjMjYwJzogJ8SEJyxcbiAgICAnIzI2MSc6ICfEhScsXG4gICAgJyMyNjInOiAnxIYnLFxuICAgICcjMjYzJzogJ8SHJyxcbiAgICAnIzI2NCc6ICfEiCcsXG4gICAgJyMyNjUnOiAnxIknLFxuICAgICcjMjY2JzogJ8SKJyxcbiAgICAnIzI2Nyc6ICfEiycsXG4gICAgJyMyNjgnOiAnxIwnLFxuICAgICcjMjY5JzogJ8SNJyxcbiAgICAnIzI3JzogJ8SVJyxcbiAgICAnIzI3MCc6ICfEjicsXG4gICAgJyMyNzEnOiAnxI8nLFxuICAgICcjMjcyJzogJ8SQJyxcbiAgICAnIzI3Myc6ICfEkScsXG4gICAgJyMyNzQnOiAnxJInLFxuICAgICcjMjc1JzogJ8STJyxcbiAgICAnIzI3Nic6ICfElCcsXG4gICAgJyMyNzgnOiAnxJYnLFxuICAgICcjMjc5JzogJ8SXJyxcbiAgICAnIzI4MCc6ICfEmCcsXG4gICAgJyMyODEnOiAnxJknLFxuICAgICcjMjgyJzogJ8SaJyxcbiAgICAnIzI4Myc6ICfEmycsXG4gICAgJyMyODQnOiAnxJwnLFxuICAgICcjMjg1JzogJ8SdJyxcbiAgICAnIzI4Nic6ICfEnicsXG4gICAgJyMyODcnOiAnxJ8nLFxuICAgICcjMjg4JzogJ8SgJyxcbiAgICAnIzI4OSc6ICfEoScsXG4gICAgJyMyOTAnOiAnxKInLFxuICAgICcjMjkxJzogJ8SjJyxcbiAgICAnIzI5Mic6ICfEpCcsXG4gICAgJyMyOTMnOiAnxKUnLFxuICAgICcjMjk0JzogJ8SmJyxcbiAgICAnIzI5NSc6ICfEpycsXG4gICAgJyMyOTYnOiAnxKgnLFxuICAgICcjMjk3JzogJ8SpJyxcbiAgICAnIzI5OCc6ICfEqicsXG4gICAgJyMyOTknOiAnxKsnLFxuICAgICcjMzAwJzogJ8SsJyxcbiAgICAnIzMwMSc6ICfErScsXG4gICAgJyMzMDInOiAnxK4nLFxuICAgICcjMzAzJzogJ8SvJyxcbiAgICAnIzMwNCc6ICfEsCcsXG4gICAgJyMzMDUnOiAnxLEnLFxuICAgICcjMzA2JzogJ8SyJyxcbiAgICAnIzMwNyc6ICfEsycsXG4gICAgJyMzMDgnOiAnxLQnLFxuICAgICcjMzA5JzogJ8S1JyxcbiAgICAnIzMxJzogJ8S9JyxcbiAgICAnIzMxMCc6ICfEticsXG4gICAgJyMzMTEnOiAnxLcnLFxuICAgICcjMzEyJzogJ8S4JyxcbiAgICAnIzMxMyc6ICfEuScsXG4gICAgJyMzMTQnOiAnxLonLFxuICAgICcjMzE1JzogJ8S7JyxcbiAgICAnIzMxNic6ICfEvCcsXG4gICAgJyMzMTgnOiAnxL4nLFxuICAgICcjMzE5JzogJ8S/JyxcbiAgICAnIzMyJzogJyAnLFxuICAgICcjMzIwJzogJ8WAJyxcbiAgICAnIzMyMSc6ICfFgScsXG4gICAgJyMzMjInOiAnxYInLFxuICAgICcjMzIzJzogJ8WDJyxcbiAgICAnIzMyNCc6ICfFhCcsXG4gICAgJyMzMjUnOiAnxYUnLFxuICAgICcjMzI2JzogJ8WGJyxcbiAgICAnIzMyNyc6ICfFhycsXG4gICAgJyMzMjgnOiAnxYgnLFxuICAgICcjMzI5JzogJ8WJJyxcbiAgICAnIzMzJzogJyEnLFxuICAgICcjMzMwJzogJ8WKJyxcbiAgICAnIzMzMSc6ICfFiycsXG4gICAgJyMzMzInOiAnxYwnLFxuICAgICcjMzMzJzogJ8WNJyxcbiAgICAnIzMzNCc6ICfFjicsXG4gICAgJyMzMzUnOiAnxY8nLFxuICAgICcjMzM2JzogJ8WQJyxcbiAgICAnIzMzNyc6ICfFkScsXG4gICAgJyMzMzgnOiAnxZInLFxuICAgICcjMzM5JzogJ8WTJyxcbiAgICAnIzM0JzogJ1wiJyxcbiAgICAnIzM0MCc6ICfFlCcsXG4gICAgJyMzNDAnOiAnxZQnLFxuICAgICcjMzQxJzogJ8WVJyxcbiAgICAnIzM0MSc6ICfFlScsXG4gICAgJyMzNDInOiAnxZYnLFxuICAgICcjMzQyJzogJ8WWJyxcbiAgICAnIzM0Myc6ICfFlycsXG4gICAgJyMzNDMnOiAnxZcnLFxuICAgICcjMzQ0JzogJ8WYJyxcbiAgICAnIzM0NCc6ICfFmCcsXG4gICAgJyMzNDUnOiAnxZknLFxuICAgICcjMzQ1JzogJ8WZJyxcbiAgICAnIzM0Nic6ICfFmicsXG4gICAgJyMzNDYnOiAnxZonLFxuICAgICcjMzQ3JzogJ8WbJyxcbiAgICAnIzM0Nyc6ICfFmycsXG4gICAgJyMzNDgnOiAnxZwnLFxuICAgICcjMzQ4JzogJ8WcJyxcbiAgICAnIzM0OSc6ICfFnScsXG4gICAgJyMzNDknOiAnxZ0nLFxuICAgICcjMzUnOiAnIycsXG4gICAgJyMzNSc6ICfFpScsXG4gICAgJyMzNTAnOiAnxZ4nLFxuICAgICcjMzUwJzogJ8WeJyxcbiAgICAnIzM1MSc6ICfFnycsXG4gICAgJyMzNTEnOiAnxZ8nLFxuICAgICcjMzUyJzogJ8WgJyxcbiAgICAnIzM1Mic6ICfFoCcsXG4gICAgJyMzNTMnOiAnxaEnLFxuICAgICcjMzUzJzogJ8WhJyxcbiAgICAnIzM1NCc6ICfFoicsXG4gICAgJyMzNTQnOiAnxaInLFxuICAgICcjMzU1JzogJ8WjJyxcbiAgICAnIzM1NSc6ICfFoycsXG4gICAgJyMzNTYnOiAnxaQnLFxuICAgICcjMzU2JzogJ8WkJyxcbiAgICAnIzM1OCc6ICfFpicsXG4gICAgJyMzNTgnOiAnxaYnLFxuICAgICcjMzU5JzogJ8WnJyxcbiAgICAnIzM1OSc6ICfFpycsXG4gICAgJyMzNic6ICckJyxcbiAgICAnIzM2MCc6ICfFqCcsXG4gICAgJyMzNjAnOiAnxagnLFxuICAgICcjMzYxJzogJ8WpJyxcbiAgICAnIzM2MSc6ICfFqScsXG4gICAgJyMzNjInOiAnxaonLFxuICAgICcjMzYyJzogJ8WqJyxcbiAgICAnIzM2Myc6ICfFqycsXG4gICAgJyMzNjMnOiAnxasnLFxuICAgICcjMzY0JzogJ8WsJyxcbiAgICAnIzM2NCc6ICfFrCcsXG4gICAgJyMzNjUnOiAnxa0nLFxuICAgICcjMzY1JzogJ8WtJyxcbiAgICAnIzM2Nic6ICfFricsXG4gICAgJyMzNjYnOiAnxa4nLFxuICAgICcjMzY3JzogJ8WvJyxcbiAgICAnIzM2Nyc6ICfFrycsXG4gICAgJyMzNjgnOiAnxbAnLFxuICAgICcjMzY4JzogJ8WwJyxcbiAgICAnIzM2OSc6ICfFsScsXG4gICAgJyMzNjknOiAnxbEnLFxuICAgICcjMzcnOiAnJScsXG4gICAgJyMzNyc6ICfFuScsXG4gICAgJyMzNzAnOiAnxbInLFxuICAgICcjMzcwJzogJ8WyJyxcbiAgICAnIzM3MSc6ICfFsycsXG4gICAgJyMzNzEnOiAnxbMnLFxuICAgICcjMzcyJzogJ8W0JyxcbiAgICAnIzM3Mic6ICfFtCcsXG4gICAgJyMzNzMnOiAnxbUnLFxuICAgICcjMzczJzogJ8W1JyxcbiAgICAnIzM3NCc6ICfFticsXG4gICAgJyMzNzQnOiAnxbYnLFxuICAgICcjMzc1JzogJ8W3JyxcbiAgICAnIzM3NSc6ICfFtycsXG4gICAgJyMzNzYnOiAnxbgnLFxuICAgICcjMzc2JzogJ8W4JyxcbiAgICAnIzM3Nyc6ICfFuScsXG4gICAgJyMzNzgnOiAnxbonLFxuICAgICcjMzc4JzogJ8W6JyxcbiAgICAnIzM3OSc6ICfFuycsXG4gICAgJyMzNzknOiAnxbsnLFxuICAgICcjMzgnOiAnJicsXG4gICAgJyMzODAnOiAnxbwnLFxuICAgICcjMzgwJzogJ8W8JyxcbiAgICAnIzM4MSc6ICfFvScsXG4gICAgJyMzODEnOiAnxb0nLFxuICAgICcjMzgyJzogJ8W+JyxcbiAgICAnIzM4Mic6ICfFvicsXG4gICAgJyMzODMnOiAnxb8nLFxuICAgICcjMzgzJzogJ8W/JyxcbiAgICAnIzM5JzogJ1xcJycsXG4gICAgJyM0MCc6ICcoJyxcbiAgICAnIzQxJzogJyknLFxuICAgICcjNDInOiAnKicsXG4gICAgJyM0Myc6ICcrJyxcbiAgICAnIzQ0JzogJywnLFxuICAgICcjNDUnOiAnLScsXG4gICAgJyM0Nic6ICcuJyxcbiAgICAnIzQ3JzogJy8nLFxuICAgICcjNDgnOiAnMCcsXG4gICAgJyM0OSc6ICcxJyxcbiAgICAnIzUwJzogJzInLFxuICAgICcjNTEnOiAnMycsXG4gICAgJyM1Mic6ICc0JyxcbiAgICAnIzUzJzogJzUnLFxuICAgICcjNTQnOiAnNicsXG4gICAgJyM1NSc6ICc3JyxcbiAgICAnIzU2JzogJzgnLFxuICAgICcjNTcnOiAnOScsXG4gICAgJyM1NzcnOiAnxaUnLFxuICAgICcjNTgnOiAnOicsXG4gICAgJyM1OSc6ICc7JyxcbiAgICAnIzYwJzogJzwnLFxuICAgICcjNjEnOiAnPScsXG4gICAgJyM2Mic6ICc+JyxcbiAgICAnIzYzJzogJz8nLFxuICAgICcjNjQnOiAnQCcsXG4gICAgJyM2NSc6ICdBJyxcbiAgICAnIzY2JzogJ0InLFxuICAgICcjNjcnOiAnQycsXG4gICAgJyM2OCc6ICdEJyxcbiAgICAnIzY5JzogJ0UnLFxuICAgICcjNzAnOiAnRicsXG4gICAgJyM3MSc6ICdHJyxcbiAgICAnIzcyJzogJ0gnLFxuICAgICcjNzMnOiAnSScsXG4gICAgJyM3NCc6ICdKJyxcbiAgICAnIzc1JzogJ0snLFxuICAgICcjNzYnOiAnTCcsXG4gICAgJyM3Nyc6ICdNJyxcbiAgICAnIzc4JzogJ04nLFxuICAgICcjNzknOiAnTycsXG4gICAgJyM4MCc6ICdQJyxcbiAgICAnIzgxJzogJ1EnLFxuICAgICcjODInOiAnUicsXG4gICAgJyM4Myc6ICdTJyxcbiAgICAnIzg0JzogJ1QnLFxuICAgICcjODQ4Mic6ICfihKInLFxuICAgICcjODUnOiAnVScsXG4gICAgJyM4Nic6ICdWJyxcbiAgICAnIzg3JzogJ1cnLFxuICAgICcjODgnOiAnWCcsXG4gICAgJyM4OSc6ICdZJyxcbiAgICAnIzkwJzogJ1onLFxuICAgICcjOTEnOiAnWycsXG4gICAgJyM5Mic6ICdcXFxcJyxcbiAgICAnIzkzJzogJ10nLFxuICAgICcjOTQnOiAnXicsXG4gICAgJyM5NSc6ICdfJyxcbiAgICAnIzk2JzogJ2AnLFxuICAgICcjOTcnOiAnYScsXG4gICAgJyM5OCc6ICdiJyxcbiAgICAnIzk5JzogJ2MnLFxuICAgICcmIzE3MzsnOiAnJyxcbiAgICAnQUVsaWcnOiAnw4YnLFxuICAgICdBYWN1dGUnOiAnw4EnLFxuICAgICdBY2lyYyc6ICfDgicsXG4gICAgJ0FncmF2ZSc6ICfDgCcsXG4gICAgJ0FyaW5nJzogJ8OFJyxcbiAgICAnQXRpbGRlJzogJ8ODJyxcbiAgICAnQXVtbCc6ICfDhCcsXG4gICAgJ0NjZWRpbCc6ICfDhycsXG4gICAgJ0VUSCc6ICfDkCcsXG4gICAgJ0VhY3V0ZSc6ICfDiScsXG4gICAgJ0VjaXJjJzogJ8OKJyxcbiAgICAnRWdyYXZlJzogJ8OIJyxcbiAgICAnRXVtbCc6ICfDiycsXG4gICAgJ0lhY3V0ZSc6ICfDjScsXG4gICAgJ0ljaXJjJzogJ8OOJyxcbiAgICAnSWdyYXZlJzogJ8OMJyxcbiAgICAnSXVtbCc6ICfDjycsXG4gICAgJ050aWxkZSc6ICfDkScsXG4gICAgJ09hY3V0ZSc6ICfDkycsXG4gICAgJ09jaXJjJzogJ8OUJyxcbiAgICAnT2dyYXZlJzogJ8OSJyxcbiAgICAnT3NsYXNoJzogJ8OYJyxcbiAgICAnT3RpbGRlJzogJ8OVJyxcbiAgICAnT3VtbCc6ICfDlicsXG4gICAgJ1RIT1JOJzogJ8OeJyxcbiAgICAnVWFjdXRlJzogJ8OaJyxcbiAgICAnVWNpcmMnOiAnw5snLFxuICAgICdVZ3JhdmUnOiAnw5knLFxuICAgICdVdW1sJzogJ8OcJyxcbiAgICAnWWFjdXRlJzogJ8OdJyxcbiAgICAnYWFjdXRlJzogJ8OhJyxcbiAgICAnYWNpcmMnOiAnw6InLFxuICAgICdhY3V0ZSc6ICfCtCcsXG4gICAgJ2FlbGlnJzogJ8OmJyxcbiAgICAnYWdyYXZlJzogJ8OgJyxcbiAgICAnYW1wJzogJyYnLFxuICAgICdhcmluZyc6ICfDpScsXG4gICAgJ2F0aWxkZSc6ICfDoycsXG4gICAgJ2F1bWwnOiAnw6QnLFxuICAgICdicnZiYXInOiAnwqYnLFxuICAgICdjY2VkaWwnOiAnw6cnLFxuICAgICdjZWRpbCc6ICfCuCcsXG4gICAgJ2NlbnQnOiAnwqInLFxuICAgICdjb3B5JzogJ8KpJyxcbiAgICAnY3VycmVuJzogJ8KkJyxcbiAgICAnZGVnJzogJ8KwJyxcbiAgICAnZGl2aWRlJzogJ8O3JyxcbiAgICAnZWFjdXRlJzogJ8OpJyxcbiAgICAnZWNpcmMnOiAnw6onLFxuICAgICdlZ3JhdmUnOiAnw6gnLFxuICAgICdldGgnOiAnw7AnLFxuICAgICdldW1sJzogJ8OrJyxcbiAgICAnZXVybyc6ICfigqwnLFxuICAgICdmcmFjMTInOiAnwr0nLFxuICAgICdmcmFjMTQnOiAnwrwnLFxuICAgICdmcmFjMzQnOiAnwr4nLFxuICAgICdndCc6ICc+JyxcbiAgICAnaWFjdXRlJzogJ8OtJyxcbiAgICAnaWNpcmMnOiAnw64nLFxuICAgICdpZXhjbCc6ICfCoScsXG4gICAgJ2lncmF2ZSc6ICfDrCcsXG4gICAgJ2lxdWVzdCc6ICfCvycsXG4gICAgJ2l1bWwnOiAnw68nLFxuICAgICdsdCc6ICc8JyxcbiAgICAnbWFjcic6ICfCrycsXG4gICAgJ21pY3JvJzogJ8K1JyxcbiAgICAnbWlkZG90JzogJ8K3JyxcbiAgICAnbmJzcCc6ICcgJyxcbiAgICAnbmJzcCc6ICcnLFxuICAgICdub3QnOiAnwqwnLFxuICAgICdudGlsZGUnOiAnw7EnLFxuICAgICdvYWN1dGUnOiAnw7MnLFxuICAgICdvY2lyYyc6ICfDtCcsXG4gICAgJ29ncmF2ZSc6ICfDsicsXG4gICAgJ29yZGYnOiAnwqonLFxuICAgICdvcmRtJzogJ8K6JyxcbiAgICAnb3NsYXNoJzogJ8O4JyxcbiAgICAnb3RpbGRlJzogJ8O1JyxcbiAgICAnb3VtbCc6ICfDticsXG4gICAgJ3BhcmEnOiAnwrYnLFxuICAgICdwbHVzbW4nOiAnwrEnLFxuICAgICdwb3VuZCc6ICfCoycsXG4gICAgJ3F1b3QnOiAnXCInLFxuICAgICdyYXF1byc6ICfCuycsXG4gICAgJ3JlZyc6ICfCricsXG4gICAgJ3NlY3QnOiAnwqcnLFxuICAgICdzaHknOiAnJyxcbiAgICAnc3VwMSc6ICfCuScsXG4gICAgJ3N1cDInOiAnwrInLFxuICAgICdzdXAzJzogJ8KzJyxcbiAgICAnc3psaWcnOiAnw58nLFxuICAgICd0aG9ybic6ICfDvicsXG4gICAgJ3RpbWVzJzogJ8OXJyxcbiAgICAndWFjdXRlJzogJ8O6JyxcbiAgICAndWNpcmMnOiAnw7snLFxuICAgICd1Z3JhdmUnOiAnw7knLFxuICAgICd1bWwnOiAnwqgnLFxuICAgICd1dW1sJzogJ8O8JyxcbiAgICAneWFjdXRlJzogJ8O9JyxcbiAgICAneWVuJzogJ8KlJyxcbiAgfTtcbiAgdmFyIGVzY2FwZU1hcCA9IHt9O1xuICBmb3IgKCB2YXIga2V5IGluIHVuZXNjYXBlTWFwICkge1xuICAgIGlmICggdW5lc2NhcGVNYXAuaGFzT3duUHJvcGVydHkoa2V5KSApIGVzY2FwZU1hcFt1bmVzY2FwZU1hcFtrZXldXSA9IGtleTtcbiAgfVxuXG4gIC8vIEZVVFVSRTogTGF6aWx5IGluc3RhbnRpYXRlIFJlZ0V4cCB0byBzYXZlIG1lbW9yeS5cbiAgdmFyIHVuZXNjYXBlS2V5cyA9IE9iamVjdC5rZXlzKHVuZXNjYXBlTWFwKS5tYXAoZnVuY3Rpb24oa2V5KSB7XG4gICAgcmV0dXJuIGAmJHtrZXl9O2A7XG4gIH0pO1xuICB2YXIgZXNjYXBlU2VxdWVuY2VSZWdFeHAgPSBSZWdFeHAoYCg/PSgke3VuZXNjYXBlS2V5cy5qb2luKCd8Jyl9KSlcXFxcMWAsICdnJyk7XG4gIHZhciBlc2NhcGVLZXlzID0gT2JqZWN0LmtleXMoZXNjYXBlTWFwKS5tYXAoZnVuY3Rpb24oZXNjYXBlQ2hhcikge1xuICAgIHJldHVybiBgWyR7ZXNjYXBlQ2hhcn1dYDtcbiAgfSk7XG4gIHZhciBlc2NhcGFibGVDaGFyUmVnRXhwID0gUmVnRXhwKGAoPz0oJHtlc2NhcGVLZXlzLmpvaW4oJ3wnKX0pKVxcXFwxYCwgJ2cnKTtcblxuICBmb2FtLkxJQih7XG4gICAgbmFtZTogJ2ZvYW0ucGFyc2Vycy5odG1sJyxcblxuICAgIG1ldGhvZHM6IFtcbiAgICAgIGZ1bmN0aW9uIGdldEh0bWxFc2NhcGVDaGFyKGlkKSB7XG4gICAgICAgIGlmICggISB1bmVzY2FwZU1hcC5oYXNPd25Qcm9wZXJ0eShpZCkgKSByZXR1cm4gJyc7XG4gICAgICAgIHJldHVybiB1bmVzY2FwZU1hcFtpZF07XG4gICAgICB9LFxuICAgICAgZnVuY3Rpb24gZ2V0SHRtbEVzY2FwZVNlcXVlbmNlKGMpIHtcbiAgICAgICAgaWYgKCAhIGVzY2FwZU1hcC5oYXNPd25Qcm9wZXJ0eShjKSApIHJldHVybiAnJztcbiAgICAgICAgcmV0dXJuIGVzY2FwZU1hcFtjXTtcbiAgICAgIH0sXG4gICAgICBmdW5jdGlvbiBpc1NlbGZDbG9zaW5nKG5vZGVOYW1lKSB7XG4gICAgICAgIHJldHVybiBzZWxmQ2xvc2luZ05vZGVOYW1lc1tub2RlTmFtZV07XG4gICAgICB9LFxuICAgICAgZnVuY3Rpb24gdW5lc2NhcGVTdHJpbmcoc3RyKSB7XG4gICAgICAgIGlmICggISBmb2FtLlN0cmluZy5pc0luc3RhbmNlKHN0cikgKSByZXR1cm4gJyc7XG5cbiAgICAgICAgcmV0dXJuIHN0ci5yZXBsYWNlKGVzY2FwZVNlcXVlbmNlUmVnRXhwLCBmdW5jdGlvbihtKSB7XG4gICAgICAgICAgLy8gbSBpcyBpbiB0aGUgZm9ybSBvZiAmaWQ7IFdlIGRyb3AgZmlyc3QgYW5kIGxhc3QgY2hhcmFjdGVyLlxuICAgICAgICAgIHZhciBpZCA9IG0uc2xpY2UoMSwgLTEpO1xuICAgICAgICAgIHJldHVybiB1bmVzY2FwZU1hcFtpZF07XG4gICAgICAgIH0pO1xuICAgICAgfSxcbiAgICAgIGZ1bmN0aW9uIGVzY2FwZVN0cmluZyhzdHIpIHtcbiAgICAgICAgaWYgKCAhIGZvYW0uU3RyaW5nLmlzSW5zdGFuY2Uoc3RyKSApIHJldHVybiAnJztcblxuICAgICAgICByZXR1cm4gc3RyLnJlcGxhY2UoZXNjYXBhYmxlQ2hhclJlZ0V4cCwgZnVuY3Rpb24oaWQpIHtcbiAgICAgICAgICByZXR1cm4gYCYke2VzY2FwZU1hcFtpZF19O2A7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIF1cbiAgfSk7XG59KSgpO1xuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuZm9hbS5DTEFTUyh7XG4gIHBhY2thZ2U6ICdmb2FtLnBhcnNlcnMuaHRtbCcsXG4gIG5hbWU6ICdBdHRyaWJ1dGUnLFxuXG4gIHByb3BlcnRpZXM6IFtcbiAgICB7XG4gICAgICBjbGFzczogJ1N0cmluZycsXG4gICAgICBuYW1lOiAnbmFtZSdcbiAgICB9LFxuICAgIHtcbiAgICAgIGNsYXNzOiAnU3RyaW5nJyxcbiAgICAgIG5hbWU6ICd2YWx1ZSdcbiAgICB9XG4gIF1cbn0pO1xuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuZm9hbS5FTlVNKHtcbiAgcGFja2FnZTogJ2ZvYW0ucGFyc2Vycy5odG1sJyxcbiAgbmFtZTogJ1RhZ1R5cGUnLFxuXG4gIHZhbHVlczogW1xuICAgIHsgbmFtZTogJ09QRU4nLCAgICAgICBsYWJlbDogJ09wZW4nIH0sXG4gICAgeyBuYW1lOiAnQ0xPU0UnLCAgICAgIGxhYmVsOiAnQ2xvc2UnIH0sXG4gICAgeyBuYW1lOiAnT1BFTl9DTE9TRScsIGxhYmVsOiAnT3BlbiAmIENsb3NlJyB9XG4gIF1cbn0pO1xuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuZm9hbS5DTEFTUyh7XG4gIHBhY2thZ2U6ICdmb2FtLnBhcnNlcnMuaHRtbCcsXG4gIG5hbWU6ICdUYWcnLFxuXG4gIHByb3BlcnRpZXM6IFtcbiAgICB7XG4gICAgICBjbGFzczogJ0VudW0nLFxuICAgICAgb2Y6ICdmb2FtLnBhcnNlcnMuaHRtbC5UYWdUeXBlJyxcbiAgICAgIG5hbWU6ICd0eXBlJyxcbiAgICAgIGZhY3Rvcnk6IGZ1bmN0aW9uKCkgeyByZXR1cm4gZm9hbS5wYXJzZXIuaHRtbC5UYWdUeXBlLk9QRU47IH1cbiAgICB9LFxuICAgIHtcbiAgICAgIGNsYXNzOiAnU3RyaW5nJyxcbiAgICAgIG5hbWU6ICdub2RlTmFtZScsXG4gICAgICB2YWx1ZTogJ2RpdidcbiAgICB9LFxuICAgIHtcbiAgICAgIGNsYXNzOiAnRk9iamVjdEFycmF5JyxcbiAgICAgIG9mOiAnZm9hbS5wYXJzZXJzLmh0bWwuQXR0cmlidXRlJyxcbiAgICAgIG5hbWU6ICdhdHRyaWJ1dGVzJyxcbiAgICB9XG4gIF1cbn0pO1xuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuZm9hbS5DTEFTUyh7XG4gIHBhY2thZ2U6ICdmb2FtLnBhcnNlcnMuaHRtbCcsXG4gIG5hbWU6ICdIVE1MTGV4ZXInLFxuXG4gIGRvY3VtZW50YXRpb246IGBQYXJzZSBhbiBIVE1MIHN0cmluZyBpbnRvIGEgZmxhdCBzZXF1ZW5jZSBvZiB0YWdzIGFuZFxuICAgICAgc3RyaW5ncy5gLFxuXG4gIHJlcXVpcmVzOiBbXG4gICAgJ2ZvYW0ucGFyc2UuSW1wZXJhdGl2ZUdyYW1tYXInLFxuICAgICdmb2FtLnBhcnNlLlBhcnNlcnMnLFxuICAgICdmb2FtLnBhcnNlLlN0cmluZ1BTdHJlYW0nLFxuICAgICdmb2FtLnBhcnNlcnMuaHRtbC5BdHRyaWJ1dGUnLFxuICAgICdmb2FtLnBhcnNlcnMuaHRtbC5UYWcnLFxuICAgICdmb2FtLnBhcnNlcnMuaHRtbC5UYWdUeXBlJ1xuICBdLFxuXG4gIGF4aW9tczogW1xuICAgIGZvYW0ucGF0dGVybi5TaW5nbGV0b24uY3JlYXRlKClcbiAgXSxcblxuICBwcm9wZXJ0aWVzOiBbXG4gICAge1xuICAgICAgbmFtZTogJ2xpYicsXG4gICAgICBmYWN0b3J5OiBmdW5jdGlvbigpIHsgcmV0dXJuIGZvYW0ucGFyc2Vycy5odG1sOyB9XG4gICAgfSxcbiAgICB7XG4gICAgICBuYW1lOiAnc3ltYm9sc0ZhY3RvcnknLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uKFxuICAgICAgICAgIHNlcTEsIHN5bSwgc2VxLCByZXBlYXQsIGFsdCwgb3B0aW9uYWwsIHN0ciwgcGx1cywgbm90Q2hhcnMsIHJlcGVhdDAsXG4gICAgICAgICAgbm90LCBhbnlDaGFyLCByYW5nZSwgbGl0ZXJhbElDKSB7XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBTVEFSVDogc2VxMSgxLCBvcHRpb25hbChzeW0oJ2hlYWRlcicpKSwgc3ltKCdodG1sJykpLFxuXG4gICAgICAgICAgaHRtbDogcmVwZWF0KHN5bSgnaHRtbFBhcnQnKSksXG5cbiAgICAgICAgICBodG1sUGFydDogYWx0KFxuICAgICAgICAgICAgICBzeW0oJ2NkYXRhJyksXG4gICAgICAgICAgICAgIHN5bSgnY29tbWVudCcpLFxuICAgICAgICAgICAgICBzeW0oJ2Nsb3NlVGFnJyksXG4gICAgICAgICAgICAgIHN5bSgnb3BlblRhZycpLFxuICAgICAgICAgICAgICBzeW0oJ3RleHQnKSksXG5cbiAgICAgICAgICBvcGVuVGFnOiBzZXEoXG4gICAgICAgICAgICAgICc8JyxcbiAgICAgICAgICAgICAgc3ltKCd0YWdOYW1lJyksXG4gICAgICAgICAgICAgIHN5bSgnd2hpdGVzcGFjZScpLFxuICAgICAgICAgICAgICBzeW0oJ2F0dHJpYnV0ZXMnKSxcbiAgICAgICAgICAgICAgc3ltKCd3aGl0ZXNwYWNlJyksXG4gICAgICAgICAgICAgIG9wdGlvbmFsKCcvJyksXG4gICAgICAgICAgICAgICc+JyksXG5cbiAgICAgICAgICBjbG9zZVRhZzogc2VxMSgxLFxuICAgICAgICAgICAgICAgICAgICAgICAnPC8nLFxuICAgICAgICAgICAgICAgICAgICAgICBzeW0oJ3RhZ05hbWUnKSxcbiAgICAgICAgICAgICAgICAgICAgICAgc3ltKCd3aGl0ZXNwYWNlJyksXG4gICAgICAgICAgICAgICAgICAgICAgICc+JyksXG5cbiAgICAgICAgICBoZWFkZXI6IHNlcShcbiAgICAgICAgICAgIHN5bSgnd2hpdGVzcGFjZScpLFxuICAgICAgICAgICAgb3B0aW9uYWwoc3ltKCdsYW5nVGFnJykpLFxuICAgICAgICAgICAgc3ltKCd3aGl0ZXNwYWNlJyksXG4gICAgICAgICAgICBvcHRpb25hbChzeW0oJ2RvY3R5cGUnKSksXG4gICAgICAgICAgICBzeW0oJ3doaXRlc3BhY2UnKSksXG5cbiAgICAgICAgICBsYW5nVGFnOiBzZXEoJzw/JywgcmVwZWF0MChub3RDaGFycygnPycpKSwgJz8+JyksXG5cbiAgICAgICAgICBkb2N0eXBlOiBzZXEoJzwhJywgbGl0ZXJhbElDKCdET0NUWVBFJyksIHN5bSgnd2hpdGVzcGFjZScpLFxuICAgICAgICAgICAgICAgICAgICAgICByZXBlYXQwKHN5bSgnZG9jdHlwZVBhcnQnKSksICc+JyksXG5cbiAgICAgICAgICBkb2N0eXBlUGFydDogYWx0KHBsdXMobm90Q2hhcnMoJ1s+JywgYW55Q2hhcigpKSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBzZXEoJ1snLCByZXBlYXQwKG5vdENoYXJzKCddJywgYW55Q2hhcigpKSksICddJykpLFxuXG4gICAgICAgICAgY2RhdGE6IHNlcTEoMSxcbiAgICAgICAgICAgICAgICAgICAgICAnPCFbQ0RBVEFbJywgc3RyKHJlcGVhdChub3QoJ11dPicsIGFueUNoYXIoKSkpKSwgJ11dPicpLFxuXG4gICAgICAgICAgY29tbWVudDogc2VxKCc8IS0tJywgcmVwZWF0MChub3QoJy0tPicsIGFueUNoYXIoKSkpLCAnLS0+JyksXG5cbiAgICAgICAgICBhdHRyaWJ1dGVzOiByZXBlYXQoc3ltKCdhdHRyaWJ1dGUnKSwgc3ltKCd3aGl0ZXNwYWNlJykpLFxuXG4gICAgICAgICAgbGFiZWw6IHN0cihwbHVzKG5vdENoYXJzKCcgPS9cXHRcXHJcXG48PicpKSksXG5cbiAgICAgICAgICB0YWdOYW1lOiBzeW0oJ2xhYmVsJyksXG5cbiAgICAgICAgICB0ZXh0OiBzdHIocGx1cyhub3QoYWx0KHN5bSgnY2xvc2VUYWcnKSwgc3ltKCdvcGVuVGFnJykpLFxuICAgICAgICAgICAgICAgICAgYW55Q2hhcigpKSkpLFxuXG4gICAgICAgICAgYXR0cmlidXRlOiBzZXEoc3ltKCdsYWJlbCcpLCBvcHRpb25hbChcbiAgICAgICAgICAgICAgc2VxMSgzLCBzeW0oJ3doaXRlc3BhY2UnKSwgJz0nLCBzeW0oJ3doaXRlc3BhY2UnKSxcbiAgICAgICAgICAgICAgICAgICBzeW0oJ3ZhbHVlJykpKSksXG5cbiAgICAgICAgICB2YWx1ZTogc3RyKGFsdChcbiAgICAgICAgICAgICAgcGx1cyhub3RDaGFycygnXFwnXCIgXFx0XFxyXFxuPD4nKSksXG4gICAgICAgICAgICAgIHNlcTEoMSwgJ1wiJywgcmVwZWF0KG5vdENoYXJzKCdcIicsIGFueUNoYXIoKSkpLCAnXCInKSxcbiAgICAgICAgICAgICAgc2VxMSgxLCBcIidcIiwgcmVwZWF0KG5vdENoYXJzKFwiJ1wiLCBhbnlDaGFyKCkpKSwgXCInXCIpKSksXG5cbiAgICAgICAgICB3aGl0ZXNwYWNlOiByZXBlYXQwKGFsdCgnICcsICdcXHQnLCAnXFxyJywgJ1xcbicpKVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH0sXG4gICAge1xuICAgICAgbmFtZTogJ3N5bWJvbHMnLFxuICAgICAgZmFjdG9yeTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBmb2FtLkZ1bmN0aW9uLndpdGhBcmdzKFxuICAgICAgICAgIHRoaXMuc3ltYm9sc0ZhY3RvcnksXG4gICAgICAgICAgdGhpcy5QYXJzZXJzLmNyZWF0ZSgpLFxuICAgICAgICAgIHRoaXNcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHtcbiAgICAgIG5hbWU6ICdhY3Rpb25zJyxcbiAgICAgIGZhY3Rvcnk6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgc2VsZiAgPSB0aGlzO1xuICAgICAgICB2YXIgbGliICAgPSBzZWxmLmxpYjtcbiAgICAgICAgdmFyIFRhZyAgID0gc2VsZi5UYWc7XG4gICAgICAgIHZhciBBdHRyaWJ1dGUgPSBzZWxmLkF0dHJpYnV0ZTtcbiAgICAgICAgdmFyIE9QRU4gID0gc2VsZi5UYWdUeXBlLk9QRU47XG4gICAgICAgIHZhciBDTE9TRSA9IHNlbGYuVGFnVHlwZS5DTE9TRTtcbiAgICAgICAgdmFyIE9QRU5fQ0xPU0UgPSBzZWxmLlRhZ1R5cGUuT1BFTl9DTE9TRTtcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIG9wZW5UYWc6IGZ1bmN0aW9uKHYpIHtcbiAgICAgICAgICAgIHJldHVybiBUYWcuY3JlYXRlKHtcbiAgICAgICAgICAgICAgdHlwZTogdls1XSB8fCBsaWIuaXNTZWxmQ2xvc2luZyh2WzFdKSA/IE9QRU5fQ0xPU0UgOiBPUEVOLFxuICAgICAgICAgICAgICBub2RlTmFtZTogdlsxXSxcbiAgICAgICAgICAgICAgYXR0cmlidXRlczogdlszXSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0sXG5cbiAgICAgICAgICBjbG9zZVRhZzogZnVuY3Rpb24odikge1xuICAgICAgICAgICAgcmV0dXJuIFRhZy5jcmVhdGUoeyB0eXBlOiBDTE9TRSwgbm9kZU5hbWU6IHYgfSk7XG4gICAgICAgICAgfSxcblxuICAgICAgICAgIC8vIFRPRE8obWFya2RpdHRtZXIpOiBEbyBzb21ldGhpbmcgd2l0aCB0aGVzZSB2YWx1ZXMuXG4gICAgICAgICAgaGVhZGVyOiBmdW5jdGlvbih2KSB7IHJldHVybiBudWxsOyB9LFxuICAgICAgICAgIGxhbmdUYWc6IGZ1bmN0aW9uKHYpIHsgcmV0dXJuIG51bGw7IH0sXG4gICAgICAgICAgZG9jdHlwZTogZnVuY3Rpb24odikgeyByZXR1cm4gbnVsbDsgfSxcbiAgICAgICAgICBkb2N0eXBlUGFydDogZnVuY3Rpb24odikgeyByZXR1cm4gbnVsbDsgfSxcbiAgICAgICAgICBjZGF0YTogZnVuY3Rpb24odikgeyByZXR1cm4gbnVsbDsgfSxcbiAgICAgICAgICBjb21tZW50OiBmdW5jdGlvbih2KSB7IHJldHVybiBudWxsOyB9LFxuICAgICAgICAgIGF0dHJpYnV0ZTogZnVuY3Rpb24odikge1xuICAgICAgICAgICAgcmV0dXJuIEF0dHJpYnV0ZS5jcmVhdGUoeyBuYW1lOiB2WzBdLCB2YWx1ZTogdlsxXSB8fCBudWxsIH0pO1xuICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfSxcbiAgICB7XG4gICAgICBuYW1lOiAnZ3JhbW1hcicsXG4gICAgICBmYWN0b3J5OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGdyYW1tYXIgPSB0aGlzLkltcGVyYXRpdmVHcmFtbWFyLmNyZWF0ZSh7c3ltYm9sczogdGhpcy5zeW1ib2xzfSk7XG4gICAgICAgIGdyYW1tYXIuYWRkQWN0aW9ucyh0aGlzLmFjdGlvbnMpO1xuICAgICAgICByZXR1cm4gZ3JhbW1hcjtcbiAgICAgIH1cbiAgICB9LFxuICAgIHtcbiAgICAgIG5hbWU6ICdwcycsXG4gICAgICBmYWN0b3J5OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuU3RyaW5nUFN0cmVhbS5jcmVhdGUoKTtcbiAgICAgIH1cbiAgICB9XG4gIF0sXG5cbiAgbWV0aG9kczogW1xuICAgIGZ1bmN0aW9uIHBhcnNlU3RyaW5nKHN0ciwgb3B0X25hbWUpIHtcbiAgICAgIG9wdF9uYW1lID0gb3B0X25hbWUgfHwgJ1NUQVJUJztcblxuICAgICAgdGhpcy5wcy5zZXRTdHJpbmcoc3RyKTtcbiAgICAgIHZhciBzdGFydCA9IHRoaXMuZ3JhbW1hci5nZXRTeW1ib2wob3B0X25hbWUpO1xuICAgICAgZm9hbS5hc3NlcnQoc3RhcnQsICdObyBzeW1ib2wgZm91bmQgZm9yJywgb3B0X25hbWUpO1xuXG4gICAgICByZXR1cm4gc3RhcnQucGFyc2UodGhpcy5wcywgdGhpcy5ncmFtbWFyKTtcbiAgICB9XG4gIF1cbn0pO1xuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgVGhlIEZPQU0gQXV0aG9ycy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICovXG5cbmZvYW0uQ0xBU1Moe1xuICBwYWNrYWdlOiAnZm9hbS5kYW8uaGlzdG9yeScsXG4gIG5hbWU6ICdQcm9wZXJ0eVVwZGF0ZScsXG4gIGRvY3VtZW50YXRpb246IGBNb2RlbCBjb250YWluaW5nIHRoZSBuYW1lIG9mIHRoZSBwcm9wZXJ0eVxuICAgIGJlaW5nIHVwZGF0ZWQsIHRoZSBvbGQgdmFsdWUsIGFuZCB0aGUgbmV3IHZhbHVlYCxcbiAgcHJvcGVydGllczogW1xuICAgIHtcbiAgICAgIGNsYXNzOiAnU3RyaW5nJyxcbiAgICAgIG5hbWU6ICduYW1lJ1xuICAgIH0sXG4gICAge1xuICAgICAgY2xhc3M6ICdPYmplY3QnLFxuICAgICAgbmFtZTogJ29sZFZhbHVlJ1xuICAgIH0sXG4gICAge1xuICAgICAgY2xhc3M6ICdPYmplY3QnLFxuICAgICAgbmFtZTogJ25ld1ZhbHVlJ1xuICAgIH1cbiAgXVxufSk7XG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBUaGUgRk9BTSBBdXRob3JzLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKi9cblxuZm9hbS5DTEFTUyh7XG4gIHBhY2thZ2U6ICdmb2FtLmRhby5oaXN0b3J5JyxcbiAgbmFtZTogJ0hpc3RvcnlSZWNvcmQnLFxuXG4gIGRvY3VtZW50YXRpb246ICdDb250YWlucyBhbiBhcnJheSBvZiBwcm9wZXJ0eSB1cGRhdGVzJyxcbiAgaWRzOiBbICdvYmplY3RJZCcsICdzZXFObycgXSxcbiAgXG4gIHByb3BlcnRpZXM6IFtcbiAgICB7XG4gICAgICBjbGFzczogJ0xvbmcnLFxuICAgICAgbmFtZTogJ3NlcU5vJ1xuICAgIH0sXG4gICAge1xuICAgICAgY2xhc3M6ICdPYmplY3QnLFxuICAgICAgbmFtZTogJ29iamVjdElkJ1xuICAgIH0sXG4gICAge1xuICAgICAgY2xhc3M6ICdTdHJpbmcnLFxuICAgICAgbmFtZTogJ3VzZXInXG4gICAgfSxcbiAgICB7XG4gICAgICBjbGFzczogJ0RhdGVUaW1lJyxcbiAgICAgIG5hbWU6ICd0aW1lc3RhbXAnXG4gICAgfSxcbiAgICB7XG4gICAgICBjbGFzczogJ0ZPYmplY3RBcnJheScsXG4gICAgICBvZjogJ2ZvYW0uZGFvLmhpc3RvcnkuUHJvcGVydHlVcGRhdGUnLFxuICAgICAgbmFtZTogJ3VwZGF0ZXMnXG4gICAgfVxuICBdXG59KTtcbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IFRoZSBGT0FNIEF1dGhvcnMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqL1xuXG5mb2FtLklOVEVSRkFDRSh7XG4gIHBhY2thZ2U6ICdmb2FtLm1vcCcsXG4gIG5hbWU6ICdNT1AnLFxuXG4gIGRvY3VtZW50YXRpb246ICdNT1AgSW50ZXJmYWNlJyxcblxuICBtZXRob2RzOiBbXG4gICAge1xuICAgICAgbmFtZTogJ2dldCcsXG4gICAgICByZXR1cm5zOiAnUHJvbWlzZScsXG4gICAgICBhcmdzOiBbICd4JyBdXG4gICAgfSxcbiAgICB7XG4gICAgICBuYW1lOiAnc2V0UHJvcGVydHknLFxuICAgICAgcmV0dXJuczogJ1Byb21pc2UnLFxuICAgICAgYXJnczogWyAneCcsICduYW1lJywgJ3ZhbHVlJyBdXG4gICAgfSxcbiAgICB7XG4gICAgICBuYW1lOiAnc2V0UHJvcGVydGllcycsXG4gICAgICByZXR1cm5zOiAnUHJvbWlzZScsXG4gICAgICBhcmdzOiBbICd4JywgJ3ZhbHVlcycgXVxuICAgIH1cbiAgXVxufSk7XG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBUaGUgRk9BTSBBdXRob3JzLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKi9cblxuZm9hbS5DTEFTUyh7XG4gIHBhY2thZ2U6ICdmb2FtLmRhby5wZycsXG4gIG5hbWU6ICdDb25uZWN0aW9uUG9vbCcsXG5cbiAgZG9jdW1lbnRhdGlvbjogJ1JlcHJlc2VudHMgYSBkYXRhYmFzZSBjb25uZWN0aW9uIHBvb2wnLFxuXG4gIGltcGxlbWVudHM6IFsgJ2ZvYW0ubmFub3MuTmFub1NlcnZpY2UnIF0sXG5cbiAgamF2YUltcG9ydHM6IFsgJ29yZy5hcGFjaGUuY29tbW9ucy5kYmNwMi5CYXNpY0RhdGFTb3VyY2UnIF0sXG5cbiAgcHJvcGVydGllczogW1xuICAgIHtcbiAgICAgIGNsYXNzOiAnT2JqZWN0JyxcbiAgICAgIG5hbWU6ICdwb29sJyxcbiAgICAgIGphdmFUeXBlOiAnQmFzaWNEYXRhU291cmNlJyxcbiAgICAgIGRvY3VtZW50YXRpb246ICdDb25uZWN0aW9uIHBvb2wnLFxuICAgIH0sXG4gICAge1xuICAgICAgY2xhc3M6ICdJbnQnLFxuICAgICAgbmFtZTogJ3Bvb2xTaXplJyxcbiAgICAgIHZhbHVlOiAyMCxcbiAgICAgIGRvY3VtZW50YXRpb246ICdDb25uZWN0aW9uIHBvb2wgc2l6ZSdcbiAgICB9LFxuICAgIHtcbiAgICAgIGNsYXNzOiAnU3RyaW5nJyxcbiAgICAgIG5hbWU6ICdkcml2ZXInLFxuICAgICAgZG9jdW1lbnRhdGlvbjogJ0RhdGFiYXNlIGRyaXZlcidcbiAgICB9LFxuICAgIHtcbiAgICAgIGNsYXNzOiAnU3RyaW5nJyxcbiAgICAgIG5hbWU6ICdwcmVmaXgnLFxuICAgICAgZG9jdW1lbnRhdGlvbjogJ0RhdGFiYXNlIGNvbm5lY3Rpb24gc3RyaW5nIHByZWZpeC4gaS5lLiBqZGJjOnBvc3RncmVzcTovLydcbiAgICB9LFxuICAgIHtcbiAgICAgIGNsYXNzOiAnU3RyaW5nJyxcbiAgICAgIG5hbWU6ICdob3N0bmFtZScsXG4gICAgICBkb2N1bWVudGF0aW9uOiAnRGF0YWJhc2UgaG9zdG5hbWUnXG4gICAgfSxcbiAgICB7XG4gICAgICBjbGFzczogJ1N0cmluZycsXG4gICAgICBuYW1lOiAncG9ydCcsXG4gICAgICBkb2N1bWVudGF0aW9uOiAnRGF0YWJhc2UgcG9ydCdcbiAgICB9LFxuICAgIHtcbiAgICAgIGNsYXNzOiAnU3RyaW5nJyxcbiAgICAgIG5hbWU6ICdkYXRhYmFzZScsXG4gICAgICBkb2N1bWVudGF0aW9uOiAnRGF0YWJhc2UgbmFtZSdcbiAgICB9LFxuICAgIHtcbiAgICAgIGNsYXNzOiAnU3RyaW5nJyxcbiAgICAgIG5hbWU6ICd1c2VybmFtZScsXG4gICAgICBkb2N1bWVudGF0aW9uOiAnRGF0YWJhc2UgdXNlcm5hbWUgZm9yIGF1dGhlbnRpY2F0aW9uJ1xuICAgIH0sXG4gICAge1xuICAgICAgY2xhc3M6ICdTdHJpbmcnLFxuICAgICAgbmFtZTogJ3Bhc3N3b3JkJyxcbiAgICAgIGRvY3VtZW50YXRpb246ICdEYXRhYmFzZSBwYXNzd29yZCBmb3IgYXV0aGVudGljYXRpb24nXG4gICAgfSxcbiAgICB7XG4gICAgICBjbGFzczogJ1N0cmluZycsXG4gICAgICBuYW1lOiAnY29ubmVjdGlvblN0cmluZycsXG4gICAgICB0cmFuc2llbnQ6IHRydWUsXG4gICAgICBqYXZhRmFjdG9yeTogYHJldHVybiBnZXRQcmVmaXgoKSArXG4gICAgICAgIGdldEhvc3RuYW1lKCkgKyBcIjpcIiArXG4gICAgICAgIGdldFBvcnQoKSArIFwiL1wiICtcbiAgICAgICAgZ2V0RGF0YWJhc2UoKTtgXG4gICAgfVxuICBdLFxuXG4gIG1ldGhvZHM6IFtcbiAgICB7XG4gICAgICBuYW1lOiAnc3RhcnQnLFxuICAgICAgamF2YVJldHVybnM6ICd2b2lkJyxcbiAgICAgIGphdmFDb2RlOiBgdHJ5IHtcbiAgQmFzaWNEYXRhU291cmNlIHBvb2wgPSBuZXcgQmFzaWNEYXRhU291cmNlKCk7XG4gIHBvb2wuc2V0VXNlcm5hbWUoZ2V0VXNlcm5hbWUoKSk7XG4gIHBvb2wuc2V0RHJpdmVyQ2xhc3NOYW1lKGdldERyaXZlcigpKTtcbiAgcG9vbC5zZXRVcmwoZ2V0Q29ubmVjdGlvblN0cmluZygpKTtcbiAgcG9vbC5zZXRJbml0aWFsU2l6ZShnZXRQb29sU2l6ZSgpKTtcbiAgc2V0UG9vbChwb29sKTtcbn0gY2F0Y2ggKEV4Y2VwdGlvbiBlKSB7XG4gIGUucHJpbnRTdGFja1RyYWNlKCk7XG59YFxuICAgIH0sXG4gICAge1xuICAgICAgbmFtZTogJ2dldENvbm5lY3Rpb24nLFxuICAgICAgamF2YVJldHVybnM6ICdqYXZhLnNxbC5Db25uZWN0aW9uJyxcbiAgICAgIGphdmFUaHJvd3M6IFsnamF2YS5zcWwuU1FMRXhjZXB0aW9uJ10sXG4gICAgICBqYXZhQ29kZTogJ3JldHVybiBnZXRQb29sKCkuZ2V0Q29ubmVjdGlvbigpOydcbiAgICB9XG4gIF1cbn0pOy8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IFRoZSBGT0FNIEF1dGhvcnMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqL1xuXG5mb2FtLkVOVU0oe1xuICBwYWNrYWdlOiAnZm9hbS5saWIuanNvbicsXG4gIG5hbWU6ICdPdXRwdXR0ZXJNb2RlJyxcblxuICBkb2N1bWVudGF0aW9uOiAnRGVmaW5lcyB0aGUgbW9kZSBmb3IgSlNPTiBPdXRwdXR0ZXInLFxuXG4gIHZhbHVlczogW1xuICAgIHtcbiAgICAgIG5hbWU6ICdORVRXT1JLJyxcbiAgICAgIGxhYmVsOiAnTmV0d29yaydcbiAgICB9LFxuICAgIHtcbiAgICAgIG5hbWU6ICdTVE9SQUdFJyxcbiAgICAgIGxhYmVsOiAnU3RvcmFnZSdcbiAgICB9LFxuICAgIHtcbiAgICAgIG5hbWU6ICdGVUxMJyxcbiAgICAgIGxhYmVsOiAnRnVsbCdcbiAgICB9XG4gIF1cbn0pOy8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IFRoZSBGT0FNIEF1dGhvcnMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqL1xuXG5mb2FtLklOVEVSRkFDRSh7XG4gIHBhY2thZ2U6ICdmb2FtLmxpYi5wYXJzZScsXG4gIG5hbWU6ICdQYXJzZXInLFxuXG4gIGRvY3VtZW50YXRpb246ICdQYXJzZXIgaW50ZXJmYWNlJyxcblxuICBtZXRob2RzOiBbXG4gICAge1xuICAgICAgbmFtZTogJ3BhcnNlJyxcbiAgICAgIGphdmFSZXR1cm5zOiAnZm9hbS5saWIucGFyc2UuUFN0cmVhbScsXG4gICAgICBhcmdzOiBbXG4gICAgICAgIHtcbiAgICAgICAgICBuYW1lOiAncHMnLFxuICAgICAgICAgIGphdmFUeXBlOiAnZm9hbS5saWIucGFyc2UuUFN0cmVhbSdcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIG5hbWU6ICd4JyxcbiAgICAgICAgICBqYXZhVHlwZTogJ2ZvYW0ubGliLnBhcnNlLlBhcnNlckNvbnRleHQnXG4gICAgICAgIH1cbiAgICAgIF1cbiAgICB9XG4gIF1cbn0pOy8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IFRoZSBGT0FNIEF1dGhvcnMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqL1xuXG5mb2FtLklOVEVSRkFDRSh7XG4gIHBhY2thZ2U6ICdmb2FtLmxpYi5wYXJzZScsXG4gIG5hbWU6ICdQU3RyZWFtJyxcblxuICBkb2N1bWVudGF0aW9uOiAnUFN0cmVhbSBpbnRlcmZhY2UnLFxuXG4gIG1ldGhvZHM6IFtcbiAgICB7XG4gICAgICBuYW1lOiAnaGVhZCcsXG4gICAgICBqYXZhUmV0dXJuczogJ2NoYXInLFxuICAgIH0sXG4gICAge1xuICAgICAgbmFtZTogJ3ZhbGlkJyxcbiAgICAgIGphdmFSZXR1cm5zOiAnYm9vbGVhbidcbiAgICB9LFxuICAgIHtcbiAgICAgIG5hbWU6ICd0YWlsJyxcbiAgICAgIGphdmFSZXR1cm5zOiAnZm9hbS5saWIucGFyc2UuUFN0cmVhbSdcbiAgICB9LFxuICAgIHtcbiAgICAgIG5hbWU6ICd2YWx1ZScsXG4gICAgICBqYXZhUmV0dXJuczogJ09iamVjdCdcbiAgICB9LFxuICAgIHtcbiAgICAgIG5hbWU6ICdzZXRWYWx1ZScsXG4gICAgICBqYXZhUmV0dXJuczogJ2ZvYW0ubGliLnBhcnNlLlBTdHJlYW0nLFxuICAgICAgYXJnczogW1xuICAgICAgICB7XG4gICAgICAgICAgbmFtZTogJ3ZhbHVlJyxcbiAgICAgICAgICBqYXZhVHlwZTogJ09iamVjdCdcbiAgICAgICAgfVxuICAgICAgXVxuICAgIH0sXG4gICAge1xuICAgICAgbmFtZTogJ3N1YnN0cmluZycsXG4gICAgICBqYXZhUmV0dXJuczogJ1N0cmluZycsXG4gICAgICBhcmdzOiBbXG4gICAgICAgIHtcbiAgICAgICAgICBuYW1lOiAnZW5kJyxcbiAgICAgICAgICBqYXZhVHlwZTogJ2ZvYW0ubGliLnBhcnNlLlBTdHJlYW0nXG4gICAgICAgIH1cbiAgICAgIF1cbiAgICB9LFxuICAgIHtcbiAgICAgIG5hbWU6ICdhcHBseScsXG4gICAgICBqYXZhUmV0dXJuczogJ2ZvYW0ubGliLnBhcnNlLlBTdHJlYW0nLFxuICAgICAgYXJnczogW1xuICAgICAgICB7XG4gICAgICAgICAgbmFtZTogJ3BzJyxcbiAgICAgICAgICBqYXZhVHlwZTogJ2ZvYW0ubGliLnBhcnNlLlBhcnNlcidcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIG5hbWU6ICd4JyxcbiAgICAgICAgICBqYXZhVHlwZTogJ2ZvYW0ubGliLnBhcnNlLlBhcnNlckNvbnRleHQnXG4gICAgICAgIH1cbiAgICAgIF1cbiAgICB9XG4gIF1cbn0pOy8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE4IFRoZSBGT0FNIEF1dGhvcnMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqL1xuXG5mb2FtLklOVEVSRkFDRSh7XG4gIHBhY2thZ2U6ICdmb2FtLmNyeXB0by5oYXNoJyxcbiAgbmFtZTogJ0hhc2hlcicsXG5cbiAgZG9jdW1lbnRhdGlvbjogJ0hhc2hlciBpbnRlcmZhY2UnLFxuXG4gIG1ldGhvZHM6IFtcbiAgICB7XG4gICAgICBuYW1lOiAndXBkYXRlRGlnZXN0JyxcbiAgICAgIGFyZ3M6IFtcbiAgICAgICAge1xuICAgICAgICAgIG5hbWU6ICdvYmonLFxuICAgICAgICAgIGphdmFUeXBlOiAnZm9hbS5jb3JlLkZPYmplY3QnXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICBuYW1lOiAnbWQnLFxuICAgICAgICAgIGphdmFUeXBlOiAnamF2YS5zZWN1cml0eS5NZXNzYWdlRGlnZXN0J1xuICAgICAgICB9XG4gICAgICBdXG4gICAgfVxuICBdXG59KTsvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxOCBUaGUgRk9BTSBBdXRob3JzLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKi9cblxuZm9hbS5JTlRFUkZBQ0Uoe1xuICBwYWNrYWdlOiAnZm9hbS5jcnlwdG8uaGFzaCcsXG4gIG5hbWU6ICdIYXNoYWJsZScsXG5cbiAgZG9jdW1lbnRhdGlvbjogJ0hhc2hhYmxlIGludGVyZmFjZScsXG5cbiAgbWV0aG9kczogW1xuICAgIHtcbiAgICAgIG5hbWU6ICdoYXNoJyxcbiAgICAgIGphdmFSZXR1cm5zOiAnYnl0ZVtdJyxcbiAgICAgIGFyZ3M6IFtcbiAgICAgICAge1xuICAgICAgICAgIG5hbWU6ICdhbGdvcml0aG0nLFxuICAgICAgICAgIGphdmFUeXBlOiAnU3RyaW5nJyxcbiAgICAgICAgICBkb2N1bWVudGF0aW9uOiAnSGFzaGluZyBhbGdvcml0aG0gdG8gdXNlJ1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgbmFtZTogJ2hhc2gnLFxuICAgICAgICAgIGphdmFUeXBlOiAnYnl0ZVtdJyxcbiAgICAgICAgICBkb2N1bWVudGF0aW9uOiAnUHJldmlvdXMgaGFzaCAodXNlZCBmb3IgY2hhaW5pbmcpJ1xuICAgICAgICB9XG4gICAgICBdXG4gICAgfVxuICBdXG59KTsvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxOCBUaGUgRk9BTSBBdXRob3JzLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKi9cblxuZm9hbS5JTlRFUkZBQ0Uoe1xuICBwYWNrYWdlOiAnZm9hbS5jcnlwdG8uc2lnbicsXG4gIG5hbWU6ICdTaWduZXInLFxuXG4gIGRvY3VtZW50YXRpb246ICdTaWduZXIgaW50ZXJmYWNlJyxcblxuICBtZXRob2RzOiBbXG4gICAge1xuICAgICAgbmFtZTogJ3VwZGF0ZVNpZ25hdHVyZScsXG4gICAgICBqYXZhVGhyb3dzOiBbXG4gICAgICAgICdqYXZhLnNlY3VyaXR5LlNpZ25hdHVyZUV4Y2VwdGlvbidcbiAgICAgIF0sXG4gICAgICBhcmdzOiBbXG4gICAgICAgIHtcbiAgICAgICAgICBuYW1lOiAnb2JqJyxcbiAgICAgICAgICBqYXZhVHlwZTogJ2ZvYW0uY29yZS5GT2JqZWN0J1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgbmFtZTogJ3NpZycsXG4gICAgICAgICAgamF2YVR5cGU6ICdqYXZhLnNlY3VyaXR5LlNpZ25hdHVyZSdcbiAgICAgICAgfVxuICAgICAgXVxuICAgIH1cbiAgXVxufSk7XG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxOCBUaGUgRk9BTSBBdXRob3JzLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKi9cblxuZm9hbS5JTlRFUkZBQ0Uoe1xuICBwYWNrYWdlOiAnZm9hbS5jcnlwdG8uc2lnbicsXG4gIG5hbWU6ICdTaWduYWJsZScsXG5cbiAgZG9jdW1lbnRhdGlvbjogJ1NpZ25lciBpbnRlcmZhY2UnLFxuXG4gIG1ldGhvZHM6IFtcbiAgICB7XG4gICAgICBuYW1lOiAnc2lnbicsXG4gICAgICBqYXZhUmV0dXJuczogJ2J5dGVbXScsXG4gICAgICBhcmdzOiBbXG4gICAgICAgIHtcbiAgICAgICAgICBuYW1lOiAnYWxnb3JpdGhtJyxcbiAgICAgICAgICBqYXZhVHlwZTogJ1N0cmluZycsXG4gICAgICAgICAgZG9jdW1lbnRhdGlvbjogJ1NpZ25pbmcgYWxnb3JpdGhtJ1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgbmFtZTogJ2tleScsXG4gICAgICAgICAgamF2YVR5cGU6ICdqYXZhLnNlY3VyaXR5LlByaXZhdGVLZXknLFxuICAgICAgICAgIGRvY3VtZW50YXRpb246ICdQcml2YXRlIGtleSB0byB1c2UgZm9yIHNpZ25pbmcnXG4gICAgICAgIH1cbiAgICAgIF1cbiAgICB9LFxuICAgIHtcbiAgICAgIG5hbWU6ICd2ZXJpZnknLFxuICAgICAgamF2YVJldHVybnM6ICdib29sZWFuJyxcbiAgICAgIGFyZ3M6IFtcbiAgICAgICAge1xuICAgICAgICAgIG5hbWU6ICdzaWduYXR1cmUnLFxuICAgICAgICAgIGphdmFUeXBlOiAnYnl0ZVtdJyxcbiAgICAgICAgICBkb2N1bWVudGF0aW9uOiAnU2lnbmF0dXJlIHRvIHZlcmlmeSdcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIG5hbWU6ICdhbGdvcml0aG0nLFxuICAgICAgICAgIGphdmFUeXBlOiAnU3RyaW5nJyxcbiAgICAgICAgICBkb2N1bWVudGF0aW9uOiAnU2lnbmluZyBhbGdvcml0aG0nXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICBuYW1lOiAna2V5JyxcbiAgICAgICAgICBqYXZhVHlwZTogJ2phdmEuc2VjdXJpdHkuUHVibGljS2V5JyxcbiAgICAgICAgICBkb2N1bWVudGF0aW9uOiAnUHVibGljIGtleSB0byB1c2UgZm9yIHZlcmlmeWluZydcbiAgICAgICAgfVxuICAgICAgXVxuICAgIH1cbiAgXVxufSk7XG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxOCBUaGUgRk9BTSBBdXRob3JzLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKi9cblxuZm9hbS5DTEFTUyh7XG4gIHBhY2thZ2U6ICdmb2FtLmNyeXB0by5zaWduJyxcbiAgbmFtZTogJ1NpZ25lZEZPYmplY3QnLFxuXG4gIGRvY3VtZW50YXRpb246ICdSZXByZXNlbnRzIGFuIEZPYmplY3Qgd2l0aCBpdFxcJ3Mgc2lnbmF0dXJlJyxcblxuICBwcm9wZXJ0aWVzOiBbXG4gICAge1xuICAgICAgY2xhc3M6ICdGT2JqZWN0UHJvcGVydHknLFxuICAgICAgbmFtZTogJ2RhdGEnLFxuICAgICAgZG9jdW1lbnRhdGlvbjogJ09yaWdpbmFsIG9iamVjdCdcbiAgICB9LFxuICAgIHtcbiAgICAgIGNsYXNzOiAnU3RyaW5nJyxcbiAgICAgIG5hbWU6ICdzaWduYXR1cmUnLFxuICAgICAgZG9jdW1lbnRhdGlvbjogJ1NpZ25hdHVyZSBvZiBvYmplY3QnXG4gICAgfVxuICBdXG59KTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vLmxvY2FsL2ZvYW0tYmluLmpzXG4vLyBtb2R1bGUgaWQgPSAzOTVcbi8vIG1vZHVsZSBjaHVua3MgPSAzIiwiLyogKGlnbm9yZWQpICovXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gYnVmZmVyIChpZ25vcmVkKVxuLy8gbW9kdWxlIGlkID0gODc4XG4vLyBtb2R1bGUgY2h1bmtzID0gMyIsIi8qIChpZ25vcmVkKSAqL1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIGNyeXB0byAoaWdub3JlZClcbi8vIG1vZHVsZSBpZCA9IDg3OVxuLy8gbW9kdWxlIGNodW5rcyA9IDMiLCIvKiAoaWdub3JlZCkgKi9cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyB1dGlsIChpZ25vcmVkKVxuLy8gbW9kdWxlIGlkID0gODgwXG4vLyBtb2R1bGUgY2h1bmtzID0gMyIsIi8qIChpZ25vcmVkKSAqL1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIHV0aWwgKGlnbm9yZWQpXG4vLyBtb2R1bGUgaWQgPSA4ODFcbi8vIG1vZHVsZSBjaHVua3MgPSAzIl0sInNvdXJjZVJvb3QiOiIifQ==